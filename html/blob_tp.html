<table border="1">
  <tr>
    <th align="center">id</th>
    <th align="center">chat_gpt_response</th>
    <th align="center">question</th>
    <th align="center">badsmell_base</th>
    <th align="center">bad_smell_gpt</th>
    <th align="center">found_any</th>
    <th align="center">valid_bad_smell</th>
    <th align="center">bad_smell_in_base</th>
    <th align="center">bad_smell_not_in_the_base</th>
    <th align="center">bad_smell_not_found</th>
    <th align="center">index</th>
    <th align="center">index_base</th>
    <th align="center">url_github</th>
    <th align="center">nr_question</th>
    <th align="center">id_source_code</th>
    <th align="center">id_base</th>
  </tr>
  <tr valign="top">
    <td align="right">95</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells\nthe bad smells are: Blob, Long Method, Data Class&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class QueryItemTreeControl extends Composite {     public static interface QueryItemDoubleClickedListener {         public void queryItemDoubleClicked(QueryItem queryItem);     }      public static interface QueryItemSelectionListener {         public void queryItemSelected(QueryItem queryItem);     }      /*      * a reference to all the projects on the server      */     private final Project[] projects;      /*      * a sorted array of the names of the currently &quot;active&quot; projects, where      * active means the user has added the project to team explorer      */     private final String[] activeProjectNames;      /*      * the tree viewer this composite is based around      */     private TreeViewer treeViewer;      /*      * used to track the currently selected query in the tree      */     private QueryItem selectedQueryItem;      private final QueryItemType itemTypes;      /*      * listener set      */     private final Set queryDoubleClickListeners =         new HashSet();     private final Set querySelectionListeners = new HashSet();      public QueryItemTreeControl(         final Composite parent,         final int style,         final TFSServer server,         final Project[] projects,         final QueryItem initialQueryItem,         final QueryItemType itemTypes) {         this(             parent,             style,             projects,             ProjectInfoHelper.getProjectNames(server.getProjectCache().getActiveTeamProjects()),             initialQueryItem,             itemTypes);     }      public QueryItemTreeControl(         final Composite parent,         final int style,         final Project[] projects,         final String[] activeProjects,         final QueryItem initialQueryItem,         final QueryItemType itemTypes) {         super(parent, style);         this.projects = projects;         selectedQueryItem = initialQueryItem;         this.itemTypes = itemTypes;          activeProjectNames = activeProjects;         Arrays.sort(activeProjectNames);          if (activeProjectNames.length &gt; 0) {             /*              * set up the tree control in this composite              */             createUI();         } else {             createNoProjectsUI();         }     }      public QueryItem getSelectedQueryItem() {         return selectedQueryItem;     }      public void addQueryItemDoubleClickedListener(final QueryItemDoubleClickedListener listener) {         synchronized (queryDoubleClickListeners) {             queryDoubleClickListeners.add(listener);         }     }      public void removeQueryItemDoubleClickedListener(final QueryItemDoubleClickedListener listener) {         synchronized (queryDoubleClickListeners) {             queryDoubleClickListeners.remove(listener);         }     }      public void addQueryItemSelectionListener(final QueryItemSelectionListener listener) {         synchronized (querySelectionListeners) {             querySelectionListeners.add(listener);         }     }      public void removeQueryItemSelectionListener(final QueryItemSelectionListener listener) {         synchronized (querySelectionListeners) {             querySelectionListeners.remove(listener);         }     }      private void createUI() {         setLayout(new FillLayout());          treeViewer = new TreeViewer(this, SWT.BORDER);         treeViewer.setContentProvider(new ContentProvider(activeProjectNames));         treeViewer.setLabelProvider(new LabelProvider());         treeViewer.addDoubleClickListener(new DoubleClickListener(treeViewer, queryDoubleClickListeners));         treeViewer.addSelectionChangedListener(new SelectionChangedListener(querySelectionListeners));          addContextMenu();          treeViewer.setInput(projects);          /*          * set the initial selection if applicable          */         if (selectedQueryItem != null) {             treeViewer.setSelection(new StructuredSelection(selectedQueryItem), true);         }     }      private void createNoProjectsUI() {         setLayout(new FillLayout());          final Label label = new Label(this, SWT.WRAP);         label.setText(Messages.getString(&quot;QueryItemTreeControl.NoTeamProjectsLabelText&quot;)); //$NON-NLS-1$     }      private void addContextMenu() {         final MenuManager menuMgr = new MenuManager(&quot;#PopUp&quot;); //$NON-NLS-1$         final IAction copyToClipboardAction = new Action() {             @Override             public void run() {                 final IStructuredSelection selection = (IStructuredSelection) treeViewer.getSelection();                 final QueryDefinition queryDefinition = (QueryDefinition) selection.getFirstElement();                 UIHelpers.copyToClipboard(queryDefinition.getQueryText());             }         };         copyToClipboardAction.setText(Messages.getString(&quot;QueryItemTreeControl.CopyWiqlToClipboard&quot;)); //$NON-NLS-1$         copyToClipboardAction.setEnabled(false);         menuMgr.add(copyToClipboardAction);          treeViewer.getControl().setMenu(menuMgr.createContextMenu(treeViewer.getControl()));          treeViewer.addSelectionChangedListener(new ISelectionChangedListener() {             @Override             public void selectionChanged(final SelectionChangedEvent event) {                 final IStructuredSelection selection = (IStructuredSelection) event.getSelection();                 final boolean enable = (selection.getFirstElement() instanceof QueryDefinition);                 copyToClipboardAction.setEnabled(enable);             }         });     }      private class SelectionChangedListener implements ISelectionChangedListener {         private final Set listeners;          public SelectionChangedListener(final Set listeners) {             this.listeners = listeners;         }          @Override         public void selectionChanged(final SelectionChangedEvent event) {             final Object selected = ((IStructuredSelection) event.getSelection()).getFirstElement();             if (selected instanceof QueryItem &amp;&amp; itemTypes.contains(((QueryItem) selected).getType())) {                 selectedQueryItem = (QueryItem) selected;             } else {                 selectedQueryItem = null;             }              synchronized (listeners) {                 for (final QueryItemSelectionListener listener : listeners) {                     listener.queryItemSelected(selectedQueryItem);                 }             }         }     }      private static class DoubleClickListener extends TreeViewerDoubleClickListener {         private final Set listeners;          public DoubleClickListener(final TreeViewer treeViewer, final Set listeners) {             super(treeViewer);             this.listeners = listeners;         }          @Override         public void doubleClick(final DoubleClickEvent event) {             super.doubleClick(event);              final Object element = ((IStructuredSelection) event.getSelection()).getFirstElement();             if (element instanceof QueryDefinition) {                 final QueryDefinition queryDefinition = (QueryDefinition) element;                 synchronized (listeners) {                     for (final QueryItemDoubleClickedListener listener : listeners) {                         listener.queryItemDoubleClicked(queryDefinition);                     }                 }             }         }     }      private class ContentProvider extends TreeContentProvider {         private final String[] activeProjectNames;          public ContentProvider(final String[] activeProjectNames) {             this.activeProjectNames = activeProjectNames;         }          @Override         public Object getParent(final Object element) {             if (element instanceof QueryHierarchy) {                 return null;             }              return ((QueryItem) element).getParent();         }          @Override         public Object[] getChildren(final Object parentElement) {             final QueryItemType displayTypes = getDisplayTypes();              if (parentElement instanceof QueryFolder) {                 final List childList = new ArrayList();                 final QueryItem[] children = ((QueryFolder) parentElement).getItems();                  for (final QueryItem child : children) {                     if (displayTypes.contains(child.getType())) {                         childList.add(child);                     }                 }                  return childList.toArray(new QueryItem[childList.size()]);             }              return null;         }          @Override         public boolean hasChildren(final Object element) {             final QueryItemType displayTypes = getDisplayTypes();              if (element instanceof QueryFolder) {                 final QueryItem[] children = ((QueryFolder) element).getItems();                  for (int i = 0; i &lt; children.length; i++) {                     if (displayTypes.contains(children[i].getType())) {                         return true;                     }                 }             }              return false;         }          private QueryItemType getDisplayTypes() {             if (itemTypes.contains(QueryItemType.QUERY_DEFINITION)) {                 return QueryItemType.ALL;             } else if (itemTypes.contains(QueryItemType.QUERY_FOLDER)) {                 return QueryItemType.ALL_FOLDERS;             }              return itemTypes;         }          @Override         public Object[] getElements(final Object inputElement) {             final Project[] projects = (Project[]) inputElement;             final List queryHierarchies = new ArrayList();              final Map availableProjects = new HashMap();             for (final Project project : projects) {                 availableProjects.put(project.getName(), project);             }              for (final String activeProjectName : activeProjectNames) {                 final Project project = availableProjects.get(activeProjectName);                 if (project != null) {                     queryHierarchies.add(project.getQueryHierarchy());                 }             }              return queryHierarchies.toArray(new QueryHierarchy[queryHierarchies.size()]);         }     }      private static class LabelProvider extends org.eclipse.jface.viewers.LabelProvider {         private final Map definitionToQueryMap =             new HashMap();         private final ImageHelper imageHelper = new ImageHelper(TFSCommonUIClientPlugin.PLUGIN_ID);          public LabelProvider() {         }          @Override         public Image getImage(final Object element) {             if (element instanceof QueryHierarchy) {                 return imageHelper.getImage(&quot;images/common/team_project.gif&quot;); //$NON-NLS-1$             }             if (element instanceof QueryFolder) {                 final QueryFolder queryFolder = (QueryFolder) element;                  if (GUID.EMPTY.getGUIDString().replaceAll(&quot;-&quot;, &quot;&quot;).equals(queryFolder.getParent().getID())) //$NON-NLS-1$ //$NON-NLS-2$                 {                     // This is a top level &quot;Team Queries&quot; / &quot;My Queries&quot; folder                     if (queryFolder.isPersonal()) {                         return imageHelper.getImage(&quot;images/wit/query_group_my.gif&quot;); //$NON-NLS-1$                     }                     return imageHelper.getImage(&quot;images/wit/query_group_team.gif&quot;); //$NON-NLS-1$                 }                  return PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_OBJ_FOLDER);             }             if (element instanceof QueryDefinition) {                 final QueryDefinition queryDefinition = (QueryDefinition) element;                  StoredQuery query = definitionToQueryMap.get(queryDefinition);                  if (query == null) {                     query = new StoredQueryImpl(                         queryDefinition.getID(),                         queryDefinition.getName(),                         queryDefinition.getQueryText(),                         queryDefinition.isPersonal() ? QueryScope.PRIVATE : QueryScope.PUBLIC,                         queryDefinition.getProject().getID(),                         (ProjectImpl) queryDefinition.getProject(),                         queryDefinition.isDeleted(),                         queryDefinition.getProject().getWITContext());                      definitionToQueryMap.put(queryDefinition, query);                 }                  if (QueryType.LIST.equals(queryDefinition.getQueryType())) {                     return imageHelper.getImage(&quot;images/wit/query_type_flat.gif&quot;); //$NON-NLS-1$                 } else if (QueryType.TREE.equals(queryDefinition.getQueryType())) {                     return imageHelper.getImage(&quot;images/wit/query_type_tree.gif&quot;); //$NON-NLS-1$                 } else if (QueryType.ONE_HOP.equals(queryDefinition.getQueryType())) {                     return imageHelper.getImage(&quot;images/wit/query_type_onehop.gif&quot;); //$NON-NLS-1$                 }                  return imageHelper.getImage(&quot;images/wit/query_type_flat_error.gif&quot;); //$NON-NLS-1$             }              return imageHelper.getImage(&quot;images/wit/query.gif&quot;); //$NON-NLS-1$         }          @Override         public String getText(final Object element) {             return ((QueryItem) element).getName();         }          @Override         public void dispose() {             imageHelper.dispose();         }     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method, data class </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method,  data class </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1268</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.client.common.ui/src/com/microsoft/tfs/client/common/ui/wit/controls/QueryItemTreeControl.java/#L52-L416</td>
    <td align="right">1</td>
    <td align="right">95</td>
    <td align="right">1268</td>
  </tr>
  <tr valign="top">
    <td align="right">106</td>
    <td align="left">&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Blob&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class HttpExchangeTracer {  	private final Set includes;  	/** 	 * Creates a new {@code HttpExchangeTracer} that will use the given {@code includes} 	 * to determine the contents of its traces. 	 * @param includes the includes 	 */ 	public HttpExchangeTracer(Set includes) { 		this.includes = includes; 	}  	/** 	 * Begins the tracing of the exchange that was initiated by the given {@code request} 	 * being received. 	 * @param request the received request 	 * @return the HTTP trace for the 	 */ 	public final HttpTrace receivedRequest(TraceableRequest request) { 		return new HttpTrace(new FilteredTraceableRequest(request)); 	}  	/** 	 * Ends the tracing of the exchange that is being concluded by sending the given 	 * {@code response}. 	 * @param trace the trace for the exchange 	 * @param response the response that concludes the exchange 	 * @param principal a supplier for the exchange's principal 	 * @param sessionId a supplier for the id of the exchange's session 	 */ 	public final void sendingResponse(HttpTrace trace, TraceableResponse response, 			Supplier principal, Supplier sessionId) { 		setIfIncluded(Include.TIME_TAKEN, 				() -&gt; System.currentTimeMillis() - trace.getTimestamp().toEpochMilli(), 				trace::setTimeTaken); 		setIfIncluded(Include.SESSION_ID, sessionId, trace::setSessionId); 		setIfIncluded(Include.PRINCIPAL, principal, trace::setPrincipal); 		trace.setResponse( 				new HttpTrace.Response(new FilteredTraceableResponse(response))); 	}  	/** 	 * Post-process the given mutable map of request {@code headers}. 	 * @param headers the headers to post-process 	 */ 	protected void postProcessRequestHeaders(Map&gt; headers) {  	}  	private  T getIfIncluded(Include include, Supplier valueSupplier) { 		return this.includes.contains(include) ? valueSupplier.get() : null; 	}  	private  void setIfIncluded(Include include, Supplier supplier, 			Consumer consumer) { 		if (this.includes.contains(include)) { 			consumer.accept(supplier.get()); 		} 	}  	private Map&gt; getHeadersIfIncluded(Include include, 			Supplier&gt;&gt; headersSupplier, 			Predicate headerPredicate) { 		if (!this.includes.contains(include)) { 			return new LinkedHashMap&lt;&gt;(); 		} 		return headersSupplier.get().entrySet().stream() 				.filter((entry) -&gt; headerPredicate.test(entry.getKey())) 				.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)); 	}  	private final class FilteredTraceableRequest implements TraceableRequest {  		private final TraceableRequest delegate;  		private FilteredTraceableRequest(TraceableRequest delegate) { 			this.delegate = delegate; 		}  		@Override 		public String getMethod() { 			return this.delegate.getMethod(); 		}  		@Override 		public URI getUri() { 			return this.delegate.getUri(); 		}  		@Override 		public Map&gt; getHeaders() { 			Map&gt; headers = getHeadersIfIncluded( 					Include.REQUEST_HEADERS, this.delegate::getHeaders, 					this::includedHeader); 			postProcessRequestHeaders(headers); 			return headers; 		}  		private boolean includedHeader(String name) { 			if (name.equalsIgnoreCase(HttpHeaders.COOKIE)) { 				return HttpExchangeTracer.this.includes.contains(Include.COOKIE_HEADERS); 			} 			if (name.equalsIgnoreCase(HttpHeaders.AUTHORIZATION)) { 				return HttpExchangeTracer.this.includes 						.contains(Include.AUTHORIZATION_HEADER); 			} 			return true; 		}  		@Override 		public String getRemoteAddress() { 			return getIfIncluded(Include.REMOTE_ADDRESS, this.delegate::getRemoteAddress); 		}  	}  	private final class FilteredTraceableResponse implements TraceableResponse {  		private final TraceableResponse delegate;  		private FilteredTraceableResponse(TraceableResponse delegate) { 			this.delegate = delegate; 		}  		@Override 		public int getStatus() { 			return this.delegate.getStatus(); 		}  		@Override 		public Map&gt; getHeaders() { 			return getHeadersIfIncluded(Include.RESPONSE_HEADERS, 					this.delegate::getHeaders, this::includedHeader); 		}  		private boolean includedHeader(String name) { 			if (name.equalsIgnoreCase(HttpHeaders.SET_COOKIE)) { 				return HttpExchangeTracer.this.includes.contains(Include.COOKIE_HEADERS); 			} 			return true; 		}  	}  }</td>
    <td align="left">blob</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;data class</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1407</td>
    <td align="left">https://github.com/spring-projects/spring-boot/blob/2225b362991f225e3a93f00e160526d2b8abdfb2/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/trace/http/HttpExchangeTracer.java/#L38-L183</td>
    <td align="right">1</td>
    <td align="right">106</td>
    <td align="right">1407</td>
  </tr>
  <tr valign="top">
    <td align="right">171</td>
    <td align="left">{&quot;output&quot;: &quot;YES I found bad smells\nthe bad smells are: 1. Blob, 2. Long Method&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@APICommand(name = RevokeCertificateCmd.APINAME,         description = &quot;Revokes certificate using configured CA plugin&quot;,         responseObject = SuccessResponse.class,         requestHasSensitiveInfo = true,         responseHasSensitiveInfo = false,         since = &quot;4.11.0&quot;,         authorized = {RoleType.Admin}) public class RevokeCertificateCmd extends BaseAsyncCmd {      public static final String APINAME = &quot;revokeCertificate&quot;;      @Inject     private CAManager caManager;      /////////////////////////////////////////////////////     //////////////// API parameters /////////////////////     /////////////////////////////////////////////////////      @Parameter(name = ApiConstants.SERIAL, type = BaseCmd.CommandType.STRING, required = true, description = &quot;The certificate serial number, as a hex value&quot;)     private String serial;      @Parameter(name = ApiConstants.CN, type = BaseCmd.CommandType.STRING, description = &quot;The certificate CN&quot;)     private String cn;      @Parameter(name = ApiConstants.PROVIDER, type = BaseCmd.CommandType.STRING, description = &quot;Name of the CA service provider, otherwise the default configured provider plugin will be used&quot;)     private String provider;      /////////////////////////////////////////////////////     /////////////////// Accessors ///////////////////////     /////////////////////////////////////////////////////      public BigInteger getSerialBigInteger() {         if (Strings.isNullOrEmpty(serial)) {             throw new ServerApiException(ApiErrorCode.PARAM_ERROR, &quot;Certificate serial cannot be empty&quot;);         }         return new BigInteger(serial, 16);     }      public String getCn() {         return cn;     }      public String getProvider() {         return provider;     }      /////////////////////////////////////////////////////     /////////////// API Implementation///////////////////     /////////////////////////////////////////////////////      @Override     public void execute() {         boolean result = caManager.revokeCertificate(getSerialBigInteger(), getCn(), getProvider());         SuccessResponse response = new SuccessResponse(getCommandName());         response.setSuccess(result);         setResponseObject(response);     }      @Override     public String getCommandName() {         return APINAME.toLowerCase() + BaseCmd.RESPONSE_SUFFIX;     }      @Override     public long getEntityOwnerId() {         return CallContext.current().getCallingAccount().getId();     }      @Override     public String getEventType() {         return EventTypes.EVENT_CA_CERTIFICATE_REVOKE;     }      @Override     public String getEventDescription() {         return &quot;revoking certificate with serial id=&quot; + serial + &quot;, cn=&quot; + cn;     } }</td>
    <td align="left">blob</td>
    <td align="left">1. blob, 2. long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;2. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2036</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/api/src/main/java/org/apache/cloudstack/api/command/admin/ca/RevokeCertificateCmd.java/#L39-L116</td>
    <td align="right">1</td>
    <td align="right">171</td>
    <td align="right">2036</td>
  </tr>
  <tr valign="top">
    <td align="right">177</td>
    <td align="left">{&quot;answer&quot;:&quot;YES I found bad smells&quot;,&quot;the bad smells are: 1. Blob, 2. Long Method, 3. Long Parameter List, 4. Data Class, 5. Feature Envy, 6. Long Method, 7. Long Parameter List, 8. Data Class, 9. Feature Envy, 10. Long Method, 11. Long Parameter List, 12. Data Class, 13. Feature Envy, 14. Long Method, 15. Blob, 16. Long Parameter List, 17. Data Class, 18. Feature Envy, 19. Long Method, 20. Blob, 21. Long Parameter List, 22. Data Class, 23. Long Method, 24. Blob, 25. Long Parameter List, 26. Data Class, 27. Feature Envy, 28. Long Method, 29. Blob, 30. Long Parameter List, 31. Data Class, 32. Feature Envy, 33. Long Method, 34. Blob, 35. Long Parameter List, 36. Data Class, 37. Feature Envy, 38. Long Method, 39. Blob, 40. Long Parameter List, 41. Data Class, 42. Feature Envy, 43. Long Method, 44. Blob, 45. Long Parameter List, 46. Data Class, 47. Feature Envy, 48. Long Method, 49. Blob, 50. Long Parameter List, 51. Data Class, 52. Feature Envy, 53. Long Method, 54. Blob, 55. Long Parameter List, 56. Data Class, 57. Feature Envy, 58. Long Method, 59. Long Parameter List, 60. Data Class, 61. Feature Envy, 62. Long Method, 63. Long Parameter List, 64. Data Class, 65. Feature Envy, 66. Long Method, 67. Long Parameter List, 68. Data Class, 69. Feature Envy, 70. Long Method, 71. Blob, 72. Data Class, 73. Long Method, 74. Blob, 75. Data Class, 76. Long Method, 77. Blob, 78. Data Class, 79. Long Method, 80. Blob, 81. Data Class, 82. Long Method, 83. Blob, 84. Data Class, 85. Long Method, 86. Blob, 87. Data Class, 88. Long Method, 89. Blob, 90. Data Class, 91. Long Method, 92. Long Parameter List, 93. Data Class, 94. Feature Envy, 95. Long Method, 96. Long Parameter List, 97. Data Class, 98. Feature Envy, 99. Long Method, 100. Long Parameter List, 101. Data Class, 102. Feature Envy, 103. Long Method, 104. Long Parameter List, 105. Data Class, 106. Feature Envy, 107. Long Method, 108. Long Parameter List, 109. Data Class, 110. Feature Envy, 111. Long Method, 112. Long Parameter List, 113. Data Class, 114. Feature Envy, 115. Long Method, 116. Long Parameter List, 117. Data Class, 118. Feature Envy, 119. Long Method, 120. Long Parameter List, 121. Data Class, 122. Feature Envy, 123. Long Method, 124. Long Parameter List, 125. Data Class, 126. Feature Envy, 127. Long Method, 128. Long Parameter List, 129. Data Class, 130. Feature Envy, 131. Long Method, 132. Long Parameter List, 133. Data Class, 134. Feature Envy, 135. Long Method, 136. Long Parameter List, 137. Data Class, 138. Feature Envy, 139. Long Method, 140. Long Parameter List, 141. Data Class, 142. Feature Envy, 143. Long Method, 144. Long Parameter List, 145. Data Class, 146. Feature Envy, 147. Long Method, 148. Long Parameter List, 149. Data Class, 150. Feature Envy, 151. Long Method, 152. Long Parameter List, 153. Data Class, 154. Feature Envy, 155. Long Method, 156. Long Parameter List, 157. Data Class, 158. Feature Envy, 159. Long Method, 160. Long Parameter List, 161. Data Class, 162. Feature Envy, 163. Long Method, 164. Long Parameter List, 165. Data Class, 166. Feature Envy, 167. Long Method, 168. Long Parameter List, 169. Data Class, 170. Feature Envy, 171. Long Method, 172. Long Parameter List, 173. Data Class, 174. Feature Envy, 175. Blob, 176. Data Class, 177. Feature Envy, 178. Long Method, 179. Blob, 180. Data Class, 181. Feature Envy, 182. Long Method, 183. Blob, 184. Data Class, 185. Feature Envy, 186. Long Method, 187. Blob, 188. Long Parameter List, 189. Data Class, 190. Feature Envy, 191. Long Method, 192. Blob, 193. Long Parameter List, 194. Data Class, 195. Feature Envy, 196. Long Method, 197. Blob, 198. Long Parameter List, 199. Data Class, 200. Feature Envy, 201. Blob, 202. Data Class, 203. Feature Envy, 204. Long Method, 205. Blob, 206. Data Class, 207. Feature Envy, 208. Long Method, 209. Blob, 210. Data Class, 211. Feature Envy, 212. Long Method, 213. Blob, 214. Data Class, 215. Feature Envy, 216. Long Method, 217. Blob, 218. Data Class, 219. Feature Envy, 220. Long Method, 221. Blob, 222. Data Class, 223. Feature Envy, 224. Long Method, 225. Blob, 226. Data Class, 227. Feature Envy, 228. Long Method, 229. Blob, 230. Data Class, 231. Feature Envy, 232. Long Method, 233. Long Parameter List, 234. Data Class, 235. Feature Envy, 236. Long Method, 237. Long Parameter List, 238. Data Class, 239. Feature Envy, 240. Long Method, 241. Long Parameter List, 242. Data Class, 243. Feature Envy, 244. Long Method, 245. Long Parameter List, 246. Data Class, 247. Feature Envy, 248. Long Method, 249. Long Parameter List, 250. Data Class, 251. Feature Envy, 252. Long Method, 253. Long Parameter List, 254. Data Class, 255. Feature Envy, 256. Long Method, 257. Long Parameter List, 258. Data Class, 259. Feature Envy, 260. Long Method, 261. Long Parameter List, 262. Data Class, 263. Feature Envy, 264. Long Method, 265. Long Parameter List, 266. Data Class, 267. Feature Envy, 268. Long Method, 269. Long Parameter List, 270. Data Class, 271. Feature Envy, 272. Long Method, 273. Long Parameter List, 274. Data Class, 275. Feature Envy, 276. Long Method, 277. Long Parameter List, 278. Data Class, 279. Feature Envy, 280. Long Method, 281. Long Parameter List, 282. Data Class, 283. Feature Envy, 284. Long Method, 285. Long Parameter List, 286. Data Class, 287. Feature Envy, 288. Long Method, 289. Long Parameter List, 290. Data Class, 291. Feature Envy, 292. Long Method, 293. Long Parameter List, 294. Data Class, 295. Feature Envy, 296. Long Method, 297. Long Parameter List, 298. Data Class, 299. Feature Envy, 300. Long Method, 301. Long Parameter List, 302. Data Class, 303. Feature Envy, 304. Long Method, 305. Long Parameter List, 306. Data Class, 307. Feature Envy, 308. Long Method, 309. Long Parameter List, 310. Data Class, 311. Feature Envy, 312. Long Method, 313. Long Parameter List, 314. Data Class, 315. Feature Envy, 316. Long Method, 317. Long Parameter List, 318. Data Class, 319. Feature Envy, 320. Long Method, 321. Long Parameter List, 322. Data Class, 323. Feature Envy, 324. Long Method, 325. Long Parameter List, 326. Data Class, 327. Feature Envy, 328. Long Method, 329. Long Parameter List, 330. Data Class, 331. Feature Envy, 332. Long Method, 333. Long Parameter List, 334. Data Class, 335. Feature Envy, 336. Long Method, 337. Long Parameter List, 338. Data Class, 339. Feature Envy, 340. Long Method, 341. Long Parameter List, 342. Data Class, 343. Feature Envy, 344. Long Method, 345. Long Parameter List, 346. Data Class, 347. Feature Envy, 348. Long Method, 349. Long Parameter List, 350. Data Class, 351. Feature Envy, 352. Long Method, 353. Long Parameter List, 354. Data Class, 355. Feature Envy, 356. Long Method, 357. Long Parameter List, 358. Data Class, 359. Feature Envy, 360. Long Method, 361. Long Parameter List, 362. Data Class, 363. Feature Envy, 364. Long Method, 365. Long Parameter List, 366. Data Class, 367. Feature Envy, 368. Long Method, 369. Long Parameter List, 370. Data Class, 371. Feature Envy, 372. Long Method, 373. Long Parameter List, 374. Data Class, 375. Feature Envy, 376. Long Method, 377. Long Parameter List, 378. Data Class, 379. Feature Envy, 380. Long Method, 381. Long Parameter List, 382. Data Class, 383. Feature Envy, 384. Long Method, 385. Long Parameter List, 386. Data Class, 387. Feature Envy, 388. Long Method, 389. Long Parameter List, 390. Data Class, 391. Feature Envy, 392. Long Method, 393. Long Parameter List, 394. Data Class, 395. Feature Envy, 396. Long Method, 397. Long Parameter List, 398. Data Class, 399. Feature Envy, 400. Long Method, 401. Long Parameter List, 402. Data Class, 403. Feature Envy, 404. Long Method, 405. Long Parameter List, 406. Data Class, 407. Feature Envy, 408. Long Method, 409. Long Parameter List, 410. Data Class, 411. Feature Envy, 412. Long Method, 413. Long Parameter List, 414. Data Class, 415. Feature Envy, 416. Long Method, 417. Long Parameter List, 418. Data Class, 419. Feature Envy, 420. Long Method, 421. Long Parameter List, 422. Data Class, 423. Feature Envy, 424. Long Method, 425. Long Parameter List, 426. Data Class, 427. Feature Envy, 428. Long Method, 429. Data Class, 430. Feature Envy, 431. Long Method, 432. Long Parameter List, 433. Data Class, 434. Feature Envy, 435. Long Method, 436. Long Parameter List, 437. Data Class, 438. Feature Envy, 439. Long Method, 440. Long Parameter List, 441. Data Class, 442. Feature Envy, 443. Long Method, 444. Blob, 445. Data Class, 446. Feature Envy, 447. Long Method, 448. Blob, 449. Data Class, 450. Feature Envy, 451. Long Method, 452. Blob, 453. Data Class, 454. Feature Envy, 455. Long Method, 456. Blob, 457. Long Parameter List, 458. Data Class, 459. Feature Envy, 460. Long Method, 461. Blob, 462. Long Parameter List, 463. Data Class, 464. Feature Envy, 465. Long Method, 466. Blob, 467. Long Parameter List, 468. Data Class, 469. Feature Envy, 470. Long Method, 471. Blob, 472. Long Parameter List, 473. Data Class, 474. Feature Envy, 475. Long Method, 476. Data Class, 477. Feature Envy, 478. Long Method, 479. Blob, 480. Data Class, 481. Feature Envy, 482. Long Method, 483. Blob, 484. Data Class, 485. Feature Envy, 486. Long Method, 487. Blob, 488. Data Class, 489. Feature Envy, 490. Long Method, 491. Blob, 492. Data Class, 493. Feature Envy, 494. Long Method, 495. Blob, 496. Data Class, 497. Feature Envy, 498. Long Method, 499. Data Class, 500. Feature Envy, 501. Long Method, 502. Blob, 503. Data Class, 504. Feature Envy, 505. Long Method, 506. Blob, 507. Data Class, 508. Feature Envy, 509. Long Method, 510. Blob, 511. Data Class, 512. Feature Envy, 513. Long Method, 514. Blob, 515. Data Class, 516. Feature Envy, 517. Long Method, 518. Blob, 519. Data Class, 520. Feature Envy, 521. Long Method, 522. Blob, 523. Data Class, 524. Feature Envy, 525. Long Method, 526. Blob, 527. Data Class, 528. Feature Envy, 529. Long Method, 530. Blob, 531. Data Class, 532. Feature Envy, 533. Long Method, 534. Blob, 535. Data Class, 536. Feature Envy, 537. Long Method, 538. Blob, 539. Data Class, 540. Feature Envy, 541. Long Method, 542. Blob, 543. Data Class, 544. Feature Envy, 545. Long Method, 546. Blob, 547. Data Class, 548. Feature Envy, 549. Long Method, 550. Blob, 551. Data Class, 552. Feature Envy, 553. Long Method, 554. Blob, 555. Data Class, 556. Feature Envy, 557. Long Method, 558. Blob, 559. Data Class, 560. Feature Envy, 561. Long Method, 562. Blob, 563. Data Class, 564. Feature Envy, 565. Long Method, 566. Blob, 567. Data Class, 568. Feature Envy, 569. Long Method, 570. Blob, 571. Data Class, 572. Feature Envy, 573. Long Method, 574. Blob, 575. Data Class, 576. Feature Envy, 577. Long Method, 578. Blob, 579. Data Class, 580. Feature Envy, 581. Long Method, 582. Blob, 583. Data Class, 584. Feature Envy, 585. Long Method, 586. Blob, 587. Data Class, 588. Feature Envy, 589. Long Method, 590. Blob, 591. Data Class, 592. Feature Envy, 593. Long Method, 594. Blob, 595. Data Class, 596. Feature Envy, 597. Long Method, 598. Blob, 599. Data Class, 600. Feature Envy, 601. Long Method, 602. Blob, 603. Data Class, 604. Feature Envy, 605. Long Method, 606. Blob, 607. Data Class, 608. Feature Envy, 609. Long Method, 610. Blob, 611. Data Class, 612. Feature Envy, 613. Long Method, 614. Blob, 615. Data Class, 616. Feature Envy, 617. Long Method, 618. Blob, 619. Data Class, 620. Feature Envy, 621. Long Method, 622. Blob, 623. Data Class, 624. Feature Envy, 625. Long Method, 626. Blob, 627. Data Class, 628. Feature Envy, 629. Long Method, 630. Blob, 631. Data Class, 632. Feature Envy, 633. Long Method, 634. Blob, 635. Data Class, 636. Feature Envy, 637. Long Method, 638. Blob, 639. Data Class, 640. Feature Envy, 641. Long Method, 642. Blob, 643. Data Class, 644. Feature Envy, 645. Long Method, 646. Blob, 647. Data Class, 648. Feature Envy, 649. Long Method, 650. Blob, 651. Data Class, 652. Feature Envy, 653</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class ExternalLoadBalancerDeviceManagerImpl extends AdapterBase implements ExternalLoadBalancerDeviceManager, ResourceStateAdapter {      @Inject     NetworkExternalLoadBalancerDao _networkExternalLBDao;     @Inject     ExternalLoadBalancerDeviceDao _externalLoadBalancerDeviceDao;     @Inject     HostDao _hostDao;     @Inject     DataCenterDao _dcDao;     @Inject     NetworkModel _networkModel;     @Inject     NetworkOrchestrationService _networkMgr;     @Inject     InlineLoadBalancerNicMapDao _inlineLoadBalancerNicMapDao;     @Inject     NicDao _nicDao;     @Inject     AgentManager _agentMgr;     @Inject     ResourceManager _resourceMgr;     @Inject     IPAddressDao _ipAddressDao;     @Inject     VlanDao _vlanDao;     @Inject     NetworkOfferingDao _networkOfferingDao;     @Inject     AccountDao _accountDao;     @Inject     PhysicalNetworkDao _physicalNetworkDao;     @Inject     PhysicalNetworkServiceProviderDao _physicalNetworkServiceProviderDao;     @Inject     AccountManager _accountMgr;     @Inject     UserStatisticsDao _userStatsDao;     @Inject     NetworkDao _networkDao;     @Inject     DomainRouterDao _routerDao;     @Inject     LoadBalancerDao _loadBalancerDao;     @Inject     PortForwardingRulesDao _portForwardingRulesDao;     @Inject     ConfigurationDao _configDao;     @Inject     HostDetailsDao _hostDetailDao;     @Inject     NetworkExternalLoadBalancerDao _networkLBDao;     @Inject     NetworkServiceMapDao _ntwkSrvcProviderDao;     @Inject     NetworkExternalFirewallDao _networkExternalFirewallDao;     @Inject     ExternalFirewallDeviceDao _externalFirewallDeviceDao;     @Inject     protected HostPodDao _podDao = null;     @Inject     IpAddressManager _ipAddrMgr;     @Inject     protected     VirtualMachineManager _itMgr;     @Inject     VMInstanceDao _vmDao;     @Inject     VMTemplateDao _templateDao;     @Inject     ServiceOfferingDao _serviceOfferingDao;     @Inject     PhysicalNetworkServiceProviderDao _physicalProviderDao;     @Inject     VirtualRouterProviderDao _vrProviderDao;      private long _defaultLbCapacity;     private static final org.apache.log4j.Logger s_logger = Logger.getLogger(ExternalLoadBalancerDeviceManagerImpl.class);      @Override     @DB     public ExternalLoadBalancerDeviceVO addExternalLoadBalancer(long physicalNetworkId, String url, String username, String password, final String deviceName,         ServerResource resource, final boolean gslbProvider, final boolean exclusiveGslbProivider,         final String gslbSitePublicIp, final String gslbSitePrivateIp) {          PhysicalNetworkVO pNetwork = null;         final NetworkDevice ntwkDevice = NetworkDevice.getNetworkDevice(deviceName);         long zoneId;          if ((ntwkDevice == null) || (url == null) || (username == null) || (resource == null) || (password == null)) {             throw new InvalidParameterValueException(&quot;Atleast one of the required parameters (url, username, password,&quot;                 + &quot; server resource, zone id/physical network id) is not specified or a valid parameter.&quot;);         }          pNetwork = _physicalNetworkDao.findById(physicalNetworkId);         if (pNetwork == null) {             throw new InvalidParameterValueException(&quot;Could not find phyical network with ID: &quot; + physicalNetworkId);         }          zoneId = pNetwork.getDataCenterId();         PhysicalNetworkServiceProviderVO ntwkSvcProvider =             _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), ntwkDevice.getNetworkServiceProvder());          ntwkSvcProvider = _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), ntwkDevice.getNetworkServiceProvder());         if (ntwkSvcProvider == null) {             throw new CloudRuntimeException(&quot;Network Service Provider: &quot; + ntwkDevice.getNetworkServiceProvder() + &quot; is not enabled in the physical network: &quot; +                 physicalNetworkId + &quot;to add this device&quot;);         } else if (ntwkSvcProvider.getState() == PhysicalNetworkServiceProvider.State.Shutdown) {             throw new CloudRuntimeException(&quot;Network Service Provider: &quot; + ntwkSvcProvider.getProviderName() + &quot; is in shutdown state in the physical network: &quot; +                 physicalNetworkId + &quot;to add this device&quot;);         }          if (gslbProvider) {             ExternalLoadBalancerDeviceVO zoneGslbProvider =                 _externalLoadBalancerDeviceDao.findGslbServiceProvider(physicalNetworkId, ntwkDevice.getNetworkServiceProvder());             if (zoneGslbProvider != null) {                 throw new CloudRuntimeException(&quot;There is a GSLB service provider configured in the zone alredy.&quot;);             }         }          URI uri;         try {             uri = new URI(url);         } catch (Exception e) {             s_logger.debug(e);             throw new InvalidParameterValueException(e.getMessage());         }          String ipAddress = uri.getHost();         Map hostDetails = new HashMap();         String hostName = getExternalLoadBalancerResourceGuid(pNetwork.getId(), deviceName, ipAddress);         hostDetails.put(&quot;name&quot;, hostName);         hostDetails.put(&quot;guid&quot;, UUID.randomUUID().toString());         hostDetails.put(&quot;zoneId&quot;, String.valueOf(pNetwork.getDataCenterId()));         hostDetails.put(&quot;ip&quot;, ipAddress);         hostDetails.put(&quot;physicalNetworkId&quot;, String.valueOf(pNetwork.getId()));         hostDetails.put(&quot;username&quot;, username);         hostDetails.put(&quot;password&quot;, password);         hostDetails.put(&quot;deviceName&quot;, deviceName);          // leave parameter validation to be part server resource configure         Map configParams = new HashMap();         UrlUtil.parseQueryParameters(uri.getQuery(), false, configParams);         hostDetails.putAll(configParams);          try {             resource.configure(hostName, hostDetails);              final Host host = _resourceMgr.addHost(zoneId, resource, Host.Type.ExternalLoadBalancer, hostDetails);             if (host != null) {                  final boolean dedicatedUse =                     (configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_DEDICATED) != null) ? Boolean.parseBoolean(configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_DEDICATED))                         : false;                 long capacity = NumbersUtil.parseLong(configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_CAPACITY), 0);                 if (capacity == 0) {                     capacity = _defaultLbCapacity;                 }                  final long capacityFinal = capacity;                 final PhysicalNetworkVO pNetworkFinal = pNetwork;                 return Transaction.execute(new TransactionCallback() {                     @Override                     public ExternalLoadBalancerDeviceVO doInTransaction(TransactionStatus status) {                         ExternalLoadBalancerDeviceVO lbDeviceVO =                             new ExternalLoadBalancerDeviceVO(host.getId(), pNetworkFinal.getId(), ntwkDevice.getNetworkServiceProvder(), deviceName, capacityFinal,                                 dedicatedUse, gslbProvider);                         if (gslbProvider) {                             lbDeviceVO.setGslbSitePublicIP(gslbSitePublicIp);                             lbDeviceVO.setGslbSitePrivateIP(gslbSitePrivateIp);                             lbDeviceVO.setExclusiveGslbProvider(exclusiveGslbProivider);                         }                         _externalLoadBalancerDeviceDao.persist(lbDeviceVO);                         DetailVO hostDetail = new DetailVO(host.getId(), ApiConstants.LOAD_BALANCER_DEVICE_ID, String.valueOf(lbDeviceVO.getId()));                         _hostDetailDao.persist(hostDetail);                          return lbDeviceVO;                     }                 });             } else {                 throw new CloudRuntimeException(&quot;Failed to add load balancer device due to internal error.&quot;);             }         } catch (ConfigurationException e) {             throw new CloudRuntimeException(e.getMessage());         }     }      @Override     public boolean deleteExternalLoadBalancer(long hostId) {         HostVO externalLoadBalancer = _hostDao.findById(hostId);         if (externalLoadBalancer == null) {             throw new InvalidParameterValueException(&quot;Could not find an external load balancer with ID: &quot; + hostId);         }          DetailVO lbHostDetails = _hostDetailDao.findDetail(hostId, ApiConstants.LOAD_BALANCER_DEVICE_ID);         long lbDeviceId = Long.parseLong(lbHostDetails.getValue());          ExternalLoadBalancerDeviceVO lbDeviceVo = _externalLoadBalancerDeviceDao.findById(lbDeviceId);         if (lbDeviceVo.getAllocationState() == LBDeviceAllocationState.Provider) {             // check if cloudstack has provisioned any load balancer appliance on the device before deleting             List lbDevices = _externalLoadBalancerDeviceDao.listAll();             if (lbDevices != null) {                 for (ExternalLoadBalancerDeviceVO lbDevice : lbDevices) {                     if (lbDevice.getParentHostId() == hostId) {                         throw new CloudRuntimeException(                             &quot;This load balancer device can not be deleted as there are one or more load balancers applainces provisioned by cloudstack on the device.&quot;);                     }                 }             }         } else {             // check if any networks are using this load balancer device             List networks = _networkLBDao.listByLoadBalancerDeviceId(lbDeviceId);             if ((networks != null) &amp;&amp; !networks.isEmpty()) {                 throw new CloudRuntimeException(&quot;Delete can not be done as there are networks using this load balancer device &quot;);             }         }          try {             // put the host in maintenance state in order for it to be deleted             externalLoadBalancer.setResourceState(ResourceState.Maintenance);             _hostDao.update(hostId, externalLoadBalancer);             _resourceMgr.deleteHost(hostId, false, false);              // delete the external load balancer entry             _externalLoadBalancerDeviceDao.remove(lbDeviceId);              return true;         } catch (Exception e) {             s_logger.debug(e);             return false;         }     }      @Override     public List listExternalLoadBalancers(long physicalNetworkId, String deviceName) {         List lbHosts = new ArrayList();         NetworkDevice lbNetworkDevice = NetworkDevice.getNetworkDevice(deviceName);         PhysicalNetworkVO pNetwork = null;          pNetwork = _physicalNetworkDao.findById(physicalNetworkId);          if ((pNetwork == null) || (lbNetworkDevice == null)) {             throw new InvalidParameterValueException(&quot;Atleast one of the required parameter physical networkId, device name is invalid.&quot;);         }          PhysicalNetworkServiceProviderVO ntwkSvcProvider =             _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), lbNetworkDevice.getNetworkServiceProvder());         // if provider not configured in to physical network, then there can be no instances         if (ntwkSvcProvider == null) {             return null;         }          List lbDevices =             _externalLoadBalancerDeviceDao.listByPhysicalNetworkAndProvider(physicalNetworkId, ntwkSvcProvider.getProviderName());         for (ExternalLoadBalancerDeviceVO provderInstance : lbDevices) {             lbHosts.add(_hostDao.findById(provderInstance.getHostId()));         }         return lbHosts;     }      public ExternalLoadBalancerResponse createExternalLoadBalancerResponse(Host externalLoadBalancer) {         Map lbDetails = _hostDetailDao.findDetails(externalLoadBalancer.getId());         ExternalLoadBalancerResponse response = new ExternalLoadBalancerResponse();         response.setId(externalLoadBalancer.getUuid());         response.setIpAddress(externalLoadBalancer.getPrivateIpAddress());         response.setUsername(lbDetails.get(&quot;username&quot;));         response.setPublicInterface(lbDetails.get(&quot;publicInterface&quot;));         response.setPrivateInterface(lbDetails.get(&quot;privateInterface&quot;));         response.setNumRetries(lbDetails.get(&quot;numRetries&quot;));         return response;     }      public String getExternalLoadBalancerResourceGuid(long physicalNetworkId, String deviceName, String ip) {         return physicalNetworkId + &quot;-&quot; + deviceName + &quot;-&quot; + ip;     }      @Override     public ExternalLoadBalancerDeviceVO getExternalLoadBalancerForNetwork(Network network) {         NetworkExternalLoadBalancerVO lbDeviceForNetwork = _networkExternalLBDao.findByNetworkId(network.getId());         if (lbDeviceForNetwork != null) {             long lbDeviceId = lbDeviceForNetwork.getExternalLBDeviceId();             ExternalLoadBalancerDeviceVO lbDeviceVo = _externalLoadBalancerDeviceDao.findById(lbDeviceId);             assert (lbDeviceVo != null);             return lbDeviceVo;         }         return null;     }      public void setExternalLoadBalancerForNetwork(Network network, long externalLBDeviceID) {         NetworkExternalLoadBalancerVO lbDeviceForNetwork = new NetworkExternalLoadBalancerVO(network.getId(), externalLBDeviceID);         _networkExternalLBDao.persist(lbDeviceForNetwork);     }      @DB     protected ExternalLoadBalancerDeviceVO allocateLoadBalancerForNetwork(final Network guestConfig) throws InsufficientCapacityException {         boolean retry = true;         boolean tryLbProvisioning = false;         ExternalLoadBalancerDeviceVO lbDevice = null;         long physicalNetworkId = guestConfig.getPhysicalNetworkId();         NetworkOfferingVO offering = _networkOfferingDao.findById(guestConfig.getNetworkOfferingId());         String provider = _ntwkSrvcProviderDao.getProviderForServiceInNetwork(guestConfig.getId(), Service.Lb);          while (retry) {             GlobalLock deviceMapLock = GlobalLock.getInternLock(&quot;LoadBalancerAllocLock&quot;);             try {                 if (deviceMapLock.lock(120)) {                     try {                         final boolean dedicatedLB = offering.isDedicatedLB(); // does network offering supports a dedicated load balancer?                          try {                             lbDevice = Transaction.execute(new TransactionCallbackWithException() {                                 @Override                                 public ExternalLoadBalancerDeviceVO doInTransaction(TransactionStatus status) throws InsufficientCapacityException {                                     // FIXME: should the device allocation be done during network implement phase or do a                                     // lazy allocation when first rule for the network is configured??                                      // find a load balancer device for this network as per the network offering                                     ExternalLoadBalancerDeviceVO lbDevice = findSuitableLoadBalancerForNetwork(guestConfig, dedicatedLB);                                     long lbDeviceId = lbDevice.getId();                                      // persist the load balancer device id that will be used for this network. Once a network                                     // is implemented on a LB device then later on all rules will be programmed on to same device                                     NetworkExternalLoadBalancerVO networkLB = new NetworkExternalLoadBalancerVO(guestConfig.getId(), lbDeviceId);                                     _networkExternalLBDao.persist(networkLB);                                      // mark device to be either dedicated or shared use                                     lbDevice.setAllocationState(dedicatedLB ? LBDeviceAllocationState.Dedicated : LBDeviceAllocationState.Shared);                                     _externalLoadBalancerDeviceDao.update(lbDeviceId, lbDevice);                                     return lbDevice;                                 }                             });                              // allocated load balancer for the network, so skip retry                             tryLbProvisioning = false;                             retry = false;                         } catch (InsufficientCapacityException exception) {                             // if already attempted to provision load balancer then throw out of capacity exception,                             if (tryLbProvisioning) {                                 retry = false;                                 // TODO: throwing warning instead of error for now as its possible another provider can service this network                                 s_logger.warn(&quot;There are no load balancer device with the capacity for implementing this network&quot;);                                 throw exception;                             } else {                                 tryLbProvisioning = true; // if possible provision a LB appliance in to the physical network                             }                         }                     } finally {                         deviceMapLock.unlock();                     }                 }             } finally {                 deviceMapLock.releaseRef();             }              // there are no LB devices or there is no free capacity on the devices in the physical network so provision a new LB appliance             if (tryLbProvisioning) {                 // check if LB appliance can be dynamically provisioned                 List providerLbDevices =                     _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Provider);                 if ((providerLbDevices != null) &amp;&amp; (!providerLbDevices.isEmpty())) {                     for (ExternalLoadBalancerDeviceVO lbProviderDevice : providerLbDevices) {                         if (lbProviderDevice.getState() == LBDeviceState.Enabled) {                             // acquire a private IP from the data center which will be used as management IP of provisioned LB appliance,                             DataCenterIpAddressVO dcPrivateIp = _dcDao.allocatePrivateIpAddress(guestConfig.getDataCenterId(), lbProviderDevice.getUuid());                             if (dcPrivateIp == null) {                                 throw new InsufficientNetworkCapacityException(&quot;failed to acquire a priavate IP in the zone &quot; + guestConfig.getDataCenterId() +                                     &quot; needed for management IP of the load balancer appliance&quot;, DataCenter.class, guestConfig.getDataCenterId());                             }                             Pod pod = _podDao.findById(dcPrivateIp.getPodId());                             String lbIP = dcPrivateIp.getIpAddress();                             String netmask = NetUtils.getCidrNetmask(pod.getCidrSize());                             String gateway = pod.getGateway();                              // send CreateLoadBalancerApplianceCommand to the host capable of provisioning                             CreateLoadBalancerApplianceCommand lbProvisionCmd = new CreateLoadBalancerApplianceCommand(lbIP, netmask, gateway);                             CreateLoadBalancerApplianceAnswer createLbAnswer = null;                             try {                                 createLbAnswer = (CreateLoadBalancerApplianceAnswer)_agentMgr.easySend(lbProviderDevice.getHostId(), lbProvisionCmd);                                 if (createLbAnswer == null || !createLbAnswer.getResult()) {                                     s_logger.error(&quot;Could not provision load balancer instance on the load balancer device &quot; + lbProviderDevice.getId());                                     continue;                                 }                             } catch (Exception agentException) {                                 s_logger.error(&quot;Could not provision load balancer instance on the load balancer device &quot; + lbProviderDevice.getId() + &quot; due to &quot; +                                     agentException.getMessage());                                 continue;                             }                              String username = createLbAnswer.getUsername();                             String password = createLbAnswer.getPassword();                             String publicIf = createLbAnswer.getPublicInterface();                             String privateIf = createLbAnswer.getPrivateInterface();                              // we have provisioned load balancer so add the appliance as cloudstack provisioned external load balancer                             String dedicatedLb = offering.isDedicatedLB() ? &quot;true&quot; : &quot;false&quot;;                             String capacity = Long.toString(lbProviderDevice.getCapacity());                              // acquire a public IP to associate with lb appliance (used as subnet IP to make the appliance part of private network)                             PublicIp publicIp =                                 _ipAddrMgr.assignPublicIpAddress(guestConfig.getDataCenterId(), null, _accountMgr.getSystemAccount(), VlanType.VirtualNetwork, null,                                     null, false, false);                             String publicIPNetmask = publicIp.getVlanNetmask();                             String publicIPgateway = publicIp.getVlanGateway();                             String publicIP = publicIp.getAddress().toString();                             String publicIPVlanTag=&quot;&quot;;                             try {                                 publicIPVlanTag = BroadcastDomainType.getValue(publicIp.getVlanTag());                             } catch (URISyntaxException e) {                                 s_logger.error(&quot;Failed to parse public ip vlan tag&quot; + e.getMessage());                             }                              String url =                                 &quot;https://&quot; + lbIP + &quot;?publicinterface=&quot; + publicIf + &quot;&amp;privateinterface=&quot; + privateIf + &quot;&amp;lbdevicededicated=&quot; + dedicatedLb +                                     &quot;&amp;cloudmanaged=true&quot; + &quot;&amp;publicip=&quot; + publicIP + &quot;&amp;publicipnetmask=&quot; + publicIPNetmask + &quot;&amp;lbdevicecapacity=&quot; + capacity +                                     &quot;&amp;publicipvlan=&quot; + publicIPVlanTag + &quot;&amp;publicipgateway=&quot; + publicIPgateway;                             ExternalLoadBalancerDeviceVO lbAppliance = null;                             try {                                 lbAppliance =                                     addExternalLoadBalancer(physicalNetworkId, url, username, password, createLbAnswer.getDeviceName(),                                         createLbAnswer.getServerResource(), false, false, null, null);                             } catch (Exception e) {                                 s_logger.error(&quot;Failed to add load balancer appliance in to cloudstack due to &quot; + e.getMessage() +                                     &quot;. So provisioned load balancer appliance will be destroyed.&quot;);                             }                              if (lbAppliance != null) {                                 // mark the load balancer as cloudstack managed and set parent host id on which lb appliance is provisioned                                 ExternalLoadBalancerDeviceVO managedLb = _externalLoadBalancerDeviceDao.findById(lbAppliance.getId());                                 managedLb.setIsManagedDevice(true);                                 managedLb.setParentHostId(lbProviderDevice.getHostId());                                 _externalLoadBalancerDeviceDao.update(lbAppliance.getId(), managedLb);                             } else {                                 // failed to add the provisioned load balancer into cloudstack so destroy the appliance                                 DestroyLoadBalancerApplianceCommand lbDeleteCmd = new DestroyLoadBalancerApplianceCommand(lbIP);                                 DestroyLoadBalancerApplianceAnswer answer = null;                                 try {                                     answer = (DestroyLoadBalancerApplianceAnswer)_agentMgr.easySend(lbProviderDevice.getHostId(), lbDeleteCmd);                                     if (answer == null || !answer.getResult()) {                                         s_logger.warn(&quot;Failed to destroy load balancer appliance created&quot;);                                     } else {                                         // release the public &amp; private IP back to dc pool, as the load balancer appliance is now destroyed                                         _dcDao.releasePrivateIpAddress(lbIP, guestConfig.getDataCenterId(), null);                                         _ipAddrMgr.disassociatePublicIpAddress(publicIp.getId(), _accountMgr.getSystemUser().getId(), _accountMgr.getSystemAccount());                                     }                                 } catch (Exception e) {                                     s_logger.warn(&quot;Failed to destroy load balancer appliance created for the network&quot; + guestConfig.getId() + &quot; due to &quot; + e.getMessage());                                 }                             }                         }                     }                 }             }         }          return lbDevice;     }      @Override     public ExternalLoadBalancerDeviceVO findSuitableLoadBalancerForNetwork(Network network, boolean dedicatedLb) throws InsufficientCapacityException {         long physicalNetworkId = network.getPhysicalNetworkId();         List lbDevices = null;         String provider = _ntwkSrvcProviderDao.getProviderForServiceInNetwork(network.getId(), Service.Lb);         assert (provider != null);          if (dedicatedLb) {             lbDevices = _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Free);             if (lbDevices != null &amp;&amp; !lbDevices.isEmpty()) {                 // return first device that is free, fully configured and meant for dedicated use                 for (ExternalLoadBalancerDeviceVO lbdevice : lbDevices) {                     if (lbdevice.getState() == LBDeviceState.Enabled &amp;&amp; lbdevice.getIsDedicatedDevice()) {                         return lbdevice;                     }                 }             }         } else {             // get the LB devices that are already allocated for shared use             lbDevices = _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Shared);              if (lbDevices != null) {                  ExternalLoadBalancerDeviceVO maxFreeCapacityLbdevice = null;                 long maxFreeCapacity = 0;                  // loop through the LB device in the physical network and pick the one with maximum free capacity                 for (ExternalLoadBalancerDeviceVO lbdevice : lbDevices) {                      // skip if device is not enabled                     if (lbdevice.getState() != LBDeviceState.Enabled) {                         continue;                     }                      // get the used capacity from the list of guest networks that are mapped to this load balancer                     List mappedNetworks = _networkExternalLBDao.listByLoadBalancerDeviceId(lbdevice.getId());                     long usedCapacity = ((mappedNetworks == null) || (mappedNetworks.isEmpty())) ? 0 : mappedNetworks.size();                      // get the configured capacity for this device                     long fullCapacity = lbdevice.getCapacity();                     if (fullCapacity == 0) {                         fullCapacity = _defaultLbCapacity; // if capacity not configured then use the default                     }                      long freeCapacity = fullCapacity - usedCapacity;                     if (freeCapacity &gt; 0) {                         if (maxFreeCapacityLbdevice == null) {                             maxFreeCapacityLbdevice = lbdevice;                             maxFreeCapacity = freeCapacity;                         } else if (freeCapacity &gt; maxFreeCapacity) {                             maxFreeCapacityLbdevice = lbdevice;                             maxFreeCapacity = freeCapacity;                         }                     }                 }                  // return the device with maximum free capacity and is meant for shared use                 if (maxFreeCapacityLbdevice != null) {                     return maxFreeCapacityLbdevice;                 }             }              // if we are here then there are no existing LB devices in shared use or the devices in shared use has no // free capacity left             // so allocate a new load balancer configured for shared use from the pool of free LB devices             lbDevices = _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Free);             if (lbDevices != null &amp;&amp; !lbDevices.isEmpty()) {                 for (ExternalLoadBalancerDeviceVO lbdevice : lbDevices) {                     if (lbdevice.getState() == LBDeviceState.Enabled &amp;&amp; !lbdevice.getIsDedicatedDevice()) {                         return lbdevice;                     }                 }             }         }          // there are no devices which capacity         throw new InsufficientNetworkCapacityException(&quot;Unable to find a load balancing provider with sufficient capcity &quot; + &quot; to implement the network&quot;, Network.class,             network.getId());     }      @DB     protected boolean freeLoadBalancerForNetwork(final Network guestConfig) {         GlobalLock deviceMapLock = GlobalLock.getInternLock(&quot;LoadBalancerAllocLock&quot;);          try {             if (deviceMapLock.lock(120)) {                 ExternalLoadBalancerDeviceVO lbDevice = Transaction.execute(new TransactionCallback() {                     @Override                     public ExternalLoadBalancerDeviceVO doInTransaction(TransactionStatus status) {                         // since network is shutdown remove the network mapping to the load balancer device                         NetworkExternalLoadBalancerVO networkLBDevice = _networkExternalLBDao.findByNetworkId(guestConfig.getId());                         long lbDeviceId = networkLBDevice.getExternalLBDeviceId();                         _networkExternalLBDao.remove(networkLBDevice.getId());                          List ntwksMapped = _networkExternalLBDao.listByLoadBalancerDeviceId(networkLBDevice.getExternalLBDeviceId());                         ExternalLoadBalancerDeviceVO lbDevice = _externalLoadBalancerDeviceDao.findById(lbDeviceId);                         boolean lbInUse = !(ntwksMapped == null || ntwksMapped.isEmpty());                         boolean lbCloudManaged = lbDevice.getIsManagedDevice();                          if (!lbInUse &amp;&amp; !lbCloudManaged) {                             // this is the last network mapped to the load balancer device so set device allocation state to be free                             lbDevice.setAllocationState(LBDeviceAllocationState.Free);                             _externalLoadBalancerDeviceDao.update(lbDevice.getId(), lbDevice);                         }                          // commit the changes before sending agent command to destroy cloudstack managed LB                         if (!lbInUse &amp;&amp; lbCloudManaged) {                             return lbDevice;                         } else {                             return null;                         }                     }                 });                  if (lbDevice != null) {                     // send DestroyLoadBalancerApplianceCommand to the host where load balancer appliance is provisioned                     Host lbHost = _hostDao.findById(lbDevice.getHostId());                     String lbIP = lbHost.getPrivateIpAddress();                     DestroyLoadBalancerApplianceCommand lbDeleteCmd = new DestroyLoadBalancerApplianceCommand(lbIP);                     DestroyLoadBalancerApplianceAnswer answer = null;                     try {                         answer = (DestroyLoadBalancerApplianceAnswer)_agentMgr.easySend(lbDevice.getParentHostId(), lbDeleteCmd);                         if (answer == null || !answer.getResult()) {                             s_logger.warn(&quot;Failed to destoy load balancer appliance used by the network&quot;                                     + guestConfig.getId() + &quot; due to &quot; + answer == null ? &quot;communication error with agent&quot;                                     : answer.getDetails());                         }                     } catch (Exception e) {                         s_logger.warn(&quot;Failed to destroy load balancer appliance used by the network&quot; + guestConfig.getId() + &quot; due to &quot; + e.getMessage());                     }                      if (s_logger.isDebugEnabled()) {                         s_logger.debug(&quot;Successfully destroyed load balancer appliance used for the network&quot; + guestConfig.getId());                     }                     deviceMapLock.unlock();                      // remove the provisioned load balancer appliance from cloudstack                     deleteExternalLoadBalancer(lbHost.getId());                      // release the private IP back to dc pool, as the load balancer appliance is now destroyed                     _dcDao.releasePrivateIpAddress(lbHost.getPrivateIpAddress(), guestConfig.getDataCenterId(), null);                      // release the public IP allocated for this LB appliance                     DetailVO publicIpDetail = _hostDetailDao.findDetail(lbHost.getId(), &quot;publicip&quot;);                     IPAddressVO ipVo = _ipAddressDao.findByIpAndDcId(guestConfig.getDataCenterId(), publicIpDetail.toString());                     _ipAddrMgr.disassociatePublicIpAddress(ipVo.getId(), _accountMgr.getSystemUser().getId(), _accountMgr.getSystemAccount());                 } else {                     deviceMapLock.unlock();                 }                  return true;             } else {                 s_logger.error(&quot;Failed to release load balancer device for the network&quot; + guestConfig.getId() + &quot;as failed to acquire lock &quot;);                 return false;             }         } catch (Exception exception) {             s_logger.error(&quot;Failed to release load balancer device for the network&quot; + guestConfig.getId() + &quot; due to &quot; + exception.getMessage());         } finally {             deviceMapLock.releaseRef();         }          return false;     }      private void applyStaticNatRuleForInlineLBRule(DataCenterVO zone, Network network, boolean revoked, String publicIp, String privateIp)         throws ResourceUnavailableException {         List staticNats = new ArrayList();         IPAddressVO ipVO = _ipAddressDao.listByDcIdIpAddress(zone.getId(), publicIp).get(0);         StaticNatImpl staticNat = new StaticNatImpl(ipVO.getAllocatedToAccountId(), ipVO.getAllocatedInDomainId(), network.getId(), ipVO.getId(), privateIp, revoked);         staticNats.add(staticNat);         StaticNatServiceProvider element = _networkMgr.getStaticNatProviderForNetwork(network);         element.applyStaticNats(network, staticNats);     }      private enum MappingState {         Create, Remove, Unchanged,     };      private class MappingNic {         private Nic nic;         private MappingState state;          public Nic getNic() {             return nic;         }          public void setNic(Nic nic) {             this.nic = nic;         }          public MappingState getState() {             return state;         }          public void setState(MappingState state) {             this.state = state;         }     };      private MappingNic getLoadBalancingIpNic(DataCenterVO zone, Network network, long sourceIpId, boolean revoked, String existedGuestIp)         throws ResourceUnavailableException {         String srcIp = _networkModel.getIp(sourceIpId).getAddress().addr();         InlineLoadBalancerNicMapVO mapping = _inlineLoadBalancerNicMapDao.findByPublicIpAddress(srcIp);         Nic loadBalancingIpNic = null;         MappingNic nic = new MappingNic();         nic.setState(MappingState.Unchanged);         if (!revoked) {             if (mapping == null) {                 // Acquire a new guest IP address and save it as the load balancing IP address                 String loadBalancingIpAddress = existedGuestIp;                  if (loadBalancingIpAddress == null) {                     if (network.getGuestType() == Network.GuestType.Isolated) {                         loadBalancingIpAddress = _ipAddrMgr.acquireGuestIpAddress(network, null);                     } else if (network.getGuestType() == Network.GuestType.Shared) {                         try {                             PublicIp directIp =                                 _ipAddrMgr.assignPublicIpAddress(network.getDataCenterId(), null, _accountDao.findById(network.getAccountId()), VlanType.DirectAttached,                                     network.getId(), null, true, false);                             loadBalancingIpAddress = directIp.getAddress().addr();                         } catch (InsufficientCapacityException capException) {                             String msg = &quot;Ran out of guest IP addresses from the shared network.&quot;;                             s_logger.error(msg);                             throw new ResourceUnavailableException(msg, DataCenter.class, network.getDataCenterId());                         }                     }                 }                  if (loadBalancingIpAddress == null) {                     String msg = &quot;Ran out of guest IP addresses.&quot;;                     s_logger.error(msg);                     throw new ResourceUnavailableException(msg, DataCenter.class, network.getDataCenterId());                 }                  // If a NIC doesn't exist for the load balancing IP address, create one                 loadBalancingIpNic = _nicDao.findByIp4AddressAndNetworkId(loadBalancingIpAddress, network.getId());                 if (loadBalancingIpNic == null) {                     loadBalancingIpNic = _networkMgr.savePlaceholderNic(network, loadBalancingIpAddress, null, null);                 }                  // Save a mapping between the source IP address and the load balancing IP address NIC                 mapping = new InlineLoadBalancerNicMapVO(srcIp, loadBalancingIpNic.getId());                 _inlineLoadBalancerNicMapDao.persist(mapping);                  // On the firewall provider for the network, create a static NAT rule between the source IP                 // address and the load balancing IP address                 try {                     applyStaticNatRuleForInlineLBRule(zone, network, revoked, srcIp, loadBalancingIpNic.getIPv4Address());                 } catch (ResourceUnavailableException ex) {                     // Rollback db operation                     _inlineLoadBalancerNicMapDao.expunge(mapping.getId());                     _nicDao.expunge(loadBalancingIpNic.getId());                     throw ex;                 }                  s_logger.debug(&quot;Created static nat rule for inline load balancer&quot;);                 nic.setState(MappingState.Create);             } else {                 loadBalancingIpNic = _nicDao.findById(mapping.getNicId());             }         } else {             if (mapping != null) {                 // Find the NIC that the mapping refers to                 loadBalancingIpNic = _nicDao.findById(mapping.getNicId());                  int count = _ipAddrMgr.getRuleCountForIp(sourceIpId, Purpose.LoadBalancing, FirewallRule.State.Active);                 if (count == 0) {                     // On the firewall provider for the network, delete the static NAT rule between the source IP                     // address and the load balancing IP address                     applyStaticNatRuleForInlineLBRule(zone, network, revoked, srcIp, loadBalancingIpNic.getIPv4Address());                      // Delete the mapping between the source IP address and the load balancing IP address                     _inlineLoadBalancerNicMapDao.expunge(mapping.getId());                      // Delete the NIC                     _nicDao.expunge(loadBalancingIpNic.getId());                      s_logger.debug(&quot;Revoked static nat rule for inline load balancer&quot;);                     nic.setState(MappingState.Remove);                 }             } else {                 s_logger.debug(&quot;Revoking a rule for an inline load balancer that has not been programmed yet.&quot;);                 nic.setNic(null);                 return nic;             }         }          nic.setNic(loadBalancingIpNic);         return nic;     }      public boolean isNccServiceProvider(Network network) {         NetworkOffering networkOffering = _networkOfferingDao.findById(network.getNetworkOfferingId());         if(null!= networkOffering &amp;&amp; networkOffering.getServicePackage() != null ) {             return true;         }         else {             return false;         }     }      public HostVO getNetScalerControlCenterForNetwork(Network guestConfig) {         long zoneId = guestConfig.getDataCenterId();         return _hostDao.findByTypeNameAndZoneId(zoneId, &quot;NetscalerControlCenter&quot;, Type.NetScalerControlCenter);     }      @Override     public boolean applyLoadBalancerRules(Network network, List loadBalancingRules) throws ResourceUnavailableException {         // Find the external load balancer in this zone         long zoneId = network.getDataCenterId();         DataCenterVO zone = _dcDao.findById(zoneId);          if (loadBalancingRules == null || loadBalancingRules.isEmpty()) {             return true;         }          HostVO externalLoadBalancer = null;          if(isNccServiceProvider(network)) {             externalLoadBalancer  = getNetScalerControlCenterForNetwork(network);         } else {             ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(network);             if (lbDeviceVO == null) {                 s_logger.warn(&quot;There is no external load balancer device assigned to this network either network is not implement are already shutdown so just returning&quot;);                 return true;             } else {                 externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());             }         }            boolean externalLoadBalancerIsInline = _networkMgr.isNetworkInlineMode(network);          if (network.getState() == Network.State.Allocated) {             s_logger.debug(&quot;External load balancer was asked to apply LB rules for network with ID &quot; + network.getId() +                 &quot;; this network is not implemented. Skipping backend commands.&quot;);             return true;         }          List loadBalancersToApply = new ArrayList();         List mappingStates = new ArrayList();         for (int i = 0; i &lt; loadBalancingRules.size(); i++) {             LoadBalancingRule rule = loadBalancingRules.get(i);              boolean revoked = (rule.getState().equals(FirewallRule.State.Revoke));             String protocol = rule.getProtocol();             String algorithm = rule.getAlgorithm();             String uuid = rule.getUuid();             String srcIp = rule.getSourceIp().addr();             String srcIpVlan = null;             String srcIpGateway = null;             String srcIpNetmask = null;             Long vlanid =  _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getVlanId();             if(vlanid != null ) {               VlanVO publicVlan =   _vlanDao.findById(vlanid);               srcIpVlan =  publicVlan.getVlanTag();               srcIpGateway = publicVlan.getVlanGateway();               srcIpNetmask = publicVlan.getVlanNetmask();             }             int srcPort = rule.getSourcePortStart();             List destinations = rule.getDestinations();              if (externalLoadBalancerIsInline) {                 long ipId = _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getId();                 MappingNic nic = getLoadBalancingIpNic(zone, network, ipId, revoked, null);                 mappingStates.add(nic.getState());                 Nic loadBalancingIpNic = nic.getNic();                 if (loadBalancingIpNic == null) {                     continue;                 }                  // Change the source IP address for the load balancing rule to be the load balancing IP address                 srcIp = loadBalancingIpNic.getIPv4Address();             }              if ((destinations != null &amp;&amp; !destinations.isEmpty()) || rule.isAutoScaleConfig()) {                 boolean inline = _networkMgr.isNetworkInlineMode(network);                 LoadBalancerTO loadBalancer =                     new LoadBalancerTO(uuid, srcIp, srcPort, protocol, algorithm, revoked, false, inline, destinations, rule.getStickinessPolicies(),                         rule.getHealthCheckPolicies(), rule.getLbSslCert(), rule.getLbProtocol());                 loadBalancer.setNetworkId(network.getId());                 loadBalancer.setSrcIpVlan(srcIpVlan);                 loadBalancer.setSrcIpNetmask(srcIpNetmask);                 loadBalancer.setSrcIpGateway(srcIpGateway);                 if (rule.isAutoScaleConfig()) {                     loadBalancer.setAutoScaleVmGroup(rule.getAutoScaleVmGroup());                 }                 loadBalancersToApply.add(loadBalancer);             }         }          try {             if (loadBalancersToApply.size() &gt; 0) {                 int numLoadBalancersForCommand = loadBalancersToApply.size();                 LoadBalancerTO[] loadBalancersForCommand = loadBalancersToApply.toArray(new LoadBalancerTO[numLoadBalancersForCommand]);                 LoadBalancerConfigCommand cmd = new LoadBalancerConfigCommand(loadBalancersForCommand, null);                 long guestVlanTag = Integer.parseInt(BroadcastDomainType.getValue(network.getBroadcastUri()));                 cmd.setAccessDetail(NetworkElementCommand.GUEST_VLAN_TAG, String.valueOf(guestVlanTag));                 Answer answer = _agentMgr.easySend(externalLoadBalancer.getId(), cmd);                 if (answer == null || !answer.getResult()) {                     String details = (answer != null) ? answer.getDetails() : &quot;details unavailable&quot;;                     String msg = &quot;Unable to apply load balancer rules to the external load balancer appliance in zone &quot; + zone.getName() + &quot; due to: &quot; + details + &quot;.&quot;;                     s_logger.error(msg);                     throw new ResourceUnavailableException(msg, DataCenter.class, network.getDataCenterId());                 }             }         } catch (Exception ex) {             if (externalLoadBalancerIsInline) {                 s_logger.error(&quot;Rollbacking static nat operation of inline mode load balancing due to error on applying LB rules!&quot;);                 String existedGuestIp = loadBalancersToApply.get(0).getSrcIp();                 // Rollback static NAT operation in current session                 for (int i = 0; i &lt; loadBalancingRules.size(); i++) {                     LoadBalancingRule rule = loadBalancingRules.get(i);                     MappingState state = mappingStates.get(i);                     boolean revoke;                     if (state == MappingState.Create) {                         revoke = true;                     } else if (state == MappingState.Remove) {                         revoke = false;                     } else {                         continue;                     }                     long sourceIpId = _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getId();                     getLoadBalancingIpNic(zone, network, sourceIpId, revoke, existedGuestIp);                 }             }             throw new ResourceUnavailableException(ex.getMessage(), DataCenter.class, network.getDataCenterId());         }          return true;     }      @Override     public boolean manageGuestNetworkWithExternalLoadBalancer(boolean add, Network guestConfig) throws ResourceUnavailableException, InsufficientCapacityException {         if (guestConfig.getTrafficType() != TrafficType.Guest) {             s_logger.trace(&quot;External load balancer can only be used for guest networks.&quot;);             return false;         }          long zoneId = guestConfig.getDataCenterId();         DataCenterVO zone = _dcDao.findById(zoneId);         HostVO externalLoadBalancer = null;          if (add) {             ExternalLoadBalancerDeviceVO lbDeviceVO = null;             // on restart network, device could have been allocated already, skip allocation if a device is assigned             lbDeviceVO = getExternalLoadBalancerForNetwork(guestConfig);             if (lbDeviceVO == null) {                 // allocate a load balancer device for the network                 lbDeviceVO = allocateLoadBalancerForNetwork(guestConfig);                 if (lbDeviceVO == null) {                     String msg = &quot;failed to alloacate a external load balancer for the network &quot; + guestConfig.getId();                     s_logger.error(msg);                     throw new InsufficientNetworkCapacityException(msg, DataCenter.class, guestConfig.getDataCenterId());                 }             }             externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());             s_logger.debug(&quot;Allocated external load balancer device:&quot; + lbDeviceVO.getId() + &quot; for the network: &quot; + guestConfig.getId());         } else {             // find the load balancer device allocated for the network             ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(guestConfig);             if (lbDeviceVO == null) {                 s_logger.warn(&quot;Network shutdwon requested on external load balancer element, which did not implement the network.&quot;                     + &quot; Either network implement failed half way through or already network shutdown is completed. So just returning.&quot;);                 return true;             }              externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());             assert (externalLoadBalancer != null) : &quot;There is no device assigned to this network how did shutdown network ended up here??&quot;;         }          // Send a command to the external load balancer to implement or shutdown the guest network         String guestVlanTag = BroadcastDomainType.getValue(guestConfig.getBroadcastUri());         String selfIp = null;         String guestVlanNetmask = NetUtils.cidr2Netmask(guestConfig.getCidr());         Integer networkRate = _networkModel.getNetworkRate(guestConfig.getId(), null);          if (add) {             // on restart network, network could have already been implemented. If already implemented then return             Nic selfipNic = getPlaceholderNic(guestConfig);             if (selfipNic != null) {                 return true;             }              // Acquire a self-ip address from the guest network IP address range             selfIp = _ipAddrMgr.acquireGuestIpAddress(guestConfig, null);             if (selfIp == null) {                 String msg = &quot;failed to acquire guest IP address so not implementing the network on the external load balancer &quot;;                 s_logger.error(msg);                 throw new InsufficientNetworkCapacityException(msg, Network.class, guestConfig.getId());             }         } else {             // get the self-ip used by the load balancer             Nic selfipNic = getPlaceholderNic(guestConfig);             if (selfipNic == null) {                 s_logger.warn(&quot;Network shutdwon requested on external load balancer element, which did not implement the network.&quot;                     + &quot; Either network implement failed half way through or already network shutdown is completed. So just returning.&quot;);                 return true;             }             selfIp = selfipNic.getIPv4Address();         }          // It's a hack, using isOneToOneNat field for indicate if it's inline or not         boolean inline = _networkMgr.isNetworkInlineMode(guestConfig);         IpAddressTO ip =             new IpAddressTO(guestConfig.getAccountId(), null, add, false, true, guestVlanTag, selfIp, guestVlanNetmask, null, networkRate, inline);         IpAddressTO[] ips = new IpAddressTO[1];         ips[0] = ip;         IpAssocCommand cmd = new IpAssocCommand(ips);         Answer answer = _agentMgr.easySend(externalLoadBalancer.getId(), cmd);          if (answer == null || !answer.getResult()) {             String action = add ? &quot;implement&quot; : &quot;shutdown&quot;;             String answerDetails = (answer != null) ? answer.getDetails() : null;             answerDetails = (answerDetails != null) ? &quot; due to &quot; + answerDetails : &quot;&quot;;             String msg = &quot;External load balancer was unable to &quot; + action + &quot; the guest network on the external load balancer in zone &quot; + zone.getName() + answerDetails;             s_logger.error(msg);             throw new ResourceUnavailableException(msg, Network.class, guestConfig.getId());         }          if (add) {             // Insert a new NIC for this guest network to reserve the self IP             _networkMgr.savePlaceholderNic(guestConfig, selfIp, null, null);         } else {             // release the self-ip obtained from guest network             Nic selfipNic = getPlaceholderNic(guestConfig);             _nicDao.remove(selfipNic.getId());              // release the load balancer allocated for the network             boolean releasedLB = freeLoadBalancerForNetwork(guestConfig);             if (!releasedLB) {                 String msg = &quot;Failed to release the external load balancer used for the network: &quot; + guestConfig.getId();                 s_logger.error(msg);             }         }          if (s_logger.isDebugEnabled()) {             Account account = _accountDao.findByIdIncludingRemoved(guestConfig.getAccountId());             String action = add ? &quot;implemented&quot; : &quot;shut down&quot;;             s_logger.debug(&quot;External load balancer has &quot; + action + &quot; the guest network for account &quot; + account.getAccountName() + &quot;(id = &quot; + account.getAccountId() +                 &quot;) with VLAN tag &quot; + guestVlanTag);         }          return true;     }      @Override     public boolean configure(String name, Map params) throws ConfigurationException {         super.configure(name, params);         _defaultLbCapacity = NumbersUtil.parseLong(_configDao.getValue(Config.DefaultExternalLoadBalancerCapacity.key()), 50);         _resourceMgr.registerResourceStateAdapter(this.getClass().getSimpleName(), this);         return true;     }      @Override     public boolean start() {         return true;     }      @Override     public boolean stop() {         return true;     }      @Override     public HostVO createHostVOForConnectedAgent(HostVO host, StartupCommand[] cmd) {         // TODO Auto-generated method stub         return null;     }      @Override     public HostVO createHostVOForDirectConnectAgent(HostVO host, StartupCommand[] startup, ServerResource resource, Map details, List hostTags) {         if (!(startup[0] instanceof StartupExternalLoadBalancerCommand)) {             return null;         }         if(host.getName().equalsIgnoreCase(&quot;NetScalerControlCenter&quot;)) {             host.setType(Host.Type.NetScalerControlCenter);         }         else {             host.setType(Host.Type.ExternalLoadBalancer);         }         return host;     }      @Override     public DeleteHostAnswer deleteHost(HostVO host, boolean isForced, boolean isForceDeleteStorage) throws UnableDeleteHostException {         if (host.getType() != com.cloud.host.Host.Type.ExternalLoadBalancer) {             return null;         }         return new DeleteHostAnswer(true);     }      protected IpDeployer getIpDeployerForInlineMode(Network network) {         //We won't deploy IP, instead the firewall in front of us would do it         List providers = _networkMgr.getProvidersForServiceInNetwork(network, Service.Firewall);         //Only support one provider now         if (providers == null) {             s_logger.error(&quot;Cannot find firewall provider for network &quot; + network.getId());             return null;         }         if (providers.size() != 1) {             s_logger.error(&quot;Found &quot; + providers.size() + &quot; firewall provider for network &quot; + network.getId());             return null;         }          NetworkElement element = _networkModel.getElementImplementingProvider(providers.get(0).getName());         if (!(element instanceof IpDeployer)) {             s_logger.error(&quot;The firewall provider for network &quot; + network.getName() + &quot; don't have ability to deploy IP address!&quot;);             return null;         }         s_logger.info(&quot;Let &quot; + element.getName() + &quot; handle ip association for &quot; + getName() + &quot; in network &quot; + network.getId());         return (IpDeployer)element;     }      @Override     public List getLBHealthChecks(Network network, List loadBalancingRules) throws ResourceUnavailableException {          // Find the external load balancer in this zone         long zoneId = network.getDataCenterId();         DataCenterVO zone = _dcDao.findById(zoneId);          if (loadBalancingRules == null || loadBalancingRules.isEmpty()) {             return null;         }          HostVO externalLoadBalancer = null;          if(isNccServiceProvider(network)) {             externalLoadBalancer  = getNetScalerControlCenterForNetwork(network);         } else {             ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(network);             if (lbDeviceVO == null) {                 s_logger.warn(&quot;There is no external load balancer device assigned to this network either network is not implement are already shutdown so just returning&quot;);                 return null;             } else {                 externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());             }         }          boolean externalLoadBalancerIsInline = _networkMgr.isNetworkInlineMode(network);          if (network.getState() == Network.State.Allocated) {             s_logger.debug(&quot;External load balancer was asked to apply LB rules for network with ID &quot; + network.getId() +                 &quot;; this network is not implemented. Skipping backend commands.&quot;);             return null;         }          List loadBalancersToApply = new ArrayList();         List mappingStates = new ArrayList();         for (final LoadBalancingRule rule : loadBalancingRules) {             boolean revoked = (FirewallRule.State.Revoke.equals(rule.getState()));             String protocol = rule.getProtocol();             String algorithm = rule.getAlgorithm();             String uuid = rule.getUuid();             String srcIp = rule.getSourceIp().addr();             int srcPort = rule.getSourcePortStart();             List destinations = rule.getDestinations();              if (externalLoadBalancerIsInline) {                 long sourceIpId = _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getId();                 MappingNic nic = getLoadBalancingIpNic(zone, network, sourceIpId, revoked, null);                 mappingStates.add(nic.getState());                 Nic loadBalancingIpNic = nic.getNic();                 if (loadBalancingIpNic == null) {                     continue;                 }                  // Change the source IP address for the load balancing rule to                 // be the load balancing IP address                 srcIp = loadBalancingIpNic.getIPv4Address();             }              if ((destinations != null &amp;&amp; !destinations.isEmpty()) || !rule.isAutoScaleConfig()) {                 boolean inline = _networkMgr.isNetworkInlineMode(network);                 LoadBalancerTO loadBalancer =                     new LoadBalancerTO(uuid, srcIp, srcPort, protocol, algorithm, revoked, false, inline, destinations, rule.getStickinessPolicies(),                         rule.getHealthCheckPolicies(), rule.getLbSslCert(), rule.getLbProtocol());                 loadBalancersToApply.add(loadBalancer);             }         }          try {             if (loadBalancersToApply.size() &gt; 0) {                 int numLoadBalancersForCommand = loadBalancersToApply.size();                 LoadBalancerTO[] loadBalancersForCommand = loadBalancersToApply.toArray(new LoadBalancerTO[numLoadBalancersForCommand]);                 HealthCheckLBConfigCommand cmd = new HealthCheckLBConfigCommand(loadBalancersForCommand, network.getId());                 long guestVlanTag = Integer.parseInt(BroadcastDomainType.getValue(network.getBroadcastUri()));                 cmd.setAccessDetail(NetworkElementCommand.GUEST_VLAN_TAG, String.valueOf(guestVlanTag));                  HealthCheckLBConfigAnswer answer = (HealthCheckLBConfigAnswer) _agentMgr.easySend(externalLoadBalancer.getId(), cmd);                 // easySend will return null on error                 return answer == null ? null : answer.getLoadBalancers();             }         } catch (Exception ex) {             s_logger.error(&quot;Exception Occured &quot;, ex);         }         //null return is handled by clients         return null;     }      private NicVO getPlaceholderNic(Network network) {         List guestIps = _nicDao.listByNetworkId(network.getId());         for (NicVO guestIp : guestIps) {             // only external firewall and external load balancer will create NicVO with PlaceHolder reservation strategy             if (guestIp.getReservationStrategy().equals(ReservationStrategy.PlaceHolder) &amp;&amp; guestIp.getVmType() == null &amp;&amp; guestIp.getReserver() == null &amp;&amp;                 !guestIp.getIPv4Address().equals(network.getGateway())) {                 return guestIp;             }         }         return null;     }  }</td>
    <td align="left">blob</td>
    <td align="left">&nbsp;Blob, 2 Long Method, 3 Long Parameter List, 4 Data Class, 5 Feature Envy, 6 Long Method, 7 Long Parameter List, 8 Data Class, 9 Feature Envy, </td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;2. Long Method,  3. Long Parameter List,  4. Data Class,  5. Feature Envy,  6. Long Method,  7. Long Parameter List,  8. Data Class,  9. Feature Envy,  </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2053</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/server/src/main/java/com/cloud/network/ExternalLoadBalancerDeviceManagerImpl.java/#L141-L1311</td>
    <td align="right">1</td>
    <td align="right">177</td>
    <td align="right">2053</td>
  </tr>
  <tr valign="top">
    <td align="right">185</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;the bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private static class Map4 extends Map3 {         /** */         private static final long serialVersionUID = 0L;          /** */         protected K k4;          /** */         protected V v4;          /**          * Constructs map.          */         Map4() {             // No-op.         }          /**          * Constructs map.          *          * @param k1 Key1.          * @param v1 Value1.          * @param k2 Key2.          * @param v2 Value2.          * @param k3 Key3.          * @param v3 Value3.          * @param k4 Key4.          * @param v4 Value4.          */         Map4(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {             super(k1, v1, k2, v2, k3, v3);              this.k4 = k4;             this.v4 = v4;         }          /** {@inheritDoc} */         @Override public boolean isFull() {             return size() == 4;         }          /** {@inheritDoc} */         @Nullable @Override public V remove(Object key) {             if (F.eq(key, k4)) {                 V res = v4;                  v4 = null;                 k4 = null;                  return res;             }              return super.remove(key);         }          /** {@inheritDoc} */         @Override public int size() {             return super.size() + (k4 != null ? 1 : 0);         }          /** {@inheritDoc} */         @Override public boolean containsKey(Object k) {             return super.containsKey(k) || (k4 != null &amp;&amp; F.eq(k, k4));         }          /** {@inheritDoc} */         @Override public boolean containsValue(Object v) {             return super.containsValue(v) || (k4 != null &amp;&amp; F.eq(v, v4));         }          /** {@inheritDoc} */         @Nullable @Override public V get(Object k) {             V v = super.get(k);              return v != null ? v : (k4 != null &amp;&amp; F.eq(k, k4)) ? v4 : null;         }          /**          * Puts key-value pair into map only if given key is already contained in the map          * or there are free slots.          * Note that this implementation of {@link Map#put(Object, Object)} does not match          * general contract of {@link Map} interface and serves only for internal purposes.          *          * @param key Key.          * @param val Value.          * @return Previous value associated with given key.          */         @Nullable @Override public V put(K key, V val) throws NullPointerException {             V oldVal = get(key);              if (k1 == null || F.eq(k1, key)) {                 k1 = key;                 v1 = val;             }             else if (k2 == null || F.eq(k2, key)) {                 k2 = key;                 v2 = val;             }             else if (k3 == null || F.eq(k3, key)) {                 k3 = key;                 v3 = val;             }             else if (k4 == null || F.eq(k4, key)) {                 k4 = key;                 v4 = val;             }              return oldVal;         }          /** {@inheritDoc} */         @Override public Set&gt; entrySet() {             return new AbstractSet&gt;() {                 @Override public Iterator&gt; iterator() {                     return new Iterator&gt;() {                         private int idx;                          private Entry next;                          {                             if (k1 != null) {                                 idx = 1;                                 next = e(k1, v1);                             }                             else if (k2 != null) {                                 idx = 2;                                 next = e(k2, v2);                             }                             else if (k3 != null) {                                 idx = 3;                                 next = e(k3, v3);                             }                             else if (k4 != null) {                                 idx = 4;                                 next = e(k4, v4);                             }                         }                          @Override public boolean hasNext() {                             return next != null;                         }                          @SuppressWarnings(&quot;fallthrough&quot;)                         @Override public Entry next() {                             if (!hasNext())                                 throw new NoSuchElementException();                              Entry old = next;                              next = null;                              switch (idx) {                                 case 1:                                     if (k2 != null) {                                         idx = 2;                                         next = e(k2, v2);                                          break;                                     }                                  case 2:                                     if (k3 != null) {                                         idx = 3;                                         next = e(k3, v3);                                          break;                                     }                                  case 3:                                     if (k4 != null) {                                         idx = 4;                                         next = e(k4, v4);                                          break;                                     }                             }                              return old;                         }                          @Override public void remove() {                             throw new UnsupportedOperationException();                         }                     };                 }                  @Override public int size() {                     return Map4.this.size();                 }             };         }     }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2110</td>
    <td align="left">https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/core/src/main/java/org/apache/ignite/internal/util/GridLeanMap.java/#L836-L1027</td>
    <td align="right">1</td>
    <td align="right">185</td>
    <td align="right">2110</td>
  </tr>
  <tr valign="top">
    <td align="right">196</td>
    <td align="left">&nbsp;{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Blob&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class MissedUpdatesFinder extends MissedUpdatesFinderBase {     private long ourHighThreshold; // 80th percentile     private long ourHighest;  // currently just used for logging/debugging purposes     private String logPrefix;     private long nUpdates;      MissedUpdatesFinder(List ourUpdates, String logPrefix, long nUpdates,                         long ourLowThreshold, long ourHighThreshold) {       super(ourUpdates, ourLowThreshold);        this.logPrefix = logPrefix;       this.ourHighThreshold = ourHighThreshold;       this.ourHighest = ourUpdates.get(0);       this.nUpdates = nUpdates;     }      public MissedUpdatesRequest find(List otherVersions, Object updateFrom, Supplier canHandleVersionRanges) {       otherVersions.sort(absComparator);       if (debug) {         log.debug(&quot;{} sorted versions from {} = {}&quot;, logPrefix, otherVersions, updateFrom);       }        long otherHigh = percentile(otherVersions, .2f);       long otherLow = percentile(otherVersions, .8f);       long otherHighest = otherVersions.get(0);        if (ourHighThreshold &lt; otherLow) {         // Small overlap between version windows and ours is older         // This means that we might miss updates if we attempted to use this method.         // Since there exists just one replica that is so much newer, we must         // fail the sync.         log.info(&quot;{} Our versions are too old. ourHighThreshold={} otherLowThreshold={} ourHighest={} otherHighest={}&quot;,             logPrefix, ourHighThreshold, otherLow, ourHighest, otherHighest);         return MissedUpdatesRequest.UNABLE_TO_SYNC;       }        if (ourLowThreshold &gt; otherHigh &amp;&amp; ourHighest &gt;= otherHighest) {         // Small overlap between windows and ours is newer.         // Using this list to sync would result in requesting/replaying results we don't need         // and possibly bringing deleted docs back to life.         log.info(&quot;{} Our versions are newer. ourHighThreshold={} otherLowThreshold={} ourHighest={} otherHighest={}&quot;,             logPrefix, ourHighThreshold, otherLow, ourHighest, otherHighest);          // Because our versions are newer, IndexFingerprint with the remote would not match us.         // We return true on our side, but the remote peersync with us should fail.         return MissedUpdatesRequest.ALREADY_IN_SYNC;       }        boolean completeList = otherVersions.size() &lt; nUpdates;        MissedUpdatesRequest updatesRequest;       if (canHandleVersionRanges.get()) {         updatesRequest = handleVersionsWithRanges(otherVersions, completeList);       } else {         updatesRequest = handleIndividualVersions(otherVersions, completeList);       }        if (updatesRequest.totalRequestedUpdates &gt; nUpdates) {         log.info(&quot;{} PeerSync will fail because number of missed updates is more than:{}&quot;, logPrefix, nUpdates);         return MissedUpdatesRequest.UNABLE_TO_SYNC;       }        if (updatesRequest == MissedUpdatesRequest.EMPTY) {         log.info(&quot;{} No additional versions requested. ourHighThreshold={} otherLowThreshold={} ourHighest={} otherHighest={}&quot;,             logPrefix, ourHighThreshold, otherLow, ourHighest, otherHighest);       }        return updatesRequest;     }   }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2236</td>
    <td align="left">https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/solr/core/src/java/org/apache/solr/update/PeerSync.java/#L787-L856</td>
    <td align="right">1</td>
    <td align="right">196</td>
    <td align="right">2236</td>
  </tr>
  <tr valign="top">
    <td align="right">206</td>
    <td align="left">&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Blob&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TruffleNFI_DLL implements DLLRFFI {      public static final class NFIHandle implements LibHandle {         @SuppressWarnings(&quot;unused&quot;) private final String libName;         final TruffleObject libHandle;          NFIHandle(String libName, TruffleObject libHandle) {             this.libName = libName;             this.libHandle = libHandle;         }          @Override         public Type getRFFIType() {             return RFFIFactory.Type.NFI;         }     }      private static final class TruffleNFI_DLOpenNode extends Node implements DLLRFFI.DLOpenNode {          @Override         @TruffleBoundary         public LibHandle execute(String path, boolean local, boolean now) {             String librffiPath = LibPaths.getBuiltinLibPath(&quot;R&quot;);             // Do not call before/afterDowncall when loading libR to prevent the pushing/popping of             // the callback array, which requires that the libR have already been loaded             boolean notifyStateRFFI = !librffiPath.equals(path);             long before = notifyStateRFFI ? RContext.getInstance().getStateRFFI().beforeDowncall(RFFIFactory.Type.NFI) : 0;             try {                 String libName = DLL.libName(path);                 Env env = RContext.getInstance().getEnv();                 TruffleObject libHandle = (TruffleObject) env.parse(Source.newBuilder(&quot;nfi&quot;, prepareLibraryOpen(path, local, now), path).build()).call();                 return new NFIHandle(libName, libHandle);             } finally {                 if (notifyStateRFFI) {                     RContext.getInstance().getStateRFFI().afterDowncall(before, RFFIFactory.Type.NFI);                 }             }         }     }      @TruffleBoundary     private static String prepareLibraryOpen(String path, boolean local, boolean now) {         StringBuilder sb = new StringBuilder(&quot;load&quot;);         sb.append(&quot;(&quot;);         sb.append(local ? &quot;RTLD_LOCAL&quot; : &quot;RTLD_GLOBAL&quot;);         sb.append('|');         sb.append(now ? &quot;RTLD_NOW&quot; : &quot;RTLD_LAZY&quot;);         sb.append(&quot;) \&quot;&quot;);         sb.append(path);         sb.append('&quot;');         return sb.toString();     }      private static class TruffleNFI_DLSymNode extends Node implements DLLRFFI.DLSymNode {          @Child private Node lookupSymbol;          @Override         @TruffleBoundary         public SymbolHandle execute(Object handle, String symbol) {             assert handle instanceof NFIHandle;             NFIHandle nfiHandle = (NFIHandle) handle;             if (lookupSymbol == null) {                 CompilerDirectives.transferToInterpreterAndInvalidate();                 lookupSymbol = insert(Message.READ.createNode());             }             try {                 TruffleObject result = (TruffleObject) ForeignAccess.sendRead(lookupSymbol, nfiHandle.libHandle, symbol);                 return new SymbolHandle(result);             } catch (UnknownIdentifierException e) {                 throw new UnsatisfiedLinkError();             } catch (InteropException e) {                 throw RInternalError.shouldNotReachHere();             }         }     }      private static class TruffleNFI_DLCloseNode extends Node implements DLLRFFI.DLCloseNode {          @Override         public int execute(Object handle) {             assert handle instanceof NFIHandle;             // TODO             return 0;         }     }      @Override     public DLOpenNode createDLOpenNode() {         return new TruffleNFI_DLOpenNode();     }      @Override     public DLSymNode createDLSymNode() {         return new TruffleNFI_DLSymNode();     }      @Override     public DLCloseNode createDLCloseNode() {         return new TruffleNFI_DLCloseNode();     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2304</td>
    <td align="left">https://github.com/oracle/fastr/blob/a1ee49060317621c0c9eceea8ec60040aca59b2d/com.oracle.truffle.r.ffi.impl/src/com/oracle/truffle/r/ffi/impl/nfi/TruffleNFI_DLL.java/#L44-L145</td>
    <td align="right">1</td>
    <td align="right">206</td>
    <td align="right">2304</td>
  </tr>
  <tr valign="top">
    <td align="right">208</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Long Method&quot;,         &quot;Blob&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class FastRTrace {      static final class Helper extends RBaseNode {         @Child private GetFunctions.Get getNode;         @Child private EnvFunctions.TopEnv topEnv;         @Child private FrameFunctions.ParentFrame parentFrame;          protected Object getWhere(VirtualFrame frame) {             if (topEnv == null) {                 CompilerDirectives.transferToInterpreterAndInvalidate();                 topEnv = insert(TopEnvNodeGen.create());             }             if (parentFrame == null) {                 CompilerDirectives.transferToInterpreterAndInvalidate();                 parentFrame = insert(ParentFrameNodeGen.create());             }             return topEnv.execute(frame, parentFrame.execute(frame, 1), RNull.instance);         }          protected Object getFunction(VirtualFrame frame, Object what, Object where) {             if (getNode == null) {                 CompilerDirectives.transferToInterpreterAndInvalidate();                 getNode = insert(GetNodeGen.create());             }             return getNode.execute(frame, what, where, RType.Function.getName(), true);         }          protected void checkWhat(Object what) {             if (what == RMissing.instance) {                 throw error(RError.Message.ARGUMENT_MISSING, &quot;what&quot;);             }         }          protected RFunction checkFunction(Object what) {             if (what instanceof RFunction) {                 RFunction func = (RFunction) what;                 if (func.isBuiltin()) {                     throw error(RError.Message.GENERIC, &quot;builtin functions cannot be traced&quot;);                 } else {                     return func;                 }             } else {                 throw error(RError.Message.ARG_MUST_BE_CLOSURE);             }         }     }      @RBuiltin(name = &quot;.fastr.trace&quot;, visibility = CUSTOM, kind = PRIMITIVE, parameterNames = {&quot;what&quot;, &quot;tracer&quot;, &quot;exit&quot;, &quot;at&quot;, &quot;print&quot;, &quot;signature&quot;, &quot;where&quot;}, behavior = COMPLEX)     public abstract static class Trace extends RBuiltinNode.Arg7 {          @Child private TraceFunctions.PrimTrace primTrace;         @Child private CastLogicalNode castLogical;         @Child private SetVisibilityNode visibility = SetVisibilityNode.create();         @Child private Helper helper = new Helper();          static {             Casts.noCasts(Trace.class);         }          @Specialization         protected Object trace(VirtualFrame frame, Object whatObj, Object tracer, Object exit, Object at, Object printObj, Object signature, Object whereObj) {             Object what = whatObj;             helper.checkWhat(what);             Object where = whereObj;             if (where == RMissing.instance) {                 where = helper.getWhere(frame);             }             String funcName = RRuntime.asString(what);             if (funcName != null) {                 what = helper.getFunction(frame, what, where);             }             RFunction func = helper.checkFunction(what);              if (tracer == RMissing.instance &amp;&amp; exit == RMissing.instance &amp;&amp; at == RMissing.instance &amp;&amp; printObj == RMissing.instance &amp;&amp; signature == RMissing.instance) {                 // simple case, nargs() == 1, corresponds to .primTrace that has invisible output                 if (primTrace == null) {                     CompilerDirectives.transferToInterpreterAndInvalidate();                     primTrace = insert(PrimTraceNodeGen.create());                 }                  Object result = primTrace.execute(frame, func);                 visibility.execute(frame, false);                 return result;             }              if (at != RMissing.instance) {                 throw RError.nyi(this, &quot;'at'&quot;);             }             boolean print = true;             if (printObj != RMissing.instance) {                 if (castLogical == null) {                     CompilerDirectives.transferToInterpreterAndInvalidate();                     castLogical = insert(CastLogicalNodeGen.create(false, false, false));                 }                 print = RRuntime.fromLogical((byte) castLogical.doCast(printObj));             }             complexCase(func, tracer, exit, at, print, signature);             visibility.execute(frame, true);             return Utils.toString(func);         }          @TruffleBoundary         private void complexCase(RFunction func, Object tracerObj, @SuppressWarnings(&quot;unused&quot;) Object exit, Object at, boolean print, @SuppressWarnings(&quot;unused&quot;) Object signature) {             // the complex case             RPairList tracer;             if (tracerObj instanceof RFunction) {                 Closure closure = Closure.createLanguageClosure(RASTUtils.createCall(tracerObj, false, ArgumentsSignature.empty(0)).asRNode());                 tracer = RDataFactory.createLanguage(closure);             } else if ((tracerObj instanceof RPairList &amp;&amp; ((RPairList) tracerObj).isLanguage())) {                 tracer = (RPairList) tracerObj;             } else {                 throw error(RError.Message.GENERIC, &quot;tracer is unexpected type&quot;);             }             TraceHandling.enableStatementTrace(func, tracer, at, print);         }     }      @RBuiltin(name = &quot;.fastr.untrace&quot;, visibility = OFF, kind = PRIMITIVE, parameterNames = {&quot;what&quot;, &quot;signature&quot;, &quot;where&quot;}, behavior = COMPLEX)     public abstract static class Untrace extends RBuiltinNode.Arg3 {          @Child private TraceFunctions.PrimUnTrace primUnTrace;         @Child private Helper helper = new Helper();          static {             Casts.noCasts(Untrace.class);         }          @Specialization         protected Object untrace(VirtualFrame frame, Object whatObj, Object signature, Object whereObj) {             Object what = whatObj;             helper.checkWhat(what);             Object where = whereObj;             if (where == RMissing.instance) {                 where = helper.getWhere(frame);             }             String funcName = RRuntime.asString(what);             if (funcName != null) {                 what = helper.getFunction(frame, what, where);             }             RFunction func = helper.checkFunction(what);             if (signature == RMissing.instance) {                 if (primUnTrace == null) {                     CompilerDirectives.transferToInterpreterAndInvalidate();                     primUnTrace = insert(PrimUnTraceNodeGen.create());                 }                 primUnTrace.execute(frame, func);             } else {                 throw RError.nyi(this, &quot;method tracing&quot;);             }              return Utils.toString(func);         }     } }</td>
    <td align="left">blob</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2310</td>
    <td align="left">https://github.com/oracle/fastr/blob/a1ee49060317621c0c9eceea8ec60040aca59b2d/com.oracle.truffle.r.nodes.builtin/src/com/oracle/truffle/r/nodes/builtin/fastr/FastRTrace.java/#L70-L223</td>
    <td align="right">1</td>
    <td align="right">208</td>
    <td align="right">2310</td>
  </tr>
  <tr valign="top">
    <td align="right">231</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;1. Blob&quot;,       &quot;2. Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class CrunchInputFormat extends InputFormat {    @Override   public List getSplits(JobContext job) throws IOException, InterruptedException {     List splits = Lists.newArrayList();     Configuration base = job.getConfiguration();     Map&gt;&gt; formatNodeMap = CrunchInputs.getFormatNodeMap(job);      // First, build a map of InputFormats to Paths     for (Map.Entry&gt;&gt; entry : formatNodeMap.entrySet()) {       FormatBundle inputBundle = entry.getKey();       Configuration conf = new Configuration(base);       inputBundle.configure(conf);       Job jobCopy = new Job(conf);       InputFormat format = (InputFormat) ReflectionUtils.newInstance(inputBundle.getFormatClass(),           jobCopy.getConfiguration());       if (format instanceof FileInputFormat &amp;&amp; !conf.getBoolean(RuntimeParameters.DISABLE_COMBINE_FILE, true)) {         format = new CrunchCombineFileInputFormat(jobCopy);       }       for (Map.Entry&gt; nodeEntry : entry.getValue().entrySet()) {         Integer nodeIndex = nodeEntry.getKey();         List paths = nodeEntry.getValue();         FileInputFormat.setInputPaths(jobCopy, paths.toArray(new Path[paths.size()]));          // Get splits for each input path and tag with InputFormat         // and Mapper types by wrapping in a TaggedInputSplit.         List pathSplits = format.getSplits(jobCopy);         for (InputSplit pathSplit : pathSplits) {           splits.add(new CrunchInputSplit(pathSplit, inputBundle, nodeIndex, jobCopy.getConfiguration()));         }       }     }     return splits;   }    @Override   public RecordReader createRecordReader(InputSplit inputSplit, TaskAttemptContext context) throws IOException,       InterruptedException {     return new CrunchRecordReader(inputSplit, context);   } }</td>
    <td align="left">blob</td>
    <td align="left">1. blob, 2. long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;2. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2520</td>
    <td align="left">https://github.com/apache/crunch/blob/9b8849cfd89f1e7f187b99914163509060692aa5/crunch-core/src/main/java/org/apache/crunch/impl/mr/run/CrunchInputFormat.java/#L39-L79</td>
    <td align="right">1</td>
    <td align="right">231</td>
    <td align="right">2520</td>
  </tr>
  <tr valign="top">
    <td align="right">234</td>
    <td align="left">{&quot;output&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class BasicUUID implements UUID, Formatable { 	/* 	** Fields of BasicUUID 	*/ 	 	private long majorId; // only using 48 bits 	private long timemillis; 	private int sequence;  	/* 	** Methods of BasicUUID 	*/  	/** 		Constructor only called by BasicUUIDFactory. 	**/ 	public BasicUUID(long majorId, long timemillis, int sequence) 	{ 		this.majorId = majorId; 		this.timemillis = timemillis; 		this.sequence = sequence; 	}  	/** 		Constructor only called by BasicUUIDFactory. 		Constructs a UUID from the string representation 		produced by toString. 		@see BasicUUID#toString 	**/ 	public BasicUUID(String uuidstring) 	{ 		StringReader sr = new StringReader(uuidstring); 		sequence = (int) readMSB(sr);  		long ltimemillis = readMSB(sr) &lt;&lt; 32; 		ltimemillis += readMSB(sr) &lt;&lt; 16; 		ltimemillis += readMSB(sr); 		timemillis = ltimemillis; 		majorId = readMSB(sr); 	}  	/* 	 * Formatable methods 	 */  	// no-arg constructor, required by Formatable  	public BasicUUID() { super(); }  	/** 		Write this out. 		@exception IOException error writing to log stream 	*/ 	public void writeExternal(ObjectOutput out) throws IOException  	{ 		out.writeLong(majorId); 		out.writeLong(timemillis); 		out.writeInt(sequence); 	}  	/** 		Read this in 		@exception IOException error reading from log stream 	*/ 	public void readExternal(ObjectInput in) throws IOException 	{ 		majorId = in.readLong(); 		timemillis = in.readLong(); 		sequence = in.readInt(); 	}  	/** 		Return my format identifier. 	*/ 	public int getTypeFormatId() { 		return StoredFormatIds.BASIC_UUID; 	}  	private static void writeMSB(char[] data, int offset, long value, int nbytes)     {     	for (int i = nbytes - 1; i &gt;= 0; i--) 		{ 		   long b = (value &amp; (255L &lt;&lt; (8 * i))) &gt;&gt;&gt; (8 * i);  		   int c = (int) ((b &amp; 0xf0) &gt;&gt; 4); 		   data[offset++] = (char) (c &lt; 10 ? c + '0' : (c - 10) + 'a'); 		   c = (int) (b &amp; 0x0f); 		   data[offset++] = (char) (c &lt; 10 ? c + '0' : (c - 10) + 'a'); 		}      }      /** 		Read a long value, msb first, from its character  		representation in the string reader, using '-' or 		end of string to delimit. 	**/ 	private static long readMSB(StringReader sr)     { 		long value = 0;  		try 		{ 			int c; 			while ((c = sr.read()) != -1) 			{ 				if (c == '-') 					break; 				value &lt;&lt;= 4;  				int nibble; 				if (c &lt;= '9') 					nibble = c - '0'; 				else if (c &lt;= 'F') 					nibble = c - 'A' + 10; 				else 					nibble = c - 'a' + 10; 				value += nibble; 			} 		} 		catch (Exception e) 		{ 		}  		return value;     }  	/* 	** Methods of UUID 	*/  	/** 		Implement value equality.  	**/ 	public boolean equals(Object otherObject) 	{ 		if (!(otherObject instanceof BasicUUID)) 			return false;  		BasicUUID other = (BasicUUID) otherObject;  		return (this.sequence == other.sequence) 			&amp;&amp; (this.timemillis == other.timemillis) 			&amp;&amp; (this.majorId == other.majorId); 	}  	/** 		Provide a hashCode which is compatible with 		the equals() method. 	**/ 	public int hashCode() 	{ 		long hc = majorId ^ timemillis;  		return sequence ^ ((int) (hc &gt;&gt; 4)); 	}  	/** 		Produce a string representation of this UUID which 		can be passed to UUIDFactory.recreateUUID later on 		to reconstruct it.  The funny representation is  		designed to (sort of) match the format of Microsoft's 		UUIDGEN utility. 	 */ 	public String toString() {return stringWorkhorse( '-' );}  	/** 		Produce a string representation of this UUID which 		is suitable for use as a unique ANSI identifier. 	 */ 	public String toANSIidentifier() {return &quot;U&quot; + stringWorkhorse( 'X' );}  	/** 	  *	Private workhorse of the string making routines. 	  * 	  *	@param	separator	Character to separate number blocks. 	  *                     Null means do not include a separator. 	  * 	  *	@return	string representation of UUID. 	  */ 	public	String	stringWorkhorse( char separator ) 	{ 		char[] data = new char[36];  		writeMSB(data, 0, (long) sequence, 4);  		int offset = 8; 		if (separator != 0) data[offset++] = separator;  		long ltimemillis = timemillis; 		writeMSB(data, offset, (ltimemillis &amp; 0x0000ffff00000000L) &gt;&gt;&gt; 32, 2); 		offset += 4; 		if (separator != 0) data[offset++] = separator; 		writeMSB(data, offset, (ltimemillis &amp; 0x00000000ffff0000L) &gt;&gt;&gt; 16, 2); 		offset += 4; 		if (separator != 0) data[offset++] = separator; 		writeMSB(data, offset, (ltimemillis &amp; 0x000000000000ffffL), 2); 		offset += 4; 		if (separator != 0) data[offset++] = separator; 		writeMSB(data, offset, majorId, 6); 		offset += 12;  		return new String(data, 0, offset); 	}  	/** 	  Clone this UUID.  	  @return	a copy of this UUID 	  */ 	public UUID cloneMe() 	{ 		return	new	BasicUUID(majorId, timemillis, sequence); 	} }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2553</td>
    <td align="left">https://github.com/apache/derby/blob/bd246fc89d4fce3f82f8344074ecb8a4713418df/java/org.apache.derby.engine/org/apache/derby/impl/services/uuid/BasicUUID.java/#L36-L250</td>
    <td align="right">1</td>
    <td align="right">234</td>
    <td align="right">2553</td>
  </tr>
  <tr valign="top">
    <td align="right">300</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class HistoryClientService extends AbstractService {    private static final Log LOG = LogFactory.getLog(HistoryClientService.class);    private HSClientProtocol protocolHandler;   private Server server;   private WebApp webApp;   private InetSocketAddress bindAddress;   private HistoryContext history;   private JHSDelegationTokenSecretManager jhsDTSecretManager;      public HistoryClientService(HistoryContext history,       JHSDelegationTokenSecretManager jhsDTSecretManager) {     super(&quot;HistoryClientService&quot;);     this.history = history;     this.protocolHandler = new HSClientProtocolHandler();     this.jhsDTSecretManager = jhsDTSecretManager;   }    protected void serviceStart() throws Exception {     Configuration conf = getConfig();     YarnRPC rpc = YarnRPC.create(conf);     initializeWebApp(conf);     InetSocketAddress address = conf.getSocketAddr(         JHAdminConfig.MR_HISTORY_BIND_HOST,         JHAdminConfig.MR_HISTORY_ADDRESS,         JHAdminConfig.DEFAULT_MR_HISTORY_ADDRESS,         JHAdminConfig.DEFAULT_MR_HISTORY_PORT);      server =         rpc.getServer(HSClientProtocol.class, protocolHandler, address,             conf, jhsDTSecretManager,             conf.getInt(JHAdminConfig.MR_HISTORY_CLIENT_THREAD_COUNT,                 JHAdminConfig.DEFAULT_MR_HISTORY_CLIENT_THREAD_COUNT));      // Enable service authorization?     if (conf.getBoolean(         CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHORIZATION,         false)) {       server.refreshServiceAcl(conf, new ClientHSPolicyProvider());     }          server.start();     this.bindAddress = conf.updateConnectAddr(JHAdminConfig.MR_HISTORY_BIND_HOST,                                               JHAdminConfig.MR_HISTORY_ADDRESS,                                               JHAdminConfig.DEFAULT_MR_HISTORY_ADDRESS,                                               server.getListenerAddress());     LOG.info(&quot;Instantiated HistoryClientService at &quot; + this.bindAddress);      super.serviceStart();   }    @VisibleForTesting   protected void initializeWebApp(Configuration conf) {     webApp = new HsWebApp(history);     InetSocketAddress bindAddress = MRWebAppUtil.getJHSWebBindAddress(conf);     // NOTE: there should be a .at(InetSocketAddress)     WebApps         .$for(&quot;jobhistory&quot;, HistoryClientService.class, this, &quot;ws&quot;)         .with(conf)         .withHttpSpnegoKeytabKey(             JHAdminConfig.MR_WEBAPP_SPNEGO_KEYTAB_FILE_KEY)         .withHttpSpnegoPrincipalKey(             JHAdminConfig.MR_WEBAPP_SPNEGO_USER_NAME_KEY)         .at(NetUtils.getHostPortString(bindAddress)).start(webApp);          String connectHost = MRWebAppUtil.getJHSWebappURLWithoutScheme(conf).split(&quot;:&quot;)[0];     MRWebAppUtil.setJHSWebappURLWithoutScheme(conf,         connectHost + &quot;:&quot; + webApp.getListenerAddress().getPort());   }    @Override   protected void serviceStop() throws Exception {     if (server != null) {       server.stop();     }     if (webApp != null) {       webApp.stop();     }     super.serviceStop();   }    @Private   public MRClientProtocol getClientHandler() {     return this.protocolHandler;   }    @Private   public InetSocketAddress getBindAddress() {     return this.bindAddress;   }    private class HSClientProtocolHandler implements HSClientProtocol {      private RecordFactory recordFactory = RecordFactoryProvider.getRecordFactory(null);      public InetSocketAddress getConnectAddress() {       return getBindAddress();     }          private Job verifyAndGetJob(final JobId jobID) throws IOException {       UserGroupInformation loginUgi = null;       Job job = null;       try {         loginUgi = UserGroupInformation.getLoginUser();         job = loginUgi.doAs(new PrivilegedExceptionAction() {            @Override           public Job run() throws Exception {             Job job = history.getJob(jobID);             return job;           }         });       } catch (InterruptedException e) {         throw new IOException(e);       }       if (job != null) {         JobACL operation = JobACL.VIEW_JOB;         checkAccess(job, operation);       }       return job;     }      @Override     public GetCountersResponse getCounters(GetCountersRequest request)         throws IOException {       JobId jobId = request.getJobId();       Job job = verifyAndGetJob(jobId);       GetCountersResponse response = recordFactory.newRecordInstance(GetCountersResponse.class);       response.setCounters(TypeConverter.toYarn(job.getAllCounters()));       return response;     }      @Override     public GetJobReportResponse getJobReport(GetJobReportRequest request)         throws IOException {       JobId jobId = request.getJobId();       Job job = verifyAndGetJob(jobId);       GetJobReportResponse response = recordFactory.newRecordInstance(GetJobReportResponse.class);       if (job != null) {         response.setJobReport(job.getReport());       }       else {         response.setJobReport(null);       }       return response;     }      @Override     public GetTaskAttemptReportResponse getTaskAttemptReport(         GetTaskAttemptReportRequest request) throws IOException {       TaskAttemptId taskAttemptId = request.getTaskAttemptId();       Job job = verifyAndGetJob(taskAttemptId.getTaskId().getJobId());       GetTaskAttemptReportResponse response = recordFactory.newRecordInstance(GetTaskAttemptReportResponse.class);       response.setTaskAttemptReport(job.getTask(taskAttemptId.getTaskId()).getAttempt(taskAttemptId).getReport());       return response;     }      @Override     public GetTaskReportResponse getTaskReport(GetTaskReportRequest request)         throws IOException {       TaskId taskId = request.getTaskId();       Job job = verifyAndGetJob(taskId.getJobId());       GetTaskReportResponse response = recordFactory.newRecordInstance(GetTaskReportResponse.class);       response.setTaskReport(job.getTask(taskId).getReport());       return response;     }      @Override     public GetTaskAttemptCompletionEventsResponse         getTaskAttemptCompletionEvents(             GetTaskAttemptCompletionEventsRequest request) throws IOException {       JobId jobId = request.getJobId();       int fromEventId = request.getFromEventId();       int maxEvents = request.getMaxEvents();        Job job = verifyAndGetJob(jobId);       GetTaskAttemptCompletionEventsResponse response = recordFactory.newRecordInstance(GetTaskAttemptCompletionEventsResponse.class);       response.addAllCompletionEvents(Arrays.asList(job.getTaskAttemptCompletionEvents(fromEventId, maxEvents)));       return response;     }      @Override     public KillJobResponse killJob(KillJobRequest request) throws IOException {       throw new IOException(&quot;Invalid operation on completed job&quot;);     }      @Override     public KillTaskResponse killTask(KillTaskRequest request)         throws IOException {       throw new IOException(&quot;Invalid operation on completed job&quot;);     }      @Override     public KillTaskAttemptResponse killTaskAttempt(         KillTaskAttemptRequest request) throws IOException {       throw new IOException(&quot;Invalid operation on completed job&quot;);     }      @Override     public GetDiagnosticsResponse getDiagnostics(GetDiagnosticsRequest request)         throws IOException {       TaskAttemptId taskAttemptId = request.getTaskAttemptId();        Job job = verifyAndGetJob(taskAttemptId.getTaskId().getJobId());        GetDiagnosticsResponse response = recordFactory.newRecordInstance(GetDiagnosticsResponse.class);       response.addAllDiagnostics(job.getTask(taskAttemptId.getTaskId()).getAttempt(taskAttemptId).getDiagnostics());       return response;     }      @Override     public FailTaskAttemptResponse failTaskAttempt(         FailTaskAttemptRequest request) throws IOException {       throw new IOException(&quot;Invalid operation on completed job&quot;);     }      @Override     public GetTaskReportsResponse getTaskReports(GetTaskReportsRequest request)         throws IOException {       JobId jobId = request.getJobId();       TaskType taskType = request.getTaskType();        GetTaskReportsResponse response = recordFactory.newRecordInstance(GetTaskReportsResponse.class);       Job job = verifyAndGetJob(jobId);       Collection tasks = job.getTasks(taskType).values();       for (Task task : tasks) {         response.addTaskReport(task.getReport());       }       return response;     }          @Override     public GetDelegationTokenResponse getDelegationToken(         GetDelegationTokenRequest request) throws IOException {        UserGroupInformation ugi = UserGroupInformation.getCurrentUser();        // Verify that the connection is kerberos authenticated         if (!isAllowedDelegationTokenOp()) {           throw new IOException(               &quot;Delegation Token can be issued only with kerberos authentication&quot;);         }        GetDelegationTokenResponse response = recordFactory.newRecordInstance(           GetDelegationTokenResponse.class);        String user = ugi.getUserName();       Text owner = new Text(user);       Text realUser = null;       if (ugi.getRealUser() != null) {         realUser = new Text(ugi.getRealUser().getUserName());       }       MRDelegationTokenIdentifier tokenIdentifier =           new MRDelegationTokenIdentifier(owner, new Text(             request.getRenewer()), realUser);       Token realJHSToken =           new Token(tokenIdentifier,               jhsDTSecretManager);       org.apache.hadoop.yarn.api.records.Token mrDToken =           org.apache.hadoop.yarn.api.records.Token.newInstance(             realJHSToken.getIdentifier(), realJHSToken.getKind().toString(),             realJHSToken.getPassword(), realJHSToken.getService().toString());       response.setDelegationToken(mrDToken);       return response;     }      @Override     public RenewDelegationTokenResponse renewDelegationToken(         RenewDelegationTokenRequest request) throws IOException {         if (!isAllowedDelegationTokenOp()) {           throw new IOException(               &quot;Delegation Token can be renewed only with kerberos authentication&quot;);         }          org.apache.hadoop.yarn.api.records.Token protoToken = request.getDelegationToken();         Token token =             new Token(                 protoToken.getIdentifier().array(), protoToken.getPassword()                     .array(), new Text(protoToken.getKind()), new Text(                     protoToken.getService()));          String user = UserGroupInformation.getCurrentUser().getShortUserName();         long nextExpTime = jhsDTSecretManager.renewToken(token, user);         RenewDelegationTokenResponse renewResponse = Records             .newRecord(RenewDelegationTokenResponse.class);         renewResponse.setNextExpirationTime(nextExpTime);         return renewResponse;     }      @Override     public CancelDelegationTokenResponse cancelDelegationToken(         CancelDelegationTokenRequest request) throws IOException {         if (!isAllowedDelegationTokenOp()) {           throw new IOException(               &quot;Delegation Token can be cancelled only with kerberos authentication&quot;);         }          org.apache.hadoop.yarn.api.records.Token protoToken = request.getDelegationToken();         Token token =             new Token(                 protoToken.getIdentifier().array(), protoToken.getPassword()                     .array(), new Text(protoToken.getKind()), new Text(                     protoToken.getService()));          String user = UserGroupInformation.getCurrentUser().getUserName();         jhsDTSecretManager.cancelToken(token, user);         return Records.newRecord(CancelDelegationTokenResponse.class);     }      private void checkAccess(Job job, JobACL jobOperation)         throws IOException {        UserGroupInformation callerUGI;       callerUGI = UserGroupInformation.getCurrentUser();        if (!job.checkAccess(callerUGI, jobOperation)) {         throw new IOException(new AccessControlException(&quot;User &quot;             + callerUGI.getShortUserName() + &quot; cannot perform operation &quot;             + jobOperation.name() + &quot; on &quot; + job.getID()));       }     }      private boolean isAllowedDelegationTokenOp() throws IOException {       if (UserGroupInformation.isSecurityEnabled()) {         return EnumSet.of(AuthenticationMethod.KERBEROS,                           AuthenticationMethod.KERBEROS_SSL,                           AuthenticationMethod.CERTIFICATE)             .contains(UserGroupInformation.getCurrentUser()                     .getRealAuthenticationMethod());       } else {         return true;       }     }    } }</td>
    <td align="left">blob</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3154</td>
    <td align="left">https://github.com/apache/hadoop-common/blob/42a61a4fbc88303913c4681f0d40ffcc737e70b5/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-hs/src/main/java/org/apache/hadoop/mapreduce/v2/hs/HistoryClientService.java/#L99-L435</td>
    <td align="right">1</td>
    <td align="right">300</td>
    <td align="right">3154</td>
  </tr>
  <tr valign="top">
    <td align="right">319</td>
    <td align="left">{&quot;response&quot;:&quot;YES I found bad smells&quot;,&quot;bad smells&quot;:[&quot;Blob&quot;,&quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class NetAgent extends Agent {     //---------------------navigational members-----------------------------------      // All these request objects point to the same physical request object.     ConnectionRequestInterface connectionRequest_;     StatementRequestInterface statementRequest_;     ResultSetRequestInterface resultSetRequest_;      // All these reply objects point to the same physical reply object.     ConnectionReply connectionReply_;     private ConnectionReply packageReply_;     StatementReply statementReply_;     ResultSetReply resultSetReply_;      //---------------------navigational cheat-links-------------------------------     // Cheat-links are for convenience only, and are not part of the conceptual model.     // Warning:     //   Cheat-links should only be defined for invariant state data.     //   That is, the state data is set by the constructor and never changes.      // Alias for (NetConnection) super.connection     NetConnection netConnection_;      // Alias for (Request) super.*Request, all in one     // In the case of the NET implementation, these all point to the same physical request object.     private Request request_;     NetConnectionRequest netConnectionRequest_;     private NetPackageRequest netPackageRequest_;     private NetStatementRequest netStatementRequest_;     private NetResultSetRequest netResultSetRequest_;      // Alias for (Reply) super.*Reply, all in one.     // In the case of the NET implementation, these all point to the same physical reply object.     private Reply reply_;     NetConnectionReply netConnectionReply_;     private NetPackageReply netPackageReply_;     private NetStatementReply netStatementReply_;     private NetResultSetReply netResultSetReply_;      //-----------------------------state------------------------------------------      Socket socket_;     private InputStream rawSocketInputStream_;     private OutputStream rawSocketOutputStream_;      String server_;     int port_;     private int clientSSLMode_;      private EbcdicCcsidManager ebcdicCcsidManager_;     private Utf8CcsidManager utf8CcsidManager_;     private CcsidManager currentCcsidManager_;          // TODO: Remove target? Keep just one CcsidManager?     //public CcsidManager targetCcsidManager_;     Typdef typdef_;     Typdef targetTypdef_;     Typdef originalTargetTypdef_; // added to support typdef overrides      private int svrcod_;      int orignalTargetSqlam_ = NetConfiguration.MGRLVL_7;     int targetSqlam_ = orignalTargetSqlam_;      SqlException exceptionOpeningSocket_ = null;     SqlException exceptionConvertingRdbnam = null;          /**      * Flag which indicates that a writeChain has been started and data sent to      * the server.      * If true, starting a new write chain will throw a DisconnectException.       * It is cleared when the write chain is ended.      */     private boolean writeChainIsDirty_ = false;     //---------------------constructors/finalizer---------------------------------      // Only used for testing     public NetAgent(NetConnection netConnection,                     LogWriter logWriter) throws SqlException {         super(netConnection, logWriter);         this.netConnection_ = netConnection;     }      NetAgent(NetConnection netConnection,              LogWriter netLogWriter,              int loginTimeout,              String server,              int port,              int clientSSLMode) throws SqlException {         super(netConnection, netLogWriter);          server_ = server;         port_ = port;         netConnection_ = netConnection;         clientSSLMode_ = clientSSLMode;          if (server_ == null) {             throw new DisconnectException(this,                  new ClientMessageId(SQLState.CONNECT_REQUIRED_PROPERTY_NOT_SET),                 &quot;serverName&quot;);         }          try {             socket_ = (Socket)AccessController.doPrivileged(                 new OpenSocketAction(server, port, clientSSLMode_));         } catch (PrivilegedActionException e) {             throw new DisconnectException(this,                 new ClientMessageId(SQLState.CONNECT_UNABLE_TO_CONNECT_TO_SERVER),                 e.getException(),                 e.getException().getClass().getName(), server, port,                 e.getException().getMessage());         }          // Set TCP/IP Socket Properties         try {             if (exceptionOpeningSocket_ == null) {                 socket_.setTcpNoDelay(true); // disables nagles algorithm                 socket_.setKeepAlive(true); // PROTOCOL Manual: TCP/IP connection allocation rule #2                 socket_.setSoTimeout(loginTimeout * 1000);             }         } catch (SocketException e) {             try {                 socket_.close();             } catch (IOException doNothing) {             }             exceptionOpeningSocket_ = new DisconnectException(this,                 new ClientMessageId(SQLState.CONNECT_SOCKET_EXCEPTION),                 e, e.getMessage());         }          try {             if (exceptionOpeningSocket_ == null) {                 rawSocketOutputStream_ = socket_.getOutputStream();                 rawSocketInputStream_ = socket_.getInputStream();             }         } catch (IOException e) {             try {                 socket_.close();             } catch (IOException doNothing) {             }             exceptionOpeningSocket_ = new DisconnectException(this,                  new ClientMessageId(SQLState.CONNECT_UNABLE_TO_OPEN_SOCKET_STREAM),                 e, e.getMessage());         }          ebcdicCcsidManager_ = new EbcdicCcsidManager();         utf8CcsidManager_ = new Utf8CcsidManager();                  currentCcsidManager_ = ebcdicCcsidManager_;          if (netConnection_.isXAConnection()) {             NetXAConnectionReply netXAConnectionReply_ = new NetXAConnectionReply(this, netConnection_.commBufferSize_);             netResultSetReply_ = (NetResultSetReply) netXAConnectionReply_;             netStatementReply_ = (NetStatementReply) netResultSetReply_;             netPackageReply_ = (NetPackageReply) netStatementReply_;             netConnectionReply_ = (NetConnectionReply) netPackageReply_;             reply_ = (Reply) netConnectionReply_;              resultSetReply_ = new ResultSetReply(this,                     netResultSetReply_,                     netStatementReply_,                     netConnectionReply_);             statementReply_ = (StatementReply) resultSetReply_;             packageReply_ = (ConnectionReply) statementReply_;             connectionReply_ = (ConnectionReply) packageReply_;             NetXAConnectionRequest netXAConnectionRequest_ = new NetXAConnectionRequest(this, netConnection_.commBufferSize_);             netResultSetRequest_ = (NetResultSetRequest) netXAConnectionRequest_;             netStatementRequest_ = (NetStatementRequest) netResultSetRequest_;             netPackageRequest_ = (NetPackageRequest) netStatementRequest_;             netConnectionRequest_ = (NetConnectionRequest) netPackageRequest_;             request_ = (Request) netConnectionRequest_;              resultSetRequest_ = (ResultSetRequestInterface) netResultSetRequest_;             statementRequest_ = (StatementRequestInterface) netStatementRequest_;             connectionRequest_ = (ConnectionRequestInterface) netConnectionRequest_;         } else {             netResultSetReply_ = new NetResultSetReply(this, netConnection_.commBufferSize_);             netStatementReply_ = (NetStatementReply) netResultSetReply_;             netPackageReply_ = (NetPackageReply) netStatementReply_;             netConnectionReply_ = (NetConnectionReply) netPackageReply_;             reply_ = (Reply) netConnectionReply_;              resultSetReply_ = new ResultSetReply(this,                     netResultSetReply_,                     netStatementReply_,                     netConnectionReply_);             statementReply_ = (StatementReply) resultSetReply_;             packageReply_ = (ConnectionReply) statementReply_;             connectionReply_ = (ConnectionReply) packageReply_;             netResultSetRequest_ = new NetResultSetRequest(this, netConnection_.commBufferSize_);             netStatementRequest_ = (NetStatementRequest) netResultSetRequest_;             netPackageRequest_ = (NetPackageRequest) netStatementRequest_;             netConnectionRequest_ = (NetConnectionRequest) netPackageRequest_;             request_ = (Request) netConnectionRequest_;              resultSetRequest_ = (ResultSetRequestInterface) netResultSetRequest_;             statementRequest_ = (StatementRequestInterface) netStatementRequest_;             connectionRequest_ = (ConnectionRequestInterface) netConnectionRequest_;         }     }      protected void resetAgent_(LogWriter netLogWriter,                                //CcsidManager sourceCcsidManager,                                //CcsidManager targetCcsidManager,                                int loginTimeout,                                String server,                                int port) throws SqlException {                  exceptionConvertingRdbnam = null;         // most properties will remain unchanged on connect reset.         targetTypdef_ = originalTargetTypdef_;         svrcod_ = 0;          // Set TCP/IP Socket Properties         try {             socket_.setSoTimeout(loginTimeout * 1000);         } catch (SocketException e) {             try {                 socket_.close();             } catch (IOException doNothing) {             }             throw new SqlException(logWriter_,                  new ClientMessageId(SQLState.SOCKET_EXCEPTION),                 e, e.getMessage());         }     }       void setSvrcod(int svrcod) {         if (svrcod &gt; svrcod_) {             svrcod_ = svrcod;         }     }      void clearSvrcod() {         svrcod_ = CodePoint.SVRCOD_INFO;     }      private int getSvrcod() {         return svrcod_;     }      public void flush_() throws DisconnectException {         sendRequest();         reply_.initialize();     }      // Close socket and its streams.     public void close_() throws SqlException {         // can we just close the socket here, do we need to close streams individually         SqlException accumulatedExceptions = null;         if (rawSocketInputStream_ != null) {             try {                 rawSocketInputStream_.close();             } catch (IOException e) {                 // note when {6} = 0 it indicates the socket was closed.                 // this should be ok since we are going to go an close the socket                 // immediately following this call.                 // changing {4} to e.getMessage() may require pub changes                 accumulatedExceptions = new SqlException(logWriter_,                     new ClientMessageId(SQLState.COMMUNICATION_ERROR),                     e, e.getMessage());             } finally {                 rawSocketInputStream_ = null;             }         }          if (rawSocketOutputStream_ != null) {             try {                 rawSocketOutputStream_.close();             } catch (IOException e) {                 // note when {6} = 0 it indicates the socket was closed.                 // this should be ok since we are going to go an close the socket                 // immediately following this call.                 // changing {4} to e.getMessage() may require pub changes                 SqlException latestException = new SqlException(logWriter_,                     new ClientMessageId(SQLState.COMMUNICATION_ERROR),                     e, e.getMessage());                 accumulatedExceptions = Utils.accumulateSQLException(latestException, accumulatedExceptions);             } finally {                 rawSocketOutputStream_ = null;             }         }          if (socket_ != null) {             try {                 socket_.close();             } catch (IOException e) {                 // again {6} = 0, indicates the socket was closed.                 // maybe set {4} to e.getMessage().                 // do this for now and but may need to modify or                 // add this to the message pubs.                 SqlException latestException = new SqlException(logWriter_,                     new ClientMessageId(SQLState.COMMUNICATION_ERROR),                         e, e.getMessage());                 accumulatedExceptions = Utils.accumulateSQLException(latestException, accumulatedExceptions);             } finally {                 socket_ = null;             }         }          if (accumulatedExceptions != null) {             throw accumulatedExceptions;         }     }      /**      * Specifies the maximum blocking time that should be used when sending      * and receiving messages. The timeout is implemented by using the the       * underlying socket implementation's timeout support.       *       * Note that the support for timeout on sockets is dependent on the OS       * implementation. For the same reason we ignore any exceptions thrown      * by the call to the socket layer.      *       * @param timeout The timeout value in seconds. A value of 0 corresponds to       * infinite timeout.      */     protected void setTimeout(int timeout) {         try {             // Sets a timeout on the socket             socket_.setSoTimeout(timeout * 1000); // convert to milliseconds         } catch (SocketException se) {             // Silently ignore any exceptions from the socket layer             if (SanityManager.DEBUG) {                 System.out.println(&quot;NetAgent.setTimeout: ignoring exception: &quot; +                                     se);             }         }     }      /**      * Returns the current timeout value that is set on the socket.      *       * Note that the support for timeout on sockets is dependent on the OS       * implementation. For the same reason we ignore any exceptions thrown      * by the call to the socket layer.      *       * @return The timeout value in seconds. A value of 0 corresponds to      * that no timeout is specified on the socket.      */     protected int getTimeout() {         int timeout = 0; // 0 is default timeout for sockets          // Read the timeout currently set on the socket         try {             timeout = socket_.getSoTimeout();         } catch (SocketException se) {             // Silently ignore any exceptions from the socket layer             if (SanityManager.DEBUG) {                 System.out.println(&quot;NetAgent.getTimeout: ignoring exception: &quot; +                                     se);             }         }          // Convert from milliseconds to seconds (note that this truncates         // the results towards zero but that should not be a problem).         timeout = timeout / 1000;         return timeout;     }      private void sendRequest() throws DisconnectException {         try {             request_.flush(rawSocketOutputStream_);         } catch (IOException e) {             throwCommunicationsFailure(e);         }     }      public InputStream getInputStream() {         return rawSocketInputStream_;     }      public CcsidManager getCurrentCcsidManager() {         return currentCcsidManager_;     }          public OutputStream getOutputStream() {         return rawSocketOutputStream_;     }      void setInputStream(InputStream inputStream) {         rawSocketInputStream_ = inputStream;     }      void setOutputStream(OutputStream outputStream) {         rawSocketOutputStream_ = outputStream;     }      void throwCommunicationsFailure(Throwable cause)         throws DisconnectException {         //DisconnectException         //accumulateReadExceptionAndDisconnect         // note when {6} = 0 it indicates the socket was closed.         // need to still validate any token values against message publications.         accumulateChainBreakingReadExceptionAndThrow(             new DisconnectException(this,                 new ClientMessageId(SQLState.COMMUNICATION_ERROR),                 cause, cause.getMessage()));     }              // ----------------------- call-down methods ---------------------------------      protected void markChainBreakingException_() {         setSvrcod(CodePoint.SVRCOD_ERROR);     }      public void checkForChainBreakingException_() throws SqlException {         int svrcod = getSvrcod();         clearSvrcod();         if (svrcod &gt; CodePoint.SVRCOD_WARNING) // Not for SQL warning, if svrcod &gt; WARNING, then its a chain breaker         {             super.checkForExceptions(); // throws the accumulated exceptions, we'll always have at least one.         }     }      private void writeDeferredResetConnection() throws SqlException {         if (!netConnection_.resetConnectionAtFirstSql_) {             return;         }         try {             netConnection_.writeDeferredReset();         } catch (SqlException sqle) {             DisconnectException de = new DisconnectException(this,                  new ClientMessageId(SQLState.CONNECTION_FAILED_ON_DEFERRED_RESET));             de.setNextException(sqle);             throw de;         }     }     /**      * Marks the agent's write chain as dirty. A write chain is dirty when data      * from it has been sent to the server. A dirty write chain cannot be reset       * and reused for another request until the remaining data has been sent to      * the server and the write chain properly ended.       *       * Resetting a dirty chain will cause the new request to be appended to the       * unfinished request already at the server, which will likely lead to       * cryptic syntax errors.      */     void markWriteChainAsDirty() {             writeChainIsDirty_ = true;     }          private void verifyWriteChainIsClean() throws DisconnectException {         if (writeChainIsDirty_) {              throw new DisconnectException(this,                  new ClientMessageId(SQLState.NET_WRITE_CHAIN_IS_DIRTY));         }     }     public void beginWriteChainOutsideUOW() throws SqlException {         verifyWriteChainIsClean();         request_.initialize();         writeDeferredResetConnection();     }      public void beginWriteChain(ClientStatement statement) throws SqlException {         verifyWriteChainIsClean();         request_.initialize();         writeDeferredResetConnection();         super.beginWriteChain(statement);     }      protected void endWriteChain() {}          private void readDeferredResetConnection() throws SqlException {         if (!netConnection_.resetConnectionAtFirstSql_) {             return;         }         try {             netConnection_.readDeferredReset();             checkForExceptions();         } catch (SqlException sqle) {             DisconnectException de = new DisconnectException(this,                  new ClientMessageId(SQLState.CONNECTION_FAILED_ON_DEFERRED_RESET));             de.setNextException(sqle);             throw de;         }     }      protected void beginReadChain(ClientStatement statement)             throws SqlException {         // Clear here as endWriteChain may not always be called         writeChainIsDirty_ = false;         readDeferredResetConnection();         super.beginReadChain(statement);     }      protected void beginReadChainOutsideUOW() throws SqlException {         // Clear here as endWriteChain may not always be called         writeChainIsDirty_ = false;         readDeferredResetConnection();         super.beginReadChainOutsideUOW();     }      /**      * Switches the current CCSID manager to UTF-8      */     void switchToUtf8CcsidMgr() {         currentCcsidManager_ = utf8CcsidManager_;     }          /**      * Switches the current CCSID manager to EBCDIC      */     void switchToEbcdicMgr() {         currentCcsidManager_ = ebcdicCcsidManager_;     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3272</td>
    <td align="left">https://github.com/apache/derby/blob/bd246fc89d4fce3f82f8344074ecb8a4713418df/java/org.apache.derby.client/org/apache/derby/client/net/NetAgent.java/#L43-L550</td>
    <td align="right">1</td>
    <td align="right">319</td>
    <td align="right">3272</td>
  </tr>
  <tr valign="top">
    <td align="right">321</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells the bad smells are: 1. Long method, 2. Blob&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    static final class DemoControls extends CustomControls implements ActionListener, ChangeListener {          TransformAnim demo;         JSlider shapeSlider, stringSlider, imageSlider;         Font font = new Font(Font.SERIF, Font.BOLD, 10);         JToolBar toolbar;         ButtonBorder buttonBorder = new ButtonBorder();          @SuppressWarnings(&quot;LeakingThisInConstructor&quot;)         public DemoControls(TransformAnim demo) {             super(demo.name);             this.demo = demo;             setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));             add(Box.createVerticalStrut(5));              JToolBar bar = new JToolBar(SwingConstants.VERTICAL);             bar.setFloatable(false);             shapeSlider = new JSlider(SwingConstants.HORIZONTAL,0,20,demo.numShapes);             shapeSlider.addChangeListener(this);             TitledBorder tb = new TitledBorder(new EtchedBorder());             tb.setTitleFont(font);             tb.setTitle(String.valueOf(demo.numShapes) + &quot; Shapes&quot;);             shapeSlider.setBorder(tb);             shapeSlider.setOpaque(true);             shapeSlider.setPreferredSize(new Dimension(80,44));             bar.add(shapeSlider);             bar.addSeparator();              stringSlider = new JSlider(SwingConstants.HORIZONTAL,0,10,demo.numStrings);             stringSlider.addChangeListener(this);             tb = new TitledBorder(new EtchedBorder());             tb.setTitleFont(font);             tb.setTitle(String.valueOf(demo.numStrings) + &quot; Strings&quot;);             stringSlider.setBorder(tb);             stringSlider.setOpaque(true);             stringSlider.setPreferredSize(new Dimension(80,44));             bar.add(stringSlider);             bar.addSeparator();              imageSlider = new JSlider(SwingConstants.HORIZONTAL,0,10,demo.numImages);             imageSlider.addChangeListener(this);             tb = new TitledBorder(new EtchedBorder());             tb.setTitleFont(font);             tb.setTitle(String.valueOf(demo.numImages) + &quot; Images&quot;);             imageSlider.setBorder(tb);             imageSlider.setOpaque(true);             imageSlider.setPreferredSize(new Dimension(80,44));             bar.add(imageSlider);             bar.addSeparator();             add(bar);              toolbar = new JToolBar();             toolbar.setFloatable(false);             addButton(&quot;T&quot;, &quot;translate&quot;, demo.doTranslate);             addButton(&quot;R&quot;, &quot;rotate&quot;, demo.doRotate);             addButton(&quot;SC&quot;, &quot;scale&quot;, demo.doScale);             addButton(&quot;SH&quot;, &quot;shear&quot;, demo.doShear);             add(toolbar);         }           public void addButton(String s, String tt, boolean state) {             JToggleButton b = (JToggleButton) toolbar.add(new JToggleButton(s));             b.setFont(font);             b.setSelected(state);             b.setToolTipText(tt);             b.setFocusPainted(false);             b.setBorder(buttonBorder);             b.addActionListener(this);         }           @Override         public void actionPerformed(ActionEvent e) {             JToggleButton b = (JToggleButton) e.getSource();             if (b.getText().equals(&quot;T&quot;)) {                 demo.doTranslate = b.isSelected();             } else if (b.getText().equals(&quot;R&quot;)) {                 demo.doRotate = b.isSelected();             } else if (b.getText().equals(&quot;SC&quot;)) {                 demo.doScale = b.isSelected();             } else if (b.getText().equals(&quot;SH&quot;)) {                 demo.doShear = b.isSelected();             }             if (!demo.animating.running()) {                 demo.repaint();             }         }           @Override         public void stateChanged(ChangeEvent e) {             JSlider slider = (JSlider) e.getSource();             int value = slider.getValue();             TitledBorder tb = (TitledBorder) slider.getBorder();             if (slider.equals(shapeSlider)) {                 tb.setTitle(String.valueOf(value) + &quot; Shapes&quot;);                 demo.setShapes(value);             } else if (slider.equals(stringSlider)) {                 tb.setTitle(String.valueOf(value) + &quot; Strings&quot;);                 demo.setStrings(value);             } else if (slider.equals(imageSlider)) {                 tb.setTitle(String.valueOf(value) + &quot; Images&quot;);                 demo.setImages(value);             }             if (!demo.animating.running()) {                 demo.repaint();             }             slider.repaint();         }           @Override         public Dimension getPreferredSize() {             return new Dimension(80,38);         }           @Override         @SuppressWarnings(&quot;SleepWhileHoldingLock&quot;)         public void run() {             Thread me = Thread.currentThread();             while (thread == me) {                 for (int i = 1; i &lt; toolbar.getComponentCount(); i++) {                     try {                         Thread.sleep(4444);                     } catch (InterruptedException e) { return; }                     ((AbstractButton) toolbar.getComponentAtIndex(i)).doClick();                 }             }             thread = null;         }     } // End DemoControls</td>
    <td align="left">blob</td>
    <td align="left">1. long method, 2. blob </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3298</td>
    <td align="left">https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/demo/share/jfc/J2Ddemo/java2d/demos/Transforms/TransformAnim.java/#L386-L518</td>
    <td align="right">1</td>
    <td align="right">321</td>
    <td align="right">3298</td>
  </tr>
  <tr valign="top">
    <td align="right">339</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class LdapProtocolUtils {     /** A delimiter for the replicaId */     public static final String COOKIE_DELIM = &quot;,&quot;;      /** the prefix for replicaId value */     public static final String REPLICA_ID_PREFIX = &quot;rid=&quot;;      public static final int REPLICA_ID_PREFIX_LEN = REPLICA_ID_PREFIX.length();      /** the prefix for Csn value */     public static final String CSN_PREFIX = &quot;csn=&quot;;      private static final int CSN_PREFIX_LEN = CSN_PREFIX.length();      private static final Logger LOG = LoggerFactory.getLogger( LdapProtocolUtils.class );       private LdapProtocolUtils()     {     }       /**      * Extracts request controls from a request to populate into an      * OperationContext.      *      * @param opContext the context to populate with request controls      * @param request the request to extract controls from      */     public static void setRequestControls( OperationContext opContext, Request request )     {         if ( request.getControls() != null )         {             opContext                 .addRequestControls( request.getControls().values().toArray( LdapProtocolConstants.EMPTY_CONTROLS ) );         }     }       /**      * Extracts response controls from a an OperationContext to populate into      * a Response object.      *      * @param opContext the context to extract controls from      * @param response the response to populate with response controls      */     public static void setResponseControls( OperationContext opContext, Response response )     {         response.addAllControls( opContext.getResponseControls() );     }       public static byte[] createCookie( int replicaId, String csn )     {         // the syncrepl cookie format (compatible with OpenLDAP)         // rid=nn,csn=xxxz         String replicaIdStr = StringUtils.leftPad( Integer.toString( replicaId ), 3, '0' );         return Strings.getBytesUtf8( REPLICA_ID_PREFIX + replicaIdStr + COOKIE_DELIM + CSN_PREFIX + csn );     }       /**      * Check the cookie syntax. A cookie must have the following syntax :      * { rid={replicaId},csn={CSN} }      *      * @param cookieString The cookie      * @return true if the cookie is valid      */     public static boolean isValidCookie( String cookieString )     {         if ( ( cookieString == null ) || ( cookieString.trim().length() == 0 ) )         {             return false;         }          int pos = cookieString.indexOf( COOKIE_DELIM );          // position should start from REPLICA_ID_PREFIX_LEN or higher cause a cookie can be         // like &quot;rid=0,csn={csn}&quot; or &quot;rid=11,csn={csn}&quot;         if ( pos &lt;= REPLICA_ID_PREFIX_LEN )         {             return false;         }          String replicaId = cookieString.substring( REPLICA_ID_PREFIX_LEN, pos );          try         {             Integer.parseInt( replicaId );         }         catch ( NumberFormatException e )         {             LOG.debug( &quot;Failed to parse the replica id {}&quot;, replicaId );             return false;         }          if ( pos == cookieString.length() )         {             return false;         }          String csnString = cookieString.substring( pos + 1 + CSN_PREFIX_LEN );          return Csn.isValid( csnString );     }       /**      * returns the CSN present in cookie      *      * @param cookieString the cookie      * @return The CSN      */     public static String getCsn( String cookieString )     {         int pos = cookieString.indexOf( COOKIE_DELIM );         return cookieString.substring( pos + 1 + CSN_PREFIX_LEN );     }       /**      * returns the replica id present in cookie      *      * @param cookieString  the cookie      * @return The replica Id      */     public static int getReplicaId( String cookieString )     {         String replicaId = cookieString.substring( REPLICA_ID_PREFIX_LEN, cookieString.indexOf( COOKIE_DELIM ) );          return Integer.parseInt( replicaId );     } }</td>
    <td align="left">blob</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method</td>
    <td align="left">blob</td>
    <td align="right">0</td>
    <td align="right">3490</td>
    <td align="left">https://github.com/apache/directory-server/blob/310007cc1c7eb5415f93bed67d5553bc70980820/protocol-ldap/src/main/java/org/apache/directory/server/ldap/LdapProtocolUtils.java/#L38-L171</td>
    <td align="right">1</td>
    <td align="right">339</td>
    <td align="right">3490</td>
  </tr>
  <tr valign="top">
    <td align="right">354</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class HeaderParser {     private static final String DIRECTIVE_FILTER = &quot;filter&quot;; // NOI18N      private final String headerName;     private final Map parameters = new HashMap&lt;&gt;();     private final Map directives = new HashMap&lt;&gt;();     private final Map filterValue = new HashMap&lt;&gt;();     private final Feedback feedback;      private String header;     private int pos;     private String directiveOrParameterName;     private int contentStart;     private String versionFilter;      // static final ResourceBundle BUNDLE =     // ResourceBundle.getBundle(&quot;org.graalvm.component.installer.persist.Bundle&quot;);      public HeaderParser(String headerName, String header, Feedback feedback) {         this.headerName = headerName;         this.feedback = feedback;          if (header != null) {             // trim whitespaces;             this.header = header.trim();         } else {             this.header = &quot;&quot;;         }     }      private MetadataException metaEx(String key, Object... args) {         return new MetadataException(headerName, feedback.l10n(key, args));     }      public HeaderParser mustExist() throws MetadataException {         if (header == null || header.isEmpty()) {             throw metaEx(&quot;ERROR_HeaderMissing&quot;, headerName);         }         return this;     }      private static boolean isAlphaNum(char c) {         return (c &gt;= '0' &amp;&amp; c &lt;= '9') ||    // NOI18N                         (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') ||    // NOI18N                         (c &gt;= 'a' &amp;&amp; c &lt;= 'z');      // NOI18N     }      private static boolean isToken(char c) {         return isAlphaNum(c) || c == '_' || c == '-'; // NOI18N     }      private static boolean isExtended(char c) {         return isToken(c) || c == '.';     }      public boolean getBoolean(Boolean defValue) {         if (pos &gt;= header.length()) {             if (defValue == null) {                 throw metaEx(&quot;ERROR_HeaderMissing&quot;, headerName); // NOI18N             }             return defValue;         } else {             String s = header.substring(pos).trim().toLowerCase(Locale.ENGLISH);             switch (s) {                 case &quot;true&quot;: // NOI18N                     return true;                 case &quot;false&quot;: // NOI18N                     return false;             }             throw metaEx(&quot;ERROR_HeaderInvalid&quot;, headerName, s); // NOI18N         }     }      public String getContents(String defValue) {         if (pos &gt;= header.length()) {             return defValue;         } else {             return header.substring(pos).trim();         }     }      private void addFilterAttribute(String attrName, String value) {         if (filterValue.put(attrName, value) != null) {             throw metaErr(&quot;ERROR_DuplicateFilterAttribute&quot;);         }     }      private boolean isEmpty() {         return pos &gt;= header.length();     }      public String parseSymbolicName() throws MetadataException {         return parseNameOrNamespace(HeaderParser::isToken, &quot;ERROR_MissingSymbolicName&quot;, &quot;ERROR_InvalidSymbolicName&quot;, '.');     }      private char next() {         return pos &lt; header.length() ? header.charAt(pos++) : 0;     }      private void advance() {         pos++;     }      private char ch() {         return isEmpty() ? 0 : header.charAt(pos);     }      private String returnCut() {         String s = cut();         skipWhitespaces();         return s;     }      private void skipWhitespaces() {         while (!isEmpty()) {             if (!Character.isWhitespace(ch())) {                 contentStart = pos;                 return;             }             advance();         }         contentStart = -1;     }      private void skipWithSemicolon() {         skipWhitespaces();         if (ch() == ';') {             advance();         }         contentStart = -1;     }      private String cut() {         return cut(0);     }      private String cut(int delim) {         int e = pos - delim;         return contentStart == -1 || contentStart &gt;= e ? &quot;&quot; : header.substring(contentStart, e); // NOI18N     }      private void markContent() {         contentStart = pos;     }      private String readExtendedParameter() throws MetadataException {         skipWhitespaces();         while (!isEmpty()) {             char c = next();             if (Character.isWhitespace(c)) {                 break;             }             if (!isExtended(c)) {                 throw metaEx(&quot;ERROR_InvalidParameterSyntax&quot;, directiveOrParameterName);             }         }         String s = cut();         skipWithSemicolon();         return s;     }      private String readQuotedParameter() throws MetadataException {         markContent();         while (!isEmpty()) {             char c = next();             switch (c) {                 case '&quot;':                     return cut(1);                 case '\n':                 case '\r':                 case 0:                     throw metaEx(&quot;ERROR_InvalidQuotedString&quot;);                 case '\\':                     next();                     break;             }         }         throw metaEx(&quot;ERROR_InvalidQuotedString&quot;);     }      private String parseArgument() throws MetadataException {         skipWhitespaces();         char c = ch();         if (c == ';') {             throw metaEx(&quot;ERROR_MissingArgument&quot;, directiveOrParameterName);         }         if (c == '&quot;') { // NOI18N             advance();             return readQuotedParameter();         } else {             return readExtendedParameter();         }     }      private String parseNameOrNamespace(Predicate charAcceptor,                     String missingKeyName, String invalidKeyName, char compDelimiter) throws MetadataException {         if (header == null || isEmpty()) {             throw metaEx(missingKeyName);         }         skipWhitespaces();         boolean componentEmpty = true;         while (!isEmpty()) {             char c = ch();             if (c == ';') {                 String s = cut();                 return s;             }             advance();             if (c == compDelimiter) {                 if (componentEmpty) {                     throw metaEx(invalidKeyName);                 }                 componentEmpty = true;                 continue;             }             if (Character.isWhitespace(c)) {                 break;             }             if (!charAcceptor.test(c)) {                 throw metaEx(invalidKeyName);             }             componentEmpty = false;         }         return returnCut();     }      private String parseNamespace() throws MetadataException {         return parseNameOrNamespace(HeaderParser::isExtended, &quot;ERROR_MissingCapabilityName&quot;, &quot;ERROR_InvalidCapabilityName&quot;, (char) 0);     }      /**      * Parses version at the current position.      */     public String version() throws MetadataException {         int versionStart = -1;         int partCount = 0;         boolean partContents = false;         if (isEmpty()) {             throw metaErr(&quot;ERROR_InvalidVersion&quot;);         }         boolean dash = false;         while (!isEmpty()) {             char c = ch();              if (Character.isWhitespace(c)) {                 if (versionStart != -1) {                     break;                 }                 advance();                 continue;             }              if (c == ';') {                 break;             }             advance();             if (c == '.') {                 if (++partCount &gt; 3 || !partContents) {                     throw metaErr(&quot;ERROR_InvalidVersion&quot;);                 }                 partContents = false;                 dash = false;                 continue;             }             if (partCount &gt; 0 &amp;&amp; partContents &amp;&amp; c == '-') {                 dash = true;                 continue;             }             if (c &gt;= '0' &amp;&amp; c &lt;= '9') {                 if (versionStart == -1) {                     versionStart = pos - 1;                 }             } else {                 if (partCount &lt; 1) {                     throw metaErr(&quot;ERROR_InvalidVersion&quot;);                 }                 boolean err = false;                 if (partCount &gt;= 3 || dash) {                     err = !isToken(c);                 } else {                     err = true;                 }                 if (err) {                     throw metaErr(&quot;ERROR_InvalidVersion&quot;);                 }             }             partContents = true;         }         String v = cut();         skipWhitespaces();         if (!isEmpty() || !partContents) {             throw metaErr(&quot;ERROR_InvalidVersion&quot;);         }          return v;     }      private String readExtendedName() {         skipWhitespaces();         while (!isEmpty()) {             char c = ch();             if (isExtended(c)) {                 advance();             } else if (Character.isWhitespace(c) || c == ':' || c == '=') {                 break;             } else {                 throw metaEx(&quot;ERROR_InvalidParameterName&quot;);             }         }         return returnCut();     }      private void parseParameters() {         while (!isEmpty()) {             String paramOrDirectiveName = readExtendedName();             if (paramOrDirectiveName.isEmpty()) {                 throw metaEx(&quot;ERROR_InvalidParameterName&quot;);             }             directiveOrParameterName = paramOrDirectiveName;              char c = ch();             boolean dcolon = c == ':'; // NOI18N             if (dcolon) {                 advance();             }             c = next();             if (c != '=') { // NOI18N                 throw metaEx(&quot;ERROR_InvalidParameterSyntax&quot;, paramOrDirectiveName);             }             (dcolon ? directives : parameters).put(paramOrDirectiveName, parseArgument());         }     }      private void replaceInputText(String text) {         this.header = text;         this.pos = 0;     }      private MetadataException metaErr(String key, Object... args) throws MetadataException {         throw metaEx(key, args);     }      private MetadataException filterError() throws MetadataException {         throw metaErr(&quot;ERROR_InvalidFilterSpecification&quot;);     }      private void parseFilterConjunction() {         skipWhitespaces();         char c = next();         while (c == '(') {             parseFilterContent();             c = next();         }         if (c != ')') {             throw filterError();         }     }      private void parseFilterClause() {         skipWhitespaces();         int lastPos = -1;         W: while (!isEmpty()) {             char c = ch();             if (Character.isWhitespace(c)) {                 if (lastPos == -1) {                     lastPos = pos;                 }                 continue;             }             switch (c) {                 case '=':                 case '&lt;':                 case '&gt;':                 case '~':                 case '(':                 case ')':                     break W;             }             lastPos = -1;             advance();         }          String attributeName = returnCut();         char c = next();         if (c != '=') {             throw metaErr(&quot;ERROR_UnsupportedFilterOperation&quot;);         }         c = ch();         if (c == '*') {             throw metaErr(&quot;ERROR_UnsupportedFilterOperation&quot;);         }         markContent();         while (!isEmpty()) {             c = next();             if (c == ')') {                 addFilterAttribute(attributeName, cut(1));                 skipWhitespaces();                 return;             }              switch (c) {                 case '\\':                     c = next();                     if (c == 0) {                         throw filterError();                     }                     break;                 case '*':                     throw metaErr(&quot;ERROR_UnsupportedFilterOperation&quot;);                 case '(':                 case '&lt;':                 case '&gt;':                 case '~':                 case '=':                     throw filterError();             }         }         throw filterError();     }      private void parseFilterContent() {         skipWhitespaces();         char o = ch();         if (o == '&amp;') {             advance();             parseFilterConjunction();         } else if (isExtended(o)) {             parseFilterClause();         } else {             throw metaErr(&quot;ERROR_InvalidFilterSpecification&quot;);         }     }      private void parseFilterSpecification() {         skipWhitespaces();         if (isEmpty()) {             throw filterError();         }         char c = next();         if (c == '(') {             parseFilterContent();             skipWhitespaces();             if (!isEmpty()) {                 throw metaErr(&quot;ERROR_InvalidFilterSpecification&quot;);             }         } else {             throw filterError();         }     }      /**      * Parses required capabilities string.      *      * org.graalvm; filter:=&quot;(&amp;(graalvm_version=0.32)(os_name=linux)(os_arch=amd64))&quot;      *       * @return graal capabilities      * @throws MetadataException      */     public Map parseRequiredCapabilities() {         String namespace = parseNamespace();          char c = next();         if (c != ';' &amp;&amp; c != 0) {             throw metaErr(&quot;ERROR_InvalidFilterSpecification&quot;);         }          if (!BundleConstants.GRAALVM_CAPABILITY.equals(namespace)) {             // unsupported capability             throw new DependencyException(namespace, null, null, feedback.l10n(&quot;ERROR_UnknownCapability&quot;));         }         parseParameters();          if (!parameters.isEmpty()) {             throw metaErr(&quot;ERROR_UnsupportedParameters&quot;);         }         versionFilter = directives.remove(DIRECTIVE_FILTER);         if (!directives.isEmpty()) {             throw metaErr(&quot;ERROR_UnsupportedDirectives&quot;);         }         if (versionFilter == null) {             throw metaErr(&quot;ERROR_MissingVersionFilter&quot;);         }          // replace the input text, the rest of header will be ignored         replaceInputText(versionFilter);         parseFilterSpecification();          return filterValue;     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3651</td>
    <td align="left">https://github.com/oracle/graal/blob/4deb681aaaa79c248115037fc8e399c9876619fd/vm/src/org.graalvm.component.installer/src/org/graalvm/component/installer/persist/HeaderParser.java/#L39-L528</td>
    <td align="right">1</td>
    <td align="right">354</td>
    <td align="right">3651</td>
  </tr>
  <tr valign="top">
    <td align="right">358</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;,      &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SafeFileOutputStream extends FilterOutputStream {      private final Path desiredFile;     private Path tempFile;     boolean desiredAlreadyExisted;      public SafeFileOutputStream(Path file) throws IOException {         this(file, tempFile(file));     }      public SafeFileOutputStream(Path desiredFile, Path tempFile)             throws IOException {          super(Files.newOutputStream(tempFile));         this.desiredFile = desiredFile;         this.tempFile = tempFile;         // Some useful things to check that we preferably don't want to fail on         // close()         desiredAlreadyExisted = Files.exists(desiredFile);         Path desiredFolder = this.desiredFile.getParent();         if (desiredAlreadyExisted) {             if (!Files.isWritable(desiredFile)) {                 throw new FileNotFoundException(&quot;Can't write to &quot; + desiredFile);             }         } else {             if (!Files.exists(desiredFolder)) {                 throw new FileNotFoundException(&quot;Folder does not exist: &quot;                         + desiredFolder);             }             if (!Files.isDirectory(desiredFolder)) {                 throw new FileNotFoundException(&quot;Not a directory: &quot;                         + desiredFolder);             }         }         if (!Files.isWritable(desiredFolder)) {             throw new FileNotFoundException(&quot;Can't modify folder &quot;                     + desiredFolder);         }     }      private static Path tempFile(Path file) throws IOException {         return Files.createTempFile(file.getParent(), file.getFileName()                 .toString(), &quot;.tmp&quot;);     }      @Override     public void close() throws IOException {         // If super.close fails - we leave the tempfiles behind         super.close();         if (!Files.exists(tempFile)) {             // Probably something went wrong before close called,             // like rollback()             return;         }         Path beforeDeletion = null;         try {             if (desiredAlreadyExisted) {                 // In case renaming goes wrong, we don't want to have already                 // deleted the                 // desired file. So we'll rename it to another temporary file                 // instead which                 // we can delete on successful rename.                 beforeDeletion = tempFile(desiredFile);                 if (!Files.deleteIfExists(beforeDeletion)) {                     // Should not happen, we just made it!                     throw new IOException(&quot;Can't delete temporary file &quot;                             + beforeDeletion);                 }                 Files.move(desiredFile, beforeDeletion,                         StandardCopyOption.ATOMIC_MOVE);             }             try {                 Files.move(tempFile, desiredFile,                         StandardCopyOption.ATOMIC_MOVE);             } catch (IOException e) {                 // We'll leave our tempFiles for recovery.                 tempFile = null;                 beforeDeletion = null;                  if (Files.exists(desiredFile)) {                     // Someone else added or replaced the file afterwards,                     // kind-a OK                     return;                 }                 throw e;             }         } finally {             if (beforeDeletion != null) {                 Files.deleteIfExists(beforeDeletion);             }             if (tempFile != null) {                 Files.deleteIfExists(tempFile);             }         }     }      public void rollback() throws IOException {         super.close();         Files.deleteIfExists(tempFile);     }  }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3683</td>
    <td align="left">https://github.com/apache/incubator-taverna-engine/blob/98536c6b702a0541debbb66be996455384561b54/taverna-prov/src/main/java/org/apache/taverna/prov/SafeFileOutputStream.java/#L36-L137</td>
    <td align="right">1</td>
    <td align="right">358</td>
    <td align="right">3683</td>
  </tr>
  <tr valign="top">
    <td align="right">438</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SCOMMetricHelper {   private static final String SQLSERVER_PROPERTIES_FILE = &quot;sqlserver_properties.json&quot;;   private static final String JMX_PROPERTIES_FILE = &quot;jmx_properties.json&quot;;    private static final Map&gt;&gt; JMX_PROPERTY_IDS = readPropertyProviderIds(JMX_PROPERTIES_FILE);   private static final Map&gt;&gt; SQLSERVER_PROPERTY_IDS = readPropertyProviderIds(SQLSERVER_PROPERTIES_FILE);    public static Map&gt; getSqlServerPropertyIds(Resource.Type resourceType) {     return SQLSERVER_PROPERTY_IDS.get(resourceType.getInternalType());   }    public static Map&gt; getJMXPropertyIds(Resource.Type resourceType) {     return JMX_PROPERTY_IDS.get(resourceType.getInternalType());   }    protected static class Metric {     private String metric;     private boolean pointInTime;     private boolean temporal;      private Metric() {     }      protected Metric(String metric, boolean pointInTime, boolean temporal) {       this.metric = metric;       this.pointInTime = pointInTime;       this.temporal = temporal;     }      public String getMetric() {       return metric;     }      public void setMetric(String metric) {       this.metric = metric;     }      public boolean isPointInTime() {       return pointInTime;     }      public void setPointInTime(boolean pointInTime) {       this.pointInTime = pointInTime;     }      public boolean isTemporal() {       return temporal;     }      public void setTemporal(boolean temporal) {       this.temporal = temporal;     }   }    private static Map&gt;&gt; readPropertyProviderIds(String filename) {     ObjectMapper mapper = new ObjectMapper();      try {       Map&gt;&gt; resourceMetricMap =               mapper.readValue(ClassLoader.getSystemResourceAsStream(filename),                       new TypeReference&gt;&gt;&gt;() {});        Map&gt;&gt; resourceMetrics =               new HashMap&gt;&gt;();        for (Map.Entry&gt;&gt; resourceEntry : resourceMetricMap.entrySet()) {         Map&gt; componentMetrics = new HashMap&gt;();          for (Map.Entry&gt; componentEntry : resourceEntry.getValue().entrySet()) {           Map metrics = new HashMap();            for (Map.Entry metricEntry : componentEntry.getValue().entrySet()) {             String property = metricEntry.getKey();             Metric metric = metricEntry.getValue();              metrics.put(property, new PropertyInfo(metric.getMetric(), metric.isTemporal(), metric.isPointInTime()));           }           componentMetrics.put(componentEntry.getKey(), metrics);         }         resourceMetrics.put(resourceEntry.getKey(), componentMetrics);       }       return resourceMetrics;     }     catch (IOException e) {       throw new IllegalStateException(&quot;Can't read properties file &quot; + filename, e);     }   } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4293</td>
    <td align="left">https://github.com/apache/ambari/blob/2bc4779a1e6aabe638101fc8b0e28cd1963d6b13/contrib/ambari-scom/ambari-scom-server/src/main/java/org/apache/ambari/scom/utilities/SCOMMetricHelper.java/#L32-L119</td>
    <td align="right">1</td>
    <td align="right">438</td>
    <td align="right">4293</td>
  </tr>
  <tr valign="top">
    <td align="right">442</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells the bad smells are: 1. Blob&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class FileIODecorator extends AbstractFileIO {     /** File I/O delegate */     protected final FileIO delegate;      /**      *      * @param delegate File I/O delegate      */     public FileIODecorator(FileIO delegate) {         this.delegate = delegate;     }      /** {@inheritDoc} */     @Override public int getFileSystemBlockSize() {         return delegate.getFileSystemBlockSize();     }      /** {@inheritDoc} */     @Override public long getSparseSize() {         return delegate.getSparseSize();     }      /** {@inheritDoc} */     @Override public int punchHole(long pos, int len) {         return delegate.punchHole(pos, len);     }      /** {@inheritDoc} */     @Override public long position() throws IOException {         return delegate.position();     }      /** {@inheritDoc} */     @Override public void position(long newPosition) throws IOException {         delegate.position(newPosition);     }      /** {@inheritDoc} */     @Override public int read(ByteBuffer destBuf) throws IOException {         return delegate.read(destBuf);     }      /** {@inheritDoc} */     @Override public int read(ByteBuffer destBuf, long position) throws IOException {         return delegate.read(destBuf, position);     }      /** {@inheritDoc} */     @Override public int read(byte[] buf, int off, int len) throws IOException {         return delegate.read(buf, off, len);     }      /** {@inheritDoc} */     @Override public int write(ByteBuffer srcBuf) throws IOException {         return delegate.write(srcBuf);     }      /** {@inheritDoc} */     @Override public int write(ByteBuffer srcBuf, long position) throws IOException {         return delegate.write(srcBuf, position);     }      /** {@inheritDoc} */     @Override public int write(byte[] buf, int off, int len) throws IOException {         return delegate.write(buf, off, len);     }      /** {@inheritDoc} */     @Override public MappedByteBuffer map(int sizeBytes) throws IOException {         return delegate.map(sizeBytes);     }      /** {@inheritDoc} */     @Override public void force() throws IOException {         delegate.force();     }      /** {@inheritDoc} */     @Override public void force(boolean withMetadata) throws IOException {         delegate.force(withMetadata);     }      /** {@inheritDoc} */     @Override public long size() throws IOException {         return delegate.size();     }      /** {@inheritDoc} */     @Override public void clear() throws IOException {         delegate.clear();     }      /** {@inheritDoc} */     @Override public void close() throws IOException {         delegate.close();     } }</td>
    <td align="left">blob</td>
    <td align="left">1. blob </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4303</td>
    <td align="left">https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/file/FileIODecorator.java/#L27-L123</td>
    <td align="right">1</td>
    <td align="right">442</td>
    <td align="right">4303</td>
  </tr>
  <tr valign="top">
    <td align="right">451</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells the bad smells are: 1. Long Method, 2. Blob&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class RemoteWasbDelegationTokenManager     implements WasbDelegationTokenManager {    /**    * Configuration parameter name expected in the configuration    * object to provide the url of the delegation token service to fetch the delegation tokens.    */   public static final String KEY_DELEGATION_TOKEN_SERVICE_URLS =       &quot;fs.azure.delegation.token.service.urls&quot;;   /**    * Configuration key to enable http retry policy for delegation token service calls.    */   public static final String DT_MANAGER_HTTP_CLIENT_RETRY_POLICY_ENABLED_KEY =       &quot;fs.azure.delegationtokenservice.http.retry.policy.enabled&quot;;   /**    * Configuration key for delegation token service http retry policy spec.    */   public static final String DT_MANAGER_HTTP_CLIENT_RETRY_POLICY_SPEC_KEY =       &quot;fs.azure.delegationtokenservice.http.retry.policy.spec&quot;;   /**    * Default remote delegation token manager endpoint.    */   private static final String DEFAULT_DELEGATION_TOKEN_MANAGER_ENDPOINT =       &quot;/tokenmanager/v1&quot;;   /**    * Default for delegation token service http retry policy spec.    */   private static final String DT_MANAGER_HTTP_CLIENT_RETRY_POLICY_SPEC_DEFAULT =       &quot;10,3,100,2&quot;;    private static final boolean       DT_MANAGER_HTTP_CLIENT_RETRY_POLICY_ENABLED_DEFAULT = true;    private static final Text WASB_DT_SERVICE_NAME = new Text(&quot;WASB_DT_SERVICE&quot;);   /**    * Query parameter value for Getting delegation token http request    */   private static final String GET_DELEGATION_TOKEN_OP = &quot;GETDELEGATIONTOKEN&quot;;   /**    * Query parameter value for renewing delegation token http request    */   private static final String RENEW_DELEGATION_TOKEN_OP =       &quot;RENEWDELEGATIONTOKEN&quot;;   /**    * Query parameter value for canceling the delegation token http request    */   private static final String CANCEL_DELEGATION_TOKEN_OP =       &quot;CANCELDELEGATIONTOKEN&quot;;   /**    * op parameter to represent the operation.    */   private static final String OP_PARAM_KEY_NAME = &quot;op&quot;;   /**    * renewer parameter to represent the renewer of the delegation token.    */   private static final String RENEWER_PARAM_KEY_NAME = &quot;renewer&quot;;   /**    * service parameter to represent the service which returns delegation tokens.    */   private static final String SERVICE_PARAM_KEY_NAME = &quot;service&quot;;   /**    * token parameter to represent the delegation token.    */   private static final String TOKEN_PARAM_KEY_NAME = &quot;token&quot;;   private WasbRemoteCallHelper remoteCallHelper;   private String[] dtServiceUrls;   private boolean isSpnegoTokenCacheEnabled;    public RemoteWasbDelegationTokenManager(Configuration conf)       throws IOException {     RetryPolicy retryPolicy = RetryUtils.getMultipleLinearRandomRetry(conf,         DT_MANAGER_HTTP_CLIENT_RETRY_POLICY_ENABLED_KEY,         DT_MANAGER_HTTP_CLIENT_RETRY_POLICY_ENABLED_DEFAULT,         DT_MANAGER_HTTP_CLIENT_RETRY_POLICY_SPEC_KEY,         DT_MANAGER_HTTP_CLIENT_RETRY_POLICY_SPEC_DEFAULT);     this.isSpnegoTokenCacheEnabled =         conf.getBoolean(Constants.AZURE_ENABLE_SPNEGO_TOKEN_CACHE, true);      remoteCallHelper = new SecureWasbRemoteCallHelper(retryPolicy, true,         isSpnegoTokenCacheEnabled);     this.dtServiceUrls =         conf.getTrimmedStrings(KEY_DELEGATION_TOKEN_SERVICE_URLS);     if (this.dtServiceUrls == null || this.dtServiceUrls.length &lt;= 0) {       throw new IOException(           KEY_DELEGATION_TOKEN_SERVICE_URLS + &quot; config not set&quot;               + &quot; in configuration.&quot;);     }   }    @Override   public Token getDelegationToken(       String renewer) throws IOException {     URIBuilder uriBuilder =         new URIBuilder().setPath(DEFAULT_DELEGATION_TOKEN_MANAGER_ENDPOINT)             .addParameter(OP_PARAM_KEY_NAME, GET_DELEGATION_TOKEN_OP)             .addParameter(RENEWER_PARAM_KEY_NAME, renewer)             .addParameter(SERVICE_PARAM_KEY_NAME,                 WASB_DT_SERVICE_NAME.toString());     String responseBody = remoteCallHelper         .makeRemoteRequest(dtServiceUrls, uriBuilder.getPath(),             uriBuilder.getQueryParams(), HttpGet.METHOD_NAME);     return TokenUtils.toDelegationToken(JsonUtils.parse(responseBody));   }    @Override   public long renewDelegationToken(Token token)       throws IOException {     URIBuilder uriBuilder =         new URIBuilder().setPath(DEFAULT_DELEGATION_TOKEN_MANAGER_ENDPOINT)             .addParameter(OP_PARAM_KEY_NAME, RENEW_DELEGATION_TOKEN_OP)             .addParameter(TOKEN_PARAM_KEY_NAME, token.encodeToUrlString());      String responseBody = remoteCallHelper         .makeRemoteRequest(dtServiceUrls, uriBuilder.getPath(),             uriBuilder.getQueryParams(), HttpPut.METHOD_NAME);      Map parsedResp = JsonUtils.parse(responseBody);     return ((Number) parsedResp.get(&quot;long&quot;)).longValue();   }    @Override   public void cancelDelegationToken(Token token)       throws IOException {     URIBuilder uriBuilder =         new URIBuilder().setPath(DEFAULT_DELEGATION_TOKEN_MANAGER_ENDPOINT)             .addParameter(OP_PARAM_KEY_NAME, CANCEL_DELEGATION_TOKEN_OP)             .addParameter(TOKEN_PARAM_KEY_NAME, token.encodeToUrlString());     remoteCallHelper.makeRemoteRequest(dtServiceUrls, uriBuilder.getPath(),         uriBuilder.getQueryParams(), HttpPut.METHOD_NAME);   } }</td>
    <td align="left">blob</td>
    <td align="left">1. long method, 2. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. long method</td>
    <td align="left">blob</td>
    <td align="right">0</td>
    <td align="right">4407</td>
    <td align="left">https://github.com/apache/hadoop/blob/128dd91e10080bdcbcd7d555fa3c4105e55a6b51/hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/security/RemoteWasbDelegationTokenManager.java/#L39-L169</td>
    <td align="right">1</td>
    <td align="right">451</td>
    <td align="right">4407</td>
  </tr>
  <tr valign="top">
    <td align="right">456</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SSLConfigClient extends SSLConfig {    private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(SSLConfigClient.class);    private final Properties properties;   private final boolean userSslEnabled;   private final String trustStoreType;   private final String trustStorePath;   private final String trustStorePassword;   private final boolean disableHostVerification;   private final boolean disableCertificateVerification;   private final boolean useSystemTrustStore;   private final String protocol;   private final int handshakeTimeout;   private final String provider;    private final String emptyString = new String();    public SSLConfigClient(Properties properties) throws DrillException {     this.properties = properties;     userSslEnabled = getBooleanProperty(DrillProperties.ENABLE_TLS);     trustStoreType = getStringProperty(DrillProperties.TRUSTSTORE_TYPE, &quot;JKS&quot;);     trustStorePath = getStringProperty(DrillProperties.TRUSTSTORE_PATH, &quot;&quot;);     trustStorePassword = getStringProperty(DrillProperties.TRUSTSTORE_PASSWORD, &quot;&quot;);     disableHostVerification = getBooleanProperty(DrillProperties.DISABLE_HOST_VERIFICATION);     disableCertificateVerification = getBooleanProperty(DrillProperties.DISABLE_CERT_VERIFICATION);     useSystemTrustStore = getBooleanProperty(DrillProperties.USE_SYSTEM_TRUSTSTORE);     protocol = getStringProperty(DrillProperties.TLS_PROTOCOL, DEFAULT_SSL_PROTOCOL);     int hsTimeout = getIntProperty(DrillProperties.TLS_HANDSHAKE_TIMEOUT, DEFAULT_SSL_HANDSHAKE_TIMEOUT_MS);     if (hsTimeout &lt;= 0) {       hsTimeout = DEFAULT_SSL_HANDSHAKE_TIMEOUT_MS;     }     handshakeTimeout = hsTimeout;     // If provider is OPENSSL then to debug or run this code in an IDE, you will need to enable     // the dependency on netty-tcnative with the correct classifier for the platform you use.     // This can be done by enabling the openssl profile.     // If the IDE is Eclipse, it requires you to install an additional Eclipse plugin available here:     // http://repo1.maven.org/maven2/kr/motd/maven/os-maven-plugin/1.6.1/os-maven-plugin-1.6.1.jar     // or from your local maven repository:     // ~/.m2/repository/kr/motd/maven/os-maven-plugin/1.6.1/os-maven-plugin-1.6.1.jar     // Note that installing this plugin may require you to start with a new workspace     provider = getStringProperty(DrillProperties.TLS_PROVIDER, DEFAULT_SSL_PROVIDER);   }    private boolean getBooleanProperty(String propName) {     return (properties != null) &amp;&amp; (properties.containsKey(propName))         &amp;&amp; (properties.getProperty(propName).compareToIgnoreCase(&quot;true&quot;) == 0);   }    private String getStringProperty(String name, String defaultValue) {     String value = &quot;&quot;;     if ( (properties != null) &amp;&amp; (properties.containsKey(name))) {       value = properties.getProperty(name);     }     if (value.isEmpty()) {       value = defaultValue;     }     value = value.trim();     return value;   }    private int getIntProperty(String name, int defaultValue) {     int value = defaultValue;     if (properties != null) {       String property = properties.getProperty(name);       if (property != null &amp;&amp; property.length() &gt; 0) {         value = Integer.decode(property);       }     }     return value;   }    public void validateKeyStore() throws DrillException {    }    @Override   public SslContext initNettySslContext() throws DrillException {     final SslContext sslCtx;      if (!userSslEnabled) {       return null;     }      TrustManagerFactory tmf;     try {       tmf = initializeTrustManagerFactory();       sslCtx = SslContextBuilder.forClient()           .sslProvider(getProvider())           .trustManager(tmf)           .protocols(protocol)           .build();     } catch (Exception e) {       // Catch any SSL initialization Exceptions here and abort.       throw new DrillException(new StringBuilder()           .append(&quot;SSL is enabled but cannot be initialized due to the following exception: &quot;)           .append(&quot;[ &quot;)           .append(e.getMessage())           .append(&quot;]. &quot;)           .toString());     }     this.nettySslContext = sslCtx;     return sslCtx;   }    @Override   public SSLContext initJDKSSLContext() throws DrillException {     final SSLContext sslCtx;      if (!userSslEnabled) {       return null;     }      TrustManagerFactory tmf;     try {       tmf = initializeTrustManagerFactory();       sslCtx = SSLContext.getInstance(protocol);       sslCtx.init(null, tmf.getTrustManagers(), null);     } catch (Exception e) {       // Catch any SSL initialization Exceptions here and abort.       throw new DrillException(new StringBuilder()           .append(&quot;SSL is enabled but cannot be initialized due to the following exception: &quot;)           .append(&quot;[ &quot;)           .append(e.getMessage())           .append(&quot;]. &quot;)           .toString());     }     this.jdkSSlContext = sslCtx;     return sslCtx;   }    @Override   public SSLEngine createSSLEngine(BufferAllocator allocator, String peerHost, int peerPort) {     SSLEngine engine = super.createSSLEngine(allocator, peerHost, peerPort);      if (!this.disableHostVerification()) {       SSLParameters sslParameters = engine.getSSLParameters();       // only available since Java 7       sslParameters.setEndpointIdentificationAlgorithm(&quot;HTTPS&quot;);       engine.setSSLParameters(sslParameters);     }      engine.setUseClientMode(true);      try {       engine.setEnableSessionCreation(true);     } catch (Exception e) {       // Openssl implementation may throw this.       logger.debug(&quot;Session creation not enabled. Exception: {}&quot;, e.getMessage());     }      return engine;   }    @Override   public boolean isUserSslEnabled() {     return userSslEnabled;   }    @Override   public boolean isHttpsEnabled() {     return false;   }    @Override   public String getKeyStoreType() {     return emptyString;   }    @Override   public String getKeyStorePath() {     return emptyString;   }    @Override   public String getKeyStorePassword() {     return emptyString;   }    @Override   public String getKeyPassword() {     return emptyString;   }    @Override   public String getTrustStoreType() {     return trustStoreType;   }    @Override   public boolean hasTrustStorePath() {     return !trustStorePath.isEmpty();   }    @Override   public String getTrustStorePath() {     return trustStorePath;   }    @Override   public boolean hasTrustStorePassword() {     return !trustStorePassword.isEmpty();   }    @Override   public String getTrustStorePassword() {     return trustStorePassword;   }    @Override   public String getProtocol() {     return protocol;   }    @Override   public SslProvider getProvider() {     return provider.equalsIgnoreCase(&quot;JDK&quot;) ? SslProvider.JDK : SslProvider.OPENSSL;   }    @Override   public int getHandshakeTimeout() {     return handshakeTimeout;   }    @Override   public Mode getMode() {     return Mode.CLIENT;   }    @Override   public boolean disableHostVerification() {     return disableHostVerification;   }    @Override   public boolean disableCertificateVerification() {     return disableCertificateVerification;   }    @Override   public boolean useSystemTrustStore() {     return useSystemTrustStore;   }    public boolean isSslValid() {     return true;   }  }</td>
    <td align="left">blob</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4453</td>
    <td align="left">https://github.com/apache/drill/blob/5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3/exec/java-exec/src/main/java/org/apache/drill/exec/ssl/SSLConfigClient.java/#L33-L281</td>
    <td align="right">1</td>
    <td align="right">456</td>
    <td align="right">4453</td>
  </tr>
  <tr valign="top">
    <td align="right">464</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    class Cel4rreg {          long seghigh;         long seglow;         int p_dsafmt = -1;         long p_dsaptr;         RegisterSet regs;          /**          * Creates the instance and attempts to locate the registers.          */         Cel4rreg() {             /* Debug option - before we do anything else, try using the old svcdump code */             String useSvcdump = System.getProperty(&quot;zebedee.use.svcdump&quot;);             if (useSvcdump != null &amp;&amp; useSvcdump.equals(&quot;true&quot;)) {                 getRegistersFromSvcdump();                 return;             }              /*              * Try and get the registers from the following locations:              *              * 1) RTM2 work area              * 2) BPXGMSTA service              * 3) linkage stack entries              * 4) TCB              * 5) Usta              *              * if any succeeds we return otherwise move to the next location.              */              int whereCount = 0;              try {                 if ((regs = getRegistersFromRTM2()) != null &amp;&amp; whereCount++ &gt;= whereSkip) {                     whereFound = &quot;RTM2&quot;;                     failingRegisters = regs;                     registers = regs;                     return;                 }             } catch (IOException e) {                 throw new Error(&quot;oops: &quot; + e);             }             /* If we still have not found a dsa, invoke kernel svs */             try {                 if ((regs = getRegistersFromBPXGMSTA()) != null &amp;&amp; whereCount++ &gt;= whereSkip) {                     whereFound = regs.whereFound();                     if (whereFound == null)                         whereFound = &quot;BPXGMSTA&quot;;                     if (tcb.tcbcmp() != 0)                         failingRegisters = regs;                     registers = regs;                     return;                 }             } catch (IOException e) {                 //throw new Error(&quot;oops: &quot; + e);             }             try {                 if ((regs = getRegistersFromLinkageStack()) != null &amp;&amp; whereCount++ &gt;= whereSkip) {                     whereFound = &quot;Linkage&quot;;                     if (tcb.tcbcmp() != 0)                         failingRegisters = regs;                     registers = regs;                     return;                 }             } catch (IOException e) {                 log.logp(Level.WARNING,&quot;com.ibm.j9ddr.corereaders.tdump.zebedee.le.Caa.Cel4rreg&quot;, &quot;Cel4rreg&quot;,&quot;Unexepected exception&quot;, e);                 throw new Error(&quot;Unexpected IOException: &quot; + e);             }             try {                 if ((regs = getRegistersFromTCB()) != null &amp;&amp; whereCount++ &gt;= whereSkip) {                     whereFound = &quot;TCB&quot;;                     if (tcb.tcbcmp() != 0)                         failingRegisters = regs;                     registers = regs;                     return;                 }             } catch (IOException e) {                 throw new Error(&quot;oops: &quot; + e);             }             try {                 if (is64bit) {                     /* This is from celqrreg.plx370: &quot;Get the save R4 from a NOSTACK call&quot; */                     long lca = CeexlaaTemplate.getCeelaa_lca64(inputStream, laa);                     p_dsaptr = CeelcaTemplate.getCeelca_savstack(inputStream, lca);                     log.fine(&quot;p_dsaptr from lca = &quot; + hex(p_dsaptr));                     p_dsafmt = stackdirection = CEECAASTACK_DOWN;                     if (validateDSA() == 0 &amp;&amp; whereCount++ &gt;= whereSkip) {                         whereFound = &quot;LCA&quot;;                         return;                     }                 }             } catch (IOException e) {                 throw new Error(&quot;oops: &quot; + e);             }             /* Last ditch */             try {                 if ((regs = getRegistersFromUsta()) != null &amp;&amp; whereCount++ &gt;= whereSkip) {                     whereFound = regs.whereFound();                     if (tcb.tcbcmp() != 0)                         failingRegisters = regs;                     registers = regs;                     return;                 }             } catch (IOException e) {             }             whereFound = &quot;not found&quot;;         }          /**          * Try and get the registers from the RTM2 work area. Returns null if none found. As a          * side-effect it also sets the stackdirection.          */         private RegisterSet getRegistersFromRTM2() throws IOException {             int level = ceecaalevel();             log.finer(&quot;caa level is &quot; + level);             /* If the CAA level is 13 or greater, get stack direction from               * CAA.  For older releases or the dummy CAA, default stack               * direction to UP.              */             if (is64bit) {                 /* Always use downstack in 64-bit mode? */                 stackdirection = CEECAASTACK_DOWN;                 log.finer(&quot;stack direction is down&quot;);             } else if (level &gt;= 13) { /* If LE 2.10 or higher */                 /* Obtain dsa format from the CAA */                 stackdirection = ceecaa_stackdirection();                 log.finer(&quot;stack direction is &quot; + (stackdirection == CEECAASTACK_UP ? &quot;up&quot; : &quot;down&quot;));             } else {                 stackdirection = CEECAASTACK_UP;                 log.finer(&quot;stack direction is up&quot;);             }             if ((stackdirection == CEECAASTACK_DOWN) &amp;&amp; !is64bit) {                 try {                     long tempptr = ceecaasmcb();			//the ceecaasmcb call is not currently supported for 64 bit CAAs                     seghigh = SmcbTemplate.getSmcb_dsbos(inputStream, tempptr);                     seglow = CeexstkhTemplate.getStkh_stackfloor(inputStream, seghigh);                 } catch (Exception e) {                     //throw new Error(&quot;oops: &quot; + e);                     return null;                 }             }             /* At this point, a valid CAA has been obtained. Access the RTM2 to obtain the DSA. */             long rtm2ptr = tcb.tcbrtwa();             if (rtm2ptr != 0) {                 try {                     log.finer(&quot;found some rtm2 registers&quot;);                     RegisterSet regs = new RegisterSet();                     long rtm2grs = rtm2ptr + Ihartm2aTemplate.getRtm2ereg$offset();                     long rtm2grshi = rtm2ptr + Ihartm2aTemplate.getRtm2g64h$offset();                     for (int i = 0; i &lt; 16; i++) {                         long low = space.readUnsignedInt(rtm2grs + i*4);                         long high = is64bit ? space.readUnsignedInt(rtm2grshi + i*4) : 0;                         regs.setRegister(i, (high &lt;&lt; 32) | low);                     }                     long rtm2psw = rtm2ptr + Ihartm2aTemplate.getRtm2apsw$offset();                     regs.setPSW(space.readLong(rtm2psw));                     if (registersValid(regs)) {                         log.finer(&quot;found good dsa in rtm2&quot;);                     } else {                         log.finer(&quot;bad dsa in rtm2&quot;);                         regs = null;                     }                     return regs;                 } catch (IOException e) {                     throw e;                 } catch (Exception e) {                     throw new Error(&quot;oops: &quot; + e);                 }             } else {                 log.finer(&quot;failed to get registers from rtm2&quot;);                 return null;             }         }          /**          * Validates the given register set with retry for down stack          */         private boolean registersValid(RegisterSet regs) throws IOException {             if (regs == null)                 return false;             p_dsafmt = stackdirection;             if (p_dsafmt == CEECAASTACK_DOWN) {                 p_dsaptr = regs.getRegisterAsAddress(4);                 log.finer(&quot;p_dsaptr from reg 4 = &quot; + hex(p_dsaptr));             } else {                 p_dsaptr = regs.getRegisterAsAddress(13);                 log.finer(&quot;p_dsaptr from reg 13 = &quot; + hex(p_dsaptr));             }             int lastrc = validateDSA();             if (lastrc == 0) {                 log.finer(&quot;found valid dsa&quot;);                 return true;             } else {                 if (stackdirection == CEECAASTACK_DOWN) {                     p_dsaptr = regs.getRegisterAsAddress(13);                     log.finer(&quot;p_dsaptr from reg 13 (again) = &quot; + hex(p_dsaptr));                     p_dsafmt = CEECAASTACK_UP;                     lastrc = validateDSA();                     if (lastrc == WARNING) {                         lastrc = validateDSA();                         if (lastrc == 0) {                             log.finer(&quot;found valid dsa&quot;);                             return true;                         }                     }                 }                 /* reset values */                 log.finer(&quot;p_dsaptr invalid so reset: &quot; + hex(p_dsaptr));                 p_dsaptr = 0;             }             return false;         }          /**          * Try and get the registers from the BPXGMSTA service.          */         private RegisterSet getRegistersFromBPXGMSTA() throws IOException {             RegisterSet regs = tcb.getRegistersFromBPXGMSTA();             if (is64bit)                 // celqrreg appears to always assume down stack                 stackdirection = CEECAASTACK_DOWN;             if (registersValid(regs)) {                 log.finer(&quot;found good dsa in BPXGMSTA&quot;);                 return regs;             } else {                 log.finer(&quot;BPX registers are invalid so keep looking&quot;);                 return null;             }         }          /**          * Try and get the registers from the linkage stack.          */         private RegisterSet getRegistersFromLinkageStack() throws IOException {             log.finer(&quot;enter getRegistersFromLinkageStack&quot;);             try {                 Lse[] linkageStack = tcb.getLinkageStack();                 /* If Linkage stack is empty, leave */                 if (linkageStack.length == 0) {                     log.finer(&quot;empty linkage stack&quot;);                     return null;                 }                 for (int i = 0; i &lt; linkageStack.length; i++) {                     Lse lse = linkageStack[i];                     if (lse.lses1pasn() == space.getAsid()) {                         RegisterSet regs = new RegisterSet();                         if (lse.isZArchitecture() &amp;&amp; (lse.lses1typ7() == Lse.LSED1PC || lse.lses1typ7() == Lse.LSED1BAKR)) {                             log.finer(&quot;found some z arch registers&quot;);                             regs.setPSW(lse.lses1pswh());                             for (int j = 0; j &lt; 16; j++) {                                 regs.setRegister(j, lse.lses1grs(j));                             }                         } else {                             log.finer(&quot;found some non z arch registers&quot;);                             regs.setPSW(lse.lsespsw());                             for (int j = 0; j &lt; 16; j++) {                                 regs.setRegister(j, lse.lsesgrs(j));                             }                         }                         if (registersValid(regs)) {                             log.finer(&quot;found good dsa in linkage stack&quot;);                             return regs;                         }                     } else {                         log.finer(&quot;different asid: &quot; + hex(lse.lses1pasn()));                     }                 }             } catch (IOException e) {                 throw e;             } catch (Exception e) {                 throw new Error(&quot;oops: &quot; + e);             }             log.finer(&quot;could not find registers in linkage stack&quot;);             return null;         }          /**          * Try and get the registers from the TCB.          */         private RegisterSet getRegistersFromTCB() throws IOException {             log.finer(&quot;getRegistersFromTCB&quot;);             RegisterSet regs = tcb.getRegisters();             if (registersValid(regs)) {                 log.finer(&quot;found good dsa in TCB&quot;);                 return regs;             } else {                 return null;             }         }          /**          * Try and get the registers from the Usta. Note that this is a kind of last-ditch          * thing and so no validation is done.          */         private RegisterSet getRegistersFromUsta() throws IOException {             log.fine(&quot;enter getRegistersFromUsta&quot;);             RegisterSet regs = tcb.getRegistersFromUsta();             if (registersValid(regs)) {                 log.finer(&quot;found good dsa in Usta&quot;);                 return regs;             } else {                 /* If there are more than three stack entries that's probably better than nothing */                 boolean isDownStack = stackdirection == CEECAASTACK_DOWN;                 long dsaptr;                 if (isDownStack) {                     dsaptr = regs.getRegister(4);                     log.finer(&quot;p_dsaptr from reg 4 = &quot; + hex(p_dsaptr));                 } else {                     dsaptr = regs.getRegister(13);                     log.finer(&quot;p_dsaptr from reg 13 = &quot; + hex(p_dsaptr));                 }                 try {                     DsaStackFrame dsa = new DsaStackFrame(dsaptr, isDownStack, regs, space, Caa.this);                     int count = 0;                     for (; dsa != null; dsa = dsa.getParentFrame()) {                     	if (++count &gt; 3) {                     		p_dsaptr = dsaptr;                     		p_dsafmt = stackdirection;                     		return regs;                     	}                     }                 } catch (IOException e) {                 } catch (AssertionError e) {                 }             }             return null;         }          /**          * Try and get the registers using the old svcdump code. This is for debugging          * purposes only. Uses reflection so there is no compilation dependency.          */         private void getRegistersFromSvcdump() {         }          /**          * Validate the given DSA. Returns 0 if valid. Note because this is Java, we can't          * modify the input parameters, so we use the instance variables instead and          * val_dsa == p_dsaptr, val_dsafmt == p_dsafmt.          */         private int validateDSA() {             log.finer(&quot;attempt to validate &quot; + hex(p_dsaptr) + &quot; on &quot; + (p_dsafmt == CEECAASTACK_DOWN ? &quot;down&quot; : &quot;up&quot;) + &quot; stack&quot;);             try {                 if (is64bit) {                     assert laa != 0;                     long l_sancptr = CeexlaaTemplate.getCeelaa_sanc64(inputStream, laa);                     assert l_sancptr != 0;                     long seghigh = CeexsancTemplate.getSanc_bos(inputStream, l_sancptr);                     long seglow = 0;                     long sanc_stack = CeexsancTemplate.getSanc_stack(inputStream, l_sancptr);                     long sanc_user_stack = CeexsancTemplate.getSanc_user_stack(inputStream, l_sancptr);                     if (sanc_stack == sanc_user_stack) {                         /* Get Stackfloor from sanc */                         seglow = CeexsancTemplate.getSanc_user_floor(inputStream, l_sancptr);                     } else {                         /* Get StackFloor from LAA */                         seglow = CeexlaaTemplate.getCeelaa_stackfloor64(inputStream, laa);                     }                     if (p_dsaptr &lt; seghigh &amp;&amp; (p_dsaptr + 0x800) &gt;= seglow &amp;&amp; (p_dsaptr &amp; 0xf) == 0) {                         log.finer(&quot;dsa &quot; + hex(p_dsaptr) + &quot; is within seglow = &quot; + hex(seglow) + &quot; seghigh = &quot; + hex(seghigh));                         return 0;                     } else {                         log.finer(&quot;dsa &quot; + hex(p_dsaptr) + &quot; is NOT within seglow = &quot; + hex(seglow) + &quot; seghigh = &quot; + hex(seghigh));                         return ERROR;                     }                 }                 if (p_dsafmt == CEECAASTACK_DOWN) {                     /* the check for being in the current segment is commented out */                 } else {                     if (is64bit)                         return ERROR;                     long tptr = ceecaaerrcm();                     /* Chicken egg situation */                     //assert !space.is64bit();                     /* If the input DSA address is within the HCOM and double word aligned,                       * assume that it is good. */                     if (p_dsaptr &lt; (tptr + hcomLength) &amp;&amp; p_dsaptr &gt;= tptr &amp;&amp; (p_dsaptr &amp; 7) == 0) {                         log.finer(&quot;upstack dsa &quot; + hex(p_dsaptr) + &quot; is inside hcom&quot;);                         return 0;                     }                 }                 long ddsa = ceecaaddsa();                 long dsaptr = p_dsaptr;                 int dsafmt8 = p_dsafmt;                 long slowdsaptr = p_dsaptr;                 int slowdsafmt8 = p_dsafmt;                 for (boolean slow = false;; slow = !slow) {                     Ceexdsaf dsaf = new Ceexdsaf(space, dsaptr, dsafmt8, is64bit);                     /* If the stack direction is down but we are validating an upstack DSA                      * and the current DSA is inside the current segment of the down stack,                      * assume this must be a OS_NOSTACK call, return WARNING and replace                      * input DSA and DSAFmt with R4 value from this DSA */                     log.finer(&quot;looping with dsa = &quot; + hex(dsaptr));                     if (stackdirection == CEECAASTACK_DOWN &amp;&amp; p_dsafmt == CEECAASTACK_UP &amp;&amp;                             dsaptr &lt; seghigh &amp;&amp; dsaptr &gt;= seglow) {                         p_dsaptr = CeedsaTemplate.getCeedsar4(inputStream, dsaptr);                         p_dsafmt = CEECAASTACK_DOWN;                         log.finer(&quot;warning, try switching to down stack&quot;);                         return WARNING;                     }                     long callers_dsaptr = dsaf.DSA_Prev;                     dsafmt8 = dsaf.DSA_Format;                     /* If we are not able to backchain any farther or we have encountered                      * a linkage stack, assume that the input DSA address is bad. */                     if (callers_dsaptr == 0 || callers_dsaptr == F1SA) {                         log.finer(&quot;cannot backchain futher because &quot; + (callers_dsaptr == 0 ? &quot;zero&quot; : &quot;linkage stack&quot;) + &quot; found&quot;);                         return ERROR;                     }                     /* If we were able to backchain to the dummy DSA, the input DSA address                      * must be good. */                     if (callers_dsaptr == ddsa) {                         log.finer(&quot;dummy dsa reached&quot;);                         return 0;                     }                     /* If we backchained across a stack transition, assume that the input                      * DSA address is good. */                     if (dsafmt8 != p_dsafmt) {                         log.finer(&quot;backchained across a stack transition&quot;);                         return 0;                     }                     /* If we have located an upstack DSA with a valid NAB value, assume that                      * the input DSA address is good. */                     if (dsafmt8 == CEECAASTACK_UP) {                         long tptr = CeedsaTemplate.getCeedsanab(inputStream, callers_dsaptr);                         if (tptr == dsaptr) {                             log.finer(&quot;upstack DSA is good&quot;);                             return 0;                         }                     }                     dsaptr = callers_dsaptr;                     /* We use the Tortoise and the Hare algorithm to detect loops. If the slow                      * iterator is lapped it means there is a loop. */                     if (slow) {                         dsaf = new Ceexdsaf(space, slowdsaptr, slowdsafmt8, is64bit);                         slowdsaptr = dsaf.DSA_Prev;                         slowdsafmt8 = dsaf.DSA_Format;                     }                     if (dsaptr == slowdsaptr) {                         log.finer(&quot;loop detected in DSA chain&quot;);                         return ERROR;                     }                 }             } catch (IOException e) {                 /* Any bad read means the DSA was invalid */                 log.logp(Level.FINER,&quot;com.ibm.j9ddr.corereaders.tdump.zebedee.le.Caa.Cel4rreg&quot;, &quot;validateDSA&quot;,&quot;Bad read&quot;, e);                 return ERROR;             } catch (Exception e) {                 log.logp(Level.WARNING,&quot;com.ibm.j9ddr.corereaders.tdump.zebedee.le.Caa.Cel4rreg&quot;, &quot;validateDSA&quot;,&quot;Unexepected exception&quot;, e);                 throw new Error(&quot;Unexpected Exception:: &quot; + e);             }         }     }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4492</td>
    <td align="left">https://github.com/eclipse/openj9/blob/4911084853eb75b20e037c434ad4521b7317ebfb/debugtools/DDR_VM/src/com/ibm/j9ddr/corereaders/tdump/zebedee/le/Caa.java/#L348-L800</td>
    <td align="right">1</td>
    <td align="right">464</td>
    <td align="right">4492</td>
  </tr>
  <tr valign="top">
    <td align="right">496</td>
    <td align="left">{&quot;output&quot;: &quot;YES I found bad smells\nthe bad smells are: Blob, Long Method&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class DiscoverAnnotatedBeans implements DynamicDeployer {         public AppModule deploy(AppModule appModule) throws OpenEJBException {             for (EjbModule ejbModule : appModule.getEjbModules()) {                 ejbModule.initAppModule(appModule);                 setModule(ejbModule);                 try {                     deploy(ejbModule);                 } finally {                     removeModule();                 }             }             for (ClientModule clientModule : appModule.getClientModules()) {                 clientModule.initAppModule(appModule);                 setModule(clientModule);                 try {                     deploy(clientModule);                 } finally {                     removeModule();                 }             }             for (ConnectorModule connectorModule : appModule.getConnectorModules()) {                 connectorModule.initAppModule(appModule);                 setModule(connectorModule);                 try {                     deploy(connectorModule);                 } finally {                     removeModule();                 }             }             for (WebModule webModule : appModule.getWebModules()) {                 webModule.initAppModule(appModule);                 setModule(webModule);                 try {                     deploy(webModule);                 } finally {                     removeModule();                 }             }             final AdditionalBeanDiscoverer discoverer = SystemInstance.get().getComponent(AdditionalBeanDiscoverer.class);             if (discoverer != null) {                 appModule = discoverer.discover(appModule);             }             return appModule;         }          public ClientModule deploy(ClientModule clientModule) throws OpenEJBException {              if (clientModule.getApplicationClient() == null){                 clientModule.setApplicationClient(new ApplicationClient());             }              // Lots of jars have main classes so this might not even be an app client.             // We're not going to scrape it for @LocalClient or @RemoteClient annotations             // unless they flag us specifically by adding a META-INF/application-client.xml             //             // ClientModules that already have a AnnotationFinder have been generated automatically             // from an EjbModule, so we don't skip those ever.             if (clientModule.getFinder() == null &amp;&amp; clientModule.getAltDDs().containsKey(&quot;application-client.xml&quot;))              if (clientModule.getApplicationClient() != null &amp;&amp; clientModule.getApplicationClient().isMetadataComplete()) return clientModule;               IAnnotationFinder finder = clientModule.getFinder();              if (finder == null) {                 try {                     finder = FinderFactory.createFinder(clientModule);                 } catch (MalformedURLException e) {                     startupLogger.warning(&quot;startup.scrapeFailedForClientModule.url&quot;, clientModule.getJarLocation());                     return clientModule;                 } catch (Exception e) {                     startupLogger.warning(&quot;startup.scrapeFailedForClientModule&quot;, e, clientModule.getJarLocation());                     return clientModule;                 }             }              // This method is also called by the deploy(EjbModule) method to see if those             // modules have any @LocalClient or @RemoteClient classes             for (Annotated&gt; clazz : finder.findMetaAnnotatedClasses(LocalClient.class)) {                 clientModule.getLocalClients().add(clazz.get().getName());             }              for (Annotated&gt; clazz : finder.findMetaAnnotatedClasses(RemoteClient.class)) {                 clientModule.getRemoteClients().add(clazz.get().getName());             }              if (clientModule.getApplicationClient() == null){                 if (clientModule.getRemoteClients().size() &gt; 0 || clientModule.getLocalClients().size() &gt; 0) {                     clientModule.setApplicationClient(new ApplicationClient());                 }             }              return clientModule;         }          public ConnectorModule deploy(ConnectorModule connectorModule) throws OpenEJBException {          	org.apache.openejb.jee.Connector connector = connectorModule.getConnector();         	if (connector == null) {         		connector = new org.apache.openejb.jee.Connector();         	}          	// JCA 1.6 - 18.3.1 do not look at annotations if the provided connector         	// deployment descriptor is &quot;meta-data complete&quot;.          	float specVersion = 0;         	try {         		specVersion = Float.parseFloat(connector.getVersion());         	} catch (Exception e) {         	}  			if (specVersion &lt; 1.6 || Boolean.TRUE.equals(connector.isMetadataComplete())) { 				return connectorModule; 			}           	IAnnotationFinder finder = connectorModule.getFinder();         	if (finder == null) {         		try {         			finder = FinderFactory.createFinder(connectorModule); 					connectorModule.setFinder(finder); 				} catch (Exception e) { 					// TODO: some sort of error 					return connectorModule; 				}         	}          	List&gt; connectorClasses = finder.findAnnotatedClasses(Connector.class);          	// are we allowed to have more than one connector class? Not without a deployment descriptor         	if (connector.getResourceAdapter() == null || connector.getResourceAdapter().getResourceAdapterClass() == null ||  connector.getResourceAdapter().getResourceAdapterClass().length() == 0) {         		if (connectorClasses.size() == 0) {         			// fail some validation here too         		}          		if (connectorClasses.size() &gt; 1) {         			// too many connector classes, this is against the spec         			// something like connectorModule.getValidation().fail(ejbName, &quot;abstractAnnotatedAsBean&quot;, annotationClass.getSimpleName(), beanClass.get().getName());         		}         	}          	Class connectorClass = null;         	if (connectorClasses.size() == 1) {         		connectorClass = connectorClasses.get(0);         	}          	if (connectorClasses.size() &gt; 1) {         		for (Class cls : connectorClasses) {         			if (cls.getName().equals(connector.getResourceAdapter().getResourceAdapterClass())) {         				connectorClass = cls;         				break;         			}         		}         	}          	if (connectorClass != null) { 	    		if (connector.getResourceAdapter() == null) { 	    			connector.setResourceAdapter(new ResourceAdapter()); 	    		}  	    		if (connector.getResourceAdapter().getResourceAdapterClass() == null || connector.getResourceAdapter().getResourceAdapterClass().length() == 0) { 	    			connector.getResourceAdapter().setResourceAdapterClass(connectorClass.getName()); 	    		}  	    		Connector connectorAnnotation = connectorClass.getAnnotation(Connector.class);  	    		connector.setDisplayNames(getTexts(connector.getDisplayNames(), connectorAnnotation.displayName())); 	    		connector.setDescriptions(getTexts(connector.getDescriptions(), connectorAnnotation.description()));  	    		connector.setEisType(getString(connector.getEisType(), connectorAnnotation.eisType())); 	    		connector.setVendorName(getString(connector.getVendorName(), connectorAnnotation.vendorName())); 	    		connector.setResourceAdapterVersion(getString(connector.getResourceAdapterVersion(), connectorAnnotation.version()));  	    		if (connector.getIcons().isEmpty()) { 	    			int smallIcons = connectorAnnotation.smallIcon().length; 	    			int largeIcons = connectorAnnotation.largeIcon().length;  	    			for (int i = 0; i &lt; smallIcons &amp;&amp; i &lt; largeIcons; i++) { 	    				Icon icon = new Icon();                         // locale can't be specified in the annotation and it is en by default                         // so on other systems it doesn't work because Icon return the default locale                         icon.setLang(Locale.getDefault().getLanguage()); 	    				if (i &lt; smallIcons) { 	    					icon.setSmallIcon(connectorAnnotation.smallIcon()[i]); 	    				}  	    				if (i &lt; largeIcons) { 	    					icon.setLargeIcon(connectorAnnotation.largeIcon()[i]); 	    				}  	    				connector.getIcons().add(icon); 	    			} 	    		}  	    		if (connector.getLicense() == null) { 	    			License license = new License(); 					connector.setLicense(license); 					license.setLicenseRequired(connectorAnnotation.licenseRequired()); 	    		}  	    		connector.getLicense().setDescriptions(getTexts(connector.getLicense().getDescriptions(), connectorAnnotation.licenseDescription()));   	    		SecurityPermission[] annotationSecurityPermissions = connectorAnnotation.securityPermissions(); 				List securityPermission = connector.getResourceAdapter().getSecurityPermission(); 				if (securityPermission == null || securityPermission.size() == 0) { 					for (SecurityPermission sp : annotationSecurityPermissions) { 						org.apache.openejb.jee.SecurityPermission permission = new org.apache.openejb.jee.SecurityPermission(); 						permission.setSecurityPermissionSpec(sp.permissionSpec()); 						permission.setDescriptions(stringsToTexts(sp.description())); 						securityPermission.add(permission); 					} 				}  				Class[] annotationRequiredWorkContexts = connectorAnnotation.requiredWorkContexts(); 				List requiredWorkContext = connector.getRequiredWorkContext(); 				if (requiredWorkContext.size() == 0) { 					for (Class cls : annotationRequiredWorkContexts) { 						requiredWorkContext.add(cls.getName()); 					} 				}  				OutboundResourceAdapter outboundResourceAdapter = connector.getResourceAdapter().getOutboundResourceAdapter(); 				if (outboundResourceAdapter == null) { 					outboundResourceAdapter = new OutboundResourceAdapter(); 					connector.getResourceAdapter().setOutboundResourceAdapter(outboundResourceAdapter); 				}  				List authenticationMechanisms = outboundResourceAdapter.getAuthenticationMechanism(); 				javax.resource.spi.AuthenticationMechanism[] authMechanisms = connectorAnnotation.authMechanisms(); 				if (authenticationMechanisms.size() == 0) { 					for (javax.resource.spi.AuthenticationMechanism am : authMechanisms) { 						AuthenticationMechanism authMechanism = new AuthenticationMechanism(); 						authMechanism.setAuthenticationMechanismType(am.authMechanism()); 						authMechanism.setCredentialInterface(am.credentialInterface().toString()); 						authMechanism.setDescriptions(stringsToTexts(am.description()));  						authenticationMechanisms.add(authMechanism); 					} 				}  				if (outboundResourceAdapter.getTransactionSupport() == null) { 					outboundResourceAdapter.setTransactionSupport(TransactionSupportType.fromValue(connectorAnnotation.transactionSupport().toString())); 				}  				if (outboundResourceAdapter.isReauthenticationSupport() == null) { 					outboundResourceAdapter.setReauthenticationSupport(connectorAnnotation.reauthenticationSupport()); 				}         	} else {         		// we couldn't process a connector class - probably a validation issue which we should warn about.         	}          	// process @ConnectionDescription(s)         	List&gt; classes = finder.findAnnotatedClasses(ConnectionDefinitions.class);         	for (Class cls : classes) { 				ConnectionDefinitions connectionDefinitionsAnnotation = cls.getAnnotation(ConnectionDefinitions.class); 				ConnectionDefinition[] definitions = connectionDefinitionsAnnotation.value();  				for (ConnectionDefinition definition : definitions) { 					processConnectionDescription(connector.getResourceAdapter(), definition, cls); 				} 			}          	classes = finder.findAnnotatedClasses(ConnectionDefinition.class);         	for (Class cls : classes) { 				ConnectionDefinition connectionDefinitionAnnotation = cls.getAnnotation(ConnectionDefinition.class); 				processConnectionDescription(connector.getResourceAdapter(), connectionDefinitionAnnotation, cls); 			}           	InboundResourceadapter inboundResourceAdapter = connector.getResourceAdapter().getInboundResourceAdapter();         	if (inboundResourceAdapter == null) {         		inboundResourceAdapter = new InboundResourceadapter();         		connector.getResourceAdapter().setInboundResourceAdapter(inboundResourceAdapter);         	}          	MessageAdapter messageAdapter = inboundResourceAdapter.getMessageAdapter();         	if (messageAdapter == null) {         		messageAdapter = new MessageAdapter();         		inboundResourceAdapter.setMessageAdapter(messageAdapter);         	}          	classes = finder.findAnnotatedClasses(Activation.class);         	for (Class cls : classes) {         		MessageListener messageListener = null;         		Activation activationAnnotation = cls.getAnnotation(Activation.class);          		List messageListeners = messageAdapter.getMessageListener(); 				for (MessageListener ml : messageListeners) { 					if (cls.getName().equals(ml.getActivationSpec().getActivationSpecClass())) { 						messageListener = ml; 						break; 					} 				}  				if (messageListener == null) { 					Class[] listeners = activationAnnotation.messageListeners(); 					for (Class listener : listeners) { 						messageAdapter.addMessageListener(new MessageListener(listener.getName(), cls.getName())); 					} 				} 			}          	classes = finder.findAnnotatedClasses(AdministeredObject.class);         	List adminObjects = connector.getResourceAdapter().getAdminObject();         	for (Class cls : classes) { 				AdministeredObject administeredObjectAnnotation = cls.getAnnotation(AdministeredObject.class); 				Class[] adminObjectInterfaces = administeredObjectAnnotation.adminObjectInterfaces();  				AdminObject adminObject = null; 				for (AdminObject admObj : adminObjects) { 					if (admObj.getAdminObjectClass().equals(cls.getName())) { 						adminObject = admObj; 					} 				}  				if (adminObject == null) { 					for (Class iface : adminObjectInterfaces) { 						AdminObject newAdminObject = new AdminObject(); 						newAdminObject.setAdminObjectClass(cls.getName()); 						newAdminObject.setAdminObjectInterface(iface.getName()); 						adminObjects.add(newAdminObject); 					} 				} 			}          	// need to make a list of classes to process for config properties          	// resource adapter         	String raCls = connector.getResourceAdapter().getResourceAdapterClass();         	process(connectorModule.getClassLoader(), raCls, connector.getResourceAdapter());          	// managedconnectionfactory         	if (connector.getResourceAdapter() != null &amp;&amp; connector.getResourceAdapter().getOutboundResourceAdapter() != null) { 	        	List connectionDefinitions = connector.getResourceAdapter().getOutboundResourceAdapter().getConnectionDefinition(); 	        	for (org.apache.openejb.jee.ConnectionDefinition connectionDefinition : connectionDefinitions) { 	        		process(connectorModule.getClassLoader(), connectionDefinition.getManagedConnectionFactoryClass(), connectionDefinition); 				}         	}          	// administeredobject         	if (connector.getResourceAdapter() != null) { 	        	List raAdminObjects = connector.getResourceAdapter().getAdminObject(); 	        	for (AdminObject raAdminObject : raAdminObjects) { 					process(connectorModule.getClassLoader(), raAdminObject.getAdminObjectClass(), raAdminObject); 				}         	}          	// activationspec         	if (connector.getResourceAdapter() != null &amp;&amp; connector.getResourceAdapter().getInboundResourceAdapter() != null &amp;&amp; connector.getResourceAdapter().getInboundResourceAdapter().getMessageAdapter() != null) { 	        	List messageListeners = connector.getResourceAdapter().getInboundResourceAdapter().getMessageAdapter().getMessageListener(); 	        	for (MessageListener messageListener : messageListeners) { 					ActivationSpec activationSpec = messageListener.getActivationSpec(); 					process(connectorModule.getClassLoader(), activationSpec.getActivationSpecClass(), activationSpec); 				}         	}              return connectorModule;         }  		void process(ClassLoader cl, String cls, Object object) {  			List configProperties = null; 			try { 			// grab a list of ConfigProperty objects 				configProperties = (List) object.getClass().getDeclaredMethod(&quot;getConfigProperty&quot;).invoke(object); 			} catch (Exception e) { 			}  			if (configProperties == null) { 				// can't get config properties 				return; 			}  			ClassLoader classLoader = cl; 			if (classLoader == null) { 				classLoader = Thread.currentThread().getContextClassLoader(); 			}  			final List allowedTypes = Arrays.asList(new String[] { Boolean.class.getName(), String.class.getName(), Integer.class.getName(), Double.class.getName(), Byte.class.getName(), Short.class.getName(), Long.class.getName(), Float.class.getName(), Character.class.getName()});  			try { 				Class clazz = classLoader.loadClass(realClassName(cls)); 				Object o = clazz.newInstance();  				// add any introspected properties 				BeanInfo beanInfo = Introspector.getBeanInfo(clazz); 				PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();  				for (PropertyDescriptor propertyDescriptor : propertyDescriptors) { 					String name = propertyDescriptor.getName(); 					Class type = propertyDescriptor.getPropertyType();                     if (type == null) {                         continue;                     } 					if (type.isPrimitive()) { 						type = getWrapper(type.getName()); 					}  					if (! allowedTypes.contains(type.getName())) { 						continue; 					}  					if (! containsConfigProperty(configProperties, name)) { 						if (type != null) { 							ConfigProperty configProperty = new ConfigProperty(); 							configProperties.add(configProperty);  							Object value = null; 							try { 								value = propertyDescriptor.getReadMethod().invoke(o); 							} catch (Exception e) { 							}  							javax.resource.spi.ConfigProperty annotation = propertyDescriptor.getWriteMethod().getAnnotation(javax.resource.spi.ConfigProperty.class);                             if (annotation == null) {                                 try {                                     // if there's no annotation on the setter, we'll try and scrape one off the field itself (assuming the same name)                                     annotation = clazz.getDeclaredField(name).getAnnotation(javax.resource.spi.ConfigProperty.class);                                 } catch (Exception ignored) {                                     // no-op : getDeclaredField() throws exceptions and does not return null                                 }                             }  							configProperty.setConfigPropertyName(name); 							configProperty.setConfigPropertyType(getConfigPropertyType(annotation, type)); 							if (value != null) { 								configProperty.setConfigPropertyValue(value.toString()); 							}  							if (annotation != null) { 								if (annotation.defaultValue() != null &amp;&amp; annotation.defaultValue().length() &gt; 0) { 									configProperty.setConfigPropertyValue(annotation.defaultValue()); 								} 								configProperty.setConfigPropertyConfidential(annotation.confidential()); 								configProperty.setConfigPropertyIgnore(annotation.ignore()); 								configProperty.setConfigPropertySupportsDynamicUpdates(annotation.supportsDynamicUpdates()); 								configProperty.setDescriptions(stringsToTexts(annotation.description())); 							} 						} 					} 				}  				// add any annotated fields we haven't already picked up 				Field[] declaredFields = clazz.getDeclaredFields(); 				for (Field field : declaredFields) { 					javax.resource.spi.ConfigProperty annotation = field.getAnnotation(javax.resource.spi.ConfigProperty.class);  					String name = field.getName(); 					Object value = null; 					try { 						value = field.get(o); 					} catch (Exception e) { 					}  					if (! containsConfigProperty(configProperties, name)) { 						String type = getConfigPropertyType(annotation, field.getType());  						if (type != null) { 							ConfigProperty configProperty = new ConfigProperty(); 							configProperties.add(configProperty);  							configProperty.setConfigPropertyName(name); 							configProperty.setConfigPropertyType(type); 							if (value != null) { 								configProperty.setConfigPropertyValue(value.toString()); 							}  							if (annotation != null) { 								if (annotation.defaultValue() != null) { 									configProperty.setConfigPropertyValue(annotation.defaultValue()); 								} 								configProperty.setConfigPropertyConfidential(annotation.confidential()); 								configProperty.setConfigPropertyIgnore(annotation.ignore()); 								configProperty.setConfigPropertySupportsDynamicUpdates(annotation.supportsDynamicUpdates()); 							} 						} 					} 				} 			} catch (Exception  e) { 				e.printStackTrace(); 			} 		}  		private String getConfigPropertyType(javax.resource.spi.ConfigProperty annotation, Class type) { 			Class t = (annotation == null) ? null : annotation.type();             if (t == null &amp;&amp; type != null) {                 return type.getName();             } else if (t == null) {                 return null;             }  			if (t.equals(Object.class)) { 				t = type; 			}             if (t == null) { // t == null &amp;&amp; type == null                 return null;             }  			if (t.isPrimitive()) { 				t = getWrapper(t.getName()); 			}  			return t.getName(); 		}  		private boolean containsConfigProperty(List configProperties, String name) { 			for (ConfigProperty configProperty : configProperties) { 				if (configProperty.getConfigPropertyName().equals(name)) { 					return true; 				} 			}  			return false; 		}  		private Class getWrapper(String primitiveType) { 			final Map&gt; builtInMap = new HashMap&gt;();{ 			       builtInMap.put(&quot;int&quot;, Integer.class); 			       builtInMap.put(&quot;long&quot;, Long.class); 			       builtInMap.put(&quot;double&quot;, Double.class); 			       builtInMap.put(&quot;float&quot;, Float.class); 			       builtInMap.put(&quot;boolean&quot;, Boolean.class); 			       builtInMap.put(&quot;char&quot;, Character.class); 			       builtInMap.put(&quot;byte&quot;, Byte.class); 			       builtInMap.put(&quot;void&quot;, Void.class); 			       builtInMap.put(&quot;short&quot;, Short.class); 			}  			return builtInMap.get(primitiveType); 		}  		private void processConnectionDescription(ResourceAdapter resourceAdapter, ConnectionDefinition connectionDefinitionAnnotation, Class cls) { 			// try and find the managed connection factory  			OutboundResourceAdapter outboundResourceAdapter = resourceAdapter.getOutboundResourceAdapter(); 			if (outboundResourceAdapter == null) { 				outboundResourceAdapter = new OutboundResourceAdapter(); 				resourceAdapter.setOutboundResourceAdapter(outboundResourceAdapter); 			}  			List connectionDefinition = outboundResourceAdapter.getConnectionDefinition();  			org.apache.openejb.jee.ConnectionDefinition definition = null; 			for (org.apache.openejb.jee.ConnectionDefinition cd : connectionDefinition) { 				if (cd.getManagedConnectionFactoryClass().equals(cls.getName())) { 					definition = cd; 					break; 				} 			}  			if (definition == null) { 				definition = new org.apache.openejb.jee.ConnectionDefinition(); 				outboundResourceAdapter.getConnectionDefinition().add(definition); 			}  			if (definition.getManagedConnectionFactoryClass() == null) { 				definition.setManagedConnectionFactoryClass(cls.getName()); 			}  			if (definition.getConnectionInterface() == null) { 				definition.setConnectionInterface(connectionDefinitionAnnotation.connection().getName()); 			}  			if (definition.getConnectionImplClass() == null) { 				definition.setConnectionImplClass(connectionDefinitionAnnotation.connectionImpl().getName()); 			}  			if (definition.getConnectionFactoryInterface() == null) { 				definition.setConnectionFactoryInterface(connectionDefinitionAnnotation.connectionFactory().getName()); 			}  			if (definition.getConnectionFactoryImplClass() == null) { 				definition.setConnectionFactoryImplClass(connectionDefinitionAnnotation.connectionFactoryImpl().getName()); 			} 		}  		private Text[] stringsToTexts(String[] strings) { 			if (strings == null) { 				return null; 			}  			Text[] result = new Text[strings.length]; 			for (int i = 0; i &lt; result.length; i++) { 				result[i] = new Text(); 				result[i].setValue(strings[i]); 			}  			return result; 		}  		private String getString(String descriptorString, String annotationString) { 			if (descriptorString != null &amp;&amp; descriptorString.length() &gt; 0) { 				return descriptorString; 			}  			if (annotationString != null &amp;&amp; annotationString.length() &gt; 0) { 				return annotationString; 			}  			return null; 		}  		private Text[] getTexts(Text[] originalTexts, String[] newStrings) { 			if (newStrings != null &amp;&amp; newStrings.length &gt; 0 &amp;&amp; (originalTexts == null || originalTexts.length == 0)) { 				Text[] texts = new Text[newStrings.length]; 				for (int i = 0; i &lt; newStrings.length; i++) { 					texts[i] = new Text(null, newStrings[i]); 				}  				return texts; 			} else { 				return originalTexts; 			} 		}          public WebModule deploy(WebModule webModule) throws OpenEJBException {             WebApp webApp = webModule.getWebApp();             if (webApp != null &amp;&amp; (webApp.isMetadataComplete())) return webModule;              try {                 if (webModule.getFinder() == null) {                     webModule.setFinder(FinderFactory.createFinder(webModule));                 }             } catch (Exception e) {                 startupLogger.warning(&quot;Unable to scrape for @WebService or @WebServiceProvider annotations. AnnotationFinder failed.&quot;, e);                 return webModule;             }              if (webApp == null) {                 webApp = new WebApp();                 webModule.setWebApp(webApp);             }              List existingServlets = new ArrayList();             for (Servlet servlet : webApp.getServlet()) {                 if (servlet.getServletClass() != null) {                     existingServlets.add(servlet.getServletClass());                 }             }              IAnnotationFinder finder = webModule.getFinder();             List classes = new ArrayList();             classes.addAll(finder.findAnnotatedClasses(WebService.class));             classes.addAll(finder.findAnnotatedClasses(WebServiceProvider.class));              for (Class webServiceClass : classes) {                 // If this class is also annotated @Stateless or @Singleton, we should skip it                 if (webServiceClass.isAnnotationPresent(Singleton.class) || webServiceClass.isAnnotationPresent(Stateless.class)) {                     webModule.getEjbWebServices().add(webServiceClass.getName());                     continue;                 }                  int modifiers = webServiceClass.getModifiers();                 if (!Modifier.isPublic(modifiers) || Modifier.isFinal(modifiers) || isAbstract(modifiers)) {                     continue;                 }                  if (existingServlets.contains(webServiceClass.getName())) continue;                  // create webApp and webservices objects if they don't exist already                  // add new  element                 Servlet servlet = new Servlet();                 servlet.setServletName(webServiceClass.getName());                 servlet.setServletClass(webServiceClass.getName());                 webApp.getServlet().add(servlet);             }             /*             * REST             */             // get by annotations             webModule.getRestClasses().addAll(findRestClasses(webModule, finder));             addJaxRsProviders(finder, webModule.getJaxrsProviders(), Provider.class);              // Applications with a default constructor             // findSubclasses will not work by default to gain a lot of time             // look FinderFactory for the flag to activate it or             // use @ApplicationPath(&quot;/&quot;)             List&gt; applications = finder.findSubclasses(Application.class);             for (Class app : applications) {                 addRestApplicationIfPossible(webModule, app);             }              // look for ApplicationPath, it will often return the same than the previous one             // but without finder.link() invocation it still works             // so it can save a lot of startup time             List&gt;&gt; applicationsByAnnotation = finder.findMetaAnnotatedClasses(ApplicationPath.class);             for (Annotated&gt; annotatedApp : applicationsByAnnotation) {                 final Class app = annotatedApp.get();                 if (!Application.class.isAssignableFrom(app)) {                     logger.error(&quot;class '&quot; + app.getName() + &quot;' is annotated with @ApplicationPath but doesn't implement &quot; + Application.class.getName());                     continue;                 }                  addRestApplicationIfPossible(webModule, (Class) app);             }              /*              * JSF              */             final ClassLoader classLoader = webModule.getClassLoader();             for (String jsfClass : JSF_CLASSES) {                 final Class clazz;                 try {                     clazz = (Class) classLoader.loadClass(jsfClass);                 } catch (ClassNotFoundException e) {                     continue;                 }                  final List&gt;&gt; found = finder.findMetaAnnotatedClasses(clazz);                 final Set convertedClasses = new HashSet(found.size());                 for (Annotated&gt; annotated : found) {                     convertedClasses.add(annotated.get().getName());                 }                 webModule.getJsfAnnotatedClasses().put(jsfClass, convertedClasses);             }              /*              * Servlet, Filter, Listener              */              Map urlByClasses = null;             for (String apiClassName : WEB_CLASSES) {                 final Class clazz;                 try {                     clazz = (Class) classLoader.loadClass(apiClassName);                 } catch (ClassNotFoundException e) {                     continue;                 }                  if (urlByClasses == null) { // try to reuse scanning info, maybe some better indexing can be a nice idea                     if (finder instanceof FinderFactory.ModuleLimitedFinder) {                         final IAnnotationFinder limitedFinder = ((FinderFactory.ModuleLimitedFinder) finder).getDelegate();                         if (limitedFinder instanceof AnnotationFinder) {                             final Archive archive = ((AnnotationFinder) limitedFinder).getArchive();                             if (archive instanceof WebappAggregatedArchive) {                                 final Map&gt; index = ((WebappAggregatedArchive) archive).getClassesMap();                                 urlByClasses = new HashMap();                                 for (Map.Entry&gt; entry : index.entrySet()) {                                     final String url = entry.getKey().toExternalForm();                                     for (String current : entry.getValue()) {                                         urlByClasses.put(current,  url);                                     }                                 }                             }                         }                     }                 }                  final List&gt;&gt; found = finder.findMetaAnnotatedClasses(clazz);                 addWebAnnotatedClassInfo(urlByClasses, webModule.getWebAnnotatedClasses(), found);             }              if (urlByClasses != null) {                 urlByClasses.clear();             }              return webModule;         }          private void addJaxRsProviders(final IAnnotationFinder finder, final Collection set, final Class annotation) {             for (Annotated&gt; provider : finder.findMetaAnnotatedClasses(annotation)) {                 set.add(provider.get().getName());             }         }          private static void addRestApplicationIfPossible(final WebModule webModule, final Class app) {             if (app.getConstructors().length == 0) {                 webModule.getRestApplications().add(app.getName());             } else {                 for (Constructor ctr : app.getConstructors()) {                     if (ctr.getParameterTypes().length == 0) {                         webModule.getRestApplications().add(app.getName());                         break;                     }                 }             }         }          public EjbModule deploy(EjbModule ejbModule) throws OpenEJBException {             if (ejbModule.getEjbJar() != null &amp;&amp; ejbModule.getEjbJar().isMetadataComplete()) return ejbModule;               try {                 if (ejbModule.getFinder() == null) {                     ejbModule.setFinder(FinderFactory.createFinder(ejbModule));                 }             } catch (MalformedURLException e) {                 startupLogger.warning(&quot;startup.scrapeFailedForModule&quot;, ejbModule.getJarLocation());                 return ejbModule;             } catch (Exception e) {                 startupLogger.warning(&quot;Unable to scrape for @Stateful, @Stateless, @Singleton or @MessageDriven annotations. AnnotationFinder failed.&quot;, e);                 return ejbModule;             }              IAnnotationFinder finder = ejbModule.getFinder();               final List managedClasses;             {                 final Beans beans = ejbModule.getBeans();                  if (beans != null) {                     managedClasses = beans.getManagedClasses();                     final List classNames = getBeanClasses(finder);                     for (String rawClassName : classNames) {                         final String className = realClassName(rawClassName);                         try {                             final ClassLoader loader = ejbModule.getClassLoader();                             final Class clazz = loader.loadClass(className);                              // The following can NOT be beans in CDI                              // 1. Non-static inner classes                             if (clazz.getEnclosingClass() != null &amp;&amp; !Modifier.isStatic(clazz.getModifiers())) continue; // //                            // 2. Abstract classes (unless they are an @Decorator) //                            if (Modifier.isAbstract(clazz.getModifiers()) &amp;&amp; !clazz.isAnnotationPresent(javax.decorator.Decorator.class)) continue; //                             // 3. Implementations of Extension                             if (Extension.class.isAssignableFrom(clazz)) continue;                              managedClasses.add(className);                         } catch (ClassNotFoundException e) {                             // todo log debug warning                         } catch (java.lang.NoClassDefFoundError e) {                             // no-op                         }                     }                      // passing jar location to be able to manage maven classes/test-classes which have the same moduleId                     String id = ejbModule.getModuleId();                     if (ejbModule.getJarLocation() != null &amp;&amp; ejbModule.getJarLocation().contains(ejbModule.getModuleId() + &quot;/target/test-classes&quot;.replace(&quot;/&quot;, File.separator))) {                         // with maven if both src/main/java and src/test/java are deployed                         // moduleId.Comp exists twice so it fails                         // here we simply modify the test comp bean name to avoid it                         id += &quot;_test&quot;;                     }                     final String name = BeanContext.Comp.openejbCompName(id);                     final org.apache.openejb.jee.ManagedBean managedBean = new CompManagedBean(name, BeanContext.Comp.class);                     managedBean.setTransactionType(TransactionType.BEAN);                     ejbModule.getEjbJar().addEnterpriseBean(managedBean);                 } else {                     managedClasses = new ArrayList();                 }             }              final Set&gt; specializingClasses = new HashSet&gt;();               // Fill in default sessionType for xml declared EJBs             for (EnterpriseBean bean : ejbModule.getEjbJar().getEnterpriseBeans()) {                 if (!(bean instanceof SessionBean)) continue;                  SessionBean sessionBean = (SessionBean) bean;                  if (sessionBean.getSessionType() != null) continue;                  try {                     final Class clazz = ejbModule.getClassLoader().loadClass(bean.getEjbClass());                     sessionBean.setSessionType(getSessionType(clazz));                 } catch (Throwable handledInValidation) {                     // no-op                 }             }              // Fill in default ejbName for xml declared EJBs             for (EnterpriseBean bean : ejbModule.getEjbJar().getEnterpriseBeans()) {                 if (bean.getEjbClass() == null) continue;                 if (bean.getEjbName() == null || bean.getEjbName().startsWith(&quot;@NULL@&quot;)) {                     ejbModule.getEjbJar().removeEnterpriseBean(bean.getEjbName());                     try {                         final Class clazz = ejbModule.getClassLoader().loadClass(bean.getEjbClass());                         final String ejbName = getEjbName(bean, clazz);                         bean.setEjbName(ejbName);                     } catch (Throwable handledInValidation) {                     }                     ejbModule.getEjbJar().addEnterpriseBean(bean);                 }             }             /* 19.2:  ejb-name: Default is the unqualified name of the bean class */              EjbJar ejbJar = ejbModule.getEjbJar();             for (Annotated&gt; beanClass : finder.findMetaAnnotatedClasses(Singleton.class)) {                  if (beanClass.isAnnotationPresent(Specializes.class)) {                     managedClasses.remove(beanClass.get().getName());                     specializingClasses.add(beanClass.get());                     continue;                 }                  Singleton singleton = beanClass.getAnnotation(Singleton.class);                 String ejbName = getEjbName(singleton, beanClass.get());                  if (!isValidEjbAnnotationUsage(Singleton.class, beanClass, ejbName, ejbModule)) continue;                  EnterpriseBean enterpriseBean = ejbJar.getEnterpriseBean(ejbName);                 if (enterpriseBean == null) {                     enterpriseBean = new SingletonBean(ejbName, beanClass.get());                     ejbJar.addEnterpriseBean(enterpriseBean);                 }                 if (enterpriseBean.getEjbClass() == null) {                     enterpriseBean.setEjbClass(beanClass.get());                 }                 if (enterpriseBean instanceof SessionBean) {                     SessionBean sessionBean = (SessionBean) enterpriseBean;                     sessionBean.setSessionType(SessionType.SINGLETON);                      if (singleton.mappedName() != null) {                         sessionBean.setMappedName(singleton.mappedName());                     }                 }                 LegacyProcessor.process(beanClass.get(), enterpriseBean);             }              for (Annotated&gt; beanClass : finder.findMetaAnnotatedClasses(Stateless.class)) {                  if (beanClass.isAnnotationPresent(Specializes.class)) {                     managedClasses.remove(beanClass.get().getName());                     specializingClasses.add(beanClass.get());                     continue;                 }                  Stateless stateless = beanClass.getAnnotation(Stateless.class);                 String ejbName = getEjbName(stateless, beanClass.get());                  if (!isValidEjbAnnotationUsage(Stateless.class, beanClass, ejbName, ejbModule)) continue;                  EnterpriseBean enterpriseBean = ejbJar.getEnterpriseBean(ejbName);                 if (enterpriseBean == null) {                     enterpriseBean = new StatelessBean(ejbName, beanClass.get());                     ejbJar.addEnterpriseBean(enterpriseBean);                 }                 if (enterpriseBean.getEjbClass() == null) {                     enterpriseBean.setEjbClass(beanClass.get());                 }                 if (enterpriseBean instanceof SessionBean) {                     SessionBean sessionBean = (SessionBean) enterpriseBean;                     sessionBean.setSessionType(SessionType.STATELESS);                      if (stateless.mappedName() != null) {                         sessionBean.setMappedName(stateless.mappedName());                     }                 }                 LegacyProcessor.process(beanClass.get(), enterpriseBean);             }              // The Specialization code is good, but it possibly needs to be moved to after the full processing of the bean             // the plus is that it would get the required interfaces.  The minus is that it would get all the other items              // Possibly study alternatives.  Alternatives might have different meta data completely while it seems Specializing beans inherit all meta-data              // Anyway.. the qualifiers aren't getting inherited, so we need to fix that              for (Annotated&gt; beanClass : finder.findMetaAnnotatedClasses(Stateful.class)) {                  if (beanClass.isAnnotationPresent(Specializes.class)) {                     managedClasses.remove(beanClass.get().getName());                     specializingClasses.add(beanClass.get());                     continue;                 }                  Stateful stateful = beanClass.getAnnotation(Stateful.class);                 String ejbName = getEjbName(stateful, beanClass.get());                  if (!isValidEjbAnnotationUsage(Stateful.class, beanClass, ejbName, ejbModule)) continue;                  EnterpriseBean enterpriseBean = ejbJar.getEnterpriseBean(ejbName);                 if (enterpriseBean == null) {                     enterpriseBean = new StatefulBean(ejbName, beanClass.get());                     ejbJar.addEnterpriseBean(enterpriseBean);                 }                 if (enterpriseBean.getEjbClass() == null) {                     enterpriseBean.setEjbClass(beanClass.get());                 }                 if (enterpriseBean instanceof SessionBean) {                     SessionBean sessionBean = (SessionBean) enterpriseBean;                     // TODO: We might be stepping on an xml override here                     sessionBean.setSessionType(SessionType.STATEFUL);                     if (stateful.mappedName() != null) {                         sessionBean.setMappedName(stateful.mappedName());                     }                 }                 LegacyProcessor.process(beanClass.get(), enterpriseBean);             }              for (Annotated&gt; beanClass : finder.findMetaAnnotatedClasses(ManagedBean.class)) {                  if (beanClass.isAnnotationPresent(Specializes.class)) {                     managedClasses.remove(beanClass.get().getName());                     specializingClasses.add(beanClass.get());                     continue;                 }                  ManagedBean managed = beanClass.getAnnotation(ManagedBean.class);                 String ejbName = getEjbName(managed, beanClass.get());                  // TODO: this is actually against the spec, but the requirement is rather silly                 // (allowing @Stateful and @ManagedBean on the same class)                 // If the TCK doesn't complain we should discourage it                 if (!isValidEjbAnnotationUsage(ManagedBean.class, beanClass, ejbName, ejbModule)) continue;                  EnterpriseBean enterpriseBean = ejbJar.getEnterpriseBean(ejbName);                 if (enterpriseBean == null) {                     enterpriseBean = new org.apache.openejb.jee.ManagedBean(ejbName, beanClass.get());                     ejbJar.addEnterpriseBean(enterpriseBean);                 }                 if (enterpriseBean.getEjbClass() == null) {                     enterpriseBean.setEjbClass(beanClass.get());                 }                 if (enterpriseBean instanceof SessionBean) {                     SessionBean sessionBean = (SessionBean) enterpriseBean;                     sessionBean.setSessionType(SessionType.MANAGED);                      final TransactionType transactionType = sessionBean.getTransactionType();                     if (transactionType == null) sessionBean.setTransactionType(TransactionType.BEAN);                 }             }              for (Annotated&gt; beanClass : finder.findMetaAnnotatedClasses(MessageDriven.class)) {                  if (beanClass.isAnnotationPresent(Specializes.class)) {                     managedClasses.remove(beanClass.get().getName());                     specializingClasses.add(beanClass.get());                     continue;                 }                  MessageDriven mdb = beanClass.getAnnotation(MessageDriven.class);                 String ejbName = getEjbName(mdb, beanClass.get());                  if (!isValidEjbAnnotationUsage(MessageDriven.class, beanClass, ejbName, ejbModule)) continue;                  MessageDrivenBean messageBean = (MessageDrivenBean) ejbJar.getEnterpriseBean(ejbName);                 if (messageBean == null) {                     messageBean = new MessageDrivenBean(ejbName);                     ejbJar.addEnterpriseBean(messageBean);                 }                 if (messageBean.getEjbClass() == null) {                     messageBean.setEjbClass(beanClass.get());                 }                 LegacyProcessor.process(beanClass.get(), messageBean);             }               for (Class specializingClass : sortClassesParentFirst(new ArrayList&gt;(specializingClasses))) {                  final Class parent = specializingClass.getSuperclass();                  if (parent == null || parent.equals(Object.class)) {                     ejbModule.getValidation().fail(specializingClass.getSimpleName(), &quot;specializes.extendsNothing&quot;, specializingClass.getName());                 }                  boolean found = false;                  for (EnterpriseBean enterpriseBean : ejbJar.getEnterpriseBeans()) {                      final String ejbClass = enterpriseBean.getEjbClass();                      if (ejbClass != null &amp;&amp; ejbClass.equals(parent.getName())) {                         managedClasses.remove(ejbClass);                         enterpriseBean.setEjbClass(specializingClass.getName());                         found = true;                     }                 }                  if (!found) {                     ejbModule.getValidation().fail(specializingClass.getSimpleName(), &quot;specializes.extendsSimpleBean&quot;, specializingClass.getName());                 }             }              AssemblyDescriptor assemblyDescriptor = ejbModule.getEjbJar().getAssemblyDescriptor();             if (assemblyDescriptor == null) {                 assemblyDescriptor = new AssemblyDescriptor();                 ejbModule.getEjbJar().setAssemblyDescriptor(assemblyDescriptor);             }              startupLogger.debug(&quot;Searching for annotated application exceptions (see OPENEJB-980)&quot;);             List&gt; appExceptions = finder.findAnnotatedClasses(ApplicationException.class);             for (Class exceptionClass : appExceptions) {                 startupLogger.debug(&quot;...handling &quot; + exceptionClass);                 ApplicationException annotation = exceptionClass.getAnnotation(ApplicationException.class);                 if (assemblyDescriptor.getApplicationException(exceptionClass) == null) {                     startupLogger.debug(&quot;...adding &quot; + exceptionClass + &quot; with rollback=&quot; + annotation.rollback());                     assemblyDescriptor.addApplicationException(exceptionClass, annotation.rollback(), annotation.inherited());                 } else {                     mergeApplicationExceptionAnnotation(assemblyDescriptor, exceptionClass, annotation);                 }             }              // ejb can be rest bean and only then in standalone so scan providers here too             // adding them to app since they should be in the app classloader             if (ejbModule.getAppModule() != null) {                 addJaxRsProviders(finder, ejbModule.getAppModule().getJaxRsProviders(), Provider.class);             }              if (ejbModule.getAppModule() != null) {                 for (PersistenceModule pm : ejbModule.getAppModule().getPersistenceModules()) {                     for (org.apache.openejb.jee.jpa.unit.PersistenceUnit pu : pm.getPersistence().getPersistenceUnit()) {                         if ((pu.isExcludeUnlistedClasses() == null || !pu.isExcludeUnlistedClasses())                                 &amp;&amp; &quot;true&quot;.equalsIgnoreCase(pu.getProperties().getProperty(OPENEJB_JPA_AUTO_SCAN))) {                             final String packageName = pu.getProperties().getProperty(OPENEJB_JPA_AUTO_SCAN_PACKAGE);                              // no need of meta currently since JPA providers doesn't support it                             final List&gt; classes = new ArrayList&gt;();                             classes.addAll(finder.findAnnotatedClasses(Entity.class));                             classes.addAll(finder.findAnnotatedClasses(Embeddable.class));                             classes.addAll(finder.findAnnotatedClasses(MappedSuperclass.class));                             final List existingClasses = pu.getClazz();                             for (Class clazz : classes) {                                 final String name = clazz.getName();                                 if ((packageName == null || name.startsWith(packageName)) &amp;&amp; !existingClasses.contains(name)) {                                     pu.getClazz().add(name);                                 }                             }                             pu.setScanned(true);                         }                     }                 }             }              return ejbModule;         }          private SessionType getSessionType(Class clazz) {             if (clazz.isAnnotationPresent(Stateful.class)) return SessionType.STATEFUL;             if (clazz.isAnnotationPresent(Stateless.class)) return SessionType.STATELESS;             if (clazz.isAnnotationPresent(Singleton.class)) return SessionType.SINGLETON;             if (clazz.isAnnotationPresent(ManagedBean.class)) return SessionType.MANAGED;             return null;         }          private String getEjbName(EnterpriseBean bean, Class clazz) {              if (bean instanceof SessionBean) {                 SessionBean sessionBean = (SessionBean) bean;                 switch (sessionBean.getSessionType()) {                     case STATEFUL: {                         final Stateful annotation = clazz.getAnnotation(Stateful.class);                         if (annotation != null &amp;&amp; specified(annotation.name())) {                             return annotation.name();                         }                     }                     case STATELESS: {                         final Stateless annotation = clazz.getAnnotation(Stateless.class);                         if (annotation != null &amp;&amp; specified(annotation.name())) {                             return annotation.name();                         }                     }                     case SINGLETON: {                         final Singleton annotation = clazz.getAnnotation(Singleton.class);                         if (annotation != null &amp;&amp; specified(annotation.name())) {                             return annotation.name();                         }                     }                 }             }              if (bean instanceof MessageDrivenBean) {                 final MessageDriven annotation = clazz.getAnnotation(MessageDriven.class);                 if (annotation != null &amp;&amp; specified(annotation.name())) {                     return annotation.name();                 }             }              return clazz.getSimpleName();         }          private static boolean specified(final String name) {             return name != null &amp;&amp; name.length() != 0;         }          private List getBeanClasses(IAnnotationFinder finder) {              //  What we're hoping in this method is to get lucky and find             //  that our 'finder' instances is an AnnotationFinder that is             //  holding an AggregatedArchive so we can get the classes that             //  that pertain to each URL for CDI purposes.             //             //  If not we call finder.getAnnotatedClassNames() which may return             //  more classes than actually apply to CDI.  This can &quot;pollute&quot;             //  the CDI class space and break injection points              if (!(finder instanceof FinderFactory.ModuleLimitedFinder)) return finder.getAnnotatedClassNames();              final IAnnotationFinder delegate = ((FinderFactory.ModuleLimitedFinder) finder).getDelegate();             if (!(delegate instanceof AnnotationFinder)) return finder.getAnnotatedClassNames();              final AnnotationFinder annotationFinder = (AnnotationFinder) delegate;              final Archive archive = annotationFinder.getArchive();             if (!(archive instanceof WebappAggregatedArchive)) return finder.getAnnotatedClassNames();              final List classes = new ArrayList();              final WebappAggregatedArchive aggregatedArchive = (WebappAggregatedArchive) archive;             final Map&gt; map = aggregatedArchive.getClassesMap();              for (Map.Entry&gt; entry : map.entrySet()) {                  if (hasBeansXml(entry.getKey())) classes.addAll(entry.getValue());             }              return classes;         }          public static boolean hasBeansXml(URL url) {             if (url.getPath().endsWith(&quot;WEB-INF/classes/&quot;)) return true;             if (url.getPath().endsWith(&quot;!/META-INF/beans.xml&quot;)) return true;             try {                 final URLClassLoader loader = new URLClassLoader(new URL[]{ url } , new EmptyResourcesClassLoader());                 String[] paths = {                         &quot;META-INF/beans.xml&quot;,                         &quot;WEB-INF/beans.xml&quot;,                         &quot;/WEB-INF/beans.xml&quot;,                         &quot;/META-INF/beans.xml&quot;,                 };                  for (String path : paths) {                     if (loader.findResource(path) != null) return true;                 }             } catch (Exception e) {             }             return false;         }          private String getEjbName(MessageDriven mdb, Class beanClass) {             return (mdb.name().isEmpty() ? beanClass.getSimpleName() : mdb.name());         }          private String getEjbName(Stateful stateful, Class beanClass) {             return (stateful.name().isEmpty() ? beanClass.getSimpleName() : stateful.name());         }          private String getEjbName(Stateless stateless, Class beanClass) {             return (stateless.name().isEmpty() ? beanClass.getSimpleName() : stateless.name());         }          private String getEjbName(Singleton singleton, Class beanClass) {             return (singleton.name().isEmpty() ? beanClass.getSimpleName() : singleton.name());         }          private String getEjbName(ManagedBean managed, Class beanClass) {             return (managed.value().isEmpty() ? beanClass.getSimpleName() : managed.value());         }          private boolean isValidEjbAnnotationUsage(Class annotationClass, Annotated&gt; beanClass, String ejbName, EjbModule ejbModule) {             List&gt; annotations = new ArrayList(asList(Singleton.class, Stateless.class, Stateful.class, MessageDriven.class));             annotations.remove(annotationClass);              boolean b = true;             for (Class secondAnnotation : annotations) {                 Annotation annotation = beanClass.getAnnotation(secondAnnotation);                  if (annotation == null) continue;                  String secondEjbName = null;                 if (annotation instanceof Stateful) {                     secondEjbName = getEjbName((Stateful) annotation, beanClass.get());                 } else if (annotation instanceof Stateless) {                     secondEjbName = getEjbName((Stateless) annotation, beanClass.get());                 } else if (annotation instanceof Singleton) {                     secondEjbName = getEjbName((Singleton) annotation, beanClass.get());                 } else if (annotation instanceof MessageDriven) {                     secondEjbName = getEjbName((MessageDriven) annotation, beanClass.get());                 }                  if (ejbName.equals(secondEjbName)) {                     ejbModule.getValidation().fail(ejbName, &quot;multiplyAnnotatedAsBean&quot;, annotationClass.getSimpleName(), secondAnnotation.getSimpleName(), ejbName, beanClass.get().getName());                 }             }              // not a dynamic proxy implemented bean             if (beanClass.getAnnotation(PersistenceContext.class) == null                     &amp;&amp; beanClass.getAnnotation(Proxy.class) == null                     &amp;&amp; beanClass.get().isInterface()) {                 ejbModule.getValidation().fail(ejbName, &quot;interfaceAnnotatedAsBean&quot;, annotationClass.getSimpleName(), beanClass.get().getName());                 return false;             }              if (!beanClass.get().isInterface() &amp;&amp; isAbstract(beanClass.get().getModifiers())) {                 ejbModule.getValidation().fail(ejbName, &quot;abstractAnnotatedAsBean&quot;, annotationClass.getSimpleName(), beanClass.get().getName());                 return false;             }              return b;         }      }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5024</td>
    <td align="left">https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/container/openejb-core/src/main/java/org/apache/openejb/config/AnnotationDeployer.java/#L411-L1700</td>
    <td align="right">1</td>
    <td align="right">496</td>
    <td align="right">5024</td>
  </tr>
  <tr valign="top">
    <td align="right">570</td>
    <td align="left">&nbsp;	{ 		&quot;output&quot;: &quot;YES I found bad smells&quot;, 		&quot;the bad smells are&quot;: [ 			&quot;Blob&quot;, 			&quot;Data Class&quot;, 			&quot;Long Method&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface VMInstanceDao extends GenericDao, StateDao {     /**      * What are the vms running on this host?      * @param hostId host.      * @return list of VMInstanceVO running on that host.      */     List listByHostId(long hostId);      /**      * List VMs by zone ID      * @param zoneId      * @return list of VMInstanceVO in the specified zone      */     List listByZoneId(long zoneId);      /**      * List VMs by pod ID      * @param podId      * @return list of VMInstanceVO in the specified pod      */     List listByPodId(long podId);      /**      * Lists non-expunged VMs by  templateId      * @param templateId      * @return list of VMInstanceVO deployed from the specified template, that are not expunged      */     public List listNonExpungedByTemplate(long templateId);       /**      * Lists non-expunged VMs by zone ID and templateId      * @param zoneId      * @return list of VMInstanceVO in the specified zone, deployed from the specified template, that are not expunged      */     public List listNonExpungedByZoneAndTemplate(long zoneId, long templateId);      /**      * Find vm instance with names like.      *      * @param name name that fits SQL like.      * @return list of VMInstanceVO      */     List findVMInstancesLike(String name);      List findVMInTransition(Date time, State... states);      List listByHostAndState(long hostId, State... states);      List listByTypes(VirtualMachine.Type... types);      VMInstanceVO findByIdTypes(long id, VirtualMachine.Type... types);      VMInstanceVO findVMByInstanceName(String name);      VMInstanceVO findVMByHostName(String hostName);      void updateProxyId(long id, Long proxyId, Date time);      List listByHostIdTypes(long hostid, VirtualMachine.Type... types);      List listUpByHostIdTypes(long hostid, VirtualMachine.Type... types);      List listByZoneIdAndType(long zoneId, VirtualMachine.Type type);      List listUpByHostId(Long hostId);      List listByLastHostId(Long hostId);      List listByTypeAndState(VirtualMachine.Type type, State state);      List listByAccountId(long accountId);      public List findIdsOfAllocatedVirtualRoutersForAccount(long accountId);      List listByClusterId(long clusterId);  // this does not pull up VMs which are starting      List listLHByClusterId(long clusterId);  // get all the VMs even starting one on this cluster      List listVmsMigratingFromHost(Long hostId);      public Long countActiveByHostId(long hostId);      Pair, Map&gt; listClusterIdsInZoneByVmCount(long zoneId, long accountId);      Pair, Map&gt; listClusterIdsInPodByVmCount(long podId, long accountId);      Pair, Map&gt; listPodIdsInZoneByVmCount(long dataCenterId, long accountId);      List listHostIdsByVmCount(long dcId, Long podId, Long clusterId, long accountId);      Long countRunningByAccount(long accountId);      Long countByZoneAndState(long zoneId, State state);      List listNonRemovedVmsByTypeAndNetwork(long networkId, VirtualMachine.Type... types);      /**      * @param networkId      * @param types      * @return      */     List listDistinctHostNames(long networkId, VirtualMachine.Type... types);      List findByHostInStates(Long hostId, State... states);      List listStartingWithNoHostId();      boolean updatePowerState(long instanceId, long powerHostId, VirtualMachine.PowerState powerState);      void resetVmPowerStateTracking(long instanceId);      void resetHostPowerStateTracking(long hostId);      HashMap countVgpuVMs(Long dcId, Long podId, Long clusterId);      VMInstanceVO findVMByHostNameInZone(String hostName, long zoneId);      boolean isPowerStateUpToDate(long instanceId);      List listNonMigratingVmsByHostEqualsLastHost(long hostId); }</td>
    <td align="left">blob</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;data class,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5736</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/engine/schema/src/main/java/com/cloud/vm/dao/VMInstanceDao.java/#L34-L155</td>
    <td align="right">1</td>
    <td align="right">570</td>
    <td align="right">5736</td>
  </tr>
  <tr valign="top">
    <td align="right">664</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [         &quot;Blob&quot;,         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlTransient public abstract class PendingActionNotificationResponse     extends ImmutableObject implements ResponseData {    /** The inner name type that contains a name and the result boolean. */   @Embed   static class NameOrId extends ImmutableObject {     @XmlValue     String value;      @XmlAttribute(name = &quot;paResult&quot;)     boolean actionResult;   }    @XmlTransient   NameOrId nameOrId;    @XmlElement(name = &quot;paTRID&quot;)   Trid trid;    @XmlElement(name = &quot;paDate&quot;)   DateTime processedDate;    public String getNameAsString() {     return nameOrId.value;   }    @VisibleForTesting   public Trid getTrid() {     return trid;   }    @VisibleForTesting   public boolean getActionResult() {     return nameOrId.actionResult;   }    protected static  T init(       T response, String nameOrId, boolean actionResult, Trid trid, DateTime processedDate) {     response.nameOrId = new NameOrId();     response.nameOrId.value = nameOrId;     response.nameOrId.actionResult = actionResult;     response.trid = trid;     response.processedDate = processedDate;     return response;   }    /** An adapter to output the XML in response to resolving a pending command on a domain. */   @Embed   @XmlRootElement(name = &quot;panData&quot;, namespace = &quot;urn:ietf:params:xml:ns:domain-1.0&quot;)   @XmlType(       propOrder = {&quot;name&quot;, &quot;trid&quot;, &quot;processedDate&quot;},       namespace = &quot;urn:ietf:params:xml:ns:domain-1.0&quot;)   public static class DomainPendingActionNotificationResponse       extends PendingActionNotificationResponse {      @XmlElement     NameOrId getName() {       return nameOrId;     }      public static DomainPendingActionNotificationResponse create(         String fullyQualifiedDomainName, boolean actionResult, Trid trid, DateTime processedDate) {       return init(           new DomainPendingActionNotificationResponse(),           fullyQualifiedDomainName,           actionResult,           trid,           processedDate);     }   }    /** An adapter to output the XML in response to resolving a pending command on a contact. */   @Embed   @XmlRootElement(name = &quot;panData&quot;, namespace = &quot;urn:ietf:params:xml:ns:contact-1.0&quot;)   @XmlType(       propOrder = {&quot;id&quot;, &quot;trid&quot;, &quot;processedDate&quot;},       namespace = &quot;urn:ietf:params:xml:ns:contact-1.0&quot;)   public static class ContactPendingActionNotificationResponse       extends PendingActionNotificationResponse {      @XmlElement     NameOrId getId() {       return nameOrId;     }      public static ContactPendingActionNotificationResponse create(         String contactId, boolean actionResult, Trid trid, DateTime processedDate) {       return init(           new ContactPendingActionNotificationResponse(),           contactId,           actionResult,           trid,           processedDate);     }   }    /** An adapter to output the XML in response to resolving a pending command on a host. */   @Embed   @XmlRootElement(name = &quot;panData&quot;, namespace = &quot;urn:ietf:params:xml:ns:domain-1.0&quot;)   @XmlType(     propOrder = {&quot;name&quot;, &quot;trid&quot;, &quot;processedDate&quot;},     namespace = &quot;urn:ietf:params:xml:ns:domain-1.0&quot;   )   public static class HostPendingActionNotificationResponse       extends PendingActionNotificationResponse {      @XmlElement     NameOrId getName() {       return nameOrId;     }      public static HostPendingActionNotificationResponse create(         String fullyQualifiedHostName, boolean actionResult, Trid trid, DateTime processedDate) {       return init(           new HostPendingActionNotificationResponse(),           fullyQualifiedHostName,           actionResult,           trid,           processedDate);     }   } }</td>
    <td align="left">blob</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;data class,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6459</td>
    <td align="left">https://github.com/google/nomulus/blob/2481704d00f10f6b5675dd26f9effaad434ddbea/java/google/registry/model/poll/PendingActionNotificationResponse.java/#L31-L153</td>
    <td align="right">1</td>
    <td align="right">664</td>
    <td align="right">6459</td>
  </tr>
  <tr valign="top">
    <td align="right">705</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class WithName extends INodeReference {      private final byte[] name;      /**      * The id of the last snapshot in the src tree when this WithName node was       * generated. When calculating the quota usage of the referred node, only       * the files/dirs existing when this snapshot was taken will be counted for       * this WithName node and propagated along its ancestor path.      */     private final int lastSnapshotId;          public WithName(INodeDirectory parent, WithCount referred, byte[] name,         int lastSnapshotId) {       super(parent, referred);       this.name = name;       this.lastSnapshotId = lastSnapshotId;       referred.addReference(this);     }      @Override     public final byte[] getLocalNameBytes() {       return name;     }      @Override     public final void setLocalName(byte[] name) {       throw new UnsupportedOperationException(&quot;Cannot set name: &quot; + getClass()           + &quot; is immutable.&quot;);     }          public int getLastSnapshotId() {       return lastSnapshotId;     }          @Override     public final ContentSummaryComputationContext computeContentSummary(         int snapshotId, ContentSummaryComputationContext summary) {       final int s = snapshotId &lt; lastSnapshotId ? snapshotId : lastSnapshotId;       // only count storagespace for WithName       final QuotaCounts q = computeQuotaUsage(           summary.getBlockStoragePolicySuite(), getStoragePolicyID(), false, s);       summary.getCounts().addContent(Content.DISKSPACE, q.getStorageSpace());       summary.getCounts().addTypeSpaces(q.getTypeSpaces());       return summary;     }      @Override     public final QuotaCounts computeQuotaUsage(BlockStoragePolicySuite bsps,         byte blockStoragePolicyId, boolean useCache, int lastSnapshotId) {       // if this.lastSnapshotId &lt; lastSnapshotId, the rename of the referred       // node happened before the rename of its ancestor. This should be       // impossible since for WithName node we only count its children at the       // time of the rename.       Preconditions.checkState(lastSnapshotId == Snapshot.CURRENT_STATE_ID           || this.lastSnapshotId &gt;= lastSnapshotId);       final INode referred = this.getReferredINode().asReference()           .getReferredINode();       // We will continue the quota usage computation using the same snapshot id       // as time line (if the given snapshot id is valid). Also, we cannot use        // cache for the referred node since its cached quota may have already        // been updated by changes in the current tree.       int id = lastSnapshotId != Snapshot.CURRENT_STATE_ID ?            lastSnapshotId : this.lastSnapshotId;       return referred.computeQuotaUsage(bsps, blockStoragePolicyId, false, id);     }          @Override     public void cleanSubtree(ReclaimContext reclaimContext, final int snapshot,         int prior) {       // since WithName node resides in deleted list acting as a snapshot copy,       // the parameter snapshot must be non-null       Preconditions.checkArgument(snapshot != Snapshot.CURRENT_STATE_ID);       // if prior is NO_SNAPSHOT_ID, we need to check snapshot belonging to the       // previous WithName instance       if (prior == Snapshot.NO_SNAPSHOT_ID) {         prior = getPriorSnapshot(this);       }              if (prior != Snapshot.NO_SNAPSHOT_ID           &amp;&amp; Snapshot.ID_INTEGER_COMPARATOR.compare(snapshot, prior) &lt;= 0) {         return;       }        // record the old quota delta       QuotaCounts old = reclaimContext.quotaDelta().getCountsCopy();       getReferredINode().cleanSubtree(reclaimContext, snapshot, prior);       INodeReference ref = getReferredINode().getParentReference();       if (ref != null) {         QuotaCounts current = reclaimContext.quotaDelta().getCountsCopy();         current.subtract(old);         // we need to update the quota usage along the parent path from ref         reclaimContext.quotaDelta().addUpdatePath(ref, current);       }              if (snapshot &lt; lastSnapshotId) {         // for a WithName node, when we compute its quota usage, we only count         // in all the nodes existing at the time of the corresponding rename op.         // Thus if we are deleting a snapshot before/at the snapshot associated          // with lastSnapshotId, we do not need to update the quota upwards.         reclaimContext.quotaDelta().setCounts(old);       }     }          @Override     public void destroyAndCollectBlocks(ReclaimContext reclaimContext) {       int snapshot = getSelfSnapshot();       reclaimContext.quotaDelta().add(computeQuotaUsage(reclaimContext.bsps));       if (removeReference(this) &lt;= 0) {         getReferredINode().destroyAndCollectBlocks(reclaimContext.getCopy());       } else {         int prior = getPriorSnapshot(this);         INode referred = getReferredINode().asReference().getReferredINode();          if (snapshot != Snapshot.NO_SNAPSHOT_ID) {           if (prior != Snapshot.NO_SNAPSHOT_ID &amp;&amp; snapshot &lt;= prior) {             // the snapshot to be deleted has been deleted while traversing              // the src tree of the previous rename operation. This usually              // happens when rename's src and dst are under the same              // snapshottable directory. E.g., the following operation sequence:             // 1. create snapshot s1 on /test             // 2. rename /test/foo/bar to /test/foo2/bar             // 3. create snapshot s2 on /test             // 4. rename foo2 again             // 5. delete snapshot s2             return;           }           ReclaimContext newCtx = reclaimContext.getCopy();           referred.cleanSubtree(newCtx, snapshot, prior);           INodeReference ref = getReferredINode().getParentReference();           if (ref != null) {             // we need to update the quota usage along the parent path from ref             reclaimContext.quotaDelta().addUpdatePath(ref,                 newCtx.quotaDelta().getCountsCopy());           }         }       }     }          private int getSelfSnapshot() {       INode referred = getReferredINode().asReference().getReferredINode();       int snapshot = Snapshot.NO_SNAPSHOT_ID;       if (referred.isFile() &amp;&amp; referred.asFile().isWithSnapshot()) {         snapshot = referred.asFile().getDiffs().getPrior(lastSnapshotId);       } else if (referred.isDirectory()) {         DirectoryWithSnapshotFeature sf = referred.asDirectory()             .getDirectoryWithSnapshotFeature();         if (sf != null) {           snapshot = sf.getDiffs().getPrior(lastSnapshotId);         }       }       return snapshot;     }   }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6714</td>
    <td align="left">https://github.com/apache/hadoop/blob/128dd91e10080bdcbcd7d555fa3c4105e55a6b51/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeReference.java/#L466-L619</td>
    <td align="right">1</td>
    <td align="right">705</td>
    <td align="right">6714</td>
  </tr>
  <tr valign="top">
    <td align="right">727</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells the bad smells are:&quot;,         &quot;bad_smells&quot;: [             &quot;1. Blob&quot;,             &quot;2. Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private static class BucketList implements Iterable&gt; {         private final ArrayList&gt; bucketList;         private final List&gt; immutableVisibleList;          private BucketList(ArrayList&gt; bucketList, ArrayList&gt; publicBucketList) {             this.bucketList = bucketList;              int displayIndex = 0;             for (Bucket bucket : publicBucketList) {                 bucket.displayIndex = displayIndex++;             }             immutableVisibleList = Collections.unmodifiableList(publicBucketList);         }          private int getBucketCount() {             return immutableVisibleList.size();         }          private int getBucketIndex(CharSequence name, Collator collatorPrimaryOnly) {             // binary search             int start = 0;             int limit = bucketList.size();             while ((start + 1) &lt; limit) {                 int i = (start + limit) / 2;                 Bucket bucket = bucketList.get(i);                 int nameVsBucket = collatorPrimaryOnly.compare(name, bucket.lowerBoundary);                 if (nameVsBucket &lt; 0) {                     limit = i;                 } else {                     start = i;                 }             }             Bucket bucket = bucketList.get(start);             if (bucket.displayBucket != null) {                 bucket = bucket.displayBucket;             }             return bucket.displayIndex;         }          /**          * Private iterator over all the buckets, visible and invisible          */         private Iterator&gt; fullIterator() {             return bucketList.iterator();         }          /**          * Iterator over just the visible buckets.          */         @Override         public Iterator&gt; iterator() {             return immutableVisibleList.iterator(); // use immutable list to prevent remove().         }     }</td>
    <td align="left">blob</td>
    <td align="left">1. blob, 2. long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;2. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6852</td>
    <td align="left">https://github.com/google/j2objc/blob/471504a735b48d5d4ace51afa1542cc4790a921a/jre_emul/android/platform/external/icu/android_icu4j/src/main/java/android/icu/text/AlphabeticIndex.java/#L1101-L1154</td>
    <td align="right">1</td>
    <td align="right">727</td>
    <td align="right">6852</td>
  </tr>
  <tr valign="top">
    <td align="right">805</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells&quot;: [&quot;Long Method&quot;, &quot;Data Class&quot;, &quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class VideoProducerImplementation extends HandlerBase implements IVideoProducer {     private VideoProducer videoParams;     private Framebuffer fbo;     private FloatBuffer depthBuffer;      @Override     public boolean parseParameters(Object params)     {         if (params == null || !(params instanceof VideoProducer))             return false;         this.videoParams = (VideoProducer) params;          return true;     }      @Override     public VideoType getVideoType()     {         return VideoType.VIDEO;     }      @Override     public void getFrame(MissionInit missionInit, ByteBuffer buffer)     {         if (!this.videoParams.isWantDepth())         {             getRGBFrame(buffer); // Just return the simple RGB, 3bpp image.             return;         }          // Otherwise, do the work of extracting the depth map:         final int width = this.videoParams.getWidth();         final int height = this.videoParams.getHeight();          GL30.glBindFramebuffer(GL30.GL_READ_FRAMEBUFFER, Minecraft.getMinecraft().getFramebuffer().framebufferObject);         GL30.glBindFramebuffer(GL30.GL_DRAW_FRAMEBUFFER, this.fbo.framebufferObject);         GL30.glBlitFramebuffer(0, 0, Minecraft.getMinecraft().getFramebuffer().framebufferWidth, Minecraft.getMinecraft().getFramebuffer().framebufferHeight, 0, 0, width, height, GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT, GL11.GL_NEAREST);          this.fbo.bindFramebuffer(true);         glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, buffer);         glReadPixels(0, 0, width, height, GL_DEPTH_COMPONENT, GL_FLOAT, this.depthBuffer);         this.fbo.unbindFramebuffer();          // Now convert the depth buffer into values from 0-255 and copy it over         // the alpha channel.         // We either use the min and max values supplied in order to scale it,         // or we scale it according         // to the dynamic content:         float minval, maxval;          // The scaling section is optional (since the depthmap is optional) - so         // if there is no depthScaling object,         // go with the default of autoscale.         if (this.videoParams.getDepthScaling() == null || this.videoParams.getDepthScaling().isAutoscale())         {             minval = 1;             maxval = 0;             for (int i = 0; i &lt; width * height; i++)             {                 float f = this.depthBuffer.get(i);                 if (f &lt; minval)                     minval = f;                 if (f &gt; maxval)                     maxval = f;             }         }         else         {             minval = this.videoParams.getDepthScaling().getMin().floatValue();             maxval = this.videoParams.getDepthScaling().getMax().floatValue();             if (minval &gt; maxval)             {                 // You can't trust users.                 float t = minval;                 minval = maxval;                 maxval = t;             }         }         float range = maxval - minval;         if (range &lt; 0.000001)             range = 0.000001f; // To avoid divide by zero errors in cases where                                // there is no depth variance         float scale = 255 / range;         for (int i = 0; i &lt; width * height; i++)         {             float f = this.depthBuffer.get(i);             f = (f &lt; minval ? minval : (f &gt; maxval ? maxval : f));             f -= minval;             f *= scale;             buffer.put(i * 4 + 3, (byte) f);         }         // Reset depth buffer ready for next read:         this.depthBuffer.clear();     }      @Override     public int getWidth()     {         return this.videoParams.getWidth();     }      @Override     public int getHeight()     {         return this.videoParams.getHeight();     }      public int getRequiredBufferSize()     {         return this.videoParams.getWidth() * this.videoParams.getHeight() * (this.videoParams.isWantDepth() ? 4 : 3);     }      private void getRGBFrame(ByteBuffer buffer)     {         final int format = GL_RGB;         final int width = this.videoParams.getWidth();         final int height = this.videoParams.getHeight();          // Render the Minecraft frame into our own FBO, at the desired size:         this.fbo.bindFramebuffer(true);         Minecraft.getMinecraft().getFramebuffer().framebufferRenderExt(width, height, true);         // Now read the pixels out from that:         // glReadPixels appears to be faster than doing:         // GlStateManager.bindTexture(this.fbo.framebufferTexture);         // GL11.glGetTexImage(GL11.GL_TEXTURE_2D, 0, format, GL_UNSIGNED_BYTE,         // buffer);         glReadPixels(0, 0, width, height, format, GL_UNSIGNED_BYTE, buffer);         this.fbo.unbindFramebuffer();         GlStateManager.enableDepth();         Minecraft.getMinecraft().getFramebuffer().bindFramebuffer(true);     }      @Override     public void prepare(MissionInit missionInit)     {         this.fbo = new Framebuffer(this.videoParams.getWidth(), this.videoParams.getHeight(), true);         // Create a buffer for retrieving the depth map, if requested:         if (this.videoParams.isWantDepth())             this.depthBuffer = BufferUtils.createFloatBuffer(this.videoParams.getWidth() * this.videoParams.getHeight());         // Set the requested camera position         Minecraft.getMinecraft().gameSettings.thirdPersonView = this.videoParams.getViewpoint();     }      @Override     public void cleanup()     {         this.fbo.deleteFramebuffer(); // Must do this or we leak resources.     } }</td>
    <td align="left">blob</td>
    <td align="left">long method, data class, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method,  data class</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7623</td>
    <td align="left">https://github.com/Microsoft/malmo/blob/91b1a7a01ec0dd883f81a51048badac0398695f7/Minecraft/src/main/java/com/microsoft/Malmo/MissionHandlers/VideoProducerImplementation.java/#L44-L193</td>
    <td align="right">1</td>
    <td align="right">805</td>
    <td align="right">7623</td>
  </tr>
  <tr valign="top">
    <td align="right">874</td>
    <td align="left">{&quot;answer&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class JSAMDEmitter extends JSEmitter implements IJSAMDEmitter {      private Map foundAccessors = new HashMap();      private int inheritenceLevel = -1;      private ExportWriter exportWriter;      private boolean initializingFieldsInConstructor;      private List baseClassCalls = new ArrayList();      StringBuilder builder()     {         return getBuilder();     }      IJSAMDDocEmitter getDoc()     {         return (IJSAMDDocEmitter) getDocEmitter();     }      public JSAMDEmitter(FilterWriter out)     {         super(out);          exportWriter = new ExportWriter(this);     }      @Override     public void emitPackageHeader(IPackageDefinition definition)     {         // TODO (mschmalle|AMD) this is a hack but I know no other way to do replacements in a Writer         setBufferWrite(true);          write(JSAMDEmitterTokens.DEFINE);         write(ASEmitterTokens.PAREN_OPEN);          IASScope containedScope = definition.getContainedScope();         ITypeDefinition type = findType(containedScope.getAllLocalDefinitions());         if (type == null)             return;          exportWriter.addFrameworkDependencies();         exportWriter.addImports(type);          exportWriter.queueExports(type, true);          writeToken(ASEmitterTokens.COMMA);     }      @Override     public void emitPackageHeaderContents(IPackageDefinition definition)     {         // nothing     }      @Override     public void emitPackageContents(IPackageDefinition definition)     {         IASScope containedScope = definition.getContainedScope();         ITypeDefinition type = findType(containedScope.getAllLocalDefinitions());         if (type == null)             return;          write(&quot;function($exports&quot;);          exportWriter.queueExports(type, false);          write(&quot;) {&quot;);         indentPush();         writeNewline();         write(&quot;\&quot;use strict\&quot;; &quot;);         writeNewline();          ITypeNode tnode = findTypeNode(definition.getNode());         if (tnode != null)         {             getWalker().walk(tnode); // IClassNode | IInterfaceNode         }          indentPop();         writeNewline();         write(&quot;}&quot;); // end returned function     }      @Override     public void emitPackageFooter(IPackageDefinition definition)     {         IASScope containedScope = definition.getContainedScope();         ITypeDefinition type = findType(containedScope.getAllLocalDefinitions());         if (type == null)             return;          exportWriter.writeExports(type, true);         exportWriter.writeExports(type, false);          write(&quot;);&quot;); // end define()          // flush the buffer, writes the builder to out         flushBuilder();     }      private void emitConstructor(IFunctionNode node)     {         FunctionNode fn = (FunctionNode) node;         fn.parseFunctionBody(getProblems());          //IFunctionDefinition definition = node.getDefinition();          write(&quot;function &quot;);         write(node.getName());         emitParameters(node.getParametersContainerNode());         if (!isImplicit((IContainerNode) node.getScopedNode()))         {             emitMethodScope(node.getScopedNode());         }         else         {             // we have a synthesized constructor, implict         }     }      @Override     public void emitInterface(IInterfaceNode node)     {         final IInterfaceDefinition definition = node.getDefinition();         final String interfaceName = definition.getBaseName();          write(&quot;AS3.interface_($exports, {&quot;);         indentPush();         writeNewline();          write(&quot;package_: \&quot;&quot;);         write(definition.getPackageName());         write(&quot;\&quot;,&quot;);         writeNewline();          write(&quot;interface_: \&quot;&quot;);         write(interfaceName);         write(&quot;\&quot;&quot;);          IReference[] references = definition.getExtendedInterfaceReferences();         final int len = references.length;         if (len &gt; 0)         {             writeNewline();             write(&quot;extends_: [&quot;);             indentPush();             writeNewline();             int i = 0;             for (IReference reference : references)             {                 write(reference.getName());                 if (i &lt; len - 1)                 {                     write(&quot;,&quot;);                     writeNewline();                 }                 i++;             }             indentPop();             writeNewline();             write(&quot;]&quot;);         }          indentPop();         writeNewline();         write(&quot;});&quot;); // end compilation unit     }      @Override     public void emitClass(IClassNode node)     {         //ICompilerProject project = getWalker().getProject();          IClassDefinition definition = node.getDefinition();         getModel().setCurrentClass(definition);          final String className = definition.getBaseName();          write(&quot;AS3.compilationUnit($exports, function($primaryDeclaration){&quot;);         indentPush();         writeNewline();          // write constructor         emitConstructor((IFunctionNode) definition.getConstructor().getNode());         writeNewline();          // base class         IReference baseClassReference = definition.getBaseClassReference();         boolean hasSuper = baseClassReference != null                 &amp;&amp; !baseClassReference.getName().equals(&quot;Object&quot;);         if (hasSuper)         {             String baseName = baseClassReference.getName();             write(&quot;var Super = (&quot; + baseName + &quot;._ || &quot; + baseName                     + &quot;._$get());&quot;);             writeNewline();             write(&quot;var super$ = Super.prototype;&quot;);             writeNewline();         }          write(&quot;$primaryDeclaration(AS3.class_({&quot;);         indentPush();         writeNewline();          // write out package         write(&quot;package_: \&quot;&quot; + definition.getPackageName() + &quot;\&quot;,&quot;);         writeNewline();         // write class         write(&quot;class_: \&quot;&quot; + definition.getBaseName() + &quot;\&quot;,&quot;);         writeNewline();         if (hasSuper)         {             write(&quot;extends_: Super,&quot;);             writeNewline();         }          IReference[] references = definition                 .getImplementedInterfaceReferences();         int len = references.length;          // write implements         write(&quot;implements_:&quot;);         write(&quot; [&quot;);          if (len &gt; 0)         {             indentPush();             writeNewline();         }          int i = 0;         for (IReference reference : references)         {             write(reference.getName());             exportWriter.addDependency(reference.getName(),                     reference.getDisplayString(), false, false);             if (i &lt; len - 1)             {                 write(&quot;,&quot;);                 writeNewline();             }             i++;         }          if (len &gt; 0)         {             indentPop();             writeNewline();         }          write(&quot;],&quot;);         writeNewline();          // write members         final IDefinitionNode[] members = node.getAllMemberNodes();          write(&quot;members: {&quot;);          indentPush();         writeNewline();          // constructor         write(&quot;constructor: &quot; + className);         if (members.length &gt; 0)         {             write(&quot;,&quot;);             writeNewline();         }          List instanceMembers = new ArrayList();         List staticMembers = new ArrayList();         List staticStatements = new ArrayList();          TempTools.fillInstanceMembers(members, instanceMembers);         TempTools.fillStaticMembers(members, staticMembers, true, false);         TempTools.fillStaticStatements(node, staticStatements, false);          len = instanceMembers.size();         i = 0;         for (IDefinitionNode mnode : instanceMembers)         {             if (mnode instanceof IAccessorNode)             {                 if (foundAccessors.containsKey(mnode.getName()))                 {                     len--;                     continue;                 }                  getWalker().walk(mnode);             }             else if (mnode instanceof IFunctionNode)             {                 getWalker().walk(mnode);             }             else if (mnode instanceof IVariableNode)             {                 getWalker().walk(mnode);             }             else             {                 write(mnode.getName());             }              if (i &lt; len - 1)             {                 write(&quot;,&quot;);                 writeNewline();             }             i++;         }          // base class super calls         len = baseClassCalls.size();         i = 0;         if (len &gt; 0)         {             write(&quot;,&quot;);             writeNewline();         }          for (IDefinition baseCall : baseClassCalls)         {             write(baseCall.getBaseName() + &quot;$&quot; + inheritenceLevel + &quot;: super$.&quot;                     + baseCall.getBaseName());              if (i &lt; len - 1)             {                 write(&quot;,&quot;);                 writeNewline();             }         }          // end members         indentPop();         writeNewline();         write(&quot;},&quot;);         writeNewline();          len = staticMembers.size();          write(&quot;staticMembers: {&quot;);          indentPush();         writeNewline();          i = 0;         for (IDefinitionNode mnode : staticMembers)         {             if (mnode instanceof IAccessorNode)             {                 // TODO (mschmalle|AMD) havn't taken care of static accessors                 if (foundAccessors.containsKey(mnode.getName()))                     continue;                  foundAccessors.put(mnode.getName(), mnode);                  getWalker().walk(mnode);             }             else if (mnode instanceof IFunctionNode)             {                 getWalker().walk(mnode);             }             else if (mnode instanceof IVariableNode)             {                 getWalker().walk(mnode);             }              if (i &lt; len - 1)             {                 write(&quot;,&quot;);                 writeNewline();             }             i++;         }         indentPop();         if (len &gt; 0)             writeNewline();         write(&quot;}&quot;);          indentPop();         writeNewline();         write(&quot;}));&quot;);          // static statements         len = staticStatements.size();         if (len &gt; 0)             writeNewline();          i = 0;         for (IASNode statement : staticStatements)         {             getWalker().walk(statement);             if (!(statement instanceof IBlockNode))                 write(&quot;;&quot;);              if (i &lt; len - 1)                 writeNewline();              i++;         }          indentPop();         writeNewline();         write(&quot;});&quot;); // end compilation unit      }      //--------------------------------------------------------------------------     //      //--------------------------------------------------------------------------      @Override     public void emitField(IVariableNode node)     {         IVariableDefinition definition = (IVariableDefinition) node                 .getDefinition();          if (definition.isStatic())         {             IClassDefinition parent = (IClassDefinition) definition.getParent();             write(parent.getBaseName());             write(&quot;.&quot;);             write(definition.getBaseName());             write(&quot; = &quot;);             emitFieldInitialValue(node);             return;         }          String name = toPrivateName(definition);         write(name);         write(&quot;: &quot;);         write(&quot;{&quot;);         indentPush();         writeNewline();         // field value         write(&quot;value:&quot;);         emitFieldInitialValue(node);         write(&quot;,&quot;);         writeNewline();         // writable         write(&quot;writable:&quot;);         write(!(definition instanceof IConstantDefinition) ? &quot;true&quot; : &quot;false&quot;);         indentPop();         writeNewline();         write(&quot;}&quot;);     }      private void emitFieldInitialValue(IVariableNode node)     {         ICompilerProject project = getWalker().getProject();         IVariableDefinition definition = (IVariableDefinition) node                 .getDefinition();          IExpressionNode valueNode = node.getAssignedValueNode();         if (valueNode != null)             getWalker().walk(valueNode);         else             write(TempTools.toInitialValue(definition, project));     }      @Override     public void emitGetAccessor(IGetterNode node)     {         if (foundAccessors.containsKey(node.getName()))             return;          foundAccessors.put(node.getName(), node);          ICompilerProject project = getWalker().getProject();         IAccessorDefinition getter = (IAccessorDefinition) node.getDefinition();         IAccessorDefinition setter = getter                 .resolveCorrespondingAccessor(project);          emitGetterSetterPair(getter, setter);     }      @Override     public void emitSetAccessor(ISetterNode node)     {         if (foundAccessors.containsKey(node.getName()))             return;          foundAccessors.put(node.getName(), node);          ICompilerProject project = getWalker().getProject();         IAccessorDefinition setter = (IAccessorDefinition) node.getDefinition();         IAccessorDefinition getter = setter                 .resolveCorrespondingAccessor(project);          emitGetterSetterPair(getter, setter);     }      private void emitGetterSetterPair(IAccessorDefinition getter,             IAccessorDefinition setter)     {         write(getter.getBaseName());         write(&quot;: {&quot;);         indentPush();         writeNewline();          if (getter != null)         {             emitAccessor(&quot;get&quot;, getter);         }         if (setter != null)         {             write(&quot;,&quot;);             writeNewline();             emitAccessor(&quot;set&quot;, setter);         }          indentPop();         writeNewline();         write(&quot;}&quot;);      }      protected void emitAccessor(String kind, IAccessorDefinition definition)     {         IFunctionNode fnode = definition.getFunctionNode();          FunctionNode fn = (FunctionNode) fnode;         fn.parseFunctionBody(new ArrayList());          write(kind + &quot;: function &quot;);         write(definition.getBaseName() + &quot;$&quot; + kind);         emitParameters(fnode.getParametersContainerNode());         emitMethodScope(fnode.getScopedNode());     }      @Override     public void emitMethod(IFunctionNode node)     {         if (node.isConstructor())         {             emitConstructor(node);             return;         }          FunctionNode fn = (FunctionNode) node;         fn.parseFunctionBody(new ArrayList());         IFunctionDefinition definition = node.getDefinition();          String name = toPrivateName(definition);         write(name);         write(&quot;:&quot;);         write(&quot; function &quot;);         write(node.getName());         emitParameters(node.getParametersContainerNode());         emitMethodScope(node.getScopedNode());     }      @Override     public void emitFunctionBlockHeader(IFunctionNode node)     {         IFunctionDefinition definition = node.getDefinition();          if (node.isConstructor())         {             initializingFieldsInConstructor = true;             IClassDefinition type = (IClassDefinition) definition                     .getAncestorOfType(IClassDefinition.class);             // emit public fields init values             List fields = TempTools.getFields(type, true);             for (IVariableDefinition field : fields)             {                 if (TempTools.isVariableAParameter(field,                         definition.getParameters()))                     continue;                 write(&quot;this.&quot;);                 write(field.getBaseName());                 write(&quot; = &quot;);                 emitFieldInitialValue((IVariableNode) field.getNode());                 write(&quot;;&quot;);                 writeNewline();             }             initializingFieldsInConstructor = false;         }          emitDefaultParameterCodeBlock(node);     }      private void emitDefaultParameterCodeBlock(IFunctionNode node)     {         // TODO (mschmalle|AMD) test for ... rest          // if default parameters exist, produce the init code         IParameterNode[] pnodes = node.getParameterNodes();         Map defaults = TempTools.getDefaults(pnodes);         if (pnodes.length == 0)             return;          if (defaults != null)         {             boolean hasBody = node.getScopedNode().getChildCount() &gt; 0;              if (!hasBody)             {                 indentPush();                 write(ASEmitterTokens.INDENT);             }              final StringBuilder code = new StringBuilder();              List parameters = new ArrayList(                     defaults.values());             Collections.reverse(parameters);              int len = defaults.size();             // make the header in reverse order             for (IParameterNode pnode : parameters)             {                 if (pnode != null)                 {                     code.setLength(0);                      code.append(ASEmitterTokens.IF.getToken());                     code.append(ASEmitterTokens.SPACE.getToken());                     code.append(ASEmitterTokens.PAREN_OPEN.getToken());                     code.append(JSEmitterTokens.ARGUMENTS.getToken());                     code.append(ASEmitterTokens.MEMBER_ACCESS.getToken());                     code.append(JSAMDEmitterTokens.LENGTH.getToken());                     code.append(ASEmitterTokens.SPACE.getToken());                     code.append(ASEmitterTokens.LESS_THAN.getToken());                     code.append(ASEmitterTokens.SPACE.getToken());                     code.append(len);                     code.append(ASEmitterTokens.PAREN_CLOSE.getToken());                     code.append(ASEmitterTokens.SPACE.getToken());                     code.append(ASEmitterTokens.BLOCK_OPEN.getToken());                      write(code.toString());                      indentPush();                     writeNewline();                 }                 len--;             }              Collections.reverse(parameters);             for (int i = 0, n = parameters.size(); i &lt; n; i++)             {                 IParameterNode pnode = parameters.get(i);                  if (pnode != null)                 {                     code.setLength(0);                      code.append(pnode.getName());                     code.append(ASEmitterTokens.SPACE.getToken());                     code.append(ASEmitterTokens.EQUAL.getToken());                     code.append(ASEmitterTokens.SPACE.getToken());                     code.append(pnode.getDefaultValue());                     code.append(ASEmitterTokens.SEMICOLON.getToken());                     write(code.toString());                      indentPop();                     writeNewline();                      write(ASEmitterTokens.BLOCK_CLOSE);                      if (i == n - 1 &amp;&amp; !hasBody)                         indentPop();                      writeNewline();                 }             }         }     }      @Override     public void emitParameter(IParameterNode node)     {         getWalker().walk(node.getNameExpressionNode());     }      @Override     public void emitMemberAccessExpression(IMemberAccessExpressionNode node)     {         getWalker().walk(node.getLeftOperandNode());         if (!(node.getLeftOperandNode() instanceof ILanguageIdentifierNode))             write(node.getOperator().getOperatorText());         getWalker().walk(node.getRightOperandNode());     }      @Override     public void emitFunctionCall(IFunctionCallNode node)     {         if (node.isNewExpression())         {             write(ASEmitterTokens.NEW);             write(ASEmitterTokens.SPACE);         }         //        IDefinition resolve = node.resolveType(project);         //        if (NativeUtils.isNative(resolve.getBaseName()))         //        {         //         //        }          getWalker().walk(node.getNameNode());          emitArguments(node.getArgumentsNode());     }      @Override     public void emitArguments(IContainerNode node)     {         IContainerNode newNode = node;         FunctionCallNode fnode = (FunctionCallNode) node.getParent();         if (TempTools.injectThisArgument(fnode, false))         {             IdentifierNode thisNode = new IdentifierNode(&quot;this&quot;);             newNode = EmitterUtils.insertArgumentsBefore(node, thisNode);         }          int len = newNode.getChildCount();         write(ASEmitterTokens.PAREN_OPEN);         for (int i = 0; i &lt; len; i++)         {             IExpressionNode inode = (IExpressionNode) newNode.getChild(i);             if (inode.getNodeID() == ASTNodeID.IdentifierID)             {                 emitArgumentIdentifier((IIdentifierNode) inode);             }             else             {                 getWalker().walk(inode);             }              if (i &lt; len - 1)             {                 writeToken(ASEmitterTokens.COMMA);             }         }         write(ASEmitterTokens.PAREN_CLOSE);     }      private void emitArgumentIdentifier(IIdentifierNode node)     {         ITypeDefinition type = node.resolveType(getWalker().getProject());         if (type instanceof ClassTraitsDefinition)         {             String qualifiedName = type.getQualifiedName();             write(qualifiedName);         }         else         {             // XXX A problem?             getWalker().walk(node);         }     }      @Override     public void emitIdentifier(IIdentifierNode node)     {         ICompilerProject project = getWalker().getProject();          IDefinition resolve = node.resolve(project);         if (TempTools.isBinding(node, project))         {             // AS3.bind( this,&quot;secret$1&quot;);             // this will happen on the right side of the = sign to bind a methof/function             // to a variable              write(&quot;AS3.bind(this, \&quot;&quot; + toPrivateName(resolve) + &quot;\&quot;)&quot;);         }         else         {             IExpressionNode leftBase = TempTools.getNode(node, false, project);             if (leftBase == node)             {                 if (TempTools.isValidThis(node, project))                     write(&quot;this.&quot;);                 // in constructor and a type                 if (initializingFieldsInConstructor                         &amp;&amp; resolve instanceof IClassDefinition)                 {                     String name = resolve.getBaseName();                     write(&quot;(&quot; + name + &quot;._ || &quot; + name + &quot;._$get())&quot;);                     return;                 }             }              if (resolve != null)             {                 // TODO (mschmalle|AMD) optimize                 String name = toPrivateName(resolve);                 if (NativeUtils.isNative(name))                     exportWriter.addDependency(name, name, true, false);                  if (node.getParent() instanceof IMemberAccessExpressionNode)                 {                     IMemberAccessExpressionNode mnode = (IMemberAccessExpressionNode) node                             .getParent();                     if (mnode.getLeftOperandNode().getNodeID() == ASTNodeID.SuperID)                     {                         IIdentifierNode lnode = (IIdentifierNode) mnode                                 .getRightOperandNode();                          IClassNode cnode = (IClassNode) node                                 .getAncestorOfType(IClassNode.class);                          initializeInheritenceLevel(cnode.getDefinition());                          // super.foo();                         write(&quot;this.&quot;);                          write(lnode.getName() + &quot;$&quot; + inheritenceLevel);                          baseClassCalls.add(resolve);                          return;                     }                 }                 write(name);             }             else             {                 // no definition, just plain ole identifer                 write(node.getName());             }         }     }      @Override     protected void emitType(IExpressionNode node)     {     }      @Override     public void emitLanguageIdentifier(ILanguageIdentifierNode node)     {         if (node.getKind() == ILanguageIdentifierNode.LanguageIdentifierKind.ANY_TYPE)         {             write(&quot;&quot;);         }         else if (node.getKind() == ILanguageIdentifierNode.LanguageIdentifierKind.REST)         {             write(&quot;&quot;);         }         else if (node.getKind() == ILanguageIdentifierNode.LanguageIdentifierKind.SUPER)         {             IIdentifierNode inode = (IIdentifierNode) node;             if (inode.getParent() instanceof IMemberAccessExpressionNode)             {              }             else             {                 write(&quot;Super.call&quot;);             }         }         else if (node.getKind() == ILanguageIdentifierNode.LanguageIdentifierKind.THIS)         {             write(&quot;&quot;);         }         else if (node.getKind() == ILanguageIdentifierNode.LanguageIdentifierKind.VOID)         {             write(&quot;&quot;);         }     }      private String toPrivateName(IDefinition definition)     {         if (definition instanceof ITypeDefinition)             return definition.getBaseName();         if (!definition.isPrivate())             return definition.getBaseName();          initializeInheritenceLevel(definition);          return definition.getBaseName() + &quot;$&quot; + inheritenceLevel;     }      void initializeInheritenceLevel(IDefinition definition)     {         if (inheritenceLevel != -1)             return;          IClassDefinition cdefinition = null;         if (definition instanceof IClassDefinition)             cdefinition = (IClassDefinition) definition;         else             cdefinition = (IClassDefinition) definition                     .getAncestorOfType(IClassDefinition.class);          ICompilerProject project = getWalker().getProject();         IClassDefinition[] ancestry = cdefinition.resolveAncestry(project);         inheritenceLevel = ancestry.length - 1;     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7998</td>
    <td align="left">https://github.com/apache/royale-compiler/blob/fbd9bc3b9e48c80dbd8c1d32a6f83221e314efdd/compiler-jx/src/main/java/org/apache/royale/compiler/internal/codegen/js/amd/JSAMDEmitter.java/#L78-L971</td>
    <td align="right">1</td>
    <td align="right">874</td>
    <td align="right">7998</td>
  </tr>
  <tr valign="top">
    <td align="right">876</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ReloadingFileBasedConfigurationBuilder         extends FileBasedConfigurationBuilder implements ReloadingControllerSupport {     /** The default factory for creating reloading detector objects. */     private static final ReloadingDetectorFactory DEFAULT_DETECTOR_FACTORY =             new DefaultReloadingDetectorFactory();      /** The reloading controller associated with this object. */     private final ReloadingController reloadingController;      /**      * The reloading detector which does the actual reload check for the current      * result object. A new instance is created whenever a new result object      * (and thus a new current file handler) becomes available. The field must      * be volatile because it is accessed by the reloading controller probably      * from within another thread.      */     private volatile ReloadingDetector resultReloadingDetector;      /**      * Creates a new instance of {@code ReloadingFileBasedConfigurationBuilder}      * which produces result objects of the specified class and sets      * initialization parameters.      *      * @param resCls the result class (must not be null      * @param params a map with initialization parameters      * @throws IllegalArgumentException if the result class is null      */     public ReloadingFileBasedConfigurationBuilder(final Class resCls,             final Map params)     {         super(resCls, params);         reloadingController = createReloadingController();     }      /**      * Creates a new instance of {@code ReloadingFileBasedConfigurationBuilder}      * which produces result objects of the specified class and sets      * initialization parameters and the allowFailOnInit flag.      *      * @param resCls the result class (must not be null      * @param params a map with initialization parameters      * @param allowFailOnInit the allowFailOnInit flag      * @throws IllegalArgumentException if the result class is null      */     public ReloadingFileBasedConfigurationBuilder(final Class resCls,             final Map params, final boolean allowFailOnInit)     {         super(resCls, params, allowFailOnInit);         reloadingController = createReloadingController();     }      /**      * Creates a new instance of {@code ReloadingFileBasedConfigurationBuilder}      * which produces result objects of the specified class.      *      * @param resCls the result class (must not be null      * @throws IllegalArgumentException if the result class is null      */     public ReloadingFileBasedConfigurationBuilder(final Class resCls)     {         super(resCls);         reloadingController = createReloadingController();     }      /**      * Returns the {@code ReloadingController} associated with this builder.      * This controller is directly created. However, it becomes active (i.e.      * associated with a meaningful reloading detector) not before a result      * object was created.      *      * @return the {@code ReloadingController}      */     @Override     public ReloadingController getReloadingController()     {         return reloadingController;     }      /**      * {@inheritDoc} This method is overridden here to change the result type.      */     @Override     public ReloadingFileBasedConfigurationBuilder configure(             final BuilderParameters... params)     {         super.configure(params);         return this;     }      /**      * Creates a {@code ReloadingDetector} which monitors the passed in      * {@code FileHandler}. This method is called each time a new result object      * is created with the current {@code FileHandler}. This implementation      * checks whether a {@code ReloadingDetectorFactory} is specified in the      * current parameters. If this is the case, it is invoked. Otherwise, a      * default factory is used to create a {@code FileHandlerReloadingDetector}      * object. Note: This method is called from a synchronized block.      *      * @param handler the current {@code FileHandler}      * @param fbparams the object with parameters related to file-based builders      * @return a {@code ReloadingDetector} for this {@code FileHandler}      * @throws ConfigurationException if an error occurs      */     protected ReloadingDetector createReloadingDetector(final FileHandler handler,             final FileBasedBuilderParametersImpl fbparams)             throws ConfigurationException     {         return fetchDetectorFactory(fbparams).createReloadingDetector(handler,                 fbparams);     }      /**      * {@inheritDoc} This implementation also takes care that a new      * {@code ReloadingDetector} for the new current {@code FileHandler} is      * created. Also, the reloading controller's reloading state has to be      * reset; after the creation of a new result object changes in the      * underlying configuration source have to be monitored again.      */     @Override     protected void initFileHandler(final FileHandler handler)             throws ConfigurationException     {         super.initFileHandler(handler);          resultReloadingDetector =                 createReloadingDetector(handler,                         FileBasedBuilderParametersImpl.fromParameters(                                 getParameters(), true));     }      /**      * Creates the {@code ReloadingController} associated with this object. The      * controller is assigned a specialized reloading detector which delegates      * to the detector for the current result object. (      * {@code FileHandlerReloadingDetector} does not support changing the file      * handler, and {@code ReloadingController} does not support changing the      * reloading detector; therefore, this level of indirection is needed to      * change the monitored file dynamically.)      *      * @return the new {@code ReloadingController}      */     private ReloadingController createReloadingController()     {         final ReloadingDetector ctrlDetector = createReloadingDetectorForController();         final ReloadingController ctrl = new ReloadingController(ctrlDetector);         connectToReloadingController(ctrl);         return ctrl;     }      /**      * Creates a {@code ReloadingDetector} wrapper to be passed to the      * associated {@code ReloadingController}. This detector wrapper simply      * delegates to the current {@code ReloadingDetector} if it is available.      *      * @return the wrapper {@code ReloadingDetector}      */     private ReloadingDetector createReloadingDetectorForController()     {         return new ReloadingDetector()         {             @Override             public void reloadingPerformed()             {                 final ReloadingDetector detector = resultReloadingDetector;                 if (detector != null)                 {                     detector.reloadingPerformed();                 }             }              @Override             public boolean isReloadingRequired()             {                 final ReloadingDetector detector = resultReloadingDetector;                 return (detector != null) &amp;&amp; detector.isReloadingRequired();             }         };     }      /**      * Returns a {@code ReloadingDetectorFactory} either from the passed in      * parameters or a default factory.      *      * @param params the current parameters object      * @return the {@code ReloadingDetectorFactory} to be used      */     private static ReloadingDetectorFactory fetchDetectorFactory(             final FileBasedBuilderParametersImpl params)     {         final ReloadingDetectorFactory factory = params.getReloadingDetectorFactory();         return (factory != null) ? factory : DEFAULT_DETECTOR_FACTORY;     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8010</td>
    <td align="left">https://github.com/apache/commons-configuration/blob/34357e075d63c3634310878636f9498847badcab/src/main/java/org/apache/commons/configuration2/builder/ReloadingFileBasedConfigurationBuilder.java/#L62-L255</td>
    <td align="right">1</td>
    <td align="right">876</td>
    <td align="right">8010</td>
  </tr>
  <tr valign="top">
    <td align="right">877</td>
    <td align="left">{     &quot;answer&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Shape {      private String type;      private Map members = Collections.emptyMap();      private String documentation;      private List required;      private List enumValues;      private String payload;      private boolean flattened;      private boolean exception;      private boolean streaming;      private boolean wrapper;      private Member listMember;      private Member mapKeyType;      private Member mapValueType;      @JsonProperty(value = &quot;error&quot;)     private ErrorTrait errorTrait;      private long min;      private long max;      private String pattern;      private boolean fault;      private boolean deprecated;      @JsonProperty(value = &quot;eventstream&quot;)     private boolean isEventStream;      @JsonProperty(value = &quot;event&quot;)     private boolean isEvent;      private String timestampFormat;      private boolean sensitive;      public boolean isFault() {         return fault;     }      public void setFault(boolean fault) {         this.fault = fault;     }      public String getPattern() {         return pattern;     }      public void setPattern(String pattern) {         this.pattern = pattern;     }      public String getType() {         return type;     }      public void setType(String type) {         this.type = type;     }      public Map getMembers() {         return members;     }      public void setMembers(Map members) {         this.members = members;     }      public String getDocumentation() {         return documentation;     }      public void setDocumentation(String documentation) {         this.documentation = documentation;     }      public List getRequired() {         return required;     }      public void setRequired(List required) {         this.required = required;     }      public List getEnumValues() {         return enumValues;     }      @JsonProperty(value = &quot;enum&quot;)     public void setEnumValues(List enumValues) {         this.enumValues = enumValues;     }      public String getPayload() {         return payload;     }      public void setPayload(String payload) {         this.payload = payload;     }      public boolean isFlattened() {         return flattened;     }      public void setFlattened(boolean flattened) {         this.flattened = flattened;     }      public boolean isException() {         return exception;     }      public void setException(boolean exception) {         this.exception = exception;     }      public Member getMapKeyType() {         return mapKeyType;     }      @JsonProperty(value = &quot;key&quot;)     public void setMapKeyType(Member mapKeyType) {         this.mapKeyType = mapKeyType;     }      public Member getMapValueType() {         return mapValueType;     }      @JsonProperty(value = &quot;value&quot;)     public void setMapValueType(Member mapValueType) {         this.mapValueType = mapValueType;     }      public Member getListMember() {         return listMember;     }      @JsonProperty(value = &quot;member&quot;)     public void setListMember(Member listMember) {         this.listMember = listMember;     }      public long getMin() {         return min;     }      public void setMin(long min) {         this.min = min;     }      public long getMax() {         return max;     }      public void setMax(long max) {         this.max = max;     }      public boolean isStreaming() {         return streaming;     }      public void setStreaming(boolean streaming) {         this.streaming = streaming;     }      public boolean isWrapper() {         return wrapper;     }      public void setWrapper(boolean wrapper) {         this.wrapper = wrapper;     }      public ErrorTrait getErrorTrait() {         return errorTrait;     }      public void setErrorTrait(ErrorTrait errorTrait) {         this.errorTrait = errorTrait;     }      public boolean isDeprecated() {         return deprecated;     }      public void setDeprecated(boolean deprecated) {         this.deprecated = deprecated;     }      public boolean isEventStream() {         return isEventStream;     }      public void setIsEventStream(boolean eventStream) {         isEventStream = eventStream;     }      public boolean isEvent() {         return isEvent;     }      public void setIsEvent(boolean event) {         isEvent = event;     }      public String getTimestampFormat() {         return timestampFormat;     }      public void setTimestampFormat(String timestampFormat) {         this.timestampFormat = timestampFormat;     }      public boolean isSensitive() {         return sensitive;     }      public void setSensitive(boolean sensitive) {         this.sensitive = sensitive;     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;data class</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8011</td>
    <td align="left">https://github.com/aws/aws-sdk-java-v2/blob/1d5d11e8087c93ab1a3a2d35193052e526fd123c/codegen/src/main/java/software/amazon/awssdk/codegen/model/service/Shape.java/#L23-L261</td>
    <td align="right">1</td>
    <td align="right">877</td>
    <td align="right">8011</td>
  </tr>
  <tr valign="top">
    <td align="right">889</td>
    <td align="left">&nbsp;&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells. the bad smells are: 1. Blob&quot;   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DruidPooledCallableStatement extends DruidPooledPreparedStatement implements CallableStatement {      private CallableStatement stmt;      public DruidPooledCallableStatement(DruidPooledConnection conn, PreparedStatementHolder holder) throws SQLException{         super(conn, holder);         this.stmt = (CallableStatement) holder.statement;     }      public CallableStatement getCallableStatementRaw() {         return stmt;     }      @Override     public void registerOutParameter(int parameterIndex, int sqlType) throws SQLException {         try {             stmt.registerOutParameter(parameterIndex, sqlType);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(int parameterIndex, int sqlType, int scale) throws SQLException {         try {             stmt.registerOutParameter(parameterIndex, sqlType, scale);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public boolean wasNull() throws SQLException {         try {             return stmt.wasNull();         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public String getString(int parameterIndex) throws SQLException {         try {             return stmt.getString(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public boolean getBoolean(int parameterIndex) throws SQLException {         try {             return stmt.getBoolean(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public byte getByte(int parameterIndex) throws SQLException {         try {             return stmt.getByte(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public short getShort(int parameterIndex) throws SQLException {         try {             return stmt.getShort(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public int getInt(int parameterIndex) throws SQLException {         try {             return stmt.getInt(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public long getLong(int parameterIndex) throws SQLException {         try {             return stmt.getLong(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public float getFloat(int parameterIndex) throws SQLException {         try {             return stmt.getFloat(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public double getDouble(int parameterIndex) throws SQLException {         try {             return stmt.getDouble(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     @Deprecated     public BigDecimal getBigDecimal(int parameterIndex, int scale) throws SQLException {         try {             return stmt.getBigDecimal(parameterIndex, scale);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public byte[] getBytes(int parameterIndex) throws SQLException {         try {             return stmt.getBytes(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Date getDate(int parameterIndex) throws SQLException {         try {             return stmt.getDate(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Time getTime(int parameterIndex) throws SQLException {         try {             return stmt.getTime(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Timestamp getTimestamp(int parameterIndex) throws SQLException {         try {             return stmt.getTimestamp(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Object getObject(int parameterIndex) throws SQLException {         try {             Object obj = stmt.getObject(parameterIndex);             return wrapObject(obj);         } catch (Throwable t) {             throw checkException(t);         }     }      private Object wrapObject(Object obj) {         if (obj instanceof ResultSet) {             ResultSet rs = (ResultSet) obj;                          DruidPooledResultSet poolableResultSet = new DruidPooledResultSet(this, rs);             addResultSetTrace(poolableResultSet);                          obj = poolableResultSet;         }                  return obj;     }      @Override     public BigDecimal getBigDecimal(int parameterIndex) throws SQLException {         try {             return stmt.getBigDecimal(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Object getObject(int parameterIndex, java.util.Map&gt; map) throws SQLException {         try {             Object obj = stmt.getObject(parameterIndex, map);             return wrapObject(obj);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Ref getRef(int parameterIndex) throws SQLException {         try {             return stmt.getRef(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Blob getBlob(int parameterIndex) throws SQLException {         try {             return stmt.getBlob(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Clob getClob(int parameterIndex) throws SQLException {         try {             return stmt.getClob(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Array getArray(int parameterIndex) throws SQLException {         try {             return stmt.getArray(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Date getDate(int parameterIndex, Calendar cal) throws SQLException {         try {             return stmt.getDate(parameterIndex, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Time getTime(int parameterIndex, Calendar cal) throws SQLException {         try {             return stmt.getTime(parameterIndex, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Timestamp getTimestamp(int parameterIndex, Calendar cal) throws SQLException {         try {             return stmt.getTimestamp(parameterIndex, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(int parameterIndex, int sqlType, String typeName) throws SQLException {         try {             stmt.registerOutParameter(parameterIndex, sqlType, typeName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(String parameterName, int sqlType) throws SQLException {         try {             stmt.registerOutParameter(parameterName, sqlType);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(String parameterName, int sqlType, int scale) throws SQLException {         try {             stmt.registerOutParameter(parameterName, sqlType, scale);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(String parameterName, int sqlType, String typeName) throws SQLException {         try {             stmt.registerOutParameter(parameterName, sqlType, typeName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.net.URL getURL(int parameterIndex) throws SQLException {         try {             return stmt.getURL(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setURL(String parameterName, java.net.URL val) throws SQLException {         try {             stmt.setURL(parameterName, val);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNull(String parameterName, int sqlType) throws SQLException {         try {             stmt.setNull(parameterName, sqlType);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBoolean(String parameterName, boolean x) throws SQLException {         try {             stmt.setBoolean(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setByte(String parameterName, byte x) throws SQLException {         try {             stmt.setByte(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setShort(String parameterName, short x) throws SQLException {         try {             stmt.setShort(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setInt(String parameterName, int x) throws SQLException {         try {             stmt.setInt(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setLong(String parameterName, long x) throws SQLException {         try {             stmt.setLong(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setFloat(String parameterName, float x) throws SQLException {         try {             stmt.setFloat(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setDouble(String parameterName, double x) throws SQLException {         try {             stmt.setDouble(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBigDecimal(String parameterName, BigDecimal x) throws SQLException {         try {             stmt.setBigDecimal(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setString(String parameterName, String x) throws SQLException {         try {             stmt.setString(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBytes(String parameterName, byte x[]) throws SQLException {         try {             stmt.setBytes(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setDate(String parameterName, java.sql.Date x) throws SQLException {         try {             stmt.setDate(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setTime(String parameterName, java.sql.Time x) throws SQLException {         try {             stmt.setTime(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setTimestamp(String parameterName, java.sql.Timestamp x) throws SQLException {         try {             stmt.setTimestamp(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setAsciiStream(String parameterName, java.io.InputStream x, int length) throws SQLException {         try {             stmt.setAsciiStream(parameterName, x, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBinaryStream(String parameterName, java.io.InputStream x, int length) throws SQLException {         try {             stmt.setBinaryStream(parameterName, x, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setObject(String parameterName, Object x, int targetSqlType, int scale) throws SQLException {         try {             stmt.setObject(parameterName, x, targetSqlType, scale);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setObject(String parameterName, Object x, int targetSqlType) throws SQLException {         try {             stmt.setObject(parameterName, x, targetSqlType);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setObject(String parameterName, Object x) throws SQLException {         try {             stmt.setObject(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setCharacterStream(String parameterName, java.io.Reader reader, int length) throws SQLException {         try {             stmt.setCharacterStream(parameterName, reader, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setDate(String parameterName, java.sql.Date x, Calendar cal) throws SQLException {         try {             stmt.setDate(parameterName, x, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setTime(String parameterName, java.sql.Time x, Calendar cal) throws SQLException {         try {             stmt.setTime(parameterName, x, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setTimestamp(String parameterName, java.sql.Timestamp x, Calendar cal) throws SQLException {         try {             stmt.setTimestamp(parameterName, x, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNull(String parameterName, int sqlType, String typeName) throws SQLException {         try {             stmt.setNull(parameterName, sqlType, typeName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public String getString(String parameterName) throws SQLException {         try {             return stmt.getString(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public boolean getBoolean(String parameterName) throws SQLException {         try {             return stmt.getBoolean(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public byte getByte(String parameterName) throws SQLException {         try {             return stmt.getByte(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public short getShort(String parameterName) throws SQLException {         try {             return stmt.getShort(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public int getInt(String parameterName) throws SQLException {         try {             return stmt.getInt(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public long getLong(String parameterName) throws SQLException {         try {             return stmt.getLong(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public float getFloat(String parameterName) throws SQLException {         try {             return stmt.getFloat(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public double getDouble(String parameterName) throws SQLException {         try {             return stmt.getDouble(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public byte[] getBytes(String parameterName) throws SQLException {         try {             return stmt.getBytes(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Date getDate(String parameterName) throws SQLException {         try {             return stmt.getDate(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Time getTime(String parameterName) throws SQLException {         try {             return stmt.getTime(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Timestamp getTimestamp(String parameterName) throws SQLException {         try {             return stmt.getTimestamp(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Object getObject(String parameterName) throws SQLException {         try {             Object obj = stmt.getObject(parameterName);             return wrapObject(obj);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public BigDecimal getBigDecimal(String parameterName) throws SQLException {         try {             return stmt.getBigDecimal(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Object getObject(String parameterName, java.util.Map&gt; map) throws SQLException {         try {             Object obj = stmt.getObject(parameterName, map);             return wrapObject(obj);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Ref getRef(String parameterName) throws SQLException {         try {             return stmt.getRef(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Blob getBlob(String parameterName) throws SQLException {         try {             return stmt.getBlob(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Clob getClob(String parameterName) throws SQLException {         try {             return stmt.getClob(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Array getArray(String parameterName) throws SQLException {         try {             return stmt.getArray(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Date getDate(String parameterName, Calendar cal) throws SQLException {         try {             return stmt.getDate(parameterName, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Time getTime(String parameterName, Calendar cal) throws SQLException {         try {             return stmt.getTime(parameterName, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Timestamp getTimestamp(String parameterName, Calendar cal) throws SQLException {         try {             return stmt.getTimestamp(parameterName, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.net.URL getURL(String parameterName) throws SQLException {         try {             return stmt.getURL(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public RowId getRowId(int parameterIndex) throws SQLException {         try {             return stmt.getRowId(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public RowId getRowId(String parameterName) throws SQLException {         try {             return stmt.getRowId(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setRowId(String parameterName, RowId x) throws SQLException {         try {             stmt.setRowId(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNString(String parameterName, String value) throws SQLException {         try {             stmt.setNString(parameterName, value);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNCharacterStream(String parameterName, Reader value, long length) throws SQLException {         try {             stmt.setNCharacterStream(parameterName, value, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNClob(String parameterName, NClob value) throws SQLException {         try {             stmt.setNClob(parameterName, value);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setClob(String parameterName, Reader reader, long length) throws SQLException {         try {             stmt.setClob(parameterName, reader, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBlob(String parameterName, InputStream inputStream, long length) throws SQLException {         try {             stmt.setBlob(parameterName, inputStream, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNClob(String parameterName, Reader reader, long length) throws SQLException {         try {             stmt.setNClob(parameterName, reader, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public NClob getNClob(int parameterIndex) throws SQLException {         try {             return stmt.getNClob(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public NClob getNClob(String parameterName) throws SQLException {         try {             return stmt.getNClob(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setSQLXML(String parameterName, SQLXML xmlObject) throws SQLException {         try {             stmt.setSQLXML(parameterName, xmlObject);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public SQLXML getSQLXML(int parameterIndex) throws SQLException {         try {             return stmt.getSQLXML(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public SQLXML getSQLXML(String parameterName) throws SQLException {         try {             return stmt.getSQLXML(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public String getNString(int parameterIndex) throws SQLException {         try {             return stmt.getNString(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public String getNString(String parameterName) throws SQLException {         try {             return stmt.getNString(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.io.Reader getNCharacterStream(int parameterIndex) throws SQLException {         try {             return stmt.getNCharacterStream(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.io.Reader getNCharacterStream(String parameterName) throws SQLException {         try {             return stmt.getNCharacterStream(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.io.Reader getCharacterStream(int parameterIndex) throws SQLException {         try {             return stmt.getCharacterStream(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.io.Reader getCharacterStream(String parameterName) throws SQLException {         try {             return stmt.getCharacterStream(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBlob(String parameterName, Blob x) throws SQLException {         try {             stmt.setBlob(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setClob(String parameterName, Clob x) throws SQLException {         try {             stmt.setClob(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setAsciiStream(String parameterName, java.io.InputStream x, long length) throws SQLException {         try {             stmt.setAsciiStream(parameterName, x, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBinaryStream(String parameterName, java.io.InputStream x, long length) throws SQLException {         try {             stmt.setBinaryStream(parameterName, x, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setCharacterStream(String parameterName, java.io.Reader reader, long length) throws SQLException {         try {             stmt.setCharacterStream(parameterName, reader, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setAsciiStream(String parameterName, java.io.InputStream x) throws SQLException {         try {             stmt.setAsciiStream(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBinaryStream(String parameterName, java.io.InputStream x) throws SQLException {         try {             stmt.setBinaryStream(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setCharacterStream(String parameterName, java.io.Reader reader) throws SQLException {         try {             stmt.setCharacterStream(parameterName, reader);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNCharacterStream(String parameterName, Reader value) throws SQLException {         try {             stmt.setNCharacterStream(parameterName, value);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setClob(String parameterName, Reader reader) throws SQLException {         try {             stmt.setClob(parameterName, reader);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBlob(String parameterName, InputStream inputStream) throws SQLException {         try {             stmt.setBlob(parameterName, inputStream);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNClob(String parameterName, Reader reader) throws SQLException {         try {             stmt.setNClob(parameterName, reader);         } catch (Throwable t) {             throw checkException(t);         }     }      public  T getObject(int parameterIndex, Class type) throws SQLException {         throw new SQLFeatureNotSupportedException();     }      public  T getObject(String parameterName, Class type) throws SQLException {         throw new SQLFeatureNotSupportedException();     }      @SuppressWarnings(&quot;unchecked&quot;)     public  T unwrap(Class iface) throws SQLException {         if (iface == CallableStatement.class || iface == PreparedStatement.class) {             if (stmt instanceof CallableStatementProxy) {                 return stmt.unwrap(iface);             }             return (T) stmt;         }                  return super.unwrap(iface);     } }</td>
    <td align="left">blob</td>
    <td align="left">1. blob   </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">&nbsp; </td>
    <td align="left">blob</td>
    <td align="right">0</td>
    <td align="right">8078</td>
    <td align="left">https://github.com/alibaba/druid/blob/768469fe4d1340efe1036453366a58c9ab7e30d1/src/main/java/com/alibaba/druid/pool/DruidPooledCallableStatement.java/#L40-L1089</td>
    <td align="right">1</td>
    <td align="right">889</td>
    <td align="right">8078</td>
  </tr>
  <tr valign="top">
    <td align="right">913</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Long Method&quot;, &quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Bug288734TestLanguageSwitch extends Switch {   /**    * The cached model package    *     *     * @generated    */   protected static Bug288734TestLanguagePackage modelPackage;    /**    * Creates an instance of the switch.    *     *     * @generated    */   public Bug288734TestLanguageSwitch()   {     if (modelPackage == null)     {       modelPackage = Bug288734TestLanguagePackage.eINSTANCE;     }   }    /**    * Checks whether this is a switch for the given package.    *     *     * @param ePackage the package in question.    * @return whether this is a switch for the given package.    * @generated    */   @Override   protected boolean isSwitchFor(EPackage ePackage)   {     return ePackage == modelPackage;   }    /**    * Calls caseXXX for each class of the model until one returns a non null result; it yields that result.    *     *     * @return the first non-null result returned by a caseXXX call.    * @generated    */   @Override   protected T doSwitch(int classifierID, EObject theEObject)   {     switch (classifierID)     {       case Bug288734TestLanguagePackage.MODEL:       {         Model model = (Model)theEObject;         T result = caseModel(model);         if (result == null) result = defaultCase(theEObject);         return result;       }       case Bug288734TestLanguagePackage.TCONSTANT:       {         TConstant tConstant = (TConstant)theEObject;         T result = caseTConstant(tConstant);         if (result == null) result = defaultCase(theEObject);         return result;       }       case Bug288734TestLanguagePackage.TSTRING_CONSTANT:       {         TStringConstant tStringConstant = (TStringConstant)theEObject;         T result = caseTStringConstant(tStringConstant);         if (result == null) result = caseTConstant(tStringConstant);         if (result == null) result = defaultCase(theEObject);         return result;       }       case Bug288734TestLanguagePackage.TINTEGER_CONSTANT:       {         TIntegerConstant tIntegerConstant = (TIntegerConstant)theEObject;         T result = caseTIntegerConstant(tIntegerConstant);         if (result == null) result = caseTConstant(tIntegerConstant);         if (result == null) result = defaultCase(theEObject);         return result;       }       case Bug288734TestLanguagePackage.TBOOLEAN_CONSTANT:       {         TBooleanConstant tBooleanConstant = (TBooleanConstant)theEObject;         T result = caseTBooleanConstant(tBooleanConstant);         if (result == null) result = caseTConstant(tBooleanConstant);         if (result == null) result = defaultCase(theEObject);         return result;       }       case Bug288734TestLanguagePackage.TANNOTATION:       {         TAnnotation tAnnotation = (TAnnotation)theEObject;         T result = caseTAnnotation(tAnnotation);         if (result == null) result = defaultCase(theEObject);         return result;       }       default: return defaultCase(theEObject);     }   }    /**    * Returns the result of interpreting the object as an instance of 'Model'.    *     * This implementation returns null;    * returning a non-null result will terminate the switch.    *     * @param object the target of the switch.    * @return the result of interpreting the object as an instance of 'Model'.    * @see #doSwitch(org.eclipse.emf.ecore.EObject) doSwitch(EObject)    * @generated    */   public T caseModel(Model object)   {     return null;   }    /**    * Returns the result of interpreting the object as an instance of 'TConstant'.    *     * This implementation returns null;    * returning a non-null result will terminate the switch.    *     * @param object the target of the switch.    * @return the result of interpreting the object as an instance of 'TConstant'.    * @see #doSwitch(org.eclipse.emf.ecore.EObject) doSwitch(EObject)    * @generated    */   public T caseTConstant(TConstant object)   {     return null;   }    /**    * Returns the result of interpreting the object as an instance of 'TString Constant'.    *     * This implementation returns null;    * returning a non-null result will terminate the switch.    *     * @param object the target of the switch.    * @return the result of interpreting the object as an instance of 'TString Constant'.    * @see #doSwitch(org.eclipse.emf.ecore.EObject) doSwitch(EObject)    * @generated    */   public T caseTStringConstant(TStringConstant object)   {     return null;   }    /**    * Returns the result of interpreting the object as an instance of 'TInteger Constant'.    *     * This implementation returns null;    * returning a non-null result will terminate the switch.    *     * @param object the target of the switch.    * @return the result of interpreting the object as an instance of 'TInteger Constant'.    * @see #doSwitch(org.eclipse.emf.ecore.EObject) doSwitch(EObject)    * @generated    */   public T caseTIntegerConstant(TIntegerConstant object)   {     return null;   }    /**    * Returns the result of interpreting the object as an instance of 'TBoolean Constant'.    *     * This implementation returns null;    * returning a non-null result will terminate the switch.    *     * @param object the target of the switch.    * @return the result of interpreting the object as an instance of 'TBoolean Constant'.    * @see #doSwitch(org.eclipse.emf.ecore.EObject) doSwitch(EObject)    * @generated    */   public T caseTBooleanConstant(TBooleanConstant object)   {     return null;   }    /**    * Returns the result of interpreting the object as an instance of 'TAnnotation'.    *     * This implementation returns null;    * returning a non-null result will terminate the switch.    *     * @param object the target of the switch.    * @return the result of interpreting the object as an instance of 'TAnnotation'.    * @see #doSwitch(org.eclipse.emf.ecore.EObject) doSwitch(EObject)    * @generated    */   public T caseTAnnotation(TAnnotation object)   {     return null;   }    /**    * Returns the result of interpreting the object as an instance of 'EObject'.    *     * This implementation returns null;    * returning a non-null result will terminate the switch, but this is the last case anyway.    *     * @param object the target of the switch.    * @return the result of interpreting the object as an instance of 'EObject'.    * @see #doSwitch(org.eclipse.emf.ecore.EObject)    * @generated    */   @Override   public T defaultCase(EObject object)   {     return null;   }  } //Bug288734TestLanguageSwitch</td>
    <td align="left">blob</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8243</td>
    <td align="left">https://github.com/eclipse/xtext-eclipse/blob/0c7546b6aaf3644a77fc68eef9f3da368cbbeabd/org.eclipse.xtext.ui.tests/src-gen/org/eclipse/xtext/ui/tests/editor/contentassist/bug288734TestLanguage/util/Bug288734TestLanguageSwitch.java/#L26-L238</td>
    <td align="right">1</td>
    <td align="right">913</td>
    <td align="right">8243</td>
  </tr>
  <tr valign="top">
    <td align="right">943</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SimpleMessage implements Message {      private final MessageId messageId;     private final String subType;     private final String mediaType;     private final SharedInputStream content;     private final int bodyStartOctet;     private final Date internalDate;     private final long size;     private final Long textualLineCount;     private final List properties;     private final List attachments;      public SimpleMessage(MessageId messageId, SharedInputStream content, long size, Date internalDate, String subType, String mediaType, int bodyStartOctet, Long textualLineCount, List properties, List attachments) {         this.messageId = messageId;         this.subType = subType;         this.mediaType = mediaType;         this.content = content;         this.bodyStartOctet = bodyStartOctet;         this.internalDate = internalDate;         this.size = size;         this.textualLineCount = textualLineCount;         this.properties = properties;         this.attachments = attachments;     }      public SimpleMessage(MessageId messageId, SharedInputStream content, long size, Date internalDate, String subType, String mediaType, int bodyStartOctet, Long textualLineCount, List properties) {         this(messageId, content, size, internalDate, subType, mediaType, bodyStartOctet, textualLineCount, properties, ImmutableList.of());     }      @Override     public MessageId getMessageId() {         return messageId;     }      @Override     public Date getInternalDate() {         return internalDate;     }      @Override     public InputStream getBodyContent() throws IOException {         return content.newStream(bodyStartOctet, -1);     }      @Override     public String getMediaType() {         return mediaType;     }      @Override     public String getSubType() {         return subType;     }      @Override     public long getBodyOctets() {         return getFullContentOctets() - bodyStartOctet;     }      @Override     public long getHeaderOctets() {         return bodyStartOctet;     }      @Override     public long getFullContentOctets() {         return size;     }      @Override     public Long getTextualLineCount() {         return textualLineCount;     }      @Override     public InputStream getHeaderContent() throws IOException {         long headerEnd = bodyStartOctet;         if (headerEnd &lt; 0) {             headerEnd = 0;         }         return content.newStream(0, headerEnd);     }      @Override     public InputStream getFullContent() throws IOException {         return content.newStream(0, -1);     }      @Override     public List getProperties() {         return properties;     }      @Override     public List getAttachments() {         return attachments;     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8473</td>
    <td align="left">https://github.com/apache/james-project/blob/fa24a096a5853459c3769a34ccc68feb91626bfa/mailbox/store/src/main/java/org/apache/james/mailbox/store/mail/model/impl/SimpleMessage.java/#L35-L133</td>
    <td align="right">1</td>
    <td align="right">943</td>
    <td align="right">8473</td>
  </tr>
  <tr valign="top">
    <td align="right">948</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells\nthe bad smells are: 1. Blob, 2. Long Method&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class _Repository4Soap_QueryPendingSetsWithLocalWorkspaces     implements ElementSerializable {     // No attributes          // Elements     protected String localWorkspaceName;     protected String localWorkspaceOwner;     protected String queryWorkspaceName;     protected String ownerName;     protected _ItemSpec[] itemSpecs;     protected boolean generateDownloadUrls;     protected String[] itemPropertyFilters;      public _Repository4Soap_QueryPendingSetsWithLocalWorkspaces()     {         super();     }      public _Repository4Soap_QueryPendingSetsWithLocalWorkspaces(         final String localWorkspaceName,         final String localWorkspaceOwner,         final String queryWorkspaceName,         final String ownerName,         final _ItemSpec[] itemSpecs,         final boolean generateDownloadUrls,         final String[] itemPropertyFilters)     {         // TODO : Call super() instead of setting all fields directly?         setLocalWorkspaceName(localWorkspaceName);         setLocalWorkspaceOwner(localWorkspaceOwner);         setQueryWorkspaceName(queryWorkspaceName);         setOwnerName(ownerName);         setItemSpecs(itemSpecs);         setGenerateDownloadUrls(generateDownloadUrls);         setItemPropertyFilters(itemPropertyFilters);     }      public String getLocalWorkspaceName()     {         return this.localWorkspaceName;     }      public void setLocalWorkspaceName(String value)     {         this.localWorkspaceName = value;     }      public String getLocalWorkspaceOwner()     {         return this.localWorkspaceOwner;     }      public void setLocalWorkspaceOwner(String value)     {         this.localWorkspaceOwner = value;     }      public String getQueryWorkspaceName()     {         return this.queryWorkspaceName;     }      public void setQueryWorkspaceName(String value)     {         this.queryWorkspaceName = value;     }      public String getOwnerName()     {         return this.ownerName;     }      public void setOwnerName(String value)     {         this.ownerName = value;     }      public _ItemSpec[] getItemSpecs()     {         return this.itemSpecs;     }      public void setItemSpecs(_ItemSpec[] value)     {         this.itemSpecs = value;     }      public boolean isGenerateDownloadUrls()     {         return this.generateDownloadUrls;     }      public void setGenerateDownloadUrls(boolean value)     {         this.generateDownloadUrls = value;     }      public String[] getItemPropertyFilters()     {         return this.itemPropertyFilters;     }      public void setItemPropertyFilters(String[] value)     {         this.itemPropertyFilters = value;     }      public void writeAsElement(         final XMLStreamWriter writer,         final String name)         throws XMLStreamException     {         writer.writeStartElement(name);          // Elements         XMLStreamWriterHelper.writeElement(             writer,             &quot;localWorkspaceName&quot;,             this.localWorkspaceName);         XMLStreamWriterHelper.writeElement(             writer,             &quot;localWorkspaceOwner&quot;,             this.localWorkspaceOwner);         XMLStreamWriterHelper.writeElement(             writer,             &quot;queryWorkspaceName&quot;,             this.queryWorkspaceName);         XMLStreamWriterHelper.writeElement(             writer,             &quot;ownerName&quot;,             this.ownerName);          if (this.itemSpecs != null)         {             /*              * The element type is an array.              */             writer.writeStartElement(&quot;itemSpecs&quot;);              for (int iterator0 = 0; iterator0 &lt; this.itemSpecs.length; iterator0++)             {                 this.itemSpecs[iterator0].writeAsElement(                     writer,                     &quot;ItemSpec&quot;);             }              writer.writeEndElement();         }          XMLStreamWriterHelper.writeElement(             writer,             &quot;generateDownloadUrls&quot;,             this.generateDownloadUrls);          if (this.itemPropertyFilters != null)         {             /*              * The element type is an array.              */             writer.writeStartElement(&quot;itemPropertyFilters&quot;);              for (int iterator0 = 0; iterator0 &lt; this.itemPropertyFilters.length; iterator0++)             {                 XMLStreamWriterHelper.writeElement(                     writer,                     &quot;string&quot;,                     this.itemPropertyFilters[iterator0]);             }              writer.writeEndElement();         }          writer.writeEndElement();     } }</td>
    <td align="left">blob</td>
    <td align="left">1. blob, 2. long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;2. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8508</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core.ws/generated-src/ms/tfs/versioncontrol/clientservices/_03/_Repository4Soap_QueryPendingSetsWithLocalWorkspaces.java/#L33-L208</td>
    <td align="right">1</td>
    <td align="right">948</td>
    <td align="right">8508</td>
  </tr>
  <tr valign="top">
    <td align="right">1015</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Long Method&quot;,         &quot;Blob&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class KafkaTestServer {     public static final int CACHE_TTL_MS = 1;      private static final Logger LOGGER = LoggerFactory.getLogger(KafkaTestServer.class);      private int kafkaPort = -1;     private TestingServer zkServer;     private KafkaServerStartable kafkaServer = null;     private File sentrySitePath = null;      public KafkaTestServer(File sentrySitePath) throws Exception {         this.sentrySitePath = sentrySitePath;         createZkServer();         this.kafkaPort = TestUtils.getFreePort();         createKafkaServer();     }      public void start() throws Exception {         kafkaServer.startup();         LOGGER.info(&quot;Started Kafka broker.&quot;);     }      public void shutdown() {         if (kafkaServer != null) {             kafkaServer.shutdown();             kafkaServer.awaitShutdown();             LOGGER.info(&quot;Stopped Kafka server.&quot;);         }          if (zkServer != null) {             try {                 zkServer.stop();                 LOGGER.info(&quot;Stopped ZK server.&quot;);             } catch (IOException e) {                 LOGGER.error(&quot;Failed to shutdown ZK server.&quot;, e);             }         }     }      private Path getTempDirectory() {         Path tempDirectory = null;         try {             tempDirectory = Files.createTempDirectory(&quot;kafka-sentry-&quot;);         } catch (IOException e) {             LOGGER.error(&quot;Failed to create temp dir for Kafka's log dir.&quot;);             throw new RuntimeException(e);         }         return tempDirectory;     }      private void setupKafkaProps(Properties props) throws UnknownHostException {         props.put(&quot;listeners&quot;, &quot;SSL://&quot; + InetAddress.getLocalHost().getHostAddress() + &quot;:&quot; + kafkaPort);         props.put(&quot;log.dir&quot;, getTempDirectory().toAbsolutePath().toString());         props.put(&quot;zookeeper.connect&quot;, zkServer.getConnectString());         props.put(&quot;replica.socket.timeout.ms&quot;, &quot;1500&quot;);         props.put(&quot;controller.socket.timeout.ms&quot;, &quot;1500&quot;);         props.put(&quot;controlled.shutdown.enable&quot;, true);         props.put(&quot;delete.topic.enable&quot;, false);         props.put(&quot;controlled.shutdown.retry.backoff.ms&quot;, &quot;100&quot;);         props.put(&quot;port&quot;, kafkaPort);         props.put(&quot;offsets.topic.replication.factor&quot;, &quot;1&quot;);         props.put(&quot;authorizer.class.name&quot;, &quot;org.apache.sentry.kafka.authorizer.SentryKafkaAuthorizer&quot;);         props.put(&quot;sentry.kafka.site.url&quot;, &quot;file://&quot; + sentrySitePath.getAbsolutePath());         props.put(&quot;allow.everyone.if.no.acl.found&quot;, &quot;true&quot;);         props.put(&quot;ssl.keystore.location&quot;, KafkaTestServer.class.getResource(&quot;/test.keystore.jks&quot;).getPath());         props.put(&quot;ssl.keystore.password&quot;, &quot;test-ks-passwd&quot;);         props.put(&quot;ssl.key.password&quot;, &quot;test-key-passwd&quot;);         props.put(&quot;ssl.truststore.location&quot;, KafkaTestServer.class.getResource(&quot;/test.truststore.jks&quot;).getPath());         props.put(&quot;ssl.truststore.password&quot;, &quot;test-ts-passwd&quot;);         props.put(&quot;security.inter.broker.protocol&quot;, &quot;SSL&quot;);         props.put(&quot;ssl.client.auth&quot;, &quot;required&quot;);         props.put(KafkaAuthConf.KAFKA_SUPER_USERS, &quot;User:CN=superuser;User:CN=superuser1; User:CN=Superuser2 &quot;);         props.put(KafkaAuthConf.SENTRY_KAFKA_CACHING_ENABLE_NAME, &quot;true&quot;);         props.put(KafkaAuthConf.SENTRY_KAFKA_CACHING_TTL_MS_NAME, String.valueOf(CACHE_TTL_MS));     }      private void createKafkaServer() throws UnknownHostException {         Properties props = new Properties();         setupKafkaProps(props);         kafkaServer = KafkaServerStartable.fromProps(props);     }      private void createZkServer() throws Exception {         try {             zkServer = new TestingServer();         } catch (Exception e) {             LOGGER.error(&quot;Failed to create testing zookeeper server.&quot;);             throw new RuntimeException(e);         }     }      public String getBootstrapServers() throws UnknownHostException {         return InetAddress.getLocalHost().getHostAddress() + &quot;:&quot; + kafkaPort;     } }</td>
    <td align="left">blob</td>
    <td align="left">long method, blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method,  data class</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9297</td>
    <td align="left">https://github.com/apache/sentry/blob/f859446b65bbc274bc4899464892151eec8217c6/sentry-tests/sentry-tests-kafka/src/main/java/org/apache/sentry/tests/e2e/kafka/KafkaTestServer.java/#L35-L129</td>
    <td align="right">1</td>
    <td align="right">1015</td>
    <td align="right">9297</td>
  </tr>
  <tr valign="top">
    <td align="right">1055</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Long Method&quot;,         &quot;Blob&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class XmiWriterCasConsumer extends CasConsumer_ImplBase {   /**    * Name of configuration parameter that must be set to the path of a directory into which the    * output files will be written.    */   public static final String PARAM_OUTPUTDIR = &quot;OutputDirectory&quot;;    private File mOutputDir;    private int mDocNum;    public void initialize() throws ResourceInitializationException {     mDocNum = 0;     mOutputDir = new File((String) getConfigParameterValue(PARAM_OUTPUTDIR));     if (!mOutputDir.exists()) {       mOutputDir.mkdirs();     }   }    /**    * Processes the CAS which was populated by the TextAnalysisEngines.     * In this case, the CAS is converted to XMI and written into the output file .    *     * @param aCAS    *          a CAS which has been populated by the TAEs    *     * @throws ResourceProcessException    *           if there is an error in processing the Resource    *     * @see org.apache.uima.collection.base_cpm.CasObjectProcessor#processCas(org.apache.uima.cas.CAS)    */   public void processCas(CAS aCAS) throws ResourceProcessException {     String modelFileName = null;      JCas jcas;     try {       jcas = aCAS.getJCas();     } catch (CASException e) {       throw new ResourceProcessException(e);     }      // retrieve the filename of the input file from the CAS     FSIterator it = jcas.getAnnotationIndex(SourceDocumentInformation.type).iterator();     File outFile = null;     if (it.hasNext()) {       SourceDocumentInformation fileLoc = (SourceDocumentInformation) it.next();       File inFile;       try {         inFile = new File(new URL(fileLoc.getUri()).getPath());         String outFileName = inFile.getName();         if (fileLoc.getOffsetInSource() &gt; 0) {           outFileName += (&quot;_&quot; + fileLoc.getOffsetInSource());         }         outFileName += &quot;.xmi&quot;;         outFile = new File(mOutputDir, outFileName);         modelFileName = mOutputDir.getAbsolutePath() + &quot;/&quot; + inFile.getName() + &quot;.ecore&quot;;       } catch (MalformedURLException e1) {         // invalid URL, use default processing below       }     }     if (outFile == null) {       outFile = new File(mOutputDir, &quot;doc&quot; + mDocNum++ + &quot;.xmi&quot;);          }     // serialize XCAS and write to output file     try {       writeXmi(jcas.getCas(), outFile, modelFileName);     } catch (IOException e) {       throw new ResourceProcessException(e);     } catch (SAXException e) {       throw new ResourceProcessException(e);     }   }    /**    * Serialize a CAS to a file in XMI format    *     * @param aCas    *          CAS to serialize    * @param name    *          output file    * @throws SAXException -    * @throws Exception -    *     * @throws ResourceProcessException -    */   private void writeXmi(CAS aCas, File name, String modelFileName) throws IOException, SAXException {     FileOutputStream out = null;      try {       // write XMI       out = new FileOutputStream(name);       XmiCasSerializer ser = new XmiCasSerializer(aCas.getTypeSystem());       XMLSerializer xmlSer = new XMLSerializer(out, false);       ser.serialize(aCas, xmlSer.getContentHandler());     } finally {       if (out != null) {         out.close();       }     }   } }</td>
    <td align="left">blob</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9506</td>
    <td align="left">https://github.com/apache/uima-uimaj/blob/e79c33b5a3e4c25afb407e68e98df1829a68e5a7/uimaj-examples/src/main/java/org/apache/uima/examples/xmi/XmiWriterCasConsumer.java/#L48-L148</td>
    <td align="right">1</td>
    <td align="right">1055</td>
    <td align="right">9506</td>
  </tr>
  <tr valign="top">
    <td align="right">1070</td>
    <td align="left">{&quot;result&quot;:&quot;YES I found bad smells&quot;,&quot;the bad smells are&quot;:[&quot;1. Long Method&quot;,&quot;2. Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
class WindmillStateReader {   /**    * Ideal maximum bytes in a TagBag response. However, Windmill will always return at least one    * value if possible irrespective of this limit.    */   public static final long MAX_BAG_BYTES = 8L &lt;&lt; 20; // 8MB    /**    * Ideal maximum bytes in a KeyedGetDataResponse. However, Windmill will always return at least    * one value if possible irrespective of this limit.    */   public static final long MAX_KEY_BYTES = 16L &lt;&lt; 20; // 16MB    /**    * When combined with a key and computationId, represents the unique address for state managed by    * Windmill.    */   private static class StateTag {     private enum Kind {       VALUE,       BAG,       WATERMARK;     }      private final Kind kind;     private final ByteString tag;     private final String stateFamily;      /**      * For {@link Kind#BAG} kinds: A previous 'continuation_position' returned by Windmill to signal      * the resulting bag was incomplete. Sending that position will request the next page of values.      * Null for first request.      *      * Null for other kinds.      */     @Nullable private final Long requestPosition;      private StateTag(         Kind kind, ByteString tag, String stateFamily, @Nullable Long requestPosition) {       this.kind = kind;       this.tag = tag;       this.stateFamily = Preconditions.checkNotNull(stateFamily);       this.requestPosition = requestPosition;     }      private StateTag(Kind kind, ByteString tag, String stateFamily) {       this(kind, tag, stateFamily, null);     }      @Override     public boolean equals(Object obj) {       if (this == obj) {         return true;       }        if (!(obj instanceof StateTag)) {         return false;       }        StateTag that = (StateTag) obj;       return Objects.equal(this.kind, that.kind)           &amp;&amp; Objects.equal(this.tag, that.tag)           &amp;&amp; Objects.equal(this.stateFamily, that.stateFamily)           &amp;&amp; Objects.equal(this.requestPosition, that.requestPosition);     }      @Override     public int hashCode() {       return Objects.hashCode(kind, tag, stateFamily, requestPosition);     }      @Override     public String toString() {       return &quot;Tag(&quot;           + kind           + &quot;,&quot;           + tag.toStringUtf8()           + &quot;,&quot;           + stateFamily           + (requestPosition == null ? &quot;&quot; : (&quot;,&quot; + requestPosition.toString()))           + &quot;)&quot;;     }   }    /**    * An in-memory collection of deserialized values and an optional continuation position to pass to    * Windmill when fetching the next page of values.    */   private static class ValuesAndContPosition {     private final List values;      /** Position to pass to next request for next page of values. Null if done. */     @Nullable private final Long continuationPosition;      public ValuesAndContPosition(List values, @Nullable Long continuationPosition) {       this.values = values;       this.continuationPosition = continuationPosition;     }   }    private final String computation;   private final ByteString key;   private final long shardingKey;   private final long workToken;    private final MetricTrackingWindmillServerStub server;    private long bytesRead = 0L;    public WindmillStateReader(       MetricTrackingWindmillServerStub server,       String computation,       ByteString key,       long shardingKey,       long workToken) {     this.server = server;     this.computation = computation;     this.key = key;     this.shardingKey = shardingKey;     this.workToken = workToken;   }    private static final class CoderAndFuture {     private Coder coder;     private final SettableFuture future;      private CoderAndFuture(Coder coder, SettableFuture future) {       this.coder = coder;       this.future = future;     }      private SettableFuture getFuture() {       return future;     }      private SettableFuture getNonDoneFuture(StateTag stateTag) {       if (future.isDone()) {         throw new IllegalStateException(&quot;Future for &quot; + stateTag + &quot; is already done&quot;);       }       return future;     }      private Coder getAndClearCoder() {       if (coder == null) {         throw new IllegalStateException(&quot;Coder has already been cleared from cache&quot;);       }       Coder result = coder;       coder = null;       return result;     }      private void checkNoCoder() {       if (coder != null) {         throw new IllegalStateException(&quot;Unexpected coder&quot;);       }     }   }    @VisibleForTesting ConcurrentLinkedQueue pendingLookups = new ConcurrentLinkedQueue&lt;&gt;();   private ConcurrentHashMap&gt; waiting = new ConcurrentHashMap&lt;&gt;();    private  Future stateFuture(       StateTag stateTag, @Nullable Coder coder) {     CoderAndFuture coderAndFuture =         new CoderAndFuture&lt;&gt;(coder, SettableFuture.create());     CoderAndFuture existingCoderAndFutureWildcard =         waiting.putIfAbsent(stateTag, coderAndFuture);     if (existingCoderAndFutureWildcard == null) {       // Schedule a new request. It's response is guaranteed to find the future and coder.       pendingLookups.add(stateTag);     } else {       // Piggy-back on the pending or already answered request.       @SuppressWarnings(&quot;unchecked&quot;)       CoderAndFuture existingCoderAndFuture =           (CoderAndFuture) existingCoderAndFutureWildcard;       coderAndFuture = existingCoderAndFuture;     }      return wrappedFuture(coderAndFuture.getFuture());   }    private  CoderAndFuture getWaiting(       StateTag stateTag, boolean shouldRemove) {     CoderAndFuture coderAndFutureWildcard;     if (shouldRemove) {       coderAndFutureWildcard = waiting.remove(stateTag);     } else {       coderAndFutureWildcard = waiting.get(stateTag);     }     if (coderAndFutureWildcard == null) {       throw new IllegalStateException(&quot;Missing future for &quot; + stateTag);     }     @SuppressWarnings(&quot;unchecked&quot;)     CoderAndFuture coderAndFuture =         (CoderAndFuture) coderAndFutureWildcard;     return coderAndFuture;   }    public Future watermarkFuture(ByteString encodedTag, String stateFamily) {     return stateFuture(new StateTag(StateTag.Kind.WATERMARK, encodedTag, stateFamily), null);   }    public  Future valueFuture(ByteString encodedTag, String stateFamily, Coder coder) {     return stateFuture(new StateTag(StateTag.Kind.VALUE, encodedTag, stateFamily), coder);   }    public  Future&gt; bagFuture(       ByteString encodedTag, String stateFamily, Coder elemCoder) {     // First request has no continuation position.     StateTag stateTag = new StateTag(StateTag.Kind.BAG, encodedTag, stateFamily);     // Convert the ValuesAndContPosition to Iterable.     return valuesToPagingIterableFuture(         stateTag, elemCoder, this.&gt;stateFuture(stateTag, elemCoder));   }    /**    * Internal request to fetch the next 'page' of values in a TagBag. Return null if no continuation    * position is in {@code contStateTag}, which signals there are no more pages.    */   @Nullable   private  Future&gt; continuationBagFuture(       StateTag contStateTag, Coder elemCoder) {     if (contStateTag.requestPosition == null) {       // We're done.       return null;     }     return stateFuture(contStateTag, elemCoder);   }    /**    * A future which will trigger a GetData request to Windmill for all outstanding futures on the    * first {@link #get}.    */   private static class WrappedFuture extends ForwardingFuture.SimpleForwardingFuture {     /**      * The reader we'll use to service the eventual read. Null if read has been fulfilled.      *      * NOTE: We must clear this after the read is fulfilled to prevent space leaks.      */     @Nullable private WindmillStateReader reader;      public WrappedFuture(WindmillStateReader reader, Future delegate) {       super(delegate);       this.reader = reader;     }      @Override     public T get() throws InterruptedException, ExecutionException {       if (!delegate().isDone() &amp;&amp; reader != null) {         // Only one thread per reader, so no race here.         reader.startBatchAndBlock();       }       reader = null;       return super.get();     }      @Override     public T get(long timeout, TimeUnit unit)         throws InterruptedException, ExecutionException, TimeoutException {       if (!delegate().isDone() &amp;&amp; reader != null) {         // Only one thread per reader, so no race here.         reader.startBatchAndBlock();       }       reader = null;       return super.get(timeout, unit);     }   }    private  Future wrappedFuture(final Future future) {     if (future.isDone()) {       // If the underlying lookup is already complete, we don't need to create the wrapper.       return future;     } else {       // Otherwise, wrap the true future so we know when to trigger a GetData.       return new WrappedFuture&lt;&gt;(this, future);     }   }    /** Function to extract an {@link Iterable} from the continuation-supporting page read future. */   private static class ToIterableFunction       implements Function, Iterable&gt; {     /**      * Reader to request continuation pages from, or {@literal null} if no continuation pages      * required.      */     @Nullable private WindmillStateReader reader;      private final StateTag stateTag;     private final Coder elemCoder;      public ToIterableFunction(WindmillStateReader reader, StateTag stateTag, Coder elemCoder) {       this.reader = reader;       this.stateTag = stateTag;       this.elemCoder = elemCoder;     }      @Override     public Iterable apply(ValuesAndContPosition valuesAndContPosition) {       if (valuesAndContPosition.continuationPosition == null) {         // Number of values is small enough Windmill sent us the entire bag in one response.         reader = null;         return valuesAndContPosition.values;       } else {         // Return an iterable which knows how to come back for more.         StateTag contStateTag =             new StateTag(                 stateTag.kind,                 stateTag.tag,                 stateTag.stateFamily,                 valuesAndContPosition.continuationPosition);         return new BagPagingIterable&lt;&gt;(             reader, valuesAndContPosition.values, contStateTag, elemCoder);       }     }   }    /**    * Return future which transforms a {@code ValuesAndContPosition} result into the initial    * Iterable result expected from the external caller.    */   private  Future&gt; valuesToPagingIterableFuture(       final StateTag stateTag,       final Coder elemCoder,       final Future&gt; future) {     return Futures.lazyTransform(future, new ToIterableFunction(this, stateTag, elemCoder));   }    public void startBatchAndBlock() {     // First, drain work out of the pending lookups into a set. These will be the items we fetch.     HashSet toFetch = new HashSet&lt;&gt;();     while (!pendingLookups.isEmpty()) {       StateTag stateTag = pendingLookups.poll();       if (stateTag == null) {         break;       }        if (!toFetch.add(stateTag)) {         throw new IllegalStateException(&quot;Duplicate tags being fetched.&quot;);       }     }      // If we failed to drain anything, some other thread pulled it off the queue. We have no work     // to do.     if (toFetch.isEmpty()) {       return;     }      Windmill.KeyedGetDataRequest request = createRequest(toFetch);     Windmill.KeyedGetDataResponse response = server.getStateData(computation, request);      if (response == null) {       throw new RuntimeException(&quot;Windmill unexpectedly returned null for request &quot; + request);     }      consumeResponse(request, response, toFetch);   }    public long getBytesRead() {     return bytesRead;   }    private Windmill.KeyedGetDataRequest createRequest(Iterable toFetch) {     Windmill.KeyedGetDataRequest.Builder keyedDataBuilder =         Windmill.KeyedGetDataRequest.newBuilder()             .setKey(key)             .setShardingKey(shardingKey)             .setWorkToken(workToken);      for (StateTag stateTag : toFetch) {       switch (stateTag.kind) {         case BAG:           TagBag.Builder bag =               keyedDataBuilder                   .addBagsToFetchBuilder()                   .setTag(stateTag.tag)                   .setStateFamily(stateTag.stateFamily)                   .setFetchMaxBytes(MAX_BAG_BYTES);           if (stateTag.requestPosition != null) {             // We're asking for the next page.             bag.setRequestPosition(stateTag.requestPosition);           }           break;          case WATERMARK:           keyedDataBuilder               .addWatermarkHoldsToFetchBuilder()               .setTag(stateTag.tag)               .setStateFamily(stateTag.stateFamily);           break;          case VALUE:           keyedDataBuilder               .addValuesToFetchBuilder()               .setTag(stateTag.tag)               .setStateFamily(stateTag.stateFamily);           break;          default:           throw new RuntimeException(&quot;Unknown kind of tag requested: &quot; + stateTag.kind);       }     }      keyedDataBuilder.setMaxBytes(MAX_KEY_BYTES);      return keyedDataBuilder.build();   }    private void consumeResponse(       Windmill.KeyedGetDataRequest request,       Windmill.KeyedGetDataResponse response,       Set toFetch) {     bytesRead += response.getSerializedSize();      if (response.getFailed()) {       // Set up all the futures for this key to throw an exception:       KeyTokenInvalidException keyTokenInvalidException =           new KeyTokenInvalidException(key.toStringUtf8());       for (StateTag stateTag : toFetch) {         waiting.get(stateTag).future.setException(keyTokenInvalidException);       }       return;     }      if (!key.equals(response.getKey())) {       throw new RuntimeException(&quot;Expected data for key &quot; + key + &quot; but was &quot; + response.getKey());     }      for (Windmill.TagBag bag : response.getBagsList()) {       StateTag stateTag =           new StateTag(               StateTag.Kind.BAG,               bag.getTag(),               bag.getStateFamily(),               bag.hasRequestPosition() ? bag.getRequestPosition() : null);       if (!toFetch.remove(stateTag)) {         throw new IllegalStateException(             &quot;Received response for unrequested tag &quot; + stateTag + &quot;. Pending tags: &quot; + toFetch);       }       consumeBag(bag, stateTag);     }      for (Windmill.WatermarkHold hold : response.getWatermarkHoldsList()) {       StateTag stateTag =           new StateTag(StateTag.Kind.WATERMARK, hold.getTag(), hold.getStateFamily());       if (!toFetch.remove(stateTag)) {         throw new IllegalStateException(             &quot;Received response for unrequested tag &quot; + stateTag + &quot;. Pending tags: &quot; + toFetch);       }       consumeWatermark(hold, stateTag);     }      for (Windmill.TagValue value : response.getValuesList()) {       StateTag stateTag = new StateTag(StateTag.Kind.VALUE, value.getTag(), value.getStateFamily());       if (!toFetch.remove(stateTag)) {         throw new IllegalStateException(             &quot;Received response for unrequested tag &quot; + stateTag + &quot;. Pending tags: &quot; + toFetch);       }       consumeTagValue(value, stateTag);     }      if (!toFetch.isEmpty()) {       throw new IllegalStateException(           &quot;Didn't receive responses for all pending fetches. Missing: &quot; + toFetch);     }   }    @VisibleForTesting   static class WeightedList extends ForwardingList implements Weighted {     private List delegate;     long weight;      WeightedList(List delegate) {       this.delegate = delegate;       this.weight = 0;     }      @Override     protected List delegate() {       return delegate;     }      @Override     public boolean add(T elem) {       throw new UnsupportedOperationException(&quot;Must use AddWeighted()&quot;);     }      @Override     public long getWeight() {       return weight;     }      public void addWeighted(T elem, long weight) {       delegate.add(elem);       this.weight += weight;     }   }    /** The deserialized values in {@code bag} as a read-only array list. */   private  List bagPageValues(TagBag bag, Coder elemCoder) {     if (bag.getValuesCount() == 0) {       return new WeightedList(Collections.emptyList());     }      WeightedList valueList = new WeightedList&lt;&gt;(new ArrayList(bag.getValuesCount()));     for (ByteString value : bag.getValuesList()) {       try {         valueList.addWeighted(             elemCoder.decode(value.newInput(), Coder.Context.OUTER), value.size());       } catch (IOException e) {         throw new IllegalStateException(&quot;Unable to decode tag list using &quot; + elemCoder, e);       }     }     return valueList;   }    private  void consumeBag(TagBag bag, StateTag stateTag) {     boolean shouldRemove;     if (stateTag.requestPosition == null) {       // This is the response for the first page.       // Leave the future in the cache so subsequent requests for the first page       // can return immediately.       shouldRemove = false;     } else {       // This is a response for a subsequent page.       // Don't cache the future since we may need to make multiple requests with different       // continuation positions.       shouldRemove = true;     }     CoderAndFuture&gt; coderAndFuture = getWaiting(stateTag, shouldRemove);     SettableFuture&gt; future = coderAndFuture.getNonDoneFuture(stateTag);     Coder coder = coderAndFuture.getAndClearCoder();     List values = this.bagPageValues(bag, coder);     future.set(         new ValuesAndContPosition(             values, bag.hasContinuationPosition() ? bag.getContinuationPosition() : null));   }    private void consumeWatermark(Windmill.WatermarkHold watermarkHold, StateTag stateTag) {     CoderAndFuture coderAndFuture = getWaiting(stateTag, false);     SettableFuture future = coderAndFuture.getNonDoneFuture(stateTag);     // No coders for watermarks     coderAndFuture.checkNoCoder();      Instant hold = null;     for (long timestamp : watermarkHold.getTimestampsList()) {       Instant instant = new Instant(TimeUnit.MICROSECONDS.toMillis(timestamp));       // TIMESTAMP_MAX_VALUE represents infinity, and windmill will return it if no hold is set, so       // don't treat it as a hold here.       if (instant.isBefore(BoundedWindow.TIMESTAMP_MAX_VALUE)           &amp;&amp; (hold == null || instant.isBefore(hold))) {         hold = instant;       }     }      future.set(hold);   }    private  void consumeTagValue(TagValue tagValue, StateTag stateTag) {     CoderAndFuture coderAndFuture = getWaiting(stateTag, false);     SettableFuture future = coderAndFuture.getNonDoneFuture(stateTag);     Coder coder = coderAndFuture.getAndClearCoder();      if (tagValue.hasValue()         &amp;&amp; tagValue.getValue().hasData()         &amp;&amp; !tagValue.getValue().getData().isEmpty()) {       InputStream inputStream = tagValue.getValue().getData().newInput();       try {         T value = coder.decode(inputStream, Coder.Context.OUTER);         future.set(value);       } catch (IOException e) {         throw new IllegalStateException(&quot;Unable to decode value using &quot; + coder, e);       }     } else {       future.set(null);     }   }    /**    * An iterable over elements backed by paginated GetData requests to Windmill. The iterable may be    * iterated over an arbitrary number of times and multiple iterators may be active simultaneously.    *    * There are two pattern we wish to support with low -memory and -latency:    *    *     *   Re-iterate over the initial elements multiple times (eg Iterables.first). We'll cache the    *       initial 'page' of values returned by Windmill from our first request for the lifetime of    *       the iterable.    *   Iterate through all elements of a very large collection. We'll send the GetData request    *       for the next page when the current page is begun. We'll discard intermediate pages and    *       only retain the first. Thus the maximum memory pressure is one page plus one page per    *       call to iterator.    *     */   private static class BagPagingIterable implements Iterable {     /**      * The reader we will use for scheduling continuation pages.      *      * NOTE We've made this explicit to remind us to be careful not to cache the iterable.      */     private final WindmillStateReader reader;      /** Initial values returned for the first page. Never reclaimed. */     private final List firstPage;      /** State tag with continuation position set for second page. */     private final StateTag secondPagePos;      /** Coder for elements. */     private final Coder elemCoder;      private BagPagingIterable(         WindmillStateReader reader, List firstPage, StateTag secondPagePos, Coder elemCoder) {       this.reader = reader;       this.firstPage = firstPage;       this.secondPagePos = secondPagePos;       this.elemCoder = elemCoder;     }      @Override     public Iterator iterator() {       return new AbstractIterator() {         private Iterator currentPage = firstPage.iterator();         private StateTag nextPagePos = secondPagePos;         private Future&gt; pendingNextPage =             // NOTE: The results of continuation page reads are never cached.             reader.continuationBagFuture(nextPagePos, elemCoder);          @Override         protected T computeNext() {           while (true) {             if (currentPage.hasNext()) {               return currentPage.next();             }             if (pendingNextPage == null) {               return endOfData();             }              ValuesAndContPosition valuesAndContPosition;             try {               valuesAndContPosition = pendingNextPage.get();             } catch (InterruptedException | ExecutionException e) {               if (e instanceof InterruptedException) {                 Thread.currentThread().interrupt();               }               throw new RuntimeException(&quot;Unable to read value from state&quot;, e);             }             currentPage = valuesAndContPosition.values.iterator();             nextPagePos =                 new StateTag(                     nextPagePos.kind,                     nextPagePos.tag,                     nextPagePos.stateFamily,                     valuesAndContPosition.continuationPosition);             pendingNextPage =                 // NOTE: The results of continuation page reads are never cached.                 reader.continuationBagFuture(nextPagePos, elemCoder);           }         }       };     }   } }</td>
    <td align="left">blob</td>
    <td align="left">1. long method, 2. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9598</td>
    <td align="left">https://github.com/apache/beam/blob/a956ff77a8448e5f2c12f6695fec608348b5ab60/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateReader.java/#L61-L722</td>
    <td align="right">1</td>
    <td align="right">1070</td>
    <td align="right">9598</td>
  </tr>
  <tr valign="top">
    <td align="right">1105</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [         &quot;1. Long Method&quot;,         &quot;2. Blob&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Private final class NflyFSystem extends FileSystem {   private static final Log LOG = LogFactory.getLog(NflyFSystem.class);   private static final String NFLY_TMP_PREFIX = &quot;_nfly_tmp_&quot;;    enum NflyKey {     // minimum replication, if local filesystem is included +1 is recommended     minReplication,      // forces to check all the replicas and fetch the one with the most recent     // time stamp     //     readMostRecent,      // create missing replica from far to near, including local?     repairOnRead   }    private static final int DEFAULT_MIN_REPLICATION = 2;   private static URI nflyURI = URI.create(&quot;nfly:///&quot;);    private final NflyNode[] nodes;   private final int minReplication;   private final EnumSet nflyFlags;   private final Node myNode;   private final NetworkTopology topology;    /**    * URI's authority is used as an approximation of the distance from the    * client. It's sufficient for DC but not accurate because worker nodes can be    * closer.    */   private static class NflyNode extends NodeBase {     private final ChRootedFileSystem fs;     NflyNode(String hostName, String rackName, URI uri,         Configuration conf) throws IOException {       this(hostName, rackName, new ChRootedFileSystem(uri, conf));     }      NflyNode(String hostName, String rackName, ChRootedFileSystem fs) {       super(hostName, rackName);       this.fs = fs;     }      ChRootedFileSystem getFs() {       return fs;     }      @Override     public boolean equals(Object o) {       // satisfy findbugs       return super.equals(o);     }      @Override     public int hashCode() {       // satisfy findbugs       return super.hashCode();     }    }    private static final class MRNflyNode       extends NflyNode implements Comparable {      private FileStatus status;      private MRNflyNode(NflyNode n) {       super(n.getName(), n.getNetworkLocation(), n.fs);     }      private void updateFileStatus(Path f) throws IOException {       final FileStatus tmpStatus = getFs().getFileStatus(f);       status = tmpStatus == null           ? notFoundStatus(f)           : tmpStatus;     }      // TODO allow configurable error margin for FileSystems with different     // timestamp precisions     @Override     public int compareTo(MRNflyNode other) {       if (status == null) {         return other.status == null ? 0 : 1; // move non-null towards head       } else if (other.status == null) {         return -1; // move this towards head       } else {         final long mtime = status.getModificationTime();         final long their = other.status.getModificationTime();         return Long.compare(their, mtime); // move more recent towards head       }     }      @Override     public boolean equals(Object o) {       if (!(o instanceof MRNflyNode)) {         return false;       }       MRNflyNode other = (MRNflyNode) o;       return 0 == compareTo(other);     }      @Override     public int hashCode() {       // satisfy findbugs       return super.hashCode();     }      private FileStatus nflyStatus() throws IOException {       return new NflyStatus(getFs(), status);     }      private FileStatus cloneStatus() throws IOException {       return new FileStatus(status.getLen(),           status.isDirectory(),           status.getReplication(),           status.getBlockSize(),           status.getModificationTime(),           status.getAccessTime(),           null, null, null,           status.isSymlink() ? status.getSymlink() : null,           status.getPath());     }   }    private MRNflyNode[] workSet() {     final MRNflyNode[] res = new MRNflyNode[nodes.length];     for (int i = 0; i &lt; res.length; i++) {       res[i] = new MRNflyNode(nodes[i]);     }     return res;   }     /**    * Utility to replace null with DEFAULT_RACK.    *    * @param rackString rack value, can be null    * @return non-null rack string    */   private static String getRack(String rackString) {     return rackString == null ? NetworkTopology.DEFAULT_RACK : rackString;   }    /**    * Creates a new Nfly instance.    *    * @param uris the list of uris in the mount point    * @param conf configuration object    * @param minReplication minimum copies to commit a write op    * @param nflyFlags modes such readMostRecent    * @throws IOException    */   private NflyFSystem(URI[] uris, Configuration conf, int minReplication,       EnumSet nflyFlags) throws IOException {     if (uris.length &lt; minReplication) {       throw new IOException(minReplication + &quot; &lt; &quot; + uris.length           + &quot;: Minimum replication &lt; #destinations&quot;);     }     setConf(conf);     final String localHostName = InetAddress.getLocalHost().getHostName();      // build a list for topology resolution     final List hostStrings = new ArrayList(uris.length + 1);     for (URI uri : uris) {       final String uriHost = uri.getHost();       // assume local file system or another closest filesystem if no authority       hostStrings.add(uriHost == null ? localHostName : uriHost);     }     // resolve the client node     hostStrings.add(localHostName);      final DNSToSwitchMapping tmpDns = ReflectionUtils.newInstance(conf.getClass(         CommonConfigurationKeys.NET_TOPOLOGY_NODE_SWITCH_MAPPING_IMPL_KEY,         ScriptBasedMapping.class, DNSToSwitchMapping.class), conf);      // this is an ArrayList     final List rackStrings = tmpDns.resolve(hostStrings);     nodes = new NflyNode[uris.length];     final Iterator rackIter = rackStrings.iterator();     for (int i = 0; i &lt; nodes.length; i++) {       nodes[i] = new NflyNode(hostStrings.get(i), rackIter.next(), uris[i],           conf);     }     // sort all the uri's by distance from myNode, the local file system will     // automatically be the the first one.     //     myNode = new NodeBase(localHostName, getRack(rackIter.next()));     topology = NetworkTopology.getInstance(conf);     topology.sortByDistance(myNode, nodes, nodes.length);      this.minReplication = minReplication;     this.nflyFlags = nflyFlags;     statistics = getStatistics(nflyURI.getScheme(), getClass());   }    /**    * Transactional output stream. When creating path /dir/file    * 1) create invisible /real/dir_i/_nfly_tmp_file    * 2) when more than min replication was written, write is committed by    *   renaming all successfully written files to /real/dir_i/file    */   private final class NflyOutputStream extends OutputStream {     // actual path     private final Path nflyPath;     // tmp path before commit     private final Path tmpPath;     // broadcast set     private final FSDataOutputStream[] outputStreams;     // status set: 1 working, 0 problem     private final BitSet opSet;     private final boolean useOverwrite;      private NflyOutputStream(Path f, FsPermission permission, boolean overwrite,         int bufferSize, short replication, long blockSize,         Progressable progress) throws IOException {       nflyPath = f;       tmpPath = getNflyTmpPath(f);       outputStreams = new FSDataOutputStream[nodes.length];       for (int i = 0; i &lt; outputStreams.length; i++) {         outputStreams[i] = nodes[i].fs.create(tmpPath, permission, true,             bufferSize, replication, blockSize, progress);       }       opSet = new BitSet(outputStreams.length);       opSet.set(0, outputStreams.length);       useOverwrite = false;     }      //     // TODO consider how to clean up and throw an exception early when the clear     // bits under min replication     //      private void mayThrow(List ioExceptions) throws IOException {       final IOException ioe = MultipleIOException           .createIOException(ioExceptions);       if (opSet.cardinality() &lt; minReplication) {         throw ioe;       } else {         if (LOG.isDebugEnabled()) {           LOG.debug(&quot;Exceptions occurred: &quot; + ioe);         }       }     }       @Override     public void write(int d) throws IOException {       final List ioExceptions = new ArrayList();       for (int i = opSet.nextSetBit(0);            i &gt;=0;            i = opSet.nextSetBit(i + 1)) {         try {           outputStreams[i].write(d);         } catch (Throwable t) {           osException(i, &quot;write&quot;, t, ioExceptions);         }       }       mayThrow(ioExceptions);     }      private void osException(int i, String op, Throwable t,         List ioExceptions) {       opSet.clear(i);       processThrowable(nodes[i], op, t, ioExceptions, tmpPath, nflyPath);     }      @Override     public void write(byte[] bytes, int offset, int len) throws IOException {       final List ioExceptions = new ArrayList();       for (int i = opSet.nextSetBit(0);            i &gt;= 0;            i = opSet.nextSetBit(i + 1)) {         try {           outputStreams[i].write(bytes, offset, len);         } catch (Throwable t) {           osException(i, &quot;write&quot;, t, ioExceptions);         }       }       mayThrow(ioExceptions);     }      @Override     public void flush() throws IOException {       final List ioExceptions = new ArrayList();       for (int i = opSet.nextSetBit(0);            i &gt;= 0;            i = opSet.nextSetBit(i + 1)) {         try {           outputStreams[i].flush();         } catch (Throwable t) {           osException(i, &quot;flush&quot;, t, ioExceptions);         }       }       mayThrow(ioExceptions);     }      @Override     public void close() throws IOException {       final List ioExceptions = new ArrayList();       for (int i = opSet.nextSetBit(0);            i &gt;= 0;            i = opSet.nextSetBit(i + 1)) {         try {           outputStreams[i].close();         } catch (Throwable t) {           osException(i, &quot;close&quot;, t, ioExceptions);         }       }       if (opSet.cardinality() &lt; minReplication) {         cleanupAllTmpFiles();         throw new IOException(&quot;Failed to sufficiently replicate: min=&quot;             + minReplication + &quot; actual=&quot; + opSet.cardinality());       } else {         commit();       }     }      private void cleanupAllTmpFiles() throws IOException {       for (int i = 0; i &lt; outputStreams.length; i++) {         try {           nodes[i].fs.delete(tmpPath);         } catch (Throwable t) {           processThrowable(nodes[i], &quot;delete&quot;, t, null, tmpPath);         }       }     }      private void commit() throws IOException {       final List ioExceptions = new ArrayList();       for (int i = opSet.nextSetBit(0);            i &gt;= 0;            i = opSet.nextSetBit(i + 1)) {         final NflyNode nflyNode = nodes[i];         try {           if (useOverwrite) {             nflyNode.fs.delete(nflyPath);           }           nflyNode.fs.rename(tmpPath, nflyPath);          } catch (Throwable t) {           osException(i, &quot;commit&quot;, t, ioExceptions);         }       }        if (opSet.cardinality() &lt; minReplication) {         // cleanup should be done outside. If rename failed, it's unlikely that         // delete will work either. It's the same kind of metadata-only op         //         throw MultipleIOException.createIOException(ioExceptions);       }        // best effort to have a consistent timestamp       final long commitTime = System.currentTimeMillis();       for (int i = opSet.nextSetBit(0);           i &gt;= 0;           i = opSet.nextSetBit(i + 1)) {         try {           nodes[i].fs.setTimes(nflyPath, commitTime, commitTime);         } catch (Throwable t) {           LOG.info(&quot;Failed to set timestamp: &quot; + nodes[i] + &quot; &quot; + nflyPath);         }       }     }   }    private Path getNflyTmpPath(Path f) {     return new Path(f.getParent(), NFLY_TMP_PREFIX + f.getName());   }    /**    * // TODO    * Some file status implementations have expensive deserialization or metadata    * retrieval. This probably does not go beyond RawLocalFileSystem. Wrapping    * the the real file status to preserve this behavior. Otherwise, calling    * realStatus getters in constructor defeats this design.    */   static final class NflyStatus extends FileStatus {     private static final long serialVersionUID = 0x21f276d8;      private final FileStatus realStatus;     private final String strippedRoot;      private NflyStatus(ChRootedFileSystem realFs, FileStatus realStatus)         throws IOException {       this.realStatus = realStatus;       this.strippedRoot = realFs.stripOutRoot(realStatus.getPath());     }      String stripRoot() throws IOException {       return strippedRoot;     }      @Override     public long getLen() {       return realStatus.getLen();     }      @Override     public boolean isFile() {       return realStatus.isFile();     }      @Override     public boolean isDirectory() {       return realStatus.isDirectory();     }      @Override     public boolean isSymlink() {       return realStatus.isSymlink();     }      @Override     public long getBlockSize() {       return realStatus.getBlockSize();     }      @Override     public short getReplication() {       return realStatus.getReplication();     }      @Override     public long getModificationTime() {       return realStatus.getModificationTime();     }      @Override     public long getAccessTime() {       return realStatus.getAccessTime();     }      @Override     public FsPermission getPermission() {       return realStatus.getPermission();     }      @Override     public String getOwner() {       return realStatus.getOwner();     }      @Override     public String getGroup() {       return realStatus.getGroup();     }      @Override     public Path getPath() {       return realStatus.getPath();     }      @Override     public void setPath(Path p) {       realStatus.setPath(p);     }      @Override     public Path getSymlink() throws IOException {       return realStatus.getSymlink();     }      @Override     public void setSymlink(Path p) {       realStatus.setSymlink(p);     }      @Override     public boolean equals(Object o) {       return realStatus.equals(o);     }      @Override     public int hashCode() {       return realStatus.hashCode();     }      @Override     public String toString() {       return realStatus.toString();     }   }    @Override   public URI getUri() {     return nflyURI;   }    /**    * Category: READ.    *    * @param f the file name to open    * @param bufferSize the size of the buffer to be used.    * @return input stream according to nfly flags (closest, most recent)    * @throws IOException    * @throws FileNotFoundException iff all destinations generate this exception    */   @Override   public FSDataInputStream open(Path f, int bufferSize) throws IOException {     // TODO proxy stream for reads     final List ioExceptions =         new ArrayList(nodes.length);     int numNotFounds = 0;     final MRNflyNode[] mrNodes = workSet();      // naively iterate until one can be opened     //     for (final MRNflyNode nflyNode : mrNodes) {       try {         if (nflyFlags.contains(NflyKey.repairOnRead)             || nflyFlags.contains(NflyKey.readMostRecent)) {           // calling file status to avoid pulling bytes prematurely           nflyNode.updateFileStatus(f);         } else {           return nflyNode.getFs().open(f, bufferSize);         }       } catch (FileNotFoundException fnfe) {         nflyNode.status = notFoundStatus(f);         numNotFounds++;         processThrowable(nflyNode, &quot;open&quot;, fnfe, ioExceptions, f);       } catch (Throwable t) {         processThrowable(nflyNode, &quot;open&quot;, t, ioExceptions, f);       }     }      if (nflyFlags.contains(NflyKey.readMostRecent)) {       // sort from most recent to least recent       Arrays.sort(mrNodes);     }      final FSDataInputStream fsdisAfterRepair = repairAndOpen(mrNodes, f,         bufferSize);      if (fsdisAfterRepair != null) {       return fsdisAfterRepair;     }      mayThrowFileNotFound(ioExceptions, numNotFounds);     throw MultipleIOException.createIOException(ioExceptions);   }    private static FileStatus notFoundStatus(Path f) {     return new FileStatus(-1, false, 0, 0, 0, f);   }    /**    * Iterate all available nodes in the proximity order to attempt repair of all    * FileNotFound nodes.    *    * @param mrNodes work set copy of nodes    * @param f path to repair and open    * @param bufferSize buffer size for read RPC    * @return the closest/most recent replica stream AFTER repair    */   private FSDataInputStream repairAndOpen(MRNflyNode[] mrNodes, Path f,       int bufferSize) {     long maxMtime = 0L;     for (final MRNflyNode srcNode : mrNodes) {       if (srcNode.status == null  // not available           || srcNode.status.getLen() &lt; 0L) { // not found         continue; // not available       }       if (srcNode.status.getModificationTime() &gt; maxMtime) {         maxMtime = srcNode.status.getModificationTime();       }        // attempt to repair all notFound nodes with srcNode       //       for (final MRNflyNode dstNode : mrNodes) {         if (dstNode.status == null // not available             || srcNode.compareTo(dstNode) == 0) { // same mtime           continue;         }          try {           // status is absolute from the underlying mount, making it chrooted           //           final FileStatus srcStatus = srcNode.cloneStatus();           srcStatus.setPath(f);           final Path tmpPath = getNflyTmpPath(f);           FileUtil.copy(srcNode.getFs(), srcStatus, dstNode.getFs(), tmpPath,               false,                // don't delete               true,                 // overwrite               getConf());           dstNode.getFs().delete(f, false);           if (dstNode.getFs().rename(tmpPath, f)) {             try {               dstNode.getFs().setTimes(f, srcNode.status.getModificationTime(),                   srcNode.status.getAccessTime());             } finally {               // save getFileStatus rpc               srcStatus.setPath(dstNode.getFs().makeQualified(f));               dstNode.status = srcStatus;             }           }         } catch (IOException ioe) {           // can blame the source by statusSet.clear(ai), however, it would           // cost an extra RPC, so just rely on the loop below that will attempt           // an open anyhow           //           LOG.info(f + &quot; &quot; + srcNode + &quot;-&gt;&quot; + dstNode + &quot;: Failed to repair&quot;,                 ioe);         }       }     }      // Since Java7, QuickSort is used instead of MergeSort.     // QuickSort may not be stable and thus the equal most recent nodes, may no     // longer appear in the NetworkTopology order.     //     if (maxMtime &gt; 0) {       final List mrList = new ArrayList();       for (final MRNflyNode openNode : mrNodes) {         if (openNode.status != null &amp;&amp; openNode.status.getLen() &gt;= 0L) {           if (openNode.status.getModificationTime() == maxMtime) {             mrList.add(openNode);           }         }       }       // assert mrList.size &gt; 0       final MRNflyNode[] readNodes = mrList.toArray(new MRNflyNode[0]);       topology.sortByDistance(myNode, readNodes, readNodes.length);       for (final MRNflyNode rNode : readNodes) {         try {           return rNode.getFs().open(f, bufferSize);         } catch (IOException e) {           LOG.info(f + &quot;: Failed to open at &quot; + rNode.getFs().getUri());         }       }     }     return null;   }    private void mayThrowFileNotFound(List ioExceptions,       int numNotFounds) throws FileNotFoundException {     if (numNotFounds == nodes.length) {       throw (FileNotFoundException)ioExceptions.get(nodes.length - 1);     }   }    // WRITE   @Override   public FSDataOutputStream create(Path f, FsPermission permission,       boolean overwrite, int bufferSize, short replication, long blockSize,       Progressable progress) throws IOException {     return new FSDataOutputStream(new NflyOutputStream(f, permission, overwrite,         bufferSize, replication, blockSize, progress), statistics);   }    // WRITE   @Override   public FSDataOutputStream append(Path f, int bufferSize,       Progressable progress) throws IOException {     return null;   }    // WRITE   @Override   public boolean rename(Path src, Path dst) throws IOException {     final List ioExceptions = new ArrayList();     int numNotFounds = 0;     boolean succ = true;     for (final NflyNode nflyNode : nodes) {       try {         succ &amp;= nflyNode.fs.rename(src, dst);       } catch (FileNotFoundException fnfe) {         numNotFounds++;         processThrowable(nflyNode, &quot;rename&quot;, fnfe, ioExceptions, src, dst);       } catch (Throwable t) {         processThrowable(nflyNode, &quot;rename&quot;, t, ioExceptions, src, dst);         succ = false;       }     }      mayThrowFileNotFound(ioExceptions, numNotFounds);      // if all destinations threw exceptions throw, otherwise return     //     if (ioExceptions.size() == nodes.length) {       throw MultipleIOException.createIOException(ioExceptions);     }      return succ;   }    // WRITE   @Override   public boolean delete(Path f, boolean recursive) throws IOException {     final List ioExceptions = new ArrayList();     int numNotFounds = 0;     boolean succ = true;     for (final NflyNode nflyNode : nodes) {       try {         succ &amp;= nflyNode.fs.delete(f);       } catch (FileNotFoundException fnfe) {         numNotFounds++;         processThrowable(nflyNode, &quot;delete&quot;, fnfe, ioExceptions, f);       } catch (Throwable t) {         processThrowable(nflyNode, &quot;delete&quot;, t, ioExceptions, f);         succ = false;       }     }     mayThrowFileNotFound(ioExceptions, numNotFounds);      // if all destinations threw exceptions throw, otherwise return     //     if (ioExceptions.size() == nodes.length) {       throw MultipleIOException.createIOException(ioExceptions);     }      return succ;   }     /**    * Returns the closest non-failing destination's result.    *    * @param f given path    * @return array of file statuses according to nfly modes    * @throws FileNotFoundException    * @throws IOException    */   @Override   public FileStatus[] listStatus(Path f) throws FileNotFoundException,       IOException {     final List ioExceptions =         new ArrayList(nodes.length);      final MRNflyNode[] mrNodes = workSet();     if (nflyFlags.contains(NflyKey.readMostRecent)) {       int numNotFounds = 0;       for (final MRNflyNode nflyNode : mrNodes) {         try {           nflyNode.updateFileStatus(f);         } catch (FileNotFoundException fnfe) {           numNotFounds++;           processThrowable(nflyNode, &quot;listStatus&quot;, fnfe, ioExceptions, f);         } catch (Throwable t) {           processThrowable(nflyNode, &quot;listStatus&quot;, t, ioExceptions, f);         }       }       mayThrowFileNotFound(ioExceptions, numNotFounds);       Arrays.sort(mrNodes);     }      int numNotFounds = 0;     for (final MRNflyNode nflyNode : mrNodes) {       try {         final FileStatus[] realStats = nflyNode.getFs().listStatus(f);         final FileStatus[] nflyStats = new FileStatus[realStats.length];         for (int i = 0; i &lt; realStats.length; i++) {           nflyStats[i] = new NflyStatus(nflyNode.getFs(), realStats[i]);         }         return nflyStats;       } catch (FileNotFoundException fnfe) {         numNotFounds++;         processThrowable(nflyNode, &quot;listStatus&quot;, fnfe, ioExceptions, f);       } catch (Throwable t) {         processThrowable(nflyNode, &quot;listStatus&quot;, t, ioExceptions, f);       }     }     mayThrowFileNotFound(ioExceptions, numNotFounds);     throw MultipleIOException.createIOException(ioExceptions);   }    @Override   public RemoteIterator listLocatedStatus(Path f)       throws FileNotFoundException, IOException {     // TODO important for splits     return super.listLocatedStatus(f);   }    @Override   public void setWorkingDirectory(Path newDir) {     for (final NflyNode nflyNode : nodes) {       nflyNode.fs.setWorkingDirectory(newDir);     }   }    @Override   public Path getWorkingDirectory() {     return nodes[0].fs.getWorkingDirectory(); // 0 is as good as any   }    @Override   public boolean mkdirs(Path f, FsPermission permission) throws IOException {     boolean succ = true;     for (final NflyNode nflyNode : nodes) {       succ &amp;= nflyNode.fs.mkdirs(f, permission);     }     return succ;   }    @Override   public FileStatus getFileStatus(Path f) throws IOException {     // TODO proxy stream for reads     final List ioExceptions =         new ArrayList(nodes.length);     int numNotFounds = 0;     final MRNflyNode[] mrNodes = workSet();      long maxMtime = Long.MIN_VALUE;     int maxMtimeIdx = Integer.MIN_VALUE;      // naively iterate until one can be returned     //     for (int i = 0; i &lt; mrNodes.length; i++) {       MRNflyNode nflyNode = mrNodes[i];       try {         nflyNode.updateFileStatus(f);         if (nflyFlags.contains(NflyKey.readMostRecent)) {           final long nflyTime = nflyNode.status.getModificationTime();           if (nflyTime &gt; maxMtime) {             maxMtime = nflyTime;             maxMtimeIdx = i;           }         } else {           return nflyNode.nflyStatus();         }       } catch (FileNotFoundException fnfe) {         numNotFounds++;         processThrowable(nflyNode, &quot;getFileStatus&quot;, fnfe, ioExceptions, f);       } catch (Throwable t) {         processThrowable(nflyNode, &quot;getFileStatus&quot;, t, ioExceptions, f);       }     }      if (maxMtimeIdx &gt;= 0) {       return mrNodes[maxMtimeIdx].nflyStatus();     }      mayThrowFileNotFound(ioExceptions, numNotFounds);     throw MultipleIOException.createIOException(ioExceptions);   }    private static void processThrowable(NflyNode nflyNode, String op,       Throwable t, List ioExceptions,       Path... f) {     final String errMsg = Arrays.toString(f)         + &quot;: failed to &quot; + op + &quot; &quot; + nflyNode.fs.getUri();     final IOException ioex;     if (t instanceof FileNotFoundException) {       ioex = new FileNotFoundException(errMsg);       ioex.initCause(t);     } else {       ioex = new IOException(errMsg, t);     }      if (ioExceptions != null) {       ioExceptions.add(ioex);     }   }    /**    * Initializes an nfly mountpoint in viewfs.    *    * @param uris destinations to replicate writes to    * @param conf file system configuration    * @param settings comma-separated list of k=v pairs.    * @return an Nfly filesystem    * @throws IOException    */   static FileSystem createFileSystem(URI[] uris, Configuration conf,       String settings) throws IOException {     // assert settings != null     int minRepl = DEFAULT_MIN_REPLICATION;     EnumSet nflyFlags = EnumSet.noneOf(NflyKey.class);     final String[] kvPairs = StringUtils.split(settings);     for (String kv : kvPairs) {       final String[] kvPair = StringUtils.split(kv, '=');       if (kvPair.length != 2) {         throw new IllegalArgumentException(kv);       }       NflyKey nflyKey = NflyKey.valueOf(kvPair[0]);       switch (nflyKey) {       case minReplication:         minRepl = Integer.parseInt(kvPair[1]);         break;       case repairOnRead:       case readMostRecent:         if (Boolean.valueOf(kvPair[1])) {           nflyFlags.add(nflyKey);         }         break;       default:         throw new IllegalArgumentException(nflyKey + &quot;: Infeasible&quot;);       }     }     return new NflyFSystem(uris, conf, minRepl, nflyFlags);   } }</td>
    <td align="left">blob</td>
    <td align="left">1. long method, 2. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9857</td>
    <td align="left">https://github.com/apache/hadoop/blob/128dd91e10080bdcbcd7d555fa3c4105e55a6b51/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/NflyFSystem.java/#L60-L951</td>
    <td align="right">1</td>
    <td align="right">1105</td>
    <td align="right">9857</td>
  </tr>
  <tr valign="top">
    <td align="right">1110</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class RabbitGatewaySupport implements InitializingBean {  	/** Logger available to subclasses. */ 	protected final Log logger = LogFactory.getLog(getClass()); // NOSONAR  	private RabbitOperations rabbitOperations;  	/** 	 * Set the Rabbit connection factory to be used by the gateway. 	 * Will automatically create a RabbitTemplate for the given ConnectionFactory. 	 * @param connectionFactory The connection factory. 	 * @see #createRabbitTemplate 	 * @see #setConnectionFactory(org.springframework.amqp.rabbit.connection.ConnectionFactory) 	 */ 	public final void setConnectionFactory(ConnectionFactory connectionFactory) { 		this.rabbitOperations = createRabbitTemplate(connectionFactory); 	}  	/** 	 * Create a RabbitTemplate for the given ConnectionFactory. 	 * Only invoked if populating the gateway with a ConnectionFactory reference. 	 * 	 * @param connectionFactory the Rabbit ConnectionFactory to create a RabbitTemplate for 	 * @return the new RabbitTemplate instance 	 * @see #setConnectionFactory 	 */ 	protected RabbitTemplate createRabbitTemplate(ConnectionFactory connectionFactory) { 		return new RabbitTemplate(connectionFactory); 	}  	/** 	 * @return The Rabbit ConnectionFactory used by the gateway. 	 */ 	@Nullable 	public final ConnectionFactory getConnectionFactory() { 		return (this.rabbitOperations != null ? this.rabbitOperations.getConnectionFactory() : null); 	}  	/** 	 * Set the {@link RabbitOperations} for the gateway. 	 * @param rabbitOperations The Rabbit operations. 	 * @see #setConnectionFactory(org.springframework.amqp.rabbit.connection.ConnectionFactory) 	 */ 	public final void setRabbitOperations(RabbitOperations rabbitOperations) { 		this.rabbitOperations = rabbitOperations; 	}  	/** 	 * @return The {@link RabbitOperations} for the gateway. 	 */ 	public final RabbitOperations getRabbitOperations() { 		return this.rabbitOperations; 	}  	@Override 	public final void afterPropertiesSet() throws IllegalArgumentException, BeanInitializationException { 		if (this.rabbitOperations == null) { 			throw new IllegalArgumentException(&quot;'connectionFactory' or 'rabbitTemplate' is required&quot;); 		} 		try { 			initGateway(); 		} 		catch (Exception ex) { 			throw new BeanInitializationException(&quot;Initialization of Rabbit gateway failed: &quot; + ex.getMessage(), ex); 		} 	}  	/** 	 * Subclasses can override this for custom initialization behavior. 	 * Gets called after population of this instance's bean properties. 	 */ 	protected void initGateway() { 	}  }</td>
    <td align="left">blob</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9884</td>
    <td align="left">https://github.com/spring-projects/spring-amqp/blob/1614a4b0532b83e29b2a2fdb8dac102576b8aa51/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/RabbitGatewaySupport.java/#L43-L117</td>
    <td align="right">1</td>
    <td align="right">1110</td>
    <td align="right">9884</td>
  </tr>
  <tr valign="top">
    <td align="right">1143</td>
    <td align="left">&nbsp;{    &quot;message&quot;: &quot;YES I found bad smells&quot;,    &quot;bad smells&quot;: [      &quot;Blob&quot;,      &quot;Long Method&quot;   ]  }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class AbstractControllerService extends AbstractConfigurableComponent implements ControllerService {      private String identifier;     private ControllerServiceLookup serviceLookup;     private ComponentLog logger;     private StateManager stateManager;     private volatile ConfigurationContext configurationContext;     private volatile boolean enabled = false;      @Override     public final void initialize(final ControllerServiceInitializationContext context) throws InitializationException {         this.identifier = context.getIdentifier();         serviceLookup = context.getControllerServiceLookup();         logger = context.getLogger();         stateManager = context.getStateManager();         init(context);     }      @Override     public String getIdentifier() {         return identifier;     }      /**      * @return the {@link ControllerServiceLookup} that was passed to the      * {@link #init(ControllerServiceInitializationContext)} method      */     protected final ControllerServiceLookup getControllerServiceLookup() {         return serviceLookup;     }      /**      * Provides a mechanism by which subclasses can perform initialization of      * the Controller Service before it is scheduled to be run      *      * @param config of initialization context      * @throws InitializationException if unable to init      */     protected void init(final ControllerServiceInitializationContext config) throws InitializationException {     }      @OnEnabled     public final void enabled() {         this.enabled = true;     }      @OnDisabled     public final void disabled() {         this.enabled = false;     }      public boolean isEnabled() {         return this.enabled;     }      /**      * @return the logger that has been provided to the component by the      * framework in its initialize method      */     protected ComponentLog getLogger() {         return logger;     }      /**      * @return the StateManager that can be used to store and retrieve state for this Controller Service      */     protected StateManager getStateManager() {         return stateManager;     }      @OnEnabled     public final void abstractStoreConfigContext(final ConfigurationContext configContext) {         this.configurationContext = configContext;     }      @OnDisabled     public final void abstractClearConfigContext() {         this.configurationContext = null;     }      protected ConfigurationContext getConfigurationContext() {         final ConfigurationContext context = this.configurationContext;         if (context == null) {             throw new IllegalStateException(&quot;No Configuration Context exists&quot;);         }          return configurationContext;     }      protected PropertyValue getProperty(final PropertyDescriptor descriptor) {         return getConfigurationContext().getProperty(descriptor);     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10101</td>
    <td align="left">https://github.com/apache/nifi/blob/c8eff590efa3babcda0b755009224dcac168708b/nifi-api/src/main/java/org/apache/nifi/controller/AbstractControllerService.java/#L28-L120</td>
    <td align="right">1</td>
    <td align="right">1143</td>
    <td align="right">10101</td>
  </tr>
  <tr valign="top">
    <td align="right">1161</td>
    <td align="left">{&quot;response&quot;: &quot;YES, I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;1. Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SysInfo implements Serializable {      static final long serialVersionUID = -3096346807579L;      public int numCores;     public long maxMemory;      public SysInfo(int nc, long mm) {         numCores = nc;         maxMemory = mm;     } }</td>
    <td align="left">blob</td>
    <td align="left">1. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10165</td>
    <td align="left">https://github.com/google/error-prone-javac/blob/a53d069bbdb2c60232ed3811c19b65e41c3e60e0/src/jdk.compiler/share/classes/com/sun/tools/sjavac/server/SysInfo.java/#L45-L56</td>
    <td align="right">1</td>
    <td align="right">1161</td>
    <td align="right">10165</td>
  </tr>
  <tr valign="top">
    <td align="right">1192</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Blob&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ZooInspectorPanel extends JPanel implements         NodeViewersChangeListener {     private final IconResource iconResource;     private final Toolbar toolbar;     private final ZooInspectorNodeViewersPanel nodeViewersPanel;     private final ZooInspectorTreeViewer treeViewer;     private final ZooInspectorManager zooInspectorManager;      private final List listeners = new ArrayList();     {         listeners.add(this);     }      /**      * @param zooInspectorManager      *            - the {@link ZooInspectorManager} for the application      */     public ZooInspectorPanel(final ZooInspectorManager zooInspectorManager, final IconResource iconResource) {         this.zooInspectorManager = zooInspectorManager;         this.iconResource = iconResource;         toolbar = new Toolbar(iconResource);         final List nodeViewers = new ArrayList();         try {             List defaultNodeViewersClassNames = this.zooInspectorManager                     .getDefaultNodeViewerConfiguration();             for (String className : defaultNodeViewersClassNames) {                 nodeViewers.add((ZooInspectorNodeViewer) Class.forName(                         className).newInstance());             }         } catch (Exception ex) {             LoggerFactory.getLogger().error(                     &quot;Error loading default node viewers.&quot;, ex);             JOptionPane.showMessageDialog(ZooInspectorPanel.this,                     &quot;Error loading default node viewers: &quot; + ex.getMessage(),                     &quot;Error&quot;, JOptionPane.ERROR_MESSAGE);         }         nodeViewersPanel = new ZooInspectorNodeViewersPanel(                 zooInspectorManager, nodeViewers);         treeViewer = new ZooInspectorTreeViewer(zooInspectorManager,                 nodeViewersPanel, iconResource);         this.setLayout(new BorderLayout());                  toolbar.addActionListener(Toolbar.Button.connect, new ActionListener() {             public void actionPerformed(ActionEvent e) {                 ZooInspectorConnectionPropertiesDialog zicpd = new ZooInspectorConnectionPropertiesDialog(                         zooInspectorManager.getLastConnectionProps(),                         zooInspectorManager.getConnectionPropertiesTemplate(),                         ZooInspectorPanel.this);                 zicpd.setVisible(true);             }         });         toolbar.addActionListener(Toolbar.Button.disconnect, new ActionListener() {             public void actionPerformed(ActionEvent e) {                 disconnect();             }         });         toolbar.addActionListener(Toolbar.Button.refresh, new ActionListener() {             public void actionPerformed(ActionEvent e) {                 treeViewer.refreshView();             }         });          toolbar.addActionListener(Toolbar.Button.addNode,                     new AddNodeAction(this, treeViewer, zooInspectorManager));         toolbar.addActionListener(Toolbar.Button.deleteNode,                     new DeleteNodeAction(this, treeViewer, zooInspectorManager));          toolbar.addActionListener(Toolbar.Button.nodeViewers, new ActionListener() {              public void actionPerformed(ActionEvent e) {                 ZooInspectorNodeViewersDialog nvd = new ZooInspectorNodeViewersDialog(                         JOptionPane.getRootFrame(), nodeViewers, listeners,                         zooInspectorManager, iconResource);                 nvd.setVisible(true);             }         });         toolbar.addActionListener(Toolbar.Button.about, new ActionListener() {             public void actionPerformed(ActionEvent e) {                 ZooInspectorAboutDialog zicpd = new ZooInspectorAboutDialog(                         JOptionPane.getRootFrame(), iconResource);                 zicpd.setVisible(true);             }         });         JScrollPane treeScroller = new JScrollPane(treeViewer);         JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,                 treeScroller, nodeViewersPanel);         splitPane.setResizeWeight(0.25);         this.add(splitPane, BorderLayout.CENTER);         this.add(toolbar.getJToolBar(), BorderLayout.NORTH);     }      /**      * @param connectionProps      *            the {@link Properties} for connecting to the zookeeper      *            instance      */     public void connect(final Properties connectionProps) {         SwingWorker worker = new SwingWorker() {              @Override             protected Boolean doInBackground() throws Exception {                 zooInspectorManager.setLastConnectionProps(connectionProps);                 return zooInspectorManager.connect(connectionProps);             }              @Override             protected void done() {                 try {                     if (get()) {                         treeViewer.refreshView();                         toolbar.toggleButtons(true);                     } else {                         JOptionPane.showMessageDialog(ZooInspectorPanel.this,                                 &quot;Unable to connect to zookeeper&quot;, &quot;Error&quot;,                                 JOptionPane.ERROR_MESSAGE);                     }                 } catch (InterruptedException e) {                     LoggerFactory                             .getLogger()                             .error(                                     &quot;Error occurred while connecting to ZooKeeper server&quot;,                                     e);                 } catch (ExecutionException e) {                     LoggerFactory                             .getLogger()                             .error(                                     &quot;Error occurred while connecting to ZooKeeper server&quot;,                                     e);                 }             }          };         worker.execute();     }      /** 	 *  	 */     public void disconnect() {         disconnect(false);     }      /**      * @param wait      *            - set this to true if the method should only return once the      *            application has successfully disconnected      */     public void disconnect(boolean wait) {         SwingWorker worker = new SwingWorker() {              @Override             protected Boolean doInBackground() throws Exception {                 return ZooInspectorPanel.this.zooInspectorManager.disconnect();             }              @Override             protected void done() {                 try {                     if (get()) {                         treeViewer.clearView();                         toolbar.toggleButtons(false);                     }                 } catch (InterruptedException e) {                     LoggerFactory                             .getLogger()                             .error(                                     &quot;Error occurred while disconnecting from ZooKeeper server&quot;,                                     e);                 } catch (ExecutionException e) {                     LoggerFactory                             .getLogger()                             .error(                                     &quot;Error occurred while disconnecting from ZooKeeper server&quot;,                                     e);                 }             }          };         worker.execute();         if (wait) {             while (!worker.isDone()) {                 try {                     Thread.sleep(100);                 } catch (InterruptedException e) {                     LoggerFactory                             .getLogger()                             .error(                                     &quot;Error occurred while disconnecting from ZooKeeper server&quot;,                                     e);                 }             }         }     }      /*      * (non-Javadoc)      *       * @seeorg.apache.zookeeper.inspector.gui.NodeViewersChangeListener#      * nodeViewersChanged(java.util.List)      */     public void nodeViewersChanged(List newViewers) {         this.nodeViewersPanel.setNodeViewers(newViewers);     }      /**      * @param connectionProps      * @throws IOException      */     public void setdefaultConnectionProps(Properties connectionProps)             throws IOException {         this.zooInspectorManager.saveDefaultConnectionFile(connectionProps);     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10257</td>
    <td align="left">https://github.com/apache/zookeeper/blob/07c3aaf3d723fb3144c0aedc0c2b655325df70e9/zookeeper-contrib/zookeeper-contrib-zooinspector/src/main/java/org/apache/zookeeper/inspector/gui/ZooInspectorPanel.java/#L46-L258</td>
    <td align="right">1</td>
    <td align="right">1192</td>
    <td align="right">10257</td>
  </tr>
  <tr valign="top">
    <td align="right">1202</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Blob&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class WSS4JInInterceptorFactory {      private Properties properties;      public Properties getProperties() {         return properties;     }      public void setProperties(Properties properties) {         this.properties = properties;     }      public WSS4JInInterceptor create() {         final Map map = new HashMap();         for (Map.Entry entry : properties.entrySet()) {             map.put(entry.getKey().toString(), entry.getValue());         }         properties.clear();         return new WSS4JInInterceptor(map);     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10285</td>
    <td align="left">https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/server/openejb-cxf/src/main/java/org/apache/openejb/server/cxf/config/WSS4JInInterceptorFactory.java/#L28-L48</td>
    <td align="right">1</td>
    <td align="right">1202</td>
    <td align="right">10285</td>
  </tr>
  <tr valign="top">
    <td align="right">1261</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Experimental class ValueEncoder {    private final ValueSerializer valueSerializer;    public ValueEncoder(ValueSerializer valueSerializer) {     this.valueSerializer = valueSerializer;   }    /**    * Encodes a Java object into a Protobuf encoded value.    *    * @param unencodedValue Java object to encode.    * @return Encoded value of the Java object.    */   BasicTypes.EncodedValue encodeValue(Object unencodedValue) {     BasicTypes.EncodedValue.Builder builder = BasicTypes.EncodedValue.newBuilder();      if (valueSerializer.supportsPrimitives()) {       ByteString customBytes = customSerialize(unencodedValue);       return builder.setCustomObjectResult(customBytes).build();     }      if (Objects.isNull(unencodedValue)) {       builder.setNullResult(NullValue.NULL_VALUE);     } else if (Integer.class.equals(unencodedValue.getClass())) {       builder.setIntResult((Integer) unencodedValue);     } else if (Long.class.equals(unencodedValue.getClass())) {       builder.setLongResult((Long) unencodedValue);     } else if (Short.class.equals(unencodedValue.getClass())) {       builder.setShortResult((Short) unencodedValue);     } else if (Byte.class.equals(unencodedValue.getClass())) {       builder.setByteResult((Byte) unencodedValue);     } else if (Double.class.equals(unencodedValue.getClass())) {       builder.setDoubleResult((Double) unencodedValue);     } else if (Float.class.equals(unencodedValue.getClass())) {       builder.setFloatResult((Float) unencodedValue);     } else if (byte[].class.equals(unencodedValue.getClass())) {       builder.setBinaryResult(ByteString.copyFrom((byte[]) unencodedValue));     } else if (Boolean.class.equals(unencodedValue.getClass())) {       builder.setBooleanResult((Boolean) unencodedValue);     } else if (String.class.equals(unencodedValue.getClass())) {       builder.setStringResult((String) unencodedValue);     } else if (JSONWrapper.class.isAssignableFrom(unencodedValue.getClass())) {       builder.setJsonObjectResult(((JSONWrapper) unencodedValue).getJSON());     } else {       ByteString customBytes = customSerialize(unencodedValue);       if (customBytes != null) {         builder.setCustomObjectResult(customBytes);       } else {         throw new IllegalStateException(&quot;We don't know how to handle an object of type &quot;             + unencodedValue.getClass() + &quot;: &quot; + unencodedValue);       }     }      return builder.build();   }    private ByteString customSerialize(Object unencodedValue) {     try {       ByteString customBytes = valueSerializer.serialize(unencodedValue);       return customBytes;     } catch (IOException e) {       throw new IllegalStateException(e);     }   }    /**    * Decodes a Protobuf encoded value into a Java object.    *    * @param encodedValue Encoded value to decode.    * @return Decoded Java object.    */   Object decodeValue(BasicTypes.EncodedValue encodedValue) {     switch (encodedValue.getValueCase()) {       case BINARYRESULT:         return encodedValue.getBinaryResult().toByteArray();       case BOOLEANRESULT:         return encodedValue.getBooleanResult();       case BYTERESULT:         return (byte) encodedValue.getByteResult();       case DOUBLERESULT:         return encodedValue.getDoubleResult();       case FLOATRESULT:         return encodedValue.getFloatResult();       case INTRESULT:         return encodedValue.getIntResult();       case LONGRESULT:         return encodedValue.getLongResult();       case SHORTRESULT:         return (short) encodedValue.getShortResult();       case STRINGRESULT:         return encodedValue.getStringResult();       case JSONOBJECTRESULT:         return JSONWrapper.wrapJSON(encodedValue.getJsonObjectResult());       case NULLRESULT:         return null;       case CUSTOMOBJECTRESULT:         try {           return valueSerializer.deserialize(encodedValue.getCustomObjectResult());         } catch (IOException | ClassNotFoundException e) {           throw new IllegalStateException(e);         }       default:         throw new IllegalStateException(             &quot;Can't decode a value of type &quot; + encodedValue.getValueCase() + &quot;: &quot; + encodedValue);     }   }    /**    * Encodes a Java object key and a Java object value into a Protobuf encoded entry.    *    * @param unencodedKey Java object key to encode.    * @param unencodedValue Java object value to encode.    * @return Encoded entry of the Java object key and value.    */   BasicTypes.Entry encodeEntry(Object unencodedKey, Object unencodedValue) {     if (unencodedValue == null) {       return BasicTypes.Entry.newBuilder().setKey(encodeValue(unencodedKey)).build();     }     return BasicTypes.Entry.newBuilder().setKey(encodeValue(unencodedKey))         .setValue(encodeValue(unencodedValue)).build();   } }</td>
    <td align="left">blob</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10505</td>
    <td align="left">https://github.com/apache/geode/blob/8fd839e8b73e40bd2dfd14f331b587431bd35a66/geode-experimental-driver/src/main/java/org/apache/geode/experimental/driver/ValueEncoder.java/#L32-L155</td>
    <td align="right">1</td>
    <td align="right">1261</td>
    <td align="right">10505</td>
  </tr>
  <tr valign="top">
    <td align="right">1276</td>
    <td align="left">&nbsp;{   &quot;answer&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;1. Blob&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LoopedModelImpl extends MinimalEObjectImpl.Container implements LoopedModel {   /**    * The cached value of the '{@link #getVisibility() Visibility}' attribute list.    *     *     * @see #getVisibility()    * @generated    * @ordered    */   protected EList visibility;    /**    * The cached value of the '{@link #getStatic() Static}' attribute list.    *     *     * @see #getStatic()    * @generated    * @ordered    */   protected EList static_;    /**    * The cached value of the '{@link #getSynchronized() Synchronized}' attribute list.    *     *     * @see #getSynchronized()    * @generated    * @ordered    */   protected EList synchronized_;    /**    * The cached value of the '{@link #getAbstract() Abstract}' attribute list.    *     *     * @see #getAbstract()    * @generated    * @ordered    */   protected EList abstract_;    /**    * The cached value of the '{@link #getFinal() Final}' attribute list.    *     *     * @see #getFinal()    * @generated    * @ordered    */   protected EList final_;    /**    * The default value of the '{@link #getName() Name}' attribute.    *     *     * @see #getName()    * @generated    * @ordered    */   protected static final String NAME_EDEFAULT = null;    /**    * The cached value of the '{@link #getName() Name}' attribute.    *     *     * @see #getName()    * @generated    * @ordered    */   protected String name = NAME_EDEFAULT;    /**    *     *     * @generated    */   protected LoopedModelImpl()   {     super();   }    /**    *     *     * @generated    */   @Override   protected EClass eStaticClass()   {     return UnorderedGroupsTestPackage.Literals.LOOPED_MODEL;   }    /**    *     *     * @generated    */   public EList getVisibility()   {     if (visibility == null)     {       visibility = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY);     }     return visibility;   }    /**    *     *     * @generated    */   public EList getStatic()   {     if (static_ == null)     {       static_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC);     }     return static_;   }    /**    *     *     * @generated    */   public EList getSynchronized()   {     if (synchronized_ == null)     {       synchronized_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED);     }     return synchronized_;   }    /**    *     *     * @generated    */   public EList getAbstract()   {     if (abstract_ == null)     {       abstract_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT);     }     return abstract_;   }    /**    *     *     * @generated    */   public EList getFinal()   {     if (final_ == null)     {       final_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL);     }     return final_;   }    /**    *     *     * @generated    */   public String getName()   {     return name;   }    /**    *     *     * @generated    */   public void setName(String newName)   {     String oldName = name;     name = newName;     if (eNotificationRequired())       eNotify(new ENotificationImpl(this, Notification.SET, UnorderedGroupsTestPackage.LOOPED_MODEL__NAME, oldName, name));   }    /**    *     *     * @generated    */   @Override   public Object eGet(int featureID, boolean resolve, boolean coreType)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         return getVisibility();       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         return getStatic();       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         return getSynchronized();       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         return getAbstract();       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         return getFinal();       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         return getName();     }     return super.eGet(featureID, resolve, coreType);   }    /**    *     *     * @generated    */   @SuppressWarnings(&quot;unchecked&quot;)   @Override   public void eSet(int featureID, Object newValue)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         getVisibility().clear();         getVisibility().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         getStatic().clear();         getStatic().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         getSynchronized().clear();         getSynchronized().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         getAbstract().clear();         getAbstract().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         getFinal().clear();         getFinal().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         setName((String)newValue);         return;     }     super.eSet(featureID, newValue);   }    /**    *     *     * @generated    */   @Override   public void eUnset(int featureID)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         getVisibility().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         getStatic().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         getSynchronized().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         getAbstract().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         getFinal().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         setName(NAME_EDEFAULT);         return;     }     super.eUnset(featureID);   }    /**    *     *     * @generated    */   @Override   public boolean eIsSet(int featureID)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         return visibility != null &amp;&amp; !visibility.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         return static_ != null &amp;&amp; !static_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         return synchronized_ != null &amp;&amp; !synchronized_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         return abstract_ != null &amp;&amp; !abstract_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         return final_ != null &amp;&amp; !final_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         return NAME_EDEFAULT == null ? name != null : !NAME_EDEFAULT.equals(name);     }     return super.eIsSet(featureID);   }    /**    *     *     * @generated    */   @Override   public String toString()   {     if (eIsProxy()) return super.toString();      StringBuffer result = new StringBuffer(super.toString());     result.append(&quot; (visibility: &quot;);     result.append(visibility);     result.append(&quot;, static: &quot;);     result.append(static_);     result.append(&quot;, synchronized: &quot;);     result.append(synchronized_);     result.append(&quot;, abstract: &quot;);     result.append(abstract_);     result.append(&quot;, final: &quot;);     result.append(final_);     result.append(&quot;, name: &quot;);     result.append(name);     result.append(')');     return result.toString();   }  } //LoopedModelImpl</td>
    <td align="left">blob</td>
    <td align="left">1. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10587</td>
    <td align="left">https://github.com/eclipse/xtext-eclipse/blob/0c7546b6aaf3644a77fc68eef9f3da368cbbeabd/org.eclipse.xtext.ui.tests/src-gen/org/eclipse/xtext/ui/tests/editor/contentassist/unorderedGroupsTest/impl/LoopedModelImpl.java/#L40-L375</td>
    <td align="right">1</td>
    <td align="right">1276</td>
    <td align="right">10587</td>
  </tr>
  <tr valign="top">
    <td align="right">1333</td>
    <td align="left">&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells the bad smells are: 1. Blob&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class CurrentCreationalContext {     private final ThreadLocal&gt; creationalContext = new ThreadLocal&gt;();      public CreationalContext get() {         return creationalContext.get();     }      public void set(CreationalContext value) {         creationalContext.set(value);     }      public void remove() {         creationalContext.remove();     } }</td>
    <td align="left">blob</td>
    <td align="left">1. blob </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">&nbsp; </td>
    <td align="left">blob</td>
    <td align="right">0</td>
    <td align="right">10719</td>
    <td align="left">https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/container/openejb-core/src/main/java/org/apache/openejb/cdi/CurrentCreationalContext.java/#L24-L38</td>
    <td align="right">1</td>
    <td align="right">1333</td>
    <td align="right">10719</td>
  </tr>
  <tr valign="top">
    <td align="right">1445</td>
    <td align="left">{&quot;result&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public static class Undertow {  		/** 		 * Maximum size of the HTTP post content. When the value is -1, the default, the 		 * size is unlimited. 		 */ 		private DataSize maxHttpPostSize = DataSize.ofBytes(-1);  		/** 		 * Size of each buffer. The default is derived from the maximum amount of memory 		 * that is available to the JVM. 		 */ 		private DataSize bufferSize;  		/** 		 * Number of I/O threads to create for the worker. The default is derived from the 		 * number of available processors. 		 */ 		private Integer ioThreads;  		/** 		 * Number of worker threads. The default is 8 times the number of I/O threads. 		 */ 		private Integer workerThreads;  		/** 		 * Whether to allocate buffers outside the Java heap. The default is derived from 		 * the maximum amount of memory that is available to the JVM. 		 */ 		private Boolean directBuffers;  		/** 		 * Whether servlet filters should be initialized on startup. 		 */ 		private boolean eagerFilterInit = true;  		private final Accesslog accesslog = new Accesslog();  		public DataSize getMaxHttpPostSize() { 			return this.maxHttpPostSize; 		}  		public void setMaxHttpPostSize(DataSize maxHttpPostSize) { 			this.maxHttpPostSize = maxHttpPostSize; 		}  		public DataSize getBufferSize() { 			return this.bufferSize; 		}  		public void setBufferSize(DataSize bufferSize) { 			this.bufferSize = bufferSize; 		}  		public Integer getIoThreads() { 			return this.ioThreads; 		}  		public void setIoThreads(Integer ioThreads) { 			this.ioThreads = ioThreads; 		}  		public Integer getWorkerThreads() { 			return this.workerThreads; 		}  		public void setWorkerThreads(Integer workerThreads) { 			this.workerThreads = workerThreads; 		}  		public Boolean getDirectBuffers() { 			return this.directBuffers; 		}  		public void setDirectBuffers(Boolean directBuffers) { 			this.directBuffers = directBuffers; 		}  		public boolean isEagerFilterInit() { 			return this.eagerFilterInit; 		}  		public void setEagerFilterInit(boolean eagerFilterInit) { 			this.eagerFilterInit = eagerFilterInit; 		}  		public Accesslog getAccesslog() { 			return this.accesslog; 		}  		/** 		 * Undertow access log properties. 		 */ 		public static class Accesslog {  			/** 			 * Whether to enable the access log. 			 */ 			private boolean enabled = false;  			/** 			 * Format pattern for access logs. 			 */ 			private String pattern = &quot;common&quot;;  			/** 			 * Log file name prefix. 			 */ 			protected String prefix = &quot;access_log.&quot;;  			/** 			 * Log file name suffix. 			 */ 			private String suffix = &quot;log&quot;;  			/** 			 * Undertow access log directory. 			 */ 			private File dir = new File(&quot;logs&quot;);  			/** 			 * Whether to enable access log rotation. 			 */ 			private boolean rotate = true;  			public boolean isEnabled() { 				return this.enabled; 			}  			public void setEnabled(boolean enabled) { 				this.enabled = enabled; 			}  			public String getPattern() { 				return this.pattern; 			}  			public void setPattern(String pattern) { 				this.pattern = pattern; 			}  			public String getPrefix() { 				return this.prefix; 			}  			public void setPrefix(String prefix) { 				this.prefix = prefix; 			}  			public String getSuffix() { 				return this.suffix; 			}  			public void setSuffix(String suffix) { 				this.suffix = suffix; 			}  			public File getDir() { 				return this.dir; 			}  			public void setDir(File dir) { 				this.dir = dir; 			}  			public boolean isRotate() { 				return this.rotate; 			}  			public void setRotate(boolean rotate) { 				this.rotate = rotate; 			}  		}  	}</td>
    <td align="left">blob</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;data class</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10981</td>
    <td align="left">https://github.com/spring-projects/spring-boot/blob/2225b362991f225e3a93f00e160526d2b8abdfb2/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java/#L949-L1124</td>
    <td align="right">1</td>
    <td align="right">1445</td>
    <td align="right">10981</td>
  </tr>
  <tr valign="top">
    <td align="right">1462</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TupleImpl extends IndifferentAccessMap implements Seqable, Indexed, IMeta, Tuple {     private List values;     private int taskId;     private String streamId;     private GeneralTopologyContext context;     private MessageId id;     private IPersistentMap _meta = null;     Long _processSampleStartTime = null;     Long _executeSampleStartTime = null;     long _outAckVal = 0;      public TupleImpl() {     }      public TupleImpl(GeneralTopologyContext context, List values, int taskId, String streamId, MessageId id) {         this.values = values;         this.taskId = taskId;         this.streamId = streamId;         this.id = id;         this.context = context;          /*         String componentId = context.getComponentId(taskId);         Fields schema = context.getComponentOutputFields(componentId, streamId);         if (values.size() != schema.size()) {             throw new IllegalArgumentException(&quot;Tuple created with wrong number of fields. &quot; + &quot;Expected &quot; + schema.size() + &quot; fields but got &quot; + values.size()                     + &quot; fields&quot;);         }*/     }      public TupleImpl(GeneralTopologyContext context, List values, int taskId, String streamId) {         this(context, values, taskId, streamId, MessageId.makeUnanchored());     }      public void setProcessSampleStartTime(long ms) {         _processSampleStartTime = ms;     }      public Long getProcessSampleStartTime() {         return _processSampleStartTime;     }      public void setExecuteSampleStartTime(long ms) {         _executeSampleStartTime = ms;     }      public Long getExecuteSampleStartTime() {         return _executeSampleStartTime;     }      public void updateAckVal(long val) {         _outAckVal = _outAckVal ^ val;     }      public long getAckVal() {         return _outAckVal;     }      public int size() {         return values.size();     }      public int fieldIndex(String field) {         return getFields().fieldIndex(field);     }      public boolean contains(String field) {         return getFields().contains(field);     }      public Object getValue(int i) {         return values.get(i);     }      public String getString(int i) {         return (String) values.get(i);     }      public Integer getInteger(int i) {         return (Integer) values.get(i);     }      public Long getLong(int i) {         return (Long) values.get(i);     }      public Boolean getBoolean(int i) {         return (Boolean) values.get(i);     }      public Short getShort(int i) {         return (Short) values.get(i);     }      public Byte getByte(int i) {         return (Byte) values.get(i);     }      public Double getDouble(int i) {         return (Double) values.get(i);     }      public Float getFloat(int i) {         return (Float) values.get(i);     }      public byte[] getBinary(int i) {         return (byte[]) values.get(i);     }      public Object getValueByField(String field) {         return values.get(fieldIndex(field));     }      public String getStringByField(String field) {         return (String) values.get(fieldIndex(field));     }      public Integer getIntegerByField(String field) {         return (Integer) values.get(fieldIndex(field));     }      public Long getLongByField(String field) {         return (Long) values.get(fieldIndex(field));     }      public Boolean getBooleanByField(String field) {         return (Boolean) values.get(fieldIndex(field));     }      public Short getShortByField(String field) {         return (Short) values.get(fieldIndex(field));     }      public Byte getByteByField(String field) {         return (Byte) values.get(fieldIndex(field));     }      public Double getDoubleByField(String field) {         return (Double) values.get(fieldIndex(field));     }      public Float getFloatByField(String field) {         return (Float) values.get(fieldIndex(field));     }      public byte[] getBinaryByField(String field) {         return (byte[]) values.get(fieldIndex(field));     }      public List getValues() {         return values;     }      public Fields getFields() {         return context.getComponentOutputFields(getSourceComponent(), getSourceStreamId());     }      public List select(Fields selector) {         return getFields().select(selector, values);     }      public GlobalStreamId getSourceGlobalStreamid() {         return new GlobalStreamId(getSourceComponent(), streamId);     }      public String getSourceComponent() {         return context.getComponentId(taskId);     }      public int getSourceTask() {         return taskId;     }      public String getSourceStreamId() {         return streamId;     }      public MessageId getMessageId() {         return id;     }      @Override     public String toString() {         return &quot;source: &quot; + getSourceComponent() + &quot;:&quot; + taskId + &quot;, stream: &quot; + streamId + &quot;, id: &quot; + id.toString() + &quot;, &quot; + values.toString();     }      @Override     public boolean equals(Object other) {         return this == other;     }      @Override     public int hashCode() {         return System.identityHashCode(this);     }      private Keyword makeKeyword(String name) {         return Keyword.intern(Symbol.create(name));     }      /* ILookup */     @Override     public Object valAt(Object o) {         try {             if (o instanceof Keyword) {                 return getValueByField(((Keyword) o).getName());             } else if (o instanceof String) {                 return getValueByField((String) o);             }         } catch (IllegalArgumentException ignored) {         }         return null;     }      /* Seqable */     public ISeq seq() {         if (values.size() &gt; 0) {             return new Seq(getFields().toList(), values, 0);         }         return null;     }      static class Seq extends ASeq implements Counted {         final List fields;         final List values;         final int i;          Seq(List fields, List values, int i) {             this.fields = fields;             this.values = values;             assert i &gt;= 0;             this.i = i;         }          public Seq(IPersistentMap meta, List fields, List values, int i) {             super(meta);             this.fields = fields;             this.values = values;             assert i &gt;= 0;             this.i = i;         }          public Object first() {             return new MapEntry(fields.get(i), values.get(i));         }          public ISeq next() {             if (i + 1 &lt; fields.size()) {                 return new Seq(fields, values, i + 1);             }             return null;         }          public int count() {             assert fields.size() - i &gt;= 0 : &quot;index out of bounds&quot;;             // i being the position in the fields of this seq, the remainder of the seq is the size             return fields.size() - i;         }          public Obj withMeta(IPersistentMap meta) {             return new Seq(meta, fields, values, i);         }     }      /* Indexed */     public Object nth(int i) {         if (i &lt; values.size()) {             return values.get(i);         } else {             return null;         }     }      public Object nth(int i, Object notfound) {         Object ret = nth(i);         if (ret == null)             ret = notfound;         return ret;     }      /* Counted */     public int count() {         return values.size();     }      /* IMeta */     public IPersistentMap meta() {         if (_meta == null) {             _meta = new PersistentArrayMap(new Object[]{makeKeyword(&quot;stream&quot;), getSourceStreamId(),                     makeKeyword(&quot;component&quot;), getSourceComponent(), makeKeyword(&quot;task&quot;), getSourceTask()});         }         return _meta;     }      private PersistentArrayMap toMap() {         Object array[] = new Object[values.size() * 2];         List fields = getFields().toList();         for (int i = 0; i &lt; values.size(); i++) {             array[i * 2] = fields.get(i);             array[(i * 2) + 1] = values.get(i);         }         return new PersistentArrayMap(array);     }      public IPersistentMap getMap() {         if (_map == null) {             setMap(toMap());         }         return _map;     }      public void setTopologyContext(GeneralTopologyContext context) {         this.context = context;     }      public GeneralTopologyContext getTopologyContext() {         return context;     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;data class,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11026</td>
    <td align="left">https://github.com/alibaba/jstorm/blob/5d6cde22dbca7df3d6e6830bf94f98a6639ab559/jstorm-core/src/main/java/backtype/storm/tuple/TupleImpl.java/#L37-L356</td>
    <td align="right">1</td>
    <td align="right">1462</td>
    <td align="right">11026</td>
  </tr>
  <tr valign="top">
    <td align="right">1473</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_smells&quot;: [         &quot;Blob&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MultiSpinnerUI extends SpinnerUI {      /**      * The vector containing the real UIs.  This is populated      * in the call to createUI, and can be obtained by calling      * the getUIs method.  The first element is guaranteed to be the real UI      * obtained from the default look and feel.      */     protected Vector uis = new Vector&lt;&gt;();  //////////////////// // Common UI methods ////////////////////      /**      * Returns the list of UIs associated with this multiplexing UI.  This      * allows processing of the UIs by an application aware of multiplexing      * UIs on components.      *      * @return an array of the UI delegates      */     public ComponentUI[] getUIs() {         return MultiLookAndFeel.uisToArray(uis);     }  //////////////////// // SpinnerUI methods ////////////////////  //////////////////// // ComponentUI methods ////////////////////      /**      * Invokes the contains method on each UI handled by this object.      *      * @return the value obtained from the first UI, which is      * the UI obtained from the default LookAndFeel      */     public boolean contains(JComponent a, int b, int c) {         boolean returnValue =             uis.elementAt(0).contains(a,b,c);         for (int i = 1; i &lt; uis.size(); i++) {             uis.elementAt(i).contains(a,b,c);         }         return returnValue;     }      /**      * Invokes the update method on each UI handled by this object.      */     public void update(Graphics a, JComponent b) {         for (int i = 0; i &lt; uis.size(); i++) {             uis.elementAt(i).update(a,b);         }     }      /**      * Returns a multiplexing UI instance if any of the auxiliary      * LookAndFeels supports this UI.  Otherwise, just returns the      * UI object obtained from the default LookAndFeel.      *      * @param  a the component to create the UI for      * @return the UI delegate created      */     public static ComponentUI createUI(JComponent a) {         MultiSpinnerUI mui = new MultiSpinnerUI();         return MultiLookAndFeel.createUIs(mui, mui.uis, a);     }      /**      * Invokes the installUI method on each UI handled by this object.      */     public void installUI(JComponent a) {         for (int i = 0; i &lt; uis.size(); i++) {             uis.elementAt(i).installUI(a);         }     }      /**      * Invokes the uninstallUI method on each UI handled by this object.      */     public void uninstallUI(JComponent a) {         for (int i = 0; i &lt; uis.size(); i++) {             uis.elementAt(i).uninstallUI(a);         }     }      /**      * Invokes the paint method on each UI handled by this object.      */     public void paint(Graphics a, JComponent b) {         for (int i = 0; i &lt; uis.size(); i++) {             uis.elementAt(i).paint(a,b);         }     }      /**      * Invokes the getPreferredSize method on each UI handled by this object.      *      * @return the value obtained from the first UI, which is      * the UI obtained from the default LookAndFeel      */     public Dimension getPreferredSize(JComponent a) {         Dimension returnValue =             uis.elementAt(0).getPreferredSize(a);         for (int i = 1; i &lt; uis.size(); i++) {             uis.elementAt(i).getPreferredSize(a);         }         return returnValue;     }      /**      * Invokes the getMinimumSize method on each UI handled by this object.      *      * @return the value obtained from the first UI, which is      * the UI obtained from the default LookAndFeel      */     public Dimension getMinimumSize(JComponent a) {         Dimension returnValue =             uis.elementAt(0).getMinimumSize(a);         for (int i = 1; i &lt; uis.size(); i++) {             uis.elementAt(i).getMinimumSize(a);         }         return returnValue;     }      /**      * Invokes the getMaximumSize method on each UI handled by this object.      *      * @return the value obtained from the first UI, which is      * the UI obtained from the default LookAndFeel      */     public Dimension getMaximumSize(JComponent a) {         Dimension returnValue =             uis.elementAt(0).getMaximumSize(a);         for (int i = 1; i &lt; uis.size(); i++) {             uis.elementAt(i).getMaximumSize(a);         }         return returnValue;     }      /**      * Invokes the getAccessibleChildrenCount method on each UI handled by this object.      *      * @return the value obtained from the first UI, which is      * the UI obtained from the default LookAndFeel      */     public int getAccessibleChildrenCount(JComponent a) {         int returnValue =             uis.elementAt(0).getAccessibleChildrenCount(a);         for (int i = 1; i &lt; uis.size(); i++) {             uis.elementAt(i).getAccessibleChildrenCount(a);         }         return returnValue;     }      /**      * Invokes the getAccessibleChild method on each UI handled by this object.      *      * @return the value obtained from the first UI, which is      * the UI obtained from the default LookAndFeel      */     public Accessible getAccessibleChild(JComponent a, int b) {         Accessible returnValue =             uis.elementAt(0).getAccessibleChild(a,b);         for (int i = 1; i &lt; uis.size(); i++) {             uis.elementAt(i).getAccessibleChild(a,b);         }         return returnValue;     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11053</td>
    <td align="left">https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/java.desktop/share/classes/javax/swing/plaf/multi/MultiSpinnerUI.java/#L43-L214</td>
    <td align="right">1</td>
    <td align="right">1473</td>
    <td align="right">11053</td>
  </tr>
  <tr valign="top">
    <td align="right">1481</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{       &quot;message&quot;: &quot;YES I found bad smells&quot;,       &quot;bad smells are&quot;: [          &quot;1. Blob&quot;       ]    }   </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ComponentRenderInfo extends BaseRenderInfo {    public static final String LAYOUT_DIFFING_ENABLED = &quot;layout_diffing_enabled&quot;;   public static final String PERSISTENCE_ENABLED = &quot;is_persistence_enabled&quot;;    private final Component mComponent;   @Nullable private final EventHandler mRenderCompleteEventHandler;    public static Builder create() {     return new Builder();   }    private ComponentRenderInfo(Builder builder) {     super(builder);      if (builder.mComponent == null) {       throw new IllegalStateException(&quot;Component must be provided.&quot;);     }      mComponent = builder.mComponent;     mRenderCompleteEventHandler = builder.mRenderCompleteEventEventHandler;   }    /** Create empty {@link ComponentRenderInfo}. */   public static RenderInfo createEmpty() {     return create().component(new EmptyComponent()).build();   }    @Override   public Component getComponent() {     return mComponent;   }    @Override   @Nullable   public EventHandler getRenderCompleteEventHandler() {     return mRenderCompleteEventHandler;   }    @Override   public boolean rendersComponent() {     return true;   }    @Override   public String getName() {     return mComponent.getSimpleName();   }    public static class Builder extends BaseRenderInfo.Builder {     private Component mComponent;     private EventHandler mRenderCompleteEventEventHandler;      /** Specify {@link Component} that will be rendered as an item of the list. */     public Builder component(Component component) {       this.mComponent = component;       return this;     }      public Builder renderCompleteHandler(         EventHandler renderCompleteEventHandler) {       this.mRenderCompleteEventEventHandler = renderCompleteEventHandler;       return this;     }      public Builder component(Component.Builder builder) {       return component(builder.build());     }      public ComponentRenderInfo build() {       return new ComponentRenderInfo(this);     }   }    private static class EmptyComponent extends Component {      protected EmptyComponent() {       super(&quot;EmptyComponent&quot;);     }      @Override     protected Component onCreateLayout(ComponentContext c) {       return Column.create(c).build();     }      @Override     public boolean isEquivalentTo(Component other) {       return EmptyComponent.this == other           || (other != null &amp;&amp; EmptyComponent.this.getClass() == other.getClass());     }   } }</td>
    <td align="left">blob</td>
    <td align="left">1. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11082</td>
    <td align="left">https://github.com/facebook/litho/blob/19503b819b97e17d02f584633508dca8c646911a/litho-widget/src/main/java/com/facebook/litho/widget/ComponentRenderInfo.java/#L27-L118</td>
    <td align="right">1</td>
    <td align="right">1481</td>
    <td align="right">11082</td>
  </tr>
  <tr valign="top">
    <td align="right">1531</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class APIRequestGet extends APIRequest {      AdCampaignActivity lastResponse = null;     @Override     public AdCampaignActivity getLastResponse() {       return lastResponse;     }     public static final String[] PARAMS = {     };      public static final String[] FIELDS = {       &quot;auto_create_lookalike_new&quot;,       &quot;auto_create_lookalike_old&quot;,       &quot;bid_adjustments_spec_new&quot;,       &quot;bid_adjustments_spec_old&quot;,       &quot;bid_amount_new&quot;,       &quot;bid_amount_old&quot;,       &quot;bid_constraints_new&quot;,       &quot;bid_constraints_old&quot;,       &quot;bid_info_new&quot;,       &quot;bid_info_old&quot;,       &quot;bid_strategy_new&quot;,       &quot;bid_strategy_old&quot;,       &quot;bid_type_new&quot;,       &quot;bid_type_old&quot;,       &quot;billing_event_new&quot;,       &quot;billing_event_old&quot;,       &quot;brande_audience_id_new&quot;,       &quot;brande_audience_id_old&quot;,       &quot;budget_limit_new&quot;,       &quot;budget_limit_old&quot;,       &quot;created_time&quot;,       &quot;daily_impressions_new&quot;,       &quot;daily_impressions_old&quot;,       &quot;dco_mode_new&quot;,       &quot;dco_mode_old&quot;,       &quot;delivery_behavior_new&quot;,       &quot;delivery_behavior_old&quot;,       &quot;destination_type_new&quot;,       &quot;destination_type_old&quot;,       &quot;event_time&quot;,       &quot;event_type&quot;,       &quot;id&quot;,       &quot;invoicing_limit_new&quot;,       &quot;invoicing_limit_old&quot;,       &quot;min_spend_target_new&quot;,       &quot;min_spend_target_old&quot;,       &quot;name_new&quot;,       &quot;name_old&quot;,       &quot;optimization_goal_new&quot;,       &quot;optimization_goal_old&quot;,       &quot;pacing_type_new&quot;,       &quot;pacing_type_old&quot;,       &quot;run_status_new&quot;,       &quot;run_status_old&quot;,       &quot;schedule_new&quot;,       &quot;schedule_old&quot;,       &quot;spend_cap_new&quot;,       &quot;spend_cap_old&quot;,       &quot;start_time_new&quot;,       &quot;start_time_old&quot;,       &quot;stop_time_new&quot;,       &quot;stop_time_old&quot;,       &quot;targeting_expansion_new&quot;,       &quot;targeting_expansion_old&quot;,       &quot;updated_time_new&quot;,       &quot;updated_time_old&quot;,     };      @Override     public AdCampaignActivity parseResponse(String response, String header) throws APIException {       return AdCampaignActivity.parseResponse(response, getContext(), this, header).head();     }      @Override     public AdCampaignActivity execute() throws APIException {       return execute(new HashMap());     }      @Override     public AdCampaignActivity execute(Map extraParams) throws APIException {       ResponseWrapper rw = executeInternal(extraParams);       lastResponse = parseResponse(rw.getBody(), rw.getHeader());       return lastResponse;     }      public ListenableFuture executeAsync() throws APIException {       return executeAsync(new HashMap());     };      public ListenableFuture executeAsync(Map extraParams) throws APIException {       return Futures.transform(         executeAsyncInternal(extraParams),         new Function() {            public AdCampaignActivity apply(ResponseWrapper result) {              try {                return APIRequestGet.this.parseResponse(result.getBody(), result.getHeader());              } catch (Exception e) {                throw new RuntimeException(e);              }            }          }       );     };      public APIRequestGet(String nodeId, APIContext context) {       super(context, nodeId, &quot;/&quot;, &quot;GET&quot;, Arrays.asList(PARAMS));     }      @Override     public APIRequestGet setParam(String param, Object value) {       setParamInternal(param, value);       return this;     }      @Override     public APIRequestGet setParams(Map params) {       setParamsInternal(params);       return this;     }       public APIRequestGet requestAllFields () {       return this.requestAllFields(true);     }      public APIRequestGet requestAllFields (boolean value) {       for (String field : FIELDS) {         this.requestField(field, value);       }       return this;     }      @Override     public APIRequestGet requestFields (List fields) {       return this.requestFields(fields, true);     }      @Override     public APIRequestGet requestFields (List fields, boolean value) {       for (String field : fields) {         this.requestField(field, value);       }       return this;     }      @Override     public APIRequestGet requestField (String field) {       this.requestField(field, true);       return this;     }      @Override     public APIRequestGet requestField (String field, boolean value) {       this.requestFieldInternal(field, value);       return this;     }      public APIRequestGet requestAutoCreateLookalikeNewField () {       return this.requestAutoCreateLookalikeNewField(true);     }     public APIRequestGet requestAutoCreateLookalikeNewField (boolean value) {       this.requestField(&quot;auto_create_lookalike_new&quot;, value);       return this;     }     public APIRequestGet requestAutoCreateLookalikeOldField () {       return this.requestAutoCreateLookalikeOldField(true);     }     public APIRequestGet requestAutoCreateLookalikeOldField (boolean value) {       this.requestField(&quot;auto_create_lookalike_old&quot;, value);       return this;     }     public APIRequestGet requestBidAdjustmentsSpecNewField () {       return this.requestBidAdjustmentsSpecNewField(true);     }     public APIRequestGet requestBidAdjustmentsSpecNewField (boolean value) {       this.requestField(&quot;bid_adjustments_spec_new&quot;, value);       return this;     }     public APIRequestGet requestBidAdjustmentsSpecOldField () {       return this.requestBidAdjustmentsSpecOldField(true);     }     public APIRequestGet requestBidAdjustmentsSpecOldField (boolean value) {       this.requestField(&quot;bid_adjustments_spec_old&quot;, value);       return this;     }     public APIRequestGet requestBidAmountNewField () {       return this.requestBidAmountNewField(true);     }     public APIRequestGet requestBidAmountNewField (boolean value) {       this.requestField(&quot;bid_amount_new&quot;, value);       return this;     }     public APIRequestGet requestBidAmountOldField () {       return this.requestBidAmountOldField(true);     }     public APIRequestGet requestBidAmountOldField (boolean value) {       this.requestField(&quot;bid_amount_old&quot;, value);       return this;     }     public APIRequestGet requestBidConstraintsNewField () {       return this.requestBidConstraintsNewField(true);     }     public APIRequestGet requestBidConstraintsNewField (boolean value) {       this.requestField(&quot;bid_constraints_new&quot;, value);       return this;     }     public APIRequestGet requestBidConstraintsOldField () {       return this.requestBidConstraintsOldField(true);     }     public APIRequestGet requestBidConstraintsOldField (boolean value) {       this.requestField(&quot;bid_constraints_old&quot;, value);       return this;     }     public APIRequestGet requestBidInfoNewField () {       return this.requestBidInfoNewField(true);     }     public APIRequestGet requestBidInfoNewField (boolean value) {       this.requestField(&quot;bid_info_new&quot;, value);       return this;     }     public APIRequestGet requestBidInfoOldField () {       return this.requestBidInfoOldField(true);     }     public APIRequestGet requestBidInfoOldField (boolean value) {       this.requestField(&quot;bid_info_old&quot;, value);       return this;     }     public APIRequestGet requestBidStrategyNewField () {       return this.requestBidStrategyNewField(true);     }     public APIRequestGet requestBidStrategyNewField (boolean value) {       this.requestField(&quot;bid_strategy_new&quot;, value);       return this;     }     public APIRequestGet requestBidStrategyOldField () {       return this.requestBidStrategyOldField(true);     }     public APIRequestGet requestBidStrategyOldField (boolean value) {       this.requestField(&quot;bid_strategy_old&quot;, value);       return this;     }     public APIRequestGet requestBidTypeNewField () {       return this.requestBidTypeNewField(true);     }     public APIRequestGet requestBidTypeNewField (boolean value) {       this.requestField(&quot;bid_type_new&quot;, value);       return this;     }     public APIRequestGet requestBidTypeOldField () {       return this.requestBidTypeOldField(true);     }     public APIRequestGet requestBidTypeOldField (boolean value) {       this.requestField(&quot;bid_type_old&quot;, value);       return this;     }     public APIRequestGet requestBillingEventNewField () {       return this.requestBillingEventNewField(true);     }     public APIRequestGet requestBillingEventNewField (boolean value) {       this.requestField(&quot;billing_event_new&quot;, value);       return this;     }     public APIRequestGet requestBillingEventOldField () {       return this.requestBillingEventOldField(true);     }     public APIRequestGet requestBillingEventOldField (boolean value) {       this.requestField(&quot;billing_event_old&quot;, value);       return this;     }     public APIRequestGet requestBrandeAudienceIdNewField () {       return this.requestBrandeAudienceIdNewField(true);     }     public APIRequestGet requestBrandeAudienceIdNewField (boolean value) {       this.requestField(&quot;brande_audience_id_new&quot;, value);       return this;     }     public APIRequestGet requestBrandeAudienceIdOldField () {       return this.requestBrandeAudienceIdOldField(true);     }     public APIRequestGet requestBrandeAudienceIdOldField (boolean value) {       this.requestField(&quot;brande_audience_id_old&quot;, value);       return this;     }     public APIRequestGet requestBudgetLimitNewField () {       return this.requestBudgetLimitNewField(true);     }     public APIRequestGet requestBudgetLimitNewField (boolean value) {       this.requestField(&quot;budget_limit_new&quot;, value);       return this;     }     public APIRequestGet requestBudgetLimitOldField () {       return this.requestBudgetLimitOldField(true);     }     public APIRequestGet requestBudgetLimitOldField (boolean value) {       this.requestField(&quot;budget_limit_old&quot;, value);       return this;     }     public APIRequestGet requestCreatedTimeField () {       return this.requestCreatedTimeField(true);     }     public APIRequestGet requestCreatedTimeField (boolean value) {       this.requestField(&quot;created_time&quot;, value);       return this;     }     public APIRequestGet requestDailyImpressionsNewField () {       return this.requestDailyImpressionsNewField(true);     }     public APIRequestGet requestDailyImpressionsNewField (boolean value) {       this.requestField(&quot;daily_impressions_new&quot;, value);       return this;     }     public APIRequestGet requestDailyImpressionsOldField () {       return this.requestDailyImpressionsOldField(true);     }     public APIRequestGet requestDailyImpressionsOldField (boolean value) {       this.requestField(&quot;daily_impressions_old&quot;, value);       return this;     }     public APIRequestGet requestDcoModeNewField () {       return this.requestDcoModeNewField(true);     }     public APIRequestGet requestDcoModeNewField (boolean value) {       this.requestField(&quot;dco_mode_new&quot;, value);       return this;     }     public APIRequestGet requestDcoModeOldField () {       return this.requestDcoModeOldField(true);     }     public APIRequestGet requestDcoModeOldField (boolean value) {       this.requestField(&quot;dco_mode_old&quot;, value);       return this;     }     public APIRequestGet requestDeliveryBehaviorNewField () {       return this.requestDeliveryBehaviorNewField(true);     }     public APIRequestGet requestDeliveryBehaviorNewField (boolean value) {       this.requestField(&quot;delivery_behavior_new&quot;, value);       return this;     }     public APIRequestGet requestDeliveryBehaviorOldField () {       return this.requestDeliveryBehaviorOldField(true);     }     public APIRequestGet requestDeliveryBehaviorOldField (boolean value) {       this.requestField(&quot;delivery_behavior_old&quot;, value);       return this;     }     public APIRequestGet requestDestinationTypeNewField () {       return this.requestDestinationTypeNewField(true);     }     public APIRequestGet requestDestinationTypeNewField (boolean value) {       this.requestField(&quot;destination_type_new&quot;, value);       return this;     }     public APIRequestGet requestDestinationTypeOldField () {       return this.requestDestinationTypeOldField(true);     }     public APIRequestGet requestDestinationTypeOldField (boolean value) {       this.requestField(&quot;destination_type_old&quot;, value);       return this;     }     public APIRequestGet requestEventTimeField () {       return this.requestEventTimeField(true);     }     public APIRequestGet requestEventTimeField (boolean value) {       this.requestField(&quot;event_time&quot;, value);       return this;     }     public APIRequestGet requestEventTypeField () {       return this.requestEventTypeField(true);     }     public APIRequestGet requestEventTypeField (boolean value) {       this.requestField(&quot;event_type&quot;, value);       return this;     }     public APIRequestGet requestIdField () {       return this.requestIdField(true);     }     public APIRequestGet requestIdField (boolean value) {       this.requestField(&quot;id&quot;, value);       return this;     }     public APIRequestGet requestInvoicingLimitNewField () {       return this.requestInvoicingLimitNewField(true);     }     public APIRequestGet requestInvoicingLimitNewField (boolean value) {       this.requestField(&quot;invoicing_limit_new&quot;, value);       return this;     }     public APIRequestGet requestInvoicingLimitOldField () {       return this.requestInvoicingLimitOldField(true);     }     public APIRequestGet requestInvoicingLimitOldField (boolean value) {       this.requestField(&quot;invoicing_limit_old&quot;, value);       return this;     }     public APIRequestGet requestMinSpendTargetNewField () {       return this.requestMinSpendTargetNewField(true);     }     public APIRequestGet requestMinSpendTargetNewField (boolean value) {       this.requestField(&quot;min_spend_target_new&quot;, value);       return this;     }     public APIRequestGet requestMinSpendTargetOldField () {       return this.requestMinSpendTargetOldField(true);     }     public APIRequestGet requestMinSpendTargetOldField (boolean value) {       this.requestField(&quot;min_spend_target_old&quot;, value);       return this;     }     public APIRequestGet requestNameNewField () {       return this.requestNameNewField(true);     }     public APIRequestGet requestNameNewField (boolean value) {       this.requestField(&quot;name_new&quot;, value);       return this;     }     public APIRequestGet requestNameOldField () {       return this.requestNameOldField(true);     }     public APIRequestGet requestNameOldField (boolean value) {       this.requestField(&quot;name_old&quot;, value);       return this;     }     public APIRequestGet requestOptimizationGoalNewField () {       return this.requestOptimizationGoalNewField(true);     }     public APIRequestGet requestOptimizationGoalNewField (boolean value) {       this.requestField(&quot;optimization_goal_new&quot;, value);       return this;     }     public APIRequestGet requestOptimizationGoalOldField () {       return this.requestOptimizationGoalOldField(true);     }     public APIRequestGet requestOptimizationGoalOldField (boolean value) {       this.requestField(&quot;optimization_goal_old&quot;, value);       return this;     }     public APIRequestGet requestPacingTypeNewField () {       return this.requestPacingTypeNewField(true);     }     public APIRequestGet requestPacingTypeNewField (boolean value) {       this.requestField(&quot;pacing_type_new&quot;, value);       return this;     }     public APIRequestGet requestPacingTypeOldField () {       return this.requestPacingTypeOldField(true);     }     public APIRequestGet requestPacingTypeOldField (boolean value) {       this.requestField(&quot;pacing_type_old&quot;, value);       return this;     }     public APIRequestGet requestRunStatusNewField () {       return this.requestRunStatusNewField(true);     }     public APIRequestGet requestRunStatusNewField (boolean value) {       this.requestField(&quot;run_status_new&quot;, value);       return this;     }     public APIRequestGet requestRunStatusOldField () {       return this.requestRunStatusOldField(true);     }     public APIRequestGet requestRunStatusOldField (boolean value) {       this.requestField(&quot;run_status_old&quot;, value);       return this;     }     public APIRequestGet requestScheduleNewField () {       return this.requestScheduleNewField(true);     }     public APIRequestGet requestScheduleNewField (boolean value) {       this.requestField(&quot;schedule_new&quot;, value);       return this;     }     public APIRequestGet requestScheduleOldField () {       return this.requestScheduleOldField(true);     }     public APIRequestGet requestScheduleOldField (boolean value) {       this.requestField(&quot;schedule_old&quot;, value);       return this;     }     public APIRequestGet requestSpendCapNewField () {       return this.requestSpendCapNewField(true);     }     public APIRequestGet requestSpendCapNewField (boolean value) {       this.requestField(&quot;spend_cap_new&quot;, value);       return this;     }     public APIRequestGet requestSpendCapOldField () {       return this.requestSpendCapOldField(true);     }     public APIRequestGet requestSpendCapOldField (boolean value) {       this.requestField(&quot;spend_cap_old&quot;, value);       return this;     }     public APIRequestGet requestStartTimeNewField () {       return this.requestStartTimeNewField(true);     }     public APIRequestGet requestStartTimeNewField (boolean value) {       this.requestField(&quot;start_time_new&quot;, value);       return this;     }     public APIRequestGet requestStartTimeOldField () {       return this.requestStartTimeOldField(true);     }     public APIRequestGet requestStartTimeOldField (boolean value) {       this.requestField(&quot;start_time_old&quot;, value);       return this;     }     public APIRequestGet requestStopTimeNewField () {       return this.requestStopTimeNewField(true);     }     public APIRequestGet requestStopTimeNewField (boolean value) {       this.requestField(&quot;stop_time_new&quot;, value);       return this;     }     public APIRequestGet requestStopTimeOldField () {       return this.requestStopTimeOldField(true);     }     public APIRequestGet requestStopTimeOldField (boolean value) {       this.requestField(&quot;stop_time_old&quot;, value);       return this;     }     public APIRequestGet requestTargetingExpansionNewField () {       return this.requestTargetingExpansionNewField(true);     }     public APIRequestGet requestTargetingExpansionNewField (boolean value) {       this.requestField(&quot;targeting_expansion_new&quot;, value);       return this;     }     public APIRequestGet requestTargetingExpansionOldField () {       return this.requestTargetingExpansionOldField(true);     }     public APIRequestGet requestTargetingExpansionOldField (boolean value) {       this.requestField(&quot;targeting_expansion_old&quot;, value);       return this;     }     public APIRequestGet requestUpdatedTimeNewField () {       return this.requestUpdatedTimeNewField(true);     }     public APIRequestGet requestUpdatedTimeNewField (boolean value) {       this.requestField(&quot;updated_time_new&quot;, value);       return this;     }     public APIRequestGet requestUpdatedTimeOldField () {       return this.requestUpdatedTimeOldField(true);     }     public APIRequestGet requestUpdatedTimeOldField (boolean value) {       this.requestField(&quot;updated_time_old&quot;, value);       return this;     }   }</td>
    <td align="left">blob</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;data class,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11208</td>
    <td align="left">https://github.com/facebook/facebook-java-business-sdk/blob/561f1a75e1220b55a160a1b92b0187f72be9cd08/src/main/java/com/facebook/ads/sdk/AdCampaignActivity.java/#L610-L1160</td>
    <td align="right">1</td>
    <td align="right">1531</td>
    <td align="right">11208</td>
  </tr>
  <tr valign="top">
    <td align="right">1535</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Graph extends GraphShapeElement { 	public enum Alignment { 		HORIZONTAL, VERTICAL 	}  	private List nodes = new ArrayList&lt;&gt;(); 	private Set edges = new HashSet&lt;&gt;(); 	private Set subgraphs = new HashSet&lt;&gt;(); 	private Alignment alignment = Alignment.VERTICAL;  	/** 	 * Constructs a Graph that uses the specified GraphEventManager to handle 	 * any user generated events on GraphElements. 	 *  	 * @param eventManager 	 */ 	public Graph(GraphController graphController) { 		super(graphController); 	}  	/** 	 * Adds an edge to the Graph and sets its parent to be this Graph. 	 *  	 * @param edge 	 *            the edge to add 	 */ 	public void addEdge(GraphEdge edge) { 		edge.setParent(this); 		edges.add(edge); 	}  	/** 	 * Adds a node to the Graph and sets its parent to be this Graph. 	 *  	 * @param node 	 *            the node to add 	 */ 	public void addNode(GraphNode node) { 		node.setParent(this); 		nodes.add(node); 	}  	/** 	 * Adds a subgraph to the Graph and sets its parent to be this Graph. 	 *  	 * @param subgraph 	 *            the subgraph to add 	 */ 	public void addSubgraph(Graph subgraph) { 		subgraph.setParent(this); 		subgraphs.add(subgraph); 	}  	/** 	 * Returns the alignment of the Graph. 	 *  	 * @return the alignment of the Graph 	 */ 	public Alignment getAlignment() { 		return alignment; 	}  	/** 	 * Returns the edges contained in the Graph. 	 *  	 * @return the edges contained in the Graph 	 */ 	public Set getEdges() { 		return Collections.unmodifiableSet(edges); 	}  	/** 	 * Returns the nodes contained in the Graph. 	 *  	 * @return the nodes contained in the Graph 	 */ 	public List getNodes() { 		return Collections.unmodifiableList(nodes); 	}  	/** 	 * Returns the subgraphs contained in the Graph. 	 *  	 * @return the subgraphs contained in the Graph 	 */ 	public Set getSubgraphs() { 		return Collections.unmodifiableSet(subgraphs); 	}  	/** 	 * Removes an edge from the Graph. 	 *  	 * @param edge 	 *            the edge to remove 	 * @return true if the edge is removed from the Graph 	 */ 	public boolean removeEdge(GraphEdge edge) { 		return edges.remove(edge); 	}  	/** 	 * Removes a node from the Graph. 	 *  	 * @param node 	 *            the node to remove 	 * @return true if the node is removed from the Graph 	 */ 	public boolean removeNode(GraphNode node) { 		return nodes.remove(node); 	}  	/** 	 * Removes a subgraph from the Graph. 	 *  	 * @param subgraph 	 *            the subgraph to remove 	 * @return true if the subgraph is removed from the Graph 	 */ 	public boolean removeSubgraph(Graph subgraph) { 		return subgraphs.remove(subgraph); 	}  	/** 	 * Sets the alignment of the Graph. 	 *  	 * @param alignment 	 *            the new alignment 	 */ 	public void setAlignment(Alignment alignment) { 		this.alignment = alignment; 	} }</td>
    <td align="left">blob</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11218</td>
    <td align="left">https://github.com/apache/incubator-taverna-workbench/blob/2b74964ac1ee22e56c5dad3321869d84f7052dcf/taverna-graph-model/src/main/java/org/apache/taverna/workbench/models/graph/Graph.java/#L30-L161</td>
    <td align="right">1</td>
    <td align="right">1535</td>
    <td align="right">11218</td>
  </tr>
  <tr valign="top">
    <td align="right">1549</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;the bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class BacktrackingBug325745TestLanguagePackageImpl extends EPackageImpl implements BacktrackingBug325745TestLanguagePackage {   /**    *     *     * @generated    */   private EClass modelEClass = null;    /**    *     *     * @generated    */   private EClass elementEClass = null;    /**    *     *     * @generated    */   private EClass dataTypeEClass = null;    /**    *     *     * @generated    */   private EClass expressionEClass = null;    /**    *     *     * @generated    */   private EClass simpleTermEClass = null;    /**    * Creates an instance of the model Package, registered with    * {@link org.eclipse.emf.ecore.EPackage.Registry EPackage.Registry} by the package    * package URI value.    * Note: the correct way to create the package is via the static    * factory method {@link #init init()}, which also performs    * initialization of the package, or returns the registered package,    * if one already exists.    *     *     * @see org.eclipse.emf.ecore.EPackage.Registry    * @see org.eclipse.xtext.parser.unorderedGroups.backtrackingBug325745TestLanguage.BacktrackingBug325745TestLanguagePackage#eNS_URI    * @see #init()    * @generated    */   private BacktrackingBug325745TestLanguagePackageImpl()   {     super(eNS_URI, BacktrackingBug325745TestLanguageFactory.eINSTANCE);   }    /**    *     *     * @generated    */   private static boolean isInited = false;    /**    * Creates, registers, and initializes the Package for this model, and for any others upon which it depends.    *     * This method is used to initialize {@link BacktrackingBug325745TestLanguagePackage#eINSTANCE} when that field is accessed.    * Clients should not invoke it directly. Instead, they should simply access that field to obtain the package.    *     *     * @see #eNS_URI    * @see #createPackageContents()    * @see #initializePackageContents()    * @generated    */   public static BacktrackingBug325745TestLanguagePackage init()   {     if (isInited) return (BacktrackingBug325745TestLanguagePackage)EPackage.Registry.INSTANCE.getEPackage(BacktrackingBug325745TestLanguagePackage.eNS_URI);      // Obtain or create and register package     BacktrackingBug325745TestLanguagePackageImpl theBacktrackingBug325745TestLanguagePackage = (BacktrackingBug325745TestLanguagePackageImpl)(EPackage.Registry.INSTANCE.get(eNS_URI) instanceof BacktrackingBug325745TestLanguagePackageImpl ? EPackage.Registry.INSTANCE.get(eNS_URI) : new BacktrackingBug325745TestLanguagePackageImpl());      isInited = true;      // Initialize simple dependencies     EcorePackage.eINSTANCE.eClass();      // Create package meta-data objects     theBacktrackingBug325745TestLanguagePackage.createPackageContents();      // Initialize created meta-data     theBacktrackingBug325745TestLanguagePackage.initializePackageContents();      // Mark meta-data to indicate it can't be changed     theBacktrackingBug325745TestLanguagePackage.freeze();         // Update the registry and return the package     EPackage.Registry.INSTANCE.put(BacktrackingBug325745TestLanguagePackage.eNS_URI, theBacktrackingBug325745TestLanguagePackage);     return theBacktrackingBug325745TestLanguagePackage;   }    /**    *     *     * @generated    */   public EClass getModel()   {     return modelEClass;   }    /**    *     *     * @generated    */   public EReference getModel_Fields()   {     return (EReference)modelEClass.getEStructuralFeatures().get(0);   }    /**    *     *     * @generated    */   public EClass getElement()   {     return elementEClass;   }    /**    *     *     * @generated    */   public EAttribute getElement_Name()   {     return (EAttribute)elementEClass.getEStructuralFeatures().get(0);   }    /**    *     *     * @generated    */   public EReference getElement_DataType()   {     return (EReference)elementEClass.getEStructuralFeatures().get(1);   }    /**    *     *     * @generated    */   public EReference getElement_Expression()   {     return (EReference)elementEClass.getEStructuralFeatures().get(2);   }    /**    *     *     * @generated    */   public EClass getDataType()   {     return dataTypeEClass;   }    /**    *     *     * @generated    */   public EAttribute getDataType_BaseType()   {     return (EAttribute)dataTypeEClass.getEStructuralFeatures().get(0);   }    /**    *     *     * @generated    */   public EAttribute getDataType_DefaultValue()   {     return (EAttribute)dataTypeEClass.getEStructuralFeatures().get(1);   }    /**    *     *     * @generated    */   public EClass getExpression()   {     return expressionEClass;   }    /**    *     *     * @generated    */   public EAttribute getExpression_Prefix()   {     return (EAttribute)expressionEClass.getEStructuralFeatures().get(0);   }    /**    *     *     * @generated    */   public EReference getExpression_Terms()   {     return (EReference)expressionEClass.getEStructuralFeatures().get(1);   }    /**    *     *     * @generated    */   public EAttribute getExpression_Postfix()   {     return (EAttribute)expressionEClass.getEStructuralFeatures().get(2);   }    /**    *     *     * @generated    */   public EClass getSimpleTerm()   {     return simpleTermEClass;   }    /**    *     *     * @generated    */   public EAttribute getSimpleTerm_LineCount()   {     return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(0);   }    /**    *     *     * @generated    */   public EAttribute getSimpleTerm_CharCount()   {     return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(1);   }    /**    *     *     * @generated    */   public EAttribute getSimpleTerm_CharSet()   {     return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(2);   }    /**    *     *     * @generated    */   public EAttribute getSimpleTerm_RefChar()   {     return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(3);   }    /**    *     *     * @generated    */   public BacktrackingBug325745TestLanguageFactory getBacktrackingBug325745TestLanguageFactory()   {     return (BacktrackingBug325745TestLanguageFactory)getEFactoryInstance();   }    /**    *     *     * @generated    */   private boolean isCreated = false;    /**    * Creates the meta-model objects for the package.  This method is    * guarded to have no affect on any invocation but its first.    *     *     * @generated    */   public void createPackageContents()   {     if (isCreated) return;     isCreated = true;      // Create classes and their features     modelEClass = createEClass(MODEL);     createEReference(modelEClass, MODEL__FIELDS);      elementEClass = createEClass(ELEMENT);     createEAttribute(elementEClass, ELEMENT__NAME);     createEReference(elementEClass, ELEMENT__DATA_TYPE);     createEReference(elementEClass, ELEMENT__EXPRESSION);      dataTypeEClass = createEClass(DATA_TYPE);     createEAttribute(dataTypeEClass, DATA_TYPE__BASE_TYPE);     createEAttribute(dataTypeEClass, DATA_TYPE__DEFAULT_VALUE);      expressionEClass = createEClass(EXPRESSION);     createEAttribute(expressionEClass, EXPRESSION__PREFIX);     createEReference(expressionEClass, EXPRESSION__TERMS);     createEAttribute(expressionEClass, EXPRESSION__POSTFIX);      simpleTermEClass = createEClass(SIMPLE_TERM);     createEAttribute(simpleTermEClass, SIMPLE_TERM__LINE_COUNT);     createEAttribute(simpleTermEClass, SIMPLE_TERM__CHAR_COUNT);     createEAttribute(simpleTermEClass, SIMPLE_TERM__CHAR_SET);     createEAttribute(simpleTermEClass, SIMPLE_TERM__REF_CHAR);   }    /**    *     *     * @generated    */   private boolean isInitialized = false;    /**    * Complete the initialization of the package and its meta-model.  This    * method is guarded to have no affect on any invocation but its first.    *     *     * @generated    */   public void initializePackageContents()   {     if (isInitialized) return;     isInitialized = true;      // Initialize package     setName(eNAME);     setNsPrefix(eNS_PREFIX);     setNsURI(eNS_URI);      // Obtain other dependent packages     EcorePackage theEcorePackage = (EcorePackage)EPackage.Registry.INSTANCE.getEPackage(EcorePackage.eNS_URI);      // Create type parameters      // Set bounds for type parameters      // Add supertypes to classes      // Initialize classes and features; add operations and parameters     initEClass(modelEClass, Model.class, &quot;Model&quot;, !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);     initEReference(getModel_Fields(), this.getElement(), null, &quot;fields&quot;, null, 0, -1, Model.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);      initEClass(elementEClass, Element.class, &quot;Element&quot;, !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);     initEAttribute(getElement_Name(), theEcorePackage.getEString(), &quot;name&quot;, null, 0, 1, Element.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEReference(getElement_DataType(), this.getDataType(), null, &quot;dataType&quot;, null, 0, 1, Element.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEReference(getElement_Expression(), this.getExpression(), null, &quot;expression&quot;, null, 0, 1, Element.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);      initEClass(dataTypeEClass, DataType.class, &quot;DataType&quot;, !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);     initEAttribute(getDataType_BaseType(), theEcorePackage.getEString(), &quot;baseType&quot;, null, 0, 1, DataType.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEAttribute(getDataType_DefaultValue(), theEcorePackage.getEString(), &quot;defaultValue&quot;, null, 0, 1, DataType.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);      initEClass(expressionEClass, Expression.class, &quot;Expression&quot;, !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);     initEAttribute(getExpression_Prefix(), theEcorePackage.getEString(), &quot;prefix&quot;, null, 0, 1, Expression.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEReference(getExpression_Terms(), this.getSimpleTerm(), null, &quot;terms&quot;, null, 0, -1, Expression.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEAttribute(getExpression_Postfix(), theEcorePackage.getEString(), &quot;postfix&quot;, null, 0, 1, Expression.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);      initEClass(simpleTermEClass, SimpleTerm.class, &quot;SimpleTerm&quot;, !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);     initEAttribute(getSimpleTerm_LineCount(), theEcorePackage.getEInt(), &quot;lineCount&quot;, null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEAttribute(getSimpleTerm_CharCount(), theEcorePackage.getEInt(), &quot;charCount&quot;, null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEAttribute(getSimpleTerm_CharSet(), theEcorePackage.getEString(), &quot;charSet&quot;, null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEAttribute(getSimpleTerm_RefChar(), theEcorePackage.getEString(), &quot;refChar&quot;, null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);      // Create resource     createResource(eNS_URI);   }  } //BacktrackingBug325745TestLanguagePackageImpl</td>
    <td align="left">blob</td>
    <td align="left">Blob, Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;Data Class</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11262</td>
    <td align="left">https://github.com/eclipse/xtext-core/blob/e04964e4c2a3e0338c0079bd8333688835e77c31/org.eclipse.xtext.tests/src-gen/org/eclipse/xtext/parser/unorderedGroups/backtrackingBug325745TestLanguage/impl/BacktrackingBug325745TestLanguagePackageImpl.java/#L28-L426</td>
    <td align="right">1</td>
    <td align="right">1549</td>
    <td align="right">11262</td>
  </tr>
  <tr valign="top">
    <td align="right">1553</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [         &quot;Blob&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
final class DocumentsWriterDeleteQueue implements Accountable {    // the current end (latest delete operation) in the delete queue:   private volatile Node tail;    /** Used to record deletes against all prior (already written to disk) segments.  Whenever any segment flushes, we bundle up this set of    *  deletes and insert into the buffered updates stream before the newly flushed segment(s). */   private final DeleteSlice globalSlice;   private final BufferedUpdates globalBufferedUpdates;      // only acquired to update the global deletes, pkg-private for access by tests:   final ReentrantLock globalBufferLock = new ReentrantLock();    final long generation;    /** Generates the sequence number that IW returns to callers changing the index, showing the effective serialization of all operations. */   private final AtomicLong nextSeqNo;    private final InfoStream infoStream;    // for asserts   long maxSeqNo = Long.MAX_VALUE;      DocumentsWriterDeleteQueue(InfoStream infoStream) {     // seqNo must start at 1 because some APIs negate this to also return a boolean     this(infoStream, 0, 1);   }      DocumentsWriterDeleteQueue(InfoStream infoStream, long generation, long startSeqNo) {     this(infoStream, new BufferedUpdates(&quot;global&quot;), generation, startSeqNo);   }    DocumentsWriterDeleteQueue(InfoStream infoStream, BufferedUpdates globalBufferedUpdates, long generation, long startSeqNo) {     this.infoStream = infoStream;     this.globalBufferedUpdates = globalBufferedUpdates;     this.generation = generation;     this.nextSeqNo = new AtomicLong(startSeqNo);     /*      * we use a sentinel instance as our initial tail. No slice will ever try to      * apply this tail since the head is always omitted.      */     tail = new Node&lt;&gt;(null); // sentinel     globalSlice = new DeleteSlice(tail);   }    long addDelete(Query... queries) {     long seqNo = add(new QueryArrayNode(queries));     tryApplyGlobalSlice();     return seqNo;   }    long addDelete(Term... terms) {     long seqNo = add(new TermArrayNode(terms));     tryApplyGlobalSlice();     return seqNo;   }    long addDocValuesUpdates(DocValuesUpdate... updates) {     long seqNo = add(new DocValuesUpdatesNode(updates));     tryApplyGlobalSlice();     return seqNo;   }    static Node newNode(Term term) {     return new TermNode(term);   }    static Node newNode(DocValuesUpdate... updates) {     return new DocValuesUpdatesNode(updates);   }    /**    * invariant for document update    */   long add(Node deleteNode, DeleteSlice slice) {     long seqNo = add(deleteNode);     /*      * this is an update request where the term is the updated documents      * delTerm. in that case we need to guarantee that this insert is atomic      * with regards to the given delete slice. This means if two threads try to      * update the same document with in turn the same delTerm one of them must      * win. By taking the node we have created for our del term as the new tail      * it is guaranteed that if another thread adds the same right after us we      * will apply this delete next time we update our slice and one of the two      * competing updates wins!      */     slice.sliceTail = deleteNode;     assert slice.sliceHead != slice.sliceTail : &quot;slice head and tail must differ after add&quot;;     tryApplyGlobalSlice(); // TODO doing this each time is not necessary maybe     // we can do it just every n times or so?      return seqNo;   }    synchronized long add(Node newNode) {     tail.next = newNode;     this.tail = newNode;     return getNextSequenceNumber();   }    boolean anyChanges() {     globalBufferLock.lock();     try {       /*        * check if all items in the global slice were applied         * and if the global slice is up-to-date        * and if globalBufferedUpdates has changes        */       return globalBufferedUpdates.any() || !globalSlice.isEmpty() || globalSlice.sliceTail != tail || tail.next != null;     } finally {       globalBufferLock.unlock();     }   }    void tryApplyGlobalSlice() {     if (globalBufferLock.tryLock()) {       /*        * The global buffer must be locked but we don't need to update them if        * there is an update going on right now. It is sufficient to apply the        * deletes that have been added after the current in-flight global slices        * tail the next time we can get the lock!        */       try {         if (updateSliceNoSeqNo(globalSlice)) {           globalSlice.apply(globalBufferedUpdates, BufferedUpdates.MAX_INT);         }       } finally {         globalBufferLock.unlock();       }     }   }    FrozenBufferedUpdates freezeGlobalBuffer(DeleteSlice callerSlice) throws IOException {     globalBufferLock.lock();     /*      * Here we freeze the global buffer so we need to lock it, apply all      * deletes in the queue and reset the global slice to let the GC prune the      * queue.      */     final Node currentTail = tail; // take the current tail make this local any     // Changes after this call are applied later     // and not relevant here     if (callerSlice != null) {       // Update the callers slices so we are on the same page       callerSlice.sliceTail = currentTail;     }     try {       if (globalSlice.sliceTail != currentTail) {         globalSlice.sliceTail = currentTail;         globalSlice.apply(globalBufferedUpdates, BufferedUpdates.MAX_INT);       }        if (globalBufferedUpdates.any()) {         final FrozenBufferedUpdates packet = new FrozenBufferedUpdates(infoStream, globalBufferedUpdates, null);         globalBufferedUpdates.clear();         return packet;       } else {         return null;       }     } finally {       globalBufferLock.unlock();     }   }    DeleteSlice newSlice() {     return new DeleteSlice(tail);   }    /** Negative result means there were new deletes since we last applied */   synchronized long updateSlice(DeleteSlice slice) {     long seqNo = getNextSequenceNumber();     if (slice.sliceTail != tail) {       // new deletes arrived since we last checked       slice.sliceTail = tail;       seqNo = -seqNo;     }     return seqNo;   }    /** Just like updateSlice, but does not assign a sequence number */   boolean updateSliceNoSeqNo(DeleteSlice slice) {     if (slice.sliceTail != tail) {       // new deletes arrived since we last checked       slice.sliceTail = tail;       return true;     }     return false;   }    static class DeleteSlice {     // No need to be volatile, slices are thread captive (only accessed by one thread)!     Node sliceHead; // we don't apply this one     Node sliceTail;      DeleteSlice(Node currentTail) {       assert currentTail != null;       /*        * Initially this is a 0 length slice pointing to the 'current' tail of        * the queue. Once we update the slice we only need to assign the tail and        * have a new slice        */       sliceHead = sliceTail = currentTail;     }      void apply(BufferedUpdates del, int docIDUpto) {       if (sliceHead == sliceTail) {         // 0 length slice         return;       }       /*        * When we apply a slice we take the head and get its next as our first        * item to apply and continue until we applied the tail. If the head and        * tail in this slice are not equal then there will be at least one more        * non-null node in the slice!        */       Node current = sliceHead;       do {         current = current.next;         assert current != null : &quot;slice property violated between the head on the tail must not be a null node&quot;;         current.apply(del, docIDUpto);       } while (current != sliceTail);       reset();     }      void reset() {       // Reset to a 0 length slice       sliceHead = sliceTail;     }      /**      * Returns true iff the given node is identical to the the slices tail,      * otherwise false.      */     boolean isTail(Node node) {       return sliceTail == node;     }      /**      * Returns true iff the given item is identical to the item      * hold by the slices tail, otherwise false.      */     boolean isTailItem(Object object) {       return sliceTail.item == object;     }      boolean isEmpty() {       return sliceHead == sliceTail;     }   }    public int numGlobalTermDeletes() {     return globalBufferedUpdates.numTermDeletes.get();   }    void clear() {     globalBufferLock.lock();     try {       final Node currentTail = tail;       globalSlice.sliceHead = globalSlice.sliceTail = currentTail;       globalBufferedUpdates.clear();     } finally {       globalBufferLock.unlock();     }   }    static class Node {     volatile Node next;     final T item;      Node(T item) {       this.item = item;     }      void apply(BufferedUpdates bufferedDeletes, int docIDUpto) {       throw new IllegalStateException(&quot;sentinel item must never be applied&quot;);     }      boolean isDelete() {       return true;     }   }    private static final class TermNode extends Node {      TermNode(Term term) {       super(term);     }      @Override     void apply(BufferedUpdates bufferedDeletes, int docIDUpto) {       bufferedDeletes.addTerm(item, docIDUpto);     }      @Override     public String toString() {       return &quot;del=&quot; + item;     }    }    private static final class QueryArrayNode extends Node {     QueryArrayNode(Query[] query) {       super(query);     }      @Override     void apply(BufferedUpdates bufferedUpdates, int docIDUpto) {       for (Query query : item) {         bufferedUpdates.addQuery(query, docIDUpto);         }     }   }      private static final class TermArrayNode extends Node {     TermArrayNode(Term[] term) {       super(term);     }      @Override     void apply(BufferedUpdates bufferedUpdates, int docIDUpto) {       for (Term term : item) {         bufferedUpdates.addTerm(term, docIDUpto);         }     }      @Override     public String toString() {       return &quot;dels=&quot; + Arrays.toString(item);     }    }    private static final class DocValuesUpdatesNode extends Node {      DocValuesUpdatesNode(DocValuesUpdate... updates) {       super(updates);     }      @Override     void apply(BufferedUpdates bufferedUpdates, int docIDUpto) {       for (DocValuesUpdate update : item) {         switch (update.type) {           case NUMERIC:             bufferedUpdates.addNumericUpdate((NumericDocValuesUpdate) update, docIDUpto);             break;           case BINARY:             bufferedUpdates.addBinaryUpdate((BinaryDocValuesUpdate) update, docIDUpto);             break;           default:             throw new IllegalArgumentException(update.type + &quot; DocValues updates not supported yet!&quot;);         }       }     }       @Override     boolean isDelete() {       return false;     }      @Override     public String toString() {       StringBuilder sb = new StringBuilder();       sb.append(&quot;docValuesUpdates: &quot;);       if (item.length &gt; 0) {         sb.append(&quot;term=&quot;).append(item[0].term).append(&quot;; updates: [&quot;);         for (DocValuesUpdate update : item) {           sb.append(update.field).append(':').append(update.valueToString()).append(',');         }         sb.setCharAt(sb.length()-1, ']');       }       return sb.toString();     }   }      private boolean forceApplyGlobalSlice() {     globalBufferLock.lock();     final Node currentTail = tail;     try {       if (globalSlice.sliceTail != currentTail) {         globalSlice.sliceTail = currentTail;         globalSlice.apply(globalBufferedUpdates, BufferedUpdates.MAX_INT);       }       return globalBufferedUpdates.any();     } finally {       globalBufferLock.unlock();     }   }    public int getBufferedUpdatesTermsSize() {     globalBufferLock.lock();     try {       forceApplyGlobalSlice();       return globalBufferedUpdates.deleteTerms.size();     } finally {       globalBufferLock.unlock();     }   }    @Override   public long ramBytesUsed() {     return globalBufferedUpdates.ramBytesUsed();   }    @Override   public String toString() {     return &quot;DWDQ: [ generation: &quot; + generation + &quot; ]&quot;;   }    public long getNextSequenceNumber() {     long seqNo = nextSeqNo.getAndIncrement();     assert seqNo &lt; maxSeqNo: &quot;seqNo=&quot; + seqNo + &quot; vs maxSeqNo=&quot; + maxSeqNo;     return seqNo;   }      public long getLastSequenceNumber() {     return nextSeqNo.get()-1;   }      /** Inserts a gap in the sequence numbers.  This is used by IW during flush or commit to ensure any in-flight threads get sequence numbers    *  inside the gap */   public void skipSequenceNumbers(long jump) {     nextSeqNo.addAndGet(jump);   }   }</td>
    <td align="left">blob</td>
    <td align="left">Blob, Long Method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11272</td>
    <td align="left">https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue.java/#L71-L495</td>
    <td align="right">1</td>
    <td align="right">1553</td>
    <td align="right">11272</td>
  </tr>
  <tr valign="top">
    <td align="right">1558</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class QueryItemTreeControl extends Composite {     public static interface QueryItemDoubleClickedListener {         public void queryItemDoubleClicked(QueryItem queryItem);     }      public static interface QueryItemSelectionListener {         public void queryItemSelected(QueryItem queryItem);     }      /*      * a reference to all the projects on the server      */     private final Project[] projects;      /*      * a sorted array of the names of the currently &quot;active&quot; projects, where      * active means the user has added the project to team explorer      */     private final String[] activeProjectNames;      /*      * the tree viewer this composite is based around      */     private TreeViewer treeViewer;      /*      * used to track the currently selected query in the tree      */     private QueryItem selectedQueryItem;      private final QueryItemType itemTypes;      /*      * listener set      */     private final Set queryDoubleClickListeners =         new HashSet();     private final Set querySelectionListeners = new HashSet();      public QueryItemTreeControl(         final Composite parent,         final int style,         final TFSServer server,         final Project[] projects,         final QueryItem initialQueryItem,         final QueryItemType itemTypes) {         this(             parent,             style,             projects,             ProjectInfoHelper.getProjectNames(server.getProjectCache().getActiveTeamProjects()),             initialQueryItem,             itemTypes);     }      public QueryItemTreeControl(         final Composite parent,         final int style,         final Project[] projects,         final String[] activeProjects,         final QueryItem initialQueryItem,         final QueryItemType itemTypes) {         super(parent, style);         this.projects = projects;         selectedQueryItem = initialQueryItem;         this.itemTypes = itemTypes;          activeProjectNames = activeProjects;         Arrays.sort(activeProjectNames);          if (activeProjectNames.length &gt; 0) {             /*              * set up the tree control in this composite              */             createUI();         } else {             createNoProjectsUI();         }     }      public QueryItem getSelectedQueryItem() {         return selectedQueryItem;     }      public void addQueryItemDoubleClickedListener(final QueryItemDoubleClickedListener listener) {         synchronized (queryDoubleClickListeners) {             queryDoubleClickListeners.add(listener);         }     }      public void removeQueryItemDoubleClickedListener(final QueryItemDoubleClickedListener listener) {         synchronized (queryDoubleClickListeners) {             queryDoubleClickListeners.remove(listener);         }     }      public void addQueryItemSelectionListener(final QueryItemSelectionListener listener) {         synchronized (querySelectionListeners) {             querySelectionListeners.add(listener);         }     }      public void removeQueryItemSelectionListener(final QueryItemSelectionListener listener) {         synchronized (querySelectionListeners) {             querySelectionListeners.remove(listener);         }     }      private void createUI() {         setLayout(new FillLayout());          treeViewer = new TreeViewer(this, SWT.BORDER);         treeViewer.setContentProvider(new ContentProvider(activeProjectNames));         treeViewer.setLabelProvider(new LabelProvider());         treeViewer.addDoubleClickListener(new DoubleClickListener(treeViewer, queryDoubleClickListeners));         treeViewer.addSelectionChangedListener(new SelectionChangedListener(querySelectionListeners));          addContextMenu();          treeViewer.setInput(projects);          /*          * set the initial selection if applicable          */         if (selectedQueryItem != null) {             treeViewer.setSelection(new StructuredSelection(selectedQueryItem), true);         }     }      private void createNoProjectsUI() {         setLayout(new FillLayout());          final Label label = new Label(this, SWT.WRAP);         label.setText(Messages.getString(&quot;QueryItemTreeControl.NoTeamProjectsLabelText&quot;)); //$NON-NLS-1$     }      private void addContextMenu() {         final MenuManager menuMgr = new MenuManager(&quot;#PopUp&quot;); //$NON-NLS-1$         final IAction copyToClipboardAction = new Action() {             @Override             public void run() {                 final IStructuredSelection selection = (IStructuredSelection) treeViewer.getSelection();                 final QueryDefinition queryDefinition = (QueryDefinition) selection.getFirstElement();                 UIHelpers.copyToClipboard(queryDefinition.getQueryText());             }         };         copyToClipboardAction.setText(Messages.getString(&quot;QueryItemTreeControl.CopyWiqlToClipboard&quot;)); //$NON-NLS-1$         copyToClipboardAction.setEnabled(false);         menuMgr.add(copyToClipboardAction);          treeViewer.getControl().setMenu(menuMgr.createContextMenu(treeViewer.getControl()));          treeViewer.addSelectionChangedListener(new ISelectionChangedListener() {             @Override             public void selectionChanged(final SelectionChangedEvent event) {                 final IStructuredSelection selection = (IStructuredSelection) event.getSelection();                 final boolean enable = (selection.getFirstElement() instanceof QueryDefinition);                 copyToClipboardAction.setEnabled(enable);             }         });     }      private class SelectionChangedListener implements ISelectionChangedListener {         private final Set listeners;          public SelectionChangedListener(final Set listeners) {             this.listeners = listeners;         }          @Override         public void selectionChanged(final SelectionChangedEvent event) {             final Object selected = ((IStructuredSelection) event.getSelection()).getFirstElement();             if (selected instanceof QueryItem &amp;&amp; itemTypes.contains(((QueryItem) selected).getType())) {                 selectedQueryItem = (QueryItem) selected;             } else {                 selectedQueryItem = null;             }              synchronized (listeners) {                 for (final QueryItemSelectionListener listener : listeners) {                     listener.queryItemSelected(selectedQueryItem);                 }             }         }     }      private static class DoubleClickListener extends TreeViewerDoubleClickListener {         private final Set listeners;          public DoubleClickListener(final TreeViewer treeViewer, final Set listeners) {             super(treeViewer);             this.listeners = listeners;         }          @Override         public void doubleClick(final DoubleClickEvent event) {             super.doubleClick(event);              final Object element = ((IStructuredSelection) event.getSelection()).getFirstElement();             if (element instanceof QueryDefinition) {                 final QueryDefinition queryDefinition = (QueryDefinition) element;                 synchronized (listeners) {                     for (final QueryItemDoubleClickedListener listener : listeners) {                         listener.queryItemDoubleClicked(queryDefinition);                     }                 }             }         }     }      private class ContentProvider extends TreeContentProvider {         private final String[] activeProjectNames;          public ContentProvider(final String[] activeProjectNames) {             this.activeProjectNames = activeProjectNames;         }          @Override         public Object getParent(final Object element) {             if (element instanceof QueryHierarchy) {                 return null;             }              return ((QueryItem) element).getParent();         }          @Override         public Object[] getChildren(final Object parentElement) {             final QueryItemType displayTypes = getDisplayTypes();              if (parentElement instanceof QueryFolder) {                 final List childList = new ArrayList();                 final QueryItem[] children = ((QueryFolder) parentElement).getItems();                  for (final QueryItem child : children) {                     if (displayTypes.contains(child.getType())) {                         childList.add(child);                     }                 }                  return childList.toArray(new QueryItem[childList.size()]);             }              return null;         }          @Override         public boolean hasChildren(final Object element) {             final QueryItemType displayTypes = getDisplayTypes();              if (element instanceof QueryFolder) {                 final QueryItem[] children = ((QueryFolder) element).getItems();                  for (int i = 0; i &lt; children.length; i++) {                     if (displayTypes.contains(children[i].getType())) {                         return true;                     }                 }             }              return false;         }          private QueryItemType getDisplayTypes() {             if (itemTypes.contains(QueryItemType.QUERY_DEFINITION)) {                 return QueryItemType.ALL;             } else if (itemTypes.contains(QueryItemType.QUERY_FOLDER)) {                 return QueryItemType.ALL_FOLDERS;             }              return itemTypes;         }          @Override         public Object[] getElements(final Object inputElement) {             final Project[] projects = (Project[]) inputElement;             final List queryHierarchies = new ArrayList();              final Map availableProjects = new HashMap();             for (final Project project : projects) {                 availableProjects.put(project.getName(), project);             }              for (final String activeProjectName : activeProjectNames) {                 final Project project = availableProjects.get(activeProjectName);                 if (project != null) {                     queryHierarchies.add(project.getQueryHierarchy());                 }             }              return queryHierarchies.toArray(new QueryHierarchy[queryHierarchies.size()]);         }     }      private static class LabelProvider extends org.eclipse.jface.viewers.LabelProvider {         private final Map definitionToQueryMap =             new HashMap();         private final ImageHelper imageHelper = new ImageHelper(TFSCommonUIClientPlugin.PLUGIN_ID);          public LabelProvider() {         }          @Override         public Image getImage(final Object element) {             if (element instanceof QueryHierarchy) {                 return imageHelper.getImage(&quot;images/common/team_project.gif&quot;); //$NON-NLS-1$             }             if (element instanceof QueryFolder) {                 final QueryFolder queryFolder = (QueryFolder) element;                  if (GUID.EMPTY.getGUIDString().replaceAll(&quot;-&quot;, &quot;&quot;).equals(queryFolder.getParent().getID())) //$NON-NLS-1$ //$NON-NLS-2$                 {                     // This is a top level &quot;Team Queries&quot; / &quot;My Queries&quot; folder                     if (queryFolder.isPersonal()) {                         return imageHelper.getImage(&quot;images/wit/query_group_my.gif&quot;); //$NON-NLS-1$                     }                     return imageHelper.getImage(&quot;images/wit/query_group_team.gif&quot;); //$NON-NLS-1$                 }                  return PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_OBJ_FOLDER);             }             if (element instanceof QueryDefinition) {                 final QueryDefinition queryDefinition = (QueryDefinition) element;                  StoredQuery query = definitionToQueryMap.get(queryDefinition);                  if (query == null) {                     query = new StoredQueryImpl(                         queryDefinition.getID(),                         queryDefinition.getName(),                         queryDefinition.getQueryText(),                         queryDefinition.isPersonal() ? QueryScope.PRIVATE : QueryScope.PUBLIC,                         queryDefinition.getProject().getID(),                         (ProjectImpl) queryDefinition.getProject(),                         queryDefinition.isDeleted(),                         queryDefinition.getProject().getWITContext());                      definitionToQueryMap.put(queryDefinition, query);                 }                  if (QueryType.LIST.equals(queryDefinition.getQueryType())) {                     return imageHelper.getImage(&quot;images/wit/query_type_flat.gif&quot;); //$NON-NLS-1$                 } else if (QueryType.TREE.equals(queryDefinition.getQueryType())) {                     return imageHelper.getImage(&quot;images/wit/query_type_tree.gif&quot;); //$NON-NLS-1$                 } else if (QueryType.ONE_HOP.equals(queryDefinition.getQueryType())) {                     return imageHelper.getImage(&quot;images/wit/query_type_onehop.gif&quot;); //$NON-NLS-1$                 }                  return imageHelper.getImage(&quot;images/wit/query_type_flat_error.gif&quot;); //$NON-NLS-1$             }              return imageHelper.getImage(&quot;images/wit/query.gif&quot;); //$NON-NLS-1$         }          @Override         public String getText(final Object element) {             return ((QueryItem) element).getName();         }          @Override         public void dispose() {             imageHelper.dispose();         }     } }</td>
    <td align="left">blob</td>
    <td align="left">Blob, Long Method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11299</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.client.common.ui/src/com/microsoft/tfs/client/common/ui/wit/controls/QueryItemTreeControl.java/#L52-L416</td>
    <td align="right">1</td>
    <td align="right">1558</td>
    <td align="right">11299</td>
  </tr>
  <tr valign="top">
    <td align="right">1600</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class WebServer {     public static final Logger LOG = LoggerFactory.getLogger(WebServer.class);      private HttpServer2 httpServer;     private final HasConfig conf;      private InetSocketAddress httpAddress;     private InetSocketAddress httpsAddress;      protected static final String HAS_SERVER_ATTRIBUTE_KEY = &quot;hasserver&quot;;      public WebServer(HasConfig conf) {         this.conf = conf;     }      public HasConfig getConf() {         return conf;     }      private void init() {          final String pathSpec = &quot;/has/v1/*&quot;;          // add has packages         httpServer.addJerseyResourcePackage(AsRequestApi.class                 .getPackage().getName(),             pathSpec);     }      public void defineFilter() {         String authType = conf.getString(WebConfigKey.HAS_AUTHENTICATION_FILTER_AUTH_TYPE);         if (authType.equals(&quot;kerberos&quot;)) {             // add authentication filter for webhdfs             final String className = conf.getString(                 WebConfigKey.HAS_AUTHENTICATION_FILTER_KEY,                 WebConfigKey.HAS_AUTHENTICATION_FILTER_DEFAULT);              final String name = className;              Map params = getAuthFilterParams(conf);              String kadminPathSpec = &quot;/has/v1/kadmin/*&quot;;             String hadminPathSpec = &quot;/has/v1/hadmin/*&quot;;             HttpServer2.defineFilter(httpServer.getWebAppContext(), name, className,                 params, new String[]{kadminPathSpec, hadminPathSpec});             HttpServer2.LOG.info(&quot;Added filter '&quot; + name + &quot;' (class=&quot; + className                 + &quot;)&quot;);         }     }      public void defineConfFilter() {         String confFilterName = ConfFilter.class.getName();         String confPath = &quot;/has/v1/conf/*&quot;;         HttpServer2.defineFilter(httpServer.getWebAppContext(), confFilterName, confFilterName,                 getAuthFilterParams(conf), new String[]{confPath});         HttpServer2.LOG.info(&quot;Added filter '&quot; + confFilterName + &quot;' (class=&quot; + confFilterName                 + &quot;)&quot;);     }      private Map getAuthFilterParams(HasConfig conf) {         Map params = new HashMap&lt;&gt;();          String authType = conf.getString(WebConfigKey.HAS_AUTHENTICATION_FILTER_AUTH_TYPE);         if (authType != null &amp;&amp; !authType.isEmpty()) {             params.put(AuthenticationFilter.AUTH_TYPE, authType);         }         String principal = conf.getString(WebConfigKey.HAS_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);         if (principal != null &amp;&amp; !principal.isEmpty()) {             try {                 principal = SecurityUtil.getServerPrincipal(principal,                     getHttpsAddress().getHostName());             } catch (IOException e) {                 LOG.warn(&quot;Errors occurred when get server principal. &quot; + e.getMessage());             }             params.put(KerberosAuthenticationHandler.PRINCIPAL, principal);         }         String keytab = conf.getString(WebConfigKey.HAS_AUTHENTICATION_KERBEROS_KEYTAB_KEY);         if (keytab != null &amp;&amp; !keytab.isEmpty()) {             params.put(KerberosAuthenticationHandler.KEYTAB, keytab);         }         String rule = conf.getString(WebConfigKey.HAS_AUTHENTICATION_KERBEROS_NAME_RULES);         if (rule != null &amp;&amp; !rule.isEmpty()) {             params.put(KerberosAuthenticationHandler.NAME_RULES, rule);         } else {             params.put(KerberosAuthenticationHandler.NAME_RULES, &quot;DEFAULT&quot;);         }         return params;     }      public InetSocketAddress getBindAddress() {         if (httpAddress != null) {             return httpAddress;         } else if (httpsAddress != null) {             return httpsAddress;         } else {             return null;         }     }      /**      * for information related to the different configuration options and      * Http Policy is decided.      *      * @throws HasException HAS exception when starting web server      */     public void start() throws HasException {          HttpConfig.Policy policy = getHttpPolicy(conf);          final String bindHost =             conf.getString(WebConfigKey.HAS_HTTPS_BIND_HOST_KEY);         InetSocketAddress httpAddr = null;         if (policy.isHttpEnabled()) {             final String httpAddrString = conf.getString(                 WebConfigKey.HAS_HTTP_ADDRESS_KEY,                 WebConfigKey.HAS_HTTP_ADDRESS_DEFAULT);             httpAddr = NetUtils.createSocketAddr(httpAddrString);             if (bindHost != null &amp;&amp; !bindHost.isEmpty()) {                 httpAddr = new InetSocketAddress(bindHost, httpAddr.getPort());             }             LOG.info(&quot;Get the http address: &quot; + httpAddr);         }          InetSocketAddress httpsAddr = null;         if (policy.isHttpsEnabled()) {             final String httpsAddrString = conf.getString(                 WebConfigKey.HAS_HTTPS_ADDRESS_KEY,                 WebConfigKey.HAS_HTTPS_ADDRESS_DEFAULT);             httpsAddr = NetUtils.createSocketAddr(httpsAddrString);              if (bindHost != null &amp;&amp; !bindHost.isEmpty()) {                 httpsAddr = new InetSocketAddress(bindHost, httpsAddr.getPort());             }             LOG.info(&quot;Get the https address: &quot; + httpsAddr);         }          HttpServer2.Builder builder = httpServerTemplateForHAS(conf, httpAddr, httpsAddr, &quot;has&quot;);          try {             httpServer = builder.build();         } catch (IOException e) {             throw new HasException(&quot;Errors occurred when building http server. &quot; + e.getMessage());         }          init();          try {             httpServer.start();         } catch (IOException e) {             throw new HasException(&quot;Errors occurred when starting http server. &quot; + e.getMessage());         }         int connIdx = 0;         if (policy.isHttpEnabled()) {             httpAddress = httpServer.getConnectorAddress(connIdx++);             if (httpAddress != null) {                 conf.setString(WebConfigKey.HAS_HTTP_ADDRESS_KEY,                     NetUtils.getHostPortString(httpAddress));             }         }          if (policy.isHttpsEnabled()) {             httpsAddress = httpServer.getConnectorAddress(connIdx);             if (httpsAddress != null) {                 conf.setString(WebConfigKey.HAS_HTTPS_ADDRESS_KEY,                     NetUtils.getHostPortString(httpsAddress));             }         }     }      public void setWebServerAttribute(HasServer hasServer) {         httpServer.setAttribute(HAS_SERVER_ATTRIBUTE_KEY, hasServer);     }      public static HasServer getHasServerFromContext(ServletContext context) {         return (HasServer) context.getAttribute(HAS_SERVER_ATTRIBUTE_KEY);     }      /**      * Get http policy.      *      * @param conf the HAS config      * @return HttpConfig.Policy the policy      */     public HttpConfig.Policy getHttpPolicy(HasConfig conf) {         String policyStr = conf.getString(WebConfigKey.HAS_HTTP_POLICY_KEY,             WebConfigKey.HAS_HTTP_POLICY_DEFAULT);         HttpConfig.Policy policy = HttpConfig.Policy.fromString(policyStr);         if (policy == null) {             throw new HadoopIllegalArgumentException(&quot;Unrecognized value '&quot;                 + policyStr + &quot;' for &quot; + WebConfigKey.HAS_HTTP_POLICY_KEY);         }          conf.setString(WebConfigKey.HAS_HTTP_POLICY_KEY, policy.name());         return policy;     }      /**      * Return a HttpServer.Builder that the HAS can use to      * initialize their HTTP / HTTPS server.      *      * @param conf the HAS config      * @param httpAddr the InetSocketAddress of http      * @param httpsAddr the InetSocketAddress of https      * @param name the host name      * @return HttpServer2.Builder the builder      * @throws HasException HAS exception      */     public HttpServer2.Builder httpServerTemplateForHAS(         HasConfig conf, final InetSocketAddress httpAddr, final InetSocketAddress httpsAddr,         String name) throws HasException {         HttpConfig.Policy policy = getHttpPolicy(conf);          HttpServer2.Builder builder = new HttpServer2.Builder().setName(name);          if (policy.isHttpEnabled()) {             if (httpAddr != null &amp;&amp; httpAddr.getPort() == 0) {                 builder.setFindPort(true);             }              URI uri = URI.create(&quot;http://&quot; + NetUtils.getHostPortString(httpAddr));             builder.addEndpoint(uri);             LOG.info(&quot;Starting Web-server for &quot; + name + &quot; at: &quot; + uri);         }          if (policy.isHttpsEnabled() &amp;&amp; httpsAddr != null) {             HasConfig sslConf = loadSslConfiguration(conf);             loadSslConfToHttpServerBuilder(builder, sslConf);              if (httpsAddr != null &amp;&amp; httpsAddr.getPort() == 0) {                 builder.setFindPort(true);             }              URI uri = URI.create(&quot;https://&quot; + NetUtils.getHostPortString(httpsAddr));             builder.addEndpoint(uri);             LOG.info(&quot;Starting Web-server for &quot; + name + &quot; at: &quot; + uri);         }          return builder;     }      /**      * Load HTTPS-related configuration.      *      * @param conf HAS config      * @return HasConfig after loading ssl configuration      * @throws HasException HAS exception when loading HTTPS related configuration      */     public HasConfig loadSslConfiguration(HasConfig conf) throws HasException {         HasConfig sslConf = new HasConfig();          String sslConfigString = conf.getString(             WebConfigKey.HAS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,             WebConfigKey.HAS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT);         LOG.info(&quot;Get the ssl config file: &quot; + sslConfigString);         File sslConfig = new File(sslConfigString);         if (!sslConfig.exists()) {             throw new HasException(&quot;The ssl server config file &quot;                 + sslConfigString + &quot; does not exist.&quot;);         }         try {             sslConf.addIniConfig(sslConfig);         } catch (IOException e) {             throw new HasException(&quot;Errors occurred when adding config. &quot; + e.getMessage());         }          final String[] reqSslProps = {             WebConfigKey.HAS_SERVER_HTTPS_TRUSTSTORE_LOCATION_KEY,             WebConfigKey.HAS_SERVER_HTTPS_KEYSTORE_LOCATION_KEY,             WebConfigKey.HAS_SERVER_HTTPS_KEYSTORE_PASSWORD_KEY,             WebConfigKey.HAS_SERVER_HTTPS_KEYPASSWORD_KEY         };          // Check if the required properties are included         for (String sslProp : reqSslProps) {             if (sslConf.getString(sslProp) == null) {                 LOG.warn(&quot;SSL config &quot; + sslProp + &quot; is missing. If &quot;                     + WebConfigKey.HAS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY                     + &quot; is specified, make sure it is a relative path&quot;);             }         }          boolean requireClientAuth = conf.getBoolean(WebConfigKey.HAS_CLIENT_HTTPS_NEED_AUTH_KEY,             WebConfigKey.HAS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);         sslConf.setBoolean(WebConfigKey.HAS_CLIENT_HTTPS_NEED_AUTH_KEY, requireClientAuth);         return sslConf;     }      public HttpServer2.Builder loadSslConfToHttpServerBuilder(HttpServer2.Builder builder,                                                               HasConfig sslConf) {         return builder             .needsClientAuth(                 sslConf.getBoolean(WebConfigKey.HAS_CLIENT_HTTPS_NEED_AUTH_KEY,                     WebConfigKey.HAS_CLIENT_HTTPS_NEED_AUTH_DEFAULT))             .keyPassword(getPassword(sslConf, WebConfigKey.HAS_SERVER_HTTPS_KEYPASSWORD_KEY))             .keyStore(sslConf.getString(&quot;ssl.server.keystore.location&quot;),                 getPassword(sslConf, WebConfigKey.HAS_SERVER_HTTPS_KEYSTORE_PASSWORD_KEY),                 sslConf.getString(&quot;ssl.server.keystore.type&quot;, &quot;jks&quot;))             .trustStore(sslConf.getString(&quot;ssl.server.truststore.location&quot;),                 getPassword(sslConf, WebConfigKey.HAS_SERVER_HTTPS_TRUSTSTORE_PASSWORD_KEY),                 sslConf.getString(&quot;ssl.server.truststore.type&quot;, &quot;jks&quot;))             .excludeCiphers(                 sslConf.getString(&quot;ssl.server.exclude.cipher.list&quot;));     }      /**      * Leverages the Configuration.getPassword method to attempt to get      * passwords from the CredentialProvider API before falling back to      * clear text in config - if falling back is allowed.      *      * @param conf  Configuration instance      * @param alias name of the credential to retreive      * @return String credential value or null      */     public String getPassword(HasConfig conf, String alias) {          return conf.getString(alias);     }      public void stop() throws Exception {         if (httpServer != null) {             httpServer.stop();         }     }      public InetSocketAddress getHttpAddress() {         return httpAddress;     }      public InetSocketAddress getHttpsAddress() {         return httpsAddress;     } }</td>
    <td align="left">blob</td>
    <td align="left">Long Method, Blob, Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">Long Method,  Data Class</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11427</td>
    <td align="left">https://github.com/apache/directory-kerby/blob/19fa650424f60d23d1c1bf0af4bb80ffcb8d8843/has-project/has-server/src/main/java/org/apache/kerby/has/server/web/WebServer.java/#L43-L374</td>
    <td align="right">1</td>
    <td align="right">1600</td>
    <td align="right">11427</td>
  </tr>
  <tr valign="top">
    <td align="right">1606</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;1. Blob&quot;, &quot;2. Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class OperatorWrapper {   @SuppressWarnings(&quot;unused&quot;)   private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(OperatorWrapper.class);    private static final DecimalFormat DECIMAL_FORMATTER = new DecimalFormat(&quot;#.##&quot;);   private static final String UNKNOWN_OPERATOR = &quot;UNKNOWN_OPERATOR&quot;;   //Negative valued constant used for denoting invalid index to indicate absence of metric   private static final int NO_SPILL_METRIC_INDEX = Integer.MIN_VALUE;   private final int major;   private final List, String&gt;&gt; opsAndHosts; // [(operatorProfile --&gt; minorFragment number,host), ...]   private final OperatorProfile firstProfile;   private final CoreOperatorType operatorType;   private final String operatorName;   private final int size;   private final int timeSkewMin;   private final double timeSkewRatio;   private final int scanWaitMin;   private final double waitSkewRatio;    public OperatorWrapper(int major, List, String&gt;&gt; opsAndHostsList, Map phyOperMap, DrillConfig config) {     //Threshold to track if the slowest operator ran relatively slow     timeSkewMin = config.getInt(ExecConstants.PROFILE_WARNING_TIME_SKEW_MIN);     timeSkewRatio = config.getDouble(ExecConstants.PROFILE_WARNING_TIME_SKEW_RATIO_PROCESS);     //Threshold to track if the slowest SCAN operator spent more time in wait than processing     scanWaitMin = config.getInt(ExecConstants.PROFILE_WARNING_SCAN_WAIT_MIN);     waitSkewRatio = config.getDouble(ExecConstants.PROFILE_WARNING_TIME_SKEW_RATIO_WAIT);      Preconditions.checkArgument(opsAndHostsList.size() &gt; 0);     this.major = major;     firstProfile = opsAndHostsList.get(0).getLeft().getLeft();     operatorType = CoreOperatorType.valueOf(firstProfile.getOperatorType());     //Update Name from Physical Map     String path = new OperatorPathBuilder().setMajor(major).setOperator(firstProfile).build();     //Use Plan Extracted Operator Names if available     String extractedOpName = phyOperMap.get(path);     String inferredOpName = operatorType == null ? UNKNOWN_OPERATOR : operatorType.toString();     //Revert to inferred names for exceptional cases     // 1. Extracted 'FLATTEN' operator is NULL     // 2. Extracted 'SCAN' could be a PARQUET_ROW_GROUP_SCAN, or KAFKA_SUB_SCAN, or etc.     // 3. Extracted 'UNION_EXCHANGE' could be a SINGLE_SENDER or UNORDERED_RECEIVER     if (extractedOpName == null || inferredOpName.contains(extractedOpName) || extractedOpName.endsWith(&quot;_EXCHANGE&quot;)) {       operatorName =  inferredOpName;     } else {       operatorName =  extractedOpName;     }     this.opsAndHosts = opsAndHostsList;     size = opsAndHostsList.size();   }    public String getDisplayName() {     final String path = new OperatorPathBuilder().setMajor(major).setOperator(firstProfile).build();     return String.format(&quot;%s - %s&quot;, path, operatorName);   }    public String getId() {     return String.format(&quot;operator-%d-%d&quot;, major, opsAndHosts.get(0).getLeft().getLeft().getOperatorId());   }    public static final String [] OPERATOR_COLUMNS = {       OperatorTblTxt.MINOR_FRAGMENT, OperatorTblTxt.HOSTNAME, OperatorTblTxt.SETUP_TIME, OperatorTblTxt.PROCESS_TIME, OperatorTblTxt.WAIT_TIME,       OperatorTblTxt.MAX_BATCHES, OperatorTblTxt.MAX_RECORDS, OperatorTblTxt.PEAK_MEMORY   };    public static final String [] OPERATOR_COLUMNS_TOOLTIP = {       OperatorTblTooltip.MINOR_FRAGMENT, OperatorTblTooltip.HOSTNAME, OperatorTblTooltip.SETUP_TIME, OperatorTblTooltip.PROCESS_TIME, OperatorTblTooltip.WAIT_TIME,       OperatorTblTooltip.MAX_BATCHES, OperatorTblTooltip.MAX_RECORDS, OperatorTblTooltip.PEAK_MEMORY   };    public String getContent() {     TableBuilder builder = new TableBuilder(OPERATOR_COLUMNS, OPERATOR_COLUMNS_TOOLTIP, true);      Map attributeMap = new HashMap&lt;&gt;(); //Reusing for different fragments     for (ImmutablePair, String&gt; ip : opsAndHosts) {       int minor = ip.getLeft().getRight();       OperatorProfile op = ip.getLeft().getLeft();        attributeMap.put(HtmlAttribute.DATA_ORDER, String.valueOf(minor)); //Overwrite values from previous fragments       String path = new OperatorPathBuilder().setMajor(major).setMinor(minor).setOperator(op).build();       builder.appendCell(path, attributeMap);       builder.appendCell(ip.getRight());       builder.appendNanos(op.getSetupNanos());       builder.appendNanos(op.getProcessNanos());       builder.appendNanos(op.getWaitNanos());        long maxBatches = Long.MIN_VALUE;       long maxRecords = Long.MIN_VALUE;       for (StreamProfile sp : op.getInputProfileList()) {         maxBatches = Math.max(sp.getBatches(), maxBatches);         maxRecords = Math.max(sp.getRecords(), maxRecords);       }        builder.appendFormattedInteger(maxBatches);       builder.appendFormattedInteger(maxRecords);       builder.appendBytes(op.getPeakLocalMemoryAllocated());     }     return builder.build();   }    public static final String[] OPERATORS_OVERVIEW_COLUMNS = {       OverviewTblTxt.OPERATOR_ID, OverviewTblTxt.TYPE_OF_OPERATOR,       OverviewTblTxt.AVG_SETUP_TIME, OverviewTblTxt.MAX_SETUP_TIME,       OverviewTblTxt.AVG_PROCESS_TIME, OverviewTblTxt.MAX_PROCESS_TIME,       OverviewTblTxt.MIN_WAIT_TIME, OverviewTblTxt.AVG_WAIT_TIME, OverviewTblTxt.MAX_WAIT_TIME,       OverviewTblTxt.PERCENT_FRAGMENT_TIME, OverviewTblTxt.PERCENT_QUERY_TIME, OverviewTblTxt.ROWS,       OverviewTblTxt.AVG_PEAK_MEMORY, OverviewTblTxt.MAX_PEAK_MEMORY   };    public static final String[] OPERATORS_OVERVIEW_COLUMNS_TOOLTIP = {       OverviewTblTooltip.OPERATOR_ID, OverviewTblTooltip.TYPE_OF_OPERATOR,       OverviewTblTooltip.AVG_SETUP_TIME, OverviewTblTooltip.MAX_SETUP_TIME,       OverviewTblTooltip.AVG_PROCESS_TIME, OverviewTblTooltip.MAX_PROCESS_TIME,       OverviewTblTooltip.MIN_WAIT_TIME, OverviewTblTooltip.AVG_WAIT_TIME, OverviewTblTooltip.MAX_WAIT_TIME,       OverviewTblTooltip.PERCENT_FRAGMENT_TIME, OverviewTblTooltip.PERCENT_QUERY_TIME, OverviewTblTooltip.ROWS,       OverviewTblTooltip.AVG_PEAK_MEMORY, OverviewTblTooltip.MAX_PEAK_MEMORY   };    //Palette to help shade operators sharing a common major fragment   private static final String[] OPERATOR_OVERVIEW_BGCOLOR_PALETTE = {&quot;#ffffff&quot;,&quot;#f2f2f2&quot;};    public void addSummary(TableBuilder tb, Map majorFragmentBusyTally, long majorFragmentBusyTallyTotal) {     //Select background color from palette     String opTblBgColor = OPERATOR_OVERVIEW_BGCOLOR_PALETTE[major%OPERATOR_OVERVIEW_BGCOLOR_PALETTE.length];     String path = new OperatorPathBuilder().setMajor(major).setOperator(firstProfile).build();     tb.appendCell(path, opTblBgColor, null);     tb.appendCell(operatorName);      //Check if spill information is available     int spillCycleMetricIndex = getSpillCycleMetricIndex(operatorType);     boolean isSpillableOp = (spillCycleMetricIndex != NO_SPILL_METRIC_INDEX);     boolean hasSpilledToDisk = false;     boolean isScanOp = operatorName.endsWith(&quot;SCAN&quot;);      //Get MajorFragment Busy+Wait Time Tally     long majorBusyNanos = majorFragmentBusyTally.get(new OperatorPathBuilder().setMajor(major).build());      double setupSum = 0.0;     double processSum = 0.0;     double waitSum = 0.0;     double memSum = 0.0;     double spillCycleSum = 0.0;     long spillCycleMax = 0L;     long recordSum = 0L;      //Construct list for sorting purposes (using legacy Comparators)     final List&gt; opList = new ArrayList&lt;&gt;();      for (ImmutablePair,String&gt; ip : opsAndHosts) {       OperatorProfile profile = ip.getLeft().getLeft();       setupSum += profile.getSetupNanos();       processSum += profile.getProcessNanos();       waitSum += profile.getWaitNanos();       memSum += profile.getPeakLocalMemoryAllocated();       for (final StreamProfile sp : profile.getInputProfileList()) {         recordSum += sp.getRecords();       }       opList.add(ip.getLeft());        //Capture Spill Info       //Check to ensure index &lt; #metrics (old profiles have less metrics); else reset isSpillableOp       if (isSpillableOp) {         //NOTE: We get non-zero value for non-existent metrics, so we can't use getMetric(index)         //profile.getMetric(spillCycleMetricIndex).getLongValue();         //Forced to iterate list         for (MetricValue metricVal : profile.getMetricList()) {           if (metricVal.getMetricId() == spillCycleMetricIndex) {             long spillCycles = metricVal.getLongValue();             spillCycleMax = Math.max(spillCycles, spillCycleMax);             spillCycleSum += spillCycles;             hasSpilledToDisk = (spillCycleSum &gt; 0.0);           }         }       }     }      final ImmutablePair longSetup = Collections.max(opList, Comparators.setupTime);     tb.appendNanos(Math.round(setupSum / size));     tb.appendNanos(longSetup.getLeft().getSetupNanos());      Map timeSkewMap = null;     final ImmutablePair longProcess = Collections.max(opList, Comparators.processTime);     //Calculating average processing time     long avgProcTime = Math.round(processSum / size);     tb.appendNanos(avgProcTime);     long maxProcTime = longProcess.getLeft().getProcessNanos();     //Calculating skew of longest processing fragment w.r.t. average     double maxSkew = (avgProcTime &gt; 0) ? maxProcTime/Double.valueOf(avgProcTime) : 0.0d;     //Marking skew if both thresholds are crossed     if (avgProcTime &gt; TimeUnit.SECONDS.toNanos(timeSkewMin) &amp;&amp; maxSkew &gt; timeSkewRatio ) {       timeSkewMap = new HashMap&lt;&gt;();       timeSkewMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_TIME_SKEW_TAG);       timeSkewMap.put(HtmlAttribute.TITLE,  &quot;One fragment took &quot; + DECIMAL_FORMATTER.format(maxSkew) + &quot; longer than average&quot;);       timeSkewMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);     }     tb.appendNanos(maxProcTime, timeSkewMap);      final ImmutablePair shortWait = Collections.min(opList, Comparators.waitTime);     final ImmutablePair longWait = Collections.max(opList, Comparators.waitTime);     tb.appendNanos(shortWait.getLeft().getWaitNanos());     //Calculating average wait time for fragment     long avgWaitTime = Math.round(waitSum / size);      //Slow Scan Warning     Map slowScanMap = null;     //Marking slow scan if threshold is crossed and wait was longer than processing     if (isScanOp &amp;&amp; (avgWaitTime &gt; TimeUnit.SECONDS.toNanos(scanWaitMin)) &amp;&amp; (avgWaitTime &gt; avgProcTime)) {       slowScanMap = new HashMap&lt;&gt;();       slowScanMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_SCAN_WAIT_TAG);       slowScanMap.put(HtmlAttribute.TITLE, &quot;Avg Wait Time &gt; Avg Processing Time&quot;);       slowScanMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);     }     tb.appendNanos(avgWaitTime, slowScanMap);      long maxWaitTime = longWait.getLeft().getWaitNanos();     //Skewed Wait Warning     timeSkewMap = null; //Resetting     //Calculating skew of longest waiting fragment w.r.t. average     maxSkew = (avgWaitTime &gt; 0) ? maxWaitTime/Double.valueOf(avgWaitTime) : 0.0d;     //Marking skew if both thresholds are crossed     if (avgWaitTime &gt; TimeUnit.SECONDS.toNanos(timeSkewMin) &amp;&amp; maxSkew &gt; waitSkewRatio) {       timeSkewMap = new HashMap&lt;&gt;();       timeSkewMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_TIME_SKEW_TAG);       timeSkewMap.put(HtmlAttribute.TITLE, &quot;One fragment waited &quot; + DECIMAL_FORMATTER.format(maxSkew) + &quot; longer than average&quot;);       timeSkewMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);     }     tb.appendNanos(maxWaitTime, timeSkewMap);      tb.appendPercent(processSum / majorBusyNanos);     tb.appendPercent(processSum / majorFragmentBusyTallyTotal);      tb.appendFormattedInteger(recordSum);      final ImmutablePair peakMem = Collections.max(opList, Comparators.operatorPeakMemory);      //Inject spill-to-disk attributes     Map avgSpillMap = null;     Map maxSpillMap = null;     if (hasSpilledToDisk) {       avgSpillMap = new HashMap&lt;&gt;();       //Average SpillCycle       double avgSpillCycle = spillCycleSum/size;       avgSpillMap.put(HtmlAttribute.TITLE, DECIMAL_FORMATTER.format(avgSpillCycle) + &quot; spills on average&quot;);       avgSpillMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);       avgSpillMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_SPILL_TAG); //JScript will inject Icon       avgSpillMap.put(HtmlAttribute.SPILLS, DECIMAL_FORMATTER.format(avgSpillCycle)); //JScript will inject Count       maxSpillMap = new HashMap&lt;&gt;();       maxSpillMap.put(HtmlAttribute.TITLE, &quot;Most # spills: &quot; + spillCycleMax);       maxSpillMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);       maxSpillMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_SPILL_TAG); //JScript will inject Icon       maxSpillMap.put(HtmlAttribute.SPILLS, String.valueOf(spillCycleMax)); //JScript will inject Count     }      tb.appendBytes(Math.round(memSum / size), avgSpillMap);     tb.appendBytes(peakMem.getLeft().getPeakLocalMemoryAllocated(), maxSpillMap);   }    /**    * Returns index of Spill Count/Cycle metric    * @param operatorType    * @return index of spill metric    */   private int getSpillCycleMetricIndex(CoreOperatorType operatorType) {     // TODO: DRILL-6642, replace null values for ProtocolMessageEnum with UNRECOGNIZED NullValue to avoid null checks     if (operatorType == null) {       return NO_SPILL_METRIC_INDEX;     }     String metricName;      switch (operatorType) {     case EXTERNAL_SORT:       metricName = &quot;SPILL_COUNT&quot;;       break;     case HASH_AGGREGATE:     case HASH_JOIN:       metricName = &quot;SPILL_CYCLE&quot;;       break;     default:       return NO_SPILL_METRIC_INDEX;     }      int metricIndex = 0; //Default     String[] metricNames = OperatorMetricRegistry.getMetricNames(operatorType.getNumber());     for (String name : metricNames) {       if (name.equalsIgnoreCase(metricName)) {         return metricIndex;       }       metricIndex++;     }     //Backward compatibility with rendering older profiles. Ideally we should never touch this if an expected metric is not there     return NO_SPILL_METRIC_INDEX;   }    public String getMetricsTable() {     if (operatorType == null) {       return &quot;&quot;;     }     final String[] metricNames = OperatorMetricRegistry.getMetricNames(operatorType.getNumber());     if (metricNames == null) {       return &quot;&quot;;     }      final String[] metricsTableColumnNames = new String[metricNames.length + 1];     metricsTableColumnNames[0] = &quot;Minor Fragment&quot;;     int i = 1;     for (final String metricName : metricNames) {       metricsTableColumnNames[i++] = metricName;     }     final TableBuilder builder = new TableBuilder(metricsTableColumnNames, null);      for (final ImmutablePair,String&gt; ip : opsAndHosts) {       final OperatorProfile op = ip.getLeft().getLeft();        builder.appendCell(           new OperatorPathBuilder()           .setMajor(major)           .setMinor(ip.getLeft().getRight())           .setOperator(op)           .build());        final Number[] values = new Number[metricNames.length];       //Track new/Unknown Metrics       final Set unknownMetrics = new TreeSet&lt;&gt;();       for (final MetricValue metric : op.getMetricList()) {         if (metric.getMetricId() &lt; metricNames.length) {           if (metric.hasLongValue()) {             values[metric.getMetricId()] = metric.getLongValue();           } else if (metric.hasDoubleValue()) {             values[metric.getMetricId()] = metric.getDoubleValue();           }         } else {           //Tracking unknown metric IDs           unknownMetrics.add(metric.getMetricId());         }       }       for (final Number value : values) {         if (value != null) {           builder.appendFormattedNumber(value);         } else {           builder.appendCell(&quot;&quot;);         }       }     }     return builder.build();   }    private class OperatorTblTxt {     static final String MINOR_FRAGMENT = &quot;Minor Fragment&quot;;     static final String HOSTNAME = &quot;Hostname&quot;;     static final String SETUP_TIME = &quot;Setup Time&quot;;     static final String PROCESS_TIME = &quot;Process Time&quot;;     static final String WAIT_TIME = &quot;Wait Time&quot;;     static final String MAX_BATCHES = &quot;Max Batches&quot;;     static final String MAX_RECORDS = &quot;Max Records&quot;;     static final String PEAK_MEMORY = &quot;Peak Memory&quot;;   }    private class OperatorTblTooltip {     static final String MINOR_FRAGMENT = &quot;Operator's Minor Fragment&quot;;     static final String HOSTNAME = &quot;Host on which the minor fragment ran&quot;;     static final String SETUP_TIME = &quot;Setup Time for the minor fragment's operator&quot;;     static final String PROCESS_TIME = &quot;Process Time for the minor fragment's operator&quot;;     static final String WAIT_TIME = &quot;Wait Time for the minor fragment's operator&quot;;     static final String MAX_BATCHES = &quot;Max Batches processed by the minor fragment's operator&quot;;     static final String MAX_RECORDS = &quot;Max Records processed by the minor fragment's operator&quot;;     static final String PEAK_MEMORY = &quot;Peak Memory usage by the minor fragment's operator&quot;;   }    private class OverviewTblTxt {     static final String OPERATOR_ID = &quot;Operator ID&quot;;     static final String TYPE_OF_OPERATOR = &quot;Type&quot;;     static final String AVG_SETUP_TIME = &quot;Avg Setup Time&quot;;     static final String MAX_SETUP_TIME = &quot;Max Setup Time&quot;;     static final String AVG_PROCESS_TIME = &quot;Avg Process Time&quot;;     static final String MAX_PROCESS_TIME = &quot;Max Process Time&quot;;     static final String MIN_WAIT_TIME = &quot;Min Wait Time&quot;;     static final String AVG_WAIT_TIME = &quot;Avg Wait Time&quot;;     static final String MAX_WAIT_TIME = &quot;Max Wait Time&quot;;     static final String PERCENT_FRAGMENT_TIME = &quot;% Fragment Time&quot;;     static final String PERCENT_QUERY_TIME = &quot;% Query Time&quot;;     static final String ROWS = &quot;Rows&quot;;     static final String AVG_PEAK_MEMORY = &quot;Avg Peak Memory&quot;;     static final String MAX_PEAK_MEMORY = &quot;Max Peak Memory&quot;;   }    private class OverviewTblTooltip {     static final String OPERATOR_ID = &quot;Operator ID&quot;;     static final String TYPE_OF_OPERATOR = &quot;Operator Type&quot;;     static final String AVG_SETUP_TIME = &quot;Average time in setting up fragments&quot;;     static final String MAX_SETUP_TIME = &quot;Longest time a fragment took in setup&quot;;     static final String AVG_PROCESS_TIME = &quot;Average process time for a fragment&quot;;     static final String MAX_PROCESS_TIME = &quot;Longest process time of any fragment&quot;;     static final String MIN_WAIT_TIME = &quot;Shortest time a fragment spent in waiting&quot;;     static final String AVG_WAIT_TIME = &quot;Average wait time for a fragment&quot;;     static final String MAX_WAIT_TIME = &quot;Longest time a fragment spent in waiting&quot;;     static final String PERCENT_FRAGMENT_TIME = &quot;Percentage of the total fragment time that was spent on the operator&quot;;     static final String PERCENT_QUERY_TIME = &quot;Percentage of the total query time that was spent on the operator&quot;;     static final String ROWS = &quot;Rows emitted by scans, or consumed by other operators&quot;;     static final String AVG_PEAK_MEMORY  =  &quot;Average memory consumption by a fragment&quot;;     static final String MAX_PEAK_MEMORY  =  &quot;Highest memory consumption by a fragment&quot;;   } }</td>
    <td align="left">blob</td>
    <td align="left">1. blob, 2. long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;2. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11448</td>
    <td align="left">https://github.com/apache/drill/blob/5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3/exec/java-exec/src/main/java/org/apache/drill/exec/server/rest/profile/OperatorWrapper.java/#L43-L442</td>
    <td align="right">1</td>
    <td align="right">1606</td>
    <td align="right">11448</td>
  </tr>
  <tr valign="top">
    <td align="right">1616</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static final class Builder extends         com.google.protobuf.GeneratedMessage.Builder implements         // @@protoc_insertion_point(builder_implements:com.alibaba.otter.canal.protocol.RowChange)         RowChangeOrBuilder {       public static final com.google.protobuf.Descriptors.Descriptor           getDescriptor() {         return CanalEntry.internal_static_com_alibaba_otter_canal_protocol_RowChange_descriptor;       }        protected FieldAccessorTable           internalGetFieldAccessorTable() {         return CanalEntry.internal_static_com_alibaba_otter_canal_protocol_RowChange_fieldAccessorTable             .ensureFieldAccessorsInitialized(                 RowChange.class, Builder.class);       }        // Construct using com.alibaba.otter.canal.protocol.CanalEntry.RowChange.newBuilder()       private Builder() {         maybeForceBuilderInitialization();       }        private Builder(           BuilderParent parent) {         super(parent);         maybeForceBuilderInitialization();       }       private void maybeForceBuilderInitialization() {         if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {           getRowDatasFieldBuilder();           getPropsFieldBuilder();         }       }       private static Builder create() {         return new Builder();       }        public Builder clear() {         super.clear();         tableId_ = 0L;         bitField0_ = (bitField0_ &amp; ~0x00000001);         eventType_ = EventType.UPDATE;         bitField0_ = (bitField0_ &amp; ~0x00000002);         isDdl_ = false;         bitField0_ = (bitField0_ &amp; ~0x00000004);         sql_ = &quot;&quot;;         bitField0_ = (bitField0_ &amp; ~0x00000008);         if (rowDatasBuilder_ == null) {           rowDatas_ = java.util.Collections.emptyList();           bitField0_ = (bitField0_ &amp; ~0x00000010);         } else {           rowDatasBuilder_.clear();         }         if (propsBuilder_ == null) {           props_ = java.util.Collections.emptyList();           bitField0_ = (bitField0_ &amp; ~0x00000020);         } else {           propsBuilder_.clear();         }         ddlSchemaName_ = &quot;&quot;;         bitField0_ = (bitField0_ &amp; ~0x00000040);         return this;       }        public Builder clone() {         return create().mergeFrom(buildPartial());       }        public com.google.protobuf.Descriptors.Descriptor           getDescriptorForType() {         return CanalEntry.internal_static_com_alibaba_otter_canal_protocol_RowChange_descriptor;       }        public RowChange getDefaultInstanceForType() {         return RowChange.getDefaultInstance();       }        public RowChange build() {         RowChange result = buildPartial();         if (!result.isInitialized()) {           throw newUninitializedMessageException(result);         }         return result;       }        public RowChange buildPartial() {         RowChange result = new RowChange(this);         int from_bitField0_ = bitField0_;         int to_bitField0_ = 0;         if (((from_bitField0_ &amp; 0x00000001) == 0x00000001)) {           to_bitField0_ |= 0x00000001;         }         result.tableId_ = tableId_;         if (((from_bitField0_ &amp; 0x00000002) == 0x00000002)) {           to_bitField0_ |= 0x00000002;         }         result.eventType_ = eventType_;         if (((from_bitField0_ &amp; 0x00000004) == 0x00000004)) {           to_bitField0_ |= 0x00000004;         }         result.isDdl_ = isDdl_;         if (((from_bitField0_ &amp; 0x00000008) == 0x00000008)) {           to_bitField0_ |= 0x00000008;         }         result.sql_ = sql_;         if (rowDatasBuilder_ == null) {           if (((bitField0_ &amp; 0x00000010) == 0x00000010)) {             rowDatas_ = java.util.Collections.unmodifiableList(rowDatas_);             bitField0_ = (bitField0_ &amp; ~0x00000010);           }           result.rowDatas_ = rowDatas_;         } else {           result.rowDatas_ = rowDatasBuilder_.build();         }         if (propsBuilder_ == null) {           if (((bitField0_ &amp; 0x00000020) == 0x00000020)) {             props_ = java.util.Collections.unmodifiableList(props_);             bitField0_ = (bitField0_ &amp; ~0x00000020);           }           result.props_ = props_;         } else {           result.props_ = propsBuilder_.build();         }         if (((from_bitField0_ &amp; 0x00000040) == 0x00000040)) {           to_bitField0_ |= 0x00000010;         }         result.ddlSchemaName_ = ddlSchemaName_;         result.bitField0_ = to_bitField0_;         onBuilt();         return result;       }        public Builder mergeFrom(com.google.protobuf.Message other) {         if (other instanceof RowChange) {           return mergeFrom((RowChange)other);         } else {           super.mergeFrom(other);           return this;         }       }        public Builder mergeFrom(RowChange other) {         if (other == RowChange.getDefaultInstance()) return this;         if (other.hasTableId()) {           setTableId(other.getTableId());         }         if (other.hasEventType()) {           setEventType(other.getEventType());         }         if (other.hasIsDdl()) {           setIsDdl(other.getIsDdl());         }         if (other.hasSql()) {           bitField0_ |= 0x00000008;           sql_ = other.sql_;           onChanged();         }         if (rowDatasBuilder_ == null) {           if (!other.rowDatas_.isEmpty()) {             if (rowDatas_.isEmpty()) {               rowDatas_ = other.rowDatas_;               bitField0_ = (bitField0_ &amp; ~0x00000010);             } else {               ensureRowDatasIsMutable();               rowDatas_.addAll(other.rowDatas_);             }             onChanged();           }         } else {           if (!other.rowDatas_.isEmpty()) {             if (rowDatasBuilder_.isEmpty()) {               rowDatasBuilder_.dispose();               rowDatasBuilder_ = null;               rowDatas_ = other.rowDatas_;               bitField0_ = (bitField0_ &amp; ~0x00000010);               rowDatasBuilder_ =                 com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?                    getRowDatasFieldBuilder() : null;             } else {               rowDatasBuilder_.addAllMessages(other.rowDatas_);             }           }         }         if (propsBuilder_ == null) {           if (!other.props_.isEmpty()) {             if (props_.isEmpty()) {               props_ = other.props_;               bitField0_ = (bitField0_ &amp; ~0x00000020);             } else {               ensurePropsIsMutable();               props_.addAll(other.props_);             }             onChanged();           }         } else {           if (!other.props_.isEmpty()) {             if (propsBuilder_.isEmpty()) {               propsBuilder_.dispose();               propsBuilder_ = null;               props_ = other.props_;               bitField0_ = (bitField0_ &amp; ~0x00000020);               propsBuilder_ =                 com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?                    getPropsFieldBuilder() : null;             } else {               propsBuilder_.addAllMessages(other.props_);             }           }         }         if (other.hasDdlSchemaName()) {           bitField0_ |= 0x00000040;           ddlSchemaName_ = other.ddlSchemaName_;           onChanged();         }         this.mergeUnknownFields(other.getUnknownFields());         return this;       }        public final boolean isInitialized() {         return true;       }        public Builder mergeFrom(           com.google.protobuf.CodedInputStream input,           com.google.protobuf.ExtensionRegistryLite extensionRegistry)           throws java.io.IOException {         RowChange parsedMessage = null;         try {           parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);         } catch (com.google.protobuf.InvalidProtocolBufferException e) {           parsedMessage = (RowChange) e.getUnfinishedMessage();           throw e;         } finally {           if (parsedMessage != null) {             mergeFrom(parsedMessage);           }         }         return this;       }       private int bitField0_;        private long tableId_ ;       /**        * optional int64 tableId = 1;        *        *         **tableId,由数据库产生*        *         */       public boolean hasTableId() {         return ((bitField0_ &amp; 0x00000001) == 0x00000001);       }       /**        * optional int64 tableId = 1;        *        *         **tableId,由数据库产生*        *         */       public long getTableId() {         return tableId_;       }       /**        * optional int64 tableId = 1;        *        *         **tableId,由数据库产生*        *         */       public Builder setTableId(long value) {         bitField0_ |= 0x00000001;         tableId_ = value;         onChanged();         return this;       }       /**        * optional int64 tableId = 1;        *        *         **tableId,由数据库产生*        *         */       public Builder clearTableId() {         bitField0_ = (bitField0_ &amp; ~0x00000001);         tableId_ = 0L;         onChanged();         return this;       }        private EventType eventType_ = EventType.UPDATE;       /**        * optional .com.alibaba.otter.canal.protocol.EventType eventType = 2 [default = UPDATE];        *        *         **数据变更类型*        *         */       public boolean hasEventType() {         return ((bitField0_ &amp; 0x00000002) == 0x00000002);       }       /**        * optional .com.alibaba.otter.canal.protocol.EventType eventType = 2 [default = UPDATE];        *        *         **数据变更类型*        *         */       public EventType getEventType() {         return eventType_;       }       /**        * optional .com.alibaba.otter.canal.protocol.EventType eventType = 2 [default = UPDATE];        *        *         **数据变更类型*        *         */       public Builder setEventType(EventType value) {         if (value == null) {           throw new NullPointerException();         }         bitField0_ |= 0x00000002;         eventType_ = value;         onChanged();         return this;       }       /**        * optional .com.alibaba.otter.canal.protocol.EventType eventType = 2 [default = UPDATE];        *        *         **数据变更类型*        *         */       public Builder clearEventType() {         bitField0_ = (bitField0_ &amp; ~0x00000002);         eventType_ = EventType.UPDATE;         onChanged();         return this;       }        private boolean isDdl_ ;       /**        * optional bool isDdl = 10 [default = false];        *        *         ** 标识是否是ddl语句  *        *         */       public boolean hasIsDdl() {         return ((bitField0_ &amp; 0x00000004) == 0x00000004);       }       /**        * optional bool isDdl = 10 [default = false];        *        *         ** 标识是否是ddl语句  *        *         */       public boolean getIsDdl() {         return isDdl_;       }       /**        * optional bool isDdl = 10 [default = false];        *        *         ** 标识是否是ddl语句  *        *         */       public Builder setIsDdl(boolean value) {         bitField0_ |= 0x00000004;         isDdl_ = value;         onChanged();         return this;       }       /**        * optional bool isDdl = 10 [default = false];        *        *         ** 标识是否是ddl语句  *        *         */       public Builder clearIsDdl() {         bitField0_ = (bitField0_ &amp; ~0x00000004);         isDdl_ = false;         onChanged();         return this;       }        private Object sql_ = &quot;&quot;;       /**        * optional string sql = 11;        *        *         ** ddl/query的sql语句  *        *         */       public boolean hasSql() {         return ((bitField0_ &amp; 0x00000008) == 0x00000008);       }       /**        * optional string sql = 11;        *        *         ** ddl/query的sql语句  *        *         */       public String getSql() {         Object ref = sql_;         if (!(ref instanceof String)) {           com.google.protobuf.ByteString bs =               (com.google.protobuf.ByteString) ref;           String s = bs.toStringUtf8();           if (bs.isValidUtf8()) {             sql_ = s;           }           return s;         } else {           return (String) ref;         }       }       /**        * optional string sql = 11;        *        *         ** ddl/query的sql语句  *        *         */       public com.google.protobuf.ByteString           getSqlBytes() {         Object ref = sql_;         if (ref instanceof String) {           com.google.protobuf.ByteString b =               com.google.protobuf.ByteString.copyFromUtf8(                   (String) ref);           sql_ = b;           return b;         } else {           return (com.google.protobuf.ByteString) ref;         }       }       /**        * optional string sql = 11;        *        *         ** ddl/query的sql语句  *        *         */       public Builder setSql(           String value) {         if (value == null) {     throw new NullPointerException();   }   bitField0_ |= 0x00000008;         sql_ = value;         onChanged();         return this;       }       /**        * optional string sql = 11;        *        *         ** ddl/query的sql语句  *        *         */       public Builder clearSql() {         bitField0_ = (bitField0_ &amp; ~0x00000008);         sql_ = getDefaultInstance().getSql();         onChanged();         return this;       }       /**        * optional string sql = 11;        *        *         ** ddl/query的sql语句  *        *         */       public Builder setSqlBytes(           com.google.protobuf.ByteString value) {         if (value == null) {     throw new NullPointerException();   }   bitField0_ |= 0x00000008;         sql_ = value;         onChanged();         return this;       }        private java.util.List rowDatas_ =         java.util.Collections.emptyList();       private void ensureRowDatasIsMutable() {         if (!((bitField0_ &amp; 0x00000010) == 0x00000010)) {           rowDatas_ = new java.util.ArrayList(rowDatas_);           bitField0_ |= 0x00000010;          }       }        private com.google.protobuf.RepeatedFieldBuilder&lt;           RowData, RowData.Builder, RowDataOrBuilder&gt; rowDatasBuilder_;        /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public java.util.List getRowDatasList() {         if (rowDatasBuilder_ == null) {           return java.util.Collections.unmodifiableList(rowDatas_);         } else {           return rowDatasBuilder_.getMessageList();         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public int getRowDatasCount() {         if (rowDatasBuilder_ == null) {           return rowDatas_.size();         } else {           return rowDatasBuilder_.getCount();         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public RowData getRowDatas(int index) {         if (rowDatasBuilder_ == null) {           return rowDatas_.get(index);         } else {           return rowDatasBuilder_.getMessage(index);         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder setRowDatas(           int index, RowData value) {         if (rowDatasBuilder_ == null) {           if (value == null) {             throw new NullPointerException();           }           ensureRowDatasIsMutable();           rowDatas_.set(index, value);           onChanged();         } else {           rowDatasBuilder_.setMessage(index, value);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder setRowDatas(           int index, RowData.Builder builderForValue) {         if (rowDatasBuilder_ == null) {           ensureRowDatasIsMutable();           rowDatas_.set(index, builderForValue.build());           onChanged();         } else {           rowDatasBuilder_.setMessage(index, builderForValue.build());         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder addRowDatas(RowData value) {         if (rowDatasBuilder_ == null) {           if (value == null) {             throw new NullPointerException();           }           ensureRowDatasIsMutable();           rowDatas_.add(value);           onChanged();         } else {           rowDatasBuilder_.addMessage(value);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder addRowDatas(           int index, RowData value) {         if (rowDatasBuilder_ == null) {           if (value == null) {             throw new NullPointerException();           }           ensureRowDatasIsMutable();           rowDatas_.add(index, value);           onChanged();         } else {           rowDatasBuilder_.addMessage(index, value);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder addRowDatas(           RowData.Builder builderForValue) {         if (rowDatasBuilder_ == null) {           ensureRowDatasIsMutable();           rowDatas_.add(builderForValue.build());           onChanged();         } else {           rowDatasBuilder_.addMessage(builderForValue.build());         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder addRowDatas(           int index, RowData.Builder builderForValue) {         if (rowDatasBuilder_ == null) {           ensureRowDatasIsMutable();           rowDatas_.add(index, builderForValue.build());           onChanged();         } else {           rowDatasBuilder_.addMessage(index, builderForValue.build());         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder addAllRowDatas(           Iterable values) {         if (rowDatasBuilder_ == null) {           ensureRowDatasIsMutable();           com.google.protobuf.AbstractMessageLite.Builder.addAll(               values, rowDatas_);           onChanged();         } else {           rowDatasBuilder_.addAllMessages(values);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder clearRowDatas() {         if (rowDatasBuilder_ == null) {           rowDatas_ = java.util.Collections.emptyList();           bitField0_ = (bitField0_ &amp; ~0x00000010);           onChanged();         } else {           rowDatasBuilder_.clear();         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder removeRowDatas(int index) {         if (rowDatasBuilder_ == null) {           ensureRowDatasIsMutable();           rowDatas_.remove(index);           onChanged();         } else {           rowDatasBuilder_.remove(index);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public RowData.Builder getRowDatasBuilder(           int index) {         return getRowDatasFieldBuilder().getBuilder(index);       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public RowDataOrBuilder getRowDatasOrBuilder(           int index) {         if (rowDatasBuilder_ == null) {           return rowDatas_.get(index);  } else {           return rowDatasBuilder_.getMessageOrBuilder(index);         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public java.util.List            getRowDatasOrBuilderList() {         if (rowDatasBuilder_ != null) {           return rowDatasBuilder_.getMessageOrBuilderList();         } else {           return java.util.Collections.unmodifiableList(rowDatas_);         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public RowData.Builder addRowDatasBuilder() {         return getRowDatasFieldBuilder().addBuilder(             RowData.getDefaultInstance());       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public RowData.Builder addRowDatasBuilder(           int index) {         return getRowDatasFieldBuilder().addBuilder(             index, RowData.getDefaultInstance());       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public java.util.List            getRowDatasBuilderList() {         return getRowDatasFieldBuilder().getBuilderList();       }       private com.google.protobuf.RepeatedFieldBuilder&lt;           RowData, RowData.Builder, RowDataOrBuilder&gt;           getRowDatasFieldBuilder() {         if (rowDatasBuilder_ == null) {           rowDatasBuilder_ = new com.google.protobuf.RepeatedFieldBuilder&lt;               RowData, RowData.Builder, RowDataOrBuilder&gt;(                   rowDatas_,                   ((bitField0_ &amp; 0x00000010) == 0x00000010),                   getParentForChildren(),                   isClean());           rowDatas_ = null;         }         return rowDatasBuilder_;       }        private java.util.List props_ =         java.util.Collections.emptyList();       private void ensurePropsIsMutable() {         if (!((bitField0_ &amp; 0x00000020) == 0x00000020)) {           props_ = new java.util.ArrayList(props_);           bitField0_ |= 0x00000020;          }       }        private com.google.protobuf.RepeatedFieldBuilder&lt;           Pair, Pair.Builder, PairOrBuilder&gt; propsBuilder_;        /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public java.util.List getPropsList() {         if (propsBuilder_ == null) {           return java.util.Collections.unmodifiableList(props_);         } else {           return propsBuilder_.getMessageList();         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public int getPropsCount() {         if (propsBuilder_ == null) {           return props_.size();         } else {           return propsBuilder_.getCount();         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Pair getProps(int index) {         if (propsBuilder_ == null) {           return props_.get(index);         } else {           return propsBuilder_.getMessage(index);         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder setProps(           int index, Pair value) {         if (propsBuilder_ == null) {           if (value == null) {             throw new NullPointerException();           }           ensurePropsIsMutable();           props_.set(index, value);           onChanged();         } else {           propsBuilder_.setMessage(index, value);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder setProps(           int index, Pair.Builder builderForValue) {         if (propsBuilder_ == null) {           ensurePropsIsMutable();           props_.set(index, builderForValue.build());           onChanged();         } else {           propsBuilder_.setMessage(index, builderForValue.build());         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder addProps(Pair value) {         if (propsBuilder_ == null) {           if (value == null) {             throw new NullPointerException();           }           ensurePropsIsMutable();           props_.add(value);           onChanged();         } else {           propsBuilder_.addMessage(value);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder addProps(           int index, Pair value) {         if (propsBuilder_ == null) {           if (value == null) {             throw new NullPointerException();           }           ensurePropsIsMutable();           props_.add(index, value);           onChanged();         } else {           propsBuilder_.addMessage(index, value);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder addProps(           Pair.Builder builderForValue) {         if (propsBuilder_ == null) {           ensurePropsIsMutable();           props_.add(builderForValue.build());           onChanged();         } else {           propsBuilder_.addMessage(builderForValue.build());         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder addProps(           int index, Pair.Builder builderForValue) {         if (propsBuilder_ == null) {           ensurePropsIsMutable();           props_.add(index, builderForValue.build());           onChanged();         } else {           propsBuilder_.addMessage(index, builderForValue.build());         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder addAllProps(           Iterable values) {         if (propsBuilder_ == null) {           ensurePropsIsMutable();           com.google.protobuf.AbstractMessageLite.Builder.addAll(               values, props_);           onChanged();         } else {           propsBuilder_.addAllMessages(values);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder clearProps() {         if (propsBuilder_ == null) {           props_ = java.util.Collections.emptyList();           bitField0_ = (bitField0_ &amp; ~0x00000020);           onChanged();         } else {           propsBuilder_.clear();         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder removeProps(int index) {         if (propsBuilder_ == null) {           ensurePropsIsMutable();           props_.remove(index);           onChanged();         } else {           propsBuilder_.remove(index);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Pair.Builder getPropsBuilder(           int index) {         return getPropsFieldBuilder().getBuilder(index);       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public PairOrBuilder getPropsOrBuilder(           int index) {         if (propsBuilder_ == null) {           return props_.get(index);  } else {           return propsBuilder_.getMessageOrBuilder(index);         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public java.util.List            getPropsOrBuilderList() {         if (propsBuilder_ != null) {           return propsBuilder_.getMessageOrBuilderList();         } else {           return java.util.Collections.unmodifiableList(props_);         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Pair.Builder addPropsBuilder() {         return getPropsFieldBuilder().addBuilder(             Pair.getDefaultInstance());       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Pair.Builder addPropsBuilder(           int index) {         return getPropsFieldBuilder().addBuilder(             index, Pair.getDefaultInstance());       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public java.util.List            getPropsBuilderList() {         return getPropsFieldBuilder().getBuilderList();       }       private com.google.protobuf.RepeatedFieldBuilder&lt;           Pair, Pair.Builder, PairOrBuilder&gt;           getPropsFieldBuilder() {         if (propsBuilder_ == null) {           propsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder&lt;               Pair, Pair.Builder, PairOrBuilder&gt;(                   props_,                   ((bitField0_ &amp; 0x00000020) == 0x00000020),                   getParentForChildren(),                   isClean());           props_ = null;         }         return propsBuilder_;       }        private Object ddlSchemaName_ = &quot;&quot;;       /**        * optional string ddlSchemaName = 14;        *        *         ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *        *         */       public boolean hasDdlSchemaName() {         return ((bitField0_ &amp; 0x00000040) == 0x00000040);       }       /**        * optional string ddlSchemaName = 14;        *        *         ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *        *         */       public String getDdlSchemaName() {         Object ref = ddlSchemaName_;         if (!(ref instanceof String)) {           com.google.protobuf.ByteString bs =               (com.google.protobuf.ByteString) ref;           String s = bs.toStringUtf8();           if (bs.isValidUtf8()) {             ddlSchemaName_ = s;           }           return s;         } else {           return (String) ref;         }       }       /**        * optional string ddlSchemaName = 14;        *        *         ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *        *         */       public com.google.protobuf.ByteString           getDdlSchemaNameBytes() {         Object ref = ddlSchemaName_;         if (ref instanceof String) {           com.google.protobuf.ByteString b =               com.google.protobuf.ByteString.copyFromUtf8(                   (String) ref);           ddlSchemaName_ = b;           return b;         } else {           return (com.google.protobuf.ByteString) ref;         }       }       /**        * optional string ddlSchemaName = 14;        *        *         ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *        *         */       public Builder setDdlSchemaName(           String value) {         if (value == null) {     throw new NullPointerException();   }   bitField0_ |= 0x00000040;         ddlSchemaName_ = value;         onChanged();         return this;       }       /**        * optional string ddlSchemaName = 14;        *        *         ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *        *         */       public Builder clearDdlSchemaName() {         bitField0_ = (bitField0_ &amp; ~0x00000040);         ddlSchemaName_ = getDefaultInstance().getDdlSchemaName();         onChanged();         return this;       }       /**        * optional string ddlSchemaName = 14;        *        *         ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *        *         */       public Builder setDdlSchemaNameBytes(           com.google.protobuf.ByteString value) {         if (value == null) {     throw new NullPointerException();   }   bitField0_ |= 0x00000040;         ddlSchemaName_ = value;         onChanged();         return this;       }        // @@protoc_insertion_point(builder_scope:com.alibaba.otter.canal.protocol.RowChange)     }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11474</td>
    <td align="left">https://github.com/alibaba/canal/blob/08167c95c767fd3c9879584c0230820a8476a7a7/protocol/src/main/java/com/alibaba/otter/canal/protocol/CanalEntry.java/#L8477-L9689</td>
    <td align="right">1</td>
    <td align="right">1616</td>
    <td align="right">11474</td>
  </tr>
  <tr valign="top">
    <td align="right">1628</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;output&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Blob&quot;,             &quot;Data Class&quot;         ]     } </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@JacksonXmlRootElement @JsonIgnoreProperties(ignoreUnknown = true) public class User implements Serializable {      private static final long serialVersionUID = 4247427179764560935L;      private Integer id;     private String username;     private String name;     @JsonProperty(&quot;first_name&quot;)     private String firstName;     @JsonProperty(&quot;last_name&quot;)     private String lastName;     private String email;     private String url;     private String description;     private String link;     private String locale;     private String nickname;     private String slug;     @JsonProperty(&quot;registered_date&quot;)     private String registeredDate;     private List roles;     private Map capabilities;     @JsonProperty(&quot;extra_capabilities&quot;)     private Map extraCapabilities;     @JsonProperty(&quot;avatar_urls&quot;)     private Map avatarUrls;     @JsonProperty(&quot;meta&quot;)     private List&gt; meta;      public User() {      }      public Integer getId() {         return id;     }      public void setId(Integer id) {         this.id = id;     }      public String getUsername() {         return username;     }      public void setUsername(String username) {         this.username = username;     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public String getFirstName() {         return firstName;     }      public void setFirstName(String firstName) {         this.firstName = firstName;     }      public String getLastName() {         return lastName;     }      public void setLastName(String lastName) {         this.lastName = lastName;     }      public String getEmail() {         return email;     }      public void setEmail(String email) {         this.email = email;     }      public String getUrl() {         return url;     }      public void setUrl(String url) {         this.url = url;     }      public String getDescription() {         return description;     }      public void setDescription(String description) {         this.description = description;     }      public String getLink() {         return link;     }      public void setLink(String link) {         this.link = link;     }      public String getLocale() {         return locale;     }      public void setLocale(String locale) {         this.locale = locale;     }      public String getNickname() {         return nickname;     }      public void setNickname(String nickname) {         this.nickname = nickname;     }      public String getSlug() {         return slug;     }      public void setSlug(String slug) {         this.slug = slug;     }      public String getRegisteredDate() {         return registeredDate;     }      public void setRegisteredDate(String registeredDate) {         this.registeredDate = registeredDate;     }      public List getRoles() {         return roles;     }      public void setRoles(List roles) {         this.roles = roles;     }      public Map getCapabilities() {         return capabilities;     }      public void setCapabilities(Map capabilities) {         this.capabilities = capabilities;     }      public Map getExtraCapabilities() {         return extraCapabilities;     }      public void setExtraCapabilities(Map extraCapabilities) {         this.extraCapabilities = extraCapabilities;     }      public Map getAvatarUrls() {         return avatarUrls;     }      public void setAvatarUrls(Map avatarUrls) {         this.avatarUrls = avatarUrls;     }      public List&gt; getMeta() {         return meta;     }      public void setMeta(List&gt; meta) {         this.meta = meta;     }      @Override     public String toString() {         return toStringHelper(this).addValue(this.id).addValue(this.username).addValue(this.email).addValue(this.name).toString();     }  }</td>
    <td align="left">blob</td>
    <td align="left">Blob, Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;Data Class</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11502</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-wordpress/src/main/java/org/apache/camel/component/wordpress/api/model/User.java/#L29-L213</td>
    <td align="right">1</td>
    <td align="right">1628</td>
    <td align="right">11502</td>
  </tr>
  <tr valign="top">
    <td align="right">1661</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Blob&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class NetAgent extends Agent {     //---------------------navigational members-----------------------------------      // All these request objects point to the same physical request object.     ConnectionRequestInterface connectionRequest_;     StatementRequestInterface statementRequest_;     ResultSetRequestInterface resultSetRequest_;      // All these reply objects point to the same physical reply object.     ConnectionReply connectionReply_;     private ConnectionReply packageReply_;     StatementReply statementReply_;     ResultSetReply resultSetReply_;      //---------------------navigational cheat-links-------------------------------     // Cheat-links are for convenience only, and are not part of the conceptual model.     // Warning:     //   Cheat-links should only be defined for invariant state data.     //   That is, the state data is set by the constructor and never changes.      // Alias for (NetConnection) super.connection     NetConnection netConnection_;      // Alias for (Request) super.*Request, all in one     // In the case of the NET implementation, these all point to the same physical request object.     private Request request_;     NetConnectionRequest netConnectionRequest_;     private NetPackageRequest netPackageRequest_;     private NetStatementRequest netStatementRequest_;     private NetResultSetRequest netResultSetRequest_;      // Alias for (Reply) super.*Reply, all in one.     // In the case of the NET implementation, these all point to the same physical reply object.     private Reply reply_;     NetConnectionReply netConnectionReply_;     private NetPackageReply netPackageReply_;     private NetStatementReply netStatementReply_;     private NetResultSetReply netResultSetReply_;      //-----------------------------state------------------------------------------      Socket socket_;     private InputStream rawSocketInputStream_;     private OutputStream rawSocketOutputStream_;      String server_;     int port_;     private int clientSSLMode_;      private EbcdicCcsidManager ebcdicCcsidManager_;     private Utf8CcsidManager utf8CcsidManager_;     private CcsidManager currentCcsidManager_;          // TODO: Remove target? Keep just one CcsidManager?     //public CcsidManager targetCcsidManager_;     Typdef typdef_;     Typdef targetTypdef_;     Typdef originalTargetTypdef_; // added to support typdef overrides      private int svrcod_;      int orignalTargetSqlam_ = NetConfiguration.MGRLVL_7;     int targetSqlam_ = orignalTargetSqlam_;      SqlException exceptionOpeningSocket_ = null;     SqlException exceptionConvertingRdbnam = null;          /**      * Flag which indicates that a writeChain has been started and data sent to      * the server.      * If true, starting a new write chain will throw a DisconnectException.       * It is cleared when the write chain is ended.      */     private boolean writeChainIsDirty_ = false;     //---------------------constructors/finalizer---------------------------------      // Only used for testing     public NetAgent(NetConnection netConnection,                     LogWriter logWriter) throws SqlException {         super(netConnection, logWriter);         this.netConnection_ = netConnection;     }      NetAgent(NetConnection netConnection,              LogWriter netLogWriter,              int loginTimeout,              String server,              int port,              int clientSSLMode) throws SqlException {         super(netConnection, netLogWriter);          server_ = server;         port_ = port;         netConnection_ = netConnection;         clientSSLMode_ = clientSSLMode;          if (server_ == null) {             throw new DisconnectException(this,                  new ClientMessageId(SQLState.CONNECT_REQUIRED_PROPERTY_NOT_SET),                 &quot;serverName&quot;);         }          try {             socket_ = (Socket)AccessController.doPrivileged(                 new OpenSocketAction(server, port, clientSSLMode_));         } catch (PrivilegedActionException e) {             throw new DisconnectException(this,                 new ClientMessageId(SQLState.CONNECT_UNABLE_TO_CONNECT_TO_SERVER),                 e.getException(),                 e.getException().getClass().getName(), server, port,                 e.getException().getMessage());         }          // Set TCP/IP Socket Properties         try {             if (exceptionOpeningSocket_ == null) {                 socket_.setTcpNoDelay(true); // disables nagles algorithm                 socket_.setKeepAlive(true); // PROTOCOL Manual: TCP/IP connection allocation rule #2                 socket_.setSoTimeout(loginTimeout * 1000);             }         } catch (SocketException e) {             try {                 socket_.close();             } catch (IOException doNothing) {             }             exceptionOpeningSocket_ = new DisconnectException(this,                 new ClientMessageId(SQLState.CONNECT_SOCKET_EXCEPTION),                 e, e.getMessage());         }          try {             if (exceptionOpeningSocket_ == null) {                 rawSocketOutputStream_ = socket_.getOutputStream();                 rawSocketInputStream_ = socket_.getInputStream();             }         } catch (IOException e) {             try {                 socket_.close();             } catch (IOException doNothing) {             }             exceptionOpeningSocket_ = new DisconnectException(this,                  new ClientMessageId(SQLState.CONNECT_UNABLE_TO_OPEN_SOCKET_STREAM),                 e, e.getMessage());         }          ebcdicCcsidManager_ = new EbcdicCcsidManager();         utf8CcsidManager_ = new Utf8CcsidManager();                  currentCcsidManager_ = ebcdicCcsidManager_;          if (netConnection_.isXAConnection()) {             NetXAConnectionReply netXAConnectionReply_ = new NetXAConnectionReply(this, netConnection_.commBufferSize_);             netResultSetReply_ = (NetResultSetReply) netXAConnectionReply_;             netStatementReply_ = (NetStatementReply) netResultSetReply_;             netPackageReply_ = (NetPackageReply) netStatementReply_;             netConnectionReply_ = (NetConnectionReply) netPackageReply_;             reply_ = (Reply) netConnectionReply_;              resultSetReply_ = new ResultSetReply(this,                     netResultSetReply_,                     netStatementReply_,                     netConnectionReply_);             statementReply_ = (StatementReply) resultSetReply_;             packageReply_ = (ConnectionReply) statementReply_;             connectionReply_ = (ConnectionReply) packageReply_;             NetXAConnectionRequest netXAConnectionRequest_ = new NetXAConnectionRequest(this, netConnection_.commBufferSize_);             netResultSetRequest_ = (NetResultSetRequest) netXAConnectionRequest_;             netStatementRequest_ = (NetStatementRequest) netResultSetRequest_;             netPackageRequest_ = (NetPackageRequest) netStatementRequest_;             netConnectionRequest_ = (NetConnectionRequest) netPackageRequest_;             request_ = (Request) netConnectionRequest_;              resultSetRequest_ = (ResultSetRequestInterface) netResultSetRequest_;             statementRequest_ = (StatementRequestInterface) netStatementRequest_;             connectionRequest_ = (ConnectionRequestInterface) netConnectionRequest_;         } else {             netResultSetReply_ = new NetResultSetReply(this, netConnection_.commBufferSize_);             netStatementReply_ = (NetStatementReply) netResultSetReply_;             netPackageReply_ = (NetPackageReply) netStatementReply_;             netConnectionReply_ = (NetConnectionReply) netPackageReply_;             reply_ = (Reply) netConnectionReply_;              resultSetReply_ = new ResultSetReply(this,                     netResultSetReply_,                     netStatementReply_,                     netConnectionReply_);             statementReply_ = (StatementReply) resultSetReply_;             packageReply_ = (ConnectionReply) statementReply_;             connectionReply_ = (ConnectionReply) packageReply_;             netResultSetRequest_ = new NetResultSetRequest(this, netConnection_.commBufferSize_);             netStatementRequest_ = (NetStatementRequest) netResultSetRequest_;             netPackageRequest_ = (NetPackageRequest) netStatementRequest_;             netConnectionRequest_ = (NetConnectionRequest) netPackageRequest_;             request_ = (Request) netConnectionRequest_;              resultSetRequest_ = (ResultSetRequestInterface) netResultSetRequest_;             statementRequest_ = (StatementRequestInterface) netStatementRequest_;             connectionRequest_ = (ConnectionRequestInterface) netConnectionRequest_;         }     }      protected void resetAgent_(LogWriter netLogWriter,                                //CcsidManager sourceCcsidManager,                                //CcsidManager targetCcsidManager,                                int loginTimeout,                                String server,                                int port) throws SqlException {                  exceptionConvertingRdbnam = null;         // most properties will remain unchanged on connect reset.         targetTypdef_ = originalTargetTypdef_;         svrcod_ = 0;          // Set TCP/IP Socket Properties         try {             socket_.setSoTimeout(loginTimeout * 1000);         } catch (SocketException e) {             try {                 socket_.close();             } catch (IOException doNothing) {             }             throw new SqlException(logWriter_,                  new ClientMessageId(SQLState.SOCKET_EXCEPTION),                 e, e.getMessage());         }     }       void setSvrcod(int svrcod) {         if (svrcod &gt; svrcod_) {             svrcod_ = svrcod;         }     }      void clearSvrcod() {         svrcod_ = CodePoint.SVRCOD_INFO;     }      private int getSvrcod() {         return svrcod_;     }      public void flush_() throws DisconnectException {         sendRequest();         reply_.initialize();     }      // Close socket and its streams.     public void close_() throws SqlException {         // can we just close the socket here, do we need to close streams individually         SqlException accumulatedExceptions = null;         if (rawSocketInputStream_ != null) {             try {                 rawSocketInputStream_.close();             } catch (IOException e) {                 // note when {6} = 0 it indicates the socket was closed.                 // this should be ok since we are going to go an close the socket                 // immediately following this call.                 // changing {4} to e.getMessage() may require pub changes                 accumulatedExceptions = new SqlException(logWriter_,                     new ClientMessageId(SQLState.COMMUNICATION_ERROR),                     e, e.getMessage());             } finally {                 rawSocketInputStream_ = null;             }         }          if (rawSocketOutputStream_ != null) {             try {                 rawSocketOutputStream_.close();             } catch (IOException e) {                 // note when {6} = 0 it indicates the socket was closed.                 // this should be ok since we are going to go an close the socket                 // immediately following this call.                 // changing {4} to e.getMessage() may require pub changes                 SqlException latestException = new SqlException(logWriter_,                     new ClientMessageId(SQLState.COMMUNICATION_ERROR),                     e, e.getMessage());                 accumulatedExceptions = Utils.accumulateSQLException(latestException, accumulatedExceptions);             } finally {                 rawSocketOutputStream_ = null;             }         }          if (socket_ != null) {             try {                 socket_.close();             } catch (IOException e) {                 // again {6} = 0, indicates the socket was closed.                 // maybe set {4} to e.getMessage().                 // do this for now and but may need to modify or                 // add this to the message pubs.                 SqlException latestException = new SqlException(logWriter_,                     new ClientMessageId(SQLState.COMMUNICATION_ERROR),                         e, e.getMessage());                 accumulatedExceptions = Utils.accumulateSQLException(latestException, accumulatedExceptions);             } finally {                 socket_ = null;             }         }          if (accumulatedExceptions != null) {             throw accumulatedExceptions;         }     }      /**      * Specifies the maximum blocking time that should be used when sending      * and receiving messages. The timeout is implemented by using the the       * underlying socket implementation's timeout support.       *       * Note that the support for timeout on sockets is dependent on the OS       * implementation. For the same reason we ignore any exceptions thrown      * by the call to the socket layer.      *       * @param timeout The timeout value in seconds. A value of 0 corresponds to       * infinite timeout.      */     protected void setTimeout(int timeout) {         try {             // Sets a timeout on the socket             socket_.setSoTimeout(timeout * 1000); // convert to milliseconds         } catch (SocketException se) {             // Silently ignore any exceptions from the socket layer             if (SanityManager.DEBUG) {                 System.out.println(&quot;NetAgent.setTimeout: ignoring exception: &quot; +                                     se);             }         }     }      /**      * Returns the current timeout value that is set on the socket.      *       * Note that the support for timeout on sockets is dependent on the OS       * implementation. For the same reason we ignore any exceptions thrown      * by the call to the socket layer.      *       * @return The timeout value in seconds. A value of 0 corresponds to      * that no timeout is specified on the socket.      */     protected int getTimeout() {         int timeout = 0; // 0 is default timeout for sockets          // Read the timeout currently set on the socket         try {             timeout = socket_.getSoTimeout();         } catch (SocketException se) {             // Silently ignore any exceptions from the socket layer             if (SanityManager.DEBUG) {                 System.out.println(&quot;NetAgent.getTimeout: ignoring exception: &quot; +                                     se);             }         }          // Convert from milliseconds to seconds (note that this truncates         // the results towards zero but that should not be a problem).         timeout = timeout / 1000;         return timeout;     }      private void sendRequest() throws DisconnectException {         try {             request_.flush(rawSocketOutputStream_);         } catch (IOException e) {             throwCommunicationsFailure(e);         }     }      public InputStream getInputStream() {         return rawSocketInputStream_;     }      public CcsidManager getCurrentCcsidManager() {         return currentCcsidManager_;     }          public OutputStream getOutputStream() {         return rawSocketOutputStream_;     }      void setInputStream(InputStream inputStream) {         rawSocketInputStream_ = inputStream;     }      void setOutputStream(OutputStream outputStream) {         rawSocketOutputStream_ = outputStream;     }      void throwCommunicationsFailure(Throwable cause)         throws DisconnectException {         //DisconnectException         //accumulateReadExceptionAndDisconnect         // note when {6} = 0 it indicates the socket was closed.         // need to still validate any token values against message publications.         accumulateChainBreakingReadExceptionAndThrow(             new DisconnectException(this,                 new ClientMessageId(SQLState.COMMUNICATION_ERROR),                 cause, cause.getMessage()));     }              // ----------------------- call-down methods ---------------------------------      protected void markChainBreakingException_() {         setSvrcod(CodePoint.SVRCOD_ERROR);     }      public void checkForChainBreakingException_() throws SqlException {         int svrcod = getSvrcod();         clearSvrcod();         if (svrcod &gt; CodePoint.SVRCOD_WARNING) // Not for SQL warning, if svrcod &gt; WARNING, then its a chain breaker         {             super.checkForExceptions(); // throws the accumulated exceptions, we'll always have at least one.         }     }      private void writeDeferredResetConnection() throws SqlException {         if (!netConnection_.resetConnectionAtFirstSql_) {             return;         }         try {             netConnection_.writeDeferredReset();         } catch (SqlException sqle) {             DisconnectException de = new DisconnectException(this,                  new ClientMessageId(SQLState.CONNECTION_FAILED_ON_DEFERRED_RESET));             de.setNextException(sqle);             throw de;         }     }     /**      * Marks the agent's write chain as dirty. A write chain is dirty when data      * from it has been sent to the server. A dirty write chain cannot be reset       * and reused for another request until the remaining data has been sent to      * the server and the write chain properly ended.       *       * Resetting a dirty chain will cause the new request to be appended to the       * unfinished request already at the server, which will likely lead to       * cryptic syntax errors.      */     void markWriteChainAsDirty() {             writeChainIsDirty_ = true;     }          private void verifyWriteChainIsClean() throws DisconnectException {         if (writeChainIsDirty_) {              throw new DisconnectException(this,                  new ClientMessageId(SQLState.NET_WRITE_CHAIN_IS_DIRTY));         }     }     public void beginWriteChainOutsideUOW() throws SqlException {         verifyWriteChainIsClean();         request_.initialize();         writeDeferredResetConnection();     }      public void beginWriteChain(ClientStatement statement) throws SqlException {         verifyWriteChainIsClean();         request_.initialize();         writeDeferredResetConnection();         super.beginWriteChain(statement);     }      protected void endWriteChain() {}          private void readDeferredResetConnection() throws SqlException {         if (!netConnection_.resetConnectionAtFirstSql_) {             return;         }         try {             netConnection_.readDeferredReset();             checkForExceptions();         } catch (SqlException sqle) {             DisconnectException de = new DisconnectException(this,                  new ClientMessageId(SQLState.CONNECTION_FAILED_ON_DEFERRED_RESET));             de.setNextException(sqle);             throw de;         }     }      protected void beginReadChain(ClientStatement statement)             throws SqlException {         // Clear here as endWriteChain may not always be called         writeChainIsDirty_ = false;         readDeferredResetConnection();         super.beginReadChain(statement);     }      protected void beginReadChainOutsideUOW() throws SqlException {         // Clear here as endWriteChain may not always be called         writeChainIsDirty_ = false;         readDeferredResetConnection();         super.beginReadChainOutsideUOW();     }      /**      * Switches the current CCSID manager to UTF-8      */     void switchToUtf8CcsidMgr() {         currentCcsidManager_ = utf8CcsidManager_;     }          /**      * Switches the current CCSID manager to EBCDIC      */     void switchToEbcdicMgr() {         currentCcsidManager_ = ebcdicCcsidManager_;     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;data class</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11610</td>
    <td align="left">https://github.com/apache/derby/blob/bd246fc89d4fce3f82f8344074ecb8a4713418df/java/org.apache.derby.client/org/apache/derby/client/net/NetAgent.java/#L43-L550</td>
    <td align="right">1</td>
    <td align="right">1661</td>
    <td align="right">11610</td>
  </tr>
  <tr valign="top">
    <td align="right">1670</td>
    <td align="left">&nbsp;{&quot;output&quot;: &quot;YES I found bad smells the bad smells are: \n1. Blob, 2. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class NodeAnnounceMessage extends PacketImpl {     protected String nodeID;     protected String backupGroupName;     protected boolean backup;     protected long currentEventID;     protected TransportConfiguration connector;     protected TransportConfiguration backupConnector;     private String scaleDownGroupName;     // Static --------------------------------------------------------     // Constructors --------------------------------------------------     public NodeAnnounceMessage(final long currentEventID,                               final String nodeID,                               final String backupGroupName,                               final String scaleDownGroupName,                               final boolean backup,                               final TransportConfiguration tc,                               final TransportConfiguration backupConnector) {       super(NODE_ANNOUNCE);        this.currentEventID = currentEventID;        this.nodeID = nodeID;        this.backupGroupName = backupGroupName;        this.backup = backup;        this.connector = tc;        this.backupConnector = backupConnector;        this.scaleDownGroupName = scaleDownGroupName;    }     public NodeAnnounceMessage() {       super(NODE_ANNOUNCE);    }     public NodeAnnounceMessage(byte nodeAnnounceMessage_V2) {       super(nodeAnnounceMessage_V2);    }     // Public --------------------------------------------------------     public String getNodeID() {       return nodeID;    }     public String getBackupGroupName() {       return backupGroupName;    }     public boolean isBackup() {       return backup;    }     public TransportConfiguration getConnector() {       return connector;    }     public TransportConfiguration getBackupConnector() {       return backupConnector;    }     public String getScaleDownGroupName() {       return scaleDownGroupName;    }     /**     * @return the currentEventID     */    public long getCurrentEventID() {       return currentEventID;    }     @Override    public void encodeRest(final ActiveMQBuffer buffer) {       buffer.writeString(nodeID);       buffer.writeNullableString(backupGroupName);       buffer.writeBoolean(backup);       buffer.writeLong(currentEventID);       if (connector != null) {          buffer.writeBoolean(true);          connector.encode(buffer);       } else {          buffer.writeBoolean(false);       }       if (backupConnector != null) {          buffer.writeBoolean(true);          backupConnector.encode(buffer);       } else {          buffer.writeBoolean(false);       }       buffer.writeNullableString(scaleDownGroupName);    }     @Override    public void decodeRest(final ActiveMQBuffer buffer) {       this.nodeID = buffer.readString();       this.backupGroupName = buffer.readNullableString();       this.backup = buffer.readBoolean();       this.currentEventID = buffer.readLong();       if (buffer.readBoolean()) {          connector = new TransportConfiguration();          connector.decode(buffer);       }       if (buffer.readBoolean()) {          backupConnector = new TransportConfiguration();          backupConnector.decode(buffer);       }       scaleDownGroupName = buffer.readNullableString();    }     @Override    public String toString() {       return &quot;NodeAnnounceMessage [backup=&quot; + backup +          &quot;, connector=&quot; +          connector +          &quot;, nodeID=&quot; +          nodeID +          &quot;, toString()=&quot; +          super.toString() +          &quot;]&quot;;    }     @Override    public int hashCode() {       final int prime = 31;       int result = super.hashCode();       result = prime * result + (backup ? 1231 : 1237);       result = prime * result + ((backupConnector == null) ? 0 : backupConnector.hashCode());       result = prime * result + ((connector == null) ? 0 : connector.hashCode());       result = prime * result + (int) (currentEventID ^ (currentEventID &gt;&gt;&gt; 32));       result = prime * result + ((nodeID == null) ? 0 : nodeID.hashCode());       result = prime * result + ((scaleDownGroupName == null) ? 0 : scaleDownGroupName.hashCode());       return result;    }     @Override    public boolean equals(Object obj) {       if (this == obj) {          return true;       }       if (!super.equals(obj)) {          return false;       }       if (!(obj instanceof NodeAnnounceMessage)) {          return false;       }       NodeAnnounceMessage other = (NodeAnnounceMessage) obj;       if (backup != other.backup) {          return false;       }       if (backupConnector == null) {          if (other.backupConnector != null) {             return false;          }       } else if (!backupConnector.equals(other.backupConnector)) {          return false;       }       if (connector == null) {          if (other.connector != null) {             return false;          }       } else if (!connector.equals(other.connector)) {          return false;       }       if (currentEventID != other.currentEventID) {          return false;       }       if (nodeID == null) {          if (other.nodeID != null) {             return false;          }       } else if (!nodeID.equals(other.nodeID)) {          return false;       } else if (!scaleDownGroupName.equals(other.scaleDownGroupName)) {          return false;       }       return true;    } }</td>
    <td align="left">blob</td>
    <td align="left">\n1. blob, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;2. data class</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11632</td>
    <td align="left">https://github.com/apache/activemq-artemis/blob/5bd5c610195d6f4a3dd1ac28170727003f8a5a54/artemis-server/src/main/java/org/apache/activemq/artemis/core/protocol/core/impl/wireformat/NodeAnnounceMessage.java/#L23-L214</td>
    <td align="right">1</td>
    <td align="right">1670</td>
    <td align="right">11632</td>
  </tr>
  <tr valign="top">
    <td align="right">1673</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;output&quot;: &quot;YES I found bad smells&quot;,         &quot;the bad smells are&quot;: [             &quot;Blob&quot;,             &quot;Data Class&quot;,             &quot;Long Method&quot;         ]     } </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@UriParams public class Mina2Configuration implements Cloneable {      @UriPath @Metadata(required = true)     private String protocol;     @UriPath @Metadata(required = true)     private String host;     @UriPath @Metadata(required = true)     private int port;     @UriParam(defaultValue = &quot;true&quot;)     private boolean sync = true;     @UriParam(label = &quot;codec&quot;)     private boolean textline;     @UriParam(label = &quot;codec&quot;)     private Mina2TextLineDelimiter textlineDelimiter;     @UriParam(label = &quot;codec&quot;)     private ProtocolCodecFactory codec;     @UriParam(label = &quot;codec&quot;)     private String encoding;     @UriParam(defaultValue = &quot;10000&quot;)     private long writeTimeout = 10000;     @UriParam(defaultValue = &quot;30000&quot;)     private long timeout = 30000;     @UriParam(label = &quot;producer,advanced&quot;, defaultValue = &quot;true&quot;)     private boolean lazySessionCreation = true;     @UriParam(label = &quot;advanced&quot;)     private boolean transferExchange;     @UriParam     private boolean minaLogger;     @UriParam(label = &quot;codec&quot;, defaultValue = &quot;-1&quot;)     private int encoderMaxLineLength = -1;     @UriParam(label = &quot;codec&quot;, defaultValue = &quot;1024&quot;)     private int decoderMaxLineLength = 1024;     @UriParam(label = &quot;codec&quot;)     private List filters;     @UriParam(label = &quot;codec&quot;, defaultValue = &quot;true&quot;)     private boolean allowDefaultCodec = true;     @UriParam     private boolean disconnect;     @UriParam(label = &quot;consumer,advanced&quot;, defaultValue = &quot;true&quot;)     private boolean disconnectOnNoReply = true;     @UriParam(label = &quot;consumer,advanced&quot;, defaultValue = &quot;WARN&quot;)     private LoggingLevel noReplyLogLevel = LoggingLevel.WARN;     @UriParam(label = &quot;security&quot;)     private SSLContextParameters sslContextParameters;     @UriParam(label = &quot;security&quot;, defaultValue = &quot;true&quot;)     private boolean autoStartTls = true;     @UriParam(label = &quot;advanced&quot;, defaultValue = &quot;16&quot;)     private int maximumPoolSize = 16; // 16 is the default mina setting     @UriParam(label = &quot;advanced&quot;, defaultValue = &quot;true&quot;)     private boolean orderedThreadPoolExecutor = true;     @UriParam(label = &quot;producer,advanced&quot;, defaultValue = &quot;true&quot;)     private boolean cachedAddress = true;     @UriParam(label = &quot;consumer&quot;)     private boolean clientMode;      /**      * Returns a copy of this configuration      */     public Mina2Configuration copy() {         try {             return (Mina2Configuration) clone();         } catch (CloneNotSupportedException e) {             throw new RuntimeCamelException(e);         }     }      public String getCharsetName() {         if (encoding == null) {             return null;         }         if (!Charset.isSupported(encoding)) {             throw new IllegalArgumentException(&quot;The encoding: &quot; + encoding + &quot; is not supported&quot;);         }          return Charset.forName(encoding).name();     }      public String getProtocol() {         return protocol;     }      /**      * Protocol to use      */     public void setProtocol(String protocol) {         this.protocol = protocol;     }      public String getHost() {         return host;     }      /**      * Hostname to use. Use localhost or 0.0.0.0 for local server as consumer. For producer use the hostname or ip address of the remote server.      */     public void setHost(String host) {         this.host = host;     }      public int getPort() {         return port;     }      /**      * Port number      */     public void setPort(int port) {         this.port = port;     }      public boolean isSync() {         return sync;     }      /**      * Setting to set endpoint as one-way or request-response.      */     public void setSync(boolean sync) {         this.sync = sync;     }      public boolean isTextline() {         return textline;     }      /**      * Only used for TCP. If no codec is specified, you can use this flag to indicate a text line based codec;      * if not specified or the value is false, then Object Serialization is assumed over TCP.      */     public void setTextline(boolean textline) {         this.textline = textline;     }      public Mina2TextLineDelimiter getTextlineDelimiter() {         return textlineDelimiter;     }      /**      * Only used for TCP and if textline=true. Sets the text line delimiter to use.      * If none provided, Camel will use DEFAULT.      * This delimiter is used to mark the end of text.      */     public void setTextlineDelimiter(Mina2TextLineDelimiter textlineDelimiter) {         this.textlineDelimiter = textlineDelimiter;     }      public ProtocolCodecFactory getCodec() {         return codec;     }      /**      * To use a custom minda codec implementation.      */     public void setCodec(ProtocolCodecFactory codec) {         this.codec = codec;     }      public String getEncoding() {         return encoding;     }      /**      * You can configure the encoding (a charset name) to use for the TCP textline codec and the UDP protocol.      * If not provided, Camel will use the JVM default Charset      */     public void setEncoding(String encoding) {         this.encoding = encoding;     }      public long getWriteTimeout() {         return writeTimeout;     }      /**      * Maximum amount of time it should take to send data to the MINA session. Default is 10000 milliseconds.      */     public void setWriteTimeout(long writeTimeout) {         this.writeTimeout = writeTimeout;     }      public long getTimeout() {         return timeout;     }      /**      * You can configure the timeout that specifies how long to wait for a response from a remote server.      * The timeout unit is in milliseconds, so 60000 is 60 seconds.      */     public void setTimeout(long timeout) {         this.timeout = timeout;     }      public boolean isLazySessionCreation() {         return lazySessionCreation;     }      /**      * Sessions can be lazily created to avoid exceptions, if the remote server is not up and running when the Camel producer is started.      */     public void setLazySessionCreation(boolean lazySessionCreation) {         this.lazySessionCreation = lazySessionCreation;     }      public boolean isTransferExchange() {         return transferExchange;     }      /**      * Only used for TCP. You can transfer the exchange over the wire instead of just the body.      * The following fields are transferred: In body, Out body, fault body, In headers, Out headers, fault headers, exchange properties, exchange exception.      * This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.      */     public void setTransferExchange(boolean transferExchange) {         this.transferExchange = transferExchange;     }      /**      * To set the textline protocol encoder max line length. By default the default value of Mina itself is used which are Integer.MAX_VALUE.      */     public void setEncoderMaxLineLength(int encoderMaxLineLength) {         this.encoderMaxLineLength = encoderMaxLineLength;     }      public int getEncoderMaxLineLength() {         return encoderMaxLineLength;     }      /**      * To set the textline protocol decoder max line length. By default the default value of Mina itself is used which are 1024.      */     public void setDecoderMaxLineLength(int decoderMaxLineLength) {         this.decoderMaxLineLength = decoderMaxLineLength;     }      public int getDecoderMaxLineLength() {         return decoderMaxLineLength;     }      public boolean isMinaLogger() {         return minaLogger;     }      /**      * You can enable the Apache MINA logging filter. Apache MINA uses slf4j logging at INFO level to log all input and output.      */     public void setMinaLogger(boolean minaLogger) {         this.minaLogger = minaLogger;     }      public List getFilters() {         return filters;     }      /**      * You can set a list of Mina IoFilters to use.      */     public void setFilters(List filters) {         this.filters = filters;     }      public boolean isDatagramProtocol() {         return protocol.equals(&quot;udp&quot;);     }      /**      * The mina component installs a default codec if both, codec is null and textline is false.      * Setting allowDefaultCodec to false prevents the mina component from installing a default codec as the first element in the filter chain.      * This is useful in scenarios where another filter must be the first in the filter chain, like the SSL filter.      */     public void setAllowDefaultCodec(boolean allowDefaultCodec) {         this.allowDefaultCodec = allowDefaultCodec;     }      public boolean isAllowDefaultCodec() {         return allowDefaultCodec;     }      public boolean isDisconnect() {         return disconnect;     }      /**      * Whether or not to disconnect(close) from Mina session right after use. Can be used for both consumer and producer.      */     public void setDisconnect(boolean disconnect) {         this.disconnect = disconnect;     }      public boolean isDisconnectOnNoReply() {         return disconnectOnNoReply;     }      /**      * If sync is enabled then this option dictates MinaConsumer if it should disconnect where there is no reply to send back.      */     public void setDisconnectOnNoReply(boolean disconnectOnNoReply) {         this.disconnectOnNoReply = disconnectOnNoReply;     }      public LoggingLevel getNoReplyLogLevel() {         return noReplyLogLevel;     }      /**      * If sync is enabled this option dictates MinaConsumer which logging level to use when logging a there is no reply to send back.      */     public void setNoReplyLogLevel(LoggingLevel noReplyLogLevel) {         this.noReplyLogLevel = noReplyLogLevel;     }      public SSLContextParameters getSslContextParameters() {         return sslContextParameters;     }      /**      * To configure SSL security.      */     public void setSslContextParameters(SSLContextParameters sslContextParameters) {         this.sslContextParameters = sslContextParameters;     }      public boolean isAutoStartTls() {         return autoStartTls;     }      /**      * Whether to auto start SSL handshake.      */     public void setAutoStartTls(boolean autoStartTls) {         this.autoStartTls = autoStartTls;     }      public int getMaximumPoolSize() {         return maximumPoolSize;     }      /**      * Number of worker threads in the worker pool for TCP and UDP      */     public void setMaximumPoolSize(int maximumPoolSize) {         this.maximumPoolSize = maximumPoolSize;     }      public boolean isOrderedThreadPoolExecutor() {         return orderedThreadPoolExecutor;     }      /**      * Whether to use ordered thread pool, to ensure events are processed orderly on the same channel.      */     public void setOrderedThreadPoolExecutor(boolean orderedThreadPoolExecutor) {         this.orderedThreadPoolExecutor = orderedThreadPoolExecutor;     }      /**      * Whether to create the InetAddress once and reuse. Setting this to false allows to pickup DNS changes in the network.      */     public void setCachedAddress(boolean shouldCacheAddress) {         this.cachedAddress = shouldCacheAddress;     }      public boolean isCachedAddress() {         return cachedAddress;     }      /**      * If the clientMode is true, mina consumer will connect the address as a TCP client.      */     public void setClientMode(boolean clientMode) {         this.clientMode = clientMode;     }          public boolean isClientMode() {         return clientMode;     }      // here we just shows the option setting of host, port, protocol      public String getUriString() {         return &quot;mina2:&quot; + getProtocol() + &quot;:&quot; + getHost() + &quot;:&quot; + getPort();     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;data class,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11642</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-mina2/src/main/java/org/apache/camel/component/mina2/Mina2Configuration.java/#L35-L416</td>
    <td align="right">1</td>
    <td align="right">1673</td>
    <td align="right">11642</td>
  </tr>
  <tr valign="top">
    <td align="right">1686</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MultiDexConfig {      private String name;      public MultiDexConfig(String name) {         this.name = name;     }      @Config(title = &quot;Whether to enable fast&quot;, message = &quot;Enable atlas , true/false&quot;, order = 0, group = &quot;atlas&quot;)     private boolean fastMultiDex = false;      @Config(title = &quot;The extra first dex class list&quot;, message = &quot;The custom needs to be placed in the entry class in the first dex&quot;, order = 3, group = &quot;atlas&quot;)     private Set firstDexClasses = Sets.newHashSet();     /**      * dex The number of subcontracting, 0 No restrictions, no two merges      */     @Config(title = &quot;dexThe number of&quot;, message = &quot;0unlimited&quot;, order = 1, group = &quot;atlas&quot;)     private int dexCount;      public int getMainDexListCount() {         return mainDexListCount;     }      public void setMainDexListCount(int mainDexListCount) {         this.mainDexListCount = mainDexListCount;     }      private int mainDexListCount;      @Config(title = &quot;dexSeparated rules&quot;, message = &quot;a,b;c,d&quot;, order = 2, group = &quot;atlas&quot;)     private String dexSplitRules;      @Config(title = &quot;Does not enter the list of the first dex's blacklist&quot;, message = &quot;a&quot;, order = 2, group = &quot;atlas&quot;)     private Set mainDexBlackList = Sets.newHashSet();      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public boolean isFastMultiDex() {         return fastMultiDex;     }      public void setFastMultiDex(boolean fastMultiDex) {         this.fastMultiDex = fastMultiDex;     }      public Set getMainDexBlackList() {         return mainDexBlackList;     }      public void setMainDexBlackList(Set mainDexBlackList) {         this.mainDexBlackList = mainDexBlackList;     }      public Set getFirstDexClasses() {         return firstDexClasses;     }      public void setFirstDexClasses(Set firstDexClasses) {         this.firstDexClasses = firstDexClasses;     }      public int getDexCount() {         return dexCount;     }      public void setDexCount(int dexCount) {         this.dexCount = dexCount;     }      public String getDexSplitRules() {         return dexSplitRules;     }      public void setDexSplitRules(String dexSplitRules) {         this.dexSplitRules = dexSplitRules;     } }</td>
    <td align="left">blob</td>
    <td align="left">Blob</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11687</td>
    <td align="left">https://github.com/alibaba/atlas/blob/e8c7b3f1ff14b2a1df64321c6992b796cae7d732/atlas-gradle-plugin/atlas-plugin/src/main/java/com/taobao/android/builder/extension/MultiDexConfig.java/#L220-L302</td>
    <td align="right">1</td>
    <td align="right">1686</td>
    <td align="right">11687</td>
  </tr>
  <tr valign="top">
    <td align="right">1697</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;output&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Blob&quot;,             &quot;Data Class&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  static class ComparerHolder {     static final String UNSAFE_COMPARER_NAME = ComparerHolder.class.getName() + &quot;$UnsafeComparer&quot;;      static final Comparer BEST_COMPARER = getBestComparer();      static Comparer getBestComparer() {       try {         Class theClass = Class.forName(UNSAFE_COMPARER_NAME);          @SuppressWarnings(&quot;unchecked&quot;)         Comparer comparer = (Comparer) theClass.getConstructor().newInstance();         return comparer;       } catch (Throwable t) { // ensure we really catch *everything*         return PureJavaComparer.INSTANCE;       }     }      static final class PureJavaComparer extends Comparer {       static final PureJavaComparer INSTANCE = new PureJavaComparer();        private PureJavaComparer() {}        @Override       public int compareTo(byte [] buf1, int o1, int l1, ByteBuffer buf2, int o2, int l2) {         int end1 = o1 + l1;         int end2 = o2 + l2;         for (int i = o1, j = o2; i &lt; end1 &amp;&amp; j &lt; end2; i++, j++) {           int a = buf1[i] &amp; 0xFF;           int b = buf2.get(j) &amp; 0xFF;           if (a != b) {             return a - b;           }         }         return l1 - l2;       }        @Override       public int compareTo(ByteBuffer buf1, int o1, int l1, ByteBuffer buf2, int o2, int l2) {         int end1 = o1 + l1;         int end2 = o2 + l2;         for (int i = o1, j = o2; i &lt; end1 &amp;&amp; j &lt; end2; i++, j++) {           int a = buf1.get(i) &amp; 0xFF;           int b = buf2.get(j) &amp; 0xFF;           if (a != b) {             return a - b;           }         }         return l1 - l2;       }     }      static final class UnsafeComparer extends Comparer {        public UnsafeComparer() {}        static {         if(!UNSAFE_UNALIGNED) {           throw new Error();         }       }        @Override       public int compareTo(byte[] buf1, int o1, int l1, ByteBuffer buf2, int o2, int l2) {         long offset2Adj;         Object refObj2 = null;         if (buf2.isDirect()) {           offset2Adj = o2 + ((DirectBuffer)buf2).address();         } else {           offset2Adj = o2 + buf2.arrayOffset() + UnsafeAccess.BYTE_ARRAY_BASE_OFFSET;           refObj2 = buf2.array();         }         return compareToUnsafe(buf1, o1 + UnsafeAccess.BYTE_ARRAY_BASE_OFFSET, l1,                 refObj2, offset2Adj, l2);       }        @Override       public int compareTo(ByteBuffer buf1, int o1, int l1, ByteBuffer buf2, int o2, int l2) {         long offset1Adj, offset2Adj;         Object refObj1 = null, refObj2 = null;         if (buf1.isDirect()) {           offset1Adj = o1 + ((DirectBuffer) buf1).address();         } else {           offset1Adj = o1 + buf1.arrayOffset() + UnsafeAccess.BYTE_ARRAY_BASE_OFFSET;           refObj1 = buf1.array();         }         if (buf2.isDirect()) {           offset2Adj = o2 + ((DirectBuffer) buf2).address();         } else {           offset2Adj = o2 + buf2.arrayOffset() + UnsafeAccess.BYTE_ARRAY_BASE_OFFSET;           refObj2 = buf2.array();         }         return compareToUnsafe(refObj1, offset1Adj, l1, refObj2, offset2Adj, l2);       }     }   }</td>
    <td align="left">blob</td>
    <td align="left">Blob, Data Class, Long Method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;Data Class,  Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11729</td>
    <td align="left">https://github.com/apache/hbase/blob/44f8abd5c65c59e9d09f6ad14b3c825f145d8e4f/hbase-common/src/main/java/org/apache/hadoop/hbase/util/ByteBufferUtils.java/#L77-L171</td>
    <td align="right">1</td>
    <td align="right">1697</td>
    <td align="right">11729</td>
  </tr>
  <tr valign="top">
    <td align="right">1729</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are:&quot;: [         &quot;Blob&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DockerRunDialog extends AzureTitleAreaDialogWrapper {      private final String basePath;      // TODO: move to util     private static final String MISSING_ARTIFACT = &quot;A web archive (.war) artifact has not been configured.&quot;;     private static final String MISSING_IMAGE_WITH_TAG = &quot;Please specify Image and Tag.&quot;;     private static final String INVALID_DOCKER_FILE = &quot;Please specify a valid docker file.&quot;;     private static final String INVALID_CERT_PATH = &quot;Please specify a valid certificate path.&quot;;     private static final String INVALID_ARTIFACT_FILE = &quot;The artifact name %s is invalid. &quot;             + &quot;An artifact name may contain only the ASCII letters 'a' through 'z' (case-insensitive), &quot;             + &quot;and the digits '0' through '9', '.', '-' and '_'.&quot;;     private static final String REPO_LENGTH_INVALID = &quot;The length of repository name must be at least one character &quot;             + &quot;and less than 256 characters&quot;;     private static final String CANNOT_END_WITH_SLASH = &quot;The repository name should not end with '/'&quot;;     private static final String REPO_COMPONENT_INVALID = &quot;Invalid repository component: %s, should follow: %s&quot;;     private static final String TAG_LENGTH_INVALID = &quot;The length of tag name must be no more than 128 characters&quot;;     private static final String TAG_INVALID = &quot;Invalid tag: %s, should follow: %s&quot;;     private static final String MISSING_MODEL = &quot;Configuration data model not initialized.&quot;;     private static final String ARTIFACT_NAME_REGEX = &quot;^[.A-Za-z0-9_-]+\\.(war|jar)$&quot;;     private static final String REPO_COMPONENTS_REGEX = &quot;[a-z0-9]+(?:[._-][a-z0-9]+)*&quot;;     private static final String TAG_REGEX = &quot;^[\\w]+[\\w.-]*$&quot;;     private static final int TAG_LENGTH = 128;     private static final int REPO_LENGTH = 255;     private static final String IMAGE_NAME_PREFIX = &quot;localimage&quot;;     private static final String DEFAULT_TAG_NAME = &quot;latest&quot;;     private static final String SELECT_DOCKER_FILE = &quot;Browse...&quot;;      private DockerHostRunSetting dataModel;     private Text txtDockerHost;     private Text txtImageName;     private Text txtTagName;     private Button btnTlsEnabled;     private FileSelector dockerFileSelector;     private FileSelector certPathSelector;      /**      * Create the dialog.      */     public DockerRunDialog(Shell parentShell, String basePath, String targetPath) {         super(parentShell);         setShellStyle(SWT.RESIZE | SWT.TITLE);         this.basePath = basePath;         dataModel = new DockerHostRunSetting();         dataModel.setTargetPath(targetPath);         dataModel.setTargetName(FilenameUtils.getName(targetPath));     }      /**      * Create contents of the dialog.      */     @Override     protected Control createDialogArea(Composite parent) {         Composite area = (Composite) super.createDialogArea(parent);          Composite composite = new Composite(area, SWT.NONE);         composite.setLayout(new GridLayout(5, false));         composite.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true, 1, 1));          dockerFileSelector = new FileSelector(composite, SWT.NONE, false, SELECT_DOCKER_FILE, basePath, &quot;Docker File&quot;);         dockerFileSelector.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false, 5, 1));          Label lblDockerHost = new Label(composite, SWT.NONE);         lblDockerHost.setText(&quot;Docker Host&quot;);          txtDockerHost = new Text(composite, SWT.BORDER);         txtDockerHost.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false, 4, 1));          btnTlsEnabled = new Button(composite, SWT.CHECK);         btnTlsEnabled.addListener(SWT.Selection, event -&gt; onBtnTlsEnabledSelection());         btnTlsEnabled.setText(&quot;Enable TLS&quot;);          certPathSelector = new FileSelector(composite, SWT.NONE, true, &quot;Browse...&quot;, null, &quot;Cert Path&quot;);         certPathSelector.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false, 4, 1));          Label lblImage = new Label(composite, SWT.NONE);         lblImage.setText(&quot;Image Name&quot;);          txtImageName = new Text(composite, SWT.BORDER);         txtImageName.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false, 2, 1));          Label lblTagName = new Label(composite, SWT.NONE);         lblTagName.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false, 1, 1));         lblTagName.setText(&quot;Tag Name&quot;);          txtTagName = new Text(composite, SWT.BORDER);         txtTagName.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false, 1, 1));         setTitle(&quot;Run on Docker Host&quot;);         setMessage(&quot;&quot;); // TOOD: specify the message.          reset();         return area;     }      private void reset() {         // set default dockerHost value         if (Utils.isEmptyString(txtDockerHost.getText())) {             try {                 txtDockerHost.setText(DefaultDockerClient.fromEnv().uri().toString());             } catch (DockerCertificateException e) {                 e.printStackTrace();             }         }         // set default Dockerfile path         String defaultDockerFilePath = DockerUtil.getDefaultDockerFilePathIfExist(basePath);         dockerFileSelector.setFilePath(defaultDockerFilePath);          // set default image and tag         DateFormat df = new SimpleDateFormat(&quot;yyMMddHHmmss&quot;);         String date = df.format(new Date());         if (Utils.isEmptyString(txtImageName.getText())) {             txtImageName.setText(String.format(&quot;%s-%s&quot;, IMAGE_NAME_PREFIX, date));         }         if (Utils.isEmptyString(txtTagName.getText())) {             txtTagName.setText(DEFAULT_TAG_NAME);         }          updateCertPathVisibility();     }      private void onBtnTlsEnabledSelection() {         updateCertPathVisibility();     }      private void updateCertPathVisibility() {         certPathSelector.setVisible(btnTlsEnabled.getSelection());     }      /**      * Create contents of the button bar.      */     @Override     protected void createButtonsForButtonBar(Composite parent) {         createButton(parent, IDialogConstants.OK_ID, IDialogConstants.OK_LABEL, true);         createButton(parent, IDialogConstants.CANCEL_ID, IDialogConstants.CANCEL_LABEL, false);     }      /**      * Return the initial size of the dialog.      */     @Override     protected Point getInitialSize() {         this.getShell().layout(true, true);         return this.getShell().computeSize(SWT.DEFAULT, SWT.DEFAULT, true);     }      @Override     protected boolean isResizable() {         return true;     }      @Override     public boolean isHelpAvailable() {         return false;     }      @Override     protected void okPressed() {         apply();         try {             validate();             execute();             super.okPressed();         } catch (InvalidFormDataException e) {             showErrorMessage(&quot;Error&quot;, e.getMessage());         }     }      private void apply() {         dataModel.setTlsEnabled(btnTlsEnabled.getSelection());         dataModel.setDockerFilePath(dockerFileSelector.getFilePath());         dataModel.setDockerCertPath(certPathSelector.getFilePath());         dataModel.setDockerHost(txtDockerHost.getText());         dataModel.setImageName(txtImageName.getText());         dataModel.setTagName(txtTagName.getText());     }      private void validate() throws InvalidFormDataException {         if (dataModel == null) {             throw new InvalidFormDataException(MISSING_MODEL);         }         // docker file         if (Utils.isEmptyString(dataModel.getDockerFilePath())) {             throw new InvalidFormDataException(INVALID_DOCKER_FILE);         }         File dockerFile = Paths.get(dataModel.getDockerFilePath()).toFile();         if (!dockerFile.exists() || !dockerFile.isFile()) {             throw new InvalidFormDataException(INVALID_DOCKER_FILE);         }         // cert path         if (dataModel.isTlsEnabled()) {             if (Utils.isEmptyString(dataModel.getDockerCertPath())) {                 throw new InvalidFormDataException(INVALID_CERT_PATH);             }             File certPath = Paths.get(dataModel.getDockerCertPath()).toFile();             if (!certPath.exists() || !certPath.isDirectory()) {                 throw new InvalidFormDataException(INVALID_CERT_PATH);             }         }          String imageName = dataModel.getImageName();         String tagName = dataModel.getTagName();         if (Utils.isEmptyString(imageName) || Utils.isEmptyString(tagName)) {             throw new InvalidFormDataException(MISSING_IMAGE_WITH_TAG);         }          // check repository first         if (imageName.length() &lt; 1 || imageName.length() &gt; REPO_LENGTH) {             throw new InvalidFormDataException(REPO_LENGTH_INVALID);         }         if (imageName.endsWith(&quot;/&quot;)) {             throw new InvalidFormDataException(CANNOT_END_WITH_SLASH);         }         final String[] repoComponents = imageName.split(&quot;/&quot;);         for (String component : repoComponents) {             if (!component.matches(REPO_COMPONENTS_REGEX)) {                 throw new InvalidFormDataException(                         String.format(REPO_COMPONENT_INVALID, component, REPO_COMPONENTS_REGEX));             }         }         // check tag         if (tagName.length() &gt; TAG_LENGTH) {             throw new InvalidFormDataException(TAG_LENGTH_INVALID);         }         if (!tagName.matches(TAG_REGEX)) {             throw new InvalidFormDataException(String.format(TAG_INVALID, tagName, TAG_REGEX));         }          // target package         if (Utils.isEmptyString(dataModel.getTargetName())) {             throw new InvalidFormDataException(MISSING_ARTIFACT);         }         if (!dataModel.getTargetName().matches(ARTIFACT_NAME_REGEX)) {             throw new InvalidFormDataException(String.format(INVALID_ARTIFACT_FILE, dataModel.getTargetName()));         }     }      private void execute() {         Observable.fromCallable(() -&gt; {             ConsoleLogger.info(&quot;Starting job ...  &quot;);             if (basePath == null) {                 ConsoleLogger.error(&quot;Project base path is null.&quot;);                 throw new FileNotFoundException(&quot;Project base path is null.&quot;);             }             // locate artifact to specified location             String targetFilePath = dataModel.getTargetPath();             ConsoleLogger.info(String.format(&quot;Locating artifact ... [%s]&quot;, targetFilePath));              // validate dockerfile             Path targetDockerfile = Paths.get(dataModel.getDockerFilePath());             ConsoleLogger.info(String.format(&quot;Validating dockerfile ... [%s]&quot;, targetDockerfile));             if (!targetDockerfile.toFile().exists()) {                 throw new FileNotFoundException(&quot;Dockerfile not found.&quot;);             }              // replace placeholder if exists             String content = new String(Files.readAllBytes(targetDockerfile));             content = content.replaceAll(Constant.DOCKERFILE_ARTIFACT_PLACEHOLDER,                     Paths.get(basePath).toUri().relativize(Paths.get(targetFilePath).toUri()).getPath());             Files.write(targetDockerfile, content.getBytes());              // build image             String imageNameWithTag = String.format(&quot;%s:%s&quot;, dataModel.getImageName(), dataModel.getTagName());             ConsoleLogger.info(String.format(&quot;Building image ...  [%s]&quot;, imageNameWithTag));             DockerClient docker = DockerUtil.getDockerClient(dataModel.getDockerHost(), dataModel.isTlsEnabled(),                     dataModel.getDockerCertPath());             DockerUtil.buildImage(docker, imageNameWithTag, targetDockerfile.getParent(),                     targetDockerfile.getFileName().toString(), new DockerProgressHandler());              // create a container             ConsoleLogger.info(Constant.MESSAGE_CREATING_CONTAINER);             String containerId = DockerUtil.createContainer(docker,                     String.format(&quot;%s:%s&quot;, dataModel.getImageName(), dataModel.getTagName()));             ConsoleLogger.info(String.format(Constant.MESSAGE_CONTAINER_INFO, containerId));              // start container             ConsoleLogger.info(Constant.MESSAGE_STARTING_CONTAINER);             Container container = DockerUtil.runContainer(docker, containerId);             DockerRuntime.getInstance().setRunningContainerId(basePath, container.id(), dataModel);              // props             String hostname = new URI(dataModel.getDockerHost()).getHost();             ImmutableList ports = container.ports();             String publicPort = null;             if (ports != null) {                 for (Container.PortMapping portMapping : ports) {                     if (Constant.TOMCAT_SERVICE_PORT.equals(String.valueOf(portMapping.privatePort()))) {                         publicPort = String.valueOf(portMapping.publicPort());                     }                 }             }              ConsoleLogger.info(String.format(Constant.MESSAGE_CONTAINER_STARTED,                     (hostname != null ? hostname : &quot;localhost&quot;) + (publicPort != null ? &quot;:&quot; + publicPort : &quot;&quot;)));             return null;         }).subscribeOn(SchedulerProviderFactory.getInstance().getSchedulerProvider().io()).subscribe(             ret -&gt; {                 ConsoleLogger.info(&quot;Container started.&quot;);                 sendTelemetry(true, null);             },             e -&gt; {                 e.printStackTrace();                 ConsoleLogger.error(e.getMessage());                 sendTelemetry(false, e.getMessage());             }         );     }      // TODO: refactor later     private void sendTelemetry(boolean success, @Nullable String errorMsg) {         Map map = new HashMap&lt;&gt;();         map.put(&quot;Success&quot;, String.valueOf(success));         if (null != dataModel.getTargetName()) {             map.put(&quot;FileType&quot;, FilenameUtils.getExtension(dataModel.getTargetName()));         } else {             map.put(&quot;FileType&quot;, &quot;&quot;);         }         if (!success) {             map.put(&quot;ErrorMsg&quot;, errorMsg);         }         AppInsightsClient.createByType(AppInsightsClient.EventType.Action, &quot;Docker&quot;, &quot;Run&quot;, map);     }      private void showErrorMessage(String title, String message) {         MessageDialog.openError(this.getShell(), title, message);     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11813</td>
    <td align="left">https://github.com/Microsoft/azure-tools-for-java/blob/d121e8ac9cc3ab400e5b49c8b372280ae332f3fb/PluginsAndFeatures/azure-toolkit-for-eclipse/com.microsoft.azuretools.container/src/main/java/com/microsoft/azuretools/container/ui/DockerRunDialog.java/#L73-L399</td>
    <td align="right">1</td>
    <td align="right">1729</td>
    <td align="right">11813</td>
  </tr>
  <tr valign="top">
    <td align="right">1748</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface UpgradeRequest {     /**      * Add WebSocket Extension Configuration(s) to Upgrade Request.      *       * This is merely the list of requested Extensions to use, see {@link UpgradeResponse#getExtensions()} for what was      * negotiated      *      * @param configs the configuration(s) to add      */     void addExtensions(ExtensionConfig... configs);      /**      * Add WebSocket Extension Configuration(s) to request      *       * This is merely the list of requested Extensions to use, see {@link UpgradeResponse#getExtensions()} for what was      * negotiated      *      * @param configs the configuration(s) to add      */     void addExtensions(String... configs);      /**      * Remove all headers from request.      * @deprecated (no longer supported, as this can undo the required upgrade request headers)      */     @Deprecated     void clearHeaders();      /**      * Get the list of Cookies on the Upgrade request      *      * @return the list of Cookies      */     List getCookies();      /**      * Get the list of WebSocket Extension Configurations for this Upgrade Request.      *       * This is merely the list of requested Extensions to use, see {@link UpgradeResponse#getExtensions()} for what was      * negotiated      *      * @return the list of Extension configurations (in the order they were specified)      */     List getExtensions();      /**      * Get a specific Header value from Upgrade Request      *      * @param name the name of the header      * @return the value of the header (null if header does not exist)      */     String getHeader(String name);      /**      * Get the specific Header value, as an int, from the Upgrade Request.      *      * @param name the name of the header      * @return the value of the header as an int (-1 if header does not exist)      * @throws NumberFormatException if unable to parse value as an int.      */     int getHeaderInt(String name);      /**      * Get the headers as a Map of keys to value lists.      *      * @return the headers      */     Map&gt; getHeaders();      /**      * Get the specific header values (for multi-value headers)      *      * @param name the header name      * @return the value list (null if no header exists)      */     List getHeaders(String name);      /**      * The host of the Upgrade Request URI      *      * @return host of the request URI      */     String getHost();      /**      * The HTTP version used for this Upgrade Request      *       * As of RFC6455 (December 2011) this is always      * HTTP/1.1      *      * @return the HTTP Version used      */     String getHttpVersion();      /**      * The HTTP method for this Upgrade Request.      *       * As of RFC6455 (December 2011) this is always GET      *      * @return the HTTP method used      */     String getMethod();      /**      * The WebSocket Origin of this Upgrade Request      *       * See RFC6455: Section 10.2 for details.      *       * Equivalent to {@link #getHeader(String)} passed the &quot;Origin&quot; header.      *      * @return the Origin header      */     String getOrigin();      /**      * Returns a map of the query parameters of the request.      *      * @return a unmodifiable map of query parameters of the request.      */     Map&gt; getParameterMap();      /**      * Get the WebSocket Protocol Version      *       * As of RFC6455, Jetty only supports version      * 13      *      * @return the WebSocket protocol version      */     String getProtocolVersion();      /**      * Get the Query String of the request URI.      *      * @return the request uri query string      */     String getQueryString();      /**      * Get the Request URI      *      * @return the request URI      */     URI getRequestURI();      /**      * Access the Servlet HTTP Session (if present)      *       * Note: Never present on a Client UpgradeRequest.      *      * @return the Servlet HTTPSession on server side UpgradeRequests      */     Object getSession();      /**      * Get the list of offered WebSocket sub-protocols.      *      * @return the list of offered sub-protocols      */     List getSubProtocols();      /**      * Get the User Principal for this request.      *       * Only applicable when using UpgradeRequest from server side.      *      * @return the user principal      */     Principal getUserPrincipal();      /**      * Test if a specific sub-protocol is offered      *      * @param test the sub-protocol to test for      * @return true if sub-protocol exists on request      */     boolean hasSubProtocol(String test);      /**      * Test if supplied Origin is the same as the Request      *      * @param test the supplied origin      * @return true if the supplied origin matches the request origin      */     boolean isOrigin(String test);      /**      * Test if connection is secure.      *      * @return true if connection is secure.      */     boolean isSecure();      /**      * Set the list of Cookies on the request      *      * @param cookies the cookies to use      */     void setCookies(List cookies);      /**      * Set the list of WebSocket Extension configurations on the request.      * @param configs the list of extension configurations      */     void setExtensions(List configs);      /**      * Set a specific header with multi-value field      *       * Overrides any previous value for this named header      *      * @param name the name of the header      * @param values the multi-value field      */     void setHeader(String name, List values);      /**      * Set a specific header value      *       * Overrides any previous value for this named header      *      * @param name the header to set      * @param value the value to set it to      */     void setHeader(String name, String value);      /**      * Sets multiple headers on the request.      *       * Only sets those headers provided, does not remove      * headers that exist on request and are not provided in the      * parameter for this method.      *       * Convenience method vs calling {@link #setHeader(String, List)} multiple times.      *      * @param headers the headers to set      */     void setHeaders(Map&gt; headers);      /**      * Set the HTTP Version to use.      *       * As of RFC6455 (December 2011) this should always be      * HTTP/1.1      *      * @param httpVersion the HTTP version to use.      */     void setHttpVersion(String httpVersion);      /**      * Set the HTTP method to use.      *       * As of RFC6455 (December 2011) this is always GET      *      * @param method the HTTP method to use.      */     void setMethod(String method);      /**      * Set the Request URI to use for this request.      *       * Must be an absolute URI with scheme 'ws' or 'wss'      *      * @param uri the Request URI      */     void setRequestURI(URI uri);      /**      * Set the Session associated with this request.      *       * Typically used to associate the Servlet HttpSession object.      *      * @param session the session object to associate with this request      */     void setSession(Object session);      /**      * Set the offered WebSocket Sub-Protocol list.      *      * @param protocols the offered sub-protocol list      */     void setSubProtocols(List protocols);      /**      * Set the offered WebSocket Sub-Protocol list.      *      * @param protocols the offered sub-protocol list      */     void setSubProtocols(String... protocols);  }</td>
    <td align="left">blob</td>
    <td align="left">Blob, Data Class, Long Method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;Data Class,  Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11856</td>
    <td align="left">https://github.com/eclipse/jetty.project/blob/65528f76c5ef6ddca11385f9721c8f0bc5f2eed7/jetty-websocket/websocket-api/src/main/java/org/eclipse/jetty/websocket/api/UpgradeRequest.java/#L32-L323</td>
    <td align="right">1</td>
    <td align="right">1748</td>
    <td align="right">11856</td>
  </tr>
  <tr valign="top">
    <td align="right">1764</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@DeferredContextBinding public class RoutesHealthCheckRepository implements CamelContextAware, HealthCheckRepository {     private final ConcurrentMap checks;     private Set blacklist;     private List&gt; evaluators;     private ConcurrentMap&gt;&gt; evaluatorMap;     private volatile CamelContext context;      public RoutesHealthCheckRepository() {         this.checks = new ConcurrentHashMap&lt;&gt;();     }      @Override     public void setCamelContext(CamelContext camelContext) {         this.context = camelContext;     }      @Override     public CamelContext getCamelContext() {         return context;     }      public void setBlacklistedRoutes(Collection blacklistedRoutes) {         blacklistedRoutes.forEach(this::addBlacklistedRoute);     }      public void addBlacklistedRoute(String routeId) {         if (this.blacklist == null) {             this.blacklist = new HashSet&lt;&gt;();         }          this.blacklist.add(routeId);     }      public void setEvaluators(Collection&gt; evaluators) {         evaluators.forEach(this::addEvaluator);     }      public void addEvaluator(PerformanceCounterEvaluator evaluator) {         if (this.evaluators == null) {             this.evaluators = new CopyOnWriteArrayList&lt;&gt;();         }          this.evaluators.add(evaluator);     }      public void setRoutesEvaluators(Map&gt;&gt; evaluators) {         evaluators.forEach(this::setRouteEvaluators);     }      public void setRouteEvaluators(String routeId, Collection&gt; evaluators) {         evaluators.forEach(evaluator -&gt; addRouteEvaluator(routeId, evaluator));     }      public void addRouteEvaluator(String routeId, PerformanceCounterEvaluator evaluator) {         if (this.evaluatorMap == null) {             this.evaluatorMap = new ConcurrentHashMap&lt;&gt;();         }          this.evaluatorMap.computeIfAbsent(routeId, id -&gt; new CopyOnWriteArrayList&lt;&gt;()).add(evaluator);     }      public Stream&gt; evaluators() {         return this.evaluators != null             ? this.evaluators.stream()             : Stream.empty();     }      public Stream&gt; evaluators(String routeId) {         return this.evaluatorMap != null             ? evaluatorMap.getOrDefault(routeId, Collections.emptyList()).stream()             : Stream.empty();     }      @Override     public Stream stream() {         // This is not really efficient as getRoutes() creates a copy of the routes         // array for each invocation. It would be nice to have more stream oriented         // operation on CamelContext i.e.         //         // interface CamelContext {         //         //     Stream routes();         //         //     void forEachRoute(Consumer consumer);         // }         //         return this.context != null             ? this.context.getRoutes()                 .stream()                 .filter(route -&gt; route.getId() != null)                 .filter(route -&gt; isNotBlacklisted(route))                 .map(this::toRouteHealthCheck)             : Stream.empty();     }      // *****************************     // Helpers     // *****************************      private boolean isNotBlacklisted(Route route) {         return this.blacklist != null             ? !this.blacklist.contains(route.getId())             : true;     }      private HealthCheck toRouteHealthCheck(Route route) {         return checks.computeIfAbsent(             route,             r -&gt; {                 HealthCheck check = new RouteHealthCheck(                     route,                     evaluatorMap != null                         ? evaluatorMap.getOrDefault(r.getId(), evaluators)                         : evaluators                 );                  check.getConfiguration().setEnabled(true);                  return check;             }         );     } }</td>
    <td align="left">blob</td>
    <td align="left">Blob</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11900</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/core/camel-base/src/main/java/org/apache/camel/impl/health/RoutesHealthCheckRepository.java/#L38-L161</td>
    <td align="right">1</td>
    <td align="right">1764</td>
    <td align="right">11900</td>
  </tr>
  <tr valign="top">
    <td align="right">1777</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Blob&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MessageComponent extends UIOutput {       // ------------------------------------------------------------ Constructors       /**      * Create a new {@link MessageComponent} with default properties.      */     public MessageComponent() {          super();         setRendererType(&quot;org.apache.struts.faces.Message&quot;);      }       // ------------------------------------------------------ Instance Variables       /**      * MessageResources attribute key to use for message lookup.      */     private String bundle = null;       /**      * Flag indicating whether output should be filtered.      */     private boolean filter = true;     private boolean filterSet = false;       /**      * Message key to use for message lookup.      */     private String key = null;       /**      * CSS style(s) to be rendered for this component.      */     private String style = null;       /**      * CSS style class(es) to be rendered for this component.      */     private String styleClass = null;       // ---------------------------------------------------- Component Properties       /**      * Return the MessageResources key.      */     public String getBundle() {          ValueBinding vb = getValueBinding(&quot;bundle&quot;);         if (vb != null) {             return (String) vb.getValue(getFacesContext());         } else {             return bundle;         }      }       /**      * Set the MessageResources key.      *      * @param bundle The new key      */     public void setBundle(String bundle) {          this.bundle = bundle;      }       /**      * Return the component family to which this component belongs.      */     public String getFamily() {          return &quot;org.apache.struts.faces.Message&quot;;      }       /**      * Return a flag indicating whether filtering should take place.      */     public boolean isFilter() {          if (filterSet) {             return filter;         }         ValueBinding vb = getValueBinding(&quot;filter&quot;);         if (vb != null) {             Boolean value = (Boolean) vb.getValue(getFacesContext());             if (null == value) {                 return filter;             }             return value.booleanValue();         } else {             return filter;         }      }       /**      * Set the flag indicating that the output value should be filtered.      *      * @param filter The new filter flag      */     public void setFilter(boolean filter) {          this.filter = filter;         this.filterSet = true;      }       /**      * Return the message key.      */     public String getKey() {          ValueBinding vb = getValueBinding(&quot;key&quot;);         if (vb != null) {             return (String) vb.getValue(getFacesContext());         } else {             return key;         }      }       /**      * Set the message key.      *      * @param key The new key      */     public void setKey(String key) {          this.key = key;      }       /**      * Return the CSS style(s) to be rendered for this component.      */     public String getStyle() {          ValueBinding vb = getValueBinding(&quot;style&quot;);         if (vb != null) {             return (String) vb.getValue(getFacesContext());         } else {             return style;         }      }       /**      * Set the CSS style(s) to be rendered for this component.      *      * @param style The new CSS style(s)      */     public void setStyle(String style) {          this.style = style;      }       /**      * Return the CSS style class(es) to be rendered for this component.      */     public String getStyleClass() {          ValueBinding vb = getValueBinding(&quot;styleClass&quot;);         if (vb != null) {             return (String) vb.getValue(getFacesContext());         } else {             return styleClass;         }      }       /**      * Set the CSS style class(es) to be rendered for this component.      *      * @param styleClass The new CSS style class(es)      */     public void setStyleClass(String styleClass) {          this.styleClass = styleClass;      }       // ---------------------------------------------------- StateManager Methods       /**      * Restore the state of this component.      *      * @param context FacesContext for the current request      * @param state State object from which to restore our state      */     public void restoreState(FacesContext context, Object state) {          Object values[] = (Object[]) state;         super.restoreState(context, values[0]);         bundle = (String) values[1];         filter = ((Boolean) values[2]).booleanValue();         filterSet = ((Boolean) values[3]).booleanValue();         key = (String) values[4];         style = (String) values[5];         styleClass = (String) values[6];      }       /**      * Save the state of this component.      *      * @param context FacesContext for the current request      */     public Object saveState(FacesContext context) {          Object values[] = new Object[7];         values[0] = super.saveState(context);         values[1] = bundle;         values[2] = filter ? Boolean.TRUE : Boolean.FALSE;         values[3] = filterSet ? Boolean.TRUE : Boolean.FALSE;         values[4] = key;         values[5] = style;         values[6] = styleClass;         return values;      }   }</td>
    <td align="left">blob</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11957</td>
    <td align="left">https://github.com/apache/struts1/blob/02c9ff7485b1900515c6e0b32ed54ea46dd97d51/faces/src/main/java/org/apache/struts/faces/component/MessageComponent.java/#L35-L285</td>
    <td align="right">1</td>
    <td align="right">1777</td>
    <td align="right">11957</td>
  </tr>
  <tr valign="top">
    <td align="right">1778</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DataSourceLoginService extends AbstractLoginService {     private static final Logger LOG = Log.getLogger(DataSourceLoginService.class);      private String _jndiName = &quot;javax.sql.DataSource/default&quot;;     private DataSource _datasource;     private Server _server;     private String _userTableName = &quot;users&quot;;     private String _userTableKey = &quot;id&quot;;     private String _userTableUserField = &quot;username&quot;;     private String _userTablePasswordField = &quot;pwd&quot;;     private String _roleTableName = &quot;roles&quot;;     private String _roleTableKey = &quot;id&quot;;     private String _roleTableRoleField = &quot;role&quot;;     private String _userRoleTableName = &quot;user_roles&quot;;     private String _userRoleTableUserKey = &quot;user_id&quot;;     private String _userRoleTableRoleKey = &quot;role_id&quot;;     private String _userSql;     private String _roleSql;     private boolean _createTables = false;               /**      * DBUser      */     public class DBUserPrincipal extends UserPrincipal     {         private int _key;                  public DBUserPrincipal(String name, Credential credential, int key)         {             super(name, credential);             _key = key;         }                  public int getKey ()         {             return _key;         }              }      /* ------------------------------------------------------------ */     public DataSourceLoginService()     {     }      /* ------------------------------------------------------------ */     public DataSourceLoginService(String name)     {         setName(name);     }      /* ------------------------------------------------------------ */     public DataSourceLoginService(String name, IdentityService identityService)     {         setName(name);         setIdentityService(identityService);     }      /* ------------------------------------------------------------ */     public void setJndiName (String jndi)     {         _jndiName = jndi;     }      /* ------------------------------------------------------------ */     public String getJndiName ()     {         return _jndiName;     }      /* ------------------------------------------------------------ */     public void setServer (Server server)     {         _server=server;     }      /* ------------------------------------------------------------ */     public Server getServer()     {         return _server;     }      /* ------------------------------------------------------------ */     public void setCreateTables(boolean createTables)     {         _createTables = createTables;     }      /* ------------------------------------------------------------ */     public boolean getCreateTables()     {         return _createTables;     }      /* ------------------------------------------------------------ */     public void setUserTableName (String name)     {         _userTableName=name;     }      /* ------------------------------------------------------------ */     public String getUserTableName()     {         return _userTableName;     }      /* ------------------------------------------------------------ */     public String getUserTableKey()     {         return _userTableKey;     }       /* ------------------------------------------------------------ */     public void setUserTableKey(String tableKey)     {         _userTableKey = tableKey;     }       /* ------------------------------------------------------------ */     public String getUserTableUserField()     {         return _userTableUserField;     }       /* ------------------------------------------------------------ */     public void setUserTableUserField(String tableUserField)     {         _userTableUserField = tableUserField;     }       /* ------------------------------------------------------------ */     public String getUserTablePasswordField()     {         return _userTablePasswordField;     }       /* ------------------------------------------------------------ */     public void setUserTablePasswordField(String tablePasswordField)     {         _userTablePasswordField = tablePasswordField;     }       /* ------------------------------------------------------------ */     public String getRoleTableName()     {         return _roleTableName;     }       /* ------------------------------------------------------------ */     public void setRoleTableName(String tableName)     {         _roleTableName = tableName;     }       /* ------------------------------------------------------------ */     public String getRoleTableKey()     {         return _roleTableKey;     }       /* ------------------------------------------------------------ */     public void setRoleTableKey(String tableKey)     {         _roleTableKey = tableKey;     }       /* ------------------------------------------------------------ */     public String getRoleTableRoleField()     {         return _roleTableRoleField;     }       /* ------------------------------------------------------------ */     public void setRoleTableRoleField(String tableRoleField)     {         _roleTableRoleField = tableRoleField;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableName()     {         return _userRoleTableName;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableName(String roleTableName)     {         _userRoleTableName = roleTableName;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableUserKey()     {         return _userRoleTableUserKey;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableUserKey(String roleTableUserKey)     {         _userRoleTableUserKey = roleTableUserKey;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableRoleKey()     {         return _userRoleTableRoleKey;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableRoleKey(String roleTableRoleKey)     {         _userRoleTableRoleKey = roleTableRoleKey;     }              /* ------------------------------------------------------------ */     @Override     public UserPrincipal loadUserInfo (String username)     {         try         {             try (Connection connection = getConnection();                     PreparedStatement statement1 = connection.prepareStatement(_userSql))             {                 statement1.setObject(1, username);                 try (ResultSet rs1 = statement1.executeQuery())                 {                     if (rs1.next())                     {                         int key = rs1.getInt(_userTableKey);                         String credentials = rs1.getString(_userTablePasswordField);                                                  return new DBUserPrincipal(username, Credential.getCredential(credentials), key);                     }                 }             }         }         catch (NamingException e)         {             LOG.warn(&quot;No datasource for &quot;+_jndiName, e);         }         catch (SQLException e)         {             LOG.warn(&quot;Problem loading user info for &quot;+username, e);         }         return null;     }               /* ------------------------------------------------------------ */     @Override     public String[] loadRoleInfo (UserPrincipal user)     {         DBUserPrincipal dbuser = (DBUserPrincipal)user;          try         {             try (Connection connection = getConnection();                     PreparedStatement statement2 = connection.prepareStatement(_roleSql))             {                  List roles = new ArrayList();                  statement2.setInt(1, dbuser.getKey());                 try (ResultSet rs2 = statement2.executeQuery())                 {                     while (rs2.next())                     {                         roles.add(rs2.getString(_roleTableRoleField));                     }                                          return roles.toArray(new String[roles.size()]);                 }             }         }         catch (NamingException e)         {             LOG.warn(&quot;No datasource for &quot;+_jndiName, e);         }         catch (SQLException e)         {             LOG.warn(&quot;Problem loading user info for &quot;+user.getName(), e);         }         return null;     }             /* ------------------------------------------------------------ */     /**      * Lookup the datasource for the jndiName and formulate the      * necessary sql query strings based on the configured table      * and column names.      *      * @throws NamingException if unable to init jndi      * @throws SQLException if unable to init database      */     public void initDb() throws NamingException, SQLException     {         if (_datasource != null)             return;          @SuppressWarnings(&quot;unused&quot;)         InitialContext ic = new InitialContext();         assert ic!=null;          // TODO Should we try webapp scope too?          // try finding the datasource in the Server scope         if (_server != null)         {             try             {                 _datasource = (DataSource)NamingEntryUtil.lookup(_server, _jndiName);             }             catch (NameNotFoundException e)             {                 //next try the jvm scope             }         }           //try finding the datasource in the jvm scope         if (_datasource==null)         {             _datasource = (DataSource)NamingEntryUtil.lookup(null, _jndiName);         }          // set up the select statements based on the table and column names configured         _userSql = &quot;select &quot; + _userTableKey + &quot;,&quot; + _userTablePasswordField                   + &quot; from &quot; + _userTableName                   + &quot; where &quot;+ _userTableUserField + &quot; = ?&quot;;          _roleSql = &quot;select r.&quot; + _roleTableRoleField                   + &quot; from &quot; + _roleTableName + &quot; r, &quot; + _userRoleTableName                   + &quot; u where u.&quot;+ _userRoleTableUserKey + &quot; = ?&quot;                   + &quot; and r.&quot; + _roleTableKey + &quot; = u.&quot; + _userRoleTableRoleKey;          prepareTables();     }      /* ------------------------------------------------------------ */     /**      * @throws NamingException      * @throws SQLException      */     private void prepareTables()     throws NamingException, SQLException     {         if (_createTables)         {             boolean autocommit = true;             Connection connection = getConnection();             try (Statement stmt = connection.createStatement())             {                 autocommit = connection.getAutoCommit();                 connection.setAutoCommit(false);                 DatabaseMetaData metaData = connection.getMetaData();                  //check if tables exist                 String tableName = (metaData.storesLowerCaseIdentifiers()? _userTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userTableName.toUpperCase(Locale.ENGLISH): _userTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //user table default                         /*                          * create table _userTableName (_userTableKey integer,                          * _userTableUserField varchar(100) not null unique,                          * _userTablePasswordField varchar(20) not null, primary key(_userTableKey));                          */                         stmt.executeUpdate(&quot;create table &quot;+_userTableName+ &quot;(&quot;+_userTableKey+&quot; integer,&quot;+                                 _userTableUserField+&quot; varchar(100) not null unique,&quot;+                                 _userTablePasswordField+&quot; varchar(20) not null, primary key(&quot;+_userTableKey+&quot;))&quot;);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_userTableName);                     }                 }                  tableName = (metaData.storesLowerCaseIdentifiers()? _roleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_roleTableName.toUpperCase(Locale.ENGLISH): _roleTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //role table default                         /*                          * create table _roleTableName (_roleTableKey integer,                          * _roleTableRoleField varchar(100) not null unique, primary key(_roleTableKey));                          */                         String str = &quot;create table &quot;+_roleTableName+&quot; (&quot;+_roleTableKey+&quot; integer, &quot;+                         _roleTableRoleField+&quot; varchar(100) not null unique, primary key(&quot;+_roleTableKey+&quot;))&quot;;                         stmt.executeUpdate(str);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_roleTableName);                     }                 }                  tableName = (metaData.storesLowerCaseIdentifiers()? _userRoleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userRoleTableName.toUpperCase(Locale.ENGLISH): _userRoleTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //user-role table                         /*                          * create table _userRoleTableName (_userRoleTableUserKey integer,                          * _userRoleTableRoleKey integer,                          * primary key (_userRoleTableUserKey, _userRoleTableRoleKey));                          *                          * create index idx_user_role on _userRoleTableName (_userRoleTableUserKey);                          */                         stmt.executeUpdate(&quot;create table &quot;+_userRoleTableName+&quot; (&quot;+_userRoleTableUserKey+&quot; integer, &quot;+                                 _userRoleTableRoleKey+&quot; integer, &quot;+                                 &quot;primary key (&quot;+_userRoleTableUserKey+&quot;, &quot;+_userRoleTableRoleKey+&quot;))&quot;);                         stmt.executeUpdate(&quot;create index indx_user_role on &quot;+_userRoleTableName+&quot;(&quot;+_userRoleTableUserKey+&quot;)&quot;);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_userRoleTableName +&quot; and index&quot;);                     }                 }                 connection.commit();             }             finally             {                 try                 {                     connection.setAutoCommit(autocommit);                 }                 catch (SQLException e)                 {                     if (LOG.isDebugEnabled()) LOG.debug(&quot;Prepare tables&quot;, e);                 }                 finally                 {                     try                     {                         connection.close();                     }                     catch (SQLException e)                     {                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Prepare tables&quot;, e);                     }                 }             }         }         else if (LOG.isDebugEnabled())         {             LOG.debug(&quot;createTables false&quot;);         }     }      /* ------------------------------------------------------------ */     /**      * @return      * @throws NamingException      * @throws SQLException      */     private Connection getConnection ()     throws NamingException, SQLException     {         initDb();         return _datasource.getConnection();     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11958</td>
    <td align="left">https://github.com/eclipse/jetty.project/blob/65528f76c5ef6ddca11385f9721c8f0bc5f2eed7/jetty-plus/src/main/java/org/eclipse/jetty/plus/security/DataSourceLoginService.java/#L52-L530</td>
    <td align="right">1</td>
    <td align="right">1778</td>
    <td align="right">11958</td>
  </tr>
  <tr valign="top">
    <td align="right">1782</td>
    <td align="left">{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Blob&quot;,     &quot;Data Class&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = &quot;@class&quot;) @JsonSubTypes({ 	@JsonSubTypes.Type(value = SubtaskCheckpointStatistics.CompletedSubtaskCheckpointStatistics.class, name = &quot;completed&quot;), 	@JsonSubTypes.Type(value = SubtaskCheckpointStatistics.PendingSubtaskCheckpointStatistics.class, name = &quot;pending&quot;)}) public class SubtaskCheckpointStatistics {  	public static final String FIELD_NAME_INDEX = &quot;index&quot;;  	public static final String FIELD_NAME_CHECKPOINT_STATUS = &quot;status&quot;;  	@JsonProperty(FIELD_NAME_INDEX) 	private final int index;  	@JsonProperty(FIELD_NAME_CHECKPOINT_STATUS) 	private final String checkpointStatus;  	@JsonCreator 	private SubtaskCheckpointStatistics( 			@JsonProperty(FIELD_NAME_INDEX) int index, 			@JsonProperty(FIELD_NAME_CHECKPOINT_STATUS) String checkpointStatus) { 		this.index = index; 		this.checkpointStatus = checkpointStatus; 	}  	public int getIndex() { 		return index; 	}  	public String getCheckpointStatus() { 		return checkpointStatus; 	}  	@Override 	public boolean equals(Object o) { 		if (this == o) { 			return true; 		} 		if (o == null || getClass() != o.getClass()) { 			return false; 		} 		SubtaskCheckpointStatistics that = (SubtaskCheckpointStatistics) o; 		return index == that.index &amp;&amp; 			Objects.equals(checkpointStatus, that.checkpointStatus); 	}  	@Override 	public int hashCode() { 		return Objects.hash(index, checkpointStatus); 	}  	// --------------------------------------------------------------------------------- 	// Static inner classes 	// ---------------------------------------------------------------------------------  	/** 	 * Checkpoint statistics for a completed subtask checkpoint. 	 */ 	public static final class CompletedSubtaskCheckpointStatistics extends SubtaskCheckpointStatistics {  		public static final String FIELD_NAME_ACK_TIMESTAMP = &quot;ack_timestamp&quot;;  		public static final String FIELD_NAME_DURATION = &quot;end_to_end_duration&quot;;  		public static final String FIELD_NAME_STATE_SIZE = &quot;state_size&quot;;  		public static final String FIELD_NAME_CHECKPOINT_DURATION = &quot;checkpoint&quot;;  		public static final String FIELD_NAME_ALIGNMENT = &quot;alignment&quot;;  		@JsonProperty(FIELD_NAME_ACK_TIMESTAMP) 		private final long ackTimestamp;  		@JsonProperty(FIELD_NAME_DURATION) 		private final long duration;  		@JsonProperty(FIELD_NAME_STATE_SIZE) 		private final long stateSize;  		@JsonProperty(FIELD_NAME_CHECKPOINT_DURATION) 		private final CheckpointDuration checkpointDuration;  		@JsonProperty(FIELD_NAME_ALIGNMENT) 		private final CheckpointAlignment alignment;  		@JsonCreator 		public CompletedSubtaskCheckpointStatistics( 				@JsonProperty(FIELD_NAME_INDEX) int index, 				@JsonProperty(FIELD_NAME_ACK_TIMESTAMP) long ackTimestamp, 				@JsonProperty(FIELD_NAME_DURATION) long duration, 				@JsonProperty(FIELD_NAME_STATE_SIZE) long stateSize, 				@JsonProperty(FIELD_NAME_CHECKPOINT_DURATION) CheckpointDuration checkpointDuration, 				@JsonProperty(FIELD_NAME_ALIGNMENT) CheckpointAlignment alignment) { 			super(index, &quot;completed&quot;); 			this.ackTimestamp = ackTimestamp; 			this.duration = duration; 			this.stateSize = stateSize; 			this.checkpointDuration = checkpointDuration; 			this.alignment = alignment; 		}  		public long getAckTimestamp() { 			return ackTimestamp; 		}  		public long getDuration() { 			return duration; 		}  		public long getStateSize() { 			return stateSize; 		}  		public CheckpointDuration getCheckpointDuration() { 			return checkpointDuration; 		}  		public CheckpointAlignment getAlignment() { 			return alignment; 		}  		@Override 		public boolean equals(Object o) { 			if (this == o) { 				return true; 			} 			if (o == null || getClass() != o.getClass()) { 				return false; 			} 			CompletedSubtaskCheckpointStatistics that = (CompletedSubtaskCheckpointStatistics) o; 			return ackTimestamp == that.ackTimestamp &amp;&amp; 				duration == that.duration &amp;&amp; 				stateSize == that.stateSize &amp;&amp; 				Objects.equals(checkpointDuration, that.checkpointDuration) &amp;&amp; 				Objects.equals(alignment, that.alignment); 		}  		@Override 		public int hashCode() { 			return Objects.hash(ackTimestamp, duration, stateSize, checkpointDuration, alignment); 		}  		/** 		 * Duration of the checkpoint. 		 */ 		public static final class CheckpointDuration {  			public static final String FIELD_NAME_SYNC_DURATION = &quot;sync&quot;;  			public static final String FIELD_NAME_ASYNC_DURATION = &quot;async&quot;;  			@JsonProperty(FIELD_NAME_SYNC_DURATION) 			private final long syncDuration;  			@JsonProperty(FIELD_NAME_ASYNC_DURATION) 			private final long asyncDuration;  			@JsonCreator 			public CheckpointDuration( 					@JsonProperty(FIELD_NAME_SYNC_DURATION) long syncDuration, 					@JsonProperty(FIELD_NAME_ASYNC_DURATION) long asyncDuration) { 				this.syncDuration = syncDuration; 				this.asyncDuration = asyncDuration; 			}  			public long getSyncDuration() { 				return syncDuration; 			}  			public long getAsyncDuration() { 				return asyncDuration; 			}  			@Override 			public boolean equals(Object o) { 				if (this == o) { 					return true; 				} 				if (o == null || getClass() != o.getClass()) { 					return false; 				} 				CheckpointDuration that = (CheckpointDuration) o; 				return syncDuration == that.syncDuration &amp;&amp; 					asyncDuration == that.asyncDuration; 			}  			@Override 			public int hashCode() { 				return Objects.hash(syncDuration, asyncDuration); 			} 		}  		/** 		 * Alignment statistics of the checkpoint. 		 */ 		public static final class CheckpointAlignment {  			public static final String FIELD_NAME_ALIGNMENT_BUFFERED = &quot;buffered&quot;;  			public static final String FIELD_NAME_ALIGNMENT_DURATION = &quot;duration&quot;;  			@JsonProperty(FIELD_NAME_ALIGNMENT_BUFFERED) 			private final long alignmentBuffered;  			@JsonProperty(FIELD_NAME_ALIGNMENT_DURATION) 			private final long alignmentDuration;  			@JsonCreator 			public CheckpointAlignment( 					@JsonProperty(FIELD_NAME_ALIGNMENT_BUFFERED) long alignmentBuffered, 					@JsonProperty(FIELD_NAME_ALIGNMENT_DURATION) long alignmentDuration) { 				this.alignmentBuffered = alignmentBuffered; 				this.alignmentDuration = alignmentDuration; 			}  			public long getAlignmentBuffered() { 				return alignmentBuffered; 			}  			public long getAlignmentDuration() { 				return alignmentDuration; 			}  			@Override 			public boolean equals(Object o) { 				if (this == o) { 					return true; 				} 				if (o == null || getClass() != o.getClass()) { 					return false; 				} 				CheckpointAlignment that = (CheckpointAlignment) o; 				return alignmentBuffered == that.alignmentBuffered &amp;&amp; 					alignmentDuration == that.alignmentDuration; 			}  			@Override 			public int hashCode() { 				return Objects.hash(alignmentBuffered, alignmentDuration); 			} 		} 	}  	/** 	 * Checkpoint statistics for a pending subtask checkpoint. 	 */ 	public static final class PendingSubtaskCheckpointStatistics extends SubtaskCheckpointStatistics {  		@JsonCreator 		public PendingSubtaskCheckpointStatistics(@JsonProperty(FIELD_NAME_INDEX) int index) { 			super(index, &quot;pending_or_failed&quot;); 		} 	} }</td>
    <td align="left">blob</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;data class,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11964</td>
    <td align="left">https://github.com/apache/flink/blob/8068c8775ad067d75828e6360e7e0994348da9b9/flink-runtime/src/main/java/org/apache/flink/runtime/rest/messages/checkpoints/SubtaskCheckpointStatistics.java/#L31-L283</td>
    <td align="right">1</td>
    <td align="right">1782</td>
    <td align="right">11964</td>
  </tr>
  <tr valign="top">
    <td align="right">1824</td>
    <td align="left">{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;the bad smells are:&quot;,     &quot;1. Blob&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class PersistentReplicatedTestBase extends JUnit4CacheTestCase {    protected static final int MAX_WAIT = 60 * 1000;   protected static String REGION_NAME = &quot;region&quot;;   protected File diskDir;   protected static String SAVED_ACK_WAIT_THRESHOLD;    @Override   public final void postSetUp() throws Exception {     Invoke.invokeInEveryVM(PersistentReplicatedTestBase.class, &quot;setRegionName&quot;,         new Object[] {getUniqueName()});     setRegionName(getUniqueName());     diskDir = new File(&quot;diskDir-&quot; + getName()).getAbsoluteFile();     FileUtils.deleteDirectory(diskDir);     diskDir.mkdir();     diskDir.deleteOnExit();   }    public static void setRegionName(String testName) {     REGION_NAME = testName + &quot;Region&quot;;   }    @Override   public final void postTearDownCacheTestCase() throws Exception {     FileUtils.deleteDirectory(diskDir);     postTearDownPersistentReplicatedTestBase();   }    protected void postTearDownPersistentReplicatedTestBase() throws Exception {}    protected void waitForBlockedInitialization(VM vm) {     vm.invoke(new SerializableRunnable() {        @Override       public void run() {         GeodeAwaitility.await().untilAsserted(new WaitCriterion() {            @Override           public String description() {             return &quot;Waiting for another persistent member to come online&quot;;           }            @Override           public boolean done() {             GemFireCacheImpl cache = (GemFireCacheImpl) getCache();             PersistentMemberManager mm = cache.getPersistentMemberManager();             Map&gt; regions = mm.getWaitingRegions();             boolean done = !regions.isEmpty();             return done;           }          });        }      });   }    protected SerializableRunnable createPersistentRegionWithoutCompaction(final VM vm0) {     SerializableRunnable createRegion = new SerializableRunnable(&quot;Create persistent region&quot;) {       @Override       public void run() {         Cache cache = getCache();         DiskStoreFactory dsf = cache.createDiskStoreFactory();         File dir = getDiskDirForVM(vm0);         dir.mkdirs();         dsf.setDiskDirs(new File[] {dir});         dsf.setMaxOplogSize(1);         dsf.setAutoCompact(false);         dsf.setAllowForceCompaction(true);         dsf.setCompactionThreshold(20);         DiskStore ds = dsf.create(REGION_NAME);         RegionFactory rf = new RegionFactory();         rf.setDiskStoreName(ds.getName());         rf.setDiskSynchronous(true);         rf.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);         rf.setScope(Scope.DISTRIBUTED_ACK);         rf.create(REGION_NAME);       }     };     vm0.invoke(createRegion);     return createRegion;   }    protected void closeRegion(final VM vm) {     SerializableRunnable closeRegion = new SerializableRunnable(&quot;Close persistent region&quot;) {       @Override       public void run() {         Cache cache = getCache();         Region region = cache.getRegion(REGION_NAME);         region.close();       }     };     vm.invoke(closeRegion);   }    protected void closeCache(final VM vm) {     SerializableRunnable closeCache = new SerializableRunnable(&quot;close cache&quot;) {       @Override       public void run() {         Cache cache = getCache();         cache.close();       }     };     vm.invoke(closeCache);   }    protected AsyncInvocation closeCacheAsync(VM vm0) {     SerializableRunnable close = new SerializableRunnable() {       @Override       public void run() {         Cache cache = getCache();         cache.close();       }     };      return vm0.invokeAsync(close);   }    protected void createNonPersistentRegion(VM vm) throws Exception {     SerializableRunnable createRegion = new SerializableRunnable(&quot;Create non persistent region&quot;) {       @Override       public void run() {         Cache cache = getCache();         RegionFactory rf = new RegionFactory();         rf.setDataPolicy(DataPolicy.REPLICATE);         rf.setScope(Scope.DISTRIBUTED_ACK);         rf.create(REGION_NAME);       }     };     vm.invoke(createRegion);   }    protected AsyncInvocation createPersistentRegionWithWait(VM vm) throws Exception {     return _createPersistentRegion(vm, true);   }    protected void createPersistentRegion(VM vm) throws Exception {     _createPersistentRegion(vm, false);   }    private AsyncInvocation _createPersistentRegion(VM vm, boolean wait) throws Exception {     AsyncInvocation future = createPersistentRegionAsync(vm);     long waitTime = wait ? 500 : MAX_WAIT;     future.join(waitTime);     if (future.isAlive() &amp;&amp; !wait) {       fail(&quot;Region not created within&quot; + MAX_WAIT);     }     if (!future.isAlive() &amp;&amp; wait) {       fail(&quot;Did not expect region creation to complete&quot;);     }     if (!wait &amp;&amp; future.exceptionOccurred()) {       throw new RuntimeException(future.getException());     }     return future;   }    protected AsyncInvocation createPersistentRegionAsync(final VM vm) {     SerializableRunnable createRegion = new SerializableRunnable(&quot;Create persistent region&quot;) {       @Override       public void run() {         Cache cache = getCache();         DiskStoreFactory dsf = cache.createDiskStoreFactory();         File dir = getDiskDirForVM(vm);         dir.mkdirs();         dsf.setDiskDirs(new File[] {dir});         dsf.setMaxOplogSize(1);         DiskStore ds = dsf.create(REGION_NAME);         RegionFactory rf = new RegionFactory();         rf.setDiskStoreName(ds.getName());         rf.setDiskSynchronous(true);         rf.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);         rf.setScope(Scope.DISTRIBUTED_ACK);         rf.create(REGION_NAME);       }     };     return vm.invokeAsync(createRegion);   }    protected File getDiskDirForVM(final VM vm) {     File dir = new File(diskDir, String.valueOf(vm.getId()));     return dir;   }    protected void backupDir(VM vm) throws IOException {     File dirForVM = getDiskDirForVM(vm);     File backFile = new File(dirForVM.getParent(), dirForVM.getName() + &quot;.bk&quot;);     FileUtils.copyDirectory(dirForVM, backFile);   }    protected void restoreBackup(VM vm) throws IOException {     File dirForVM = getDiskDirForVM(vm);     File backFile = new File(dirForVM.getParent(), dirForVM.getName() + &quot;.bk&quot;);     if (!backFile.renameTo(dirForVM)) {       FileUtils.deleteDirectory(dirForVM);       FileUtils.copyDirectory(backFile, dirForVM);       FileUtils.deleteDirectory(backFile);     }   }  }</td>
    <td align="left">blob</td>
    <td align="left">the bad smells are:, 1 Blob</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">the bad smells are:</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12104</td>
    <td align="left">https://github.com/apache/geode/blob/8fd839e8b73e40bd2dfd14f331b587431bd35a66/geode-core/src/distributedTest/java/org/apache/geode/internal/cache/persistence/PersistentReplicatedTestBase.java/#L42-L242</td>
    <td align="right">1</td>
    <td align="right">1824</td>
    <td align="right">12104</td>
  </tr>
  <tr valign="top">
    <td align="right">1850</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;1. Long Method&quot;, &quot;2. Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LuceneIndexForPartitionedRegion extends LuceneIndexImpl {   protected Region fileAndChunkRegion;   protected final FileSystemStats fileSystemStats;    public static final String FILES_REGION_SUFFIX = &quot;.files&quot;;    private final ExecutorService waitingThreadPoolFromDM;    public LuceneIndexForPartitionedRegion(String indexName, String regionPath, InternalCache cache) {     super(indexName, regionPath, cache);     this.waitingThreadPoolFromDM = cache.getDistributionManager().getWaitingThreadPool();      final String statsName = indexName + &quot;-&quot; + regionPath;     this.fileSystemStats = new FileSystemStats(cache.getDistributedSystem(), statsName);   }    @Override   protected RepositoryManager createRepositoryManager(LuceneSerializer luceneSerializer) {     LuceneSerializer mapper = luceneSerializer;     if (mapper == null) {       mapper = new HeterogeneousLuceneSerializer();     }     PartitionedRepositoryManager partitionedRepositoryManager =         new PartitionedRepositoryManager(this, mapper, this.waitingThreadPoolFromDM);     return partitionedRepositoryManager;   }    @Override   public boolean isIndexingInProgress() {     PartitionedRegion userRegion = (PartitionedRegion) cache.getRegion(this.getRegionPath());     Set fileRegionPrimaryBucketIds =         this.getFileAndChunkRegion().getDataStore().getAllLocalPrimaryBucketIds();     for (Integer bucketId : fileRegionPrimaryBucketIds) {       BucketRegion userBucket = userRegion.getDataStore().getLocalBucketById(bucketId);       if (!userBucket.isEmpty() &amp;&amp; !this.isIndexAvailable(bucketId)) {         return true;       }     }     return false;   }    @Override   protected void createLuceneListenersAndFileChunkRegions(       PartitionedRepositoryManager partitionedRepositoryManager) {     partitionedRepositoryManager.setUserRegionForRepositoryManager((PartitionedRegion) dataRegion);     RegionShortcut regionShortCut;     final boolean withPersistence = withPersistence();     RegionAttributes regionAttributes = dataRegion.getAttributes();     final boolean withStorage = regionAttributes.getPartitionAttributes().getLocalMaxMemory() &gt; 0;      // TODO: 1) dataRegion should be withStorage     // 2) Persistence to Persistence     // 3) Replicate to Replicate, Partition To Partition     // 4) Offheap to Offheap     if (!withStorage) {       regionShortCut = RegionShortcut.PARTITION_PROXY;     } else if (withPersistence) {       // TODO: add PartitionedRegionAttributes instead       regionShortCut = RegionShortcut.PARTITION_PERSISTENT;     } else {       regionShortCut = RegionShortcut.PARTITION;     }      // create PR fileAndChunkRegion, but not to create its buckets for now     final String fileRegionName = createFileRegionName();     PartitionAttributes partitionAttributes = dataRegion.getPartitionAttributes();     DistributionManager dm = this.cache.getInternalDistributedSystem().getDistributionManager();     LuceneBucketListener lucenePrimaryBucketListener =         new LuceneBucketListener(partitionedRepositoryManager, dm);      if (!fileRegionExists(fileRegionName)) {       fileAndChunkRegion = createRegion(fileRegionName, regionShortCut, this.regionPath,           partitionAttributes, regionAttributes, lucenePrimaryBucketListener);     }      fileSystemStats         .setBytesSupplier(() -&gt; getFileAndChunkRegion().getPrStats().getDataStoreBytesInUse());    }    public PartitionedRegion getFileAndChunkRegion() {     return (PartitionedRegion) fileAndChunkRegion;   }    public FileSystemStats getFileSystemStats() {     return fileSystemStats;   }    boolean fileRegionExists(String fileRegionName) {     return cache.getRegion(fileRegionName) != null;   }    public String createFileRegionName() {     return LuceneServiceImpl.getUniqueIndexRegionName(indexName, regionPath, FILES_REGION_SUFFIX);   }    private PartitionAttributesFactory configureLuceneRegionAttributesFactory(       PartitionAttributesFactory attributesFactory,       PartitionAttributes dataRegionAttributes) {     attributesFactory.setTotalNumBuckets(dataRegionAttributes.getTotalNumBuckets());     attributesFactory.setRedundantCopies(dataRegionAttributes.getRedundantCopies());     attributesFactory.setPartitionResolver(getPartitionResolver(dataRegionAttributes));     attributesFactory.setRecoveryDelay(dataRegionAttributes.getRecoveryDelay());     attributesFactory.setStartupRecoveryDelay(dataRegionAttributes.getStartupRecoveryDelay());     return attributesFactory;   }    private PartitionResolver getPartitionResolver(PartitionAttributes dataRegionAttributes) {     if (dataRegionAttributes.getPartitionResolver() instanceof FixedPartitionResolver) {       return new BucketTargetingFixedResolver();     } else {       return new BucketTargetingResolver();     }   }    protected  Region createRegion(final String regionName,       final RegionShortcut regionShortCut, final String colocatedWithRegionName,       final PartitionAttributes partitionAttributes, final RegionAttributes regionAttributes,       PartitionListener lucenePrimaryBucketListener) {     PartitionAttributesFactory partitionAttributesFactory = new PartitionAttributesFactory();     if (lucenePrimaryBucketListener != null) {       partitionAttributesFactory.addPartitionListener(lucenePrimaryBucketListener);     }     partitionAttributesFactory.setColocatedWith(colocatedWithRegionName);     configureLuceneRegionAttributesFactory(partitionAttributesFactory, partitionAttributes);      // Create AttributesFactory based on input RegionShortcut     RegionAttributes baseAttributes = this.cache.getRegionAttributes(regionShortCut.toString());     AttributesFactory factory = new AttributesFactory(baseAttributes);     factory.setPartitionAttributes(partitionAttributesFactory.create());     if (regionAttributes.getDataPolicy().withPersistence()) {       factory.setDiskStoreName(regionAttributes.getDiskStoreName());     }     RegionAttributes attributes = factory.create();      return createRegion(regionName, attributes);   }    public void close() {}    @Override   public void dumpFiles(final String directory) {     ResultCollector results = FunctionService.onRegion(getDataRegion())         .setArguments(new String[] {directory, indexName}).execute(DumpDirectoryFiles.ID);     results.getResult();   }    @Override   public void destroy(boolean initiator) {     if (logger.isDebugEnabled()) {       logger.debug(&quot;Destroying index regionPath=&quot; + regionPath + &quot;; indexName=&quot; + indexName           + &quot;; initiator=&quot; + initiator);     }      // Invoke super destroy to remove the extension and async event queue     super.destroy(initiator);      // Destroy index on remote members if necessary     if (initiator) {       destroyOnRemoteMembers();     }      // Destroy the file region (colocated with the application region) if necessary     // localDestroyRegion can't be used because locally destroying regions is not supported on     // colocated regions     if (initiator) {       try {         fileAndChunkRegion.destroyRegion();         if (logger.isDebugEnabled()) {           logger.debug(&quot;Destroyed fileAndChunkRegion=&quot; + fileAndChunkRegion.getName());         }       } catch (RegionDestroyedException e) {         if (logger.isDebugEnabled()) {           logger.debug(&quot;Already destroyed fileAndChunkRegion=&quot; + fileAndChunkRegion.getName());         }       }     }      if (logger.isDebugEnabled()) {       logger.debug(&quot;Destroyed index regionPath=&quot; + regionPath + &quot;; indexName=&quot; + indexName           + &quot;; initiator=&quot; + initiator);     }   }    @Override   public boolean isIndexAvailable(int id) {     PartitionedRegion fileAndChunkRegion = getFileAndChunkRegion();     return (fileAndChunkRegion.get(IndexRepositoryFactory.APACHE_GEODE_INDEX_COMPLETE, id) != null         || !LuceneServiceImpl.LUCENE_REINDEX);   }    private void destroyOnRemoteMembers() {     DistributionManager dm = getDataRegion().getDistributionManager();     Set recipients = dm.getOtherNormalDistributionManagerIds();     if (!recipients.isEmpty()) {       if (logger.isDebugEnabled()) {         logger.debug(&quot;LuceneIndexForPartitionedRegion: About to send destroy message recipients=&quot;             + recipients);       }       ReplyProcessor21 processor = new ReplyProcessor21(dm, recipients);       DestroyLuceneIndexMessage message = new DestroyLuceneIndexMessage(recipients,           processor.getProcessorId(), regionPath, indexName);       dm.putOutgoing(message);       if (logger.isDebugEnabled()) {         logger.debug(&quot;LuceneIndexForPartitionedRegion: Sent message recipients=&quot; + recipients);       }       try {         processor.waitForReplies();       } catch (ReplyException e) {         Throwable cause = e.getCause();         if (cause instanceof IllegalArgumentException) {           // If the IllegalArgumentException is index not found, then its ok; otherwise rethrow it.           String fullRegionPath =               regionPath.startsWith(Region.SEPARATOR) ? regionPath : Region.SEPARATOR + regionPath;           String indexNotFoundMessage = String.format(&quot;Lucene index %s was not found in region %s&quot;,               indexName, fullRegionPath);           if (!cause.getLocalizedMessage().equals(indexNotFoundMessage)) {             throw e;           }         } else if (!(cause instanceof CancelException)) {           throw e;         }       } catch (InterruptedException e) {         dm.getCancelCriterion().checkCancelInProgress(e);         Thread.currentThread().interrupt();       }     }   } }</td>
    <td align="left">blob</td>
    <td align="left">1 Long Method, 2 Blob</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">1. Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12188</td>
    <td align="left">https://github.com/apache/geode/blob/8fd839e8b73e40bd2dfd14f331b587431bd35a66/geode-lucene/src/main/java/org/apache/geode/cache/lucene/internal/LuceneIndexForPartitionedRegion.java/#L49-L277</td>
    <td align="right">1</td>
    <td align="right">1850</td>
    <td align="right">12188</td>
  </tr>
  <tr valign="top">
    <td align="right">1879</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Deprecated public final class CompactCharArray implements Cloneable {      /**      * The total number of Unicode characters.      * @deprecated This API is ICU internal only.      * @hide draft / provisional / internal are hidden on Android      */     @Deprecated     public static  final int UNICODECOUNT = 65536;      /**      * Default constructor for CompactCharArray, the default value of the      * compact array is 0.      * @deprecated This API is ICU internal only.      * @hide draft / provisional / internal are hidden on Android      */     @Deprecated     public CompactCharArray()     {         this((char)0);     }      /**      * Constructor for CompactCharArray.      * @param defaultValue the default value of the compact array.      * @deprecated This API is ICU internal only.      * @hide draft / provisional / internal are hidden on Android      */     @Deprecated     public CompactCharArray(char defaultValue)     {         int i;         values = new char[UNICODECOUNT];         indices = new char[INDEXCOUNT];         hashes = new int[INDEXCOUNT];         for (i = 0; i &lt; UNICODECOUNT; ++i) {             values[i] = defaultValue;         }         for (i = 0; i &lt; INDEXCOUNT; ++i) {             indices[i] = (char)(i&lt;= newValues.length+BLOCKCOUNT)                 throw new IllegalArgumentException(&quot;Index out of bounds.&quot;);         }         indices = indexArray;         values = newValues;         isCompact = true;     }      /**      * Constructor for CompactCharArray.      *      * @param indexArray the RLE-encoded indicies of the compact array.      * @param valueArray the RLE-encoded values of the compact array.      *      * @throws IllegalArgumentException if the index or value array is      *          the wrong size.      * @deprecated This API is ICU internal only.      * @hide draft / provisional / internal are hidden on Android      */     @Deprecated     public CompactCharArray(String indexArray,                 String valueArray)     {         this( Utility.RLEStringToCharArray(indexArray),               Utility.RLEStringToCharArray(valueArray));     }      /**      * Get the mapped value of a Unicode character.      * @param index the character to get the mapped value with      * @return the mapped value of the given character      * @deprecated This API is ICU internal only.      * @hide draft / provisional / internal are hidden on Android      */     @Deprecated     public char elementAt(char index)     {     int ix = (indices[index &gt;&gt; BLOCKSHIFT] &amp; 0xFFFF)         + (index &amp; BLOCKMASK);     return ix &gt;= values.length ? defaultValue : values[ix];     }      /**      * Set a new value for a Unicode character.      * Set automatically expands the array if it is compacted.      * @param index the character to set the mapped value with      * @param value the new mapped value      * @deprecated This API is ICU internal only.      * @hide draft / provisional / internal are hidden on Android      */     @Deprecated     public void setElementAt(char index, char value)     {         if (isCompact)             expand();          values[index] = value;         touchBlock(index &gt;&gt; BLOCKSHIFT, value);     }      /**      * Set new values for a range of Unicode character.      *      * @param start the starting offset of the range      * @param end the ending offset of the range      * @param value the new mapped value      * @deprecated This API is ICU internal only.      * @hide draft / provisional / internal are hidden on Android      */     @Deprecated     public void setElementAt(char start, char end, char value)     {         int i;         if (isCompact) {             expand();         }         for (i = start; i &lt;= end; ++i) {             values[i] = value;             touchBlock(i &gt;&gt; BLOCKSHIFT, value);         }     }     /**      * Compact the array      * @deprecated This API is ICU internal only.      * @hide draft / provisional / internal are hidden on Android      */     @Deprecated     public void compact() {         compact(true);     }      /**      * Compact the array.      * @deprecated This API is ICU internal only.      * @hide draft / provisional / internal are hidden on Android      */     @Deprecated     public void compact(boolean exhaustive)     {         if (!isCompact) {             int iBlockStart = 0;             char iUntouched = 0xFFFF;             int newSize = 0;              char[] target = exhaustive ? new char[UNICODECOUNT] : values;              for (int i = 0; i &lt; indices.length; ++i, iBlockStart += BLOCKCOUNT) {                 indices[i] = 0xFFFF;                 boolean touched = blockTouched(i);                 if (!touched &amp;&amp; iUntouched != 0xFFFF) {                     // If no values in this block were set, we can just set its                     // index to be the same as some other block with no values                     // set, assuming we've seen one yet.                     indices[i] = iUntouched;                 } else {                     int jBlockStart = 0;                     // See if we can find a previously compacted block that's identical                     for (int j = 0; j &lt; i; ++j, jBlockStart += BLOCKCOUNT) {                         if (hashes[i] == hashes[j] &amp;&amp;                                 arrayRegionMatches(values, iBlockStart,                                                    values, jBlockStart, BLOCKCOUNT)) {                             indices[i] = indices[j];                         }                     }                     if (indices[i] == 0xFFFF) {                         int dest;   // Where to copy                         if (exhaustive) {                             // See if we can find some overlap with another block                             dest = FindOverlappingPosition(iBlockStart, target,                                                             newSize);                         } else {                             // Just copy to the end; it's quicker                             dest = newSize;                         }                         int limit = dest + BLOCKCOUNT;                         if (limit &gt; newSize) {                             for (int j = newSize; j &lt; limit; ++j) {                                 target[j] = values[iBlockStart + j - dest];                             }                             newSize = limit;                         }                         indices[i] = (char)dest;                         if (!touched) {                             // If this is the first untouched block we've seen,                             // remember its index.                             iUntouched = (char)jBlockStart;                         }                     }                 }             }             // we are done compacting, so now make the array shorter             char[] result = new char[newSize];             System.arraycopy(target, 0, result, 0, newSize);             values = result;             isCompact = true;             hashes = null;         }     }      private int FindOverlappingPosition(int start, char[] tempValues, int tempCount)     {         for (int i = 0; i &lt; tempCount; i += 1) {             int currentCount = BLOCKCOUNT;             if (i + BLOCKCOUNT &gt; tempCount) {                 currentCount = tempCount - i;             }             if (arrayRegionMatches(values, start, tempValues, i, currentCount))                 return i;         }         return tempCount;     }      /**      * Convenience utility to compare two arrays of doubles.      * @param len the length to compare.      * The start indices and start+len must be valid.      */     final static boolean arrayRegionMatches(char[] source, int sourceStart,                                             char[] target, int targetStart,                                             int len)     {         int sourceEnd = sourceStart + len;         int delta = targetStart - sourceStart;         for (int i = sourceStart; i &lt; sourceEnd; i++) {             if (source[i] != target[i + delta])             return false;         }         return true;     }      /**      * Remember that a specified block was &quot;touched&quot;, i.e. had a value set.      * Untouched blocks can be skipped when compacting the array      */     private final void touchBlock(int i, int value) {         hashes[i] = (hashes[i] + (value&lt;&lt;1)) | 1;     }      /**      * Query whether a specified block was &quot;touched&quot;, i.e. had a value set.      * Untouched blocks can be skipped when compacting the array      */     private final boolean blockTouched(int i) {         return hashes[i] != 0;     }      /**      * For internal use only.  Do not modify the result, the behavior of      * modified results are undefined.      * @deprecated This API is ICU internal only.      * @hide draft / provisional / internal are hidden on Android      */     @Deprecated     public char[] getIndexArray()     {         return indices;     }      /**      * For internal use only.  Do not modify the result, the behavior of      * modified results are undefined.      * @deprecated This API is ICU internal only.      * @hide draft / provisional / internal are hidden on Android      */     @Deprecated     public char[] getValueArray()     {         return values;     }      /**      * Overrides Cloneable      * @deprecated This API is ICU internal only.      * @hide draft / provisional / internal are hidden on Android      */     @Override     @Deprecated     public Object clone()     {         try {             CompactCharArray other = (CompactCharArray) super.clone();             other.values = values.clone();             other.indices = indices.clone();             if (hashes != null) other.hashes = hashes.clone();             return other;         } catch (CloneNotSupportedException e) {             throw new ICUCloneNotSupportedException(e);         }     }      /**      * Compares the equality of two compact array objects.      * @param obj the compact array object to be compared with this.      * @return true if the current compact array object is the same      * as the compact array object obj; false otherwise.      * @deprecated This API is ICU internal only.      * @hide draft / provisional / internal are hidden on Android      */     @Override     @Deprecated     public boolean equals(Object obj) {         if (obj == null) return false;         if (this == obj)                      // quick check             return true;         if (getClass() != obj.getClass())         // same class?             return false;         CompactCharArray other = (CompactCharArray) obj;         for (int i = 0; i &lt; UNICODECOUNT; i++) {             // could be sped up later             if (elementAt((char)i) != other.elementAt((char)i))                 return false;         }         return true; // we made it through the guantlet.     }      /**      * Generates the hash code for the compact array object      * @deprecated This API is ICU internal only.      * @hide draft / provisional / internal are hidden on Android      */     @Override     @Deprecated     public int hashCode() {         int result = 0;         int increment = Math.min(3, values.length/16);         for (int i = 0; i &lt; values.length; i+= increment) {             result = result * 37 + values[i];         }         return result;     }       // --------------------------------------------------------------     // private     // --------------------------------------------------------------      /**      * Expanding takes the array back to a 65536 element array.      */     private void expand()     {         int i;         if (isCompact) {             char[] tempArray;             hashes = new int[INDEXCOUNT];             tempArray = new char[UNICODECOUNT];             for (i = 0; i &lt; UNICODECOUNT; ++i) {                 tempArray[i] = elementAt((char)i);             }             for (i = 0; i &lt; INDEXCOUNT; ++i) {                 indices[i] = (char)(i&lt;&lt;BLOCKSHIFT);             }             values = null;             values = tempArray;             isCompact = false;         }     }     /**      * @deprecated This API is ICU internal only.      * @hide draft / provisional / internal are hidden on Android      */     @Deprecated     public static  final int BLOCKSHIFT = 5; // NormalizerBuilder needs - liu     static  final int BLOCKCOUNT =(1&lt;&lt;BLOCKSHIFT);     static  final int INDEXSHIFT =(16-BLOCKSHIFT);     static  final int INDEXCOUNT =(1&lt;&lt;INDEXSHIFT);     static  final int BLOCKMASK = BLOCKCOUNT - 1;      private char values[];     private char indices[];     private int[] hashes;     private boolean isCompact;     char defaultValue; }</td>
    <td align="left">blob</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;data class,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12276</td>
    <td align="left">https://github.com/google/j2objc/blob/471504a735b48d5d4ace51afa1542cc4790a921a/jre_emul/android/platform/external/icu/android_icu4j/src/main/java/android/icu/util/CompactCharArray.java/#L37-L434</td>
    <td align="right">1</td>
    <td align="right">1879</td>
    <td align="right">12276</td>
  </tr>
  <tr valign="top">
    <td align="right">1935</td>
    <td align="left">{&quot;message&quot;: &quot;YES, I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class InternalCacheBuilder {   private static final Logger logger = LogService.getLogger();    private static final String USE_ASYNC_EVENT_LISTENERS_PROPERTY =       GEMFIRE_PREFIX + &quot;Cache.ASYNC_EVENT_LISTENERS&quot;;    private static final boolean IS_EXISTING_OK_DEFAULT = true;   private static final boolean IS_CLIENT_DEFAULT = false;    private final Properties configProperties;   private final CacheConfig cacheConfig;   private final CompositeMeterRegistryFactory compositeMeterRegistryFactory;   private final Consumer metricsSessionInitializer;   private final Supplier singletonSystemSupplier;   private final Supplier singletonCacheSupplier;   private final InternalDistributedSystemConstructor internalDistributedSystemConstructor;   private final InternalCacheConstructor internalCacheConstructor;    private boolean isExistingOk = IS_EXISTING_OK_DEFAULT;   private boolean isClient = IS_CLIENT_DEFAULT;    /**    * Setting useAsyncEventListeners to true will invoke event listeners in asynchronously.    *    *     * Default is specified by system property {@code gemfire.Cache.ASYNC_EVENT_LISTENERS}.    */   private boolean useAsyncEventListeners = Boolean.getBoolean(USE_ASYNC_EVENT_LISTENERS_PROPERTY);    private PoolFactory poolFactory;   private TypeRegistry typeRegistry;    /**    * Creates a cache factory with default configuration properties.    */   public InternalCacheBuilder() {     this(new Properties(), new CacheConfig());   }    /**    * Create a cache factory initialized with the given configuration properties. For a list of valid    * configuration properties and their meanings see {@link ConfigurationProperties}.    *    * @param configProperties the configuration properties to initialize the factory with.    */   public InternalCacheBuilder(Properties configProperties) {     this(configProperties == null ? new Properties() : configProperties, new CacheConfig());   }    /**    * Creates a cache factory with default configuration properties.    */   public InternalCacheBuilder(CacheConfig cacheConfig) {     this(new Properties(), cacheConfig);   }    private InternalCacheBuilder(Properties configProperties, CacheConfig cacheConfig) {     this(configProperties,         cacheConfig,         new CacheMeterRegistryFactory(),         CacheLifecycleMetricsSession.builder()::build,         InternalDistributedSystem::getConnectedInstance,         InternalDistributedSystem::connectInternal,         GemFireCacheImpl::getInstance,         GemFireCacheImpl::new);   }    @VisibleForTesting   InternalCacheBuilder(Properties configProperties,       CacheConfig cacheConfig,       CompositeMeterRegistryFactory compositeMeterRegistryFactory,       Consumer metricsSessionInitializer,       Supplier singletonSystemSupplier,       InternalDistributedSystemConstructor internalDistributedSystemConstructor,       Supplier singletonCacheSupplier,       InternalCacheConstructor internalCacheConstructor) {     this.configProperties = configProperties;     this.cacheConfig = cacheConfig;     this.compositeMeterRegistryFactory = compositeMeterRegistryFactory;     this.metricsSessionInitializer = metricsSessionInitializer;     this.singletonSystemSupplier = singletonSystemSupplier;     this.internalDistributedSystemConstructor = internalDistributedSystemConstructor;     this.internalCacheConstructor = internalCacheConstructor;     this.singletonCacheSupplier = singletonCacheSupplier;   }    /**    * @see CacheFactory#create()    *    * @throws CacheXmlException If a problem occurs while parsing the declarative caching XML file.    * @throws TimeoutException If a {@link Region#put(Object, Object)} times out while initializing    *         the cache.    * @throws CacheWriterException If a {@code CacheWriterException} is thrown while initializing the    *         cache.    * @throws GatewayException If a {@code GatewayException} is thrown while initializing the cache.    * @throws RegionExistsException If the declarative caching XML file describes a region that    *         already exists (including the root region).    * @throws IllegalStateException if cache already exists and is not compatible with the new    *         configuration.    * @throws AuthenticationFailedException if authentication fails.    * @throws AuthenticationRequiredException if the distributed system is in secure mode and this    *         new member is not configured with security credentials.    */   public InternalCache create()       throws TimeoutException, CacheWriterException, GatewayException, RegionExistsException {     synchronized (InternalCacheBuilder.class) {       InternalDistributedSystem internalDistributedSystem = findInternalDistributedSystem()           .orElseGet(() -&gt; createInternalDistributedSystem());       return create(internalDistributedSystem);     }   }    /**    * @see CacheFactory#create(DistributedSystem)    *    * @throws IllegalArgumentException If {@code system} is not {@link DistributedSystem#isConnected    *         connected}.    * @throws CacheExistsException If an open cache already exists.    * @throws CacheXmlException If a problem occurs while parsing the declarative caching XML file.    * @throws TimeoutException If a {@link Region#put(Object, Object)} times out while initializing    *         the cache.    * @throws CacheWriterException If a {@code CacheWriterException} is thrown while initializing the    *         cache.    * @throws GatewayException If a {@code GatewayException} is thrown while initializing the cache.    * @throws RegionExistsException If the declarative caching XML file describes a region that    *         already exists (including the root region).    */   public InternalCache create(InternalDistributedSystem internalDistributedSystem)       throws TimeoutException, CacheWriterException, GatewayException, RegionExistsException {     requireNonNull(internalDistributedSystem, &quot;internalDistributedSystem&quot;);     try {       synchronized (InternalCacheBuilder.class) {         synchronized (GemFireCacheImpl.class) {           InternalCache cache =               existingCache(internalDistributedSystem::getCache, singletonCacheSupplier);           if (cache == null) {              int systemId = internalDistributedSystem.getConfig().getDistributedSystemId();             String memberName = internalDistributedSystem.getName();             String hostName = internalDistributedSystem.getDistributedMember().getHost();              CompositeMeterRegistry compositeMeterRegistry = compositeMeterRegistryFactory                 .create(systemId, memberName, hostName);              metricsSessionInitializer.accept(compositeMeterRegistry);              cache =                 internalCacheConstructor.construct(isClient, poolFactory, internalDistributedSystem,                     cacheConfig, useAsyncEventListeners, typeRegistry, compositeMeterRegistry);              internalDistributedSystem.setCache(cache);             cache.initialize();            } else {             internalDistributedSystem.setCache(cache);           }            return cache;         }       }     } catch (CacheXmlException | IllegalArgumentException e) {       logger.error(e.getLocalizedMessage());       throw e;     } catch (Error | RuntimeException e) {       logger.error(e);       throw e;     }   }    /**    * @see CacheFactory#set(String, String)    */   public InternalCacheBuilder set(String name, String value) {     configProperties.setProperty(name, value);     return this;   }    /**    * @see CacheFactory#setPdxReadSerialized(boolean)    */   public InternalCacheBuilder setPdxReadSerialized(boolean readSerialized) {     cacheConfig.setPdxReadSerialized(readSerialized);     return this;   }    /**    * @see CacheFactory#setSecurityManager(SecurityManager)    */   public InternalCacheBuilder setSecurityManager(SecurityManager securityManager) {     cacheConfig.setSecurityManager(securityManager);     return this;   }    /**    * @see CacheFactory#setPostProcessor(PostProcessor)    */   public InternalCacheBuilder setPostProcessor(PostProcessor postProcessor) {     cacheConfig.setPostProcessor(postProcessor);     return this;   }    /**    * @see CacheFactory#setPdxSerializer(PdxSerializer)    */   public InternalCacheBuilder setPdxSerializer(PdxSerializer serializer) {     cacheConfig.setPdxSerializer(serializer);     return this;   }    /**    * @see CacheFactory#setPdxDiskStore(String)    */   public InternalCacheBuilder setPdxDiskStore(String diskStoreName) {     cacheConfig.setPdxDiskStore(diskStoreName);     return this;   }    /**    * @see CacheFactory#setPdxPersistent(boolean)    */   public InternalCacheBuilder setPdxPersistent(boolean isPersistent) {     cacheConfig.setPdxPersistent(isPersistent);     return this;   }    /**    * @see CacheFactory#setPdxIgnoreUnreadFields(boolean)    */   public InternalCacheBuilder setPdxIgnoreUnreadFields(boolean ignore) {     cacheConfig.setPdxIgnoreUnreadFields(ignore);     return this;   }    public InternalCacheBuilder setCacheXMLDescription(String cacheXML) {     if (cacheXML != null) {       cacheConfig.setCacheXMLDescription(cacheXML);     }     return this;   }    /**    * @param isExistingOk default is true.    */   public InternalCacheBuilder setIsExistingOk(boolean isExistingOk) {     this.isExistingOk = isExistingOk;     return this;   }    /**    * @param isClient default is false.    */   public InternalCacheBuilder setIsClient(boolean isClient) {     this.isClient = isClient;     return this;   }    /**    * @param useAsyncEventListeners default is specified by the system property    *        {@code gemfire.Cache.ASYNC_EVENT_LISTENERS}.    */   public InternalCacheBuilder setUseAsyncEventListeners(boolean useAsyncEventListeners) {     this.useAsyncEventListeners = useAsyncEventListeners;     return this;   }    /**    * @param poolFactory default is null.    */   public InternalCacheBuilder setPoolFactory(PoolFactory poolFactory) {     this.poolFactory = poolFactory;     return this;   }    /**    * @param typeRegistry default is null.    */   public InternalCacheBuilder setTypeRegistry(TypeRegistry typeRegistry) {     this.typeRegistry = typeRegistry;     return this;   }    private Optional findInternalDistributedSystem() {     InternalDistributedSystem internalDistributedSystem = null;     if (configProperties.isEmpty() &amp;&amp; !ALLOW_MULTIPLE_SYSTEMS) {       // any ds will do       internalDistributedSystem = singletonSystemSupplier.get();       validateUsabilityOfSecurityCallbacks(internalDistributedSystem, cacheConfig);     }     return Optional.ofNullable(internalDistributedSystem);   }    private InternalDistributedSystem createInternalDistributedSystem() {     SecurityConfig securityConfig = new SecurityConfig(         cacheConfig.getSecurityManager(),         cacheConfig.getPostProcessor());      return internalDistributedSystemConstructor.construct(configProperties, securityConfig);   }    private InternalCache existingCache(Supplier systemCacheSupplier,       Supplier singletonCacheSupplier) {     InternalCache cache = ALLOW_MULTIPLE_SYSTEMS         ? systemCacheSupplier.get()         : singletonCacheSupplier.get();      if (validateExistingCache(cache)) {       return cache;     }      return null;   }    /**    * Validates that isExistingOk is true and existing cache is compatible with cacheConfig.    *    * if instance exists and cacheConfig is incompatible    * if instance exists and isExistingOk is false    */   private boolean validateExistingCache(InternalCache existingCache) {     if (existingCache == null || existingCache.isClosed()) {       return false;     }      if (isExistingOk) {       cacheConfig.validateCacheConfig(existingCache);     } else {       existingCache.throwCacheExistsException();     }      return true;   }    /**    * if existing DistributedSystem connection cannot use specified SecurityManager or    * PostProcessor.    */   private static void validateUsabilityOfSecurityCallbacks(       InternalDistributedSystem internalDistributedSystem, CacheConfig cacheConfig)       throws GemFireSecurityException {     if (internalDistributedSystem == null) {       return;     }     // pre-existing DistributedSystem already has an incompatible SecurityService in use     if (cacheConfig.getSecurityManager() != null) {       throw new GemFireSecurityException(           &quot;Existing DistributedSystem connection cannot use specified SecurityManager&quot;);     }     if (cacheConfig.getPostProcessor() != null) {       throw new GemFireSecurityException(           &quot;Existing DistributedSystem connection cannot use specified PostProcessor&quot;);     }   }    @VisibleForTesting   interface InternalCacheConstructor {     InternalCache construct(boolean isClient, PoolFactory poolFactory,         InternalDistributedSystem internalDistributedSystem, CacheConfig cacheConfig,         boolean useAsyncEventListeners, TypeRegistry typeRegistry, MeterRegistry meterRegistry);   }    @VisibleForTesting   interface InternalDistributedSystemConstructor {     InternalDistributedSystem construct(Properties configProperties, SecurityConfig securityConfig);   } }</td>
    <td align="left">blob</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12464</td>
    <td align="left">https://github.com/apache/geode/blob/8fd839e8b73e40bd2dfd14f331b587431bd35a66/geode-core/src/main/java/org/apache/geode/internal/cache/InternalCacheBuilder.java/#L56-L420</td>
    <td align="right">1</td>
    <td align="right">1935</td>
    <td align="right">12464</td>
  </tr>
  <tr valign="top">
    <td align="right">1949</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface MetricsIndexerSource extends BaseSource {   // Metrics2 and JMX constants   String METRICS_NAME = &quot;PhoenixIndexer&quot;;   String METRICS_CONTEXT = &quot;phoenix&quot;;   String METRICS_DESCRIPTION = &quot;Metrics about the Phoenix Indexer&quot;;   String METRICS_JMX_CONTEXT = &quot;RegionServer,sub=&quot; + METRICS_NAME;    String INDEX_PREPARE_TIME = &quot;indexPrepareTime&quot;;   String INDEX_PREPARE_TIME_DESC = &quot;Histogram for the time in milliseconds for preparing an index write&quot;;   String SLOW_INDEX_PREPARE = &quot;slowIndexPrepareCalls&quot;;   String SLOW_INDEX_PREPARE_DESC = &quot;The number of index preparations slower than the configured threshold&quot;;    String INDEX_WRITE_TIME = &quot;indexWriteTime&quot;;   String INDEX_WRITE_TIME_DESC = &quot;Histogram for the time in milliseconds for writing an index update&quot;;   String SLOW_INDEX_WRITE = &quot;slowIndexWriteCalls&quot;;   String SLOW_INDEX_WRITE_DESC = &quot;The number of index writes slower than the configured threshold&quot;;    String DUPLICATE_KEY_TIME = &quot;duplicateKeyCheckTime&quot;;   String DUPLICATE_KEY_TIME_DESC = &quot;Histogram for the time in milliseconds to handle ON DUPLICATE keywords&quot;;   String SLOW_DUPLICATE_KEY = &quot;slowDuplicateKeyCheckCalls&quot;;   String SLOW_DUPLICATE_KEY_DESC = &quot;The number of on duplicate key checks slower than the configured threshold&quot;;    String PRE_WAL_RESTORE_TIME = &quot;preWALRestoreTime&quot;;   String PRE_WAL_RESTORE_TIME_DESC = &quot;Histogram for the time in milliseconds for Indexer's preWALRestore&quot;;   String SLOW_PRE_WAL_RESTORE = &quot;slowPreWALRestoreCalls&quot;;   String SLOW_PRE_WAL_RESTORE_DESC = &quot;The number of preWALRestore calls slower than the configured threshold&quot;;    String POST_PUT_TIME = &quot;postPutTime&quot;;   String POST_PUT_TIME_DESC = &quot;Histogram for the time in milliseconds for Indexer's postPut&quot;;   String SLOW_POST_PUT = &quot;slowPostPutCalls&quot;;   String SLOW_POST_PUT_DESC = &quot;The number of postPut calls slower than the configured threshold&quot;;    String POST_DELETE_TIME = &quot;postDeleteTime&quot;;   String POST_DELETE_TIME_DESC = &quot;Histogram for the time in milliseconds for Indexer's postDelete&quot;;   String SLOW_POST_DELETE = &quot;slowPostDeleteCalls&quot;;   String SLOW_POST_DELETE_DESC = &quot;The number of postDelete calls slower than the configured threshold&quot;;    String POST_OPEN_TIME = &quot;postOpenTime&quot;;   String POST_OPEN_TIME_DESC = &quot;Histogram for the time in milliseconds for Indexer's postOpen&quot;;   String SLOW_POST_OPEN = &quot;slowPostOpenCalls&quot;;   String SLOW_POST_OPEN_DESC = &quot;The number of postOpen calls slower than the configured threshold&quot;;    /**    * Updates the index preparation time histogram (preBatchMutate).    *    * @param t time taken in milliseconds    */   void updateIndexPrepareTime(long t);    /**    * Increments the number of slow calls prepare an index write.    */   void incrementNumSlowIndexPrepareCalls();    /**    * Updates the index write time histogram (postBatchMutate).    *    * @param t time taken in milliseconds    */   void updateIndexWriteTime(long t);    /**    * Increments the number of slow calls to write to the index.    */   void incrementNumSlowIndexWriteCalls();    /**    * Updates the preWALRestore time histogram.    *    * @param t time taken in milliseconds    */   void updatePreWALRestoreTime(long t);    /**    * Increments the number of slow preWALRestore calls.    */   void incrementNumSlowPreWALRestoreCalls();    /**    * Updates the postPut time histogram.    *    * @param t time taken in milliseconds    */   void updatePostPutTime(long t);    /**    * Increments the number of slow postPut calls.    */   void incrementNumSlowPostPutCalls();    /**    * Updates the postDelete time histogram.    *    * @param t time taken in milliseconds    */   void updatePostDeleteTime(long t);    /**    * Increments the number of slow postDelete calls.    */   void incrementNumSlowPostDeleteCalls();    /**    * Updates the postOpen time histogram.    *    * @param t time taken in milliseconds    */   void updatePostOpenTime(long t);    /**    * Increments the number of slow postOpen calls.    */   void incrementNumSlowPostOpenCalls();    /**    * Updates the preIncrementAfterRowLock time histogram.    *    * @param t time taken in milliseconds    */   void updateDuplicateKeyCheckTime(long t);    /**    * Increments the number of slow preIncrementAfteRowLock calls.    */   void incrementSlowDuplicateKeyCheckCalls(); }</td>
    <td align="left">blob</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;data class,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12529</td>
    <td align="left">https://github.com/apache/phoenix/blob/69e5bb0b304a53967cef40b2a4cfc66e69ecaa51/phoenix-core/src/main/java/org/apache/phoenix/hbase/index/metrics/MetricsIndexerSource.java/#L25-L150</td>
    <td align="right">1</td>
    <td align="right">1949</td>
    <td align="right">12529</td>
  </tr>
  <tr valign="top">
    <td align="right">1958</td>
    <td align="left">&nbsp;{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Blob&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MetaDataFactoryImpl extends EFactoryImpl implements MetaDataFactory {   /**    * Creates the default factory implementation.    *     *     * @generated    */   public static MetaDataFactory init()   {     try     {       MetaDataFactory theMetaDataFactory = (MetaDataFactory)EPackage.Registry.INSTANCE.getEFactory(MetaDataPackage.eNS_URI);       if (theMetaDataFactory != null)       {         return theMetaDataFactory;       }     }     catch (Exception exception)     {       EcorePlugin.INSTANCE.log(exception);     }     return new MetaDataFactoryImpl();   }    /**    * Creates an instance of the factory.    *     *     * @generated    */   public MetaDataFactoryImpl()   {     super();   }    /**    *     *     * @generated    */   @Override   public EObject create(EClass eClass)   {     switch (eClass.getClassifierID())     {       case MetaDataPackage.MD_MODEL: return createMdModel();       case MetaDataPackage.MD_BUNDLE: return createMdBundle();       case MetaDataPackage.MD_BUNDLE_MEMBER: return createMdBundleMember();       case MetaDataPackage.MD_GROUP_OR_OPTION: return createMdGroupOrOption();       case MetaDataPackage.MD_GROUP: return createMdGroup();       case MetaDataPackage.MD_OPTION: return createMdOption();       case MetaDataPackage.MD_OPTION_DEPENDENCY: return createMdOptionDependency();       case MetaDataPackage.MD_ALGORITHM: return createMdAlgorithm();       case MetaDataPackage.MD_CATEGORY: return createMdCategory();       case MetaDataPackage.MD_OPTION_SUPPORT: return createMdOptionSupport();       default:         throw new IllegalArgumentException(&quot;The class '&quot; + eClass.getName() + &quot;' is not a valid classifier&quot;);     }   }    /**    *     *     * @generated    */   @Override   public Object createFromString(EDataType eDataType, String initialValue)   {     switch (eDataType.getClassifierID())     {       case MetaDataPackage.MD_OPTION_TARGET_TYPE:         return createMdOptionTargetTypeFromString(eDataType, initialValue);       case MetaDataPackage.MD_GRAPH_FEATURE:         return createMdGraphFeatureFromString(eDataType, initialValue);       default:         throw new IllegalArgumentException(&quot;The datatype '&quot; + eDataType.getName() + &quot;' is not a valid classifier&quot;);     }   }    /**    *     *     * @generated    */   @Override   public String convertToString(EDataType eDataType, Object instanceValue)   {     switch (eDataType.getClassifierID())     {       case MetaDataPackage.MD_OPTION_TARGET_TYPE:         return convertMdOptionTargetTypeToString(eDataType, instanceValue);       case MetaDataPackage.MD_GRAPH_FEATURE:         return convertMdGraphFeatureToString(eDataType, instanceValue);       default:         throw new IllegalArgumentException(&quot;The datatype '&quot; + eDataType.getName() + &quot;' is not a valid classifier&quot;);     }   }    /**    *     *     * @generated    */   public MdModel createMdModel()   {     MdModelImpl mdModel = new MdModelImpl();     return mdModel;   }    /**    *     *     * @generated    */   public MdBundle createMdBundle()   {     MdBundleImpl mdBundle = new MdBundleImpl();     return mdBundle;   }    /**    *     *     * @generated    */   public MdBundleMember createMdBundleMember()   {     MdBundleMemberImpl mdBundleMember = new MdBundleMemberImpl();     return mdBundleMember;   }    /**    *     *     * @generated    */   public MdGroupOrOption createMdGroupOrOption()   {     MdGroupOrOptionImpl mdGroupOrOption = new MdGroupOrOptionImpl();     return mdGroupOrOption;   }    /**    *     *     * @generated    */   public MdGroup createMdGroup()   {     MdGroupImpl mdGroup = new MdGroupImpl();     return mdGroup;   }    /**    *     *     * @generated    */   public MdOption createMdOption()   {     MdOptionImpl mdOption = new MdOptionImpl();     return mdOption;   }    /**    *     *     * @generated    */   public MdOptionDependency createMdOptionDependency()   {     MdOptionDependencyImpl mdOptionDependency = new MdOptionDependencyImpl();     return mdOptionDependency;   }    /**    *     *     * @generated    */   public MdAlgorithm createMdAlgorithm()   {     MdAlgorithmImpl mdAlgorithm = new MdAlgorithmImpl();     return mdAlgorithm;   }    /**    *     *     * @generated    */   public MdCategory createMdCategory()   {     MdCategoryImpl mdCategory = new MdCategoryImpl();     return mdCategory;   }    /**    *     *     * @generated    */   public MdOptionSupport createMdOptionSupport()   {     MdOptionSupportImpl mdOptionSupport = new MdOptionSupportImpl();     return mdOptionSupport;   }    /**    *     *     * @generated    */   public MdOptionTargetType createMdOptionTargetTypeFromString(EDataType eDataType, String initialValue)   {     MdOptionTargetType result = MdOptionTargetType.get(initialValue);     if (result == null) throw new IllegalArgumentException(&quot;The value '&quot; + initialValue + &quot;' is not a valid enumerator of '&quot; + eDataType.getName() + &quot;'&quot;);     return result;   }    /**    *     *     * @generated    */   public String convertMdOptionTargetTypeToString(EDataType eDataType, Object instanceValue)   {     return instanceValue == null ? null : instanceValue.toString();   }    /**    *     *     * @generated    */   public MdGraphFeature createMdGraphFeatureFromString(EDataType eDataType, String initialValue)   {     MdGraphFeature result = MdGraphFeature.get(initialValue);     if (result == null) throw new IllegalArgumentException(&quot;The value '&quot; + initialValue + &quot;' is not a valid enumerator of '&quot; + eDataType.getName() + &quot;'&quot;);     return result;   }    /**    *     *     * @generated    */   public String convertMdGraphFeatureToString(EDataType eDataType, Object instanceValue)   {     return instanceValue == null ? null : instanceValue.toString();   }    /**    *     *     * @generated    */   public MetaDataPackage getMetaDataPackage()   {     return (MetaDataPackage)getEPackage();   }    /**    *     *     * @deprecated    * @generated    */   @Deprecated   public static MetaDataPackage getPackage()   {     return MetaDataPackage.eINSTANCE;   }  } //MetaDataFactoryImpl</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12570</td>
    <td align="left">https://github.com/eclipse/elk/blob/9a87764f00d863463b1be6de1920d8aa3c3ade70/plugins/org.eclipse.elk.core.meta/src-gen/org/eclipse/elk/core/meta/metaData/impl/MetaDataFactoryImpl.java/#L32-L307</td>
    <td align="right">1</td>
    <td align="right">1958</td>
    <td align="right">12570</td>
  </tr>
  <tr valign="top">
    <td align="right">1961</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Blob&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Internal public class SingleThreadAccessCheckingTypeSerializer extends TypeSerializer { 	private static final long serialVersionUID = 131020282727167064L;  	private final SingleThreadAccessChecker singleThreadAccessChecker; 	private final TypeSerializer originalSerializer;  	public SingleThreadAccessCheckingTypeSerializer(TypeSerializer originalSerializer) { 		this.singleThreadAccessChecker = new SingleThreadAccessChecker(); 		this.originalSerializer = originalSerializer; 	}  	@Override 	public boolean isImmutableType() { 		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) { 			return originalSerializer.isImmutableType(); 		} 	}  	@Override 	public TypeSerializer duplicate() { 		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) { 			return new SingleThreadAccessCheckingTypeSerializer&lt;&gt;(originalSerializer.duplicate()); 		} 	}  	@Override 	public T createInstance() { 		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) { 			return originalSerializer.createInstance(); 		} 	}  	@Override 	public T copy(T from) { 		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) { 			return originalSerializer.copy(from); 		} 	}  	@Override 	public T copy(T from, T reuse) { 		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) { 			return originalSerializer.copy(from, reuse); 		} 	}  	@Override 	public int getLength() { 		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) { 			return originalSerializer.getLength(); 		} 	}  	@Override 	public void serialize(T record, DataOutputView target) throws IOException { 		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) { 			originalSerializer.serialize(record, target); 		} 	}  	@Override 	public T deserialize(DataInputView source) throws IOException { 		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) { 			return originalSerializer.deserialize(source); 		} 	}  	@Override 	public T deserialize(T reuse, DataInputView source) throws IOException { 		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) { 			return originalSerializer.deserialize(reuse, source); 		} 	}  	@Override 	public void copy(DataInputView source, DataOutputView target) throws IOException { 		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) { 			originalSerializer.copy(source, target); 		} 	}  	@Override 	public boolean equals(Object obj) { 		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) { 			return obj == this || 				(obj != null &amp;&amp; obj.getClass() == getClass() &amp;&amp; 					originalSerializer.equals(obj)); 		} 	}  	@Override 	public int hashCode() { 		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) { 			return originalSerializer.hashCode(); 		} 	}  	@Override 	public TypeSerializerSnapshot snapshotConfiguration() { 		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) { 			return new SingleThreadAccessCheckingTypeSerializerSnapshot&lt;&gt;(this); 		} 	}  	public static class SingleThreadAccessCheckingTypeSerializerSnapshot 		extends CompositeTypeSerializerSnapshot&gt; {  		@SuppressWarnings({&quot;unchecked&quot;, &quot;unused&quot;}) 		public SingleThreadAccessCheckingTypeSerializerSnapshot() { 			super((Class&gt;) (Class) SingleThreadAccessCheckingTypeSerializer.class); 		}  		SingleThreadAccessCheckingTypeSerializerSnapshot(SingleThreadAccessCheckingTypeSerializer serializerInstance) { 			super(serializerInstance); 		}  		@Override 		protected int getCurrentOuterSnapshotVersion() { 			return 1; 		}  		@Override 		protected TypeSerializer[] getNestedSerializers(SingleThreadAccessCheckingTypeSerializer outerSerializer) { 			return new TypeSerializer[] { outerSerializer.originalSerializer }; 		}  		@SuppressWarnings(&quot;unchecked&quot;) 		@Override 		protected SingleThreadAccessCheckingTypeSerializer createOuterSerializerWithNestedSerializers( 			TypeSerializer[] nestedSerializers) {  			return new SingleThreadAccessCheckingTypeSerializer&lt;&gt;((TypeSerializer) nestedSerializers[0]); 		} 	}  	private void writeObject(ObjectOutputStream outputStream) throws IOException { 		try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) { 			outputStream.defaultWriteObject(); 		} 	}  	private static class SingleThreadAccessChecker implements Serializable { 		private static final long serialVersionUID = 131020282727167064L;  		private transient AtomicReference currentThreadRef = new AtomicReference&lt;&gt;();  		SingleThreadAccessCheck startSingleThreadAccessCheck() { 			assert(currentThreadRef.compareAndSet(null, Thread.currentThread())) : 				&quot;The checker has concurrent access from &quot; + currentThreadRef.get(); 			return new SingleThreadAccessCheck(currentThreadRef); 		}  		private void readObject(ObjectInputStream inputStream) throws ClassNotFoundException, IOException { 			inputStream.defaultReadObject(); 			currentThreadRef = new AtomicReference&lt;&gt;(); 		} 	}  	private static class SingleThreadAccessCheck implements AutoCloseable { 		private final AtomicReference currentThreadRef;  		private SingleThreadAccessCheck(AtomicReference currentThreadRef) { 			this.currentThreadRef = currentThreadRef; 		}  		@Override 		public void close() { 			assert(currentThreadRef.compareAndSet(Thread.currentThread(), null)) : 				&quot;The checker has concurrent access from &quot; + currentThreadRef.get(); 		} 	} }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12584</td>
    <td align="left">https://github.com/apache/flink/blob/8068c8775ad067d75828e6360e7e0994348da9b9/flink-core/src/main/java/org/apache/flink/api/common/typeutils/SingleThreadAccessCheckingTypeSerializer.java/#L31-L203</td>
    <td align="right">1</td>
    <td align="right">1961</td>
    <td align="right">12584</td>
  </tr>
  <tr valign="top">
    <td align="right">1984</td>
    <td align="left">&nbsp;{   &quot;NO, I did not find any bad smell&quot;   :   &quot;Blob&quot;  ,   &quot;Data Class&quot;  :  [],   &quot;Feature Envy&quot;  :  &quot;YES I found bad smells&quot;,   &quot;the bad smells are&quot;  :  [       &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface XtypePackage extends EPackage { 	/** 	 * The package name. 	 *  	 *  	 * @generated 	 */ 	String eNAME = &quot;xtype&quot;;  	/** 	 * The package namespace URI. 	 *  	 *  	 * @generated 	 */ 	String eNS_URI = &quot;http://www.eclipse.org/xtext/xbase/Xtype&quot;;  	/** 	 * The package namespace name. 	 *  	 *  	 * @generated 	 */ 	String eNS_PREFIX = &quot;xtype&quot;;  	/** 	 * The singleton instance of the package. 	 *  	 *  	 * @generated 	 */ 	XtypePackage eINSTANCE = org.eclipse.xtext.xtype.impl.XtypePackageImpl.init();  	/** 	 * The meta object id for the '{@link org.eclipse.xtext.xtype.impl.XFunctionTypeRefImpl XFunction Type Ref}' class. 	 *  	 *  	 * @see org.eclipse.xtext.xtype.impl.XFunctionTypeRefImpl 	 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXFunctionTypeRef() 	 * @generated 	 */ 	int XFUNCTION_TYPE_REF = 0;  	/** 	 * The feature id for the 'Equivalent' containment reference. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XFUNCTION_TYPE_REF__EQUIVALENT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE__EQUIVALENT;  	/** 	 * The feature id for the 'Param Types' containment reference list. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XFUNCTION_TYPE_REF__PARAM_TYPES = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 0;  	/** 	 * The feature id for the 'Return Type' containment reference. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XFUNCTION_TYPE_REF__RETURN_TYPE = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 1;  	/** 	 * The feature id for the 'Type' reference. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XFUNCTION_TYPE_REF__TYPE = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 2;  	/** 	 * The feature id for the 'Instance Context' attribute. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XFUNCTION_TYPE_REF__INSTANCE_CONTEXT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 3;  	/** 	 * The number of structural features of the 'XFunction Type Ref' class. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XFUNCTION_TYPE_REF_FEATURE_COUNT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 4;  	/** 	 * The meta object id for the '{@link org.eclipse.xtext.xtype.impl.XComputedTypeReferenceImpl XComputed Type Reference}' class. 	 *  	 *  	 * @see org.eclipse.xtext.xtype.impl.XComputedTypeReferenceImpl 	 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXComputedTypeReference() 	 * @generated 	 */ 	int XCOMPUTED_TYPE_REFERENCE = 1;  	/** 	 * The feature id for the 'Equivalent' containment reference. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XCOMPUTED_TYPE_REFERENCE__EQUIVALENT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE__EQUIVALENT;  	/** 	 * The feature id for the 'Type Provider' attribute. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XCOMPUTED_TYPE_REFERENCE__TYPE_PROVIDER = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 0;  	/** 	 * The number of structural features of the 'XComputed Type Reference' class. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XCOMPUTED_TYPE_REFERENCE_FEATURE_COUNT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 1;  	/** 	 * The meta object id for the '{@link org.eclipse.xtext.xtype.impl.XImportSectionImpl XImport Section}' class. 	 *  	 *  	 * @see org.eclipse.xtext.xtype.impl.XImportSectionImpl 	 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXImportSection() 	 * @generated 	 */ 	int XIMPORT_SECTION = 2;  	/** 	 * The feature id for the 'Import Declarations' containment reference list. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XIMPORT_SECTION__IMPORT_DECLARATIONS = 0;  	/** 	 * The number of structural features of the 'XImport Section' class. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XIMPORT_SECTION_FEATURE_COUNT = 1;  	/** 	 * The meta object id for the '{@link org.eclipse.xtext.xtype.impl.XImportDeclarationImpl XImport Declaration}' class. 	 *  	 *  	 * @see org.eclipse.xtext.xtype.impl.XImportDeclarationImpl 	 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXImportDeclaration() 	 * @generated 	 */ 	int XIMPORT_DECLARATION = 3;  	/** 	 * The feature id for the 'Wildcard' attribute. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XIMPORT_DECLARATION__WILDCARD = 0;  	/** 	 * The feature id for the 'Extension' attribute. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XIMPORT_DECLARATION__EXTENSION = 1;  	/** 	 * The feature id for the 'Static' attribute. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XIMPORT_DECLARATION__STATIC = 2;  	/** 	 * The feature id for the 'Imported Type' reference. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XIMPORT_DECLARATION__IMPORTED_TYPE = 3;  	/** 	 * The feature id for the 'Member Name' attribute. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XIMPORT_DECLARATION__MEMBER_NAME = 4;  	/** 	 * The feature id for the 'Imported Namespace' attribute. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XIMPORT_DECLARATION__IMPORTED_NAMESPACE = 5;  	/** 	 * The number of structural features of the 'XImport Declaration' class. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XIMPORT_DECLARATION_FEATURE_COUNT = 6;  	/** 	 * The meta object id for the 'IJvm Type Reference Provider' data type. 	 *  	 *  	 * @see org.eclipse.xtext.xbase.typing.IJvmTypeReferenceProvider 	 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getIJvmTypeReferenceProvider() 	 * @generated 	 */ 	int IJVM_TYPE_REFERENCE_PROVIDER = 4;   	/** 	 * Returns the meta object for class '{@link org.eclipse.xtext.xtype.XFunctionTypeRef XFunction Type Ref}'. 	 *  	 *  	 * @return the meta object for class 'XFunction Type Ref'. 	 * @see org.eclipse.xtext.xtype.XFunctionTypeRef 	 * @generated 	 */ 	EClass getXFunctionTypeRef();  	/** 	 * Returns the meta object for the containment reference list '{@link org.eclipse.xtext.xtype.XFunctionTypeRef#getParamTypes Param Types}'. 	 *  	 *  	 * @return the meta object for the containment reference list 'Param Types'. 	 * @see org.eclipse.xtext.xtype.XFunctionTypeRef#getParamTypes() 	 * @see #getXFunctionTypeRef() 	 * @generated 	 */ 	EReference getXFunctionTypeRef_ParamTypes();  	/** 	 * Returns the meta object for the containment reference '{@link org.eclipse.xtext.xtype.XFunctionTypeRef#getReturnType Return Type}'. 	 *  	 *  	 * @return the meta object for the containment reference 'Return Type'. 	 * @see org.eclipse.xtext.xtype.XFunctionTypeRef#getReturnType() 	 * @see #getXFunctionTypeRef() 	 * @generated 	 */ 	EReference getXFunctionTypeRef_ReturnType();  	/** 	 * Returns the meta object for the reference '{@link org.eclipse.xtext.xtype.XFunctionTypeRef#getType Type}'. 	 *  	 *  	 * @return the meta object for the reference 'Type'. 	 * @see org.eclipse.xtext.xtype.XFunctionTypeRef#getType() 	 * @see #getXFunctionTypeRef() 	 * @generated 	 */ 	EReference getXFunctionTypeRef_Type();  	/** 	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XFunctionTypeRef#isInstanceContext Instance Context}'. 	 *  	 *  	 * @return the meta object for the attribute 'Instance Context'. 	 * @see org.eclipse.xtext.xtype.XFunctionTypeRef#isInstanceContext() 	 * @see #getXFunctionTypeRef() 	 * @generated 	 */ 	EAttribute getXFunctionTypeRef_InstanceContext();  	/** 	 * Returns the meta object for class '{@link org.eclipse.xtext.xtype.XComputedTypeReference XComputed Type Reference}'. 	 *  	 *  	 * @return the meta object for class 'XComputed Type Reference'. 	 * @see org.eclipse.xtext.xtype.XComputedTypeReference 	 * @generated 	 */ 	EClass getXComputedTypeReference();  	/** 	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XComputedTypeReference#getTypeProvider Type Provider}'. 	 *  	 *  	 * @return the meta object for the attribute 'Type Provider'. 	 * @see org.eclipse.xtext.xtype.XComputedTypeReference#getTypeProvider() 	 * @see #getXComputedTypeReference() 	 * @generated 	 */ 	EAttribute getXComputedTypeReference_TypeProvider();  	/** 	 * Returns the meta object for class '{@link org.eclipse.xtext.xtype.XImportSection XImport Section}'. 	 *  	 *  	 * @return the meta object for class 'XImport Section'. 	 * @see org.eclipse.xtext.xtype.XImportSection 	 * @generated 	 */ 	EClass getXImportSection();  	/** 	 * Returns the meta object for the containment reference list '{@link org.eclipse.xtext.xtype.XImportSection#getImportDeclarations Import Declarations}'. 	 *  	 *  	 * @return the meta object for the containment reference list 'Import Declarations'. 	 * @see org.eclipse.xtext.xtype.XImportSection#getImportDeclarations() 	 * @see #getXImportSection() 	 * @generated 	 */ 	EReference getXImportSection_ImportDeclarations();  	/** 	 * Returns the meta object for class '{@link org.eclipse.xtext.xtype.XImportDeclaration XImport Declaration}'. 	 *  	 *  	 * @return the meta object for class 'XImport Declaration'. 	 * @see org.eclipse.xtext.xtype.XImportDeclaration 	 * @generated 	 */ 	EClass getXImportDeclaration();  	/** 	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XImportDeclaration#isWildcard Wildcard}'. 	 *  	 *  	 * @return the meta object for the attribute 'Wildcard'. 	 * @see org.eclipse.xtext.xtype.XImportDeclaration#isWildcard() 	 * @see #getXImportDeclaration() 	 * @generated 	 */ 	EAttribute getXImportDeclaration_Wildcard();  	/** 	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XImportDeclaration#isExtension Extension}'. 	 *  	 *  	 * @return the meta object for the attribute 'Extension'. 	 * @see org.eclipse.xtext.xtype.XImportDeclaration#isExtension() 	 * @see #getXImportDeclaration() 	 * @generated 	 */ 	EAttribute getXImportDeclaration_Extension();  	/** 	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XImportDeclaration#isStatic Static}'. 	 *  	 *  	 * @return the meta object for the attribute 'Static'. 	 * @see org.eclipse.xtext.xtype.XImportDeclaration#isStatic() 	 * @see #getXImportDeclaration() 	 * @generated 	 */ 	EAttribute getXImportDeclaration_Static();  	/** 	 * Returns the meta object for the reference '{@link org.eclipse.xtext.xtype.XImportDeclaration#getImportedType Imported Type}'. 	 *  	 *  	 * @return the meta object for the reference 'Imported Type'. 	 * @see org.eclipse.xtext.xtype.XImportDeclaration#getImportedType() 	 * @see #getXImportDeclaration() 	 * @generated 	 */ 	EReference getXImportDeclaration_ImportedType();  	/** 	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XImportDeclaration#getMemberName Member Name}'. 	 *  	 *  	 * @return the meta object for the attribute 'Member Name'. 	 * @see org.eclipse.xtext.xtype.XImportDeclaration#getMemberName() 	 * @see #getXImportDeclaration() 	 * @generated 	 */ 	EAttribute getXImportDeclaration_MemberName();  	/** 	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XImportDeclaration#getImportedNamespace Imported Namespace}'. 	 *  	 *  	 * @return the meta object for the attribute 'Imported Namespace'. 	 * @see org.eclipse.xtext.xtype.XImportDeclaration#getImportedNamespace() 	 * @see #getXImportDeclaration() 	 * @generated 	 */ 	EAttribute getXImportDeclaration_ImportedNamespace();  	/** 	 * Returns the meta object for data type '{@link org.eclipse.xtext.xbase.typing.IJvmTypeReferenceProvider IJvm Type Reference Provider}'. 	 *  	 *  	 * @return the meta object for data type 'IJvm Type Reference Provider'. 	 * @see org.eclipse.xtext.xbase.typing.IJvmTypeReferenceProvider 	 * @model instanceClass=&quot;org.eclipse.xtext.xbase.typing.IJvmTypeReferenceProvider&quot; serializeable=&quot;false&quot; 	 * @generated 	 */ 	EDataType getIJvmTypeReferenceProvider();  	/** 	 * Returns the factory that creates the instances of the model. 	 *  	 *  	 * @return the factory that creates the instances of the model. 	 * @generated 	 */ 	XtypeFactory getXtypeFactory();  	/** 	 *  	 * Defines literals for the meta objects that represent 	 *  	 *   each class, 	 *   each feature of each class, 	 *   each enum, 	 *   and each data type 	 *  	 *  	 * @generated 	 */ 	interface Literals 	{ 		/** 		 * The meta object literal for the '{@link org.eclipse.xtext.xtype.impl.XFunctionTypeRefImpl XFunction Type Ref}' class. 		 *  		 *  		 * @see org.eclipse.xtext.xtype.impl.XFunctionTypeRefImpl 		 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXFunctionTypeRef() 		 * @generated 		 */ 		EClass XFUNCTION_TYPE_REF = eINSTANCE.getXFunctionTypeRef();  		/** 		 * The meta object literal for the 'Param Types' containment reference list feature. 		 *  		 *  		 * @generated 		 */ 		EReference XFUNCTION_TYPE_REF__PARAM_TYPES = eINSTANCE.getXFunctionTypeRef_ParamTypes();  		/** 		 * The meta object literal for the 'Return Type' containment reference feature. 		 *  		 *  		 * @generated 		 */ 		EReference XFUNCTION_TYPE_REF__RETURN_TYPE = eINSTANCE.getXFunctionTypeRef_ReturnType();  		/** 		 * The meta object literal for the 'Type' reference feature. 		 *  		 *  		 * @generated 		 */ 		EReference XFUNCTION_TYPE_REF__TYPE = eINSTANCE.getXFunctionTypeRef_Type();  		/** 		 * The meta object literal for the 'Instance Context' attribute feature. 		 *  		 *  		 * @generated 		 */ 		EAttribute XFUNCTION_TYPE_REF__INSTANCE_CONTEXT = eINSTANCE.getXFunctionTypeRef_InstanceContext();  		/** 		 * The meta object literal for the '{@link org.eclipse.xtext.xtype.impl.XComputedTypeReferenceImpl XComputed Type Reference}' class. 		 *  		 *  		 * @see org.eclipse.xtext.xtype.impl.XComputedTypeReferenceImpl 		 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXComputedTypeReference() 		 * @generated 		 */ 		EClass XCOMPUTED_TYPE_REFERENCE = eINSTANCE.getXComputedTypeReference();  		/** 		 * The meta object literal for the 'Type Provider' attribute feature. 		 *  		 *  		 * @generated 		 */ 		EAttribute XCOMPUTED_TYPE_REFERENCE__TYPE_PROVIDER = eINSTANCE.getXComputedTypeReference_TypeProvider();  		/** 		 * The meta object literal for the '{@link org.eclipse.xtext.xtype.impl.XImportSectionImpl XImport Section}' class. 		 *  		 *  		 * @see org.eclipse.xtext.xtype.impl.XImportSectionImpl 		 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXImportSection() 		 * @generated 		 */ 		EClass XIMPORT_SECTION = eINSTANCE.getXImportSection();  		/** 		 * The meta object literal for the 'Import Declarations' containment reference list feature. 		 *  		 *  		 * @generated 		 */ 		EReference XIMPORT_SECTION__IMPORT_DECLARATIONS = eINSTANCE.getXImportSection_ImportDeclarations();  		/** 		 * The meta object literal for the '{@link org.eclipse.xtext.xtype.impl.XImportDeclarationImpl XImport Declaration}' class. 		 *  		 *  		 * @see org.eclipse.xtext.xtype.impl.XImportDeclarationImpl 		 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXImportDeclaration() 		 * @generated 		 */ 		EClass XIMPORT_DECLARATION = eINSTANCE.getXImportDeclaration();  		/** 		 * The meta object literal for the 'Wildcard' attribute feature. 		 *  		 *  		 * @generated 		 */ 		EAttribute XIMPORT_DECLARATION__WILDCARD = eINSTANCE.getXImportDeclaration_Wildcard();  		/** 		 * The meta object literal for the 'Extension' attribute feature. 		 *  		 *  		 * @generated 		 */ 		EAttribute XIMPORT_DECLARATION__EXTENSION = eINSTANCE.getXImportDeclaration_Extension();  		/** 		 * The meta object literal for the 'Static' attribute feature. 		 *  		 *  		 * @generated 		 */ 		EAttribute XIMPORT_DECLARATION__STATIC = eINSTANCE.getXImportDeclaration_Static();  		/** 		 * The meta object literal for the 'Imported Type' reference feature. 		 *  		 *  		 * @generated 		 */ 		EReference XIMPORT_DECLARATION__IMPORTED_TYPE = eINSTANCE.getXImportDeclaration_ImportedType();  		/** 		 * The meta object literal for the 'Member Name' attribute feature. 		 *  		 *  		 * @generated 		 */ 		EAttribute XIMPORT_DECLARATION__MEMBER_NAME = eINSTANCE.getXImportDeclaration_MemberName();  		/** 		 * The meta object literal for the 'Imported Namespace' attribute feature. 		 *  		 *  		 * @generated 		 */ 		EAttribute XIMPORT_DECLARATION__IMPORTED_NAMESPACE = eINSTANCE.getXImportDeclaration_ImportedNamespace();  		/** 		 * The meta object literal for the 'IJvm Type Reference Provider' data type. 		 *  		 *  		 * @see org.eclipse.xtext.xbase.typing.IJvmTypeReferenceProvider 		 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getIJvmTypeReferenceProvider() 		 * @generated 		 */ 		EDataType IJVM_TYPE_REFERENCE_PROVIDER = eINSTANCE.getIJvmTypeReferenceProvider();  	}  } //XtypePackage</td>
    <td align="left">blob</td>
    <td align="left">&nbsp;&nbsp;&quot;Blob&quot;  ,  &quot;Data Class&quot;  </td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;&nbsp;&quot;Data Class&quot;  </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12647</td>
    <td align="left">https://github.com/eclipse/xtext-extras/blob/5634c291880cd46fe2f8e9a47e48ef88b85e8bda/org.eclipse.xtext.xbase/emf-gen/org/eclipse/xtext/xtype/XtypePackage.java/#L38-L639</td>
    <td align="right">1</td>
    <td align="right">1984</td>
    <td align="right">12647</td>
  </tr>
  <tr valign="top">
    <td align="right">2032</td>
    <td align="left">&nbsp;&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Strings {  	public static final String[] EMPTY_ARRAY = new String[0];  	public static boolean equalsIgnoreWhitespace(String left, String right) { 		String l = left == null ? &quot;&quot; : left.replaceAll(&quot;\\s&quot;, &quot;&quot;); 		String r = right == null ? &quot;&quot; : right.replaceAll(&quot;\\s&quot;, &quot;&quot;); 		return l.equals(r); 	}  	public static boolean equal(String literal, String name) { 		return isEmpty(literal) ? isEmpty(name) : literal.equals(name); 	}  	public static String notNull(Object o) { 		return String.valueOf(o); 	}  	public static String emptyIfNull(String s) { 		return (s == null) ? &quot;&quot; : s; 	}  	public static String concat(String separator, List list) { 		return concat(separator, list, 0); 	}  	public static  String toString(Collection list, Function toString, String delim) { 		StringBuffer buffer = new StringBuffer(); 		for (Iterator iterator = list.iterator(); iterator.hasNext();) { 			T t = iterator.next(); 			buffer.append(toString.apply(t)); 			if (iterator.hasNext()) 				buffer.append(delim); 		} 		return buffer.toString(); 	}  	public static String concat(String separator, List list, int skip) { 		StringBuffer buff = new StringBuffer(); 		int lastIndex = list.size() - skip; 		for (int i = 0; i &lt; lastIndex; i++) { 			buff.append(list.get(i)); 			if (i + 1 &lt; lastIndex) 				buff.append(separator); 		} 		String string = buff.toString(); 		return string.trim().length() == 0 ? null : string; 	}  	public static String skipLastToken(String value, String separator) { 		int endIndex = value.lastIndexOf(separator); 		if (endIndex &gt; 0) 			return value.substring(0, endIndex); 		return value; 	}  	public static String lastToken(String value, String separator) { 		int index = value.lastIndexOf(separator) + separator.length(); 		if (index &lt; value.length()) 			return value.substring(index, value.length()); 		return &quot;&quot;; 	}  	public static String toFirstUpper(String s) { 		if (s == null || s.length() == 0 || Character.isUpperCase(s.charAt(0))) 			return s; 		if (s.length() == 1) 			return s.toUpperCase(); 		return s.substring(0, 1).toUpperCase() + s.substring(1); 	}  	public static boolean isEmpty(String s) { 		return s == null || s.equals(&quot;&quot;); 	}  	public static String newLine() { 		return System.getProperty(&quot;line.separator&quot;); 	} 	 	/** 	 * @since 2.13 	 */ 	public static String toPlatformLineSeparator(CharSequence cs) { 		return cs.toString().replaceAll(&quot;\r?\n&quot;, Strings.newLine()); 	} 	 	/** 	 * @since 2.14 	 */ 	public static String toUnixLineSeparator(CharSequence cs) { 		return cs.toString().replaceAll(&quot;\r?\n&quot;, &quot;\n&quot;); 	}  	public static String toFirstLower(String s) { 		if (s == null || s.length() == 0 || Character.isLowerCase(s.charAt(0))) 			return s; 		if (s.length() == 1) 			return s.toLowerCase(); 		return s.substring(0, 1).toLowerCase() + s.substring(1); 	}  	private static final JavaStringConverter CONVERTER = new JavaStringConverter(); 	 	/** 	 * Resolve Java control character sequences with to the actual character value. 	 * Optionally handle unicode escape sequences, too.  	 */ 	public static String convertFromJavaString(String string, boolean useUnicode) { 		return CONVERTER.convertFromJavaString(string, useUnicode); 	}  	/** 	 * Escapes control characters with a preceding backslash. 	 * Encodes special chars as unicode escape sequence.  	 * The resulting string is safe to be put into a Java string literal between 	 * the quotes. 	 */ 	public static String convertToJavaString(String theString) { 		return CONVERTER.convertToJavaString(theString, true); 	} 	 	/** 	 * Escapes control characters with a preceding backslash. 	 * Optionally encodes special chars as unicode escape sequence.  	 * The resulting string is safe to be put into a Java string literal between 	 * the quotes. 	 */ 	public static String convertToJavaString(String input, boolean useUnicode) { 		return CONVERTER.convertToJavaString(input, useUnicode); 	}  	public static char toHex(int i) { 		return CONVERTER.toHex(i); 	}  	/** 	 * Splits a string around matches of the given delimiter string. 	 *  	 * This method works similar to {@link String#split(String)} but does not treat the delimiter 	 * as a regular expression. This makes it perform better in most cases where this feature is not 	 * necessary. Furthermore this implies that trailing empty segments will not be part of the 	 * result. 	 *  	 * For delimiters of length 1 it is preferred to use {@link #split(String, char)} instead. 	 *  	 * @param value 	 *            the string to split 	 * @param delimiter 	 *            the delimiting string (e.g. &quot;::&quot;) 	 *  	 * @return the list of strings computed by splitting the string around matches of the given delimiter 	 * without trailing empty segments. Never null and the list does not contain any null values. 	 *  	 * @throws NullPointerException 	 *             If the {@code value} or {@code delimiter} is {@code null} 	 */ 	public static List split(String value, String delimiter) { 		List result = new ArrayList(); 		int lastIndex = 0; 		int index = value.indexOf(delimiter, lastIndex); 		int pendingEmptyStrings = 0; 		while (index != -1) { 			String addMe = value.substring(lastIndex, index); 			if (addMe.length() == 0) 				pendingEmptyStrings++; 			else { 				while(pendingEmptyStrings &gt; 0) { 					result.add(&quot;&quot;); 					pendingEmptyStrings--; 				} 				result.add(addMe); 			} 			lastIndex = index + delimiter.length(); 			index = value.indexOf(delimiter, lastIndex); 		} 		if (lastIndex != value.length()) { 			while(pendingEmptyStrings &gt; 0) { 				result.add(&quot;&quot;); 				pendingEmptyStrings--; 			} 			result.add(value.substring(lastIndex)); 		} 		return result; 	}  	/** 	 * Splits a string around matches of the given delimiter character. 	 *  	 * This method works similar to {@link String#split(String)} but does not treat the delimiter 	 * as a regular expression. This makes it perform better in most cases where this feature is not 	 * necessary. Furthermore this implies that trailing empty segments will not be part of the 	 * result. 	 *  	 * @param value 	 *            the string to split 	 * @param delimiter 	 *            the delimiting character (e.g. '.' or ':') 	 *  	 * @return the list of strings computed by splitting the string around matches of the given delimiter 	 * without trailing empty segments. Never null and the list does not contain any null values. 	 *  	 * @throws NullPointerException 	 *             If the {@code value} is {@code null} 	 * @see String#split(String) 	 * @since 2.3 	 */ 	public static List split(String value, char delimiter) { 		List result = new ArrayList(); 		int lastIndex = 0; 		int index = value.indexOf(delimiter, lastIndex); 		int pendingEmptyStrings = 0; 		while (index != -1) { 			String addMe = value.substring(lastIndex, index); 			if (addMe.length() == 0) 				pendingEmptyStrings++; 			else { 				while(pendingEmptyStrings &gt; 0) { 					result.add(&quot;&quot;); 					pendingEmptyStrings--; 				} 				result.add(addMe); 			} 			lastIndex = index + 1; 			index = value.indexOf(delimiter, lastIndex); 		} 		if (lastIndex != value.length()) { 			while(pendingEmptyStrings &gt; 0) { 				result.add(&quot;&quot;); 				pendingEmptyStrings--; 			} 			result.add(value.substring(lastIndex)); 		} 		return result; 	}  	public static final char SEPARATOR = ':';  	/** 	 * @param strings array of strings, may not be null and may not contain any null values. 	 * @throws NullPointerException if the array of strings or any element in the array is null 	 */ 	public static String pack(String[] strings) { 		if (strings != null &amp;&amp; strings.length &gt; 0) { 			StringBuffer buffer = new StringBuffer(); 			for (String s : strings) { 				buffer.append(s.length()); 				buffer.append(SEPARATOR); 				buffer.append(s); 			} 			return buffer.toString(); 		} 		return null; 	}  	public static String[] unpack(String packed) { 		if (isEmpty(packed)) { 			return null; 		} else { 			List strings = Lists.newArrayList(); 			unpack(strings, packed); 			return strings.toArray(new String[strings.size()]); 		} 	}  	private static void unpack(List strings, String packed) { 		int delimiterIndex = packed.indexOf(&quot;:&quot;); 		int size = Integer.parseInt(packed.substring(0, delimiterIndex)); 		int endIndex = delimiterIndex + 1 + size; 		strings.add(packed.substring(delimiterIndex + 1, endIndex)); 		if (endIndex &lt; packed.length()) { 			unpack(strings, packed.substring(endIndex)); 		} 	}  	public static String removeLeadingWhitespace(String indentationString) { 		int i = 0; 		while (i 1 &amp;&amp; s.charAt(s.length() - 2) == '\r') { 				return s.subSequence(0, s.length() - 2); 			} 			return s.subSequence(0, s.length() - 1); 		} 		if (s.charAt(s.length() - 1) == '\r') { 			return s.subSequence(0, s.length() - 1); 		} 		return s; 	} 	 	/** 	 * Counts the number of lines where {@link #separator} is assumed to be the only valid line break sequence. 	 * A string without any line separators returns {@code 0} as the number of lines. 	 */ 	public static int countLines(String text) { 		return countLines(text, separator); 	}  	/** 	 * Counts the number of lines where the given separator sequence is the only valid line break sequence. 	 * A string without any line separators returns {@code 0} as the number of lines. 	 */ 	public static int countLines(String text, char[] separator) { 		return countLines(text, separator, 0, text.length()); 	}  	/** 	 * Counts the number of lines between {@code startInclusive} and {@code endExclusive} 	 * where the given separator sequence is the only valid line break sequence. 	 * A string without any line separators in that range returns {@code 0} as the number of lines. 	 *  	 * @since 2.9 	 */ 	public static int countLines(String text, char[] separator, int startInclusive, int endExclusive) { 		int line = 0; 		if (separator.length == 1) { 			char c = separator[0]; 			for (int i = startInclusive; i &lt; endExclusive; i++) { 				if (text.charAt(i) == c) { 					line++; 				} 			} 		} else if (separator.length == 2) { 			char c1 = separator[0]; 			char c2 = separator[1]; 			for (int i = startInclusive; i &lt; endExclusive; i++) { 				if (text.charAt(i) == c1 &amp;&amp; endExclusive &gt; i + 1 &amp;&amp; text.charAt(i + 1) == c2) { 					line++; 					i++; 				} else if (text.charAt(i) == c2) { 					line++; 				} 			} 		} else { 			throw new IllegalArgumentException(&quot;Separators with more than two characters are unexpected&quot;); 		} 		return line; 	} 	 	// TODO is it worthwhile to deprecate this method and fix the typo 'Whitespace'? 	public static String getLeadingWhiteSpace(String original) { 		for(int i=0; i &lt; original.length(); i++) { 			if (!Character.isWhitespace(original.charAt(i))) { 				return original.substring(0, i); 			} 		} 		return original; 	} 	 	/** 	 * @since 2.1 	 */ 	public static String wordWrap(String string, int maxCharsPerLine) { 		StringBuilder document = new StringBuilder(); 		StringBuilder line = new StringBuilder(); 		StringBuilder word = new StringBuilder(); 		StringBuilder ws = new StringBuilder(); 		for (int i = 0; i &lt; string.length(); i++) { 			char c = string.charAt(i); 			if (c == '\n') { 				line.append(ws); 				line.append(word); 				line.append(&quot;\n&quot;); 				document.append(line); 				line = new StringBuilder(); 				word = new StringBuilder(); 				ws = new StringBuilder(); 			} else if (Character.isWhitespace(c)) { 				if (line.length() + word.length() + 1 &gt; maxCharsPerLine) { 					line.append(&quot;\n&quot;); 					document.append(line); 					line = new StringBuilder(); 					line.append(word); 					word = new StringBuilder(); 					ws = new StringBuilder(); 					ws.append(c); 				} else if (word.length() == 0) { 					ws.append(c); 				} else { 					line.append(ws); 					line.append(word); 					word = new StringBuilder(); 					ws = new StringBuilder(); 					ws.append(c); 				} 			} else { 				word.append(c); 			} 		} 		if (line.length() + word.length() + 1 &gt; maxCharsPerLine) { 			document.append(line); 			document.append(&quot;\n&quot;); 			document.append(word); 		} else { 			document.append(line); 			document.append(ws); 			document.append(word); 		} 		return document.toString(); 	}  }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12819</td>
    <td align="left">https://github.com/eclipse/xtext-core/blob/e04964e4c2a3e0338c0079bd8333688835e77c31/org.eclipse.xtext.util/src/org/eclipse/xtext/util/Strings.java/#L23-L475</td>
    <td align="right">1</td>
    <td align="right">2032</td>
    <td align="right">12819</td>
  </tr>
  <tr valign="top">
    <td align="right">2049</td>
    <td align="left">{&quot;answer&quot;:&quot;YES I found bad smells&quot;,&quot;detected_bad_smells&quot;:[&quot;Long Method&quot;,&quot;Data Class&quot;,&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DefaultHotSpotLoweringProvider extends DefaultJavaLoweringProvider implements HotSpotLoweringProvider {      protected final HotSpotGraalRuntimeProvider runtime;     protected final HotSpotRegistersProvider registers;     protected final HotSpotConstantReflectionProvider constantReflection;      protected InstanceOfSnippets.Templates instanceofSnippets;     protected NewObjectSnippets.Templates newObjectSnippets;     protected MonitorSnippets.Templates monitorSnippets;     protected WriteBarrierSnippets.Templates writeBarrierSnippets;     protected LoadExceptionObjectSnippets.Templates exceptionObjectSnippets;     protected UnsafeLoadSnippets.Templates unsafeLoadSnippets;     protected AssertionSnippets.Templates assertionSnippets;     protected ArrayCopySnippets.Templates arraycopySnippets;     protected StringToBytesSnippets.Templates stringToBytesSnippets;     protected HashCodeSnippets.Templates hashCodeSnippets;     protected ResolveConstantSnippets.Templates resolveConstantSnippets;     protected ProfileSnippets.Templates profileSnippets;      protected ObjectCloneSnippets.Templates objectCloneSnippets;     protected ForeignCallSnippets.Templates foreignCallSnippets;      public DefaultHotSpotLoweringProvider(HotSpotGraalRuntimeProvider runtime, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls, HotSpotRegistersProvider registers,                     HotSpotConstantReflectionProvider constantReflection, TargetDescription target) {         super(metaAccess, foreignCalls, target, runtime.getVMConfig().useCompressedOops);         this.runtime = runtime;         this.registers = registers;         this.constantReflection = constantReflection;     }      @Override     public void initialize(OptionValues options, Iterable factories, HotSpotProviders providers, GraalHotSpotVMConfig config) {         super.initialize(options, factories, runtime, providers, providers.getSnippetReflection());          assert target == providers.getCodeCache().getTarget();         instanceofSnippets = new InstanceOfSnippets.Templates(options, factories, runtime, providers, target);         newObjectSnippets = new NewObjectSnippets.Templates(options, factories, runtime, providers, target, config);         monitorSnippets = new MonitorSnippets.Templates(options, factories, runtime, providers, target, config.useFastLocking);         writeBarrierSnippets = new WriteBarrierSnippets.Templates(options, factories, runtime, providers, target, config);         exceptionObjectSnippets = new LoadExceptionObjectSnippets.Templates(options, factories, providers, target);         unsafeLoadSnippets = new UnsafeLoadSnippets.Templates(options, factories, providers, target);         assertionSnippets = new AssertionSnippets.Templates(options, factories, providers, target);         arraycopySnippets = new ArrayCopySnippets.Templates(new HotSpotArraycopySnippets(), options, factories, runtime, providers, providers.getSnippetReflection(), target);         stringToBytesSnippets = new StringToBytesSnippets.Templates(options, factories, providers, target);         hashCodeSnippets = new HashCodeSnippets.Templates(options, factories, providers, target);         resolveConstantSnippets = new ResolveConstantSnippets.Templates(options, factories, providers, target);         if (!JavaVersionUtil.Java8OrEarlier) {             profileSnippets = new ProfileSnippets.Templates(options, factories, providers, target);         }         objectCloneSnippets = new ObjectCloneSnippets.Templates(options, factories, providers, target);         foreignCallSnippets = new ForeignCallSnippets.Templates(options, factories, providers, target);     }      public MonitorSnippets.Templates getMonitorSnippets() {         return monitorSnippets;     }      @Override     @SuppressWarnings(&quot;try&quot;)     public void lower(Node n, LoweringTool tool) {         StructuredGraph graph = (StructuredGraph) n.graph();         try (DebugCloseable context = n.withNodeSourcePosition()) {             if (n instanceof Invoke) {                 lowerInvoke((Invoke) n, tool, graph);             } else if (n instanceof LoadMethodNode) {                 lowerLoadMethodNode((LoadMethodNode) n);             } else if (n instanceof GetClassNode) {                 lowerGetClassNode((GetClassNode) n, tool, graph);             } else if (n instanceof StoreHubNode) {                 lowerStoreHubNode((StoreHubNode) n, graph);             } else if (n instanceof OSRStartNode) {                 lowerOSRStartNode((OSRStartNode) n);             } else if (n instanceof BytecodeExceptionNode) {                 lowerBytecodeExceptionNode((BytecodeExceptionNode) n);             } else if (n instanceof InstanceOfNode) {                 InstanceOfNode instanceOfNode = (InstanceOfNode) n;                 if (graph.getGuardsStage().areDeoptsFixed()) {                     instanceofSnippets.lower(instanceOfNode, tool);                 } else {                     if (instanceOfNode.allowsNull()) {                         ValueNode object = instanceOfNode.getValue();                         LogicNode newTypeCheck = graph.addOrUniqueWithInputs(InstanceOfNode.create(instanceOfNode.type(), object, instanceOfNode.profile(), instanceOfNode.getAnchor()));                         LogicNode newNode = LogicNode.or(graph.unique(IsNullNode.create(object)), newTypeCheck, GraalDirectives.UNLIKELY_PROBABILITY);                         instanceOfNode.replaceAndDelete(newNode);                     }                 }             } else if (n instanceof InstanceOfDynamicNode) {                 InstanceOfDynamicNode instanceOfDynamicNode = (InstanceOfDynamicNode) n;                 if (graph.getGuardsStage().areDeoptsFixed()) {                     instanceofSnippets.lower(instanceOfDynamicNode, tool);                 } else {                     ValueNode mirror = instanceOfDynamicNode.getMirrorOrHub();                     if (mirror.stamp(NodeView.DEFAULT).getStackKind() == JavaKind.Object) {                         ClassGetHubNode classGetHub = graph.unique(new ClassGetHubNode(mirror));                         instanceOfDynamicNode.setMirror(classGetHub);                     }                      if (instanceOfDynamicNode.allowsNull()) {                         ValueNode object = instanceOfDynamicNode.getObject();                         LogicNode newTypeCheck = graph.addOrUniqueWithInputs(                                         InstanceOfDynamicNode.create(graph.getAssumptions(), tool.getConstantReflection(), instanceOfDynamicNode.getMirrorOrHub(), object, false));                         LogicNode newNode = LogicNode.or(graph.unique(IsNullNode.create(object)), newTypeCheck, GraalDirectives.UNLIKELY_PROBABILITY);                         instanceOfDynamicNode.replaceAndDelete(newNode);                     }                 }             } else if (n instanceof ClassIsAssignableFromNode) {                 if (graph.getGuardsStage().areDeoptsFixed()) {                     instanceofSnippets.lower((ClassIsAssignableFromNode) n, tool);                 }             } else if (n instanceof NewInstanceNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     newObjectSnippets.lower((NewInstanceNode) n, registers, tool);                 }             } else if (n instanceof DynamicNewInstanceNode) {                 DynamicNewInstanceNode newInstanceNode = (DynamicNewInstanceNode) n;                 if (newInstanceNode.getClassClass() == null) {                     JavaConstant classClassMirror = constantReflection.asJavaClass(metaAccess.lookupJavaType(Class.class));                     ConstantNode classClass = ConstantNode.forConstant(classClassMirror, tool.getMetaAccess(), graph);                     newInstanceNode.setClassClass(classClass);                 }                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     newObjectSnippets.lower(newInstanceNode, registers, tool);                 }             } else if (n instanceof NewArrayNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     newObjectSnippets.lower((NewArrayNode) n, registers, tool);                 }             } else if (n instanceof DynamicNewArrayNode) {                 DynamicNewArrayNode dynamicNewArrayNode = (DynamicNewArrayNode) n;                 if (dynamicNewArrayNode.getVoidClass() == null) {                     JavaConstant voidClassMirror = constantReflection.asJavaClass(metaAccess.lookupJavaType(void.class));                     ConstantNode voidClass = ConstantNode.forConstant(voidClassMirror, tool.getMetaAccess(), graph);                     dynamicNewArrayNode.setVoidClass(voidClass);                 }                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     newObjectSnippets.lower(dynamicNewArrayNode, registers, tool);                 }             } else if (n instanceof VerifyHeapNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     newObjectSnippets.lower((VerifyHeapNode) n, registers, tool);                 }             } else if (n instanceof RawMonitorEnterNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     monitorSnippets.lower((RawMonitorEnterNode) n, registers, tool);                 }             } else if (n instanceof MonitorExitNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     monitorSnippets.lower((MonitorExitNode) n, registers, tool);                 }             } else if (n instanceof ArrayCopyNode) {                 arraycopySnippets.lower((ArrayCopyNode) n, tool);             } else if (n instanceof ArrayCopyWithSlowPathNode) {                 arraycopySnippets.lower((ArrayCopyWithSlowPathNode) n, tool);             } else if (n instanceof G1PreWriteBarrier) {                 writeBarrierSnippets.lower((G1PreWriteBarrier) n, registers, tool);             } else if (n instanceof G1PostWriteBarrier) {                 writeBarrierSnippets.lower((G1PostWriteBarrier) n, registers, tool);             } else if (n instanceof G1ReferentFieldReadBarrier) {                 writeBarrierSnippets.lower((G1ReferentFieldReadBarrier) n, registers, tool);             } else if (n instanceof SerialWriteBarrier) {                 writeBarrierSnippets.lower((SerialWriteBarrier) n, tool);             } else if (n instanceof SerialArrayRangeWriteBarrier) {                 writeBarrierSnippets.lower((SerialArrayRangeWriteBarrier) n, tool);             } else if (n instanceof G1ArrayRangePreWriteBarrier) {                 writeBarrierSnippets.lower((G1ArrayRangePreWriteBarrier) n, registers, tool);             } else if (n instanceof G1ArrayRangePostWriteBarrier) {                 writeBarrierSnippets.lower((G1ArrayRangePostWriteBarrier) n, registers, tool);             } else if (n instanceof NewMultiArrayNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     newObjectSnippets.lower((NewMultiArrayNode) n, tool);                 }             } else if (n instanceof LoadExceptionObjectNode) {                 exceptionObjectSnippets.lower((LoadExceptionObjectNode) n, registers, tool);             } else if (n instanceof AssertionNode) {                 assertionSnippets.lower((AssertionNode) n, tool);             } else if (n instanceof StringToBytesNode) {                 if (graph.getGuardsStage().areDeoptsFixed()) {                     stringToBytesSnippets.lower((StringToBytesNode) n, tool);                 }             } else if (n instanceof IntegerDivRemNode) {                 // Nothing to do for division nodes. The HotSpot signal handler catches divisions by                 // zero and the MIN_VALUE / -1 cases.             } else if (n instanceof AbstractDeoptimizeNode || n instanceof UnwindNode || n instanceof RemNode || n instanceof SafepointNode) {                 /* No lowering, we generate LIR directly for these nodes. */             } else if (n instanceof ClassGetHubNode) {                 lowerClassGetHubNode((ClassGetHubNode) n, tool);             } else if (n instanceof HubGetClassNode) {                 lowerHubGetClassNode((HubGetClassNode) n, tool);             } else if (n instanceof KlassLayoutHelperNode) {                 lowerKlassLayoutHelperNode((KlassLayoutHelperNode) n, tool);             } else if (n instanceof ComputeObjectAddressNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     lowerComputeObjectAddressNode((ComputeObjectAddressNode) n);                 }             } else if (n instanceof IdentityHashCodeNode) {                 hashCodeSnippets.lower((IdentityHashCodeNode) n, tool);             } else if (n instanceof ResolveDynamicConstantNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     resolveConstantSnippets.lower((ResolveDynamicConstantNode) n, tool);                 }             } else if (n instanceof ResolveConstantNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     resolveConstantSnippets.lower((ResolveConstantNode) n, tool);                 }             } else if (n instanceof ResolveMethodAndLoadCountersNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     resolveConstantSnippets.lower((ResolveMethodAndLoadCountersNode) n, tool);                 }             } else if (n instanceof InitializeKlassNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     resolveConstantSnippets.lower((InitializeKlassNode) n, tool);                 }             } else if (n instanceof ProfileNode) {                 profileSnippets.lower((ProfileNode) n, tool);             } else {                 super.lower(n, tool);             }         }     }      private static void lowerComputeObjectAddressNode(ComputeObjectAddressNode n) {         /*          * Lower the node into a ComputeObjectAddress node and an Add but ensure that it's below any          * potential safepoints and above it's uses.          */         for (Node use : n.usages().snapshot()) {             if (use instanceof FixedNode) {                 FixedNode fixed = (FixedNode) use;                 StructuredGraph graph = n.graph();                 GetObjectAddressNode address = graph.add(new GetObjectAddressNode(n.getObject()));                 graph.addBeforeFixed(fixed, address);                 AddNode add = graph.addOrUnique(new AddNode(address, n.getOffset()));                 use.replaceFirstInput(n, add);             } else {                 throw GraalError.shouldNotReachHere(&quot;Unexpected floating use of ComputeObjectAddressNode &quot; + n);             }         }         GraphUtil.unlinkFixedNode(n);         n.safeDelete();     }      private void lowerKlassLayoutHelperNode(KlassLayoutHelperNode n, LoweringTool tool) {         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {             return;         }         StructuredGraph graph = n.graph();         assert !n.getHub().isConstant();         AddressNode address = createOffsetAddress(graph, n.getHub(), runtime.getVMConfig().klassLayoutHelperOffset);         n.replaceAtUsagesAndDelete(graph.unique(new FloatingReadNode(address, KLASS_LAYOUT_HELPER_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE)));     }      private void lowerHubGetClassNode(HubGetClassNode n, LoweringTool tool) {         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {             return;         }          ValueNode hub = n.getHub();         GraalHotSpotVMConfig vmConfig = runtime.getVMConfig();         StructuredGraph graph = n.graph();         assert !hub.isConstant() || GraalOptions.ImmutableCode.getValue(graph.getOptions());         AddressNode mirrorAddress = createOffsetAddress(graph, hub, vmConfig.classMirrorOffset);         FloatingReadNode read = graph.unique(                         new FloatingReadNode(mirrorAddress, CLASS_MIRROR_LOCATION, null, vmConfig.classMirrorIsHandle ? StampFactory.forKind(target.wordJavaKind) : n.stamp(NodeView.DEFAULT),                                         null, BarrierType.NONE));         if (vmConfig.classMirrorIsHandle) {             AddressNode address = createOffsetAddress(graph, read, 0);             read = graph.unique(new FloatingReadNode(address, CLASS_MIRROR_HANDLE_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE));         }         n.replaceAtUsagesAndDelete(read);     }      private void lowerClassGetHubNode(ClassGetHubNode n, LoweringTool tool) {         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {             return;         }          StructuredGraph graph = n.graph();         assert !n.getValue().isConstant();         AddressNode address = createOffsetAddress(graph, n.getValue(), runtime.getVMConfig().klassOffset);         FloatingReadNode read = graph.unique(new FloatingReadNode(address, CLASS_KLASS_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE));         n.replaceAtUsagesAndDelete(read);     }      private void lowerInvoke(Invoke invoke, LoweringTool tool, StructuredGraph graph) {         if (invoke.callTarget() instanceof MethodCallTargetNode) {             MethodCallTargetNode callTarget = (MethodCallTargetNode) invoke.callTarget();             NodeInputList parameters = callTarget.arguments();             ValueNode receiver = parameters.size() &lt;= 0 ? null : parameters.get(0);             if (!callTarget.isStatic() &amp;&amp; receiver.stamp(NodeView.DEFAULT) instanceof ObjectStamp &amp;&amp; !StampTool.isPointerNonNull(receiver)) {                 ValueNode nonNullReceiver = createNullCheckedValue(receiver, invoke.asNode(), tool);                 parameters.set(0, nonNullReceiver);                 receiver = nonNullReceiver;             }             JavaType[] signature = callTarget.targetMethod().getSignature().toParameterTypes(callTarget.isStatic() ? null : callTarget.targetMethod().getDeclaringClass());              LoweredCallTargetNode loweredCallTarget = null;             OptionValues options = graph.getOptions();             if (InlineVTableStubs.getValue(options) &amp;&amp; callTarget.invokeKind().isIndirect() &amp;&amp; (AlwaysInlineVTableStubs.getValue(options) || invoke.isPolymorphic())) {                 HotSpotResolvedJavaMethod hsMethod = (HotSpotResolvedJavaMethod) callTarget.targetMethod();                 ResolvedJavaType receiverType = invoke.getReceiverType();                 if (hsMethod.isInVirtualMethodTable(receiverType)) {                     JavaKind wordKind = runtime.getTarget().wordJavaKind;                     ValueNode hub = createReadHub(graph, receiver, tool);                      ReadNode metaspaceMethod = createReadVirtualMethod(graph, hub, hsMethod, receiverType);                     // We use LocationNode.ANY_LOCATION for the reads that access the                     // compiled code entry as HotSpot does not guarantee they are final                     // values.                     int methodCompiledEntryOffset = runtime.getVMConfig().methodCompiledEntryOffset;                     AddressNode address = createOffsetAddress(graph, metaspaceMethod, methodCompiledEntryOffset);                     ReadNode compiledEntry = graph.add(new ReadNode(address, any(), StampFactory.forKind(wordKind), BarrierType.NONE));                      loweredCallTarget = graph.add(new HotSpotIndirectCallTargetNode(metaspaceMethod, compiledEntry, parameters.toArray(new ValueNode[parameters.size()]), callTarget.returnStamp(),                                     signature, callTarget.targetMethod(),                                     HotSpotCallingConventionType.JavaCall, callTarget.invokeKind()));                      graph.addBeforeFixed(invoke.asNode(), metaspaceMethod);                     graph.addAfterFixed(metaspaceMethod, compiledEntry);                 }             }              if (loweredCallTarget == null) {                 loweredCallTarget = graph.add(new HotSpotDirectCallTargetNode(parameters.toArray(new ValueNode[parameters.size()]), callTarget.returnStamp(),                                 signature, callTarget.targetMethod(),                                 HotSpotCallingConventionType.JavaCall,                                 callTarget.invokeKind()));             }             callTarget.replaceAndDelete(loweredCallTarget);         }     }      private CompressEncoding getOopEncoding() {         return runtime.getVMConfig().getOopEncoding();     }      @Override     protected Stamp loadCompressedStamp(ObjectStamp stamp) {         return HotSpotNarrowOopStamp.compressed(stamp, getOopEncoding());     }      @Override     protected ValueNode newCompressionNode(CompressionOp op, ValueNode value) {         return new HotSpotCompressionNode(op, value, getOopEncoding());     }      @Override     public ValueNode staticFieldBase(StructuredGraph graph, ResolvedJavaField f) {         HotSpotResolvedJavaField field = (HotSpotResolvedJavaField) f;         JavaConstant base = constantReflection.asJavaClass(field.getDeclaringClass());         return ConstantNode.forConstant(base, metaAccess, graph);     }      @Override     protected ValueNode createReadArrayComponentHub(StructuredGraph graph, ValueNode arrayHub, FixedNode anchor) {         /*          * Anchor the read of the element klass to the cfg, because it is only valid when arrayClass          * is an object class, which might not be the case in other parts of the compiled method.          */         AddressNode address = createOffsetAddress(graph, arrayHub, runtime.getVMConfig().arrayClassElementOffset);         return graph.unique(new FloatingReadNode(address, OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION, null, KlassPointerStamp.klassNonNull(), AbstractBeginNode.prevBegin(anchor)));     }      @Override     protected void lowerUnsafeLoadNode(RawLoadNode load, LoweringTool tool) {         StructuredGraph graph = load.graph();         if (!(load instanceof GuardedUnsafeLoadNode) &amp;&amp; !graph.getGuardsStage().allowsFloatingGuards() &amp;&amp; addReadBarrier(load)) {             unsafeLoadSnippets.lower(load, tool);         } else {             super.lowerUnsafeLoadNode(load, tool);         }     }      private void lowerLoadMethodNode(LoadMethodNode loadMethodNode) {         StructuredGraph graph = loadMethodNode.graph();         HotSpotResolvedJavaMethod method = (HotSpotResolvedJavaMethod) loadMethodNode.getMethod();         ReadNode metaspaceMethod = createReadVirtualMethod(graph, loadMethodNode.getHub(), method, loadMethodNode.getReceiverType());         graph.replaceFixed(loadMethodNode, metaspaceMethod);     }      private static void lowerGetClassNode(GetClassNode getClass, LoweringTool tool, StructuredGraph graph) {         StampProvider stampProvider = tool.getStampProvider();         LoadHubNode hub = graph.unique(new LoadHubNode(stampProvider, getClass.getObject()));         HubGetClassNode hubGetClass = graph.unique(new HubGetClassNode(tool.getMetaAccess(), hub));         getClass.replaceAtUsagesAndDelete(hubGetClass);         hub.lower(tool);         hubGetClass.lower(tool);     }      private void lowerStoreHubNode(StoreHubNode storeHub, StructuredGraph graph) {         WriteNode hub = createWriteHub(graph, storeHub.getObject(), storeHub.getValue());         graph.replaceFixed(storeHub, hub);     }      @Override     public BarrierType fieldInitializationBarrier(JavaKind entryKind) {         return (entryKind == JavaKind.Object &amp;&amp; !runtime.getVMConfig().useDeferredInitBarriers) ? BarrierType.IMPRECISE : BarrierType.NONE;     }      @Override     public BarrierType arrayInitializationBarrier(JavaKind entryKind) {         return (entryKind == JavaKind.Object &amp;&amp; !runtime.getVMConfig().useDeferredInitBarriers) ? BarrierType.PRECISE : BarrierType.NONE;     }      private void lowerOSRStartNode(OSRStartNode osrStart) {         StructuredGraph graph = osrStart.graph();         if (graph.getGuardsStage() == StructuredGraph.GuardsStage.FIXED_DEOPTS) {             StartNode newStart = graph.add(new StartNode());             ParameterNode buffer = graph.addWithoutUnique(new ParameterNode(0, StampPair.createSingle(StampFactory.forKind(runtime.getTarget().wordJavaKind))));             ForeignCallNode migrationEnd = graph.add(new ForeignCallNode(foreignCalls, OSR_MIGRATION_END, buffer));             migrationEnd.setStateAfter(osrStart.stateAfter());             newStart.setNext(migrationEnd);             FixedNode next = osrStart.next();             osrStart.setNext(null);             migrationEnd.setNext(next);             graph.setStart(newStart);              final int wordSize = target.wordSize;              // @formatter:off             // taken from c2 locals_addr = osr_buf + (max_locals-1)*wordSize)             // @formatter:on             int localsOffset = (graph.method().getMaxLocals() - 1) * wordSize;             for (OSRLocalNode osrLocal : graph.getNodes(OSRLocalNode.TYPE)) {                 int size = osrLocal.getStackKind().getSlotCount();                 int offset = localsOffset - (osrLocal.index() + size - 1) * wordSize;                 AddressNode address = createOffsetAddress(graph, buffer, offset);                 ReadNode load = graph.add(new ReadNode(address, any(), osrLocal.stamp(NodeView.DEFAULT), BarrierType.NONE));                 osrLocal.replaceAndDelete(load);                 graph.addBeforeFixed(migrationEnd, load);             }              // @formatter:off             // taken from c2 monitors_addr = osr_buf + (max_locals+mcnt*2-1)*wordSize);             // @formatter:on             final int lockCount = osrStart.stateAfter().locksSize();             final int locksOffset = (graph.method().getMaxLocals() + lockCount * 2 - 1) * wordSize;              // first initialize the lock slots for all enters with the displaced marks read from the             // buffer             for (OSRMonitorEnterNode osrMonitorEnter : graph.getNodes(OSRMonitorEnterNode.TYPE)) {                 MonitorIdNode monitorID = osrMonitorEnter.getMonitorId();                 OSRLockNode lock = (OSRLockNode) osrMonitorEnter.object();                 final int index = lock.index();                  final int offsetDisplacedHeader = locksOffset - ((index * 2) + 1) * wordSize;                 final int offsetLockObject = locksOffset - index * 2 * wordSize;                  // load the displaced mark from the osr buffer                 AddressNode addressDisplacedHeader = createOffsetAddress(graph, buffer, offsetDisplacedHeader);                 ReadNode loadDisplacedHeader = graph.add(new ReadNode(addressDisplacedHeader, any(), lock.stamp(NodeView.DEFAULT), BarrierType.NONE));                 graph.addBeforeFixed(migrationEnd, loadDisplacedHeader);                  // we need to initialize the stack slot for the lock                 BeginLockScopeNode beginLockScope = graph.add(new BeginLockScopeNode(lock.getStackKind(), monitorID.getLockDepth()));                 graph.addBeforeFixed(migrationEnd, beginLockScope);                  // write the displaced mark to the correct stack slot                 AddressNode addressDisplacedMark = createOffsetAddress(graph, beginLockScope, runtime.getVMConfig().basicLockDisplacedHeaderOffset);                 WriteNode writeStackSlot = graph.add(new WriteNode(addressDisplacedMark, DISPLACED_MARK_WORD_LOCATION, loadDisplacedHeader, BarrierType.NONE));                 graph.addBeforeFixed(migrationEnd, writeStackSlot);                  // load the lock object from the osr buffer                 AddressNode addressLockObject = createOffsetAddress(graph, buffer, offsetLockObject);                 ReadNode loadObject = graph.add(new ReadNode(addressLockObject, any(), lock.stamp(NodeView.DEFAULT), BarrierType.NONE));                 lock.replaceAndDelete(loadObject);                 graph.addBeforeFixed(migrationEnd, loadObject);             }              osrStart.replaceAtUsagesAndDelete(newStart);         }     }      static final class Exceptions {         protected static final EnumMap cachedExceptions;          static {             cachedExceptions = new EnumMap&lt;&gt;(BytecodeExceptionKind.class);             cachedExceptions.put(BytecodeExceptionKind.NULL_POINTER, clearStackTrace(new NullPointerException()));             cachedExceptions.put(BytecodeExceptionKind.OUT_OF_BOUNDS, clearStackTrace(new ArrayIndexOutOfBoundsException()));             cachedExceptions.put(BytecodeExceptionKind.CLASS_CAST, clearStackTrace(new ClassCastException()));             cachedExceptions.put(BytecodeExceptionKind.ARRAY_STORE, clearStackTrace(new ArrayStoreException()));             cachedExceptions.put(BytecodeExceptionKind.DIVISION_BY_ZERO, clearStackTrace(new ArithmeticException()));         }          private static RuntimeException clearStackTrace(RuntimeException ex) {             ex.setStackTrace(new StackTraceElement[0]);             return ex;         }     }      public static final class RuntimeCalls {         public static final EnumMap runtimeCalls;          static {             runtimeCalls = new EnumMap&lt;&gt;(BytecodeExceptionKind.class);             runtimeCalls.put(BytecodeExceptionKind.ARRAY_STORE, new ForeignCallDescriptor(&quot;createArrayStoreException&quot;, ArrayStoreException.class, Object.class));             runtimeCalls.put(BytecodeExceptionKind.CLASS_CAST, new ForeignCallDescriptor(&quot;createClassCastException&quot;, ClassCastException.class, Object.class, KlassPointer.class));             runtimeCalls.put(BytecodeExceptionKind.NULL_POINTER, new ForeignCallDescriptor(&quot;createNullPointerException&quot;, NullPointerException.class));             runtimeCalls.put(BytecodeExceptionKind.OUT_OF_BOUNDS, new ForeignCallDescriptor(&quot;createOutOfBoundsException&quot;, ArrayIndexOutOfBoundsException.class, int.class, int.class));             runtimeCalls.put(BytecodeExceptionKind.DIVISION_BY_ZERO, new ForeignCallDescriptor(&quot;createDivisionByZeroException&quot;, ArithmeticException.class));             runtimeCalls.put(BytecodeExceptionKind.INTEGER_EXACT_OVERFLOW, new ForeignCallDescriptor(&quot;createIntegerExactOverflowException&quot;, ArithmeticException.class));             runtimeCalls.put(BytecodeExceptionKind.LONG_EXACT_OVERFLOW, new ForeignCallDescriptor(&quot;createLongExactOverflowException&quot;, ArithmeticException.class));         }     }      private void throwCachedException(BytecodeExceptionNode node) {         if (IS_IN_NATIVE_IMAGE) {             throw new InternalError(&quot;Can't throw exception from SVM object&quot;);         }         Throwable exception = Exceptions.cachedExceptions.get(node.getExceptionKind());         assert exception != null;          StructuredGraph graph = node.graph();         FloatingNode exceptionNode = ConstantNode.forConstant(constantReflection.forObject(exception), metaAccess, graph);         graph.replaceFixedWithFloating(node, exceptionNode);     }      private void lowerBytecodeExceptionNode(BytecodeExceptionNode node) {         if (OmitHotExceptionStacktrace.getValue(node.getOptions())) {             throwCachedException(node);             return;         }          ForeignCallDescriptor descriptor = RuntimeCalls.runtimeCalls.get(node.getExceptionKind());         assert descriptor != null;          StructuredGraph graph = node.graph();         ForeignCallNode foreignCallNode = graph.add(new ForeignCallNode(foreignCalls, descriptor, node.stamp(NodeView.DEFAULT), node.getArguments()));         graph.replaceFixedWithFixed(node, foreignCallNode);     }      private boolean addReadBarrier(RawLoadNode load) {         if (runtime.getVMConfig().useG1GC &amp;&amp; load.graph().getGuardsStage() == StructuredGraph.GuardsStage.FIXED_DEOPTS &amp;&amp; load.object().getStackKind() == JavaKind.Object &amp;&amp;                         load.accessKind() == JavaKind.Object &amp;&amp; !StampTool.isPointerAlwaysNull(load.object())) {             ResolvedJavaType type = StampTool.typeOrNull(load.object());             if (type != null &amp;&amp; !type.isArray()) {                 return true;             }         }         return false;     }      private ReadNode createReadVirtualMethod(StructuredGraph graph, ValueNode hub, HotSpotResolvedJavaMethod method, ResolvedJavaType receiverType) {         return createReadVirtualMethod(graph, hub, method.vtableEntryOffset(receiverType));     }      private ReadNode createReadVirtualMethod(StructuredGraph graph, ValueNode hub, int vtableEntryOffset) {         assert vtableEntryOffset &gt; 0;         // We use LocationNode.ANY_LOCATION for the reads that access the vtable         // entry as HotSpot does not guarantee that this is a final value.         Stamp methodStamp = MethodPointerStamp.methodNonNull();         AddressNode address = createOffsetAddress(graph, hub, vtableEntryOffset);         ReadNode metaspaceMethod = graph.add(new ReadNode(address, any(), methodStamp, BarrierType.NONE));         return metaspaceMethod;     }      @Override     protected ValueNode createReadHub(StructuredGraph graph, ValueNode object, LoweringTool tool) {         if (tool.getLoweringStage() != LoweringTool.StandardLoweringStage.LOW_TIER) {             return graph.unique(new LoadHubNode(tool.getStampProvider(), object));         }         assert !object.isConstant() || object.isNullConstant();          KlassPointerStamp hubStamp = KlassPointerStamp.klassNonNull();         if (runtime.getVMConfig().useCompressedClassPointers) {             hubStamp = hubStamp.compressed(runtime.getVMConfig().getKlassEncoding());         }          AddressNode address = createOffsetAddress(graph, object, runtime.getVMConfig().hubOffset);         LocationIdentity hubLocation = runtime.getVMConfig().useCompressedClassPointers ? COMPRESSED_HUB_LOCATION : HUB_LOCATION;         FloatingReadNode memoryRead = graph.unique(new FloatingReadNode(address, hubLocation, null, hubStamp, null, BarrierType.NONE));         if (runtime.getVMConfig().useCompressedClassPointers) {             return HotSpotCompressionNode.uncompress(memoryRead, runtime.getVMConfig().getKlassEncoding());         } else {             return memoryRead;         }     }      private WriteNode createWriteHub(StructuredGraph graph, ValueNode object, ValueNode value) {         assert !object.isConstant() || object.asConstant().isDefaultForKind();          ValueNode writeValue = value;         if (runtime.getVMConfig().useCompressedClassPointers) {             writeValue = HotSpotCompressionNode.compress(value, runtime.getVMConfig().getKlassEncoding());         }          AddressNode address = createOffsetAddress(graph, object, runtime.getVMConfig().hubOffset);         return graph.add(new WriteNode(address, HUB_WRITE_LOCATION, writeValue, BarrierType.NONE));     }      @Override     protected BarrierType fieldLoadBarrierType(ResolvedJavaField f) {         HotSpotResolvedJavaField loadField = (HotSpotResolvedJavaField) f;         BarrierType barrierType = BarrierType.NONE;         if (runtime.getVMConfig().useG1GC &amp;&amp; loadField.getJavaKind() == JavaKind.Object &amp;&amp; metaAccess.lookupJavaType(Reference.class).equals(loadField.getDeclaringClass()) &amp;&amp;                         loadField.getName().equals(&quot;referent&quot;)) {             barrierType = BarrierType.PRECISE;         }         return barrierType;     }      @Override     public int fieldOffset(ResolvedJavaField f) {         return f.getOffset();     }      @Override     public int arrayLengthOffset() {         return runtime.getVMConfig().arrayOopDescLengthOffset();     }      @Override     protected final JavaKind getStorageKind(ResolvedJavaField field) {         return field.getJavaKind();     }      @Override     public ObjectCloneSnippets.Templates getObjectCloneSnippets() {         return objectCloneSnippets;     }      @Override     public ForeignCallSnippets.Templates getForeignCallSnippets() {         return foreignCallSnippets;     } }</td>
    <td align="left">blob</td>
    <td align="left">long method, data class, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method,  data class</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12883</td>
    <td align="left">https://github.com/oracle/graal/blob/4deb681aaaa79c248115037fc8e399c9876619fd/compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/DefaultHotSpotLoweringProvider.java/#L184-L809</td>
    <td align="right">1</td>
    <td align="right">2049</td>
    <td align="right">12883</td>
  </tr>
  <tr valign="top">
    <td align="right">2081</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;the bad smells are&quot;: [&quot;Long Method&quot;, &quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MemoryConsumptionTestClient {     private static final Logger LOGGER = LoggerFactory.getLogger(MemoryConsumptionTestClient.class);      private static final String RESULTS_FILE_ARG = &quot;resultsFile&quot;;      private static final String JNDI_PROPERTIES_ARG = &quot;jndiProperties&quot;;     private static final String JNDI_CONNECTION_FACTORY_ARG = &quot;jndiConnectionFactory&quot;;     private static final String JNDI_DESTINATION_ARG = &quot;jndiDestination&quot;;      private static final String CONNECTIONS_ARG = &quot;connections&quot;;     private static final String SESSIONS_ARG = &quot;sessions&quot;;     private static final String PRODUCERS_ARG = &quot;producers&quot;;     private static final String MESSAGE_COUNT_ARG = &quot;messagecount&quot;;     private static final String MESSAGE_SIZE_ARG = &quot;size&quot;;     private static final String PERSISTENT_ARG = &quot;persistent&quot;;     private static final String TIMEOUT_ARG = &quot;timeout&quot;;     private static final String TRANSACTED_ARG = &quot;transacted&quot;;     private static final String JMX_HOST_ARG = &quot;jmxhost&quot;;     private static final String JMX_PORT_ARG = &quot;jmxport&quot;;     private static final String JMX_USER_ARG = &quot;jmxuser&quot;;     private static final String JMX_USER_PASSWORD_ARG = &quot;jmxpassword&quot;;      private static final String RESULTS_FILE_DEFAULT = &quot;results.csv&quot;;     private static final String JNDI_PROPERTIES_DEFAULT = &quot;stress-test-client-qpid-jms-client-0-x.properties&quot;;     private static final String JNDI_CONNECTION_FACTORY_DEFAULT = &quot;qpidConnectionFactory&quot;;     private static final String JNDI_DESTINATION_DEFAULT = &quot;stressTestQueue&quot;;     private static final String CONNECTIONS_DEFAULT = &quot;1&quot;;     private static final String SESSIONS_DEFAULT = &quot;1&quot;;     private static final String PRODUCERS_DEFAULT = &quot;1&quot;;     private static final String MESSAGE_COUNT_DEFAULT = &quot;1&quot;;     private static final String MESSAGE_SIZE_DEFAULT = &quot;256&quot;;     private static final String PERSISTENT_DEFAULT = &quot;false&quot;;     private static final String TIMEOUT_DEFAULT = &quot;1000&quot;;     private static final String TRANSACTED_DEFAULT = &quot;false&quot;;      private static final String JMX_HOST_DEFAULT = &quot;localhost&quot;;     private static final String JMX_PORT_DEFAULT = &quot;8999&quot;;     private static final String JMX_GARBAGE_COLLECTOR_MBEAN = &quot;gc&quot;;      public static void main(String[] args) throws Exception     {         Map options = new HashMap&lt;&gt;();         options.put(RESULTS_FILE_ARG, RESULTS_FILE_DEFAULT);         options.put(JNDI_PROPERTIES_ARG, JNDI_PROPERTIES_DEFAULT);         options.put(JNDI_CONNECTION_FACTORY_ARG, JNDI_CONNECTION_FACTORY_DEFAULT);         options.put(JNDI_DESTINATION_ARG, JNDI_DESTINATION_DEFAULT);         options.put(CONNECTIONS_ARG, CONNECTIONS_DEFAULT);         options.put(SESSIONS_ARG, SESSIONS_DEFAULT);         options.put(PRODUCERS_ARG, PRODUCERS_DEFAULT);         options.put(MESSAGE_COUNT_ARG, MESSAGE_COUNT_DEFAULT);         options.put(MESSAGE_SIZE_ARG, MESSAGE_SIZE_DEFAULT);         options.put(PERSISTENT_ARG, PERSISTENT_DEFAULT);         options.put(TIMEOUT_ARG, TIMEOUT_DEFAULT);         options.put(TRANSACTED_ARG, TRANSACTED_DEFAULT);         options.put(JMX_HOST_ARG, JMX_HOST_DEFAULT);         options.put(JMX_PORT_ARG, JMX_PORT_DEFAULT);         options.put(JMX_USER_ARG, &quot;&quot;);         options.put(JMX_USER_PASSWORD_ARG, &quot;&quot;);         options.put(JMX_GARBAGE_COLLECTOR_MBEAN, &quot;java.lang:type=GarbageCollector,name=ConcurrentMarkSweep&quot;);          if(args.length == 1 &amp;&amp;                 (args[0].equals(&quot;-h&quot;) || args[0].equals(&quot;--help&quot;) || args[0].equals(&quot;help&quot;)))         {             System.out.println(&quot;arg=value options: \n&quot; + options.keySet());             return;         }          parseArgumentsIntoConfig(options, args);          MemoryConsumptionTestClient testClient = new MemoryConsumptionTestClient();         testClient.runTest(options);     }      private static void parseArgumentsIntoConfig(Map initialValues, String[] args)     {         for(String arg: args)         {             int equalPos = arg.indexOf('=');             if(equalPos == -1)             {                 throw new IllegalArgumentException(&quot;arguments must have format =: &quot; + arg);             }              if(initialValues.put(arg.substring(0, equalPos), arg.substring(equalPos + 1)) == null)             {                 throw new IllegalArgumentException(&quot;not a valid configuration property: &quot; + arg);             }         }     }       private void runTest(Map options) throws Exception     {         String resultsFile = options.get(RESULTS_FILE_ARG);         String jndiProperties = options.get(JNDI_PROPERTIES_ARG);         String connectionFactoryString = options.get(JNDI_CONNECTION_FACTORY_ARG);         int numConnections = Integer.parseInt(options.get(CONNECTIONS_ARG));         int numSessions = Integer.parseInt(options.get(SESSIONS_ARG));         int numProducers = Integer.parseInt(options.get(PRODUCERS_ARG));         int numMessage = Integer.parseInt(options.get(MESSAGE_COUNT_ARG));         int messageSize = Integer.parseInt(options.get(MESSAGE_SIZE_ARG));         String queueString = options.get(JNDI_DESTINATION_ARG);         int deliveryMode = Boolean.valueOf(options.get(PERSISTENT_ARG)) ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT;         long receiveTimeout = Long.parseLong(options.get(TIMEOUT_ARG));         boolean transacted = Boolean.valueOf(options.get(TRANSACTED_ARG));          LOGGER.info(&quot;Using options: &quot; + options);           // Load JNDI properties         Context ctx = getInitialContext(jndiProperties);         final ConnectionFactory conFac = (ConnectionFactory) ctx.lookup(connectionFactoryString);          Destination destination = ensureQueueCreated(queueString, conFac);         Map&gt; connectionsAndSessions = openConnectionsAndSessions(numConnections, numSessions, transacted, conFac);         publish(numMessage, messageSize, numProducers, deliveryMode, destination, connectionsAndSessions);         MemoryStatistic memoryStatistics = collectMemoryStatistics(options);         generateCSV(memoryStatistics, numConnections, numSessions, transacted, numMessage, messageSize, numProducers, deliveryMode, resultsFile);         purgeQueue(conFac, queueString, receiveTimeout);         closeConnections(connectionsAndSessions.keySet());         System.exit(0);     }      private void generateCSV(MemoryStatistic memoryStatistics,                              int numConnections,                              int numSessions,                              boolean transacted,                              int numMessage,                              int messageSize,                              int numProducers,                              int deliveryMode,                              final String resultsFile) throws IOException     {         try (FileWriter writer = new FileWriter(resultsFile))         {             writer.write(memoryStatistics.getHeapUsage()                          + &quot;,&quot;                          + memoryStatistics.getDirectMemoryUsage()                          + &quot;,&quot;                          + numConnections                          + &quot;,&quot;                          + numSessions                          + &quot;,&quot;                          + numProducers                          + &quot;,&quot;                          + transacted                          + &quot;,&quot;                          + numMessage                          + &quot;,&quot;                          + messageSize                          + &quot;,&quot;                          + deliveryMode                          + &quot;,&quot;                          + toUserFriendlyName(memoryStatistics.getHeapUsage())                          + &quot;,&quot;                          + toUserFriendlyName(memoryStatistics.getDirectMemoryUsage())                          + System.lineSeparator());         }     }      private void publish(int numberOfMessages, int messageSize, int numberOfProducers, int deliveryMode,                          Destination destination, Map&gt; connectionsAndSessions) throws JMSException     {         byte[] messageBytes = generateMessage(messageSize);         for (List sessions : connectionsAndSessions.values())         {             for (Session session: sessions)             {                 BytesMessage message = session.createBytesMessage();                  if (messageSize &gt; 0)                 {                     message.writeBytes(messageBytes);                 }                  for(int i = 0; i &lt; numberOfProducers ; i++)                 {                     MessageProducer prod = session.createProducer(destination);                     for(int j = 0; j &lt; numberOfMessages ; j++)                     {                         prod.send(message, deliveryMode, Message.DEFAULT_PRIORITY, Message.DEFAULT_TIME_TO_LIVE);                         if(session.getTransacted())                         {                             session.commit();                         }                     }                 }             }         }     }      private Map&gt; openConnectionsAndSessions(int numConnections, int numSessions, boolean transacted, ConnectionFactory conFac) throws JMSException     {         Map&gt; connectionAndSessions = new HashMap&lt;&gt;();         for (int i= 0; i &lt; numConnections ; i++)         {             Connection connection = conFac.createConnection();             connection.setExceptionListener(jmse -&gt; {                 LOGGER.error(&quot;The sample received an exception through the ExceptionListener&quot;, jmse);                 System.exit(1);             });              List sessions = new ArrayList&lt;&gt;();             connectionAndSessions.put(connection, sessions);             connection.start();             for (int s= 0; s &lt; numSessions ; s++)             {                 Session session = connection.createSession(transacted, transacted?Session.SESSION_TRANSACTED:Session.AUTO_ACKNOWLEDGE);                 sessions.add(session);             }         }         return connectionAndSessions;     }      private Context getInitialContext(final String jndiProperties) throws IOException, NamingException     {         Properties properties = new Properties();         try(InputStream is = this.getClass().getClassLoader().getResourceAsStream(jndiProperties))         {             if (is != null)             {                 properties.load(is);                 return new InitialContext(properties);             }         }          System.out.printf(MemoryConsumptionTestClient.class.getSimpleName() + &quot;: Failed to find '%s' on classpath, using fallback\n&quot;, jndiProperties);         return new InitialContext();     }      private Destination ensureQueueCreated(String queueURL, ConnectionFactory connectionFactory) throws JMSException     {         Connection connection = connectionFactory.createConnection();         Destination destination;         try         {             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);             destination = session.createQueue(queueURL);             MessageConsumer consumer = session.createConsumer(destination);             consumer.close();             session.close();         }         finally         {             connection.close();         }         return destination;     }      private void closeConnections(Collection connections) throws JMSException, NamingException     {         for (Connection c: connections)         {             c.close();         }     }      private void purgeQueue(ConnectionFactory connectionFactory, String queueString, long receiveTimeout) throws JMSException     {         LOGGER.debug(&quot;Consuming left over messages, using receive timeout:&quot; + receiveTimeout);          Connection connection = connectionFactory.createConnection();         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);         Destination destination = session.createQueue(queueString);         MessageConsumer consumer = session.createConsumer(destination);         connection.start();          int count = 0;         while (true)         {             BytesMessage msg = (BytesMessage) consumer.receive(receiveTimeout);              if(msg == null)             {                 LOGGER.debug(&quot;Received {} message(s)&quot;, count);                 break;             }             else             {                 count++;             }         }          consumer.close();         session.close();         connection.close();     }      private MemoryStatistic collectMemoryStatistics(Map options) throws Exception     {         String host = options.get(JMX_HOST_ARG);         String port = options.get(JMX_PORT_ARG);         String user = options.get(JMX_USER_ARG);         String password = options.get(JMX_USER_PASSWORD_ARG);          if (!&quot;&quot;.equals(host) &amp;&amp; !&quot;&quot;.equals(port) &amp;&amp; !&quot;&quot;.equals(user) &amp;&amp; !&quot;&quot;.equals(password))         {             Map environment = Collections.singletonMap(JMXConnector.CREDENTIALS, new String[]{user, password});              try(JMXConnector jmxConnector = JMXConnectorFactory.newJMXConnector(new JMXServiceURL(&quot;rmi&quot;, &quot;&quot;, 0, &quot;/jndi/rmi://&quot; + host + &quot;:&quot; + port + &quot;/jmxrmi&quot;), environment))             {                 jmxConnector.connect();                 final MBeanServerConnection mBeanServerConnection = jmxConnector.getMBeanServerConnection();                 final ObjectName memoryMBean = new ObjectName(&quot;java.lang:type=Memory&quot;);                 String gcCollectorMBeanName = options.get(JMX_GARBAGE_COLLECTOR_MBEAN);                 if (gcCollectorMBeanName.equals(&quot;&quot;))                 {                     mBeanServerConnection.invoke(memoryMBean, &quot;gc&quot;, null, null);                     MemoryStatistic memoryStatistics = new MemoryStatistic();                     collectMemoryStatistics(memoryStatistics, mBeanServerConnection, memoryMBean);                     return memoryStatistics;                 }                 else                 {                     ObjectName gcMBean = new ObjectName(gcCollectorMBeanName);                     if (mBeanServerConnection.isRegistered(gcMBean))                     {                         return collectMemoryStatisticsAfterGCNotification(mBeanServerConnection, gcMBean);                     }                     else                     {                         Set existingGCs = mBeanServerConnection.queryNames(new ObjectName(&quot;java.lang:type=GarbageCollector,name=*&quot;), null);                         throw new IllegalArgumentException(&quot;MBean '&quot; +gcCollectorMBeanName + &quot;' does not exists! Registered GC MBeans :&quot; + existingGCs);                     }                 }             }         }         return null;     }      private MemoryStatistic collectMemoryStatisticsAfterGCNotification(final MBeanServerConnection mBeanServerConnection, ObjectName gcMBean)             throws MalformedObjectNameException, IOException, InstanceNotFoundException, ReflectionException, MBeanException, InterruptedException     {         final MemoryStatistic memoryStatistics = new MemoryStatistic();         final CountDownLatch notificationReceived = new CountDownLatch(1);         final ObjectName memoryMBean = new ObjectName(&quot;java.lang:type=Memory&quot;);         mBeanServerConnection.addNotificationListener(gcMBean, (notification, handback) -&gt; {             if (notification.getType().equals(&quot;com.sun.management.gc.notification&quot;))             {                 CompositeData userData = (CompositeData) notification.getUserData();                 try                 {                     Object gcAction = userData.get(&quot;gcAction&quot;);                     Object gcCause = userData.get(&quot;gcCause&quot;);                     if (&quot;System.gc()&quot;.equals(gcCause) &amp;&amp; String.valueOf(gcAction).contains(&quot;end of major GC&quot;))                     {                         try                         {                             collectMemoryStatistics(memoryStatistics, mBeanServerConnection, memoryMBean);                         }                         finally                         {                             notificationReceived.countDown();                         }                      }                 }                 catch (Exception e)                 {                     e.printStackTrace();                     notificationReceived.countDown();                 }             }         }, null, null);          mBeanServerConnection.invoke(memoryMBean, &quot;gc&quot;, null, null);         if (!notificationReceived.await(5, TimeUnit.SECONDS))         {             throw new RuntimeException(&quot;GC notification was not sent in timely manner&quot;);         }         return memoryStatistics;     }      private void collectMemoryStatistics(MemoryStatistic memoryStatistics, MBeanServerConnection mBeanServerConnection, ObjectName memoryMBean) throws MBeanException, AttributeNotFoundException, InstanceNotFoundException, ReflectionException, IOException, MalformedObjectNameException     {         Object heapMemoryUsage = mBeanServerConnection.getAttribute(memoryMBean, &quot;HeapMemoryUsage&quot;);         Object used = ((CompositeData) heapMemoryUsage).get(&quot;used&quot;);         Object directMemoryTotalCapacity = mBeanServerConnection.getAttribute(new ObjectName(&quot;java.nio:type=BufferPool,name=direct&quot;), &quot;TotalCapacity&quot;);         memoryStatistics.setHeapUsage(Long.parseLong(String.valueOf(used)));         memoryStatistics.setDirectMemoryUsage(Long.parseLong(String.valueOf(directMemoryTotalCapacity)));     }      private String toUserFriendlyName(Object intValue)     {         long value = Long.parseLong(String.valueOf(intValue));         if (value &lt;= 1024)         {             return String.valueOf(value) + &quot;B&quot;;         }         else if (value &lt;= 1024 * 1024)         {             return String.valueOf(value/1024) + &quot;kB&quot;;         }         else if (value &lt;= 1024L * 1024L * 1024L)         {             return String.valueOf(value/1024L/1024L) + &quot;MB&quot;;         }         else         {             return String.valueOf(value/1024L/1024L/1024L) + &quot;GB&quot;;         }     }       private byte[] generateMessage(int messageSize)     {         byte[] sentBytes = new byte[messageSize];         for(int r = 0 ; r &lt; messageSize ; r++)         {             sentBytes[r] = (byte) (48 + (r % 10));         }         return sentBytes;     }      private class MemoryStatistic     {         private long heapUsage;         private long directMemoryUsage;          long getHeapUsage()         {             return heapUsage;         }          void setHeapUsage(long heapUsage)         {             this.heapUsage = heapUsage;         }          long getDirectMemoryUsage()         {             return directMemoryUsage;         }          void setDirectMemoryUsage(long directMemoryUsage)         {             this.directMemoryUsage = directMemoryUsage;         }     } }</td>
    <td align="left">blob</td>
    <td align="left">long method, blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method,  data class</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13072</td>
    <td align="left">https://github.com/apache/qpid-broker-j/blob/4c4400b98a5a8493cfb9e5dbb21c97175f433a62/tools/src/main/java/org/apache/qpid/tools/MemoryConsumptionTestClient.java/#L66-L506</td>
    <td align="right">1</td>
    <td align="right">2081</td>
    <td align="right">13072</td>
  </tr>
  <tr valign="top">
    <td align="right">2106</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Blob&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MavenWrapperDownloader {      /**      * Default URL to download the maven-wrapper.jar from, if no 'downloadUrl' is provided.      */     private static final String DEFAULT_DOWNLOAD_URL =             &quot;https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.4.2/maven-wrapper-0.4.2.jar&quot;;      /**      * Path to the maven-wrapper.properties file, which might contain a downloadUrl property to      * use instead of the default one.      */     private static final String MAVEN_WRAPPER_PROPERTIES_PATH =             &quot;.mvn/wrapper/maven-wrapper.properties&quot;;      /**      * Path where the maven-wrapper.jar will be saved to.      */     private static final String MAVEN_WRAPPER_JAR_PATH =             &quot;.mvn/wrapper/maven-wrapper.jar&quot;;      /**      * Name of the property which should be used to override the default download url for the wrapper.      */     private static final String PROPERTY_NAME_WRAPPER_URL = &quot;wrapperUrl&quot;;      public static void main(String args[]) {         System.out.println(&quot;- Downloader started&quot;);         File baseDirectory = new File(args[0]);         System.out.println(&quot;- Using base directory: &quot; + baseDirectory.getAbsolutePath());          // If the maven-wrapper.properties exists, read it and check if it contains a custom         // wrapperUrl parameter.         File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);         String url = DEFAULT_DOWNLOAD_URL;         if(mavenWrapperPropertyFile.exists()) {             FileInputStream mavenWrapperPropertyFileInputStream = null;             try {                 mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);                 Properties mavenWrapperProperties = new Properties();                 mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);                 url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);             } catch (IOException e) {                 System.out.println(&quot;- ERROR loading '&quot; + MAVEN_WRAPPER_PROPERTIES_PATH + &quot;'&quot;);             } finally {                 try {                     if(mavenWrapperPropertyFileInputStream != null) {                         mavenWrapperPropertyFileInputStream.close();                     }                 } catch (IOException e) {                     // Ignore ...                 }             }         }         System.out.println(&quot;- Downloading from: : &quot; + url);          File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);         if(!outputFile.getParentFile().exists()) {             if(!outputFile.getParentFile().mkdirs()) {                 System.out.println(                         &quot;- ERROR creating output direcrory '&quot; + outputFile.getParentFile().getAbsolutePath() + &quot;'&quot;);             }         }         System.out.println(&quot;- Downloading to: &quot; + outputFile.getAbsolutePath());         try {             downloadFileFromURL(url, outputFile);             System.out.println(&quot;Done&quot;);             System.exit(0);         } catch (Throwable e) {             System.out.println(&quot;- Error downloading&quot;);             e.printStackTrace();             System.exit(1);         }     }      private static void downloadFileFromURL(String urlString, File destination) throws Exception {         URL website = new URL(urlString);         ReadableByteChannel rbc;         rbc = Channels.newChannel(website.openStream());         FileOutputStream fos = new FileOutputStream(destination);         fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);         fos.close();         rbc.close();     }  }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13171</td>
    <td align="left">https://github.com/alibaba/java-dns-cache-manipulator/blob/eab50ee5c27671f9159b55458301f9429b2fcc47/.mvn/wrapper/MavenWrapperDownloader.java/#L25-L110</td>
    <td align="right">1</td>
    <td align="right">2106</td>
    <td align="right">13171</td>
  </tr>
  <tr valign="top">
    <td align="right">2119</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;the bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Feature Envy&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class RemoteInterpreterEventServer implements RemoteInterpreterEventService.Iface {    private static final Logger LOGGER = LoggerFactory.getLogger(RemoteInterpreterEventServer.class);    private String portRange;   private int port;   private String host;   private TThreadPoolServer thriftServer;   private InterpreterSettingManager interpreterSettingManager;    private final ScheduledExecutorService appendService =       Executors.newSingleThreadScheduledExecutor();   private ScheduledFuture appendFuture;   private AppendOutputRunner runner;   private final RemoteInterpreterProcessListener listener;   private final ApplicationEventListener appListener;   private final Gson gson = new Gson();    public RemoteInterpreterEventServer(ZeppelinConfiguration zConf,                                       InterpreterSettingManager interpreterSettingManager) {     this.portRange = zConf.getZeppelinServerRPCPortRange();     this.interpreterSettingManager = interpreterSettingManager;     this.listener = interpreterSettingManager.getRemoteInterpreterProcessListener();     this.appListener = interpreterSettingManager.getAppEventListener();   }    public void start() throws IOException {     Thread startingThread = new Thread() {       @Override       public void run() {         TServerSocket tSocket = null;         try {           tSocket = RemoteInterpreterUtils.createTServerSocket(portRange);           port = tSocket.getServerSocket().getLocalPort();           host = RemoteInterpreterUtils.findAvailableHostAddress();         } catch (IOException e1) {           throw new RuntimeException(e1);         }          LOGGER.info(&quot;InterpreterEventServer is starting at {}:{}&quot;, host, port);         RemoteInterpreterEventService.Processor processor =             new RemoteInterpreterEventService.Processor(RemoteInterpreterEventServer.this);         thriftServer = new TThreadPoolServer(             new TThreadPoolServer.Args(tSocket).processor(processor));         thriftServer.serve();       }     };     startingThread.start();     long start = System.currentTimeMillis();     while ((System.currentTimeMillis() - start) &lt; 30 * 1000) {       if (thriftServer != null &amp;&amp; thriftServer.isServing()) {         break;       }       try {         Thread.sleep(500);       } catch (InterruptedException e) {         throw new IOException(e);       }     }      if (thriftServer != null &amp;&amp; !thriftServer.isServing()) {       throw new IOException(&quot;Fail to start InterpreterEventServer in 30 seconds.&quot;);     }     LOGGER.info(&quot;RemoteInterpreterEventServer is started&quot;);      runner = new AppendOutputRunner(listener);     appendFuture = appendService.scheduleWithFixedDelay(         runner, 0, AppendOutputRunner.BUFFER_TIME_MS, TimeUnit.MILLISECONDS);   }    public void stop() {     if (thriftServer != null) {       thriftServer.stop();     }     if (appendFuture != null) {       appendFuture.cancel(true);     }     LOGGER.info(&quot;RemoteInterpreterEventServer is stopped&quot;);   }     public int getPort() {     return port;   }    public String getHost() {     return host;   }    @Override   public void registerInterpreterProcess(RegisterInfo registerInfo) throws TException {     InterpreterGroup interpreterGroup =         interpreterSettingManager.getInterpreterGroupById(registerInfo.getInterpreterGroupId());     if (interpreterGroup == null) {       LOGGER.warn(&quot;No such interpreterGroup: &quot; + registerInfo.getInterpreterGroupId());       return;     }     RemoteInterpreterProcess interpreterProcess =         ((ManagedInterpreterGroup) interpreterGroup).getInterpreterProcess();     if (interpreterProcess == null) {       LOGGER.warn(&quot;Interpreter process does not existed yet for InterpreterGroup: &quot; +           registerInfo.getInterpreterGroupId());     }      interpreterProcess.processStarted(registerInfo.port, registerInfo.host);   }    @Override   public void appendOutput(OutputAppendEvent event) throws TException {     if (event.getAppId() == null) {       runner.appendBuffer(           event.getNoteId(), event.getParagraphId(), event.getIndex(), event.getData());     } else {       appListener.onOutputAppend(event.getNoteId(), event.getParagraphId(), event.getIndex(),           event.getAppId(), event.getData());     }   }    @Override   public void updateOutput(OutputUpdateEvent event) throws TException {     if (event.getAppId() == null) {       listener.onOutputUpdated(event.getNoteId(), event.getParagraphId(), event.getIndex(),           InterpreterResult.Type.valueOf(event.getType()), event.getData());     } else {       appListener.onOutputUpdated(event.getNoteId(), event.getParagraphId(), event.getIndex(),           event.getAppId(), InterpreterResult.Type.valueOf(event.getType()), event.getData());     }   }    @Override   public void updateAllOutput(OutputUpdateAllEvent event) throws TException {     listener.onOutputClear(event.getNoteId(), event.getParagraphId());     for (int i = 0; i &lt; event.getMsg().size(); i++) {       RemoteInterpreterResultMessage msg = event.getMsg().get(i);       listener.onOutputUpdated(event.getNoteId(), event.getParagraphId(), i,           InterpreterResult.Type.valueOf(msg.getType()), msg.getData());     }   }    @Override   public void appendAppOutput(AppOutputAppendEvent event) throws TException {     appListener.onOutputAppend(event.noteId, event.paragraphId, event.index, event.appId,         event.data);   }    @Override   public void updateAppOutput(AppOutputUpdateEvent event) throws TException {     appListener.onOutputUpdated(event.noteId, event.paragraphId, event.index, event.appId,         InterpreterResult.Type.valueOf(event.type), event.data);   }    @Override   public void updateAppStatus(AppStatusUpdateEvent event) throws TException {     appListener.onStatusChange(event.noteId, event.paragraphId, event.appId, event.status);   }    @Override   public void runParagraphs(RunParagraphsEvent event) throws TException {     try {       listener.runParagraphs(event.getNoteId(), event.getParagraphIndices(),           event.getParagraphIds(), event.getCurParagraphId());       if (InterpreterContext.get() != null) {         LOGGER.info(&quot;complete runParagraphs.&quot; + InterpreterContext.get().getParagraphId() + &quot; &quot;           + event);       } else {         LOGGER.info(&quot;complete runParagraphs.&quot; + event);       }     } catch (IOException e) {       throw new TException(e);     }   }    @Override   public void addAngularObject(String intpGroupId, String json) throws TException {     LOGGER.debug(&quot;Add AngularObject, interpreterGroupId: &quot; + intpGroupId + &quot;, json: &quot; + json);     AngularObject angularObject = AngularObject.fromJson(json);     InterpreterGroup interpreterGroup =         interpreterSettingManager.getInterpreterGroupById(intpGroupId);     if (interpreterGroup == null) {       throw new TException(&quot;Invalid InterpreterGroupId: &quot; + intpGroupId);     }     interpreterGroup.getAngularObjectRegistry().add(angularObject.getName(),         angularObject.get(), angularObject.getNoteId(), angularObject.getParagraphId());   }    @Override   public void updateAngularObject(String intpGroupId, String json) throws TException {     AngularObject angularObject = AngularObject.fromJson(json);     InterpreterGroup interpreterGroup =         interpreterSettingManager.getInterpreterGroupById(intpGroupId);     if (interpreterGroup == null) {       throw new TException(&quot;Invalid InterpreterGroupId: &quot; + intpGroupId);     }     AngularObject localAngularObject = interpreterGroup.getAngularObjectRegistry().get(         angularObject.getName(), angularObject.getNoteId(), angularObject.getParagraphId());     if (localAngularObject instanceof RemoteAngularObject) {       // to avoid ping-pong loop       ((RemoteAngularObject) localAngularObject).set(           angularObject.get(), true, false);     } else {       localAngularObject.set(angularObject.get());     }   }    @Override   public void removeAngularObject(String intpGroupId,                                   String noteId,                                   String paragraphId,                                   String name) throws TException {     InterpreterGroup interpreterGroup =         interpreterSettingManager.getInterpreterGroupById(intpGroupId);     if (interpreterGroup == null) {       throw new TException(&quot;Invalid InterpreterGroupId: &quot; + intpGroupId);     }     interpreterGroup.getAngularObjectRegistry().remove(name, noteId, paragraphId);   }    @Override   public void sendParagraphInfo(String intpGroupId, String json) throws TException {     InterpreterGroup interpreterGroup =         interpreterSettingManager.getInterpreterGroupById(intpGroupId);     if (interpreterGroup == null) {       throw new TException(&quot;Invalid InterpreterGroupId: &quot; + intpGroupId);     }      Map paraInfos = gson.fromJson(json,         new TypeToken&gt;() {         }.getType());     String noteId = paraInfos.get(&quot;noteId&quot;);     String paraId = paraInfos.get(&quot;paraId&quot;);     String settingId = RemoteInterpreterUtils.         getInterpreterSettingId(interpreterGroup.getId());     if (noteId != null &amp;&amp; paraId != null &amp;&amp; settingId != null) {       listener.onParaInfosReceived(noteId, paraId, settingId, paraInfos);     }   }    @Override   public List getAllResources(String intpGroupId) throws TException {     ResourceSet resourceSet = getAllResourcePoolExcept(intpGroupId);     List resourceList = new LinkedList&lt;&gt;();     for (Resource r : resourceSet) {       resourceList.add(r.toJson());     }     return resourceList;   }    @Override   public ByteBuffer getResource(String resourceIdJson) throws TException {     ResourceId resourceId = ResourceId.fromJson(resourceIdJson);     Object o = getResource(resourceId);     ByteBuffer obj;     if (o == null) {       obj = ByteBuffer.allocate(0);     } else {       try {         obj = Resource.serializeObject(o);       } catch (IOException e) {         throw new TException(e);       }     }     return obj;   }    /**    *    * @param intpGroupId caller interpreter group id    * @param invokeMethodJson invoke information    * @return    * @throws TException    */   @Override   public ByteBuffer invokeMethod(String intpGroupId, String invokeMethodJson) throws TException {     InvokeResourceMethodEventMessage invokeMethodMessage =         InvokeResourceMethodEventMessage.fromJson(invokeMethodJson);     Object ret = invokeResourceMethod(intpGroupId, invokeMethodMessage);     ByteBuffer obj = null;     if (ret == null) {       obj = ByteBuffer.allocate(0);     } else {       try {         obj = Resource.serializeObject(ret);       } catch (IOException e) {         LOGGER.error(&quot;invokeMethod failed&quot;, e);       }     }     return obj;   }    @Override   public List getParagraphList(String user, String noteId)       throws TException, ServiceException {     LOGGER.info(&quot;get paragraph list from remote interpreter noteId: &quot; + noteId         + &quot;, user = &quot; + user);      if (user != null &amp;&amp; noteId != null) {       List paragraphInfos = listener.getParagraphList(user, noteId);       return paragraphInfos;     } else {       LOGGER.error(&quot;user or noteId is null!&quot;);       return null;     }   }    private Object invokeResourceMethod(String intpGroupId,                                       final InvokeResourceMethodEventMessage message) {     final ResourceId resourceId = message.resourceId;     ManagedInterpreterGroup intpGroup =         interpreterSettingManager.getInterpreterGroupById(resourceId.getResourcePoolId());     if (intpGroup == null) {       return null;     }      RemoteInterpreterProcess remoteInterpreterProcess = intpGroup.getRemoteInterpreterProcess();     if (remoteInterpreterProcess == null) {       ResourcePool localPool = intpGroup.getResourcePool();       if (localPool != null) {         Resource res = localPool.get(resourceId.getName());         if (res != null) {           try {             return res.invokeMethod(                 message.methodName,                 message.getParamTypes(),                 message.params,                 message.returnResourceName);           } catch (Exception e) {             LOGGER.error(e.getMessage(), e);             return null;           }         } else {           // object is null. can't invoke any method           LOGGER.error(&quot;Can't invoke method {} on null object&quot;, message.methodName);           return null;         }       } else {         LOGGER.error(&quot;no resource pool&quot;);         return null;       }     } else if (remoteInterpreterProcess.isRunning()) {       ByteBuffer res = remoteInterpreterProcess.callRemoteFunction(           new RemoteInterpreterProcess.RemoteFunction() {             @Override             public ByteBuffer call(RemoteInterpreterService.Client client) throws Exception {               return client.resourceInvokeMethod(                   resourceId.getNoteId(),                   resourceId.getParagraphId(),                   resourceId.getName(),                   message.toJson());             }           }       );        try {         return Resource.deserializeObject(res);       } catch (Exception e) {         LOGGER.error(e.getMessage(), e);       }       return null;     }     return null;   }    private Object getResource(final ResourceId resourceId) {     ManagedInterpreterGroup intpGroup = interpreterSettingManager         .getInterpreterGroupById(resourceId.getResourcePoolId());     if (intpGroup == null) {       return null;     }     RemoteInterpreterProcess remoteInterpreterProcess = intpGroup.getRemoteInterpreterProcess();     ByteBuffer buffer = remoteInterpreterProcess.callRemoteFunction(         new RemoteInterpreterProcess.RemoteFunction() {           @Override           public ByteBuffer call(RemoteInterpreterService.Client client) throws Exception {             return  client.resourceGet(                 resourceId.getNoteId(),                 resourceId.getParagraphId(),                 resourceId.getName());           }         }     );      try {       Object o = Resource.deserializeObject(buffer);       return o;     } catch (Exception e) {       LOGGER.error(e.getMessage(), e);     }     return null;   }    private ResourceSet getAllResourcePoolExcept(String interpreterGroupId) {     ResourceSet resourceSet = new ResourceSet();     for (ManagedInterpreterGroup intpGroup : interpreterSettingManager.getAllInterpreterGroup()) {       if (intpGroup.getId().equals(interpreterGroupId)) {         continue;       }        RemoteInterpreterProcess remoteInterpreterProcess = intpGroup.getRemoteInterpreterProcess();       if (remoteInterpreterProcess == null) {         ResourcePool localPool = intpGroup.getResourcePool();         if (localPool != null) {           resourceSet.addAll(localPool.getAll());         }       } else if (remoteInterpreterProcess.isRunning()) {         List resourceList = remoteInterpreterProcess.callRemoteFunction(             new RemoteInterpreterProcess.RemoteFunction&gt;() {               @Override               public List call(RemoteInterpreterService.Client client) throws Exception {                 return client.resourcePoolGetAll();               }             }         );         for (String res : resourceList) {           resourceSet.add(RemoteResource.fromJson(res));         }       }     }     return resourceSet;   } }</td>
    <td align="left">blob</td>
    <td align="left">blob, data class, feature envy, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;data class,  feature envy,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13201</td>
    <td align="left">https://github.com/apache/zeppelin/blob/4219d552349f8f7f3e6de34505b8a8ae9835f98b/zeppelin-zengine/src/main/java/org/apache/zeppelin/interpreter/RemoteInterpreterEventServer.java/#L66-L485</td>
    <td align="right">1</td>
    <td align="right">2119</td>
    <td align="right">13201</td>
  </tr>
  <tr valign="top">
    <td align="right">2211</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Parser {      public static GetOrderReferenceDetailsResponseData getOrderReferenceDetails(ResponseData rawResponse) throws AmazonServiceException {         final GetOrderReferenceDetailsResponse response = marshalXML(GetOrderReferenceDetailsResponse.class, rawResponse);         return new GetOrderReferenceDetailsResponseData(response, rawResponse);     }       public static SetOrderReferenceDetailsResponseData setOrderReferenceDetails(ResponseData rawResponse) throws AmazonServiceException {         final SetOrderReferenceDetailsResponse response = marshalXML(SetOrderReferenceDetailsResponse.class, rawResponse);         return new SetOrderReferenceDetailsResponseData(response, rawResponse);     }       public static AuthorizeResponseData getAuthorizeData(ResponseData rawResponse) throws AmazonServiceException {         final AuthorizeResponse response = marshalXML(AuthorizeResponse.class, rawResponse);         return new AuthorizeResponseData(response, rawResponse);     }      public static GetAuthorizationDetailsResponseData getAuthorizationDetailsData(ResponseData rawResponse) throws AmazonServiceException {         final GetAuthorizationDetailsResponse response = marshalXML(GetAuthorizationDetailsResponse.class, rawResponse);         return new GetAuthorizationDetailsResponseData(response, rawResponse);     }      public static CaptureResponseData getCapture(ResponseData rawResponse) throws AmazonServiceException {         final CaptureResponse response = marshalXML(CaptureResponse.class, rawResponse);         return new CaptureResponseData(response, rawResponse);     }      public static GetCaptureDetailsResponseData getCaptureDetailsData(ResponseData rawResponse) throws AmazonServiceException {         final GetCaptureDetailsResponse response = marshalXML(GetCaptureDetailsResponse.class, rawResponse);         return new GetCaptureDetailsResponseData(response, rawResponse);     }      public static ConfirmOrderReferenceResponseData confirmOrderReference(ResponseData rawResponse) throws AmazonServiceException {         final ConfirmOrderReferenceResponse response = marshalXML(ConfirmOrderReferenceResponse.class, rawResponse);         return new ConfirmOrderReferenceResponseData(response, rawResponse);     }      public static CloseAuthorizationResponseData closeAuthorizationResponse(ResponseData rawResponse) throws AmazonServiceException {         final CloseAuthorizationResponse response = marshalXML(CloseAuthorizationResponse.class, rawResponse);         return new CloseAuthorizationResponseData(response, rawResponse);     }      public static CancelOrderReferenceResponseData getCancelOrderReference(ResponseData rawResponse) throws AmazonServiceException {         final CancelOrderReferenceResponse response = marshalXML(CancelOrderReferenceResponse.class, rawResponse);         return new CancelOrderReferenceResponseData(response, rawResponse);     }      public static CloseOrderReferenceResponseData getCloseOrderReference(ResponseData rawResponse) throws AmazonServiceException {         final CloseOrderReferenceResponse response = marshalXML(CloseOrderReferenceResponse.class, rawResponse);         return new CloseOrderReferenceResponseData(response, rawResponse);     }      public static RefundResponseData getRefundData(ResponseData rawResponse) throws AmazonServiceException {         final RefundResponse response = marshalXML(RefundResponse.class, rawResponse);         return new RefundResponseData(response, rawResponse);     }      public static GetRefundDetailsResponseData getRefundDetailsData(ResponseData rawResponse) throws AmazonServiceException {         final GetRefundDetailsResponse response = marshalXML(GetRefundDetailsResponse.class, rawResponse);         return new GetRefundDetailsResponseData(response, rawResponse);     }      public static GetBillingAgreementDetailsResponseData getBillingAgreementDetailsData(ResponseData rawResponse) throws AmazonServiceException {         final GetBillingAgreementDetailsResponse response = marshalXML(GetBillingAgreementDetailsResponse.class, rawResponse);         return new GetBillingAgreementDetailsResponseData(response, rawResponse);     }      public static SetBillingAgreementDetailsResponseData getSetBillingAgreementDetailsResponse(ResponseData rawResponse) throws AmazonServiceException {         final SetBillingAgreementDetailsResponse response = marshalXML(SetBillingAgreementDetailsResponse.class, rawResponse);         return new SetBillingAgreementDetailsResponseData(response, rawResponse);     }      public static ValidateBillingAgreementResponseData getValidateBillingAgreementResponse(ResponseData rawResponse) throws AmazonServiceException {         final ValidateBillingAgreementResponse response = marshalXML(ValidateBillingAgreementResponse.class, rawResponse);         return new ValidateBillingAgreementResponseData(response, rawResponse);     }      public static ConfirmBillingAgreementResponseData confirmBillingAgreementResponse(ResponseData rawResponse) throws AmazonServiceException {         final ConfirmBillingAgreementResponse response = marshalXML(ConfirmBillingAgreementResponse.class, rawResponse);         return new ConfirmBillingAgreementResponseData(response, rawResponse);     }      public static AuthorizeOnBillingAgreementResponseData getAuthorizeOnBillingAgreement(ResponseData rawResponse) throws AmazonServiceException {         final AuthorizeOnBillingAgreementResponse response = marshalXML(AuthorizeOnBillingAgreementResponse.class, rawResponse);         return new AuthorizeOnBillingAgreementResponseData(response, rawResponse);     }      public static CloseBillingAgreementResponseData closeBillingAgreementResponse(ResponseData rawResponse) throws AmazonServiceException {         final CloseBillingAgreementResponse response = marshalXML(CloseBillingAgreementResponse.class, rawResponse);         return new CloseBillingAgreementResponseData(response, rawResponse);     }      public static GetProviderCreditDetailsResponseData getGetProviderCreditDetails(ResponseData rawResponse) throws AmazonServiceException {         final GetProviderCreditDetailsResponse response = marshalXML(GetProviderCreditDetailsResponse.class, rawResponse);         return new GetProviderCreditDetailsResponseData(response, rawResponse);     }      public static GetProviderCreditReversalDetailsResponseData getProviderCreditReversalDetails(ResponseData rawResponse) throws AmazonServiceException {         final GetProviderCreditReversalDetailsResponse response = marshalXML(GetProviderCreditReversalDetailsResponse.class, rawResponse);         return new GetProviderCreditReversalDetailsResponseData(response, rawResponse);     }      public static ReverseProviderCreditResponseData getReverseProviderCreditResponseData(ResponseData rawResponse) throws AmazonServiceException {         final ReverseProviderCreditResponse response = marshalXML(ReverseProviderCreditResponse.class, rawResponse);         return new ReverseProviderCreditResponseData(response, rawResponse);     }      public static GetServiceStatusResponseData getServiceStatus(                 ResponseData rawResponse) throws AmazonServiceException {         final GetServiceStatusResponse response = marshalXML(                 GetServiceStatusResponse.class, rawResponse);         return new GetServiceStatusResponseData(response, rawResponse);     }      public static CreateOrderReferenceForIdResponseData createOrderReferenceForId(                 ResponseData rawResponse) throws AmazonServiceException {         final CreateOrderReferenceForIdResponse response = marshalXML(                 CreateOrderReferenceForIdResponse.class, rawResponse);         return new CreateOrderReferenceForIdResponseData(response, rawResponse);     }      public static ListOrderReferenceResponseData listOrderReference(ResponseData rawResponse) throws AmazonServiceException {         final ListOrderReferenceResponse response = marshalXML(ListOrderReferenceResponse.class, rawResponse);         return new ListOrderReferenceResponseData(response, rawResponse);     }      public static ListOrderReferenceByNextTokenResponseData listOrderReferenceByNextToken(ResponseData rawResponse) throws AmazonServiceException {         final ListOrderReferenceByNextTokenResponse response = marshalXML(ListOrderReferenceByNextTokenResponse.class, rawResponse);         return new ListOrderReferenceByNextTokenResponseData(response, rawResponse);     }      public static SetOrderAttributesResponseData setOrderAttributes(ResponseData rawResponse) throws AmazonServiceException {         final SetOrderAttributesResponse response = marshalXML(SetOrderAttributesResponse.class, rawResponse);         return new SetOrderAttributesResponseData(response, rawResponse);     }      public static GetMerchantAccountStatusResponseData getMerchantAccountStatus(ResponseData rawResponse) throws AmazonServiceException {         final GetMerchantAccountStatusResponse response = marshalXML(GetMerchantAccountStatusResponse.class, rawResponse);         return new GetMerchantAccountStatusResponseData(response, rawResponse);     }      public static  T marshalXML(Class clazz, ResponseData rawResponse) throws AmazonServiceException  {         try {             if (rawResponse.getStatusCode() == 200) {                 T responseObject = null;                 final JAXBContext context = JAXBContext.newInstance(clazz);                  // Ignore the namespace only for marshalling purpose                 final String noNamespaceXML = rawResponse.toXML().replaceAll(                         &quot;xmlns(?:.*?)?=\&quot;http://mws.amazonservices.com/schema/OffAmazonPayments/2013-01-01\&quot;&quot;, &quot;&quot;);                 final StringReader reader = new StringReader(noNamespaceXML);                 final Unmarshaller unmarshaller = context.createUnmarshaller();                  final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();                 xmlInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);                 xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);                 final XMLStreamReader xmlStreamReader = xmlInputFactory.createXMLStreamReader(reader);                 responseObject = (T) unmarshaller.unmarshal(xmlStreamReader);                  return responseObject;             } else {                 generateErrorException(rawResponse);             }         } catch (JAXBException e) {             throw new AmazonClientException(rawResponse, &quot;Encountered marshalling error while marshalling data &quot; + rawResponse.toXML(), e);         }         catch (XMLStreamException e) {             throw new AmazonClientException(rawResponse, &quot;Encountered marshalling error while marshalling data &quot; + rawResponse.toXML(), e);         }          return null;     }      public static void generateErrorException(ResponseData rawResponse) throws AmazonServiceException, JAXBException {         final JAXBContext context = JAXBContext.newInstance(ErrorResponse.class);          // Ignore the namespace only for marshalling purpose         final String noNamespaceXML = rawResponse.toXML().replaceAll(                 &quot;xmlns(?:.*?)?=\&quot;http://mws.amazonservices.com/schema/OffAmazonPayments/2013-01-01\&quot;&quot;, &quot;&quot;);         final StringReader reader = new StringReader(noNamespaceXML);         final Unmarshaller unmarshaller = context.createUnmarshaller();          final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();         xmlInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);         xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);         try {             final XMLStreamReader xmlStreamReader = xmlInputFactory.createXMLStreamReader(reader);             final ErrorResponse result = (ErrorResponse) unmarshaller.unmarshal(xmlStreamReader);             throw new AmazonServiceException(result, rawResponse);         } catch (XMLStreamException e) {             throw new AmazonClientException(rawResponse, &quot;Encountered marshalling error while marshalling data &quot; + rawResponse.toXML(), e);         }     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;data class</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13521</td>
    <td align="left">https://github.com/amzn/amazon-pay-sdk-java/blob/5a3547d00c796aab8f0c8ac12e0310f7a5c4678a/src/com/amazon/pay/response/parser/Parser.java/#L57-L252</td>
    <td align="right">1</td>
    <td align="right">2211</td>
    <td align="right">13521</td>
  </tr>
  <tr valign="top">
    <td align="right">2263</td>
    <td align="left">{&quot;answer&quot;: &quot;YES I found bad smells&quot;, &quot;the bad smells are: 1. Long Method, 2. Blob, 3. Data Class, 4. Feature Envy, 5. Long Method, 6. Long Method, 7. Long Method, 8. Long Method, 9. Long Method, 10. Long Method, 11. Long Method, 12. Long Method, 13. Long Method, 14. Long Method, 15. Long Method, 16. Long Method, 17. Long Method, 18. Long Method, 19. Long Method, 20. Long Method, 21. Long Method, 22. Long Method, 23. Long Method, 24. Long Method, 25. Long Method, 26. Long Method, 27. Long Method, 28. Long Method, 29. Long Method, 30. Long Method, 31. Long Method, 32. Long Method, 33. Long Method, 34. Long Method, 35. Long Method, 36. Long Method, 37. Long Method, 38. Long Method, 39. Long Method, 40. Long Method, 41. Long Method, 42. Long Method, 43. Long Method, 44. Long Method, 45. Long Method, 46. Long Method, 47. Long Method, 48. Long Method, 49. Long Method, 50. Long Method, 51. Long Method, 52. Long Method, 53. Long Method, 54. Long Method, 55. Long Method, 56. Long Method, 57. Long Method, 58. Long Method, 59. Long Method, 60. Long Method, 61. Long Method, 62. Long Method, 63. Long Method, 64. Long Method, 65. Long Method, 66. Long Method, 67. Long Method, 68. Long Method, 69. Long Method, 70. Long Method, 71. Long Method, 72. Long Method, 73. Long Method, 74. Long Method, 75. Long Method, 76. Long Method, 77. Long Method, 78. Long Method, 79. Long Method, 80. Long Method, 81. Long Method, 82. Long Method, 83. Long Method, 84. Long Method, 85. Long Method, 86. Long Method, 87. Long Method, 88. Long Method, 89. Long Method, 90. Long Method, 91. Long Method, 92. Long Method, 93. Long Method, 94. Long Method, 95. Long Method, 96. Long Method, 97. Long Method, 98. Long Method, 99. Long Method, 100. Long Method, 101. Long Method, 102. Long Method, 103. Long Method, 104. Long Method, 105. Long Method, 106. Long Method, 107. Long Method, 108. Long Method, 109. Long Method, 110. Long Method, 111. Long Method, 112. Long Method, 113. Long Method, 114. Long Method, 115. Long Method, 116. Long Method, 117. Long Method, 118. Long Method, 119. Long Method, 120. Long Method, 121. Long Method, 122. Long Method, 123. Long Method, 124. Long Method, 125. Long Method, 126. Long Method, 127. Long Method, 128. Long Method, 129. Long Method, 130. Long Method, 131. Long Method, 132. Long Method, 133. Long Method, 134. Long Method, 135. Long Method, 136. Long Method, 137. Long Method, 138. Long Method, 139. Long Method, 140. Long Method, 141. Long Method, 142. Long Method, 143. Long Method, 144. Long Method, 145. Long Method, 146. Long Method, 147. Long Method, 148. Long Method, 149. Long Method, 150. Long Method, 151. Long Method, 152. Long Method, 153. Long Method, 154. Long Method, 155. Long Method, 156. Long Method, 157. Long Method, 158. Long Method, 159. Long Method, 160. Long Method, 161. Long Method, 162. Long Method, 163. Long Method, 164. Long Method, 165. Long Method, 166. Long Method, 167. Long Method, 168. Long Method, 169. Long Method, 170. Long Method, 171. Long Method, 172. Long Method, 173. Long Method, 174. Long Method, 175. Long Method, 176. Long Method, 177. Long Method, 178. Long Method, 179. Long Method, 180. Long Method, 181. Long Method, 182. Long Method, 183. Long Method, 184. Long Method, 185. Long Method, 186. Long Method, 187. Long Method, 188. Long Method, 189. Long Method, 190. Long Method, 191. Long Method, 192. Long Method, 193. Long Method, 194. Long Method, 195. Long Method, 196. Long Method, 197. Long Method, 198. Long Method, 199. Long Method, 200. Long Method, 201. Long Method, 202. Long Method, 203. Long Method, 204. Long Method, 205. Long Method, 206. Long Method, 207. Long Method, 208. Long Method, 209. Long Method, 210. Long Method, 211. Long Method, 212. Long Method, 213. Long Method, 214. Long Method, 215. Long Method, 216. Long Method, 217. Long Method, 218. Long Method, 219. Long Method, 220. Long Method, 221. Long Method, 222. Long Method, 223. Long Method, 224. Long Method, 225. Long Method, 226. Long Method, 227. Long Method, 228. Long Method, 229. Long Method, 230. Long Method, 231. Long Method, 232. Long Method, 233. Long Method, 234. Long Method, 235. Long Method, 236. Long Method, 237. Long Method, 238. Long Method, 239. Long Method, 240. Long Method, 241. Long Method, 242. Long Method, 243. Long Method, 244. Long Method, 245. Long Method, 246. Long Method, 247. Long Method, 248. Long Method, 249. Long Method, 250. Long Method, 251. Long Method, 252. Long Method, 253. Long Method, 254. Long Method, 255. Long Method, 256. Long Method, 257. Long Method, 258. Long Method, 259. Long Method, 260. Long Method, 261. Long Method, 262. Long Method, 263. Long Method, 264. Long Method, 265. Long Method, 266. Long Method, 267. Long Method, 268. Long Method, 269. Long Method, 270. Long Method, 271. Long Method, 272. Long Method, 273. Long Method, 274. Long Method, 275. Long Method, 276. Long Method, 277. Long Method, 278. Long Method, 279. Long Method, 280. Long Method, 281. Long Method, 282. Long Method, 283. Long Method, 284. Long Method, 285. Long Method, 286. Long Method, 287. Long Method, 288. Long Method, 289. Long Method, 290. Long Method, 291. Long Method, 292. Long Method, 293. Long Method, 294. Long Method, 295. Long Method, 296. Long Method, 297. Long Method, 298. Long Method, 299. Long Method, 300. Long Method, 301. Long Method, 302. Long Method, 303. Long Method, 304. Long Method, 305. Long Method, 306. Long Method, 307. Long Method, 308. Long Method, 309. Long Method, 310. Long Method, 311. Long Method, 312. Long Method, 313. Long Method, 314. Long Method, 315. Long Method, 316. Long Method, 317. Long Method, 318. Long Method, 319. Long Method, 320. Long Method, 321. Long Method, 322. Long Method, 323. Long Method, 324. Long Method, 325. Long Method, 326. Long Method, 327. Long Method, 328. Long Method, 329. Long Method, 330. Long Method, 331. Long Method, 332. Long Method, 333. Long Method, 334. Long Method, 335. Long Method, 336. Long Method, 337. Long Method, 338. Long Method, 339. Long Method, 340. Long Method, 341. Long Method, 342. Long Method, 343. Long Method, 344. Long Method, 345. Long Method, 346. Long Method, 347. Long Method, 348. Long Method, 349. Long Method, 350. Long Method, 351. Long Method, 352. Long Method, 353. Long Method, 354. Long Method, 355. Long Method, 356. Long Method, 357. Long Method, 358. Long Method, 359. Long Method, 360. Long Method, 361. Long Method, 362. Long Method, 363. Long Method, 364. Long Method, 365. Long Method, 366. Long Method, 367. Long Method, 368. Long Method, 369. Long Method, 370. Long Method, 371. Long Method, 372. Long Method, 373. Long Method, 374. Long Method, 375. Long Method, 376. Long Method, 377. Long Method, 378. Long Method, 379. Long Method, 380. Long Method, 381. Long Method, 382. Long Method, 383. Long Method, 384. Long Method, 385. Long Method, 386. Long Method, 387. Long Method, 388. Long Method, 389. Long Method, 390. Long Method, 391. Long Method, 392. Long Method, 393. Long Method, 394. Long Method, 395. Long Method, 396. Long Method, 397. Long Method, 398. Long Method, 399. Long Method, 400. Long Method, 401. Long Method, 402. Long Method, 403. Long Method, 404. Long Method, 405. Long Method, 406. Long Method, 407. Long Method, 408. Long Method, 409. Long Method, 410. Long Method, 411. Long Method, 412. Long Method, 413. Long Method, 414. Long Method, 415. Long Method, 416. Long Method, 417. Long Method, 418. Long Method, 419. Long Method, 420. Long Method, 421. Long Method, 422. Long Method, 423. Long Method, 424. Long Method, 425. Long Method, 426. Long Method, 427. Long Method, 428. Long Method, 429. Long Method, 430. Long Method, 431. Long Method, 432. Long Method, 433. Long Method, 434. Long Method, 435. Long Method, 436. Long Method, 437. Long Method, 438. Long Method, 439. Long Method, 440. Long Method, 441. Long Method, 442. Long Method, 443. Long Method, 444. Long Method, 445. Long Method, 446. Long Method, 447. Long Method, 448. Long Method, 449. Long Method, 450. Long Method, 451. Long Method, 452. Long Method, 453. Long Method, 454. Long Method, 455. Long Method, 456. Long Method, 457. Long Method, 458. Long Method, 459. Long Method, 460. Long Method, 461. Long Method, 462. Long Method, 463. Long Method, 464. Long Method, 465. Long Method, 466. Long Method, 467. Long Method, 468. Long Method, 469. Long Method, 470. Long Method, 471. Long Method, 472. Long Method, 473. Long Method, 474. Long Method, 475. Long Method, 476. Long Method, 477. Long Method, 478. Long Method, 479. Long Method, 480. Long Method, 481. Long Method, 482. Long Method, 483. Long Method, 484. Long Method, 485. Long Method, 486. Long Method, 487. Long Method, 488. Long Method, 489. Long Method, 490. Long Method, 491. Long Method, 492. Long Method, 493. Long Method, 494. Long Method, 495. Long Method, 496. Long Method, 497. Long Method, 498. Long Method, 499. Long Method, 500. Long Method, 501. Long Method, 502. Long Method, 503. Long Method, 504. Long Method, 505. Long Method, 506. Long Method, 507. Long Method, 508. Long Method, 509. Long Method, 510. Long Method, 511. Long Method, 512. Long Method, 513. Long Method, 514. Long Method, 515. Long Method, 516. Long Method, 517. Long Method, 518. Long Method, 519. Long Method, 520. Long Method, 521. Long Method, 522. Long Method, 523. Long Method, 524. Long Method, 525. Long Method, 526. Long Method, 527. Long Method, 528. Long Method, 529. Long Method, 530. Long Method, 531. Long Method, 532. Long Method, 533. Long Method, 534. Long Method, 535. Long Method, 536. Long Method, 537. Long Method, 538. Long Method, 539. Long Method, 540. Long Method, 541. Long Method, 542. Long Method, 543. Long Method, 544. Long Method, 545. Long Method, 546. Long Method, 547. Long Method, 548. Long Method, 549. Long Method, 550. Long Method, 551. Long Method, 552. Long Method, 553. Long Method, 554. Long Method, 555. Long Method, 556. Long Method, 557. Long Method, 558. Long Method, 559. Long Method, 560. Long Method, 561. Long Method, 562. Long Method, 563. Long Method, 564. Long Method, 565. Long Method, 566. Long Method, 567. Long Method, 568. Long Method, 569. Long Method, 570. Long Method, 571. Long Method, 572. Long Method, 573. Long Method, 574. Long Method, 575. Long Method, 576. Long Method, 577. Long Method, 578. Long Method, 579. Long Method, 580. Long Method, 581. Long Method, 582. Long Method, 583. Long Method, 584. Long Method, 585. Long Method, 586. Long Method, 587. Long Method, 588. Long Method, 589. Long Method, 590. Long Method, 591. Long Method, 592. Long Method, 593. Long Method, 594. Long Method, 595. Long Method, 596. Long Method, 597. Long Method, 598. Long Method, 599. Long Method, 600. Long Method, 601. Long Method, 602. Long Method, 603. Long Method, 604. Long Method, 605. Long Method, 606. Long Method, 607. Long Method, 608. Long Method, 609. Long Method, 610. Long Method, 611. Long Method, 612. Long Method, 613. Long Method, 614. Long Method, 615. Long Method, 616. Long Method, 617. Long Method, 618. Long Method, 619. Long Method, 620. Long Method, 621. Long Method, 622. Long Method, 623. Long Method, 624. Long Method, 625. Long Method, 626. Long Method, 627. Long Method, 628. Long Method, 629. Long Method, 630. Long Method, 631. Long Method, 632. Long Method, 633. Long Method, 634. Data Class, 635. Long Method, 636. Long Method, 637. Data Class, 638. Blob, 639. Data Class, 640. Blob, 641. Data Class, 642. Blob, 643. Data Class, 644. Blob, 645. Data Class, 646. Blob, 647. Data Class, 648. Blob, 649. Data Class, 650. Blob, 651. Data Class, 652. Blob, 653. Data Class, 654. Blob, 655. Data Class, 656. Blob, 657. Data Class, 658. Blob, 659. Data Class, 660. Blob, 661. Data Class, 662. Blob, 663. Data Class, 664. Blob, 665. Data Class, 666. Blob, 667. Data Class, 668. Blob, 669. Data Class, 670. Blob, 671. Data Class, 672. Blob, 673. Data Class, 674. Blob, 675. Data Class, 676. Blob, 677. Data Class, 678. Blob, 679. Data Class, 680. Blob, 681. Data Class, 682. Blob, 683. Data Class, 684. Blob,</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@InterfaceAudience.Private public class SplitTableRegionProcedure     extends AbstractStateMachineRegionProcedure {   private static final Logger LOG = LoggerFactory.getLogger(SplitTableRegionProcedure.class);   private Boolean traceEnabled = null;   private RegionInfo daughter_1_RI;   private RegionInfo daughter_2_RI;   private byte[] bestSplitRow;   private RegionSplitPolicy splitPolicy;    public SplitTableRegionProcedure() {     // Required by the Procedure framework to create the procedure on replay   }    public SplitTableRegionProcedure(final MasterProcedureEnv env,       final RegionInfo regionToSplit, final byte[] splitRow) throws IOException {     super(env, regionToSplit);     preflightChecks(env, true);     // When procedure goes to run in its prepare step, it also does these checkOnline checks. Here     // we fail-fast on construction. There it skips the split with just a warning.     checkOnline(env, regionToSplit);     this.bestSplitRow = splitRow;     checkSplittable(env, regionToSplit, bestSplitRow);     final TableName table = regionToSplit.getTable();     final long rid = getDaughterRegionIdTimestamp(regionToSplit);     this.daughter_1_RI = RegionInfoBuilder.newBuilder(table)         .setStartKey(regionToSplit.getStartKey())         .setEndKey(bestSplitRow)         .setSplit(false)         .setRegionId(rid)         .build();     this.daughter_2_RI = RegionInfoBuilder.newBuilder(table)         .setStartKey(bestSplitRow)         .setEndKey(regionToSplit.getEndKey())         .setSplit(false)         .setRegionId(rid)         .build();     TableDescriptor htd = env.getMasterServices().getTableDescriptors().get(getTableName());     if(htd.getRegionSplitPolicyClassName() != null) {       // Since we don't have region reference here, creating the split policy instance without it.       // This can be used to invoke methods which don't require Region reference. This instantiation       // of a class on Master-side though it only makes sense on the RegionServer-side is       // for Phoenix Local Indexing. Refer HBASE-12583 for more information.       Class clazz =           RegionSplitPolicy.getSplitPolicyClass(htd, env.getMasterConfiguration());       this.splitPolicy = ReflectionUtils.newInstance(clazz, env.getMasterConfiguration());     }   }    @Override   protected LockState acquireLock(final MasterProcedureEnv env) {     if (env.getProcedureScheduler().waitRegions(this, getTableName(), getParentRegion(),       daughter_1_RI, daughter_2_RI)) {       try {         LOG.debug(LockState.LOCK_EVENT_WAIT + &quot; &quot; + env.getProcedureScheduler().dumpLocks());       } catch (IOException e) {         // Ignore, just for logging       }       return LockState.LOCK_EVENT_WAIT;     }     return LockState.LOCK_ACQUIRED;   }    @Override   protected void releaseLock(final MasterProcedureEnv env) {     env.getProcedureScheduler().wakeRegions(this, getTableName(), getParentRegion(), daughter_1_RI,       daughter_2_RI);   }    /**    * Check whether the region is splittable    * @param env MasterProcedureEnv    * @param regionToSplit parent Region to be split    * @param splitRow if splitRow is not specified, will first try to get bestSplitRow from RS    * @throws IOException    */   private void checkSplittable(final MasterProcedureEnv env,       final RegionInfo regionToSplit, final byte[] splitRow) throws IOException {     // Ask the remote RS if this region is splittable.     // If we get an IOE, report it along w/ the failure so can see why we are not splittable at this time.     if(regionToSplit.getReplicaId() != RegionInfo.DEFAULT_REPLICA_ID) {       throw new IllegalArgumentException (&quot;Can't invoke split on non-default regions directly&quot;);     }     RegionStateNode node =         env.getAssignmentManager().getRegionStates().getRegionStateNode(getParentRegion());     IOException splittableCheckIOE = null;     boolean splittable = false;     if (node != null) {       try {         if (bestSplitRow == null || bestSplitRow.length == 0) {           LOG             .info(&quot;splitKey isn't explicitly specified, will try to find a best split key from RS&quot;);         }         // Always set bestSplitRow request as true here,         // need to call Region#checkSplit to check it splittable or not         GetRegionInfoResponse response = AssignmentManagerUtil.getRegionInfoResponse(env,           node.getRegionLocation(), node.getRegionInfo(), true);         if(bestSplitRow == null || bestSplitRow.length == 0) {           bestSplitRow = response.hasBestSplitRow() ? response.getBestSplitRow().toByteArray() : null;         }         splittable = response.hasSplittable() &amp;&amp; response.getSplittable();          if (LOG.isDebugEnabled()) {           LOG.debug(&quot;Splittable=&quot; + splittable + &quot; &quot; + node.toShortString());         }       } catch (IOException e) {         splittableCheckIOE = e;       }     }      if (!splittable) {       IOException e =         new DoNotRetryIOException(regionToSplit.getShortNameToLog() + &quot; NOT splittable&quot;);       if (splittableCheckIOE != null) {         e.initCause(splittableCheckIOE);       }       throw e;     }      if (bestSplitRow == null || bestSplitRow.length == 0) {       throw new DoNotRetryIOException(&quot;Region not splittable because bestSplitPoint = null, &quot; +         &quot;maybe table is too small for auto split. For force split, try specifying split row&quot;);     }      if (Bytes.equals(regionToSplit.getStartKey(), bestSplitRow)) {       throw new DoNotRetryIOException(         &quot;Split row is equal to startkey: &quot; + Bytes.toStringBinary(splitRow));     }      if (!regionToSplit.containsRow(bestSplitRow)) {       throw new DoNotRetryIOException(&quot;Split row is not inside region key range splitKey:&quot; +         Bytes.toStringBinary(splitRow) + &quot; region: &quot; + regionToSplit);     }   }    /**    * Calculate daughter regionid to use.    * @param hri Parent {@link RegionInfo}    * @return Daughter region id (timestamp) to use.    */   private static long getDaughterRegionIdTimestamp(final RegionInfo hri) {     long rid = EnvironmentEdgeManager.currentTime();     // Regionid is timestamp.  Can't be less than that of parent else will insert     // at wrong location in hbase:meta (See HBASE-710).     if (rid &lt; hri.getRegionId()) {       LOG.warn(&quot;Clock skew; parent regions id is &quot; + hri.getRegionId() +         &quot; but current time here is &quot; + rid);       rid = hri.getRegionId() + 1;     }     return rid;   }    private void removeNonDefaultReplicas(MasterProcedureEnv env) throws IOException {     AssignmentManagerUtil.removeNonDefaultReplicas(env, Stream.of(getParentRegion()),       getRegionReplication(env));   }    private void checkClosedRegions(MasterProcedureEnv env) throws IOException {     // theoretically this should not happen any more after we use TRSP, but anyway let's add a check     // here     AssignmentManagerUtil.checkClosedRegion(env, getParentRegion());   }    @Override   protected Flow executeFromState(MasterProcedureEnv env, SplitTableRegionState state)       throws InterruptedException {     LOG.trace(&quot;{} execute state={}&quot;, this, state);      try {       switch (state) {         case SPLIT_TABLE_REGION_PREPARE:           if (prepareSplitRegion(env)) {             setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_PRE_OPERATION);             break;           } else {             return Flow.NO_MORE_STATE;           }         case SPLIT_TABLE_REGION_PRE_OPERATION:           preSplitRegion(env);           setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_CLOSE_PARENT_REGION);           break;         case SPLIT_TABLE_REGION_CLOSE_PARENT_REGION:           addChildProcedure(createUnassignProcedures(env));           setNextState(SplitTableRegionState.SPLIT_TABLE_REGIONS_CHECK_CLOSED_REGIONS);           break;         case SPLIT_TABLE_REGIONS_CHECK_CLOSED_REGIONS:           checkClosedRegions(env);           setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_CREATE_DAUGHTER_REGIONS);           break;         case SPLIT_TABLE_REGION_CREATE_DAUGHTER_REGIONS:           removeNonDefaultReplicas(env);           createDaughterRegions(env);           setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_WRITE_MAX_SEQUENCE_ID_FILE);           break;         case SPLIT_TABLE_REGION_WRITE_MAX_SEQUENCE_ID_FILE:           writeMaxSequenceIdFile(env);           setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_PRE_OPERATION_BEFORE_META);           break;         case SPLIT_TABLE_REGION_PRE_OPERATION_BEFORE_META:           preSplitRegionBeforeMETA(env);           setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_UPDATE_META);           break;         case SPLIT_TABLE_REGION_UPDATE_META:           updateMeta(env);           setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_PRE_OPERATION_AFTER_META);           break;         case SPLIT_TABLE_REGION_PRE_OPERATION_AFTER_META:           preSplitRegionAfterMETA(env);           setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_OPEN_CHILD_REGIONS);           break;         case SPLIT_TABLE_REGION_OPEN_CHILD_REGIONS:           addChildProcedure(createAssignProcedures(env));           setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_POST_OPERATION);           break;         case SPLIT_TABLE_REGION_POST_OPERATION:           postSplitRegion(env);           return Flow.NO_MORE_STATE;         default:           throw new UnsupportedOperationException(this + &quot; unhandled state=&quot; + state);       }     } catch (IOException e) {       String msg = &quot;Splitting &quot; + getParentRegion().getEncodedName() + &quot;, &quot; + this;       if (!isRollbackSupported(state)) {         // We reach a state that cannot be rolled back. We just need to keep retrying.         LOG.warn(msg, e);       } else {         LOG.error(msg, e);         setFailure(&quot;master-split-regions&quot;, e);       }     }     // if split fails,  need to call ((HRegion)parent).clearSplit() when it is a force split     return Flow.HAS_MORE_STATE;   }    /**    * To rollback {@link SplitTableRegionProcedure}, an AssignProcedure is asynchronously    * submitted for parent region to be split (rollback doesn't wait on the completion of the    * AssignProcedure) . This can be improved by changing rollback() to support sub-procedures.    * See HBASE-19851 for details.    */   @Override   protected void rollbackState(final MasterProcedureEnv env, final SplitTableRegionState state)       throws IOException, InterruptedException {     if (isTraceEnabled()) {       LOG.trace(this + &quot; rollback state=&quot; + state);     }      try {       switch (state) {         case SPLIT_TABLE_REGION_POST_OPERATION:         case SPLIT_TABLE_REGION_OPEN_CHILD_REGIONS:         case SPLIT_TABLE_REGION_PRE_OPERATION_AFTER_META:         case SPLIT_TABLE_REGION_UPDATE_META:           // PONR           throw new UnsupportedOperationException(this + &quot; unhandled state=&quot; + state);         case SPLIT_TABLE_REGION_PRE_OPERATION_BEFORE_META:           break;         case SPLIT_TABLE_REGION_CREATE_DAUGHTER_REGIONS:         case SPLIT_TABLE_REGION_WRITE_MAX_SEQUENCE_ID_FILE:           // Doing nothing, as re-open parent region would clean up daughter region directories.           break;         case SPLIT_TABLE_REGIONS_CHECK_CLOSED_REGIONS:           // Doing nothing, in SPLIT_TABLE_REGION_CLOSE_PARENT_REGION,           // we will bring parent region online           break;         case SPLIT_TABLE_REGION_CLOSE_PARENT_REGION:           openParentRegion(env);           break;         case SPLIT_TABLE_REGION_PRE_OPERATION:           postRollBackSplitRegion(env);           break;         case SPLIT_TABLE_REGION_PREPARE:           break; // nothing to do         default:           throw new UnsupportedOperationException(this + &quot; unhandled state=&quot; + state);       }     } catch (IOException e) {       // This will be retried. Unless there is a bug in the code,       // this should be just a &quot;temporary error&quot; (e.g. network down)       LOG.warn(&quot;pid=&quot; + getProcId() + &quot; failed rollback attempt step &quot; + state +           &quot; for splitting the region &quot;         + getParentRegion().getEncodedName() + &quot; in table &quot; + getTableName(), e);       throw e;     }   }    /*    * Check whether we are in the state that can be rollback    */   @Override   protected boolean isRollbackSupported(final SplitTableRegionState state) {     switch (state) {       case SPLIT_TABLE_REGION_POST_OPERATION:       case SPLIT_TABLE_REGION_OPEN_CHILD_REGIONS:       case SPLIT_TABLE_REGION_PRE_OPERATION_AFTER_META:       case SPLIT_TABLE_REGION_UPDATE_META:         // It is not safe to rollback if we reach to these states.         return false;       default:         break;     }     return true;   }    @Override   protected SplitTableRegionState getState(final int stateId) {     return SplitTableRegionState.forNumber(stateId);   }    @Override   protected int getStateId(final SplitTableRegionState state) {     return state.getNumber();   }    @Override   protected SplitTableRegionState getInitialState() {     return SplitTableRegionState.SPLIT_TABLE_REGION_PREPARE;   }    @Override   protected void serializeStateData(ProcedureStateSerializer serializer)       throws IOException {     super.serializeStateData(serializer);      final MasterProcedureProtos.SplitTableRegionStateData.Builder splitTableRegionMsg =         MasterProcedureProtos.SplitTableRegionStateData.newBuilder()         .setUserInfo(MasterProcedureUtil.toProtoUserInfo(getUser()))         .setParentRegionInfo(ProtobufUtil.toRegionInfo(getRegion()))         .addChildRegionInfo(ProtobufUtil.toRegionInfo(daughter_1_RI))         .addChildRegionInfo(ProtobufUtil.toRegionInfo(daughter_2_RI));     serializer.serialize(splitTableRegionMsg.build());   }    @Override   protected void deserializeStateData(ProcedureStateSerializer serializer)       throws IOException {     super.deserializeStateData(serializer);      final MasterProcedureProtos.SplitTableRegionStateData splitTableRegionsMsg =         serializer.deserialize(MasterProcedureProtos.SplitTableRegionStateData.class);     setUser(MasterProcedureUtil.toUserInfo(splitTableRegionsMsg.getUserInfo()));     setRegion(ProtobufUtil.toRegionInfo(splitTableRegionsMsg.getParentRegionInfo()));     assert(splitTableRegionsMsg.getChildRegionInfoCount() == 2);     daughter_1_RI = ProtobufUtil.toRegionInfo(splitTableRegionsMsg.getChildRegionInfo(0));     daughter_2_RI = ProtobufUtil.toRegionInfo(splitTableRegionsMsg.getChildRegionInfo(1));   }    @Override   public void toStringClassDetails(StringBuilder sb) {     sb.append(getClass().getSimpleName());     sb.append(&quot; table=&quot;);     sb.append(getTableName());     sb.append(&quot;, parent=&quot;);     sb.append(getParentRegion().getShortNameToLog());     sb.append(&quot;, daughterA=&quot;);     sb.append(daughter_1_RI.getShortNameToLog());     sb.append(&quot;, daughterB=&quot;);     sb.append(daughter_2_RI.getShortNameToLog());   }    private RegionInfo getParentRegion() {     return getRegion();   }    @Override   public TableOperationType getTableOperationType() {     return TableOperationType.REGION_SPLIT;   }    @Override   protected ProcedureMetrics getProcedureMetrics(MasterProcedureEnv env) {     return env.getAssignmentManager().getAssignmentManagerMetrics().getSplitProcMetrics();   }    private byte[] getSplitRow() {     return daughter_2_RI.getStartKey();   }    private static final State[] EXPECTED_SPLIT_STATES = new State[] { State.OPEN, State.CLOSED };    /**    * Prepare to Split region.    * @param env MasterProcedureEnv    */   @VisibleForTesting   public boolean prepareSplitRegion(final MasterProcedureEnv env) throws IOException {     // Fail if we are taking snapshot for the given table     if (env.getMasterServices().getSnapshotManager()       .isTakingSnapshot(getParentRegion().getTable())) {       setFailure(new IOException(&quot;Skip splitting region &quot; + getParentRegion().getShortNameToLog() +         &quot;, because we are taking snapshot for the table &quot; + getParentRegion().getTable()));       return false;     }     // Check whether the region is splittable     RegionStateNode node =         env.getAssignmentManager().getRegionStates().getRegionStateNode(getParentRegion());      if (node == null) {       throw new UnknownRegionException(getParentRegion().getRegionNameAsString());     }      RegionInfo parentHRI = node.getRegionInfo();     if (parentHRI == null) {       LOG.info(&quot;Unsplittable; parent region is null; node={}&quot;, node);       return false;     }     // Lookup the parent HRI state from the AM, which has the latest updated info.     // Protect against the case where concurrent SPLIT requests came in and succeeded     // just before us.     if (node.isInState(State.SPLIT)) {       LOG.info(&quot;Split of &quot; + parentHRI + &quot; skipped; state is already SPLIT&quot;);       return false;     }     if (parentHRI.isSplit() || parentHRI.isOffline()) {       LOG.info(&quot;Split of &quot; + parentHRI + &quot; skipped because offline/split.&quot;);       return false;     }      // expected parent to be online or closed     if (!node.isInState(EXPECTED_SPLIT_STATES)) {       // We may have SPLIT already?       setFailure(new IOException(&quot;Split &quot; + parentHRI.getRegionNameAsString() +           &quot; FAILED because state=&quot; + node.getState() + &quot;; expected &quot; +           Arrays.toString(EXPECTED_SPLIT_STATES)));       return false;     }      // Since we have the lock and the master is coordinating the operation     // we are always able to split the region     if (!env.getMasterServices().isSplitOrMergeEnabled(MasterSwitchType.SPLIT)) {       LOG.warn(&quot;pid=&quot; + getProcId() + &quot; split switch is off! skip split of &quot; + parentHRI);       setFailure(new IOException(&quot;Split region &quot; + parentHRI.getRegionNameAsString() +           &quot; failed due to split switch off&quot;));       return false;     }      if (!env.getMasterServices().getTableDescriptors().get(getTableName()).isSplitEnabled()) {       LOG.warn(&quot;pid={}, split is disabled for the table! Skipping split of {}&quot;, getProcId(),         parentHRI);       setFailure(new IOException(&quot;Split region &quot; + parentHRI.getRegionNameAsString()           + &quot; failed as region split is disabled for the table&quot;));       return false;     }      // set node state as SPLITTING     node.setState(State.SPLITTING);      return true;   }    /**    * Action before splitting region in a table.    * @param env MasterProcedureEnv    */   private void preSplitRegion(final MasterProcedureEnv env)       throws IOException, InterruptedException {     final MasterCoprocessorHost cpHost = env.getMasterCoprocessorHost();     if (cpHost != null) {       cpHost.preSplitRegionAction(getTableName(), getSplitRow(), getUser());     }      // TODO: Clean up split and merge. Currently all over the place.     // Notify QuotaManager and RegionNormalizer     try {       env.getMasterServices().getMasterQuotaManager().onRegionSplit(this.getParentRegion());     } catch (QuotaExceededException e) {       env.getMasterServices().getRegionNormalizer().planSkipped(this.getParentRegion(),           NormalizationPlan.PlanType.SPLIT);       throw e;     }   }    /**    * Action after rollback a split table region action.    * @param env MasterProcedureEnv    */   private void postRollBackSplitRegion(final MasterProcedureEnv env) throws IOException {     final MasterCoprocessorHost cpHost = env.getMasterCoprocessorHost();     if (cpHost != null) {       cpHost.postRollBackSplitRegionAction(getUser());     }   }    /**    * Rollback close parent region    */   private void openParentRegion(MasterProcedureEnv env) throws IOException {     AssignmentManagerUtil.reopenRegionsForRollback(env,       Collections.singletonList((getParentRegion())), getRegionReplication(env),       getParentRegionServerName(env));   }    /**    * Create daughter regions    */   @VisibleForTesting   public void createDaughterRegions(final MasterProcedureEnv env) throws IOException {     final MasterFileSystem mfs = env.getMasterServices().getMasterFileSystem();     final Path tabledir = FSUtils.getTableDir(mfs.getRootDir(), getTableName());     final FileSystem fs = mfs.getFileSystem();     HRegionFileSystem regionFs = HRegionFileSystem.openRegionFromFileSystem(       env.getMasterConfiguration(), fs, tabledir, getParentRegion(), false);     regionFs.createSplitsDir();      Pair expectedReferences = splitStoreFiles(env, regionFs);      assertReferenceFileCount(fs, expectedReferences.getFirst(),       regionFs.getSplitsDir(daughter_1_RI));     //Move the files from the temporary .splits to the final /table/region directory     regionFs.commitDaughterRegion(daughter_1_RI);     assertReferenceFileCount(fs, expectedReferences.getFirst(),       new Path(tabledir, daughter_1_RI.getEncodedName()));      assertReferenceFileCount(fs, expectedReferences.getSecond(),       regionFs.getSplitsDir(daughter_2_RI));     regionFs.commitDaughterRegion(daughter_2_RI);     assertReferenceFileCount(fs, expectedReferences.getSecond(),       new Path(tabledir, daughter_2_RI.getEncodedName()));   }    /**    * Create Split directory    * @param env MasterProcedureEnv    */   private Pair splitStoreFiles(final MasterProcedureEnv env,       final HRegionFileSystem regionFs) throws IOException {     final MasterFileSystem mfs = env.getMasterServices().getMasterFileSystem();     final Configuration conf = env.getMasterConfiguration();     // The following code sets up a thread pool executor with as many slots as     // there's files to split. It then fires up everything, waits for     // completion and finally checks for any exception     //     // Note: splitStoreFiles creates daughter region dirs under the parent splits dir     // Nothing to unroll here if failure -- re-run createSplitsDir will     // clean this up.     int nbFiles = 0;     final Map&gt; files =       new HashMap&gt;(regionFs.getFamilies().size());     for (String family: regionFs.getFamilies()) {       Collection sfis = regionFs.getStoreFiles(family);       if (sfis == null) continue;       Collection filteredSfis = null;       for (StoreFileInfo sfi: sfis) {         // Filter. There is a lag cleaning up compacted reference files. They get cleared         // after a delay in case outstanding Scanners still have references. Because of this,         // the listing of the Store content may have straggler reference files. Skip these.         // It should be safe to skip references at this point because we checked above with         // the region if it thinks it is splittable and if we are here, it thinks it is         // splitable.         if (sfi.isReference()) {           LOG.info(&quot;Skipping split of &quot; + sfi + &quot;; presuming ready for archiving.&quot;);           continue;         }         if (filteredSfis == null) {           filteredSfis = new ArrayList(sfis.size());           files.put(family, filteredSfis);         }         filteredSfis.add(sfi);         nbFiles++;       }     }     if (nbFiles == 0) {       // no file needs to be splitted.       return new Pair(0,0);     }     // Max #threads is the smaller of the number of storefiles or the default max determined above.     int maxThreads = Math.min(       conf.getInt(HConstants.REGION_SPLIT_THREADS_MAX,         conf.getInt(HStore.BLOCKING_STOREFILES_KEY, HStore.DEFAULT_BLOCKING_STOREFILE_COUNT)),       nbFiles);     LOG.info(&quot;pid=&quot; + getProcId() + &quot; splitting &quot; + nbFiles + &quot; storefiles, region=&quot; +       getParentRegion().getShortNameToLog() + &quot;, threads=&quot; + maxThreads);     final ExecutorService threadPool = Executors.newFixedThreadPool(       maxThreads, Threads.getNamedThreadFactory(&quot;StoreFileSplitter-%1$d&quot;));     final List&gt;&gt; futures = new ArrayList&gt;&gt;(nbFiles);      TableDescriptor htd = env.getMasterServices().getTableDescriptors().get(getTableName());     // Split each store file.     for (Map.Entry&gt; e : files.entrySet()) {       byte[] familyName = Bytes.toBytes(e.getKey());       final ColumnFamilyDescriptor hcd = htd.getColumnFamily(familyName);       final Collection storeFiles = e.getValue();       if (storeFiles != null &amp;&amp; storeFiles.size() &gt; 0) {         for (StoreFileInfo storeFileInfo : storeFiles) {           // As this procedure is running on master, use CacheConfig.DISABLED means           // don't cache any block.           StoreFileSplitter sfs = new StoreFileSplitter(regionFs, familyName,               new HStoreFile(mfs.getFileSystem(), storeFileInfo, conf, CacheConfig.DISABLED,                   hcd.getBloomFilterType(), true));           futures.add(threadPool.submit(sfs));         }       }     }     // Shutdown the pool     threadPool.shutdown();      // Wait for all the tasks to finish.     // When splits ran on the RegionServer, how-long-to-wait-configuration was named     // hbase.regionserver.fileSplitTimeout. If set, use its value.     long fileSplitTimeout = conf.getLong(&quot;hbase.master.fileSplitTimeout&quot;,         conf.getLong(&quot;hbase.regionserver.fileSplitTimeout&quot;, 600000));     try {       boolean stillRunning = !threadPool.awaitTermination(fileSplitTimeout, TimeUnit.MILLISECONDS);       if (stillRunning) {         threadPool.shutdownNow();         // wait for the thread to shutdown completely.         while (!threadPool.isTerminated()) {           Thread.sleep(50);         }         throw new IOException(&quot;Took too long to split the&quot; +             &quot; files and create the references, aborting split&quot;);       }     } catch (InterruptedException e) {       throw (InterruptedIOException)new InterruptedIOException().initCause(e);     }      int daughterA = 0;     int daughterB = 0;     // Look for any exception     for (Future&gt; future : futures) {       try {         Pair p = future.get();         daughterA += p.getFirst() != null ? 1 : 0;         daughterB += p.getSecond() != null ? 1 : 0;       } catch (InterruptedException e) {         throw (InterruptedIOException) new InterruptedIOException().initCause(e);       } catch (ExecutionException e) {         throw new IOException(e);       }     }      if (LOG.isDebugEnabled()) {       LOG.debug(&quot;pid=&quot; + getProcId() + &quot; split storefiles for region &quot; +         getParentRegion().getShortNameToLog() +           &quot; Daughter A: &quot; + daughterA + &quot; storefiles, Daughter B: &quot; +           daughterB + &quot; storefiles.&quot;);     }     return new Pair(daughterA, daughterB);   }    private void assertReferenceFileCount(final FileSystem fs, final int expectedReferenceFileCount,       final Path dir) throws IOException {     if (expectedReferenceFileCount != 0 &amp;&amp;         expectedReferenceFileCount != FSUtils.getRegionReferenceFileCount(fs, dir)) {       throw new IOException(&quot;Failing split. Expected reference file count isn't equal.&quot;);     }   }    private Pair splitStoreFile(HRegionFileSystem regionFs, byte[] family, HStoreFile sf)     throws IOException {     if (LOG.isDebugEnabled()) {       LOG.debug(&quot;pid=&quot; + getProcId() + &quot; splitting started for store file: &quot; +           sf.getPath() + &quot; for region: &quot; + getParentRegion().getShortNameToLog());     }      final byte[] splitRow = getSplitRow();     final String familyName = Bytes.toString(family);     final Path path_first = regionFs.splitStoreFile(this.daughter_1_RI, familyName, sf, splitRow,         false, splitPolicy);     final Path path_second = regionFs.splitStoreFile(this.daughter_2_RI, familyName, sf, splitRow,        true, splitPolicy);     if (LOG.isDebugEnabled()) {       LOG.debug(&quot;pid=&quot; + getProcId() + &quot; splitting complete for store file: &quot; +           sf.getPath() + &quot; for region: &quot; + getParentRegion().getShortNameToLog());     }     return new Pair(path_first, path_second);   }    /**    * Utility class used to do the file splitting / reference writing    * in parallel instead of sequentially.    */   private class StoreFileSplitter implements Callable&gt; {     private final HRegionFileSystem regionFs;     private final byte[] family;     private final HStoreFile sf;      /**      * Constructor that takes what it needs to split      * @param regionFs the file system      * @param family Family that contains the store file      * @param sf which file      */     public StoreFileSplitter(HRegionFileSystem regionFs, byte[] family, HStoreFile sf) {       this.regionFs = regionFs;       this.sf = sf;       this.family = family;     }      @Override     public Pair call() throws IOException {       return splitStoreFile(regionFs, family, sf);     }   }    /**    * Post split region actions before the Point-of-No-Return step    * @param env MasterProcedureEnv    **/   private void preSplitRegionBeforeMETA(final MasterProcedureEnv env)       throws IOException, InterruptedException {     final List metaEntries = new ArrayList();     final MasterCoprocessorHost cpHost = env.getMasterCoprocessorHost();     if (cpHost != null) {       cpHost.preSplitBeforeMETAAction(getSplitRow(), metaEntries, getUser());       try {         for (Mutation p : metaEntries) {           RegionInfo.parseRegionName(p.getRow());         }       } catch (IOException e) {         LOG.error(&quot;pid=&quot; + getProcId() + &quot; row key of mutation from coprocessor not parsable as &quot;             + &quot;region name.&quot;             + &quot;Mutations from coprocessor should only for hbase:meta table.&quot;);         throw e;       }     }   }    /**    * Add daughter regions to META    * @param env MasterProcedureEnv    */   private void updateMeta(final MasterProcedureEnv env) throws IOException {     env.getAssignmentManager().markRegionAsSplit(getParentRegion(), getParentRegionServerName(env),       daughter_1_RI, daughter_2_RI);   }    /**    * Pre split region actions after the Point-of-No-Return step    * @param env MasterProcedureEnv    **/   private void preSplitRegionAfterMETA(final MasterProcedureEnv env)       throws IOException, InterruptedException {     final MasterCoprocessorHost cpHost = env.getMasterCoprocessorHost();     if (cpHost != null) {       cpHost.preSplitAfterMETAAction(getUser());     }   }    /**    * Post split region actions    * @param env MasterProcedureEnv    **/   private void postSplitRegion(final MasterProcedureEnv env) throws IOException {     final MasterCoprocessorHost cpHost = env.getMasterCoprocessorHost();     if (cpHost != null) {       cpHost.postCompletedSplitRegionAction(daughter_1_RI, daughter_2_RI, getUser());     }   }    private ServerName getParentRegionServerName(final MasterProcedureEnv env) {     return env.getMasterServices().getAssignmentManager().getRegionStates()       .getRegionServerOfRegion(getParentRegion());   }    private TransitRegionStateProcedure[] createUnassignProcedures(MasterProcedureEnv env)       throws IOException {     return AssignmentManagerUtil.createUnassignProceduresForSplitOrMerge(env,       Stream.of(getParentRegion()), getRegionReplication(env));   }    private TransitRegionStateProcedure[] createAssignProcedures(MasterProcedureEnv env)       throws IOException {     List hris = new ArrayList(2);     hris.add(daughter_1_RI);     hris.add(daughter_2_RI);     return AssignmentManagerUtil.createAssignProceduresForOpeningNewRegions(env, hris,       getRegionReplication(env), getParentRegionServerName(env));   }    private int getRegionReplication(final MasterProcedureEnv env) throws IOException {     final TableDescriptor htd = env.getMasterServices().getTableDescriptors().get(getTableName());     return htd.getRegionReplication();   }    private void writeMaxSequenceIdFile(MasterProcedureEnv env) throws IOException {     FileSystem walFS = env.getMasterServices().getMasterWalManager().getFileSystem();     long maxSequenceId =       WALSplitter.getMaxRegionSequenceId(walFS, getWALRegionDir(env, getParentRegion()));     if (maxSequenceId &gt; 0) {       WALSplitter.writeRegionSequenceIdFile(walFS, getWALRegionDir(env, daughter_1_RI),           maxSequenceId);       WALSplitter.writeRegionSequenceIdFile(walFS, getWALRegionDir(env, daughter_2_RI),           maxSequenceId);     }   }    /**    * The procedure could be restarted from a different machine. If the variable is null, we need to    * retrieve it.    * @return traceEnabled    */   private boolean isTraceEnabled() {     if (traceEnabled == null) {       traceEnabled = LOG.isTraceEnabled();     }     return traceEnabled;   }    @Override   protected boolean abort(MasterProcedureEnv env) {     // Abort means rollback. We can't rollback all steps. HBASE-18018 added abort to all     // Procedures. Here is a Procedure that has a PONR and cannot be aborted wants it enters this     // range of steps; what do we do for these should an operator want to cancel them? HBASE-20022.     return isRollbackSupported(getCurrentState())? super.abort(env): false;   } }</td>
    <td align="left">blob</td>
    <td align="left">&nbsp;Long Method, 2 Blob, 3 Data Class, 4 Feature Envy, 5 Long Method, 6 Long Method, 7 Long Method, 8 Long Method, 9 Long Method, </td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">. Long Method,  3. Data Class,  4. Feature Envy,  5. Long Method,  6. Long Method,  7. Long Method,  8. Long Method,  9. Long Method,  </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13723</td>
    <td align="left">https://github.com/apache/hbase/blob/44f8abd5c65c59e9d09f6ad14b3c825f145d8e4f/hbase-server/src/main/java/org/apache/hadoop/hbase/master/assignment/SplitTableRegionProcedure.java/#L91-L897</td>
    <td align="right">1</td>
    <td align="right">2263</td>
    <td align="right">13723</td>
  </tr>
  <tr valign="top">
    <td align="right">2319</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;1. Long method&quot;, &quot;2. Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SequenceFileReader     extends AbstractFileReader {     public static final String[] defaultFields = { &quot;key&quot;, &quot;value&quot; };     public static final String BUFFER_SIZE = &quot;hdfsspout.reader.buffer.bytes&quot;;     private static final Logger LOG = LoggerFactory         .getLogger(SequenceFileReader.class);     private static final int DEFAULT_BUFF_SIZE = 4096;     private final SequenceFile.Reader reader;      private final SequenceFileReader.Offset offset;       private final Key key;     private final Value value;       public SequenceFileReader(FileSystem fs, Path file, Map conf)         throws IOException {         super(fs, file);         int bufferSize = !conf.containsKey(BUFFER_SIZE) ? DEFAULT_BUFF_SIZE : Integer.parseInt(conf.get(BUFFER_SIZE).toString());         this.reader = new SequenceFile.Reader(fs.getConf(), SequenceFile.Reader.file(file), SequenceFile.Reader.bufferSize(bufferSize));         this.key = (Key) ReflectionUtils.newInstance(reader.getKeyClass(), fs.getConf());         this.value = (Value) ReflectionUtils.newInstance(reader.getValueClass(), fs.getConf());         this.offset = new SequenceFileReader.Offset(0, 0, 0);     }      public SequenceFileReader(FileSystem fs, Path file, Map conf, String offset)         throws IOException {         super(fs, file);         int bufferSize = !conf.containsKey(BUFFER_SIZE) ? DEFAULT_BUFF_SIZE : Integer.parseInt(conf.get(BUFFER_SIZE).toString());         this.offset = new SequenceFileReader.Offset(offset);         this.reader = new SequenceFile.Reader(fs.getConf(), SequenceFile.Reader.file(file), SequenceFile.Reader.bufferSize(bufferSize));         this.key = (Key) ReflectionUtils.newInstance(reader.getKeyClass(), fs.getConf());         this.value = (Value) ReflectionUtils.newInstance(reader.getValueClass(), fs.getConf());         skipToOffset(this.reader, this.offset, this.key);     }      private static  void skipToOffset(SequenceFile.Reader reader, Offset offset, K key) throws IOException {         reader.sync(offset.lastSyncPoint);         for (int i = 0; i &lt; offset.recordsSinceLastSync; ++i) {             reader.next(key);         }     }      public List next() throws IOException, ParseException {         if (reader.next(key, value)) {             ArrayList result = new ArrayList(2);             Collections.addAll(result, key, value);             offset.increment(reader.syncSeen(), reader.getPosition());             return result;         }         return null;     }      @Override     public void close() {         try {             reader.close();         } catch (IOException e) {             LOG.warn(&quot;Ignoring error when closing file &quot; + getFilePath(), e);         }     }      public Offset getFileOffset() {         return offset;     }       public static class Offset implements FileOffset {         public long lastSyncPoint;         public long recordsSinceLastSync;         public long currentRecord;         private long currRecordEndOffset;         private long prevRecordEndOffset;          public Offset(long lastSyncPoint, long recordsSinceLastSync, long currentRecord) {             this(lastSyncPoint, recordsSinceLastSync, currentRecord, 0, 0);         }          public Offset(long lastSyncPoint, long recordsSinceLastSync, long currentRecord             , long currRecordEndOffset, long prevRecordEndOffset) {             this.lastSyncPoint = lastSyncPoint;             this.recordsSinceLastSync = recordsSinceLastSync;             this.currentRecord = currentRecord;             this.prevRecordEndOffset = prevRecordEndOffset;             this.currRecordEndOffset = currRecordEndOffset;         }          public Offset(String offset) {             try {                 if (offset == null) {                     throw new IllegalArgumentException(&quot;offset cannot be null&quot;);                 }                 if (offset.equalsIgnoreCase(&quot;0&quot;)) {                     this.lastSyncPoint = 0;                     this.recordsSinceLastSync = 0;                     this.currentRecord = 0;                     this.prevRecordEndOffset = 0;                     this.currRecordEndOffset = 0;                 } else {                     String[] parts = offset.split(&quot;:&quot;);                     this.lastSyncPoint = Long.parseLong(parts[0].split(&quot;=&quot;)[1]);                     this.recordsSinceLastSync = Long.parseLong(parts[1].split(&quot;=&quot;)[1]);                     this.currentRecord = Long.parseLong(parts[2].split(&quot;=&quot;)[1]);                     this.prevRecordEndOffset = 0;                     this.currRecordEndOffset = 0;                 }             } catch (Exception e) {                 throw new IllegalArgumentException(&quot;'&quot; + offset +                                                    &quot;' cannot be interpreted. It is not in expected format for SequenceFileReader.&quot; +                                                    &quot; Format e.g. {sync=123:afterSync=345:record=67}&quot;);             }         }          @Override         public String toString() {             return '{' +                    &quot;sync=&quot; + lastSyncPoint +                    &quot;:afterSync=&quot; + recordsSinceLastSync +                    &quot;:record=&quot; + currentRecord +                    &quot;:}&quot;;         }          @Override         public boolean isNextOffset(FileOffset rhs) {             if (rhs instanceof Offset) {                 Offset other = ((Offset) rhs);                 return other.currentRecord &gt; currentRecord + 1;             }             return false;         }          @Override         public int compareTo(FileOffset o) {             Offset rhs = ((Offset) o);             if (currentRecord &lt; rhs.currentRecord) {                 return -1;             }             if (currentRecord == rhs.currentRecord) {                 return 0;             }             return 1;         }          @Override         public boolean equals(Object o) {             if (this == o) {                 return true;             }             if (!(o instanceof Offset)) {                 return false;             }              Offset offset = (Offset) o;              return currentRecord == offset.currentRecord;         }          @Override         public int hashCode() {             return (int) (currentRecord ^ (currentRecord &gt;&gt;&gt; 32));         }          void increment(boolean syncSeen, long newBytePosition) {             if (!syncSeen) {                 ++recordsSinceLastSync;             } else {                 recordsSinceLastSync = 1;                 lastSyncPoint = prevRecordEndOffset;             }             ++currentRecord;             prevRecordEndOffset = currRecordEndOffset;             currentRecord = newBytePosition;         }          @Override         public Offset clone() {             return new Offset(lastSyncPoint, recordsSinceLastSync, currentRecord, currRecordEndOffset, prevRecordEndOffset);         }      } //class Offset } //class</td>
    <td align="left">blob</td>
    <td align="left">1. long method, 2. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14125</td>
    <td align="left">https://github.com/apache/storm/blob/dc56e32f3dcdd9396a827a85029d60ed97474786/external/storm-hdfs/src/main/java/org/apache/storm/hdfs/spout/SequenceFileReader.java/#L28-L209</td>
    <td align="right">1</td>
    <td align="right">2319</td>
    <td align="right">14125</td>
  </tr>
  <tr valign="top">
    <td align="right">2385</td>
    <td align="left">&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;Long Method&quot;,     &quot;Blob&quot;,     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class _ConfigurationSettingsServiceSoapService     extends SOAP11Service     implements _ConfigurationSettingsServiceSoap {     private static final QName PORT_QNAME = new QName(                 &quot;http://schemas.microsoft.com/TeamFoundation/2005/06/WorkItemTracking/configurationSettingsService/03&quot;,                 &quot;ConfigurationSettingsServiceSoapService&quot;);     private static final String ENDPOINT_PATH = &quot;/tfs/DefaultCollection/WorkItemTracking/v1.0/ConfigurationSettingsService.asmx&quot;;      public _ConfigurationSettingsServiceSoapService(         final URI endpoint,         final QName port)     {         super(endpoint, port);     }      public _ConfigurationSettingsServiceSoapService(         final HttpClient client,         URI endpoint,         QName port)     {         super(client, endpoint, port);     }      /**      * @return the qualified name of the WSDL port this service implementation can be used with      */     public static QName getPortQName()     {         return _ConfigurationSettingsServiceSoapService.PORT_QNAME;     }      /**      * @return the path part to use when constructing a URI to contact a host that provides this service      */     public static String getEndpointPath()     {         return _ConfigurationSettingsServiceSoapService.ENDPOINT_PATH;     }      public String getWorkitemTrackingVersion()         throws TransportException, SOAPFault     {         final _ConfigurationSettingsServiceSoap_GetWorkitemTrackingVersion requestData = new _ConfigurationSettingsServiceSoap_GetWorkitemTrackingVersion();          final SOAPRequest request = createSOAPRequest(                 &quot;GetWorkitemTrackingVersion&quot;,                 new SOAPMethodRequestWriter()                 {                     public void writeSOAPRequest(                         final XMLStreamWriter writer,                         final OutputStream out)                         throws XMLStreamException, IOException                     {                         requestData.writeAsElement(                             writer,                             &quot;GetWorkitemTrackingVersion&quot;);                     }                 });          final _ConfigurationSettingsServiceSoap_GetWorkitemTrackingVersionResponse responseData = new _ConfigurationSettingsServiceSoap_GetWorkitemTrackingVersionResponse();          executeSOAPRequest(             request,             &quot;GetWorkitemTrackingVersionResponse&quot;,             new SOAPMethodResponseReader()             {                 public void readSOAPResponse(                     final XMLStreamReader reader,                     final InputStream in)                     throws XMLStreamException, IOException                 {                     responseData.readFromElement(reader);                 }             });          return responseData.getGetWorkitemTrackingVersionResult();     }      public long getMaxAttachmentSize()         throws TransportException, SOAPFault     {         final _ConfigurationSettingsServiceSoap_GetMaxAttachmentSize requestData = new _ConfigurationSettingsServiceSoap_GetMaxAttachmentSize();          final SOAPRequest request = createSOAPRequest(                 &quot;GetMaxAttachmentSize&quot;,                 new SOAPMethodRequestWriter()                 {                     public void writeSOAPRequest(                         final XMLStreamWriter writer,                         final OutputStream out)                         throws XMLStreamException, IOException                     {                         requestData.writeAsElement(                             writer,                             &quot;GetMaxAttachmentSize&quot;);                     }                 });          final _ConfigurationSettingsServiceSoap_GetMaxAttachmentSizeResponse responseData = new _ConfigurationSettingsServiceSoap_GetMaxAttachmentSizeResponse();          executeSOAPRequest(             request,             &quot;GetMaxAttachmentSizeResponse&quot;,             new SOAPMethodResponseReader()             {                 public void readSOAPResponse(                     final XMLStreamReader reader,                     final InputStream in)                     throws XMLStreamException, IOException                 {                     responseData.readFromElement(reader);                 }             });          return responseData.getGetMaxAttachmentSizeResult();     }      public void setMaxAttachmentSize(final long maxSize)         throws TransportException, SOAPFault     {         final _ConfigurationSettingsServiceSoap_SetMaxAttachmentSize requestData = new _ConfigurationSettingsServiceSoap_SetMaxAttachmentSize(                     maxSize);          final SOAPRequest request = createSOAPRequest(                 &quot;SetMaxAttachmentSize&quot;,                 new SOAPMethodRequestWriter()                 {                     public void writeSOAPRequest(                         final XMLStreamWriter writer,                         final OutputStream out)                         throws XMLStreamException, IOException                     {                         requestData.writeAsElement(                             writer,                             &quot;SetMaxAttachmentSize&quot;);                     }                 });          final _ConfigurationSettingsServiceSoap_SetMaxAttachmentSizeResponse responseData = new _ConfigurationSettingsServiceSoap_SetMaxAttachmentSizeResponse();          executeSOAPRequest(             request,             &quot;SetMaxAttachmentSizeResponse&quot;,             new SOAPMethodResponseReader()             {                 public void readSOAPResponse(                     final XMLStreamReader reader,                     final InputStream in)                     throws XMLStreamException, IOException                 {                     responseData.readFromElement(reader);                 }             });     }      public boolean getInProcBuildCompletionNotificationAvailability()         throws TransportException, SOAPFault     {         final _ConfigurationSettingsServiceSoap_GetInProcBuildCompletionNotificationAvailability requestData = new _ConfigurationSettingsServiceSoap_GetInProcBuildCompletionNotificationAvailability();          final SOAPRequest request = createSOAPRequest(                 &quot;GetInProcBuildCompletionNotificationAvailability&quot;,                 new SOAPMethodRequestWriter()                 {                     public void writeSOAPRequest(                         final XMLStreamWriter writer,                         final OutputStream out)                         throws XMLStreamException, IOException                     {                         requestData.writeAsElement(                             writer,                             &quot;GetInProcBuildCompletionNotificationAvailability&quot;);                     }                 });          final _ConfigurationSettingsServiceSoap_GetInProcBuildCompletionNotificationAvailabilityResponse responseData = new _ConfigurationSettingsServiceSoap_GetInProcBuildCompletionNotificationAvailabilityResponse();          executeSOAPRequest(             request,             &quot;GetInProcBuildCompletionNotificationAvailabilityResponse&quot;,             new SOAPMethodResponseReader()             {                 public void readSOAPResponse(                     final XMLStreamReader reader,                     final InputStream in)                     throws XMLStreamException, IOException                 {                     responseData.readFromElement(reader);                 }             });          return responseData.isGetInProcBuildCompletionNotificationAvailabilityResult();     }      public void setInProcBuildCompletionNotificationAvailability(final boolean isEnabled)         throws TransportException, SOAPFault     {         final _ConfigurationSettingsServiceSoap_SetInProcBuildCompletionNotificationAvailability requestData = new _ConfigurationSettingsServiceSoap_SetInProcBuildCompletionNotificationAvailability(                     isEnabled);          final SOAPRequest request = createSOAPRequest(                 &quot;SetInProcBuildCompletionNotificationAvailability&quot;,                 new SOAPMethodRequestWriter()                 {                     public void writeSOAPRequest(                         final XMLStreamWriter writer,                         final OutputStream out)                         throws XMLStreamException, IOException                     {                         requestData.writeAsElement(                             writer,                             &quot;SetInProcBuildCompletionNotificationAvailability&quot;);                     }                 });          final _ConfigurationSettingsServiceSoap_SetInProcBuildCompletionNotificationAvailabilityResponse responseData = new _ConfigurationSettingsServiceSoap_SetInProcBuildCompletionNotificationAvailabilityResponse();          executeSOAPRequest(             request,             &quot;SetInProcBuildCompletionNotificationAvailabilityResponse&quot;,             new SOAPMethodResponseReader()             {                 public void readSOAPResponse(                     final XMLStreamReader reader,                     final InputStream in)                     throws XMLStreamException, IOException                 {                     responseData.readFromElement(reader);                 }             });     }      public int getMaxBuildListSize()         throws TransportException, SOAPFault     {         final _ConfigurationSettingsServiceSoap_GetMaxBuildListSize requestData = new _ConfigurationSettingsServiceSoap_GetMaxBuildListSize();          final SOAPRequest request = createSOAPRequest(                 &quot;GetMaxBuildListSize&quot;,                 new SOAPMethodRequestWriter()                 {                     public void writeSOAPRequest(                         final XMLStreamWriter writer,                         final OutputStream out)                         throws XMLStreamException, IOException                     {                         requestData.writeAsElement(                             writer,                             &quot;GetMaxBuildListSize&quot;);                     }                 });          final _ConfigurationSettingsServiceSoap_GetMaxBuildListSizeResponse responseData = new _ConfigurationSettingsServiceSoap_GetMaxBuildListSizeResponse();          executeSOAPRequest(             request,             &quot;GetMaxBuildListSizeResponse&quot;,             new SOAPMethodResponseReader()             {                 public void readSOAPResponse(                     final XMLStreamReader reader,                     final InputStream in)                     throws XMLStreamException, IOException                 {                     responseData.readFromElement(reader);                 }             });          return responseData.getGetMaxBuildListSizeResult();     }      public void setMaxBuildListSize(final int maxBuildListSize)         throws TransportException, SOAPFault     {         final _ConfigurationSettingsServiceSoap_SetMaxBuildListSize requestData = new _ConfigurationSettingsServiceSoap_SetMaxBuildListSize(                     maxBuildListSize);          final SOAPRequest request = createSOAPRequest(                 &quot;SetMaxBuildListSize&quot;,                 new SOAPMethodRequestWriter()                 {                     public void writeSOAPRequest(                         final XMLStreamWriter writer,                         final OutputStream out)                         throws XMLStreamException, IOException                     {                         requestData.writeAsElement(                             writer,                             &quot;SetMaxBuildListSize&quot;);                     }                 });          final _ConfigurationSettingsServiceSoap_SetMaxBuildListSizeResponse responseData = new _ConfigurationSettingsServiceSoap_SetMaxBuildListSizeResponse();          executeSOAPRequest(             request,             &quot;SetMaxBuildListSizeResponse&quot;,             new SOAPMethodResponseReader()             {                 public void readSOAPResponse(                     final XMLStreamReader reader,                     final InputStream in)                     throws XMLStreamException, IOException                 {                     responseData.readFromElement(reader);                 }             });     }      public int getWorkItemQueryTimeout()         throws TransportException, SOAPFault     {         final _ConfigurationSettingsServiceSoap_GetWorkItemQueryTimeout requestData = new _ConfigurationSettingsServiceSoap_GetWorkItemQueryTimeout();          final SOAPRequest request = createSOAPRequest(                 &quot;GetWorkItemQueryTimeout&quot;,                 new SOAPMethodRequestWriter()                 {                     public void writeSOAPRequest(                         final XMLStreamWriter writer,                         final OutputStream out)                         throws XMLStreamException, IOException                     {                         requestData.writeAsElement(                             writer,                             &quot;GetWorkItemQueryTimeout&quot;);                     }                 });          final _ConfigurationSettingsServiceSoap_GetWorkItemQueryTimeoutResponse responseData = new _ConfigurationSettingsServiceSoap_GetWorkItemQueryTimeoutResponse();          executeSOAPRequest(             request,             &quot;GetWorkItemQueryTimeoutResponse&quot;,             new SOAPMethodResponseReader()             {                 public void readSOAPResponse(                     final XMLStreamReader reader,                     final InputStream in)                     throws XMLStreamException, IOException                 {                     responseData.readFromElement(reader);                 }             });          return responseData.getGetWorkItemQueryTimeoutResult();     }      public void setWorkItemQueryTimeout(final int workItemQueryTimeout)         throws TransportException, SOAPFault     {         final _ConfigurationSettingsServiceSoap_SetWorkItemQueryTimeout requestData = new _ConfigurationSettingsServiceSoap_SetWorkItemQueryTimeout(                     workItemQueryTimeout);          final SOAPRequest request = createSOAPRequest(                 &quot;SetWorkItemQueryTimeout&quot;,                 new SOAPMethodRequestWriter()                 {                     public void writeSOAPRequest(                         final XMLStreamWriter writer,                         final OutputStream out)                         throws XMLStreamException, IOException                     {                         requestData.writeAsElement(                             writer,                             &quot;SetWorkItemQueryTimeout&quot;);                     }                 });          final _ConfigurationSettingsServiceSoap_SetWorkItemQueryTimeoutResponse responseData = new _ConfigurationSettingsServiceSoap_SetWorkItemQueryTimeoutResponse();          executeSOAPRequest(             request,             &quot;SetWorkItemQueryTimeoutResponse&quot;,             new SOAPMethodResponseReader()             {                 public void readSOAPResponse(                     final XMLStreamReader reader,                     final InputStream in)                     throws XMLStreamException, IOException                 {                     responseData.readFromElement(reader);                 }             });     } }</td>
    <td align="left">blob</td>
    <td align="left">long method, blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method,  data class</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14347</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core.ws/generated-src/ms/tfs/workitemtracking/configurationsettingsservice/_03/_ConfigurationSettingsServiceSoapService.java/#L53-L439</td>
    <td align="right">1</td>
    <td align="right">2385</td>
    <td align="right">14347</td>
  </tr>
  <tr valign="top">
    <td align="right">2390</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Feature Envy&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    class Cel4rreg {          long seghigh;         long seglow;         int p_dsafmt = -1;         long p_dsaptr;         RegisterSet regs;          /**          * Creates the instance and attempts to locate the registers.          */         Cel4rreg() {             /* Debug option - before we do anything else, try using the old svcdump code */             String useSvcdump = System.getProperty(&quot;zebedee.use.svcdump&quot;);             if (useSvcdump != null &amp;&amp; useSvcdump.equals(&quot;true&quot;)) {                 getRegistersFromSvcdump();                 return;             }              /*              * Try and get the registers from the following locations:              *              * 1) RTM2 work area              * 2) BPXGMSTA service              * 3) linkage stack entries              * 4) TCB              * 5) Usta              *              * if any succeeds we return otherwise move to the next location.              */              int whereCount = 0;              try {                 if ((regs = getRegistersFromRTM2()) != null &amp;&amp; whereCount++ &gt;= whereSkip) {                     whereFound = &quot;RTM2&quot;;                     failingRegisters = regs;                     registers = regs;                     return;                 }             } catch (IOException e) {                 throw new Error(&quot;oops: &quot; + e);             }             /* If we still have not found a dsa, invoke kernel svs */             try {                 if ((regs = getRegistersFromBPXGMSTA()) != null &amp;&amp; whereCount++ &gt;= whereSkip) {                     whereFound = regs.whereFound();                     if (whereFound == null)                         whereFound = &quot;BPXGMSTA&quot;;                     if (tcb.tcbcmp() != 0)                         failingRegisters = regs;                     registers = regs;                     return;                 }             } catch (IOException e) {                 //throw new Error(&quot;oops: &quot; + e);             }             try {                 if ((regs = getRegistersFromLinkageStack()) != null &amp;&amp; whereCount++ &gt;= whereSkip) {                     whereFound = &quot;Linkage&quot;;                     if (tcb.tcbcmp() != 0)                         failingRegisters = regs;                     registers = regs;                     return;                 }             } catch (IOException e) {                 log.logp(Level.WARNING,&quot;com.ibm.j9ddr.corereaders.tdump.zebedee.le.Caa.Cel4rreg&quot;, &quot;Cel4rreg&quot;,&quot;Unexepected exception&quot;, e);                 throw new Error(&quot;Unexpected IOException: &quot; + e);             }             try {                 if ((regs = getRegistersFromTCB()) != null &amp;&amp; whereCount++ &gt;= whereSkip) {                     whereFound = &quot;TCB&quot;;                     if (tcb.tcbcmp() != 0)                         failingRegisters = regs;                     registers = regs;                     return;                 }             } catch (IOException e) {                 throw new Error(&quot;oops: &quot; + e);             }             try {                 if (is64bit) {                     /* This is from celqrreg.plx370: &quot;Get the save R4 from a NOSTACK call&quot; */                     long lca = CeexlaaTemplate.getCeelaa_lca64(inputStream, laa);                     p_dsaptr = CeelcaTemplate.getCeelca_savstack(inputStream, lca);                     log.fine(&quot;p_dsaptr from lca = &quot; + hex(p_dsaptr));                     p_dsafmt = stackdirection = CEECAASTACK_DOWN;                     if (validateDSA() == 0 &amp;&amp; whereCount++ &gt;= whereSkip) {                         whereFound = &quot;LCA&quot;;                         return;                     }                 }             } catch (IOException e) {                 throw new Error(&quot;oops: &quot; + e);             }             /* Last ditch */             try {                 if ((regs = getRegistersFromUsta()) != null &amp;&amp; whereCount++ &gt;= whereSkip) {                     whereFound = regs.whereFound();                     if (tcb.tcbcmp() != 0)                         failingRegisters = regs;                     registers = regs;                     return;                 }             } catch (IOException e) {             }             whereFound = &quot;not found&quot;;         }          /**          * Try and get the registers from the RTM2 work area. Returns null if none found. As a          * side-effect it also sets the stackdirection.          */         private RegisterSet getRegistersFromRTM2() throws IOException {             int level = ceecaalevel();             log.finer(&quot;caa level is &quot; + level);             /* If the CAA level is 13 or greater, get stack direction from               * CAA.  For older releases or the dummy CAA, default stack               * direction to UP.              */             if (is64bit) {                 /* Always use downstack in 64-bit mode? */                 stackdirection = CEECAASTACK_DOWN;                 log.finer(&quot;stack direction is down&quot;);             } else if (level &gt;= 13) { /* If LE 2.10 or higher */                 /* Obtain dsa format from the CAA */                 stackdirection = ceecaa_stackdirection();                 log.finer(&quot;stack direction is &quot; + (stackdirection == CEECAASTACK_UP ? &quot;up&quot; : &quot;down&quot;));             } else {                 stackdirection = CEECAASTACK_UP;                 log.finer(&quot;stack direction is up&quot;);             }             if ((stackdirection == CEECAASTACK_DOWN) &amp;&amp; !is64bit) {                 try {                     long tempptr = ceecaasmcb();			//the ceecaasmcb call is not currently supported for 64 bit CAAs                     seghigh = SmcbTemplate.getSmcb_dsbos(inputStream, tempptr);                     seglow = CeexstkhTemplate.getStkh_stackfloor(inputStream, seghigh);                 } catch (Exception e) {                     //throw new Error(&quot;oops: &quot; + e);                     return null;                 }             }             /* At this point, a valid CAA has been obtained. Access the RTM2 to obtain the DSA. */             long rtm2ptr = tcb.tcbrtwa();             if (rtm2ptr != 0) {                 try {                     log.finer(&quot;found some rtm2 registers&quot;);                     RegisterSet regs = new RegisterSet();                     long rtm2grs = rtm2ptr + Ihartm2aTemplate.getRtm2ereg$offset();                     long rtm2grshi = rtm2ptr + Ihartm2aTemplate.getRtm2g64h$offset();                     for (int i = 0; i &lt; 16; i++) {                         long low = space.readUnsignedInt(rtm2grs + i*4);                         long high = is64bit ? space.readUnsignedInt(rtm2grshi + i*4) : 0;                         regs.setRegister(i, (high &lt;&lt; 32) | low);                     }                     long rtm2psw = rtm2ptr + Ihartm2aTemplate.getRtm2apsw$offset();                     regs.setPSW(space.readLong(rtm2psw));                     if (registersValid(regs)) {                         log.finer(&quot;found good dsa in rtm2&quot;);                     } else {                         log.finer(&quot;bad dsa in rtm2&quot;);                         regs = null;                     }                     return regs;                 } catch (IOException e) {                     throw e;                 } catch (Exception e) {                     throw new Error(&quot;oops: &quot; + e);                 }             } else {                 log.finer(&quot;failed to get registers from rtm2&quot;);                 return null;             }         }          /**          * Validates the given register set with retry for down stack          */         private boolean registersValid(RegisterSet regs) throws IOException {             if (regs == null)                 return false;             p_dsafmt = stackdirection;             if (p_dsafmt == CEECAASTACK_DOWN) {                 p_dsaptr = regs.getRegisterAsAddress(4);                 log.finer(&quot;p_dsaptr from reg 4 = &quot; + hex(p_dsaptr));             } else {                 p_dsaptr = regs.getRegisterAsAddress(13);                 log.finer(&quot;p_dsaptr from reg 13 = &quot; + hex(p_dsaptr));             }             int lastrc = validateDSA();             if (lastrc == 0) {                 log.finer(&quot;found valid dsa&quot;);                 return true;             } else {                 if (stackdirection == CEECAASTACK_DOWN) {                     p_dsaptr = regs.getRegisterAsAddress(13);                     log.finer(&quot;p_dsaptr from reg 13 (again) = &quot; + hex(p_dsaptr));                     p_dsafmt = CEECAASTACK_UP;                     lastrc = validateDSA();                     if (lastrc == WARNING) {                         lastrc = validateDSA();                         if (lastrc == 0) {                             log.finer(&quot;found valid dsa&quot;);                             return true;                         }                     }                 }                 /* reset values */                 log.finer(&quot;p_dsaptr invalid so reset: &quot; + hex(p_dsaptr));                 p_dsaptr = 0;             }             return false;         }          /**          * Try and get the registers from the BPXGMSTA service.          */         private RegisterSet getRegistersFromBPXGMSTA() throws IOException {             RegisterSet regs = tcb.getRegistersFromBPXGMSTA();             if (is64bit)                 // celqrreg appears to always assume down stack                 stackdirection = CEECAASTACK_DOWN;             if (registersValid(regs)) {                 log.finer(&quot;found good dsa in BPXGMSTA&quot;);                 return regs;             } else {                 log.finer(&quot;BPX registers are invalid so keep looking&quot;);                 return null;             }         }          /**          * Try and get the registers from the linkage stack.          */         private RegisterSet getRegistersFromLinkageStack() throws IOException {             log.finer(&quot;enter getRegistersFromLinkageStack&quot;);             try {                 Lse[] linkageStack = tcb.getLinkageStack();                 /* If Linkage stack is empty, leave */                 if (linkageStack.length == 0) {                     log.finer(&quot;empty linkage stack&quot;);                     return null;                 }                 for (int i = 0; i &lt; linkageStack.length; i++) {                     Lse lse = linkageStack[i];                     if (lse.lses1pasn() == space.getAsid()) {                         RegisterSet regs = new RegisterSet();                         if (lse.isZArchitecture() &amp;&amp; (lse.lses1typ7() == Lse.LSED1PC || lse.lses1typ7() == Lse.LSED1BAKR)) {                             log.finer(&quot;found some z arch registers&quot;);                             regs.setPSW(lse.lses1pswh());                             for (int j = 0; j &lt; 16; j++) {                                 regs.setRegister(j, lse.lses1grs(j));                             }                         } else {                             log.finer(&quot;found some non z arch registers&quot;);                             regs.setPSW(lse.lsespsw());                             for (int j = 0; j &lt; 16; j++) {                                 regs.setRegister(j, lse.lsesgrs(j));                             }                         }                         if (registersValid(regs)) {                             log.finer(&quot;found good dsa in linkage stack&quot;);                             return regs;                         }                     } else {                         log.finer(&quot;different asid: &quot; + hex(lse.lses1pasn()));                     }                 }             } catch (IOException e) {                 throw e;             } catch (Exception e) {                 throw new Error(&quot;oops: &quot; + e);             }             log.finer(&quot;could not find registers in linkage stack&quot;);             return null;         }          /**          * Try and get the registers from the TCB.          */         private RegisterSet getRegistersFromTCB() throws IOException {             log.finer(&quot;getRegistersFromTCB&quot;);             RegisterSet regs = tcb.getRegisters();             if (registersValid(regs)) {                 log.finer(&quot;found good dsa in TCB&quot;);                 return regs;             } else {                 return null;             }         }          /**          * Try and get the registers from the Usta. Note that this is a kind of last-ditch          * thing and so no validation is done.          */         private RegisterSet getRegistersFromUsta() throws IOException {             log.fine(&quot;enter getRegistersFromUsta&quot;);             RegisterSet regs = tcb.getRegistersFromUsta();             if (registersValid(regs)) {                 log.finer(&quot;found good dsa in Usta&quot;);                 return regs;             } else {                 /* If there are more than three stack entries that's probably better than nothing */                 boolean isDownStack = stackdirection == CEECAASTACK_DOWN;                 long dsaptr;                 if (isDownStack) {                     dsaptr = regs.getRegister(4);                     log.finer(&quot;p_dsaptr from reg 4 = &quot; + hex(p_dsaptr));                 } else {                     dsaptr = regs.getRegister(13);                     log.finer(&quot;p_dsaptr from reg 13 = &quot; + hex(p_dsaptr));                 }                 try {                     DsaStackFrame dsa = new DsaStackFrame(dsaptr, isDownStack, regs, space, Caa.this);                     int count = 0;                     for (; dsa != null; dsa = dsa.getParentFrame()) {                     	if (++count &gt; 3) {                     		p_dsaptr = dsaptr;                     		p_dsafmt = stackdirection;                     		return regs;                     	}                     }                 } catch (IOException e) {                 } catch (AssertionError e) {                 }             }             return null;         }          /**          * Try and get the registers using the old svcdump code. This is for debugging          * purposes only. Uses reflection so there is no compilation dependency.          */         private void getRegistersFromSvcdump() {         }          /**          * Validate the given DSA. Returns 0 if valid. Note because this is Java, we can't          * modify the input parameters, so we use the instance variables instead and          * val_dsa == p_dsaptr, val_dsafmt == p_dsafmt.          */         private int validateDSA() {             log.finer(&quot;attempt to validate &quot; + hex(p_dsaptr) + &quot; on &quot; + (p_dsafmt == CEECAASTACK_DOWN ? &quot;down&quot; : &quot;up&quot;) + &quot; stack&quot;);             try {                 if (is64bit) {                     assert laa != 0;                     long l_sancptr = CeexlaaTemplate.getCeelaa_sanc64(inputStream, laa);                     assert l_sancptr != 0;                     long seghigh = CeexsancTemplate.getSanc_bos(inputStream, l_sancptr);                     long seglow = 0;                     long sanc_stack = CeexsancTemplate.getSanc_stack(inputStream, l_sancptr);                     long sanc_user_stack = CeexsancTemplate.getSanc_user_stack(inputStream, l_sancptr);                     if (sanc_stack == sanc_user_stack) {                         /* Get Stackfloor from sanc */                         seglow = CeexsancTemplate.getSanc_user_floor(inputStream, l_sancptr);                     } else {                         /* Get StackFloor from LAA */                         seglow = CeexlaaTemplate.getCeelaa_stackfloor64(inputStream, laa);                     }                     if (p_dsaptr &lt; seghigh &amp;&amp; (p_dsaptr + 0x800) &gt;= seglow &amp;&amp; (p_dsaptr &amp; 0xf) == 0) {                         log.finer(&quot;dsa &quot; + hex(p_dsaptr) + &quot; is within seglow = &quot; + hex(seglow) + &quot; seghigh = &quot; + hex(seghigh));                         return 0;                     } else {                         log.finer(&quot;dsa &quot; + hex(p_dsaptr) + &quot; is NOT within seglow = &quot; + hex(seglow) + &quot; seghigh = &quot; + hex(seghigh));                         return ERROR;                     }                 }                 if (p_dsafmt == CEECAASTACK_DOWN) {                     /* the check for being in the current segment is commented out */                 } else {                     if (is64bit)                         return ERROR;                     long tptr = ceecaaerrcm();                     /* Chicken egg situation */                     //assert !space.is64bit();                     /* If the input DSA address is within the HCOM and double word aligned,                       * assume that it is good. */                     if (p_dsaptr &lt; (tptr + hcomLength) &amp;&amp; p_dsaptr &gt;= tptr &amp;&amp; (p_dsaptr &amp; 7) == 0) {                         log.finer(&quot;upstack dsa &quot; + hex(p_dsaptr) + &quot; is inside hcom&quot;);                         return 0;                     }                 }                 long ddsa = ceecaaddsa();                 long dsaptr = p_dsaptr;                 int dsafmt8 = p_dsafmt;                 long slowdsaptr = p_dsaptr;                 int slowdsafmt8 = p_dsafmt;                 for (boolean slow = false;; slow = !slow) {                     Ceexdsaf dsaf = new Ceexdsaf(space, dsaptr, dsafmt8, is64bit);                     /* If the stack direction is down but we are validating an upstack DSA                      * and the current DSA is inside the current segment of the down stack,                      * assume this must be a OS_NOSTACK call, return WARNING and replace                      * input DSA and DSAFmt with R4 value from this DSA */                     log.finer(&quot;looping with dsa = &quot; + hex(dsaptr));                     if (stackdirection == CEECAASTACK_DOWN &amp;&amp; p_dsafmt == CEECAASTACK_UP &amp;&amp;                             dsaptr &lt; seghigh &amp;&amp; dsaptr &gt;= seglow) {                         p_dsaptr = CeedsaTemplate.getCeedsar4(inputStream, dsaptr);                         p_dsafmt = CEECAASTACK_DOWN;                         log.finer(&quot;warning, try switching to down stack&quot;);                         return WARNING;                     }                     long callers_dsaptr = dsaf.DSA_Prev;                     dsafmt8 = dsaf.DSA_Format;                     /* If we are not able to backchain any farther or we have encountered                      * a linkage stack, assume that the input DSA address is bad. */                     if (callers_dsaptr == 0 || callers_dsaptr == F1SA) {                         log.finer(&quot;cannot backchain futher because &quot; + (callers_dsaptr == 0 ? &quot;zero&quot; : &quot;linkage stack&quot;) + &quot; found&quot;);                         return ERROR;                     }                     /* If we were able to backchain to the dummy DSA, the input DSA address                      * must be good. */                     if (callers_dsaptr == ddsa) {                         log.finer(&quot;dummy dsa reached&quot;);                         return 0;                     }                     /* If we backchained across a stack transition, assume that the input                      * DSA address is good. */                     if (dsafmt8 != p_dsafmt) {                         log.finer(&quot;backchained across a stack transition&quot;);                         return 0;                     }                     /* If we have located an upstack DSA with a valid NAB value, assume that                      * the input DSA address is good. */                     if (dsafmt8 == CEECAASTACK_UP) {                         long tptr = CeedsaTemplate.getCeedsanab(inputStream, callers_dsaptr);                         if (tptr == dsaptr) {                             log.finer(&quot;upstack DSA is good&quot;);                             return 0;                         }                     }                     dsaptr = callers_dsaptr;                     /* We use the Tortoise and the Hare algorithm to detect loops. If the slow                      * iterator is lapped it means there is a loop. */                     if (slow) {                         dsaf = new Ceexdsaf(space, slowdsaptr, slowdsafmt8, is64bit);                         slowdsaptr = dsaf.DSA_Prev;                         slowdsafmt8 = dsaf.DSA_Format;                     }                     if (dsaptr == slowdsaptr) {                         log.finer(&quot;loop detected in DSA chain&quot;);                         return ERROR;                     }                 }             } catch (IOException e) {                 /* Any bad read means the DSA was invalid */                 log.logp(Level.FINER,&quot;com.ibm.j9ddr.corereaders.tdump.zebedee.le.Caa.Cel4rreg&quot;, &quot;validateDSA&quot;,&quot;Bad read&quot;, e);                 return ERROR;             } catch (Exception e) {                 log.logp(Level.WARNING,&quot;com.ibm.j9ddr.corereaders.tdump.zebedee.le.Caa.Cel4rreg&quot;, &quot;validateDSA&quot;,&quot;Unexepected exception&quot;, e);                 throw new Error(&quot;Unexpected Exception:: &quot; + e);             }         }     }</td>
    <td align="left">blob</td>
    <td align="left">blob, feature envy, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;feature envy,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14359</td>
    <td align="left">https://github.com/eclipse/openj9/blob/4911084853eb75b20e037c434ad4521b7317ebfb/debugtools/DDR_VM/src/com/ibm/j9ddr/corereaders/tdump/zebedee/le/Caa.java/#L348-L800</td>
    <td align="right">1</td>
    <td align="right">2390</td>
    <td align="right">14359</td>
  </tr>
  <tr valign="top">
    <td align="right">2424</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells the bad smells are: 1. Blob, 2. Long Method&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DataSourceLoginService extends AbstractLoginService {     private static final Logger LOG = Log.getLogger(DataSourceLoginService.class);      private String _jndiName = &quot;javax.sql.DataSource/default&quot;;     private DataSource _datasource;     private Server _server;     private String _userTableName = &quot;users&quot;;     private String _userTableKey = &quot;id&quot;;     private String _userTableUserField = &quot;username&quot;;     private String _userTablePasswordField = &quot;pwd&quot;;     private String _roleTableName = &quot;roles&quot;;     private String _roleTableKey = &quot;id&quot;;     private String _roleTableRoleField = &quot;role&quot;;     private String _userRoleTableName = &quot;user_roles&quot;;     private String _userRoleTableUserKey = &quot;user_id&quot;;     private String _userRoleTableRoleKey = &quot;role_id&quot;;     private String _userSql;     private String _roleSql;     private boolean _createTables = false;               /**      * DBUser      */     public class DBUserPrincipal extends UserPrincipal     {         private int _key;                  public DBUserPrincipal(String name, Credential credential, int key)         {             super(name, credential);             _key = key;         }                  public int getKey ()         {             return _key;         }              }      /* ------------------------------------------------------------ */     public DataSourceLoginService()     {     }      /* ------------------------------------------------------------ */     public DataSourceLoginService(String name)     {         setName(name);     }      /* ------------------------------------------------------------ */     public DataSourceLoginService(String name, IdentityService identityService)     {         setName(name);         setIdentityService(identityService);     }      /* ------------------------------------------------------------ */     public void setJndiName (String jndi)     {         _jndiName = jndi;     }      /* ------------------------------------------------------------ */     public String getJndiName ()     {         return _jndiName;     }      /* ------------------------------------------------------------ */     public void setServer (Server server)     {         _server=server;     }      /* ------------------------------------------------------------ */     public Server getServer()     {         return _server;     }      /* ------------------------------------------------------------ */     public void setCreateTables(boolean createTables)     {         _createTables = createTables;     }      /* ------------------------------------------------------------ */     public boolean getCreateTables()     {         return _createTables;     }      /* ------------------------------------------------------------ */     public void setUserTableName (String name)     {         _userTableName=name;     }      /* ------------------------------------------------------------ */     public String getUserTableName()     {         return _userTableName;     }      /* ------------------------------------------------------------ */     public String getUserTableKey()     {         return _userTableKey;     }       /* ------------------------------------------------------------ */     public void setUserTableKey(String tableKey)     {         _userTableKey = tableKey;     }       /* ------------------------------------------------------------ */     public String getUserTableUserField()     {         return _userTableUserField;     }       /* ------------------------------------------------------------ */     public void setUserTableUserField(String tableUserField)     {         _userTableUserField = tableUserField;     }       /* ------------------------------------------------------------ */     public String getUserTablePasswordField()     {         return _userTablePasswordField;     }       /* ------------------------------------------------------------ */     public void setUserTablePasswordField(String tablePasswordField)     {         _userTablePasswordField = tablePasswordField;     }       /* ------------------------------------------------------------ */     public String getRoleTableName()     {         return _roleTableName;     }       /* ------------------------------------------------------------ */     public void setRoleTableName(String tableName)     {         _roleTableName = tableName;     }       /* ------------------------------------------------------------ */     public String getRoleTableKey()     {         return _roleTableKey;     }       /* ------------------------------------------------------------ */     public void setRoleTableKey(String tableKey)     {         _roleTableKey = tableKey;     }       /* ------------------------------------------------------------ */     public String getRoleTableRoleField()     {         return _roleTableRoleField;     }       /* ------------------------------------------------------------ */     public void setRoleTableRoleField(String tableRoleField)     {         _roleTableRoleField = tableRoleField;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableName()     {         return _userRoleTableName;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableName(String roleTableName)     {         _userRoleTableName = roleTableName;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableUserKey()     {         return _userRoleTableUserKey;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableUserKey(String roleTableUserKey)     {         _userRoleTableUserKey = roleTableUserKey;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableRoleKey()     {         return _userRoleTableRoleKey;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableRoleKey(String roleTableRoleKey)     {         _userRoleTableRoleKey = roleTableRoleKey;     }              /* ------------------------------------------------------------ */     @Override     public UserPrincipal loadUserInfo (String username)     {         try         {             try (Connection connection = getConnection();                     PreparedStatement statement1 = connection.prepareStatement(_userSql))             {                 statement1.setObject(1, username);                 try (ResultSet rs1 = statement1.executeQuery())                 {                     if (rs1.next())                     {                         int key = rs1.getInt(_userTableKey);                         String credentials = rs1.getString(_userTablePasswordField);                                                  return new DBUserPrincipal(username, Credential.getCredential(credentials), key);                     }                 }             }         }         catch (NamingException e)         {             LOG.warn(&quot;No datasource for &quot;+_jndiName, e);         }         catch (SQLException e)         {             LOG.warn(&quot;Problem loading user info for &quot;+username, e);         }         return null;     }               /* ------------------------------------------------------------ */     @Override     public String[] loadRoleInfo (UserPrincipal user)     {         DBUserPrincipal dbuser = (DBUserPrincipal)user;          try         {             try (Connection connection = getConnection();                     PreparedStatement statement2 = connection.prepareStatement(_roleSql))             {                  List roles = new ArrayList();                  statement2.setInt(1, dbuser.getKey());                 try (ResultSet rs2 = statement2.executeQuery())                 {                     while (rs2.next())                     {                         roles.add(rs2.getString(_roleTableRoleField));                     }                                          return roles.toArray(new String[roles.size()]);                 }             }         }         catch (NamingException e)         {             LOG.warn(&quot;No datasource for &quot;+_jndiName, e);         }         catch (SQLException e)         {             LOG.warn(&quot;Problem loading user info for &quot;+user.getName(), e);         }         return null;     }             /* ------------------------------------------------------------ */     /**      * Lookup the datasource for the jndiName and formulate the      * necessary sql query strings based on the configured table      * and column names.      *      * @throws NamingException if unable to init jndi      * @throws SQLException if unable to init database      */     public void initDb() throws NamingException, SQLException     {         if (_datasource != null)             return;          @SuppressWarnings(&quot;unused&quot;)         InitialContext ic = new InitialContext();         assert ic!=null;          // TODO Should we try webapp scope too?          // try finding the datasource in the Server scope         if (_server != null)         {             try             {                 _datasource = (DataSource)NamingEntryUtil.lookup(_server, _jndiName);             }             catch (NameNotFoundException e)             {                 //next try the jvm scope             }         }           //try finding the datasource in the jvm scope         if (_datasource==null)         {             _datasource = (DataSource)NamingEntryUtil.lookup(null, _jndiName);         }          // set up the select statements based on the table and column names configured         _userSql = &quot;select &quot; + _userTableKey + &quot;,&quot; + _userTablePasswordField                   + &quot; from &quot; + _userTableName                   + &quot; where &quot;+ _userTableUserField + &quot; = ?&quot;;          _roleSql = &quot;select r.&quot; + _roleTableRoleField                   + &quot; from &quot; + _roleTableName + &quot; r, &quot; + _userRoleTableName                   + &quot; u where u.&quot;+ _userRoleTableUserKey + &quot; = ?&quot;                   + &quot; and r.&quot; + _roleTableKey + &quot; = u.&quot; + _userRoleTableRoleKey;          prepareTables();     }      /* ------------------------------------------------------------ */     /**      * @throws NamingException      * @throws SQLException      */     private void prepareTables()     throws NamingException, SQLException     {         if (_createTables)         {             boolean autocommit = true;             Connection connection = getConnection();             try (Statement stmt = connection.createStatement())             {                 autocommit = connection.getAutoCommit();                 connection.setAutoCommit(false);                 DatabaseMetaData metaData = connection.getMetaData();                  //check if tables exist                 String tableName = (metaData.storesLowerCaseIdentifiers()? _userTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userTableName.toUpperCase(Locale.ENGLISH): _userTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //user table default                         /*                          * create table _userTableName (_userTableKey integer,                          * _userTableUserField varchar(100) not null unique,                          * _userTablePasswordField varchar(20) not null, primary key(_userTableKey));                          */                         stmt.executeUpdate(&quot;create table &quot;+_userTableName+ &quot;(&quot;+_userTableKey+&quot; integer,&quot;+                                 _userTableUserField+&quot; varchar(100) not null unique,&quot;+                                 _userTablePasswordField+&quot; varchar(20) not null, primary key(&quot;+_userTableKey+&quot;))&quot;);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_userTableName);                     }                 }                  tableName = (metaData.storesLowerCaseIdentifiers()? _roleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_roleTableName.toUpperCase(Locale.ENGLISH): _roleTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //role table default                         /*                          * create table _roleTableName (_roleTableKey integer,                          * _roleTableRoleField varchar(100) not null unique, primary key(_roleTableKey));                          */                         String str = &quot;create table &quot;+_roleTableName+&quot; (&quot;+_roleTableKey+&quot; integer, &quot;+                         _roleTableRoleField+&quot; varchar(100) not null unique, primary key(&quot;+_roleTableKey+&quot;))&quot;;                         stmt.executeUpdate(str);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_roleTableName);                     }                 }                  tableName = (metaData.storesLowerCaseIdentifiers()? _userRoleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userRoleTableName.toUpperCase(Locale.ENGLISH): _userRoleTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //user-role table                         /*                          * create table _userRoleTableName (_userRoleTableUserKey integer,                          * _userRoleTableRoleKey integer,                          * primary key (_userRoleTableUserKey, _userRoleTableRoleKey));                          *                          * create index idx_user_role on _userRoleTableName (_userRoleTableUserKey);                          */                         stmt.executeUpdate(&quot;create table &quot;+_userRoleTableName+&quot; (&quot;+_userRoleTableUserKey+&quot; integer, &quot;+                                 _userRoleTableRoleKey+&quot; integer, &quot;+                                 &quot;primary key (&quot;+_userRoleTableUserKey+&quot;, &quot;+_userRoleTableRoleKey+&quot;))&quot;);                         stmt.executeUpdate(&quot;create index indx_user_role on &quot;+_userRoleTableName+&quot;(&quot;+_userRoleTableUserKey+&quot;)&quot;);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_userRoleTableName +&quot; and index&quot;);                     }                 }                 connection.commit();             }             finally             {                 try                 {                     connection.setAutoCommit(autocommit);                 }                 catch (SQLException e)                 {                     if (LOG.isDebugEnabled()) LOG.debug(&quot;Prepare tables&quot;, e);                 }                 finally                 {                     try                     {                         connection.close();                     }                     catch (SQLException e)                     {                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Prepare tables&quot;, e);                     }                 }             }         }         else if (LOG.isDebugEnabled())         {             LOG.debug(&quot;createTables false&quot;);         }     }      /* ------------------------------------------------------------ */     /**      * @return      * @throws NamingException      * @throws SQLException      */     private Connection getConnection ()     throws NamingException, SQLException     {         initDb();         return _datasource.getConnection();     } }</td>
    <td align="left">blob</td>
    <td align="left">1. blob, 2. long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp;2. long method</td>
    <td align="right">0</td>
    <td align="right">14443</td>
    <td align="left">https://github.com/eclipse/jetty.project/blob/65528f76c5ef6ddca11385f9721c8f0bc5f2eed7/jetty-plus/src/main/java/org/eclipse/jetty/plus/security/DataSourceLoginService.java/#L52-L530</td>
    <td align="right">1</td>
    <td align="right">2424</td>
    <td align="right">14443</td>
  </tr>
  <tr valign="top">
    <td align="right">2433</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;the bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class ExternalLoadBalancerDeviceManagerImpl extends AdapterBase implements ExternalLoadBalancerDeviceManager, ResourceStateAdapter {      @Inject     NetworkExternalLoadBalancerDao _networkExternalLBDao;     @Inject     ExternalLoadBalancerDeviceDao _externalLoadBalancerDeviceDao;     @Inject     HostDao _hostDao;     @Inject     DataCenterDao _dcDao;     @Inject     NetworkModel _networkModel;     @Inject     NetworkOrchestrationService _networkMgr;     @Inject     InlineLoadBalancerNicMapDao _inlineLoadBalancerNicMapDao;     @Inject     NicDao _nicDao;     @Inject     AgentManager _agentMgr;     @Inject     ResourceManager _resourceMgr;     @Inject     IPAddressDao _ipAddressDao;     @Inject     VlanDao _vlanDao;     @Inject     NetworkOfferingDao _networkOfferingDao;     @Inject     AccountDao _accountDao;     @Inject     PhysicalNetworkDao _physicalNetworkDao;     @Inject     PhysicalNetworkServiceProviderDao _physicalNetworkServiceProviderDao;     @Inject     AccountManager _accountMgr;     @Inject     UserStatisticsDao _userStatsDao;     @Inject     NetworkDao _networkDao;     @Inject     DomainRouterDao _routerDao;     @Inject     LoadBalancerDao _loadBalancerDao;     @Inject     PortForwardingRulesDao _portForwardingRulesDao;     @Inject     ConfigurationDao _configDao;     @Inject     HostDetailsDao _hostDetailDao;     @Inject     NetworkExternalLoadBalancerDao _networkLBDao;     @Inject     NetworkServiceMapDao _ntwkSrvcProviderDao;     @Inject     NetworkExternalFirewallDao _networkExternalFirewallDao;     @Inject     ExternalFirewallDeviceDao _externalFirewallDeviceDao;     @Inject     protected HostPodDao _podDao = null;     @Inject     IpAddressManager _ipAddrMgr;     @Inject     protected     VirtualMachineManager _itMgr;     @Inject     VMInstanceDao _vmDao;     @Inject     VMTemplateDao _templateDao;     @Inject     ServiceOfferingDao _serviceOfferingDao;     @Inject     PhysicalNetworkServiceProviderDao _physicalProviderDao;     @Inject     VirtualRouterProviderDao _vrProviderDao;      private long _defaultLbCapacity;     private static final org.apache.log4j.Logger s_logger = Logger.getLogger(ExternalLoadBalancerDeviceManagerImpl.class);      @Override     @DB     public ExternalLoadBalancerDeviceVO addExternalLoadBalancer(long physicalNetworkId, String url, String username, String password, final String deviceName,         ServerResource resource, final boolean gslbProvider, final boolean exclusiveGslbProivider,         final String gslbSitePublicIp, final String gslbSitePrivateIp) {          PhysicalNetworkVO pNetwork = null;         final NetworkDevice ntwkDevice = NetworkDevice.getNetworkDevice(deviceName);         long zoneId;          if ((ntwkDevice == null) || (url == null) || (username == null) || (resource == null) || (password == null)) {             throw new InvalidParameterValueException(&quot;Atleast one of the required parameters (url, username, password,&quot;                 + &quot; server resource, zone id/physical network id) is not specified or a valid parameter.&quot;);         }          pNetwork = _physicalNetworkDao.findById(physicalNetworkId);         if (pNetwork == null) {             throw new InvalidParameterValueException(&quot;Could not find phyical network with ID: &quot; + physicalNetworkId);         }          zoneId = pNetwork.getDataCenterId();         PhysicalNetworkServiceProviderVO ntwkSvcProvider =             _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), ntwkDevice.getNetworkServiceProvder());          ntwkSvcProvider = _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), ntwkDevice.getNetworkServiceProvder());         if (ntwkSvcProvider == null) {             throw new CloudRuntimeException(&quot;Network Service Provider: &quot; + ntwkDevice.getNetworkServiceProvder() + &quot; is not enabled in the physical network: &quot; +                 physicalNetworkId + &quot;to add this device&quot;);         } else if (ntwkSvcProvider.getState() == PhysicalNetworkServiceProvider.State.Shutdown) {             throw new CloudRuntimeException(&quot;Network Service Provider: &quot; + ntwkSvcProvider.getProviderName() + &quot; is in shutdown state in the physical network: &quot; +                 physicalNetworkId + &quot;to add this device&quot;);         }          if (gslbProvider) {             ExternalLoadBalancerDeviceVO zoneGslbProvider =                 _externalLoadBalancerDeviceDao.findGslbServiceProvider(physicalNetworkId, ntwkDevice.getNetworkServiceProvder());             if (zoneGslbProvider != null) {                 throw new CloudRuntimeException(&quot;There is a GSLB service provider configured in the zone alredy.&quot;);             }         }          URI uri;         try {             uri = new URI(url);         } catch (Exception e) {             s_logger.debug(e);             throw new InvalidParameterValueException(e.getMessage());         }          String ipAddress = uri.getHost();         Map hostDetails = new HashMap();         String hostName = getExternalLoadBalancerResourceGuid(pNetwork.getId(), deviceName, ipAddress);         hostDetails.put(&quot;name&quot;, hostName);         hostDetails.put(&quot;guid&quot;, UUID.randomUUID().toString());         hostDetails.put(&quot;zoneId&quot;, String.valueOf(pNetwork.getDataCenterId()));         hostDetails.put(&quot;ip&quot;, ipAddress);         hostDetails.put(&quot;physicalNetworkId&quot;, String.valueOf(pNetwork.getId()));         hostDetails.put(&quot;username&quot;, username);         hostDetails.put(&quot;password&quot;, password);         hostDetails.put(&quot;deviceName&quot;, deviceName);          // leave parameter validation to be part server resource configure         Map configParams = new HashMap();         UrlUtil.parseQueryParameters(uri.getQuery(), false, configParams);         hostDetails.putAll(configParams);          try {             resource.configure(hostName, hostDetails);              final Host host = _resourceMgr.addHost(zoneId, resource, Host.Type.ExternalLoadBalancer, hostDetails);             if (host != null) {                  final boolean dedicatedUse =                     (configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_DEDICATED) != null) ? Boolean.parseBoolean(configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_DEDICATED))                         : false;                 long capacity = NumbersUtil.parseLong(configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_CAPACITY), 0);                 if (capacity == 0) {                     capacity = _defaultLbCapacity;                 }                  final long capacityFinal = capacity;                 final PhysicalNetworkVO pNetworkFinal = pNetwork;                 return Transaction.execute(new TransactionCallback() {                     @Override                     public ExternalLoadBalancerDeviceVO doInTransaction(TransactionStatus status) {                         ExternalLoadBalancerDeviceVO lbDeviceVO =                             new ExternalLoadBalancerDeviceVO(host.getId(), pNetworkFinal.getId(), ntwkDevice.getNetworkServiceProvder(), deviceName, capacityFinal,                                 dedicatedUse, gslbProvider);                         if (gslbProvider) {                             lbDeviceVO.setGslbSitePublicIP(gslbSitePublicIp);                             lbDeviceVO.setGslbSitePrivateIP(gslbSitePrivateIp);                             lbDeviceVO.setExclusiveGslbProvider(exclusiveGslbProivider);                         }                         _externalLoadBalancerDeviceDao.persist(lbDeviceVO);                         DetailVO hostDetail = new DetailVO(host.getId(), ApiConstants.LOAD_BALANCER_DEVICE_ID, String.valueOf(lbDeviceVO.getId()));                         _hostDetailDao.persist(hostDetail);                          return lbDeviceVO;                     }                 });             } else {                 throw new CloudRuntimeException(&quot;Failed to add load balancer device due to internal error.&quot;);             }         } catch (ConfigurationException e) {             throw new CloudRuntimeException(e.getMessage());         }     }      @Override     public boolean deleteExternalLoadBalancer(long hostId) {         HostVO externalLoadBalancer = _hostDao.findById(hostId);         if (externalLoadBalancer == null) {             throw new InvalidParameterValueException(&quot;Could not find an external load balancer with ID: &quot; + hostId);         }          DetailVO lbHostDetails = _hostDetailDao.findDetail(hostId, ApiConstants.LOAD_BALANCER_DEVICE_ID);         long lbDeviceId = Long.parseLong(lbHostDetails.getValue());          ExternalLoadBalancerDeviceVO lbDeviceVo = _externalLoadBalancerDeviceDao.findById(lbDeviceId);         if (lbDeviceVo.getAllocationState() == LBDeviceAllocationState.Provider) {             // check if cloudstack has provisioned any load balancer appliance on the device before deleting             List lbDevices = _externalLoadBalancerDeviceDao.listAll();             if (lbDevices != null) {                 for (ExternalLoadBalancerDeviceVO lbDevice : lbDevices) {                     if (lbDevice.getParentHostId() == hostId) {                         throw new CloudRuntimeException(                             &quot;This load balancer device can not be deleted as there are one or more load balancers applainces provisioned by cloudstack on the device.&quot;);                     }                 }             }         } else {             // check if any networks are using this load balancer device             List networks = _networkLBDao.listByLoadBalancerDeviceId(lbDeviceId);             if ((networks != null) &amp;&amp; !networks.isEmpty()) {                 throw new CloudRuntimeException(&quot;Delete can not be done as there are networks using this load balancer device &quot;);             }         }          try {             // put the host in maintenance state in order for it to be deleted             externalLoadBalancer.setResourceState(ResourceState.Maintenance);             _hostDao.update(hostId, externalLoadBalancer);             _resourceMgr.deleteHost(hostId, false, false);              // delete the external load balancer entry             _externalLoadBalancerDeviceDao.remove(lbDeviceId);              return true;         } catch (Exception e) {             s_logger.debug(e);             return false;         }     }      @Override     public List listExternalLoadBalancers(long physicalNetworkId, String deviceName) {         List lbHosts = new ArrayList();         NetworkDevice lbNetworkDevice = NetworkDevice.getNetworkDevice(deviceName);         PhysicalNetworkVO pNetwork = null;          pNetwork = _physicalNetworkDao.findById(physicalNetworkId);          if ((pNetwork == null) || (lbNetworkDevice == null)) {             throw new InvalidParameterValueException(&quot;Atleast one of the required parameter physical networkId, device name is invalid.&quot;);         }          PhysicalNetworkServiceProviderVO ntwkSvcProvider =             _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), lbNetworkDevice.getNetworkServiceProvder());         // if provider not configured in to physical network, then there can be no instances         if (ntwkSvcProvider == null) {             return null;         }          List lbDevices =             _externalLoadBalancerDeviceDao.listByPhysicalNetworkAndProvider(physicalNetworkId, ntwkSvcProvider.getProviderName());         for (ExternalLoadBalancerDeviceVO provderInstance : lbDevices) {             lbHosts.add(_hostDao.findById(provderInstance.getHostId()));         }         return lbHosts;     }      public ExternalLoadBalancerResponse createExternalLoadBalancerResponse(Host externalLoadBalancer) {         Map lbDetails = _hostDetailDao.findDetails(externalLoadBalancer.getId());         ExternalLoadBalancerResponse response = new ExternalLoadBalancerResponse();         response.setId(externalLoadBalancer.getUuid());         response.setIpAddress(externalLoadBalancer.getPrivateIpAddress());         response.setUsername(lbDetails.get(&quot;username&quot;));         response.setPublicInterface(lbDetails.get(&quot;publicInterface&quot;));         response.setPrivateInterface(lbDetails.get(&quot;privateInterface&quot;));         response.setNumRetries(lbDetails.get(&quot;numRetries&quot;));         return response;     }      public String getExternalLoadBalancerResourceGuid(long physicalNetworkId, String deviceName, String ip) {         return physicalNetworkId + &quot;-&quot; + deviceName + &quot;-&quot; + ip;     }      @Override     public ExternalLoadBalancerDeviceVO getExternalLoadBalancerForNetwork(Network network) {         NetworkExternalLoadBalancerVO lbDeviceForNetwork = _networkExternalLBDao.findByNetworkId(network.getId());         if (lbDeviceForNetwork != null) {             long lbDeviceId = lbDeviceForNetwork.getExternalLBDeviceId();             ExternalLoadBalancerDeviceVO lbDeviceVo = _externalLoadBalancerDeviceDao.findById(lbDeviceId);             assert (lbDeviceVo != null);             return lbDeviceVo;         }         return null;     }      public void setExternalLoadBalancerForNetwork(Network network, long externalLBDeviceID) {         NetworkExternalLoadBalancerVO lbDeviceForNetwork = new NetworkExternalLoadBalancerVO(network.getId(), externalLBDeviceID);         _networkExternalLBDao.persist(lbDeviceForNetwork);     }      @DB     protected ExternalLoadBalancerDeviceVO allocateLoadBalancerForNetwork(final Network guestConfig) throws InsufficientCapacityException {         boolean retry = true;         boolean tryLbProvisioning = false;         ExternalLoadBalancerDeviceVO lbDevice = null;         long physicalNetworkId = guestConfig.getPhysicalNetworkId();         NetworkOfferingVO offering = _networkOfferingDao.findById(guestConfig.getNetworkOfferingId());         String provider = _ntwkSrvcProviderDao.getProviderForServiceInNetwork(guestConfig.getId(), Service.Lb);          while (retry) {             GlobalLock deviceMapLock = GlobalLock.getInternLock(&quot;LoadBalancerAllocLock&quot;);             try {                 if (deviceMapLock.lock(120)) {                     try {                         final boolean dedicatedLB = offering.isDedicatedLB(); // does network offering supports a dedicated load balancer?                          try {                             lbDevice = Transaction.execute(new TransactionCallbackWithException() {                                 @Override                                 public ExternalLoadBalancerDeviceVO doInTransaction(TransactionStatus status) throws InsufficientCapacityException {                                     // FIXME: should the device allocation be done during network implement phase or do a                                     // lazy allocation when first rule for the network is configured??                                      // find a load balancer device for this network as per the network offering                                     ExternalLoadBalancerDeviceVO lbDevice = findSuitableLoadBalancerForNetwork(guestConfig, dedicatedLB);                                     long lbDeviceId = lbDevice.getId();                                      // persist the load balancer device id that will be used for this network. Once a network                                     // is implemented on a LB device then later on all rules will be programmed on to same device                                     NetworkExternalLoadBalancerVO networkLB = new NetworkExternalLoadBalancerVO(guestConfig.getId(), lbDeviceId);                                     _networkExternalLBDao.persist(networkLB);                                      // mark device to be either dedicated or shared use                                     lbDevice.setAllocationState(dedicatedLB ? LBDeviceAllocationState.Dedicated : LBDeviceAllocationState.Shared);                                     _externalLoadBalancerDeviceDao.update(lbDeviceId, lbDevice);                                     return lbDevice;                                 }                             });                              // allocated load balancer for the network, so skip retry                             tryLbProvisioning = false;                             retry = false;                         } catch (InsufficientCapacityException exception) {                             // if already attempted to provision load balancer then throw out of capacity exception,                             if (tryLbProvisioning) {                                 retry = false;                                 // TODO: throwing warning instead of error for now as its possible another provider can service this network                                 s_logger.warn(&quot;There are no load balancer device with the capacity for implementing this network&quot;);                                 throw exception;                             } else {                                 tryLbProvisioning = true; // if possible provision a LB appliance in to the physical network                             }                         }                     } finally {                         deviceMapLock.unlock();                     }                 }             } finally {                 deviceMapLock.releaseRef();             }              // there are no LB devices or there is no free capacity on the devices in the physical network so provision a new LB appliance             if (tryLbProvisioning) {                 // check if LB appliance can be dynamically provisioned                 List providerLbDevices =                     _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Provider);                 if ((providerLbDevices != null) &amp;&amp; (!providerLbDevices.isEmpty())) {                     for (ExternalLoadBalancerDeviceVO lbProviderDevice : providerLbDevices) {                         if (lbProviderDevice.getState() == LBDeviceState.Enabled) {                             // acquire a private IP from the data center which will be used as management IP of provisioned LB appliance,                             DataCenterIpAddressVO dcPrivateIp = _dcDao.allocatePrivateIpAddress(guestConfig.getDataCenterId(), lbProviderDevice.getUuid());                             if (dcPrivateIp == null) {                                 throw new InsufficientNetworkCapacityException(&quot;failed to acquire a priavate IP in the zone &quot; + guestConfig.getDataCenterId() +                                     &quot; needed for management IP of the load balancer appliance&quot;, DataCenter.class, guestConfig.getDataCenterId());                             }                             Pod pod = _podDao.findById(dcPrivateIp.getPodId());                             String lbIP = dcPrivateIp.getIpAddress();                             String netmask = NetUtils.getCidrNetmask(pod.getCidrSize());                             String gateway = pod.getGateway();                              // send CreateLoadBalancerApplianceCommand to the host capable of provisioning                             CreateLoadBalancerApplianceCommand lbProvisionCmd = new CreateLoadBalancerApplianceCommand(lbIP, netmask, gateway);                             CreateLoadBalancerApplianceAnswer createLbAnswer = null;                             try {                                 createLbAnswer = (CreateLoadBalancerApplianceAnswer)_agentMgr.easySend(lbProviderDevice.getHostId(), lbProvisionCmd);                                 if (createLbAnswer == null || !createLbAnswer.getResult()) {                                     s_logger.error(&quot;Could not provision load balancer instance on the load balancer device &quot; + lbProviderDevice.getId());                                     continue;                                 }                             } catch (Exception agentException) {                                 s_logger.error(&quot;Could not provision load balancer instance on the load balancer device &quot; + lbProviderDevice.getId() + &quot; due to &quot; +                                     agentException.getMessage());                                 continue;                             }                              String username = createLbAnswer.getUsername();                             String password = createLbAnswer.getPassword();                             String publicIf = createLbAnswer.getPublicInterface();                             String privateIf = createLbAnswer.getPrivateInterface();                              // we have provisioned load balancer so add the appliance as cloudstack provisioned external load balancer                             String dedicatedLb = offering.isDedicatedLB() ? &quot;true&quot; : &quot;false&quot;;                             String capacity = Long.toString(lbProviderDevice.getCapacity());                              // acquire a public IP to associate with lb appliance (used as subnet IP to make the appliance part of private network)                             PublicIp publicIp =                                 _ipAddrMgr.assignPublicIpAddress(guestConfig.getDataCenterId(), null, _accountMgr.getSystemAccount(), VlanType.VirtualNetwork, null,                                     null, false, false);                             String publicIPNetmask = publicIp.getVlanNetmask();                             String publicIPgateway = publicIp.getVlanGateway();                             String publicIP = publicIp.getAddress().toString();                             String publicIPVlanTag=&quot;&quot;;                             try {                                 publicIPVlanTag = BroadcastDomainType.getValue(publicIp.getVlanTag());                             } catch (URISyntaxException e) {                                 s_logger.error(&quot;Failed to parse public ip vlan tag&quot; + e.getMessage());                             }                              String url =                                 &quot;https://&quot; + lbIP + &quot;?publicinterface=&quot; + publicIf + &quot;&amp;privateinterface=&quot; + privateIf + &quot;&amp;lbdevicededicated=&quot; + dedicatedLb +                                     &quot;&amp;cloudmanaged=true&quot; + &quot;&amp;publicip=&quot; + publicIP + &quot;&amp;publicipnetmask=&quot; + publicIPNetmask + &quot;&amp;lbdevicecapacity=&quot; + capacity +                                     &quot;&amp;publicipvlan=&quot; + publicIPVlanTag + &quot;&amp;publicipgateway=&quot; + publicIPgateway;                             ExternalLoadBalancerDeviceVO lbAppliance = null;                             try {                                 lbAppliance =                                     addExternalLoadBalancer(physicalNetworkId, url, username, password, createLbAnswer.getDeviceName(),                                         createLbAnswer.getServerResource(), false, false, null, null);                             } catch (Exception e) {                                 s_logger.error(&quot;Failed to add load balancer appliance in to cloudstack due to &quot; + e.getMessage() +                                     &quot;. So provisioned load balancer appliance will be destroyed.&quot;);                             }                              if (lbAppliance != null) {                                 // mark the load balancer as cloudstack managed and set parent host id on which lb appliance is provisioned                                 ExternalLoadBalancerDeviceVO managedLb = _externalLoadBalancerDeviceDao.findById(lbAppliance.getId());                                 managedLb.setIsManagedDevice(true);                                 managedLb.setParentHostId(lbProviderDevice.getHostId());                                 _externalLoadBalancerDeviceDao.update(lbAppliance.getId(), managedLb);                             } else {                                 // failed to add the provisioned load balancer into cloudstack so destroy the appliance                                 DestroyLoadBalancerApplianceCommand lbDeleteCmd = new DestroyLoadBalancerApplianceCommand(lbIP);                                 DestroyLoadBalancerApplianceAnswer answer = null;                                 try {                                     answer = (DestroyLoadBalancerApplianceAnswer)_agentMgr.easySend(lbProviderDevice.getHostId(), lbDeleteCmd);                                     if (answer == null || !answer.getResult()) {                                         s_logger.warn(&quot;Failed to destroy load balancer appliance created&quot;);                                     } else {                                         // release the public &amp; private IP back to dc pool, as the load balancer appliance is now destroyed                                         _dcDao.releasePrivateIpAddress(lbIP, guestConfig.getDataCenterId(), null);                                         _ipAddrMgr.disassociatePublicIpAddress(publicIp.getId(), _accountMgr.getSystemUser().getId(), _accountMgr.getSystemAccount());                                     }                                 } catch (Exception e) {                                     s_logger.warn(&quot;Failed to destroy load balancer appliance created for the network&quot; + guestConfig.getId() + &quot; due to &quot; + e.getMessage());                                 }                             }                         }                     }                 }             }         }          return lbDevice;     }      @Override     public ExternalLoadBalancerDeviceVO findSuitableLoadBalancerForNetwork(Network network, boolean dedicatedLb) throws InsufficientCapacityException {         long physicalNetworkId = network.getPhysicalNetworkId();         List lbDevices = null;         String provider = _ntwkSrvcProviderDao.getProviderForServiceInNetwork(network.getId(), Service.Lb);         assert (provider != null);          if (dedicatedLb) {             lbDevices = _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Free);             if (lbDevices != null &amp;&amp; !lbDevices.isEmpty()) {                 // return first device that is free, fully configured and meant for dedicated use                 for (ExternalLoadBalancerDeviceVO lbdevice : lbDevices) {                     if (lbdevice.getState() == LBDeviceState.Enabled &amp;&amp; lbdevice.getIsDedicatedDevice()) {                         return lbdevice;                     }                 }             }         } else {             // get the LB devices that are already allocated for shared use             lbDevices = _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Shared);              if (lbDevices != null) {                  ExternalLoadBalancerDeviceVO maxFreeCapacityLbdevice = null;                 long maxFreeCapacity = 0;                  // loop through the LB device in the physical network and pick the one with maximum free capacity                 for (ExternalLoadBalancerDeviceVO lbdevice : lbDevices) {                      // skip if device is not enabled                     if (lbdevice.getState() != LBDeviceState.Enabled) {                         continue;                     }                      // get the used capacity from the list of guest networks that are mapped to this load balancer                     List mappedNetworks = _networkExternalLBDao.listByLoadBalancerDeviceId(lbdevice.getId());                     long usedCapacity = ((mappedNetworks == null) || (mappedNetworks.isEmpty())) ? 0 : mappedNetworks.size();                      // get the configured capacity for this device                     long fullCapacity = lbdevice.getCapacity();                     if (fullCapacity == 0) {                         fullCapacity = _defaultLbCapacity; // if capacity not configured then use the default                     }                      long freeCapacity = fullCapacity - usedCapacity;                     if (freeCapacity &gt; 0) {                         if (maxFreeCapacityLbdevice == null) {                             maxFreeCapacityLbdevice = lbdevice;                             maxFreeCapacity = freeCapacity;                         } else if (freeCapacity &gt; maxFreeCapacity) {                             maxFreeCapacityLbdevice = lbdevice;                             maxFreeCapacity = freeCapacity;                         }                     }                 }                  // return the device with maximum free capacity and is meant for shared use                 if (maxFreeCapacityLbdevice != null) {                     return maxFreeCapacityLbdevice;                 }             }              // if we are here then there are no existing LB devices in shared use or the devices in shared use has no // free capacity left             // so allocate a new load balancer configured for shared use from the pool of free LB devices             lbDevices = _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Free);             if (lbDevices != null &amp;&amp; !lbDevices.isEmpty()) {                 for (ExternalLoadBalancerDeviceVO lbdevice : lbDevices) {                     if (lbdevice.getState() == LBDeviceState.Enabled &amp;&amp; !lbdevice.getIsDedicatedDevice()) {                         return lbdevice;                     }                 }             }         }          // there are no devices which capacity         throw new InsufficientNetworkCapacityException(&quot;Unable to find a load balancing provider with sufficient capcity &quot; + &quot; to implement the network&quot;, Network.class,             network.getId());     }      @DB     protected boolean freeLoadBalancerForNetwork(final Network guestConfig) {         GlobalLock deviceMapLock = GlobalLock.getInternLock(&quot;LoadBalancerAllocLock&quot;);          try {             if (deviceMapLock.lock(120)) {                 ExternalLoadBalancerDeviceVO lbDevice = Transaction.execute(new TransactionCallback() {                     @Override                     public ExternalLoadBalancerDeviceVO doInTransaction(TransactionStatus status) {                         // since network is shutdown remove the network mapping to the load balancer device                         NetworkExternalLoadBalancerVO networkLBDevice = _networkExternalLBDao.findByNetworkId(guestConfig.getId());                         long lbDeviceId = networkLBDevice.getExternalLBDeviceId();                         _networkExternalLBDao.remove(networkLBDevice.getId());                          List ntwksMapped = _networkExternalLBDao.listByLoadBalancerDeviceId(networkLBDevice.getExternalLBDeviceId());                         ExternalLoadBalancerDeviceVO lbDevice = _externalLoadBalancerDeviceDao.findById(lbDeviceId);                         boolean lbInUse = !(ntwksMapped == null || ntwksMapped.isEmpty());                         boolean lbCloudManaged = lbDevice.getIsManagedDevice();                          if (!lbInUse &amp;&amp; !lbCloudManaged) {                             // this is the last network mapped to the load balancer device so set device allocation state to be free                             lbDevice.setAllocationState(LBDeviceAllocationState.Free);                             _externalLoadBalancerDeviceDao.update(lbDevice.getId(), lbDevice);                         }                          // commit the changes before sending agent command to destroy cloudstack managed LB                         if (!lbInUse &amp;&amp; lbCloudManaged) {                             return lbDevice;                         } else {                             return null;                         }                     }                 });                  if (lbDevice != null) {                     // send DestroyLoadBalancerApplianceCommand to the host where load balancer appliance is provisioned                     Host lbHost = _hostDao.findById(lbDevice.getHostId());                     String lbIP = lbHost.getPrivateIpAddress();                     DestroyLoadBalancerApplianceCommand lbDeleteCmd = new DestroyLoadBalancerApplianceCommand(lbIP);                     DestroyLoadBalancerApplianceAnswer answer = null;                     try {                         answer = (DestroyLoadBalancerApplianceAnswer)_agentMgr.easySend(lbDevice.getParentHostId(), lbDeleteCmd);                         if (answer == null || !answer.getResult()) {                             s_logger.warn(&quot;Failed to destoy load balancer appliance used by the network&quot;                                     + guestConfig.getId() + &quot; due to &quot; + answer == null ? &quot;communication error with agent&quot;                                     : answer.getDetails());                         }                     } catch (Exception e) {                         s_logger.warn(&quot;Failed to destroy load balancer appliance used by the network&quot; + guestConfig.getId() + &quot; due to &quot; + e.getMessage());                     }                      if (s_logger.isDebugEnabled()) {                         s_logger.debug(&quot;Successfully destroyed load balancer appliance used for the network&quot; + guestConfig.getId());                     }                     deviceMapLock.unlock();                      // remove the provisioned load balancer appliance from cloudstack                     deleteExternalLoadBalancer(lbHost.getId());                      // release the private IP back to dc pool, as the load balancer appliance is now destroyed                     _dcDao.releasePrivateIpAddress(lbHost.getPrivateIpAddress(), guestConfig.getDataCenterId(), null);                      // release the public IP allocated for this LB appliance                     DetailVO publicIpDetail = _hostDetailDao.findDetail(lbHost.getId(), &quot;publicip&quot;);                     IPAddressVO ipVo = _ipAddressDao.findByIpAndDcId(guestConfig.getDataCenterId(), publicIpDetail.toString());                     _ipAddrMgr.disassociatePublicIpAddress(ipVo.getId(), _accountMgr.getSystemUser().getId(), _accountMgr.getSystemAccount());                 } else {                     deviceMapLock.unlock();                 }                  return true;             } else {                 s_logger.error(&quot;Failed to release load balancer device for the network&quot; + guestConfig.getId() + &quot;as failed to acquire lock &quot;);                 return false;             }         } catch (Exception exception) {             s_logger.error(&quot;Failed to release load balancer device for the network&quot; + guestConfig.getId() + &quot; due to &quot; + exception.getMessage());         } finally {             deviceMapLock.releaseRef();         }          return false;     }      private void applyStaticNatRuleForInlineLBRule(DataCenterVO zone, Network network, boolean revoked, String publicIp, String privateIp)         throws ResourceUnavailableException {         List staticNats = new ArrayList();         IPAddressVO ipVO = _ipAddressDao.listByDcIdIpAddress(zone.getId(), publicIp).get(0);         StaticNatImpl staticNat = new StaticNatImpl(ipVO.getAllocatedToAccountId(), ipVO.getAllocatedInDomainId(), network.getId(), ipVO.getId(), privateIp, revoked);         staticNats.add(staticNat);         StaticNatServiceProvider element = _networkMgr.getStaticNatProviderForNetwork(network);         element.applyStaticNats(network, staticNats);     }      private enum MappingState {         Create, Remove, Unchanged,     };      private class MappingNic {         private Nic nic;         private MappingState state;          public Nic getNic() {             return nic;         }          public void setNic(Nic nic) {             this.nic = nic;         }          public MappingState getState() {             return state;         }          public void setState(MappingState state) {             this.state = state;         }     };      private MappingNic getLoadBalancingIpNic(DataCenterVO zone, Network network, long sourceIpId, boolean revoked, String existedGuestIp)         throws ResourceUnavailableException {         String srcIp = _networkModel.getIp(sourceIpId).getAddress().addr();         InlineLoadBalancerNicMapVO mapping = _inlineLoadBalancerNicMapDao.findByPublicIpAddress(srcIp);         Nic loadBalancingIpNic = null;         MappingNic nic = new MappingNic();         nic.setState(MappingState.Unchanged);         if (!revoked) {             if (mapping == null) {                 // Acquire a new guest IP address and save it as the load balancing IP address                 String loadBalancingIpAddress = existedGuestIp;                  if (loadBalancingIpAddress == null) {                     if (network.getGuestType() == Network.GuestType.Isolated) {                         loadBalancingIpAddress = _ipAddrMgr.acquireGuestIpAddress(network, null);                     } else if (network.getGuestType() == Network.GuestType.Shared) {                         try {                             PublicIp directIp =                                 _ipAddrMgr.assignPublicIpAddress(network.getDataCenterId(), null, _accountDao.findById(network.getAccountId()), VlanType.DirectAttached,                                     network.getId(), null, true, false);                             loadBalancingIpAddress = directIp.getAddress().addr();                         } catch (InsufficientCapacityException capException) {                             String msg = &quot;Ran out of guest IP addresses from the shared network.&quot;;                             s_logger.error(msg);                             throw new ResourceUnavailableException(msg, DataCenter.class, network.getDataCenterId());                         }                     }                 }                  if (loadBalancingIpAddress == null) {                     String msg = &quot;Ran out of guest IP addresses.&quot;;                     s_logger.error(msg);                     throw new ResourceUnavailableException(msg, DataCenter.class, network.getDataCenterId());                 }                  // If a NIC doesn't exist for the load balancing IP address, create one                 loadBalancingIpNic = _nicDao.findByIp4AddressAndNetworkId(loadBalancingIpAddress, network.getId());                 if (loadBalancingIpNic == null) {                     loadBalancingIpNic = _networkMgr.savePlaceholderNic(network, loadBalancingIpAddress, null, null);                 }                  // Save a mapping between the source IP address and the load balancing IP address NIC                 mapping = new InlineLoadBalancerNicMapVO(srcIp, loadBalancingIpNic.getId());                 _inlineLoadBalancerNicMapDao.persist(mapping);                  // On the firewall provider for the network, create a static NAT rule between the source IP                 // address and the load balancing IP address                 try {                     applyStaticNatRuleForInlineLBRule(zone, network, revoked, srcIp, loadBalancingIpNic.getIPv4Address());                 } catch (ResourceUnavailableException ex) {                     // Rollback db operation                     _inlineLoadBalancerNicMapDao.expunge(mapping.getId());                     _nicDao.expunge(loadBalancingIpNic.getId());                     throw ex;                 }                  s_logger.debug(&quot;Created static nat rule for inline load balancer&quot;);                 nic.setState(MappingState.Create);             } else {                 loadBalancingIpNic = _nicDao.findById(mapping.getNicId());             }         } else {             if (mapping != null) {                 // Find the NIC that the mapping refers to                 loadBalancingIpNic = _nicDao.findById(mapping.getNicId());                  int count = _ipAddrMgr.getRuleCountForIp(sourceIpId, Purpose.LoadBalancing, FirewallRule.State.Active);                 if (count == 0) {                     // On the firewall provider for the network, delete the static NAT rule between the source IP                     // address and the load balancing IP address                     applyStaticNatRuleForInlineLBRule(zone, network, revoked, srcIp, loadBalancingIpNic.getIPv4Address());                      // Delete the mapping between the source IP address and the load balancing IP address                     _inlineLoadBalancerNicMapDao.expunge(mapping.getId());                      // Delete the NIC                     _nicDao.expunge(loadBalancingIpNic.getId());                      s_logger.debug(&quot;Revoked static nat rule for inline load balancer&quot;);                     nic.setState(MappingState.Remove);                 }             } else {                 s_logger.debug(&quot;Revoking a rule for an inline load balancer that has not been programmed yet.&quot;);                 nic.setNic(null);                 return nic;             }         }          nic.setNic(loadBalancingIpNic);         return nic;     }      public boolean isNccServiceProvider(Network network) {         NetworkOffering networkOffering = _networkOfferingDao.findById(network.getNetworkOfferingId());         if(null!= networkOffering &amp;&amp; networkOffering.getServicePackage() != null ) {             return true;         }         else {             return false;         }     }      public HostVO getNetScalerControlCenterForNetwork(Network guestConfig) {         long zoneId = guestConfig.getDataCenterId();         return _hostDao.findByTypeNameAndZoneId(zoneId, &quot;NetscalerControlCenter&quot;, Type.NetScalerControlCenter);     }      @Override     public boolean applyLoadBalancerRules(Network network, List loadBalancingRules) throws ResourceUnavailableException {         // Find the external load balancer in this zone         long zoneId = network.getDataCenterId();         DataCenterVO zone = _dcDao.findById(zoneId);          if (loadBalancingRules == null || loadBalancingRules.isEmpty()) {             return true;         }          HostVO externalLoadBalancer = null;          if(isNccServiceProvider(network)) {             externalLoadBalancer  = getNetScalerControlCenterForNetwork(network);         } else {             ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(network);             if (lbDeviceVO == null) {                 s_logger.warn(&quot;There is no external load balancer device assigned to this network either network is not implement are already shutdown so just returning&quot;);                 return true;             } else {                 externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());             }         }            boolean externalLoadBalancerIsInline = _networkMgr.isNetworkInlineMode(network);          if (network.getState() == Network.State.Allocated) {             s_logger.debug(&quot;External load balancer was asked to apply LB rules for network with ID &quot; + network.getId() +                 &quot;; this network is not implemented. Skipping backend commands.&quot;);             return true;         }          List loadBalancersToApply = new ArrayList();         List mappingStates = new ArrayList();         for (int i = 0; i &lt; loadBalancingRules.size(); i++) {             LoadBalancingRule rule = loadBalancingRules.get(i);              boolean revoked = (rule.getState().equals(FirewallRule.State.Revoke));             String protocol = rule.getProtocol();             String algorithm = rule.getAlgorithm();             String uuid = rule.getUuid();             String srcIp = rule.getSourceIp().addr();             String srcIpVlan = null;             String srcIpGateway = null;             String srcIpNetmask = null;             Long vlanid =  _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getVlanId();             if(vlanid != null ) {               VlanVO publicVlan =   _vlanDao.findById(vlanid);               srcIpVlan =  publicVlan.getVlanTag();               srcIpGateway = publicVlan.getVlanGateway();               srcIpNetmask = publicVlan.getVlanNetmask();             }             int srcPort = rule.getSourcePortStart();             List destinations = rule.getDestinations();              if (externalLoadBalancerIsInline) {                 long ipId = _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getId();                 MappingNic nic = getLoadBalancingIpNic(zone, network, ipId, revoked, null);                 mappingStates.add(nic.getState());                 Nic loadBalancingIpNic = nic.getNic();                 if (loadBalancingIpNic == null) {                     continue;                 }                  // Change the source IP address for the load balancing rule to be the load balancing IP address                 srcIp = loadBalancingIpNic.getIPv4Address();             }              if ((destinations != null &amp;&amp; !destinations.isEmpty()) || rule.isAutoScaleConfig()) {                 boolean inline = _networkMgr.isNetworkInlineMode(network);                 LoadBalancerTO loadBalancer =                     new LoadBalancerTO(uuid, srcIp, srcPort, protocol, algorithm, revoked, false, inline, destinations, rule.getStickinessPolicies(),                         rule.getHealthCheckPolicies(), rule.getLbSslCert(), rule.getLbProtocol());                 loadBalancer.setNetworkId(network.getId());                 loadBalancer.setSrcIpVlan(srcIpVlan);                 loadBalancer.setSrcIpNetmask(srcIpNetmask);                 loadBalancer.setSrcIpGateway(srcIpGateway);                 if (rule.isAutoScaleConfig()) {                     loadBalancer.setAutoScaleVmGroup(rule.getAutoScaleVmGroup());                 }                 loadBalancersToApply.add(loadBalancer);             }         }          try {             if (loadBalancersToApply.size() &gt; 0) {                 int numLoadBalancersForCommand = loadBalancersToApply.size();                 LoadBalancerTO[] loadBalancersForCommand = loadBalancersToApply.toArray(new LoadBalancerTO[numLoadBalancersForCommand]);                 LoadBalancerConfigCommand cmd = new LoadBalancerConfigCommand(loadBalancersForCommand, null);                 long guestVlanTag = Integer.parseInt(BroadcastDomainType.getValue(network.getBroadcastUri()));                 cmd.setAccessDetail(NetworkElementCommand.GUEST_VLAN_TAG, String.valueOf(guestVlanTag));                 Answer answer = _agentMgr.easySend(externalLoadBalancer.getId(), cmd);                 if (answer == null || !answer.getResult()) {                     String details = (answer != null) ? answer.getDetails() : &quot;details unavailable&quot;;                     String msg = &quot;Unable to apply load balancer rules to the external load balancer appliance in zone &quot; + zone.getName() + &quot; due to: &quot; + details + &quot;.&quot;;                     s_logger.error(msg);                     throw new ResourceUnavailableException(msg, DataCenter.class, network.getDataCenterId());                 }             }         } catch (Exception ex) {             if (externalLoadBalancerIsInline) {                 s_logger.error(&quot;Rollbacking static nat operation of inline mode load balancing due to error on applying LB rules!&quot;);                 String existedGuestIp = loadBalancersToApply.get(0).getSrcIp();                 // Rollback static NAT operation in current session                 for (int i = 0; i &lt; loadBalancingRules.size(); i++) {                     LoadBalancingRule rule = loadBalancingRules.get(i);                     MappingState state = mappingStates.get(i);                     boolean revoke;                     if (state == MappingState.Create) {                         revoke = true;                     } else if (state == MappingState.Remove) {                         revoke = false;                     } else {                         continue;                     }                     long sourceIpId = _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getId();                     getLoadBalancingIpNic(zone, network, sourceIpId, revoke, existedGuestIp);                 }             }             throw new ResourceUnavailableException(ex.getMessage(), DataCenter.class, network.getDataCenterId());         }          return true;     }      @Override     public boolean manageGuestNetworkWithExternalLoadBalancer(boolean add, Network guestConfig) throws ResourceUnavailableException, InsufficientCapacityException {         if (guestConfig.getTrafficType() != TrafficType.Guest) {             s_logger.trace(&quot;External load balancer can only be used for guest networks.&quot;);             return false;         }          long zoneId = guestConfig.getDataCenterId();         DataCenterVO zone = _dcDao.findById(zoneId);         HostVO externalLoadBalancer = null;          if (add) {             ExternalLoadBalancerDeviceVO lbDeviceVO = null;             // on restart network, device could have been allocated already, skip allocation if a device is assigned             lbDeviceVO = getExternalLoadBalancerForNetwork(guestConfig);             if (lbDeviceVO == null) {                 // allocate a load balancer device for the network                 lbDeviceVO = allocateLoadBalancerForNetwork(guestConfig);                 if (lbDeviceVO == null) {                     String msg = &quot;failed to alloacate a external load balancer for the network &quot; + guestConfig.getId();                     s_logger.error(msg);                     throw new InsufficientNetworkCapacityException(msg, DataCenter.class, guestConfig.getDataCenterId());                 }             }             externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());             s_logger.debug(&quot;Allocated external load balancer device:&quot; + lbDeviceVO.getId() + &quot; for the network: &quot; + guestConfig.getId());         } else {             // find the load balancer device allocated for the network             ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(guestConfig);             if (lbDeviceVO == null) {                 s_logger.warn(&quot;Network shutdwon requested on external load balancer element, which did not implement the network.&quot;                     + &quot; Either network implement failed half way through or already network shutdown is completed. So just returning.&quot;);                 return true;             }              externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());             assert (externalLoadBalancer != null) : &quot;There is no device assigned to this network how did shutdown network ended up here??&quot;;         }          // Send a command to the external load balancer to implement or shutdown the guest network         String guestVlanTag = BroadcastDomainType.getValue(guestConfig.getBroadcastUri());         String selfIp = null;         String guestVlanNetmask = NetUtils.cidr2Netmask(guestConfig.getCidr());         Integer networkRate = _networkModel.getNetworkRate(guestConfig.getId(), null);          if (add) {             // on restart network, network could have already been implemented. If already implemented then return             Nic selfipNic = getPlaceholderNic(guestConfig);             if (selfipNic != null) {                 return true;             }              // Acquire a self-ip address from the guest network IP address range             selfIp = _ipAddrMgr.acquireGuestIpAddress(guestConfig, null);             if (selfIp == null) {                 String msg = &quot;failed to acquire guest IP address so not implementing the network on the external load balancer &quot;;                 s_logger.error(msg);                 throw new InsufficientNetworkCapacityException(msg, Network.class, guestConfig.getId());             }         } else {             // get the self-ip used by the load balancer             Nic selfipNic = getPlaceholderNic(guestConfig);             if (selfipNic == null) {                 s_logger.warn(&quot;Network shutdwon requested on external load balancer element, which did not implement the network.&quot;                     + &quot; Either network implement failed half way through or already network shutdown is completed. So just returning.&quot;);                 return true;             }             selfIp = selfipNic.getIPv4Address();         }          // It's a hack, using isOneToOneNat field for indicate if it's inline or not         boolean inline = _networkMgr.isNetworkInlineMode(guestConfig);         IpAddressTO ip =             new IpAddressTO(guestConfig.getAccountId(), null, add, false, true, guestVlanTag, selfIp, guestVlanNetmask, null, networkRate, inline);         IpAddressTO[] ips = new IpAddressTO[1];         ips[0] = ip;         IpAssocCommand cmd = new IpAssocCommand(ips);         Answer answer = _agentMgr.easySend(externalLoadBalancer.getId(), cmd);          if (answer == null || !answer.getResult()) {             String action = add ? &quot;implement&quot; : &quot;shutdown&quot;;             String answerDetails = (answer != null) ? answer.getDetails() : null;             answerDetails = (answerDetails != null) ? &quot; due to &quot; + answerDetails : &quot;&quot;;             String msg = &quot;External load balancer was unable to &quot; + action + &quot; the guest network on the external load balancer in zone &quot; + zone.getName() + answerDetails;             s_logger.error(msg);             throw new ResourceUnavailableException(msg, Network.class, guestConfig.getId());         }          if (add) {             // Insert a new NIC for this guest network to reserve the self IP             _networkMgr.savePlaceholderNic(guestConfig, selfIp, null, null);         } else {             // release the self-ip obtained from guest network             Nic selfipNic = getPlaceholderNic(guestConfig);             _nicDao.remove(selfipNic.getId());              // release the load balancer allocated for the network             boolean releasedLB = freeLoadBalancerForNetwork(guestConfig);             if (!releasedLB) {                 String msg = &quot;Failed to release the external load balancer used for the network: &quot; + guestConfig.getId();                 s_logger.error(msg);             }         }          if (s_logger.isDebugEnabled()) {             Account account = _accountDao.findByIdIncludingRemoved(guestConfig.getAccountId());             String action = add ? &quot;implemented&quot; : &quot;shut down&quot;;             s_logger.debug(&quot;External load balancer has &quot; + action + &quot; the guest network for account &quot; + account.getAccountName() + &quot;(id = &quot; + account.getAccountId() +                 &quot;) with VLAN tag &quot; + guestVlanTag);         }          return true;     }      @Override     public boolean configure(String name, Map params) throws ConfigurationException {         super.configure(name, params);         _defaultLbCapacity = NumbersUtil.parseLong(_configDao.getValue(Config.DefaultExternalLoadBalancerCapacity.key()), 50);         _resourceMgr.registerResourceStateAdapter(this.getClass().getSimpleName(), this);         return true;     }      @Override     public boolean start() {         return true;     }      @Override     public boolean stop() {         return true;     }      @Override     public HostVO createHostVOForConnectedAgent(HostVO host, StartupCommand[] cmd) {         // TODO Auto-generated method stub         return null;     }      @Override     public HostVO createHostVOForDirectConnectAgent(HostVO host, StartupCommand[] startup, ServerResource resource, Map details, List hostTags) {         if (!(startup[0] instanceof StartupExternalLoadBalancerCommand)) {             return null;         }         if(host.getName().equalsIgnoreCase(&quot;NetScalerControlCenter&quot;)) {             host.setType(Host.Type.NetScalerControlCenter);         }         else {             host.setType(Host.Type.ExternalLoadBalancer);         }         return host;     }      @Override     public DeleteHostAnswer deleteHost(HostVO host, boolean isForced, boolean isForceDeleteStorage) throws UnableDeleteHostException {         if (host.getType() != com.cloud.host.Host.Type.ExternalLoadBalancer) {             return null;         }         return new DeleteHostAnswer(true);     }      protected IpDeployer getIpDeployerForInlineMode(Network network) {         //We won't deploy IP, instead the firewall in front of us would do it         List providers = _networkMgr.getProvidersForServiceInNetwork(network, Service.Firewall);         //Only support one provider now         if (providers == null) {             s_logger.error(&quot;Cannot find firewall provider for network &quot; + network.getId());             return null;         }         if (providers.size() != 1) {             s_logger.error(&quot;Found &quot; + providers.size() + &quot; firewall provider for network &quot; + network.getId());             return null;         }          NetworkElement element = _networkModel.getElementImplementingProvider(providers.get(0).getName());         if (!(element instanceof IpDeployer)) {             s_logger.error(&quot;The firewall provider for network &quot; + network.getName() + &quot; don't have ability to deploy IP address!&quot;);             return null;         }         s_logger.info(&quot;Let &quot; + element.getName() + &quot; handle ip association for &quot; + getName() + &quot; in network &quot; + network.getId());         return (IpDeployer)element;     }      @Override     public List getLBHealthChecks(Network network, List loadBalancingRules) throws ResourceUnavailableException {          // Find the external load balancer in this zone         long zoneId = network.getDataCenterId();         DataCenterVO zone = _dcDao.findById(zoneId);          if (loadBalancingRules == null || loadBalancingRules.isEmpty()) {             return null;         }          HostVO externalLoadBalancer = null;          if(isNccServiceProvider(network)) {             externalLoadBalancer  = getNetScalerControlCenterForNetwork(network);         } else {             ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(network);             if (lbDeviceVO == null) {                 s_logger.warn(&quot;There is no external load balancer device assigned to this network either network is not implement are already shutdown so just returning&quot;);                 return null;             } else {                 externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());             }         }          boolean externalLoadBalancerIsInline = _networkMgr.isNetworkInlineMode(network);          if (network.getState() == Network.State.Allocated) {             s_logger.debug(&quot;External load balancer was asked to apply LB rules for network with ID &quot; + network.getId() +                 &quot;; this network is not implemented. Skipping backend commands.&quot;);             return null;         }          List loadBalancersToApply = new ArrayList();         List mappingStates = new ArrayList();         for (final LoadBalancingRule rule : loadBalancingRules) {             boolean revoked = (FirewallRule.State.Revoke.equals(rule.getState()));             String protocol = rule.getProtocol();             String algorithm = rule.getAlgorithm();             String uuid = rule.getUuid();             String srcIp = rule.getSourceIp().addr();             int srcPort = rule.getSourcePortStart();             List destinations = rule.getDestinations();              if (externalLoadBalancerIsInline) {                 long sourceIpId = _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getId();                 MappingNic nic = getLoadBalancingIpNic(zone, network, sourceIpId, revoked, null);                 mappingStates.add(nic.getState());                 Nic loadBalancingIpNic = nic.getNic();                 if (loadBalancingIpNic == null) {                     continue;                 }                  // Change the source IP address for the load balancing rule to                 // be the load balancing IP address                 srcIp = loadBalancingIpNic.getIPv4Address();             }              if ((destinations != null &amp;&amp; !destinations.isEmpty()) || !rule.isAutoScaleConfig()) {                 boolean inline = _networkMgr.isNetworkInlineMode(network);                 LoadBalancerTO loadBalancer =                     new LoadBalancerTO(uuid, srcIp, srcPort, protocol, algorithm, revoked, false, inline, destinations, rule.getStickinessPolicies(),                         rule.getHealthCheckPolicies(), rule.getLbSslCert(), rule.getLbProtocol());                 loadBalancersToApply.add(loadBalancer);             }         }          try {             if (loadBalancersToApply.size() &gt; 0) {                 int numLoadBalancersForCommand = loadBalancersToApply.size();                 LoadBalancerTO[] loadBalancersForCommand = loadBalancersToApply.toArray(new LoadBalancerTO[numLoadBalancersForCommand]);                 HealthCheckLBConfigCommand cmd = new HealthCheckLBConfigCommand(loadBalancersForCommand, network.getId());                 long guestVlanTag = Integer.parseInt(BroadcastDomainType.getValue(network.getBroadcastUri()));                 cmd.setAccessDetail(NetworkElementCommand.GUEST_VLAN_TAG, String.valueOf(guestVlanTag));                  HealthCheckLBConfigAnswer answer = (HealthCheckLBConfigAnswer) _agentMgr.easySend(externalLoadBalancer.getId(), cmd);                 // easySend will return null on error                 return answer == null ? null : answer.getLoadBalancers();             }         } catch (Exception ex) {             s_logger.error(&quot;Exception Occured &quot;, ex);         }         //null return is handled by clients         return null;     }      private NicVO getPlaceholderNic(Network network) {         List guestIps = _nicDao.listByNetworkId(network.getId());         for (NicVO guestIp : guestIps) {             // only external firewall and external load balancer will create NicVO with PlaceHolder reservation strategy             if (guestIp.getReservationStrategy().equals(ReservationStrategy.PlaceHolder) &amp;&amp; guestIp.getVmType() == null &amp;&amp; guestIp.getReserver() == null &amp;&amp;                 !guestIp.getIPv4Address().equals(network.getGateway())) {                 return guestIp;             }         }         return null;     }  }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14461</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/server/src/main/java/com/cloud/network/ExternalLoadBalancerDeviceManagerImpl.java/#L141-L1311</td>
    <td align="right">1</td>
    <td align="right">2433</td>
    <td align="right">14461</td>
  </tr>
  <tr valign="top">
    <td align="right">2492</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;}) public abstract class AbstractCompendiumHandler extends ServiceTracker implements MBeanHandler {      protected final JMXAgentContext agentContext;     protected StandardMBean mbean;     protected final AtomicLong trackedId = new AtomicLong();          /**      *       * @param agentContext      * @param filter      */     protected AbstractCompendiumHandler(JMXAgentContext agentContext, Filter filter) {         super(agentContext.getBundleContext(), filter, null);         this.agentContext = agentContext;     }      /**      *       * @param agentContext      * @param clazz      */     protected AbstractCompendiumHandler(JMXAgentContext agentContext, String clazz) {         super(agentContext.getBundleContext(), clazz, null);         this.agentContext = agentContext;     }      /*      * (non-Javadoc)      *       * @see org.osgi.util.tracker.ServiceTracker#addingService(org.osgi.framework.ServiceReference)      */     public Object addingService(ServiceReference reference) {         Logger logger = agentContext.getLogger();         Object trackedService = null;         long serviceId = (Long) reference.getProperty(Constants.SERVICE_ID);         //API stipulates versions for compendium services with static ObjectName         //This shouldn't happen but added as a consistency check         if (trackedId.compareAndSet(0, serviceId)) {             logger.log(LogService.LOG_INFO, &quot;Registering MBean with ObjectName [&quot; + getName() + &quot;] for service with &quot;                     + Constants.SERVICE_ID + &quot; [&quot; + serviceId + &quot;]&quot;);             trackedService = context.getService(reference);             mbean = constructInjectMBean(trackedService);             agentContext.registerMBean(AbstractCompendiumHandler.this);         } else {             String serviceDescription = getServiceDescription(reference);             logger.log(LogService.LOG_WARNING, &quot;Detected secondary ServiceReference for [&quot; + serviceDescription                     + &quot;] with &quot; + Constants.SERVICE_ID + &quot; [&quot; + serviceId + &quot;] Only 1 instance will be JMX managed&quot;);         }         return trackedService;     }      /*      * (non-Javadoc)      *       * @see org.osgi.util.tracker.ServiceTracker#removedService(org.osgi.framework.ServiceReference, java.lang.Object)      */     public void removedService(ServiceReference reference, Object service) {         Logger logger = agentContext.getLogger();         long serviceID = (Long) reference.getProperty(Constants.SERVICE_ID);         if (trackedId.compareAndSet(serviceID, 0)) {             logger.log(LogService.LOG_INFO, &quot;Unregistering MBean with ObjectName [&quot; + getName() + &quot;] for service with &quot;                     + Constants.SERVICE_ID + &quot; [&quot; + serviceID + &quot;]&quot;);              agentContext.unregisterMBean(AbstractCompendiumHandler.this);             context.ungetService(reference);         } else {             String serviceDescription = getServiceDescription(reference);             logger.log(LogService.LOG_WARNING, &quot;ServiceReference for [&quot; + serviceDescription + &quot;] with &quot;                     + Constants.SERVICE_ID + &quot; [&quot; + serviceID + &quot;] is not currently JMX managed&quot;);         }     }      private String getServiceDescription(ServiceReference reference) {         String serviceDescription = (String) reference.getProperty(Constants.SERVICE_DESCRIPTION);         if (serviceDescription == null) {             Object obj = reference.getProperty(Constants.OBJECTCLASS);             if (obj instanceof String[]) {                 StringBuilder sb = new StringBuilder();                 for (String s : (String[]) obj) {                     if (sb.length() &gt; 0) {                         sb.append(&quot;, &quot;);                     }                     sb.append(s);                 }                 serviceDescription = sb.toString();             } else {                 serviceDescription = obj.toString();             }         }         return serviceDescription;     }      /**      * Gets the StandardMBean managed by this handler when the backing service is available or null      *       * @see org.apache.aries.jmx.MBeanHandler#getMbean()      */     public StandardMBean getMbean() {         return mbean;     }      /**      * Implement this method to construct an appropriate {@link StandardMBean} instance which is backed by the supplied      * service tracked by this handler      *       * @param targetService      *            the compendium service tracked by this handler      * @return The StandardMBean instance whose registration lifecycle will be managed by this handler      */     protected abstract StandardMBean constructInjectMBean(Object targetService);      /**      * The base name of the MBean. Will be expanded with the framework name and the UUID.      * @return      */     protected abstract String getBaseName();      /**      * @see org.apache.aries.jmx.MBeanHandler#getName()      */     public String getName() {         return ObjectNameUtils.createFullObjectName(context, getBaseName());     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14622</td>
    <td align="left">https://github.com/apache/aries/blob/52293d20268de7c98833846ded2b70d6476773de/jmx/jmx-core/src/main/java/org/apache/aries/jmx/AbstractCompendiumHandler.java/#L43-L166</td>
    <td align="right">1</td>
    <td align="right">2492</td>
    <td align="right">14622</td>
  </tr>
  <tr valign="top">
    <td align="right">2586</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Blob&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class GangliaServer implements MonitorService {   /*    * The Ganglia protocol specific stuff: the xdr_* methods    * and the sendToGanglia* methods have been shamelessly ripped off    * from Hadoop. All hail the yellow elephant!    */    private static final Logger logger =           LoggerFactory.getLogger(GangliaServer.class);   public static final int BUFFER_SIZE = 1500; // as per libgmond.c   protected byte[] buffer = new byte[BUFFER_SIZE];   protected int offset;   private final List addresses = new ArrayList();   private DatagramSocket socket = null;   private ScheduledExecutorService service =           Executors.newSingleThreadScheduledExecutor();   private List hosts;   protected final GangliaCollector collectorRunnable;   private int pollFrequency = 60;   public static final String DEFAULT_UNITS = &quot;&quot;;   public static final int DEFAULT_TMAX = 60;   public static final int DEFAULT_DMAX = 0;   public static final int DEFAULT_SLOPE = 3;   public static final String GANGLIA_DOUBLE_TYPE = &quot;double&quot;;   private volatile boolean isGanglia3 = false;   private String hostname;   public final String CONF_POLL_FREQUENCY = &quot;pollFrequency&quot;;   public final int DEFAULT_POLL_FREQUENCY = 60;   public final String CONF_HOSTS = &quot;hosts&quot;;   public final String CONF_ISGANGLIA3 = &quot;isGanglia3&quot;;   private static final String GANGLIA_CONTEXT = &quot;flume.&quot;;    public GangliaServer() throws FlumeException {     collectorRunnable = new GangliaCollector();   }    /**    * Puts a string into the buffer by first writing the size of the string as an    * int, followed by the bytes of the string, padded if necessary to a multiple    * of 4.    *    * @param s the string to be written to buffer at offset location    */   protected void xdr_string(String s) {     byte[] bytes = s.getBytes();     int len = bytes.length;     xdr_int(len);     System.arraycopy(bytes, 0, buffer, offset, len);     offset += len;     pad();   }    /**    * Pads the buffer with zero bytes up to the nearest multiple of 4.    */   private void pad() {     int newOffset = ((offset + 3) / 4) * 4;     while (offset &lt; newOffset) {       buffer[offset++] = 0;     }   }    /**    * Puts an integer into the buffer as 4 bytes, big-endian.    */   protected void xdr_int(int i) {     buffer[offset++] = (byte) ((i &gt;&gt; 24) &amp; 0xff);     buffer[offset++] = (byte) ((i &gt;&gt; 16) &amp; 0xff);     buffer[offset++] = (byte) ((i &gt;&gt; 8) &amp; 0xff);     buffer[offset++] = (byte) (i &amp; 0xff);   }    public synchronized void sendToGangliaNodes() {     DatagramPacket packet;     for (SocketAddress addr : addresses) {       try {         packet = new DatagramPacket(buffer, offset, addr);         socket.send(packet);       } catch (Exception ex) {         logger.warn(&quot;Could not send metrics to metrics server: &quot;                 + addr.toString(), ex);       }     }     offset = 0;   }    /**    * Start this server, causing it to poll JMX at the configured frequency.    */   @Override   public void start() {     try {       socket = new DatagramSocket();       hostname = InetAddress.getLocalHost().getHostName();     } catch (SocketException ex) {       logger.error(&quot;Could not create socket for metrics collection.&quot;);       throw new FlumeException(               &quot;Could not create socket for metrics collection.&quot;, ex);     } catch (Exception ex2) {       logger.warn(&quot;Unknown error occured&quot;, ex2);     }     for (HostInfo host : hosts) {       addresses.add(new InetSocketAddress(               host.getHostName(), host.getPortNumber()));     }     collectorRunnable.server = this;     if (service.isShutdown() || service.isTerminated()) {       service = Executors.newSingleThreadScheduledExecutor();     }     service.scheduleWithFixedDelay(collectorRunnable, 0,             pollFrequency, TimeUnit.SECONDS);   }    /**    * Stop this server.    */   @Override   public void stop() {     service.shutdown();      while (!service.isTerminated()) {       try {         logger.warn(&quot;Waiting for ganglia service to stop&quot;);         service.awaitTermination(500, TimeUnit.MILLISECONDS);       } catch (InterruptedException ex) {         logger.warn(&quot;Interrupted while waiting&quot;                 + &quot; for ganglia monitor to shutdown&quot;, ex);         service.shutdownNow();       }     }     addresses.clear();   }    /**    *    * @param pollFrequency Seconds between consecutive JMX polls.    */   public void setPollFrequency(int pollFrequency) {     this.pollFrequency = pollFrequency;   }    /**    *    * @return Seconds between consecutive JMX polls    */   public int getPollFrequency() {     return pollFrequency;   }    /**    *    * @param isGanglia3 When true, ganglia 3 messages will be sent, else Ganglia    * 3.1 formatted messages are sent.    */   public void setIsGanglia3(boolean isGanglia3) {     this.isGanglia3 = isGanglia3;   }    /**    *    * @return True if the server is currently sending ganglia 3 formatted msgs.    * False if the server returns Ganglia 3.1    */   public boolean isGanglia3() {     return this.isGanglia3;   }    protected void createGangliaMessage(String name, String value) {     logger.debug(&quot;Sending ganglia3 formatted message.&quot;             + name + &quot;: &quot; + value);     name = hostname + &quot;.&quot; + name;     xdr_int(0);     String type = &quot;string&quot;;     try {       Float.parseFloat(value);       type = &quot;float&quot;;     } catch (NumberFormatException ex) {       // The param is a string, and so leave the type as is.     }     xdr_string(type); // metric type     xdr_string(name);     xdr_string(value);     xdr_string(DEFAULT_UNITS);     xdr_int(DEFAULT_SLOPE);     xdr_int(DEFAULT_TMAX);     xdr_int(DEFAULT_DMAX);   }    protected void createGangliaMessage31(String name, String value) {     logger.debug(&quot;Sending ganglia 3.1 formatted message: &quot;             + name + &quot;: &quot; + value);     xdr_int(128); // metric_id = metadata_msg     xdr_string(hostname); // hostname     xdr_string(name); // metric name     xdr_int(0); // spoof = False     String type = &quot;string&quot;;     try {       Float.parseFloat(value);       type = &quot;float&quot;;     } catch (NumberFormatException ex) {       // The param is a string, and so leave the type as is.     }     xdr_string(type); // metric type     xdr_string(name); // metric name     xdr_string(DEFAULT_UNITS); // units     xdr_int(DEFAULT_SLOPE); // slope     xdr_int(DEFAULT_TMAX); // tmax, the maximum time between metrics     xdr_int(DEFAULT_DMAX); // dmax, the maximum data value     xdr_int(1); /*Num of the entries in extra_value field for Ganglia 3.1.x*/     xdr_string(&quot;GROUP&quot;); /*Group attribute*/     xdr_string(&quot;flume&quot;); /*Group value*/      this.sendToGangliaNodes();      // Now we send out a message with the actual value.     // Technically, we only need to send out the metadata message once for     // each metric, but I don't want to have to record which metrics we did and     // did not send.     xdr_int(133); // we are sending a string value     xdr_string(hostname); // hostName     xdr_string(name); // metric name     xdr_int(0); // spoof = False     xdr_string(&quot;%s&quot;); // format field     xdr_string(value); // metric value   }    @Override   public void configure(Context context) {     this.pollFrequency = context.getInteger(this.CONF_POLL_FREQUENCY, 60);     String localHosts = context.getString(this.CONF_HOSTS);     if (localHosts == null || localHosts.isEmpty()) {       throw new ConfigurationException(&quot;Hosts list cannot be empty.&quot;);     }     this.hosts = this.getHostsFromString(localHosts);     this.isGanglia3 = context.getBoolean(this.CONF_ISGANGLIA3, false);   }    private List getHostsFromString(String hosts)           throws FlumeException {     List hostInfoList = new ArrayList();     String[] hostsAndPorts = hosts.split(&quot;,&quot;);     int i = 0;     for (String host : hostsAndPorts) {       String[] hostAndPort = host.split(&quot;:&quot;);       if (hostAndPort.length &lt; 2) {         logger.warn(&quot;Invalid ganglia host: &quot;, host);         continue;       }       try {         hostInfoList.add(new HostInfo(&quot;ganglia_host-&quot; + String.valueOf(i),                 hostAndPort[0], Integer.parseInt(hostAndPort[1])));       } catch (Exception e) {         logger.warn(&quot;Invalid ganglia host: &quot; + host, e);         continue;       }     }     if (hostInfoList.isEmpty()) {       throw new FlumeException(&quot;No valid ganglia hosts defined!&quot;);     }     return hostInfoList;   }    /**    * Worker which polls JMX for all mbeans with    * {@link javax.management.ObjectName} within the flume namespace:    * org.apache.flume. All attributes of such beans are sent to the all hosts    * specified by the server that owns it's instance.    *    */   protected class GangliaCollector implements Runnable {      private GangliaServer server;      @Override     public void run() {       try {         Map&gt; metricsMap =                 JMXPollUtil.getAllMBeans();         for (String component : metricsMap.keySet()) {           Map attributeMap = metricsMap.get(component);           for (String attribute : attributeMap.keySet()) {             if (isGanglia3) {               server.createGangliaMessage(GANGLIA_CONTEXT + component + &quot;.&quot;                       + attribute,                       attributeMap.get(attribute));             } else {               server.createGangliaMessage31(GANGLIA_CONTEXT + component + &quot;.&quot;                       + attribute,                       attributeMap.get(attribute));             }             server.sendToGangliaNodes();           }         }       } catch (Throwable t) {         logger.error(&quot;Unexpected error&quot;, t);       }     }   } }</td>
    <td align="left">blob</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14989</td>
    <td align="left">https://github.com/apache/flume/blob/7d3396f26dc1541e9d2a540d50d15a15c38acb74/flume-ng-core/src/main/java/org/apache/flume/instrumentation/GangliaServer.java/#L56-L354</td>
    <td align="right">1</td>
    <td align="right">2586</td>
    <td align="right">14989</td>
  </tr>
  <tr valign="top">
    <td align="right">2610</td>
    <td align="left">{&quot;response&quot;:&quot;YES I found bad smells&quot;,&quot;the bad smells are&quot;:[&quot;Blob&quot;,&quot;Long Method&quot;,&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MetadataTableUtil {    private static final Text EMPTY_TEXT = new Text();   private static final byte[] EMPTY_BYTES = new byte[0];   private static Map root_tables = new HashMap&lt;&gt;();   private static Map metadata_tables = new HashMap&lt;&gt;();   private static final Logger log = LoggerFactory.getLogger(MetadataTableUtil.class);    private MetadataTableUtil() {}    public static synchronized Writer getMetadataTable(ServerContext context) {     Credentials credentials = context.getCredentials();     Writer metadataTable = metadata_tables.get(credentials);     if (metadataTable == null) {       metadataTable = new Writer(context, MetadataTable.ID);       metadata_tables.put(credentials, metadataTable);     }     return metadataTable;   }    public static synchronized Writer getRootTable(ServerContext context) {     Credentials credentials = context.getCredentials();     Writer rootTable = root_tables.get(credentials);     if (rootTable == null) {       rootTable = new Writer(context, RootTable.ID);       root_tables.put(credentials, rootTable);     }     return rootTable;   }    public static void putLockID(ServerContext context, ZooLock zooLock, Mutation m) {     TabletsSection.ServerColumnFamily.LOCK_COLUMN.put(m,         new Value(zooLock.getLockID().serialize(context.getZooKeeperRoot() + &quot;/&quot;).getBytes(UTF_8)));   }    private static void update(ServerContext context, Mutation m, KeyExtent extent) {     update(context, null, m, extent);   }    public static void update(ServerContext context, ZooLock zooLock, Mutation m, KeyExtent extent) {     Writer t = extent.isMeta() ? getRootTable(context) : getMetadataTable(context);     update(context, t, zooLock, m);   }    public static void update(ServerContext context, Writer t, ZooLock zooLock, Mutation m) {     if (zooLock != null)       putLockID(context, zooLock, m);     while (true) {       try {         t.update(m);         return;       } catch (AccumuloException | TableNotFoundException | AccumuloSecurityException e) {         log.error(&quot;{}&quot;, e.getMessage(), e);       } catch (ConstraintViolationException e) {         log.error(&quot;{}&quot;, e.getMessage(), e);         // retrying when a CVE occurs is probably futile and can cause problems, see ACCUMULO-3096         throw new RuntimeException(e);       }       sleepUninterruptibly(1, TimeUnit.SECONDS);     }   }    public static void updateTabletFlushID(KeyExtent extent, long flushID, ServerContext context,       ZooLock zooLock) {     if (!extent.isRootTablet()) {       Mutation m = new Mutation(extent.getMetadataEntry());       TabletsSection.ServerColumnFamily.FLUSH_COLUMN.put(m,           new Value((flushID + &quot;&quot;).getBytes(UTF_8)));       update(context, zooLock, m, extent);     }   }    public static void updateTabletCompactID(KeyExtent extent, long compactID, ServerContext context,       ZooLock zooLock) {     if (!extent.isRootTablet()) {       Mutation m = new Mutation(extent.getMetadataEntry());       TabletsSection.ServerColumnFamily.COMPACT_COLUMN.put(m,           new Value((compactID + &quot;&quot;).getBytes(UTF_8)));       update(context, zooLock, m, extent);     }   }    public static void updateTabletDataFile(long tid, KeyExtent extent,       Map estSizes, String time, ServerContext context, ZooLock zooLock) {     Mutation m = new Mutation(extent.getMetadataEntry());     byte[] tidBytes = Long.toString(tid).getBytes(UTF_8);      for (Entry entry : estSizes.entrySet()) {       Text file = entry.getKey().meta();       m.put(DataFileColumnFamily.NAME, file, new Value(entry.getValue().encode()));       m.put(TabletsSection.BulkFileColumnFamily.NAME, file, new Value(tidBytes));     }     TabletsSection.ServerColumnFamily.TIME_COLUMN.put(m, new Value(time.getBytes(UTF_8)));     update(context, zooLock, m, extent);   }    public static void updateTabletDir(KeyExtent extent, String newDir, ServerContext context,       ZooLock lock) {     Mutation m = new Mutation(extent.getMetadataEntry());     TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.put(m, new Value(newDir.getBytes(UTF_8)));     update(context, lock, m, extent);   }    public static void addTablet(KeyExtent extent, String path, ServerContext context, char timeType,       ZooLock lock) {     Mutation m = extent.getPrevRowUpdateMutation();      TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.put(m, new Value(path.getBytes(UTF_8)));     TabletsSection.ServerColumnFamily.TIME_COLUMN.put(m,         new Value((timeType + &quot;0&quot;).getBytes(UTF_8)));      update(context, lock, m, extent);   }    public static void updateTabletVolumes(KeyExtent extent, List logsToRemove,       List logsToAdd, List filesToRemove,       SortedMap filesToAdd, String newDir, ZooLock zooLock,       ServerContext context) {      if (extent.isRootTablet()) {       if (newDir != null)         throw new IllegalArgumentException(&quot;newDir not expected for &quot; + extent);        if (filesToRemove.size() != 0 || filesToAdd.size() != 0)         throw new IllegalArgumentException(&quot;files not expected for &quot; + extent);        // add before removing in case of process death       for (LogEntry logEntry : logsToAdd)         addRootLogEntry(context, zooLock, logEntry);        removeUnusedWALEntries(context, extent, logsToRemove, zooLock);     } else {       Mutation m = new Mutation(extent.getMetadataEntry());        for (LogEntry logEntry : logsToRemove)         m.putDelete(logEntry.getColumnFamily(), logEntry.getColumnQualifier());        for (LogEntry logEntry : logsToAdd)         m.put(logEntry.getColumnFamily(), logEntry.getColumnQualifier(), logEntry.getValue());        for (FileRef fileRef : filesToRemove)         m.putDelete(DataFileColumnFamily.NAME, fileRef.meta());        for (Entry entry : filesToAdd.entrySet())         m.put(DataFileColumnFamily.NAME, entry.getKey().meta(),             new Value(entry.getValue().encode()));        if (newDir != null)         ServerColumnFamily.DIRECTORY_COLUMN.put(m, new Value(newDir.getBytes(UTF_8)));        update(context, m, extent);     }   }    private interface ZooOperation {     void run(IZooReaderWriter rw) throws KeeperException, InterruptedException, IOException;   }    private static void retryZooKeeperUpdate(ServerContext context, ZooLock zooLock,       ZooOperation op) {     while (true) {       try {         IZooReaderWriter zoo = context.getZooReaderWriter();         if (zoo.isLockHeld(zooLock.getLockID())) {           op.run(zoo);         }         break;       } catch (Exception e) {         log.error(&quot;Unexpected exception {}&quot;, e.getMessage(), e);       }       sleepUninterruptibly(1, TimeUnit.SECONDS);     }   }    private static void addRootLogEntry(ServerContext context, ZooLock zooLock,       final LogEntry entry) {     retryZooKeeperUpdate(context, zooLock, new ZooOperation() {       @Override       public void run(IZooReaderWriter rw)           throws KeeperException, InterruptedException, IOException {         String root = getZookeeperLogLocation(context);         rw.putPersistentData(root + &quot;/&quot; + entry.getUniqueID(), entry.toBytes(),             NodeExistsPolicy.OVERWRITE);       }     });   }    public static SortedMap getDataFileSizes(KeyExtent extent,       ServerContext context) {     TreeMap sizes = new TreeMap&lt;&gt;();      try (Scanner mdScanner = new ScannerImpl(context, MetadataTable.ID, Authorizations.EMPTY)) {       mdScanner.fetchColumnFamily(DataFileColumnFamily.NAME);       Text row = extent.getMetadataEntry();        Key endKey = new Key(row, DataFileColumnFamily.NAME, new Text(&quot;&quot;));       endKey = endKey.followingKey(PartialKey.ROW_COLFAM);        mdScanner.setRange(new Range(new Key(row), endKey));       for (Entry entry : mdScanner) {          if (!entry.getKey().getRow().equals(row))           break;         DataFileValue dfv = new DataFileValue(entry.getValue().get());         sizes.put(new FileRef(context.getVolumeManager(), entry.getKey()), dfv);       }        return sizes;     }   }    public static void rollBackSplit(Text metadataEntry, Text oldPrevEndRow, ServerContext context,       ZooLock zooLock) {     KeyExtent ke = new KeyExtent(metadataEntry, oldPrevEndRow);     Mutation m = ke.getPrevRowUpdateMutation();     TabletsSection.TabletColumnFamily.SPLIT_RATIO_COLUMN.putDelete(m);     TabletsSection.TabletColumnFamily.OLD_PREV_ROW_COLUMN.putDelete(m);     update(context, zooLock, m, new KeyExtent(metadataEntry, (Text) null));   }    public static void splitTablet(KeyExtent extent, Text oldPrevEndRow, double splitRatio,       ServerContext context, ZooLock zooLock) {     Mutation m = extent.getPrevRowUpdateMutation(); //      TabletsSection.TabletColumnFamily.SPLIT_RATIO_COLUMN.put(m,         new Value(Double.toString(splitRatio).getBytes(UTF_8)));      TabletsSection.TabletColumnFamily.OLD_PREV_ROW_COLUMN.put(m,         KeyExtent.encodePrevEndRow(oldPrevEndRow));     ChoppedColumnFamily.CHOPPED_COLUMN.putDelete(m);     update(context, zooLock, m, extent);   }    public static void finishSplit(Text metadataEntry, Map datafileSizes,       List highDatafilesToRemove, final ServerContext context, ZooLock zooLock) {     Mutation m = new Mutation(metadataEntry);     TabletsSection.TabletColumnFamily.SPLIT_RATIO_COLUMN.putDelete(m);     TabletsSection.TabletColumnFamily.OLD_PREV_ROW_COLUMN.putDelete(m);     ChoppedColumnFamily.CHOPPED_COLUMN.putDelete(m);      for (Entry entry : datafileSizes.entrySet()) {       m.put(DataFileColumnFamily.NAME, entry.getKey().meta(), new Value(entry.getValue().encode()));     }      for (FileRef pathToRemove : highDatafilesToRemove) {       m.putDelete(DataFileColumnFamily.NAME, pathToRemove.meta());     }      update(context, zooLock, m, new KeyExtent(metadataEntry, (Text) null));   }    public static void finishSplit(KeyExtent extent, Map datafileSizes,       List highDatafilesToRemove, ServerContext context, ZooLock zooLock) {     finishSplit(extent.getMetadataEntry(), datafileSizes, highDatafilesToRemove, context, zooLock);   }    public static void addDeleteEntries(KeyExtent extent, Set datafilesToDelete,       ServerContext context) {      TableId tableId = extent.getTableId();      // TODO could use batch writer,would need to handle failure and retry like update does -     // ACCUMULO-1294     for (FileRef pathToRemove : datafilesToDelete) {       update(context, createDeleteMutation(context, tableId, pathToRemove.path().toString()),           extent);     }   }    public static void addDeleteEntry(ServerContext context, TableId tableId, String path) {     update(context, createDeleteMutation(context, tableId, path),         new KeyExtent(tableId, null, null));   }    public static Mutation createDeleteMutation(ServerContext context, TableId tableId,       String pathToRemove) {     Path path = context.getVolumeManager().getFullPath(tableId, pathToRemove);     Mutation delFlag = new Mutation(new Text(MetadataSchema.DeletesSection.getRowPrefix() + path));     delFlag.put(EMPTY_TEXT, EMPTY_TEXT, new Value(new byte[] {}));     return delFlag;   }    public static void removeScanFiles(KeyExtent extent, Set scanFiles,       ServerContext context, ZooLock zooLock) {     Mutation m = new Mutation(extent.getMetadataEntry());      for (FileRef pathToRemove : scanFiles)       m.putDelete(ScanFileColumnFamily.NAME, pathToRemove.meta());      update(context, zooLock, m, extent);   }    public static void splitDatafiles(Text midRow, double splitRatio,       Map firstAndLastRows, SortedMap datafiles,       SortedMap lowDatafileSizes,       SortedMap highDatafileSizes, List highDatafilesToRemove) {      for (Entry entry : datafiles.entrySet()) {        Text firstRow = null;       Text lastRow = null;        boolean rowsKnown = false;        FileUtil.FileInfo mfi = firstAndLastRows.get(entry.getKey());        if (mfi != null) {         firstRow = mfi.getFirstRow();         lastRow = mfi.getLastRow();         rowsKnown = true;       }        if (rowsKnown &amp;&amp; firstRow.compareTo(midRow) &gt; 0) {         // only in high         long highSize = entry.getValue().getSize();         long highEntries = entry.getValue().getNumEntries();         highDatafileSizes.put(entry.getKey(),             new DataFileValue(highSize, highEntries, entry.getValue().getTime()));       } else if (rowsKnown &amp;&amp; lastRow.compareTo(midRow) &lt;= 0) {         // only in low         long lowSize = entry.getValue().getSize();         long lowEntries = entry.getValue().getNumEntries();         lowDatafileSizes.put(entry.getKey(),             new DataFileValue(lowSize, lowEntries, entry.getValue().getTime()));          highDatafilesToRemove.add(entry.getKey());       } else {         long lowSize = (long) Math.floor((entry.getValue().getSize() * splitRatio));         long lowEntries = (long) Math.floor((entry.getValue().getNumEntries() * splitRatio));         lowDatafileSizes.put(entry.getKey(),             new DataFileValue(lowSize, lowEntries, entry.getValue().getTime()));          long highSize = (long) Math.ceil((entry.getValue().getSize() * (1.0 - splitRatio)));         long highEntries = (long) Math             .ceil((entry.getValue().getNumEntries() * (1.0 - splitRatio)));         highDatafileSizes.put(entry.getKey(),             new DataFileValue(highSize, highEntries, entry.getValue().getTime()));       }     }   }    public static void deleteTable(TableId tableId, boolean insertDeletes, ServerContext context,       ZooLock lock) throws AccumuloException {     try (Scanner ms = new ScannerImpl(context, MetadataTable.ID, Authorizations.EMPTY);         BatchWriter bw = new BatchWriterImpl(context, MetadataTable.ID,             new BatchWriterConfig().setMaxMemory(1000000)                 .setMaxLatency(120000L, TimeUnit.MILLISECONDS).setMaxWriteThreads(2))) {        // scan metadata for our table and delete everything we find       Mutation m = null;       ms.setRange(new KeyExtent(tableId, null, null).toMetadataRange());        // insert deletes before deleting data from metadata... this makes the code fault tolerant       if (insertDeletes) {          ms.fetchColumnFamily(DataFileColumnFamily.NAME);         TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.fetch(ms);          for (Entry cell : ms) {           Key key = cell.getKey();            if (key.getColumnFamily().equals(DataFileColumnFamily.NAME)) {             FileRef ref = new FileRef(context.getVolumeManager(), key);             bw.addMutation(createDeleteMutation(context, tableId, ref.meta().toString()));           }            if (TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.hasColumns(key)) {             bw.addMutation(createDeleteMutation(context, tableId, cell.getValue().toString()));           }         }          bw.flush();          ms.clearColumns();       }        for (Entry cell : ms) {         Key key = cell.getKey();          if (m == null) {           m = new Mutation(key.getRow());           if (lock != null)             putLockID(context, lock, m);         }          if (key.getRow().compareTo(m.getRow(), 0, m.getRow().length) != 0) {           bw.addMutation(m);           m = new Mutation(key.getRow());           if (lock != null)             putLockID(context, lock, m);         }         m.putDelete(key.getColumnFamily(), key.getColumnQualifier());       }        if (m != null)         bw.addMutation(m);     }   }    static String getZookeeperLogLocation(ServerContext context) {     return context.getZooKeeperRoot() + RootTable.ZROOT_TABLET_WALOGS;   }    public static void setRootTabletDir(ServerContext context, String dir) throws IOException {     IZooReaderWriter zoo = context.getZooReaderWriter();     String zpath = context.getZooKeeperRoot() + RootTable.ZROOT_TABLET_PATH;     try {       zoo.putPersistentData(zpath, dir.getBytes(UTF_8), -1, NodeExistsPolicy.OVERWRITE);     } catch (KeeperException e) {       throw new IOException(e);     } catch (InterruptedException e) {       Thread.currentThread().interrupt();       throw new IOException(e);     }   }    public static String getRootTabletDir(ServerContext context) throws IOException {     IZooReaderWriter zoo = context.getZooReaderWriter();     String zpath = context.getZooKeeperRoot() + RootTable.ZROOT_TABLET_PATH;     try {       return new String(zoo.getData(zpath, null), UTF_8);     } catch (KeeperException e) {       throw new IOException(e);     } catch (InterruptedException e) {       Thread.currentThread().interrupt();       throw new IOException(e);     }   }    public static Pair,SortedMap&gt; getFileAndLogEntries(       ServerContext context, KeyExtent extent)       throws KeeperException, InterruptedException, IOException {     ArrayList result = new ArrayList&lt;&gt;();     TreeMap sizes = new TreeMap&lt;&gt;();      VolumeManager fs = context.getVolumeManager();     if (extent.isRootTablet()) {       getRootLogEntries(context, result);       Path rootDir = new Path(getRootTabletDir(context));       FileStatus[] files = fs.listStatus(rootDir);       for (FileStatus fileStatus : files) {         if (fileStatus.getPath().toString().endsWith(&quot;_tmp&quot;)) {           continue;         }         DataFileValue dfv = new DataFileValue(0, 0);         sizes.put(new FileRef(fileStatus.getPath().toString(), fileStatus.getPath()), dfv);       }      } else {       try (TabletsMetadata tablets = TabletsMetadata.builder().forTablet(extent).fetchFiles()           .fetchLogs().fetchPrev().build(context)) {          TabletMetadata tablet = Iterables.getOnlyElement(tablets);          if (!tablet.getExtent().equals(extent))           throw new RuntimeException(               &quot;Unexpected extent &quot; + tablet.getExtent() + &quot; expected &quot; + extent);          result.addAll(tablet.getLogs());         tablet.getFilesMap().forEach((k, v) -&gt; {           sizes.put(new FileRef(k, fs.getFullPath(tablet.getTableId(), k)), v);         });       }     }      return new Pair&lt;&gt;(result, sizes);   }    public static List getLogEntries(ServerContext context, KeyExtent extent)       throws IOException, KeeperException, InterruptedException {     log.info(&quot;Scanning logging entries for {}&quot;, extent);     ArrayList result = new ArrayList&lt;&gt;();     if (extent.equals(RootTable.EXTENT)) {       log.info(&quot;Getting logs for root tablet from zookeeper&quot;);       getRootLogEntries(context, result);     } else {       log.info(&quot;Scanning metadata for logs used for tablet {}&quot;, extent);       Scanner scanner = getTabletLogScanner(context, extent);       Text pattern = extent.getMetadataEntry();       for (Entry entry : scanner) {         Text row = entry.getKey().getRow();         if (entry.getKey().getColumnFamily().equals(LogColumnFamily.NAME)) {           if (row.equals(pattern)) {             result.add(LogEntry.fromKeyValue(entry.getKey(), entry.getValue()));           }         }       }     }      log.info(&quot;Returning logs {} for extent {}&quot;, result, extent);     return result;   }    static void getRootLogEntries(ServerContext context, final ArrayList result)       throws KeeperException, InterruptedException, IOException {     IZooReaderWriter zoo = context.getZooReaderWriter();     String root = getZookeeperLogLocation(context);     // there's a little race between getting the children and fetching     // the data. The log can be removed in between.     while (true) {       result.clear();       for (String child : zoo.getChildren(root)) {         try {           LogEntry e = LogEntry.fromBytes(zoo.getData(root + &quot;/&quot; + child, null));           // upgrade from !0;!0&lt;&lt; -&gt; +r&lt;&lt;           e = new LogEntry(RootTable.EXTENT, 0, e.server, e.filename);           result.add(e);         } catch (KeeperException.NoNodeException ex) {           continue;         }       }       break;     }   }    private static Scanner getTabletLogScanner(ServerContext context, KeyExtent extent) {     TableId tableId = MetadataTable.ID;     if (extent.isMeta())       tableId = RootTable.ID;     Scanner scanner = new ScannerImpl(context, tableId, Authorizations.EMPTY);     scanner.fetchColumnFamily(LogColumnFamily.NAME);     Text start = extent.getMetadataEntry();     Key endKey = new Key(start, LogColumnFamily.NAME);     endKey = endKey.followingKey(PartialKey.ROW_COLFAM);     scanner.setRange(new Range(new Key(start), endKey));     return scanner;   }    private static class LogEntryIterator implements Iterator {      Iterator zookeeperEntries = null;     Iterator rootTableEntries = null;     Iterator&gt; metadataEntries = null;      LogEntryIterator(ServerContext context)         throws IOException, KeeperException, InterruptedException {       zookeeperEntries = getLogEntries(context, RootTable.EXTENT).iterator();       rootTableEntries = getLogEntries(context, new KeyExtent(MetadataTable.ID, null, null))           .iterator();       try {         Scanner scanner = context.createScanner(MetadataTable.NAME, Authorizations.EMPTY);         log.info(&quot;Setting range to {}&quot;, MetadataSchema.TabletsSection.getRange());         scanner.setRange(MetadataSchema.TabletsSection.getRange());         scanner.fetchColumnFamily(LogColumnFamily.NAME);         metadataEntries = scanner.iterator();       } catch (Exception ex) {         throw new IOException(ex);       }     }      @Override     public boolean hasNext() {       return zookeeperEntries.hasNext() || rootTableEntries.hasNext() || metadataEntries.hasNext();     }      @Override     public LogEntry next() {       if (zookeeperEntries.hasNext()) {         return zookeeperEntries.next();       }       if (rootTableEntries.hasNext()) {         return rootTableEntries.next();       }       Entry entry = metadataEntries.next();       return LogEntry.fromKeyValue(entry.getKey(), entry.getValue());     }      @Override     public void remove() {       throw new UnsupportedOperationException();     }   }    public static Iterator getLogEntries(ServerContext context)       throws IOException, KeeperException, InterruptedException {     return new LogEntryIterator(context);   }    public static void removeUnusedWALEntries(ServerContext context, KeyExtent extent,       final List entries, ZooLock zooLock) {     if (extent.isRootTablet()) {       retryZooKeeperUpdate(context, zooLock, new ZooOperation() {         @Override         public void run(IZooReaderWriter rw) throws KeeperException, InterruptedException {           String root = getZookeeperLogLocation(context);           for (LogEntry entry : entries) {             String path = root + &quot;/&quot; + entry.getUniqueID();             log.debug(&quot;Removing &quot; + path + &quot; from zookeeper&quot;);             rw.recursiveDelete(path, NodeMissingPolicy.SKIP);           }         }       });     } else {       Mutation m = new Mutation(extent.getMetadataEntry());       for (LogEntry entry : entries) {         m.putDelete(entry.getColumnFamily(), entry.getColumnQualifier());       }       update(context, zooLock, m, extent);     }   }    private static void getFiles(Set files, Collection tabletFiles,       TableId srcTableId) {     for (String file : tabletFiles) {       if (srcTableId != null &amp;&amp; !file.startsWith(&quot;../&quot;) &amp;&amp; !file.contains(&quot;:&quot;)) {         file = &quot;../&quot; + srcTableId + file;       }       files.add(file);     }   }    private static Mutation createCloneMutation(TableId srcTableId, TableId tableId,       Map tablet) {      KeyExtent ke = new KeyExtent(tablet.keySet().iterator().next().getRow(), (Text) null);     Mutation m = new Mutation(TabletsSection.getRow(tableId, ke.getEndRow()));      for (Entry entry : tablet.entrySet()) {       if (entry.getKey().getColumnFamily().equals(DataFileColumnFamily.NAME)) {         String cf = entry.getKey().getColumnQualifier().toString();         if (!cf.startsWith(&quot;../&quot;) &amp;&amp; !cf.contains(&quot;:&quot;))           cf = &quot;../&quot; + srcTableId + entry.getKey().getColumnQualifier();         m.put(entry.getKey().getColumnFamily(), new Text(cf), entry.getValue());       } else if (entry.getKey().getColumnFamily()           .equals(TabletsSection.CurrentLocationColumnFamily.NAME)) {         m.put(TabletsSection.LastLocationColumnFamily.NAME, entry.getKey().getColumnQualifier(),             entry.getValue());       } else if (entry.getKey().getColumnFamily()           .equals(TabletsSection.LastLocationColumnFamily.NAME)) {         // skip       } else {         m.put(entry.getKey().getColumnFamily(), entry.getKey().getColumnQualifier(),             entry.getValue());       }     }     return m;   }    private static Iterable createCloneScanner(String testTableName, TableId tableId,       AccumuloClient client) throws TableNotFoundException {      String tableName;     Range range;      if (testTableName != null) {       tableName = testTableName;       range = TabletsSection.getRange(tableId);     } else if (tableId.equals(MetadataTable.ID)) {       tableName = RootTable.NAME;       range = TabletsSection.getRange();     } else {       tableName = MetadataTable.NAME;       range = TabletsSection.getRange(tableId);     }      return TabletsMetadata.builder().scanTable(tableName).overRange(range).checkConsistency()         .saveKeyValues().fetchFiles().fetchLocation().fetchLast().fetchCloned().fetchPrev()         .fetchTime().build(client);   }    @VisibleForTesting   public static void initializeClone(String testTableName, TableId srcTableId, TableId tableId,       AccumuloClient client, BatchWriter bw)       throws TableNotFoundException, MutationsRejectedException {      Iterator ti = createCloneScanner(testTableName, srcTableId, client).iterator();      if (!ti.hasNext())       throw new RuntimeException(&quot; table deleted during clone?  srcTableId = &quot; + srcTableId);      while (ti.hasNext())       bw.addMutation(createCloneMutation(srcTableId, tableId, ti.next().getKeyValues()));      bw.flush();   }    private static int compareEndRows(Text endRow1, Text endRow2) {     return new KeyExtent(TableId.of(&quot;0&quot;), endRow1, null)         .compareTo(new KeyExtent(TableId.of(&quot;0&quot;), endRow2, null));   }    @VisibleForTesting   public static int checkClone(String testTableName, TableId srcTableId, TableId tableId,       AccumuloClient client, BatchWriter bw)       throws TableNotFoundException, MutationsRejectedException {      Iterator srcIter = createCloneScanner(testTableName, srcTableId, client)         .iterator();     Iterator cloneIter = createCloneScanner(testTableName, tableId, client)         .iterator();      if (!cloneIter.hasNext() || !srcIter.hasNext())       throw new RuntimeException(           &quot; table deleted during clone?  srcTableId = &quot; + srcTableId + &quot; tableId=&quot; + tableId);      int rewrites = 0;      while (cloneIter.hasNext()) {       TabletMetadata cloneTablet = cloneIter.next();       Text cloneEndRow = cloneTablet.getEndRow();       HashSet cloneFiles = new HashSet&lt;&gt;();        boolean cloneSuccessful = cloneTablet.getCloned() != null;        if (!cloneSuccessful)         getFiles(cloneFiles, cloneTablet.getFiles(), null);        List srcTablets = new ArrayList&lt;&gt;();       TabletMetadata srcTablet = srcIter.next();       srcTablets.add(srcTablet);        Text srcEndRow = srcTablet.getEndRow();       int cmp = compareEndRows(cloneEndRow, srcEndRow);       if (cmp &lt; 0)         throw new TabletDeletedException(             &quot;Tablets deleted from src during clone : &quot; + cloneEndRow + &quot; &quot; + srcEndRow);        HashSet srcFiles = new HashSet&lt;&gt;();       if (!cloneSuccessful)         getFiles(srcFiles, srcTablet.getFiles(), srcTableId);        while (cmp &gt; 0) {         srcTablet = srcIter.next();         srcTablets.add(srcTablet);         srcEndRow = srcTablet.getEndRow();         cmp = compareEndRows(cloneEndRow, srcEndRow);         if (cmp &lt; 0)           throw new TabletDeletedException(               &quot;Tablets deleted from src during clone : &quot; + cloneEndRow + &quot; &quot; + srcEndRow);          if (!cloneSuccessful)           getFiles(srcFiles, srcTablet.getFiles(), srcTableId);       }        if (cloneSuccessful)         continue;        if (!srcFiles.containsAll(cloneFiles)) {         // delete existing cloned tablet entry         Mutation m = new Mutation(cloneTablet.getExtent().getMetadataEntry());          for (Entry entry : cloneTablet.getKeyValues().entrySet()) {           Key k = entry.getKey();           m.putDelete(k.getColumnFamily(), k.getColumnQualifier(), k.getTimestamp());         }          bw.addMutation(m);          for (TabletMetadata st : srcTablets)           bw.addMutation(createCloneMutation(srcTableId, tableId, st.getKeyValues()));          rewrites++;       } else {         // write out marker that this tablet was successfully cloned         Mutation m = new Mutation(cloneTablet.getExtent().getMetadataEntry());         m.put(ClonedColumnFamily.NAME, new Text(&quot;&quot;), new Value(&quot;OK&quot;.getBytes(UTF_8)));         bw.addMutation(m);       }     }      bw.flush();     return rewrites;   }    public static void cloneTable(ServerContext context, TableId srcTableId, TableId tableId,       VolumeManager volumeManager) throws Exception {      try (BatchWriter bw = context.createBatchWriter(MetadataTable.NAME, new BatchWriterConfig())) {        while (true) {          try {           initializeClone(null, srcTableId, tableId, context, bw);            // the following loop looks changes in the file that occurred during the copy.. if files           // were dereferenced then they could have been GCed            while (true) {             int rewrites = checkClone(null, srcTableId, tableId, context, bw);              if (rewrites == 0)               break;           }            bw.flush();           break;          } catch (TabletDeletedException tde) {           // tablets were merged in the src table           bw.flush();            // delete what we have cloned and try again           deleteTable(tableId, false, context, null);            log.debug(&quot;Tablets merged in table {} while attempting to clone, trying again&quot;,               srcTableId);            sleepUninterruptibly(100, TimeUnit.MILLISECONDS);         }       }        // delete the clone markers and create directory entries       Scanner mscanner = context.createScanner(MetadataTable.NAME, Authorizations.EMPTY);       mscanner.setRange(new KeyExtent(tableId, null, null).toMetadataRange());       mscanner.fetchColumnFamily(ClonedColumnFamily.NAME);        int dirCount = 0;        for (Entry entry : mscanner) {         Key k = entry.getKey();         Mutation m = new Mutation(k.getRow());         m.putDelete(k.getColumnFamily(), k.getColumnQualifier());         VolumeChooserEnvironment chooserEnv = new VolumeChooserEnvironmentImpl(tableId,             new KeyExtent(k.getRow(), (Text) null).getEndRow(), context);         String dir = volumeManager.choose(chooserEnv, ServerConstants.getBaseUris(context))             + Constants.HDFS_TABLES_DIR + Path.SEPARATOR + tableId + Path.SEPARATOR + new String(                 FastFormat.toZeroPaddedString(dirCount++, 8, 16, Constants.CLONE_PREFIX_BYTES));         TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.put(m, new Value(dir.getBytes(UTF_8)));          bw.addMutation(m);       }     }   }    public static void chopped(ServerContext context, KeyExtent extent, ZooLock zooLock) {     Mutation m = new Mutation(extent.getMetadataEntry());     ChoppedColumnFamily.CHOPPED_COLUMN.put(m, new Value(&quot;chopped&quot;.getBytes(UTF_8)));     update(context, zooLock, m, extent);   }    public static void removeBulkLoadEntries(AccumuloClient client, TableId tableId, long tid)       throws Exception {     try (         Scanner mscanner = new IsolatedScanner(             client.createScanner(MetadataTable.NAME, Authorizations.EMPTY));         BatchWriter bw = client.createBatchWriter(MetadataTable.NAME, new BatchWriterConfig())) {       mscanner.setRange(new KeyExtent(tableId, null, null).toMetadataRange());       mscanner.fetchColumnFamily(TabletsSection.BulkFileColumnFamily.NAME);       byte[] tidAsBytes = Long.toString(tid).getBytes(UTF_8);       for (Entry entry : mscanner) {         log.trace(&quot;Looking at entry {} with tid {}&quot;, entry, tid);         if (Arrays.equals(entry.getValue().get(), tidAsBytes)) {           log.trace(&quot;deleting entry {}&quot;, entry);           Key key = entry.getKey();           Mutation m = new Mutation(key.getRow());           m.putDelete(key.getColumnFamily(), key.getColumnQualifier());           bw.addMutation(m);         }       }     }   }    public static List getBulkFilesLoaded(ServerContext context, AccumuloClient client,       KeyExtent extent, long tid) {     List result = new ArrayList&lt;&gt;();     try (Scanner mscanner = new IsolatedScanner(client.createScanner(         extent.isMeta() ? RootTable.NAME : MetadataTable.NAME, Authorizations.EMPTY))) {       VolumeManager fs = context.getVolumeManager();       mscanner.setRange(extent.toMetadataRange());       mscanner.fetchColumnFamily(TabletsSection.BulkFileColumnFamily.NAME);       for (Entry entry : mscanner) {         if (Long.parseLong(entry.getValue().toString()) == tid) {           result.add(new FileRef(fs, entry.getKey()));         }       }        return result;     } catch (TableNotFoundException ex) {       // unlikely       throw new RuntimeException(&quot;Onos! teh metadata table has vanished!!&quot;);     }   }    public static Map&gt; getBulkFilesLoaded(ServerContext context,       KeyExtent extent) {     Text metadataRow = extent.getMetadataEntry();     Map&gt; result = new HashMap&lt;&gt;();      VolumeManager fs = context.getVolumeManager();     try (Scanner scanner = new ScannerImpl(context,         extent.isMeta() ? RootTable.ID : MetadataTable.ID, Authorizations.EMPTY)) {       scanner.setRange(new Range(metadataRow));       scanner.fetchColumnFamily(TabletsSection.BulkFileColumnFamily.NAME);       for (Entry entry : scanner) {         Long tid = Long.parseLong(entry.getValue().toString());         List lst = result.get(tid);         if (lst == null) {           result.put(tid, lst = new ArrayList&lt;&gt;());         }         lst.add(new FileRef(fs, entry.getKey()));       }     }     return result;   }    public static void addBulkLoadInProgressFlag(ServerContext context, String path) {      Mutation m = new Mutation(MetadataSchema.BlipSection.getRowPrefix() + path);     m.put(EMPTY_TEXT, EMPTY_TEXT, new Value(new byte[] {}));      // new KeyExtent is only added to force update to write to the metadata table, not the root     // table     // because bulk loads aren't supported to the metadata table     update(context, m, new KeyExtent(TableId.of(&quot;anythingNotMetadata&quot;), null, null));   }    public static void removeBulkLoadInProgressFlag(ServerContext context, String path) {      Mutation m = new Mutation(MetadataSchema.BlipSection.getRowPrefix() + path);     m.putDelete(EMPTY_TEXT, EMPTY_TEXT);      // new KeyExtent is only added to force update to write to the metadata table, not the root     // table     // because bulk loads aren't supported to the metadata table     update(context, m, new KeyExtent(TableId.of(&quot;anythingNotMetadata&quot;), null, null));   }    /**    * During an upgrade from 1.6 to 1.7, we need to add the replication table    */   public static void createReplicationTable(ServerContext context) {      VolumeChooserEnvironment chooserEnv = new VolumeChooserEnvironmentImpl(ReplicationTable.ID,         null, context);     String dir = context.getVolumeManager().choose(chooserEnv, ServerConstants.getBaseUris(context))         + Constants.HDFS_TABLES_DIR + Path.SEPARATOR + ReplicationTable.ID         + Constants.DEFAULT_TABLET_LOCATION;      Mutation m = new Mutation(new Text(TabletsSection.getRow(ReplicationTable.ID, null)));     m.put(DIRECTORY_COLUMN.getColumnFamily(), DIRECTORY_COLUMN.getColumnQualifier(), 0,         new Value(dir.getBytes(UTF_8)));     m.put(TIME_COLUMN.getColumnFamily(), TIME_COLUMN.getColumnQualifier(), 0,         new Value((TabletTime.LOGICAL_TIME_ID + &quot;0&quot;).getBytes(UTF_8)));     m.put(PREV_ROW_COLUMN.getColumnFamily(), PREV_ROW_COLUMN.getColumnQualifier(), 0,         KeyExtent.encodePrevEndRow(null));     update(context, getMetadataTable(context), null, m);   }    /**    * During an upgrade we need to move deletion requests for files under the !METADATA table to the    * root tablet.    */   public static void moveMetaDeleteMarkers(ServerContext context) {     String oldDeletesPrefix = &quot;!!~del&quot;;     Range oldDeletesRange = new Range(oldDeletesPrefix, true, &quot;!!~dem&quot;, false);      // move old delete markers to new location, to standardize table schema between all metadata     // tables     try (Scanner scanner = new ScannerImpl(context, RootTable.ID, Authorizations.EMPTY)) {       scanner.setRange(oldDeletesRange);       for (Entry entry : scanner) {         String row = entry.getKey().getRow().toString();         if (row.startsWith(oldDeletesPrefix)) {           moveDeleteEntry(context, RootTable.OLD_EXTENT, entry, row, oldDeletesPrefix);         } else {           break;         }       }     }   }    public static void moveMetaDeleteMarkersFrom14(ServerContext context) {     // new KeyExtent is only added to force update to write to the metadata table, not the root     // table     KeyExtent notMetadata = new KeyExtent(TableId.of(&quot;anythingNotMetadata&quot;), null, null);      // move delete markers from the normal delete keyspace to the root tablet delete keyspace if the     // files are for the !METADATA table     try (Scanner scanner = new ScannerImpl(context, MetadataTable.ID, Authorizations.EMPTY)) {       scanner.setRange(MetadataSchema.DeletesSection.getRange());       for (Entry entry : scanner) {         String row = entry.getKey().getRow().toString();         if (row.startsWith(MetadataSchema.DeletesSection.getRowPrefix() + &quot;/&quot; + MetadataTable.ID)) {           moveDeleteEntry(context, notMetadata, entry, row,               MetadataSchema.DeletesSection.getRowPrefix());         } else {           break;         }       }     }   }    private static void moveDeleteEntry(ServerContext context, KeyExtent oldExtent,       Entry entry, String rowID, String prefix) {     String filename = rowID.substring(prefix.length());      // add the new entry first     log.info(&quot;Moving {} marker in {}&quot;, filename, RootTable.NAME);     Mutation m = new Mutation(MetadataSchema.DeletesSection.getRowPrefix() + filename);     m.put(EMPTY_BYTES, EMPTY_BYTES, EMPTY_BYTES);     update(context, m, RootTable.EXTENT);      // then remove the old entry     m = new Mutation(entry.getKey().getRow());     m.putDelete(EMPTY_BYTES, EMPTY_BYTES);     update(context, m, oldExtent);   }    public static SortedMap&gt; getTabletEntries(       SortedMap tabletKeyValues, List columns) {     TreeMap&gt; tabletEntries = new TreeMap&lt;&gt;();      HashSet colSet = null;     if (columns != null) {       colSet = new HashSet&lt;&gt;(columns);     }      for (Entry entry : tabletKeyValues.entrySet()) {       ColumnFQ currentKey = new ColumnFQ(entry.getKey());       if (columns != null &amp;&amp; !colSet.contains(currentKey)) {         continue;       }        Text row = entry.getKey().getRow();        SortedMap colVals = tabletEntries.get(row);       if (colVals == null) {         colVals = new TreeMap&lt;&gt;();         tabletEntries.put(row, colVals);       }        colVals.put(currentKey, entry.getValue());     }      return tabletEntries;   }  }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method,  data class</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15035</td>
    <td align="left">https://github.com/apache/accumulo/blob/f896c98c2356a52dfa2235d2cc02ae556ab17909/server/base/src/main/java/org/apache/accumulo/server/util/MetadataTableUtil.java/#L106-L1133</td>
    <td align="right">1</td>
    <td align="right">2610</td>
    <td align="right">15035</td>
  </tr>
  <tr valign="top">
    <td align="right">2688</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [         &quot;Blob&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Builder {  	public static boolean isForced(Map options) { 		return Boolean.TRUE.equals(options.get(&quot;force&quot;)); 	}  	private Properties options = new Properties(); 	private BuilderExtension[] extensions = new BuilderExtension[0];  	private Logger logger = new NullLogger(); 	private ConfigurationRegistry registry; 	private ConfigObject configObject = null; 	private boolean isIncremental = false; 	private boolean enabledMetadata = false;  	private File sourceDir = null;  	/** 	 * The value is a String[] containing the relative paths of all of the build 	 * files for a given sourceDir. 	 */ 	private final Map buildFilesBySourceDir = new HashMap&lt;&gt;(); 	/*[PR 118220] Incremental builder is not called when file is deleted in base library*/ 	private final Map&gt; deleteFilesBySourceDir = new HashMap&lt;&gt;(); 	private final Map&gt; buildResourcesBySourceDir = new HashMap&lt;&gt;();  	private int buildFileCount = 0; 	private int deleteFileCount = 0; 	private int builtFileCount = 0; 	private int buildResourcesCount = 0; 	private File outputDir = null; 	private boolean verdict = false; 	private boolean includeIfUnsure = false; 	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 	private boolean isTestsBootPath = false; 	private boolean noWarnIncludeIf = false; 	private boolean noWarnInvalidFlags = false; 	private boolean multipleSources = false; 	private boolean updateAllCopyrights = false;  	/** 	 * J9 JCL Preprocessor builder constructor.  Initializes the needed extensions. 	 */ 	public Builder() { 		addExtension(new ExternalMessagesExtension()); 		addExtension(new MacroExtension()); 		addExtension(new JxeRulesExtension()); 		addExtension(new EclipseMetadataExtension()); 		addExtension(new JitAttributesExtension()); 		addExtension(new TagExtension()); 	}  	/** 	 * Sets the preprocess options. 	 * 	 * @param 		options		the preprocess options 	 */ 	public void setOptions(Properties options) { 		if (options != null) { 			this.options.putAll(options); 		} 		this.options = options; 	}  	/** 	 * Returns the preprocess options for this builder. 	 * 	 * @return		the preprocess options 	 */ 	public Properties getOptions() { 		return this.options; 	}  	/** 	 * Adds an extension to the builder. 	 * 	 * @param 		extension	the extension to add 	 */ 	public void addExtension(BuilderExtension extension) { 		if (extension == null) { 			throw new NullPointerException(); 		}  		BuilderExtension[] newExtensions = new BuilderExtension[extensions.length + 1]; 		if (extensions.length &gt; 0) { 			System.arraycopy(extensions, 0, newExtensions, 0, extensions.length); 		} 		newExtensions[newExtensions.length - 1] = extension; 		this.extensions = newExtensions;  		extension.setBuilder(this); 	}  	/** 	 * Returns the builder extensions/ 	 * 	 * @return		the builder extensions 	 */ 	public BuilderExtension[] getExtensions() { 		return extensions; 	}  	/** 	 * Returns the logger associated with this builder. 	 * 	 * @return		the logger 	 */ 	public Logger getLogger() { 		return logger; 	}  	/** 	 * Sets this builder's logger. 	 * 	 * @param 		logger		the new logger 	 */ 	public void setLogger(Logger logger) { 		this.logger = logger; 	}  	/** 	 * Sets whether the build is incremental or not. 	 * 	 * @param 		isIncremental	true if the build is incremental, false otherwise 	 */ 	public void setIncremental(boolean isIncremental) { 		this.isIncremental = isIncremental; 	}  	/** 	 * Returns wheter or not this builder will only do an incremental build. 	 * 	 * @return		true if the build is incremental, false otherwise 	 */ 	public boolean isIncremental() { 		return this.isIncremental; 	}  	/** 	 * Sets whether or not preprocessor metadata will be generated. 	 * 	 * @param 		enabledMetadata		true if metadata is to be generated, 	 * 									false otherwise 	 */ 	public void setMetadata(boolean enabledMetadata) { 		this.enabledMetadata = enabledMetadata; 	}  	/** 	 * Returns whether or not preprocessor metadata is enabled. 	 * 	 * @return		true if metadata will be written, false otherwise 	 */ 	public boolean isMetadataEnabled() { 		return this.enabledMetadata; 	}  	/** 	 * Sets whether or not the preprocessor should include files that do not 	 * have a INCLUDE-IF tag. 	 * 	 * @param 		include		true if files with no INCLUDE-IF should 	 * 							be included, false otherwise 	 */ 	public void setIncludeIfUnsure(boolean include) { 		this.includeIfUnsure = include; 	}  	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 	/** 	 * Sets whether or not the preprocessor is running to generate Tests Boot Path project 	 * 	 * @param 	isTestsBoot		true if preprocessor is running to generate Tests Boot Path project, 	 * 							false otherwise 	 */ 	public void setIsTestsBoot(boolean isTestsBoot) { 		this.isTestsBootPath = isTestsBoot; 	}  	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 	/** 	 * Sets whether or not the preprocessor should give warningsor errors about the files that do not 	 * have a INCLUDE-IF tag. 	 * 	 * @param 		warning		true if files with no INCLUDE-IF should 	 * 							be marked with warning or error, false otherwise 	 */ 	public void setNoWarnIncludeIf(boolean warning) { 		this.noWarnIncludeIf = warning; 	}  	/** 	 * Sets the configuration to preprocess. 	 * 	 * @param 		config		the configuration to preprocess 	 */ 	public void setConfiguration(ConfigObject config) { 		if (config.isSet()) { 			System.err.println(&quot;Warning: Builder is using &quot; + config + &quot;, a set, not a configuration.&quot;); 		} 		this.configObject = config; 		this.registry = config.getRegistry(); 		this.outputDir = config.getOutputDir(); 	}  	/** 	 * Returns this builder's output directory. 	 * 	 * @return		the output directory 	 */ 	public File getOutputDir() { 		return this.outputDir; 	}  	/** 	 * Sets this builder's output directory. 	 * 	 * @param 		outputDir	the new output directory 	 */ 	public void setOutputDir(File outputDir) { 		if (outputDir == null) { 			throw new NullPointerException(); 		} 		this.outputDir = outputDir; 	}  	/** 	 * Returns this builder's configuration source directories. 	 * 	 * @return		the config's source dirs 	 */ 	public File getSourceDir() { 		return this.sourceDir; 	}  	/** 	 * Sets the proprocess job's source directory. 	 * 	 * @param 		sourceDir	the source directory to preprocess 	 */ 	public void setSourceDir(File sourceDir) { 		if (sourceDir == null) { 			throw new NullPointerException(); 		} else { 			this.sourceDir = sourceDir; 		} 	}  	/** 	 * Set builder aware of other sources (to be used by the ExternalMessagesExtension). 	 * 	 * @param 		multipleSources		true if there are other sources, false otherwise 	 */ 	public void setMultipleSources(boolean multipleSources) { 		this.multipleSources = multipleSources; 	}  	/** 	 * Returns whether or not the configuration that setup this builder has multiple sources. 	 * 	 * @return		true if there are other sources, false otherwise 	 */ 	public boolean hasMultipleSources() { 		return multipleSources; 	}  	/** 	 * Performs the build. 	 */ 	public boolean build() { 		//create output dir even if no file is gonna be included in preprocess 		getOutputDir().mkdirs(); 		if (validateOptions()) { 			computeBuildFiles(); 			notifyBuildBegin();  			PreprocessorFactory factory = newPreprocessorFactory(); 			boolean force = isForced(this.options);  			//Ignore folders that do not exist (warning thrown in computeBuildFiles() 			if (sourceDir != null) { 				File metadataDir = new File(outputDir.getParentFile(), &quot;jppmd&quot;); 				String[] buildFiles = buildFilesBySourceDir.get(sourceDir); 				getLogger().log(&quot;\nPreprocessing &quot; + sourceDir.getAbsolutePath(), 1); 				builtFileCount = 0;  				for (String buildFile : buildFiles) { 					File sourceFile = new File(sourceDir, buildFile); 					File outputFile = new File(outputDir, buildFile); 					File metadataFile = new File(metadataDir, buildFile + &quot;.jppmd&quot;);  					notifyBuildFileBegin(sourceFile, outputFile, buildFile);  					try (OutputStream metadataOutput = new PhantomOutputStream(metadataFile); 						 OutputStream output = new PhantomOutputStream(outputFile, force)) {  						// configure the preprocessor and let extensions do the same 						JavaPreprocessor jpp;  						if (enabledMetadata) { 							jpp = factory.newPreprocessor(metadataOutput, sourceFile, output, outputFile); 						} else { 							jpp = factory.newPreprocessor(sourceFile, output); 						}  						Calendar cal = new GregorianCalendar(); 						if (!updateAllCopyrights) { 							cal.setTime(new Date(sourceFile.lastModified())); 						} 						jpp.setCopyrightYear(cal.get(Calendar.YEAR)); 						jpp.addValidFlags(registry.getValidFlags()); 						/*[PR 120411] Use a javadoc tag instead of TestBootpath preprocessor tag*/ 						jpp.setTestBootPath(isTestsBootPath); 						notifyConfigurePreprocessor(jpp);  						// preprocess 						boolean included = false; 						try { 							included = jpp.preprocess(); 							if (included) { 								builtFileCount++; 							} 							handlePreprocessorWarnings(jpp, sourceFile); 						} catch (Throwable t) { 							handlePreprocessorException(t, sourceFile); 						}  						if (!included &amp;&amp; outputFile.exists()) { 							outputFile.delete(); 						}  						if (!included &amp;&amp; metadataFile.exists()) { 							metadataFile.delete(); 						} 					} catch (Throwable t) { 						getLogger().log(&quot;Exception occured in file &quot; + sourceFile.getAbsolutePath() + &quot;, preprocess failed.&quot;, 3, t); 						handleBuildException(t); 					} finally { 						notifyBuildFileEnd(sourceFile, outputFile, buildFile); 					} 				}  				logger.log(builtFileCount + &quot; of &quot; + buildFileCount + &quot; file(s) included in preprocess&quot;, 1);  				/*[PR 118220] Incremental builder is not called when file is deleted in base library*/ 				List deleteFiles = deleteFilesBySourceDir.get(sourceDir); 				if (deleteFiles != null &amp;&amp; deleteFiles.size() != 0) { 					int deletedFilesCount = 0; 					for (String file : deleteFiles) { 						File deleteFile = new File(outputDir, file); 						if (deleteFile.exists()) { 							deletedFilesCount++; 							deleteFile.delete(); 						} 					} 					getLogger().log(deletedFilesCount + &quot; of &quot; + deleteFileCount 							+ &quot; file(s) deleted in preprocess from &quot; + outputDir.getAbsolutePath(), 1); 				} 			} 			/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 			List buildResources = buildResourcesBySourceDir.get(sourceDir); 			if (buildResources != null &amp;&amp; buildResources.size() != 0) { 				int copiedResourcesCount = 0; 				int deletedResorucesCount = 0; 				String outputpath; 				if (isTestsBootPath) { 					outputpath = configObject.getBootTestsOutputPath(); 				} else { 					outputpath = configObject.getTestsOutputPath(); 				} 				for (String file : buildResources) { 					File resource_out = new File(outputpath, file); 					File resource_src = new File(sourceDir, file); 					if (resource_src.exists()) { 						copyResource(resource_src, resource_out); 						copiedResourcesCount++; 					} else { 						resource_out.delete(); 						deletedResorucesCount++; 					} 				}  				getLogger().log(&quot;Total Build Resource Count : &quot; + buildResourcesCount, 1); 				getLogger().log(&quot;  - &quot; + copiedResourcesCount + &quot; resource&quot; + (copiedResourcesCount &gt; 1 ? &quot;s are &quot; : &quot; is &quot;) + &quot;copied to &quot; + outputpath, 1); 				getLogger().log(&quot;  - &quot; + deletedResorucesCount + &quot; resource&quot; + (deletedResorucesCount &gt; 1 ? &quot;s are &quot; : &quot; is &quot;) + &quot;deleted from &quot; + outputpath, 1); 			}  			notifyBuildEnd(); 		}  		if (logger.getErrorCount() == 0) { 			if (verdict) { 				getLogger().log(&quot;PREPROCESS WAS SUCCESSFUL&quot;, 1); 			} 			return true; 		} else { 			if (verdict) { 				getLogger().log(&quot;PREPROCESS WAS NOT SUCCESSFUL&quot;, 1); 			} 			return false; 		} 	}  	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 	public static void copyResource(File source, File destination) { 		destination.delete();  		try { 			SimpleCopy.copyFile(source, destination); 		} catch (IOException e) { 			System.err.println(&quot;ERROR - Could not copy the file to destination&quot;); 			System.err.println(&quot;   Source: &quot; + source.toString()); 			System.err.println(&quot;   Destination: &quot; + destination.toString()); 			e.printStackTrace(); 		} 	}  	/** 	 * Validates the build options. 	 */ 	private boolean validateOptions() { 		boolean isValid = true;  		if (configObject == null) { 			configObject = registry.getConfiguration(options.getProperty(&quot;config&quot;)); 		} 		this.options.putAll(configObject.getOptions());  		// check for the verdict option 		if (options.containsKey(&quot;verdict&quot;)) { 			this.verdict = true; 		}  		if (options.containsKey(&quot;includeifunsure&quot;)) { 			setIncludeIfUnsure(true); 		} 		if (options.containsKey(&quot;nowarnincludeif&quot;)) { 			setNoWarnIncludeIf(true); 		}  		if (options.containsKey(&quot;nowarninvalidflags&quot;)) { 			this.noWarnInvalidFlags = true; 		}  		if (options.containsKey(&quot;updateallcopyrights&quot;)) { 			this.updateAllCopyrights = true; 		}  		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				extension.validateOptions(this.options); 			} 		} catch (BuilderConfigurationException e) { 			logger.log(&quot;A configuration exception occured&quot;, Logger.SEVERITY_FATAL, e); 			isValid = false; 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking validateOptions() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 		return isValid; 	}  	/** 	 * Notifies the extensions that the build is beginning. 	 */ 	private void notifyBuildBegin() { 		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyBuildBegin(); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyBuildBegin() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Notifies the extensions that the build is ending. 	 */ 	private void notifyBuildEnd() { 		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyBuildEnd(); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyBuildEnd() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Notifies the extensions that the build is beginning on the specified 	 * file. 	 */ 	private void notifyBuildFileBegin(File sourceFile, File outputFile, String relativePath) { 		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyBuildFileBegin(sourceFile, outputFile, relativePath); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyBuildFileBegin() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Notifies the extensions that the build is ending on the specified file. 	 */ 	private void notifyBuildFileEnd(File sourceFile, File outputFile, String relativePath) { 		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyBuildFileEnd(sourceFile, outputFile, relativePath); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyBuildFileEnd() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Notifies the extensions that they should configure the preprocessor. 	 */ 	private void notifyConfigurePreprocessor(JavaPreprocessor preprocessor) { 		preprocessor.setIncludeIfUnsure(this.includeIfUnsure); 		preprocessor.setNoWarnIncludeIf(this.noWarnIncludeIf);  		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyConfigurePreprocessor(preprocessor); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyConfigurePreprocessor() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Handles exceptions thrown while building. 	 */ 	private void handleBuildException(Throwable t) { 		if (t instanceof Error) { 			logger.log(&quot;An error occured while building&quot;, Logger.SEVERITY_FATAL, t); 			throw (Error) t; 		} else { 			logger.log(&quot;An exception occured while building&quot;, Logger.SEVERITY_ERROR, t); 		} 	}  	/** 	 * Handles exceptions thrown by the preprocessor. 	 */ 	private void handlePreprocessorException(Throwable t, File sourceFile) { 		if (t instanceof Error) { 			logger.log(&quot;An error occured while invoking the preprocessor&quot;, &quot;preprocessor&quot;, Logger.SEVERITY_FATAL, sourceFile, t); 			throw (Error) t; 		} else { 			logger.log(&quot;An exception occured while invoking the preprocessor&quot;, &quot;preprocessor&quot;, Logger.SEVERITY_ERROR, sourceFile, t); 		} 	}  	/** 	 * Handles warnings generated by the preprocessor. 	 */ 	private void handlePreprocessorWarnings(JavaPreprocessor jpp, File sourceFile) { 		if (jpp.hasWarnings()) { 			for (PreprocessorWarning warning : jpp.getWarnings()) { 				int severity = warning.shouldFail() ? Logger.SEVERITY_ERROR : Logger.SEVERITY_WARNING; 				/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 				if (warning.getMessage().startsWith(&quot;No INCLUDE-IF&quot;) &amp;&amp; sourceFile.getAbsolutePath().endsWith(&quot;.java&quot;) &amp;&amp; !includeIfUnsure &amp;&amp; !isTestsBootPath) { 					severity = Logger.SEVERITY_ERROR; 				}  				if (warning.getMessage().startsWith(&quot;Ignoring copyright&quot;)) { 					severity = Logger.SEVERITY_INFO; 				}  				logger.log(warning.getMessage(), &quot;preprocessor&quot;, severity, sourceFile, warning.getLine(), warning.getCharstart(), warning.getCharend()); 			} 		}  		if (!noWarnInvalidFlags) { 			for (PreprocessorWarning warning : jpp.getInvalidFlags()) { 				logger.log(warning.getMessage(), &quot;preprocessor&quot;, Logger.SEVERITY_ERROR, sourceFile, warning.getLine(), warning.getCharstart(), warning.getCharend()); 			} 		} 	}  	/** 	 * Determines whether the specified source file should be built. 	 */ 	private boolean shouldBuild(File sourceFile, File outputFile, String relativePath) { 		// call the method for all the extensions 		for (BuilderExtension extension : extensions) { 			logger.setMessageSource(extension.getName()); 			boolean shouldBuild = extension.shouldBuild(sourceFile, outputFile, relativePath); 			logger.setMessageSource(null); 			if (!shouldBuild) { 				return false; 			} 		}  		return true; 	}  	/*[PR 118220] Incremental builder is not called when file is deleted in base library*/ 	/** 	 * Returns the deleted Files 	 */ 	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 	private List getDeletedFiles(File sourceDir) { 		// call the method for all the extensions 		for (BuilderExtension extension : extensions) { 			logger.setMessageSource(extension.getName()); 			List elements = extension.getDeleteFiles(sourceDir); 			logger.setMessageSource(null); 			if (elements != null) { 				return elements; 			} 		}  		return null; 	}  	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 	private List getBuildResources(File sourceDir) { 		// call the method for all the extensions 		for (BuilderExtension extension : extensions) { 			logger.setMessageSource(extension.getName()); 			List elements = extension.getBuildResources(sourceDir); 			logger.setMessageSource(null); 			if (elements != null) { 				return elements; 			} 		} 		return null; 	}  	/** 	 * Creates a new PreprocessorFactory object. 	 */ 	private PreprocessorFactory newPreprocessorFactory() { 		PreprocessorFactory factory = new PreprocessorFactory(); 		/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 		factory.setFlags(this.configObject.getFlagsAsArray()); 		factory.setRequiredIncludeFlags(this.configObject.getRequiredIncludeFlagSet()); 		return factory; 	}  	/** 	 * Recursively searches the given root directory to find all files. The file 	 * paths are returned, relative to the root directory. 	 */ 	private List getFiles(File rootDirectory) { 		List fileList = new ArrayList&lt;&gt;(); 		File[] files = rootDirectory.listFiles();  		if (files == null) { 			StringBuffer msg = new StringBuffer(&quot;Error reading the source directory \&quot;&quot;); 			msg.append(rootDirectory.getAbsolutePath()); 			msg.append(&quot;\&quot; - No Files copied&quot;); 			getLogger().log(msg.toString(), 2); 			verdict = false; 		} else { 			getFiles(files, &quot;&quot;, fileList); 		}  		return fileList; 	}  	/** 	 * This is a helper function to getFiles(File); 	 */ 	private static void getFiles(File[] files, String relativePath, List fileList) { 		for (File file : files) { 			if (file.isFile()) { 				fileList.add(relativePath + file.getName()); 			} else { 				String childRelativePath = relativePath + file.getName() + File.separator; 				getFiles(file.listFiles(), childRelativePath, fileList); 			} 		} 	}  	private void computeBuildFiles() { 		if (sourceDir.exists()) { 			List allFiles = getFiles(sourceDir); 			List buildFiles = new ArrayList&lt;&gt;(allFiles.size()); 			for (int j = 0; j &lt; allFiles.size(); j++) { 				String currentFile = allFiles.get(j).toString(); 				if (shouldBuild(sourceDir, outputDir, currentFile)) { 					buildFiles.add(currentFile); 				} 			}  			String[] buildFilesArray = buildFiles.toArray(new String[buildFiles.size()]); 			buildFilesBySourceDir.put(sourceDir, buildFilesArray); 			buildFileCount += buildFilesArray.length; 			/*[PR 118220] Incremental builder is not called when file is deleted in base library*/ 			/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 			List deleteFiles = getDeletedFiles(sourceDir); 			if (deleteFiles != null &amp;&amp; deleteFiles.size() != 0) { 				deleteFileCount = deleteFiles.size(); 				deleteFilesBySourceDir.put(sourceDir, deleteFiles); 			}  			List buildResources = getBuildResources(sourceDir); 			if (buildResources != null &amp;&amp; buildResources.size() != 0) { 				buildResourcesCount = buildResources.size(); 				buildResourcesBySourceDir.put(sourceDir, buildResources); 			} 		} else { 			logger.log(&quot;Error: Source directory does not exist: &quot; + sourceDir.getAbsolutePath(), Logger.SEVERITY_ERROR, new NullPointerException()); 			sourceDir = null; 		} 	}  	/** 	 * Returns the number of files preprocessed. 	 * 	 * @return		the number of files preprocessed 	 */ 	public int getBuildFileCount() { 		return buildFileCount; 	}  }</td>
    <td align="left">blob</td>
    <td align="left">'Blob', 'Long Method'</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">{',B,l,o,b,',&quot;,&quot;,&quot; &quot;,',L,o,n,g,&quot; &quot;,M,e,t,h,o,d,'}</td>
    <td align="left">{',B,o,b,',&quot;,&quot;,&quot; &quot;,',o,n,g,&quot; &quot;,M,t,h,o,d,'}</td>
    <td align="right">0</td>
    <td align="right">15283</td>
    <td align="left">https://github.com/eclipse/openj9/blob/4911084853eb75b20e037c434ad4521b7317ebfb/sourcetools/com.ibm.jpp.preprocessor/com/ibm/jpp/om/Builder.java/#L41-L806</td>
    <td align="right">1</td>
    <td align="right">2688</td>
    <td align="right">15283</td>
  </tr>
  <tr valign="top">
    <td align="right">2707</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DataSourceLoginService extends AbstractLoginService {     private static final Logger LOG = Log.getLogger(DataSourceLoginService.class);      private String _jndiName = &quot;javax.sql.DataSource/default&quot;;     private DataSource _datasource;     private Server _server;     private String _userTableName = &quot;users&quot;;     private String _userTableKey = &quot;id&quot;;     private String _userTableUserField = &quot;username&quot;;     private String _userTablePasswordField = &quot;pwd&quot;;     private String _roleTableName = &quot;roles&quot;;     private String _roleTableKey = &quot;id&quot;;     private String _roleTableRoleField = &quot;role&quot;;     private String _userRoleTableName = &quot;user_roles&quot;;     private String _userRoleTableUserKey = &quot;user_id&quot;;     private String _userRoleTableRoleKey = &quot;role_id&quot;;     private String _userSql;     private String _roleSql;     private boolean _createTables = false;               /**      * DBUser      */     public class DBUserPrincipal extends UserPrincipal     {         private int _key;                  public DBUserPrincipal(String name, Credential credential, int key)         {             super(name, credential);             _key = key;         }                  public int getKey ()         {             return _key;         }              }      /* ------------------------------------------------------------ */     public DataSourceLoginService()     {     }      /* ------------------------------------------------------------ */     public DataSourceLoginService(String name)     {         setName(name);     }      /* ------------------------------------------------------------ */     public DataSourceLoginService(String name, IdentityService identityService)     {         setName(name);         setIdentityService(identityService);     }      /* ------------------------------------------------------------ */     public void setJndiName (String jndi)     {         _jndiName = jndi;     }      /* ------------------------------------------------------------ */     public String getJndiName ()     {         return _jndiName;     }      /* ------------------------------------------------------------ */     public void setServer (Server server)     {         _server=server;     }      /* ------------------------------------------------------------ */     public Server getServer()     {         return _server;     }      /* ------------------------------------------------------------ */     public void setCreateTables(boolean createTables)     {         _createTables = createTables;     }      /* ------------------------------------------------------------ */     public boolean getCreateTables()     {         return _createTables;     }      /* ------------------------------------------------------------ */     public void setUserTableName (String name)     {         _userTableName=name;     }      /* ------------------------------------------------------------ */     public String getUserTableName()     {         return _userTableName;     }      /* ------------------------------------------------------------ */     public String getUserTableKey()     {         return _userTableKey;     }       /* ------------------------------------------------------------ */     public void setUserTableKey(String tableKey)     {         _userTableKey = tableKey;     }       /* ------------------------------------------------------------ */     public String getUserTableUserField()     {         return _userTableUserField;     }       /* ------------------------------------------------------------ */     public void setUserTableUserField(String tableUserField)     {         _userTableUserField = tableUserField;     }       /* ------------------------------------------------------------ */     public String getUserTablePasswordField()     {         return _userTablePasswordField;     }       /* ------------------------------------------------------------ */     public void setUserTablePasswordField(String tablePasswordField)     {         _userTablePasswordField = tablePasswordField;     }       /* ------------------------------------------------------------ */     public String getRoleTableName()     {         return _roleTableName;     }       /* ------------------------------------------------------------ */     public void setRoleTableName(String tableName)     {         _roleTableName = tableName;     }       /* ------------------------------------------------------------ */     public String getRoleTableKey()     {         return _roleTableKey;     }       /* ------------------------------------------------------------ */     public void setRoleTableKey(String tableKey)     {         _roleTableKey = tableKey;     }       /* ------------------------------------------------------------ */     public String getRoleTableRoleField()     {         return _roleTableRoleField;     }       /* ------------------------------------------------------------ */     public void setRoleTableRoleField(String tableRoleField)     {         _roleTableRoleField = tableRoleField;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableName()     {         return _userRoleTableName;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableName(String roleTableName)     {         _userRoleTableName = roleTableName;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableUserKey()     {         return _userRoleTableUserKey;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableUserKey(String roleTableUserKey)     {         _userRoleTableUserKey = roleTableUserKey;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableRoleKey()     {         return _userRoleTableRoleKey;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableRoleKey(String roleTableRoleKey)     {         _userRoleTableRoleKey = roleTableRoleKey;     }              /* ------------------------------------------------------------ */     @Override     public UserPrincipal loadUserInfo (String username)     {         try         {             try (Connection connection = getConnection();                     PreparedStatement statement1 = connection.prepareStatement(_userSql))             {                 statement1.setObject(1, username);                 try (ResultSet rs1 = statement1.executeQuery())                 {                     if (rs1.next())                     {                         int key = rs1.getInt(_userTableKey);                         String credentials = rs1.getString(_userTablePasswordField);                                                  return new DBUserPrincipal(username, Credential.getCredential(credentials), key);                     }                 }             }         }         catch (NamingException e)         {             LOG.warn(&quot;No datasource for &quot;+_jndiName, e);         }         catch (SQLException e)         {             LOG.warn(&quot;Problem loading user info for &quot;+username, e);         }         return null;     }               /* ------------------------------------------------------------ */     @Override     public String[] loadRoleInfo (UserPrincipal user)     {         DBUserPrincipal dbuser = (DBUserPrincipal)user;          try         {             try (Connection connection = getConnection();                     PreparedStatement statement2 = connection.prepareStatement(_roleSql))             {                  List roles = new ArrayList();                  statement2.setInt(1, dbuser.getKey());                 try (ResultSet rs2 = statement2.executeQuery())                 {                     while (rs2.next())                     {                         roles.add(rs2.getString(_roleTableRoleField));                     }                                          return roles.toArray(new String[roles.size()]);                 }             }         }         catch (NamingException e)         {             LOG.warn(&quot;No datasource for &quot;+_jndiName, e);         }         catch (SQLException e)         {             LOG.warn(&quot;Problem loading user info for &quot;+user.getName(), e);         }         return null;     }             /* ------------------------------------------------------------ */     /**      * Lookup the datasource for the jndiName and formulate the      * necessary sql query strings based on the configured table      * and column names.      *      * @throws NamingException if unable to init jndi      * @throws SQLException if unable to init database      */     public void initDb() throws NamingException, SQLException     {         if (_datasource != null)             return;          @SuppressWarnings(&quot;unused&quot;)         InitialContext ic = new InitialContext();         assert ic!=null;          // TODO Should we try webapp scope too?          // try finding the datasource in the Server scope         if (_server != null)         {             try             {                 _datasource = (DataSource)NamingEntryUtil.lookup(_server, _jndiName);             }             catch (NameNotFoundException e)             {                 //next try the jvm scope             }         }           //try finding the datasource in the jvm scope         if (_datasource==null)         {             _datasource = (DataSource)NamingEntryUtil.lookup(null, _jndiName);         }          // set up the select statements based on the table and column names configured         _userSql = &quot;select &quot; + _userTableKey + &quot;,&quot; + _userTablePasswordField                   + &quot; from &quot; + _userTableName                   + &quot; where &quot;+ _userTableUserField + &quot; = ?&quot;;          _roleSql = &quot;select r.&quot; + _roleTableRoleField                   + &quot; from &quot; + _roleTableName + &quot; r, &quot; + _userRoleTableName                   + &quot; u where u.&quot;+ _userRoleTableUserKey + &quot; = ?&quot;                   + &quot; and r.&quot; + _roleTableKey + &quot; = u.&quot; + _userRoleTableRoleKey;          prepareTables();     }      /* ------------------------------------------------------------ */     /**      * @throws NamingException      * @throws SQLException      */     private void prepareTables()     throws NamingException, SQLException     {         if (_createTables)         {             boolean autocommit = true;             Connection connection = getConnection();             try (Statement stmt = connection.createStatement())             {                 autocommit = connection.getAutoCommit();                 connection.setAutoCommit(false);                 DatabaseMetaData metaData = connection.getMetaData();                  //check if tables exist                 String tableName = (metaData.storesLowerCaseIdentifiers()? _userTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userTableName.toUpperCase(Locale.ENGLISH): _userTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //user table default                         /*                          * create table _userTableName (_userTableKey integer,                          * _userTableUserField varchar(100) not null unique,                          * _userTablePasswordField varchar(20) not null, primary key(_userTableKey));                          */                         stmt.executeUpdate(&quot;create table &quot;+_userTableName+ &quot;(&quot;+_userTableKey+&quot; integer,&quot;+                                 _userTableUserField+&quot; varchar(100) not null unique,&quot;+                                 _userTablePasswordField+&quot; varchar(20) not null, primary key(&quot;+_userTableKey+&quot;))&quot;);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_userTableName);                     }                 }                  tableName = (metaData.storesLowerCaseIdentifiers()? _roleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_roleTableName.toUpperCase(Locale.ENGLISH): _roleTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //role table default                         /*                          * create table _roleTableName (_roleTableKey integer,                          * _roleTableRoleField varchar(100) not null unique, primary key(_roleTableKey));                          */                         String str = &quot;create table &quot;+_roleTableName+&quot; (&quot;+_roleTableKey+&quot; integer, &quot;+                         _roleTableRoleField+&quot; varchar(100) not null unique, primary key(&quot;+_roleTableKey+&quot;))&quot;;                         stmt.executeUpdate(str);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_roleTableName);                     }                 }                  tableName = (metaData.storesLowerCaseIdentifiers()? _userRoleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userRoleTableName.toUpperCase(Locale.ENGLISH): _userRoleTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //user-role table                         /*                          * create table _userRoleTableName (_userRoleTableUserKey integer,                          * _userRoleTableRoleKey integer,                          * primary key (_userRoleTableUserKey, _userRoleTableRoleKey));                          *                          * create index idx_user_role on _userRoleTableName (_userRoleTableUserKey);                          */                         stmt.executeUpdate(&quot;create table &quot;+_userRoleTableName+&quot; (&quot;+_userRoleTableUserKey+&quot; integer, &quot;+                                 _userRoleTableRoleKey+&quot; integer, &quot;+                                 &quot;primary key (&quot;+_userRoleTableUserKey+&quot;, &quot;+_userRoleTableRoleKey+&quot;))&quot;);                         stmt.executeUpdate(&quot;create index indx_user_role on &quot;+_userRoleTableName+&quot;(&quot;+_userRoleTableUserKey+&quot;)&quot;);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_userRoleTableName +&quot; and index&quot;);                     }                 }                 connection.commit();             }             finally             {                 try                 {                     connection.setAutoCommit(autocommit);                 }                 catch (SQLException e)                 {                     if (LOG.isDebugEnabled()) LOG.debug(&quot;Prepare tables&quot;, e);                 }                 finally                 {                     try                     {                         connection.close();                     }                     catch (SQLException e)                     {                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Prepare tables&quot;, e);                     }                 }             }         }         else if (LOG.isDebugEnabled())         {             LOG.debug(&quot;createTables false&quot;);         }     }      /* ------------------------------------------------------------ */     /**      * @return      * @throws NamingException      * @throws SQLException      */     private Connection getConnection ()     throws NamingException, SQLException     {         initDb();         return _datasource.getConnection();     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15352</td>
    <td align="left">https://github.com/eclipse/jetty.project/blob/65528f76c5ef6ddca11385f9721c8f0bc5f2eed7/jetty-plus/src/main/java/org/eclipse/jetty/plus/security/DataSourceLoginService.java/#L52-L530</td>
    <td align="right">1</td>
    <td align="right">2707</td>
    <td align="right">15352</td>
  </tr>
  <tr valign="top">
    <td align="right">2900</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Blob&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
None</td>
    <td align="left">blob</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2146</td>
    <td align="left">https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/standalone-metastore/metastore-common/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/ThriftHiveMetastore.java/#L233896-L233981</td>
    <td align="right">1</td>
    <td align="right">2900</td>
    <td align="right">2146</td>
  </tr>
  <tr valign="top">
    <td align="right">3570</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement(name=&quot;mqtt&quot;) @XmlAccessorType(XmlAccessType.FIELD) public class MqttDTO extends ProtocolDTO {      @XmlAttribute(name=&quot;max_message_length&quot;)     public Integer max_message_length;      @XmlElementRef     public List protocol_filters = new ArrayList();      @XmlAttribute(name=&quot;queue_prefix&quot;)     public String queue_prefix;      @XmlAttribute(name=&quot;path_separator&quot;)     public String path_separator;      @XmlAttribute(name=&quot;any_child_wildcard&quot;)     public String any_child_wildcard;      @XmlAttribute(name=&quot;any_descendant_wildcard&quot;)     public String any_descendant_wildcard;      @XmlAttribute(name=&quot;regex_wildcard_start&quot;)     public String regex_wildcard_start;      @XmlAttribute(name=&quot;regex_wildcard_end&quot;)     public String regex_wildcard_end;      @XmlAttribute(name=&quot;part_pattern&quot;)     public String part_pattern;      @XmlAttribute(name=&quot;die_delay&quot;)     public Long die_delay;      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (o == null || getClass() != o.getClass()) return false;         if (!super.equals(o)) return false;          MqttDTO mqttDTO = (MqttDTO) o;          if (any_child_wildcard != null ? !any_child_wildcard.equals(mqttDTO.any_child_wildcard) : mqttDTO.any_child_wildcard != null)             return false;         if (any_descendant_wildcard != null ? !any_descendant_wildcard.equals(mqttDTO.any_descendant_wildcard) : mqttDTO.any_descendant_wildcard != null)             return false;         if (max_message_length != null ? !max_message_length.equals(mqttDTO.max_message_length) : mqttDTO.max_message_length != null)             return false;         if (path_separator != null ? !path_separator.equals(mqttDTO.path_separator) : mqttDTO.path_separator != null)             return false;         if (protocol_filters != null ? !protocol_filters.equals(mqttDTO.protocol_filters) : mqttDTO.protocol_filters != null)             return false;         if (queue_prefix != null ? !queue_prefix.equals(mqttDTO.queue_prefix) : mqttDTO.queue_prefix != null)             return false;         if (regex_wildcard_end != null ? !regex_wildcard_end.equals(mqttDTO.regex_wildcard_end) : mqttDTO.regex_wildcard_end != null)             return false;         if (regex_wildcard_start != null ? !regex_wildcard_start.equals(mqttDTO.regex_wildcard_start) : mqttDTO.regex_wildcard_start != null)             return false;         if (part_pattern != null ? !part_pattern.equals(mqttDTO.part_pattern) : mqttDTO.part_pattern != null)             return false;          return true;     }      @Override     public int hashCode() {         int result = super.hashCode();         result = 31 * result + (max_message_length != null ? max_message_length.hashCode() : 0);         result = 31 * result + (protocol_filters != null ? protocol_filters.hashCode() : 0);         result = 31 * result + (queue_prefix != null ? queue_prefix.hashCode() : 0);         result = 31 * result + (part_pattern != null ? part_pattern.hashCode() : 0);         result = 31 * result + (path_separator != null ? path_separator.hashCode() : 0);         result = 31 * result + (any_child_wildcard != null ? any_child_wildcard.hashCode() : 0);         result = 31 * result + (any_descendant_wildcard != null ? any_descendant_wildcard.hashCode() : 0);         result = 31 * result + (regex_wildcard_start != null ? regex_wildcard_start.hashCode() : 0);         result = 31 * result + (regex_wildcard_end != null ? regex_wildcard_end.hashCode() : 0);         return result;     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;data class</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7852</td>
    <td align="left">https://github.com/apache/activemq-apollo/blob/8e4b134b2a5d3576aa62cd8df9905a9fe2eba2d0/apollo-mqtt/src/main/java/org/apache/activemq/apollo/mqtt/dto/MqttDTO.java/#L31-L109</td>
    <td align="right">1</td>
    <td align="right">3570</td>
    <td align="right">7852</td>
  </tr>
  <tr valign="top">
    <td align="right">3996</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class JavadocFormatter {      private static final String CODE_RESET = &quot;\033[0m&quot;;     private static final String CODE_HIGHLIGHT = &quot;\033[1m&quot;;     private static final String CODE_UNDERLINE = &quot;\033[4m&quot;;      private final int lineLimit;     private final boolean escapeSequencesSupported;      /** Construct the formatter.      *      * @param lineLimit maximum line length      * @param escapeSequencesSupported whether escape sequences are supported      */     public JavadocFormatter(int lineLimit, boolean escapeSequencesSupported) {         this.lineLimit = lineLimit;         this.escapeSequencesSupported = escapeSequencesSupported;     }      private static final int MAX_LINE_LENGTH = 95;     private static final int SHORTEST_LINE = 30;     private static final int INDENT = 4;      /**Format javadoc to plain text.      *      * @param header element caption that should be used      * @param javadoc to format      * @return javadoc formatted to plain text      */     public String formatJavadoc(String header, String javadoc) {         try {             StringBuilder result = new StringBuilder();              result.append(escape(CODE_HIGHLIGHT)).append(header).append(escape(CODE_RESET)).append(&quot;\n&quot;);              if (javadoc == null) {                 return result.toString();             }              JavacTask task = (JavacTask) ToolProvider.getSystemJavaCompiler().getTask(null, null, null, null, null, null);             DocTrees trees = DocTrees.instance(task);             DocCommentTree docComment = trees.getDocCommentTree(new SimpleJavaFileObject(new URI(&quot;mem://doc.html&quot;), Kind.HTML) {                 @Override @DefinedBy(Api.COMPILER)                 public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {                     return &quot;&quot; + javadoc + &quot;&quot;;                 }             });              new FormatJavadocScanner(result, task).scan(docComment, null);              addNewLineIfNeeded(result);              return result.toString();         } catch (URISyntaxException ex) {             throw new InternalError(&quot;Unexpected exception&quot;, ex);         }     }      private class FormatJavadocScanner extends DocTreeScanner {         private final StringBuilder result;         private final JavacTask task;         private int reflownTo;         private int indent;         private int limit = Math.min(lineLimit, MAX_LINE_LENGTH);         private boolean pre;         private Map tableColumns;          public FormatJavadocScanner(StringBuilder result, JavacTask task) {             this.result = result;             this.task = task;         }          @Override @DefinedBy(Api.COMPILER_TREE)         public Object visitDocComment(DocCommentTree node, Object p) {             tableColumns = countTableColumns(node);             reflownTo = result.length();             scan(node.getFirstSentence(), p);             scan(node.getBody(), p);             reflow(result, reflownTo, indent, limit);             for (Sections current : docSections.keySet()) {                 boolean seenAny = false;                 for (DocTree t : node.getBlockTags()) {                     if (current.matches(t)) {                         if (!seenAny) {                             seenAny = true;                             if (result.charAt(result.length() - 1) != '\n')                                 result.append(&quot;\n&quot;);                             result.append(&quot;\n&quot;);                             result.append(escape(CODE_UNDERLINE))                                   .append(docSections.get(current))                                   .append(escape(CODE_RESET))                                   .append(&quot;\n&quot;);                         }                          scan(t, null);                     }                 }             }             return null;         }          @Override @DefinedBy(Api.COMPILER_TREE)         public Object visitText(TextTree node, Object p) {             String text = node.getBody();             if (!pre) {                 text = text.replaceAll(&quot;[ \t\r\n]+&quot;, &quot; &quot;).trim();                 if (text.isEmpty()) {                     text = &quot; &quot;;                 }             } else {                 text = text.replaceAll(&quot;\n&quot;, &quot;\n&quot; + indentString(indent));             }             result.append(text);             return null;         }          @Override @DefinedBy(Api.COMPILER_TREE)         public Object visitLink(LinkTree node, Object p) {             if (!node.getLabel().isEmpty()) {                 scan(node.getLabel(), p);             } else {                 result.append(node.getReference().getSignature());             }             return null;         }          @Override @DefinedBy(Api.COMPILER_TREE)         public Object visitParam(ParamTree node, Object p) {             return formatDef(node.getName().getName(), node.getDescription());         }          @Override @DefinedBy(Api.COMPILER_TREE)         public Object visitThrows(ThrowsTree node, Object p) {             return formatDef(node.getExceptionName().getSignature(), node.getDescription());         }          public Object formatDef(CharSequence name, List description) {             result.append(name);             result.append(&quot; - &quot;);             reflownTo = result.length();             indent = name.length() + 3;              if (limit - indent &lt; SHORTEST_LINE) {                 result.append(&quot;\n&quot;);                 result.append(indentString(INDENT));                 indent = INDENT;                 reflownTo += INDENT;             }             try {                 return scan(description, null);             } finally {                 reflow(result, reflownTo, indent, limit);                 result.append(&quot;\n&quot;);             }         }          @Override @DefinedBy(Api.COMPILER_TREE)         public Object visitLiteral(LiteralTree node, Object p) {             return scan(node.getBody(), p);         }          @Override @DefinedBy(Api.COMPILER_TREE)         public Object visitReturn(ReturnTree node, Object p) {             reflownTo = result.length();             try {                 return super.visitReturn(node, p);             } finally {                 reflow(result, reflownTo, 0, limit);             }         }          Stack listStack = new Stack&lt;&gt;();         Stack defStack = new Stack&lt;&gt;();         Stack tableStack = new Stack&lt;&gt;();         Stack&gt; cellsStack = new Stack&lt;&gt;();         Stack&gt; headerStack = new Stack&lt;&gt;();          @Override @DefinedBy(Api.COMPILER_TREE)         public Object visitStartElement(StartElementTree node, Object p) {             switch (getHtmlTag(node.getName())) {                 case P:                     if (lastNode!= null &amp;&amp; lastNode.getKind() == DocTree.Kind.START_ELEMENT &amp;&amp;                         HtmlTag.get(((StartElementTree) lastNode).getName()) == HtmlTag.LI) {                         //ignore                         break;                     }                     reflowTillNow();                     addNewLineIfNeeded(result);                     result.append(indentString(indent));                     reflownTo = result.length();                     break;                 case BLOCKQUOTE:                     reflowTillNow();                     indent += INDENT;                     break;                 case PRE:                     reflowTillNow();                     pre = true;                     break;                 case UL:                     reflowTillNow();                     listStack.push(-1);                     indent += INDENT;                     break;                 case OL:                     reflowTillNow();                     listStack.push(1);                     indent += INDENT;                     break;                 case DL:                     reflowTillNow();                     defStack.push(indent);                     break;                 case LI:                     reflowTillNow();                     if (!listStack.empty()) {                         addNewLineIfNeeded(result);                          int top = listStack.pop();                          if (top == (-1)) {                             result.append(indentString(indent - 2));                             result.append(&quot;* &quot;);                         } else {                             result.append(indentString(indent - 3));                             result.append(&quot;&quot; + top++ + &quot;. &quot;);                         }                          listStack.push(top);                          reflownTo = result.length();                     }                     break;                 case DT:                     reflowTillNow();                     if (!defStack.isEmpty()) {                         addNewLineIfNeeded(result);                         indent = defStack.peek();                         result.append(escape(CODE_HIGHLIGHT));                     }                     break;                 case DD:                     reflowTillNow();                     if (!defStack.isEmpty()) {                         if (indent == defStack.peek()) {                             result.append(escape(CODE_RESET));                         }                         addNewLineIfNeeded(result);                         indent = defStack.peek() + INDENT;                         result.append(indentString(indent));                     }                     break;                 case H1: case H2: case H3:                 case H4: case H5: case H6:                     reflowTillNow();                     addNewLineIfNeeded(result);                     result.append(&quot;\n&quot;)                           .append(escape(CODE_UNDERLINE));                     reflownTo = result.length();                     break;                 case TABLE:                     int columns = tableColumns.get(node);                      if (columns == 0) {                         break; //broken input                     }                      reflowTillNow();                     addNewLineIfNeeded(result);                     reflownTo = result.length();                      tableStack.push(limit);                      limit = (limit - 1) / columns - 3;                      for (int sep = 0; sep &lt; (limit + 3) * columns + 1; sep++) {                         result.append(&quot;-&quot;);                     }                      result.append(&quot;\n&quot;);                      break;                 case TR:                     if (cellsStack.size() &gt;= tableStack.size()) {                         //unclosed :                         handleEndElement(node.getName());                     }                     cellsStack.push(new ArrayList&lt;&gt;());                     headerStack.push(new ArrayList&lt;&gt;());                     break;                 case TH:                 case TD:                     if (cellsStack.isEmpty()) {                         //broken code                         break;                     }                     reflowTillNow();                     result.append(&quot;\n&quot;);                     reflownTo = result.length();                     cellsStack.peek().add(result.length());                     headerStack.peek().add(HtmlTag.get(node.getName()) == HtmlTag.TH);                     break;                 case IMG:                     for (DocTree attr : node.getAttributes()) {                         if (attr.getKind() != DocTree.Kind.ATTRIBUTE) {                             continue;                         }                         AttributeTree at = (AttributeTree) attr;                         if (&quot;alt&quot;.equals(StringUtils.toLowerCase(at.getName().toString()))) {                             addSpaceIfNeeded(result);                             scan(at.getValue(), null);                             addSpaceIfNeeded(result);                             break;                         }                     }                     break;                 default:                     addSpaceIfNeeded(result);                     break;             }             return null;         }          @Override @DefinedBy(Api.COMPILER_TREE)         public Object visitEndElement(EndElementTree node, Object p) {             handleEndElement(node.getName());             return super.visitEndElement(node, p);         }          private void handleEndElement(Name name) {             switch (getHtmlTag(name)) {                 case BLOCKQUOTE:                     indent -= INDENT;                     break;                 case PRE:                     pre = false;                     addNewLineIfNeeded(result);                     reflownTo = result.length();                     break;                 case UL: case OL:                     if (listStack.isEmpty()) { //ignore stray closing tag                         break;                     }                     reflowTillNow();                     listStack.pop();                     indent -= INDENT;                     addNewLineIfNeeded(result);                     break;                 case DL:                     if (defStack.isEmpty()) {//ignore stray closing tag                         break;                     }                     reflowTillNow();                     if (indent == defStack.peek()) {                         result.append(escape(CODE_RESET));                     }                     indent = defStack.pop();                     addNewLineIfNeeded(result);                     break;                 case H1: case H2: case H3:                 case H4: case H5: case H6:                     reflowTillNow();                     result.append(escape(CODE_RESET))                           .append(&quot;\n&quot;);                     reflownTo = result.length();                     break;                 case TABLE:                     if (cellsStack.size() &gt;= tableStack.size()) {                         //unclosed :                         handleEndElement(task.getElements().getName(&quot;tr&quot;));                     }                      if (tableStack.isEmpty()) {                         break;                     }                      limit = tableStack.pop();                     break;                 case TR:                     if (cellsStack.isEmpty()) {                         break;                     }                      reflowTillNow();                      List cells = cellsStack.pop();                     List headerFlags = headerStack.pop();                     List content = new ArrayList&lt;&gt;();                     int maxLines = 0;                      result.append(&quot;\n&quot;);                      while (!cells.isEmpty()) {                         int currentCell = cells.remove(cells.size() - 1);                         String[] lines = result.substring(currentCell, result.length()).split(&quot;\n&quot;);                          result.delete(currentCell - 1, result.length());                          content.add(lines);                         maxLines = Math.max(maxLines, lines.length);                     }                      Collections.reverse(content);                      for (int line = 0; line &lt; maxLines; line++) {                         for (int column = 0; column &lt; content.size(); column++) {                             String[] lines = content.get(column);                             String currentLine = line &lt; lines.length ? lines[line] : &quot;&quot;;                             result.append(&quot;| &quot;);                             boolean header = headerFlags.get(column);                             if (header) {                                 result.append(escape(CODE_HIGHLIGHT));                             }                             result.append(currentLine);                             if (header) {                                 result.append(escape(CODE_RESET));                             }                             int padding = limit - currentLine.length();                             if (padding &gt; 0)                                 result.append(indentString(padding));                             result.append(&quot; &quot;);                         }                         result.append(&quot;|\n&quot;);                     }                      for (int sep = 0; sep &lt; (limit + 3) * content.size() + 1; sep++) {                         result.append(&quot;-&quot;);                     }                      result.append(&quot;\n&quot;);                      reflownTo = result.length();                     break;                 case TD:                 case TH:                     break;                 default:                     addSpaceIfNeeded(result);                     break;             }         }          @Override @DefinedBy(Api.COMPILER_TREE)         public Object visitEntity(EntityTree node, Object p) {             String name = node.getName().toString();             int code = -1;             if (name.startsWith(&quot;#&quot;)) {                 try {                     int v = StringUtils.toLowerCase(name).startsWith(&quot;#x&quot;)                             ? Integer.parseInt(name.substring(2), 16)                             : Integer.parseInt(name.substring(1), 10);                     if (Entity.isValid(v)) {                         code = v;                     }                 } catch (NumberFormatException ex) {                     //ignore                 }             } else {                 Entity entity = Entity.get(name);                 if (entity != null) {                     code = entity.code;                 }             }             if (code != (-1)) {                 result.appendCodePoint(code);             } else {                 result.append(node.toString());             }             return super.visitEntity(node, p);         }          private DocTree lastNode;          @Override @DefinedBy(Api.COMPILER_TREE)         public Object scan(DocTree node, Object p) {             if (node instanceof InlineTagTree) {                 addSpaceIfNeeded(result);             }             try {                 return super.scan(node, p);             } finally {                 if (node instanceof InlineTagTree) {                     addSpaceIfNeeded(result);                 }                 lastNode = node;             }         }          private void reflowTillNow() {             while (result.length() &gt; 0 &amp;&amp; result.charAt(result.length() - 1) == ' ')                 result.delete(result.length() - 1, result.length());             reflow(result, reflownTo, indent, limit);             reflownTo = result.length();         }     };      private String escape(String sequence) {         return this.escapeSequencesSupported ? sequence : &quot;&quot;;     }      private static final Map docSections = new LinkedHashMap&lt;&gt;();      static {         ResourceBundle bundle =                 ResourceBundle.getBundle(&quot;jdk.internal.shellsupport.doc.resources.javadocformatter&quot;);         docSections.put(Sections.TYPE_PARAMS, bundle.getString(&quot;CAP_TypeParameters&quot;));         docSections.put(Sections.PARAMS, bundle.getString(&quot;CAP_Parameters&quot;));         docSections.put(Sections.RETURNS, bundle.getString(&quot;CAP_Returns&quot;));         docSections.put(Sections.THROWS, bundle.getString(&quot;CAP_Thrown_Exceptions&quot;));     }      private static String indentString(int indent) {         char[] content = new char[indent];         Arrays.fill(content, ' ');         return new String(content);     }      private static void reflow(StringBuilder text, int from, int indent, int limit) {         int lineStart = from;          while (lineStart &gt; 0 &amp;&amp; text.charAt(lineStart - 1) != '\n') {             lineStart--;         }          int lineChars = from - lineStart;         int pointer = from;         int lastSpace = -1;          while (pointer &lt; text.length()) {             if (text.charAt(pointer) == ' ')                 lastSpace = pointer;             if (lineChars &gt;= limit) {                 if (lastSpace != (-1)) {                     text.setCharAt(lastSpace, '\n');                     text.insert(lastSpace + 1, indentString(indent));                     lineChars = indent + pointer - lastSpace - 1;                     pointer += indent;                     lastSpace = -1;                 }             }             lineChars++;             pointer++;         }     }      private static void addNewLineIfNeeded(StringBuilder text) {         if (text.length() &gt; 0 &amp;&amp; text.charAt(text.length() - 1) != '\n') {             text.append(&quot;\n&quot;);         }     }      private static void addSpaceIfNeeded(StringBuilder text) {         if (text.length() == 0)             return ;          char last = text.charAt(text.length() - 1);          if (last != ' ' &amp;&amp; last != '\n') {             text.append(&quot; &quot;);         }     }      private static HtmlTag getHtmlTag(Name name) {         HtmlTag tag = HtmlTag.get(name);          return tag != null ? tag : HtmlTag.HTML; //using HtmlTag.HTML as default no-op value     }      private static Map countTableColumns(DocCommentTree dct) {         Map result = new IdentityHashMap&lt;&gt;();          new DocTreeScanner() {             private StartElementTree currentTable;             private int currentMaxColumns;             private int currentRowColumns;              @Override @DefinedBy(Api.COMPILER_TREE)             public Void visitStartElement(StartElementTree node, Void p) {                 switch (getHtmlTag(node.getName())) {                     case TABLE: currentTable = node; break;                     case TR:                         currentMaxColumns = Math.max(currentMaxColumns, currentRowColumns);                         currentRowColumns = 0;                         break;                     case TD:                     case TH: currentRowColumns++; break;                 }                 return super.visitStartElement(node, p);             }              @Override @DefinedBy(Api.COMPILER_TREE)             public Void visitEndElement(EndElementTree node, Void p) {                 if (HtmlTag.get(node.getName()) == HtmlTag.TABLE) {                     closeTable();                 }                 return super.visitEndElement(node, p);             }              @Override @DefinedBy(Api.COMPILER_TREE)             public Void visitDocComment(DocCommentTree node, Void p) {                 try {                     return super.visitDocComment(node, p);                 } finally {                     closeTable();                 }             }              private void closeTable() {                 if (currentTable != null) {                     result.put(currentTable, Math.max(currentMaxColumns, currentRowColumns));                     currentTable = null;                 }             }         }.scan(dct, null);          return result;     }      private enum Sections {         TYPE_PARAMS {             @Override public boolean matches(DocTree t) {                 return t.getKind() == DocTree.Kind.PARAM &amp;&amp; ((ParamTree) t).isTypeParameter();             }         },         PARAMS {             @Override public boolean matches(DocTree t) {                 return t.getKind() == DocTree.Kind.PARAM &amp;&amp; !((ParamTree) t).isTypeParameter();             }         },         RETURNS {             @Override public boolean matches(DocTree t) {                 return t.getKind() == DocTree.Kind.RETURN;             }         },         THROWS {             @Override public boolean matches(DocTree t) {                 return t.getKind() == DocTree.Kind.THROWS;             }         };          public abstract boolean matches(DocTree t);     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10563</td>
    <td align="left">https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/jdk.compiler/share/classes/jdk/internal/shellsupport/doc/JavadocFormatter.java/#L70-L712</td>
    <td align="right">1</td>
    <td align="right">3996</td>
    <td align="right">10563</td>
  </tr>
  <tr valign="top">
    <td align="right">4068</td>
    <td align="left">&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Blob&quot;,         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class TemplateConfiguration extends Configurable implements ParserConfiguration {      private boolean parentConfigurationSet;     private Integer tagSyntax;     private Integer interpolationSyntax;     private Integer namingConvention;     private Boolean whitespaceStripping;     private Boolean strictSyntaxMode;     private Integer autoEscapingPolicy;     private Boolean recognizeStandardFileExtensions;     private OutputFormat outputFormat;     private String encoding;     private Integer tabSize;      /**      * Creates a new instance. The parent will be {@link Configuration#getDefaultConfiguration()} initially, but it will      * be changed to the real parent {@link Configuration} when this object is added to the {@link Configuration}. (It's      * not allowed to add the same instance to multiple {@link Configuration}-s).      */     public TemplateConfiguration() {         super(Configuration.getDefaultConfiguration());     }      /**      * Same as {@link #setParentConfiguration(Configuration)}.      */     @Override     void setParent(Configurable cfg) {         NullArgumentException.check(&quot;cfg&quot;, cfg);         if (!(cfg instanceof Configuration)) {             throw new IllegalArgumentException(&quot;The parent of a TemplateConfiguration can only be a Configuration&quot;);         }                  if (parentConfigurationSet) {             if (getParent() != cfg) {                 throw new IllegalStateException(                         &quot;This TemplateConfiguration is already associated with a different Configuration instance.&quot;);             }             return;         }                  if (((Configuration) cfg).getIncompatibleImprovements().intValue() &lt; _TemplateAPI.VERSION_INT_2_3_22                 &amp;&amp; hasAnyConfigurableSet()) {             throw new IllegalStateException(                     &quot;This TemplateConfiguration can't be associated to a Configuration that has &quot;                     + &quot;incompatibleImprovements less than 2.3.22, because it changes non-parser settings.&quot;);         }                  super.setParent(cfg);         parentConfigurationSet = true;     }      /**      * Associates this instance with a {@link Configuration}; usually you don't call this, as it's called internally      * when this instance is added to a {@link Configuration}. This method can be called only once (except with the same      * {@link Configuration} parameter again, as that changes nothing anyway).      *       * @throws IllegalArgumentException      *             if the argument is {@code null} or not a {@link Configuration}      * @throws IllegalStateException      *             if this object is already associated to a different {@link Configuration} object,      *             or if the {@code Configuration} has {@code #getIncompatibleImprovements()} less than 2.3.22 and      *             this object tries to change any non-parser settings        */     public void setParentConfiguration(Configuration cfg) {         setParent(cfg);     }      /**      * Returns the parent {@link Configuration}, or {@code null} if none was associated yet.      */     public Configuration getParentConfiguration() {         return parentConfigurationSet ? (Configuration) getParent() : null;     }      private Configuration getNonNullParentConfiguration() {         checkParentConfigurationSet();         return (Configuration) getParent();     }          /**      * Set all settings in this {@link TemplateConfiguration} that were set in the parameter      * {@link TemplateConfiguration}, possibly overwriting the earlier value in this object. (A setting is said to be      * set in a {@link TemplateConfiguration} if it was explicitly set via a setter method, as opposed to be inherited.)      */     public void merge(TemplateConfiguration tc) {         if (tc.isAPIBuiltinEnabledSet()) {             setAPIBuiltinEnabled(tc.isAPIBuiltinEnabled());         }         if (tc.isArithmeticEngineSet()) {             setArithmeticEngine(tc.getArithmeticEngine());         }         if (tc.isAutoEscapingPolicySet()) {             setAutoEscapingPolicy(tc.getAutoEscapingPolicy());         }         if (tc.isAutoFlushSet()) {             setAutoFlush(tc.getAutoFlush());         }         if (tc.isBooleanFormatSet()) {             setBooleanFormat(tc.getBooleanFormat());         }         if (tc.isClassicCompatibleSet()) {             setClassicCompatibleAsInt(tc.getClassicCompatibleAsInt());         }         if (tc.isCustomDateFormatsSet()) {             setCustomDateFormats(mergeMaps(getCustomDateFormats(), tc.getCustomDateFormats(), false));         }         if (tc.isCustomNumberFormatsSet()) {             setCustomNumberFormats(mergeMaps(getCustomNumberFormats(), tc.getCustomNumberFormats(), false));         }         if (tc.isDateFormatSet()) {             setDateFormat(tc.getDateFormat());         }         if (tc.isDateTimeFormatSet()) {             setDateTimeFormat(tc.getDateTimeFormat());         }         if (tc.isEncodingSet()) {             setEncoding(tc.getEncoding());         }         if (tc.isLocaleSet()) {             setLocale(tc.getLocale());         }         if (tc.isLogTemplateExceptionsSet()) {             setLogTemplateExceptions(tc.getLogTemplateExceptions());         }         if (tc.isWrapUncheckedExceptionsSet()) {             setWrapUncheckedExceptions(tc.getWrapUncheckedExceptions());         }         if (tc.isNamingConventionSet()) {             setNamingConvention(tc.getNamingConvention());         }         if (tc.isNewBuiltinClassResolverSet()) {             setNewBuiltinClassResolver(tc.getNewBuiltinClassResolver());         }         if (tc.isTruncateBuiltinAlgorithmSet()) {             setTruncateBuiltinAlgorithm(tc.getTruncateBuiltinAlgorithm());         }         if (tc.isNumberFormatSet()) {             setNumberFormat(tc.getNumberFormat());         }         if (tc.isObjectWrapperSet()) {             setObjectWrapper(tc.getObjectWrapper());         }         if (tc.isOutputEncodingSet()) {             setOutputEncoding(tc.getOutputEncoding());         }         if (tc.isOutputFormatSet()) {             setOutputFormat(tc.getOutputFormat());         }         if (tc.isRecognizeStandardFileExtensionsSet()) {             setRecognizeStandardFileExtensions(tc.getRecognizeStandardFileExtensions());         }         if (tc.isShowErrorTipsSet()) {             setShowErrorTips(tc.getShowErrorTips());         }         if (tc.isSQLDateAndTimeTimeZoneSet()) {             setSQLDateAndTimeTimeZone(tc.getSQLDateAndTimeTimeZone());         }         if (tc.isStrictSyntaxModeSet()) {             setStrictSyntaxMode(tc.getStrictSyntaxMode());         }         if (tc.isTagSyntaxSet()) {             setTagSyntax(tc.getTagSyntax());         }         if (tc.isInterpolationSyntaxSet()) {             setInterpolationSyntax(tc.getInterpolationSyntax());         }         if (tc.isTemplateExceptionHandlerSet()) {             setTemplateExceptionHandler(tc.getTemplateExceptionHandler());         }         if (tc.isAttemptExceptionReporterSet()) {             setAttemptExceptionReporter(tc.getAttemptExceptionReporter());         }         if (tc.isTimeFormatSet()) {             setTimeFormat(tc.getTimeFormat());         }         if (tc.isTimeZoneSet()) {             setTimeZone(tc.getTimeZone());         }         if (tc.isURLEscapingCharsetSet()) {             setURLEscapingCharset(tc.getURLEscapingCharset());         }         if (tc.isWhitespaceStrippingSet()) {             setWhitespaceStripping(tc.getWhitespaceStripping());         }         if (tc.isTabSizeSet()) {             setTabSize(tc.getTabSize());         }         if (tc.isLazyImportsSet()) {             setLazyImports(tc.getLazyImports());         }         if (tc.isLazyAutoImportsSet()) {             setLazyAutoImports(tc.getLazyAutoImports());         }         if (tc.isAutoImportsSet()) {             setAutoImports(mergeMaps(getAutoImportsWithoutFallback(), tc.getAutoImportsWithoutFallback(), true));         }         if (tc.isAutoIncludesSet()) {             setAutoIncludes(mergeLists(getAutoIncludesWithoutFallback(), tc.getAutoIncludesWithoutFallback()));         }                  tc.copyDirectCustomAttributes(this, true);     }      /**      * Sets those settings of the {@link Template} which aren't yet set in the {@link Template} and are set in this      * {@link TemplateConfiguration}, leaves the other settings as is. A setting is said to be set in a      * {@link TemplateConfiguration} or {@link Template} if it was explicitly set via a setter method on that object, as      * opposed to be inherited from the {@link Configuration}.      *       *       * Note that this method doesn't deal with settings that influence the parser, as those are already baked in at this      * point via the {@link ParserConfiguration}.       *       *       * Note that the {@code encoding} setting of the {@link Template} counts as unset if it's {@code null},      * even if {@code null} was set via {@link Template#setEncoding(String)}.      *      * @throws IllegalStateException      *             If the parent configuration wasn't yet set.      */     public void apply(Template template) {         Configuration cfg = getNonNullParentConfiguration();         if (template.getConfiguration() != cfg) {             // This is actually not a problem right now, but for future BC we enforce this.             throw new IllegalArgumentException(                     &quot;The argument Template doesn't belong to the same Configuration as the TemplateConfiguration&quot;);         }          if (isAPIBuiltinEnabledSet() &amp;&amp; !template.isAPIBuiltinEnabledSet()) {             template.setAPIBuiltinEnabled(isAPIBuiltinEnabled());         }         if (isArithmeticEngineSet() &amp;&amp; !template.isArithmeticEngineSet()) {             template.setArithmeticEngine(getArithmeticEngine());         }         if (isAutoFlushSet() &amp;&amp; !template.isAutoFlushSet()) {             template.setAutoFlush(getAutoFlush());         }         if (isBooleanFormatSet() &amp;&amp; !template.isBooleanFormatSet()) {             template.setBooleanFormat(getBooleanFormat());         }         if (isClassicCompatibleSet() &amp;&amp; !template.isClassicCompatibleSet()) {             template.setClassicCompatibleAsInt(getClassicCompatibleAsInt());         }         if (isCustomDateFormatsSet()) {             template.setCustomDateFormats(                     mergeMaps(getCustomDateFormats(), template.getCustomDateFormatsWithoutFallback(), false));         }         if (isCustomNumberFormatsSet()) {             template.setCustomNumberFormats(                     mergeMaps(getCustomNumberFormats(), template.getCustomNumberFormatsWithoutFallback(), false));         }         if (isDateFormatSet() &amp;&amp; !template.isDateFormatSet()) {             template.setDateFormat(getDateFormat());         }         if (isDateTimeFormatSet() &amp;&amp; !template.isDateTimeFormatSet()) {             template.setDateTimeFormat(getDateTimeFormat());         }         if (isEncodingSet() &amp;&amp; template.getEncoding() == null) {             template.setEncoding(getEncoding());         }         if (isLocaleSet() &amp;&amp; !template.isLocaleSet()) {             template.setLocale(getLocale());         }         if (isLogTemplateExceptionsSet() &amp;&amp; !template.isLogTemplateExceptionsSet()) {             template.setLogTemplateExceptions(getLogTemplateExceptions());         }         if (isWrapUncheckedExceptionsSet() &amp;&amp; !template.isWrapUncheckedExceptionsSet()) {             template.setWrapUncheckedExceptions(getWrapUncheckedExceptions());         }         if (isNewBuiltinClassResolverSet() &amp;&amp; !template.isNewBuiltinClassResolverSet()) {             template.setNewBuiltinClassResolver(getNewBuiltinClassResolver());         }         if (isTruncateBuiltinAlgorithmSet() &amp;&amp; !template.isTruncateBuiltinAlgorithmSet()) {             template.setTruncateBuiltinAlgorithm(getTruncateBuiltinAlgorithm());         }         if (isNumberFormatSet() &amp;&amp; !template.isNumberFormatSet()) {             template.setNumberFormat(getNumberFormat());         }         if (isObjectWrapperSet() &amp;&amp; !template.isObjectWrapperSet()) {             template.setObjectWrapper(getObjectWrapper());         }         if (isOutputEncodingSet() &amp;&amp; !template.isOutputEncodingSet()) {             template.setOutputEncoding(getOutputEncoding());         }         if (isShowErrorTipsSet() &amp;&amp; !template.isShowErrorTipsSet()) {             template.setShowErrorTips(getShowErrorTips());         }         if (isSQLDateAndTimeTimeZoneSet() &amp;&amp; !template.isSQLDateAndTimeTimeZoneSet()) {             template.setSQLDateAndTimeTimeZone(getSQLDateAndTimeTimeZone());         }         if (isTemplateExceptionHandlerSet() &amp;&amp; !template.isTemplateExceptionHandlerSet()) {             template.setTemplateExceptionHandler(getTemplateExceptionHandler());         }         if (isAttemptExceptionReporterSet() &amp;&amp; !template.isAttemptExceptionReporterSet()) {             template.setAttemptExceptionReporter(getAttemptExceptionReporter());         }         if (isTimeFormatSet() &amp;&amp; !template.isTimeFormatSet()) {             template.setTimeFormat(getTimeFormat());         }         if (isTimeZoneSet() &amp;&amp; !template.isTimeZoneSet()) {             template.setTimeZone(getTimeZone());         }         if (isURLEscapingCharsetSet() &amp;&amp; !template.isURLEscapingCharsetSet()) {             template.setURLEscapingCharset(getURLEscapingCharset());         }         if (isLazyImportsSet() &amp;&amp; !template.isLazyImportsSet()) {             template.setLazyImports(getLazyImports());         }         if (isLazyAutoImportsSet() &amp;&amp; !template.isLazyAutoImportsSet()) {             template.setLazyAutoImports(getLazyAutoImports());         }         if (isAutoImportsSet()) {             // Regarding the order of the maps in the merge:             // - Existing template-level imports have precedence over those coming from the TC (just as with the others             //   apply()-ed settings), thus for clashing import prefixes they must win.             // - Template-level imports count as more specific, and so come after the more generic ones from TC.             template.setAutoImports(mergeMaps(getAutoImports(), template.getAutoImportsWithoutFallback(), true));         }         if (isAutoIncludesSet()) {             template.setAutoIncludes(mergeLists(getAutoIncludes(), template.getAutoIncludesWithoutFallback()));         }                  copyDirectCustomAttributes(template, false);     }      /**      * See {@link Configuration#setTagSyntax(int)}.      */     public void setTagSyntax(int tagSyntax) {         _TemplateAPI.valideTagSyntaxValue(tagSyntax);         this.tagSyntax = Integer.valueOf(tagSyntax);     }      /**      * The getter pair of {@link #setTagSyntax(int)}.      */     public int getTagSyntax() {         return tagSyntax != null ? tagSyntax.intValue() : getNonNullParentConfiguration().getTagSyntax();     }      /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isTagSyntaxSet() {         return tagSyntax != null;     }      /**      * See {@link Configuration#setInterpolationSyntax(int)}.      */     public void setInterpolationSyntax(int interpolationSyntax) {         _TemplateAPI.valideInterpolationSyntaxValue(interpolationSyntax);         this.interpolationSyntax = Integer.valueOf(interpolationSyntax);     }          /**      * The getter pair of {@link #setInterpolationSyntax(int)}.      */     public int getInterpolationSyntax() {         return interpolationSyntax != null ? interpolationSyntax.intValue()                 : getNonNullParentConfiguration().getInterpolationSyntax();     }      /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isInterpolationSyntaxSet() {         return interpolationSyntax != null;     }          /**      * See {@link Configuration#setNamingConvention(int)}.      */     public void setNamingConvention(int namingConvention) {         _TemplateAPI.validateNamingConventionValue(namingConvention);         this.namingConvention = Integer.valueOf(namingConvention);     }      /**      * The getter pair of {@link #setNamingConvention(int)}.      */     public int getNamingConvention() {         return namingConvention != null ? namingConvention.intValue()                 : getNonNullParentConfiguration().getNamingConvention();     }      /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isNamingConventionSet() {         return namingConvention != null;     }      /**      * See {@link Configuration#setWhitespaceStripping(boolean)}.      */     public void setWhitespaceStripping(boolean whitespaceStripping) {         this.whitespaceStripping = Boolean.valueOf(whitespaceStripping);     }      /**      * The getter pair of {@link #getWhitespaceStripping()}.      */     public boolean getWhitespaceStripping() {         return whitespaceStripping != null ? whitespaceStripping.booleanValue()                 : getNonNullParentConfiguration().getWhitespaceStripping();     }      /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isWhitespaceStrippingSet() {         return whitespaceStripping != null;     }      /**      * Sets the output format of the template; see {@link Configuration#setAutoEscapingPolicy(int)} for more.      */     public void setAutoEscapingPolicy(int autoEscapingPolicy) {         _TemplateAPI.validateAutoEscapingPolicyValue(autoEscapingPolicy);         this.autoEscapingPolicy = Integer.valueOf(autoEscapingPolicy);     }      /**      * The getter pair of {@link #setAutoEscapingPolicy(int)}.      */     public int getAutoEscapingPolicy() {         return autoEscapingPolicy != null ? autoEscapingPolicy.intValue()                 : getNonNullParentConfiguration().getAutoEscapingPolicy();     }      /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isAutoEscapingPolicySet() {         return autoEscapingPolicy != null;     }      /**      * Sets the output format of the template; see {@link Configuration#setOutputFormat(OutputFormat)} for more.      */     public void setOutputFormat(OutputFormat outputFormat) {         NullArgumentException.check(&quot;outputFormat&quot;, outputFormat);         this.outputFormat = outputFormat;     }      /**      * The getter pair of {@link #setOutputFormat(OutputFormat)}.      */     public OutputFormat getOutputFormat() {         return outputFormat != null ? outputFormat : getNonNullParentConfiguration().getOutputFormat();     }      /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isOutputFormatSet() {         return outputFormat != null;     }          /**      * See {@link Configuration#setRecognizeStandardFileExtensions(boolean)}.       */     public void setRecognizeStandardFileExtensions(boolean recognizeStandardFileExtensions) {         this.recognizeStandardFileExtensions = Boolean.valueOf(recognizeStandardFileExtensions);     }      /**      * Getter pair of {@link #setRecognizeStandardFileExtensions(boolean)}.      */     public boolean getRecognizeStandardFileExtensions() {         return recognizeStandardFileExtensions != null ? recognizeStandardFileExtensions.booleanValue()                 : getNonNullParentConfiguration().getRecognizeStandardFileExtensions();     }          /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isRecognizeStandardFileExtensionsSet() {         return recognizeStandardFileExtensions != null;     }          /**      * See {@link Configuration#setStrictSyntaxMode(boolean)}.      */     public void setStrictSyntaxMode(boolean strictSyntaxMode) {         this.strictSyntaxMode = Boolean.valueOf(strictSyntaxMode);     }      /**      * The getter pair of {@link #setStrictSyntaxMode(boolean)}.      */     public boolean getStrictSyntaxMode() {         return strictSyntaxMode != null ? strictSyntaxMode.booleanValue()                 : getNonNullParentConfiguration().getStrictSyntaxMode();     }          /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isStrictSyntaxModeSet() {         return strictSyntaxMode != null;     }      @Override     public void setStrictBeanModels(boolean strict) {         throw new UnsupportedOperationException(                 &quot;Setting strictBeanModels on &quot; + TemplateConfiguration.class.getSimpleName() + &quot; level isn't supported.&quot;);     }      public String getEncoding() {         return encoding != null ? encoding : getNonNullParentConfiguration().getDefaultEncoding();     }      /**      * When the standard template loading/caching mechanism is used, this forces the charset used for reading the      * template &quot;file&quot;, overriding everything but the encoding coming from the {@code #ftl} header. This setting      * overrides the locale-specific encodings set via {@link Configuration#setEncoding(java.util.Locale, String)}. It      * also overrides the {@code encoding} parameter of {@link Configuration#getTemplate(String, String)} (and of its      * overloads) and the {@code encoding} parameter of the {@code #include} directive. This works like that because      * specifying the encoding where you are requesting the template is error prone and deprecated.      *       *       * If you are developing your own template loading/caching mechanism instead of the standard one, note that the      * above behavior is not guaranteed by this class alone; you have to ensure it. Also, read the note on      * {@code encoding} in the documentation of {@link #apply(Template)}.      */     public void setEncoding(String encoding) {         NullArgumentException.check(&quot;encoding&quot;, encoding);         this.encoding = encoding;     }      public boolean isEncodingSet() {         return encoding != null;     }          /**      * See {@link Configuration#setTabSize(int)}.       *       * @since 2.3.25      */     public void setTabSize(int tabSize) {         this.tabSize = Integer.valueOf(tabSize);     }      /**      * Getter pair of {@link #setTabSize(int)}.      *       * @since 2.3.25      */     public int getTabSize() {         return tabSize != null ? tabSize.intValue()                 : getNonNullParentConfiguration().getTabSize();     }          /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      *       * @since 2.3.25      */     public boolean isTabSizeSet() {         return tabSize != null;     }          /**      * Returns {@link Configuration#getIncompatibleImprovements()} from the parent {@link Configuration}. This mostly      * just exist to satisfy the {@link ParserConfiguration} interface.      *       * @throws IllegalStateException      *             If the parent configuration wasn't yet set.      */     public Version getIncompatibleImprovements() {         return getNonNullParentConfiguration().getIncompatibleImprovements();     }      private void checkParentConfigurationSet() {         if (!parentConfigurationSet) {             throw new IllegalStateException(&quot;The TemplateConfiguration wasn't associated with a Configuration yet.&quot;);         }     }      private boolean hasAnyConfigurableSet() {         return                 isAPIBuiltinEnabledSet()                 || isArithmeticEngineSet()                 || isAutoFlushSet()                 || isAutoImportsSet()                 || isAutoIncludesSet()                 || isBooleanFormatSet()                 || isClassicCompatibleSet()                 || isCustomDateFormatsSet()                 || isCustomNumberFormatsSet()                 || isDateFormatSet()                 || isDateTimeFormatSet()                 || isLazyImportsSet()                 || isLazyAutoImportsSet()                 || isLocaleSet()                 || isLogTemplateExceptionsSet()                 || isWrapUncheckedExceptionsSet()                 || isNewBuiltinClassResolverSet()                 || isTruncateBuiltinAlgorithmSet()                 || isNumberFormatSet()                 || isObjectWrapperSet()                 || isOutputEncodingSet()                 || isShowErrorTipsSet()                 || isSQLDateAndTimeTimeZoneSet()                 || isTemplateExceptionHandlerSet()                 || isAttemptExceptionReporterSet()                 || isTimeFormatSet()                 || isTimeZoneSet()                 || isURLEscapingCharsetSet();     }          private Map mergeMaps(Map m1, Map m2, boolean overwriteUpdatesOrder) {         if (m1 == null) return m2;         if (m2 == null) return m1;         if (m1.isEmpty()) return m2;         if (m2.isEmpty()) return m1;                  LinkedHashMap mergedM = new LinkedHashMap((m1.size() + m2.size()) * 4 / 3 + 1, 0.75f);         mergedM.putAll(m1);         for (Object m2Key : m2.keySet()) {             mergedM.remove(m2Key); // So that duplicate keys are moved after m1 keys         }         mergedM.putAll(m2);         return mergedM;     }      private List mergeLists(List list1, List list2) {         if (list1 == null) return list2;         if (list2 == null) return list1;         if (list1.isEmpty()) return list2;         if (list2.isEmpty()) return list1;                  ArrayList mergedList = new ArrayList(list1.size() + list2.size());         mergedList.addAll(list1);         mergedList.addAll(list2);         return mergedList;     }      }</td>
    <td align="left">blob</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;data class,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10741</td>
    <td align="left">https://github.com/apache/freemarker/blob/02fa5edb3cde53f284551c09ecc13301b0e83d0b/src/main/java/freemarker/core/TemplateConfiguration.java/#L77-L718</td>
    <td align="right">1</td>
    <td align="right">4068</td>
    <td align="right">10741</td>
  </tr>
  <tr valign="top">
    <td align="right">4154</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Blob&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface IAopReferenceModel { 	 	void start();  	void shutdown();  	void removeProject(IJavaProject project);  	void addProject(IJavaProject project, IAopProject aopProject);  	void fireModelChanged();  	List getAdviceDefinition(IJavaElement je);  	List getAllReferences(); 	 	List getAllReferencesForResource(IResource resource);  	IAopProject getProject(IJavaProject project); 	 	Collection getProjects();  	boolean isAdvice(IJavaElement je);  	boolean isAdvised(IJavaElement je); 	 	boolean isAdvised(IBean bean);  	void registerAopModelChangedListener(IAopModelChangedListener listener);  	void unregisterAopModelChangedListener(IAopModelChangedListener listener); 	 	void clearProjects();  }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10943</td>
    <td align="left">https://github.com/spring-projects/spring-ide/blob/915fe9bffd50db45ee0b8fb993416e45dee68179/plugins/org.springframework.ide.eclipse.aop.core/src/org/springframework/ide/eclipse/aop/core/model/IAopReferenceModel.java/#L24-L58</td>
    <td align="right">1</td>
    <td align="right">4154</td>
    <td align="right">10943</td>
  </tr>
  <tr valign="top">
    <td align="right">4311</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells the bad smells are: 1. Blob&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;EObject&quot;, propOrder = { &quot;extensions&quot; }) public class EObject {  	@XmlElement(name = &quot;Extension&quot;, namespace = &quot;http://www.omg.org/XMI&quot;) 	protected List extensions; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	@XmlJavaTypeAdapter(CollapsedStringAdapter.class) 	@XmlID 	protected String id; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected QName type; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected String version; 	@XmlAttribute 	protected String href; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	@XmlIDREF 	protected Object idref; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected String label; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected String uuid;  	/** 	 * Gets the value of the extensions property. 	 *  	 *  	 * This accessor method returns a reference to the live list, not a 	 * snapshot. Therefore any modification you make to the returned list will 	 * be present inside the JAXB object. This is why there is not a 	 * set method for the extensions property. 	 *  	 *  	 * For example, to add a new item, do as follows: 	 *  	 *  	 * getExtensions().add(newItem); 	 *  	 *  	 *  	 *  	 * Objects of the following type(s) are allowed in the list 	 * {@link Extension } 	 *  	 *  	 */ 	public List getExtensions() { 		if (extensions == null) { 			extensions = new ArrayList(); 		} 		return this.extensions; 	}  	/** 	 * Gets the value of the id property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getId() { 		return id; 	}  	/** 	 * Sets the value of the id property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setId(String value) { 		this.id = value; 	}  	/** 	 * Gets the value of the type property. 	 *  	 * @return possible object is {@link QName } 	 *  	 */ 	public QName getType() { 		return type; 	}  	/** 	 * Sets the value of the type property. 	 *  	 * @param value 	 *            allowed object is {@link QName } 	 *  	 */ 	public void setType(QName value) { 		this.type = value; 	}  	/** 	 * Gets the value of the version property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getVersion() { 		if (version == null) { 			return &quot;2.0&quot;; 		} else { 			return version; 		} 	}  	/** 	 * Sets the value of the version property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setVersion(String value) { 		this.version = value; 	}  	/** 	 * Gets the value of the href property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getHref() { 		return href; 	}  	/** 	 * Sets the value of the href property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setHref(String value) { 		this.href = value; 	}  	/** 	 * Gets the value of the idref property. 	 *  	 * @return possible object is {@link Object } 	 *  	 */ 	public Object getIdref() { 		return idref; 	}  	/** 	 * Sets the value of the idref property. 	 *  	 * @param value 	 *            allowed object is {@link Object } 	 *  	 */ 	public void setIdref(Object value) { 		this.idref = value; 	}  	/** 	 * Gets the value of the label property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getLabel() { 		return label; 	}  	/** 	 * Sets the value of the label property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setLabel(String value) { 		this.label = value; 	}  	/** 	 * Gets the value of the uuid property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getUuid() { 		return uuid; 	}  	/** 	 * Sets the value of the uuid property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setUuid(String value) { 		this.uuid = value; 	}  }</td>
    <td align="left">blob</td>
    <td align="left">1. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11363</td>
    <td align="left">https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/container/openejb-jee/src/main/java/org/apache/openejb/jee/was/v6/ecore/EObject.java/#L57-L262</td>
    <td align="right">1</td>
    <td align="right">4311</td>
    <td align="right">11363</td>
  </tr>
  <tr valign="top">
    <td align="right">4484</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class HeaderParser {     private static final String DIRECTIVE_FILTER = &quot;filter&quot;; // NOI18N      private final String headerName;     private final Map parameters = new HashMap&lt;&gt;();     private final Map directives = new HashMap&lt;&gt;();     private final Map filterValue = new HashMap&lt;&gt;();     private final Feedback feedback;      private String header;     private int pos;     private String directiveOrParameterName;     private int contentStart;     private String versionFilter;      // static final ResourceBundle BUNDLE =     // ResourceBundle.getBundle(&quot;org.graalvm.component.installer.persist.Bundle&quot;);      public HeaderParser(String headerName, String header, Feedback feedback) {         this.headerName = headerName;         this.feedback = feedback;          if (header != null) {             // trim whitespaces;             this.header = header.trim();         } else {             this.header = &quot;&quot;;         }     }      private MetadataException metaEx(String key, Object... args) {         return new MetadataException(headerName, feedback.l10n(key, args));     }      public HeaderParser mustExist() throws MetadataException {         if (header == null || header.isEmpty()) {             throw metaEx(&quot;ERROR_HeaderMissing&quot;, headerName);         }         return this;     }      private static boolean isAlphaNum(char c) {         return (c &gt;= '0' &amp;&amp; c &lt;= '9') ||    // NOI18N                         (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') ||    // NOI18N                         (c &gt;= 'a' &amp;&amp; c &lt;= 'z');      // NOI18N     }      private static boolean isToken(char c) {         return isAlphaNum(c) || c == '_' || c == '-'; // NOI18N     }      private static boolean isExtended(char c) {         return isToken(c) || c == '.';     }      public boolean getBoolean(Boolean defValue) {         if (pos &gt;= header.length()) {             if (defValue == null) {                 throw metaEx(&quot;ERROR_HeaderMissing&quot;, headerName); // NOI18N             }             return defValue;         } else {             String s = header.substring(pos).trim().toLowerCase(Locale.ENGLISH);             switch (s) {                 case &quot;true&quot;: // NOI18N                     return true;                 case &quot;false&quot;: // NOI18N                     return false;             }             throw metaEx(&quot;ERROR_HeaderInvalid&quot;, headerName, s); // NOI18N         }     }      public String getContents(String defValue) {         if (pos &gt;= header.length()) {             return defValue;         } else {             return header.substring(pos).trim();         }     }      private void addFilterAttribute(String attrName, String value) {         if (filterValue.put(attrName, value) != null) {             throw metaErr(&quot;ERROR_DuplicateFilterAttribute&quot;);         }     }      private boolean isEmpty() {         return pos &gt;= header.length();     }      public String parseSymbolicName() throws MetadataException {         return parseNameOrNamespace(HeaderParser::isToken, &quot;ERROR_MissingSymbolicName&quot;, &quot;ERROR_InvalidSymbolicName&quot;, '.');     }      private char next() {         return pos &lt; header.length() ? header.charAt(pos++) : 0;     }      private void advance() {         pos++;     }      private char ch() {         return isEmpty() ? 0 : header.charAt(pos);     }      private String returnCut() {         String s = cut();         skipWhitespaces();         return s;     }      private void skipWhitespaces() {         while (!isEmpty()) {             if (!Character.isWhitespace(ch())) {                 contentStart = pos;                 return;             }             advance();         }         contentStart = -1;     }      private void skipWithSemicolon() {         skipWhitespaces();         if (ch() == ';') {             advance();         }         contentStart = -1;     }      private String cut() {         return cut(0);     }      private String cut(int delim) {         int e = pos - delim;         return contentStart == -1 || contentStart &gt;= e ? &quot;&quot; : header.substring(contentStart, e); // NOI18N     }      private void markContent() {         contentStart = pos;     }      private String readExtendedParameter() throws MetadataException {         skipWhitespaces();         while (!isEmpty()) {             char c = next();             if (Character.isWhitespace(c)) {                 break;             }             if (!isExtended(c)) {                 throw metaEx(&quot;ERROR_InvalidParameterSyntax&quot;, directiveOrParameterName);             }         }         String s = cut();         skipWithSemicolon();         return s;     }      private String readQuotedParameter() throws MetadataException {         markContent();         while (!isEmpty()) {             char c = next();             switch (c) {                 case '&quot;':                     return cut(1);                 case '\n':                 case '\r':                 case 0:                     throw metaEx(&quot;ERROR_InvalidQuotedString&quot;);                 case '\\':                     next();                     break;             }         }         throw metaEx(&quot;ERROR_InvalidQuotedString&quot;);     }      private String parseArgument() throws MetadataException {         skipWhitespaces();         char c = ch();         if (c == ';') {             throw metaEx(&quot;ERROR_MissingArgument&quot;, directiveOrParameterName);         }         if (c == '&quot;') { // NOI18N             advance();             return readQuotedParameter();         } else {             return readExtendedParameter();         }     }      private String parseNameOrNamespace(Predicate charAcceptor,                     String missingKeyName, String invalidKeyName, char compDelimiter) throws MetadataException {         if (header == null || isEmpty()) {             throw metaEx(missingKeyName);         }         skipWhitespaces();         boolean componentEmpty = true;         while (!isEmpty()) {             char c = ch();             if (c == ';') {                 String s = cut();                 return s;             }             advance();             if (c == compDelimiter) {                 if (componentEmpty) {                     throw metaEx(invalidKeyName);                 }                 componentEmpty = true;                 continue;             }             if (Character.isWhitespace(c)) {                 break;             }             if (!charAcceptor.test(c)) {                 throw metaEx(invalidKeyName);             }             componentEmpty = false;         }         return returnCut();     }      private String parseNamespace() throws MetadataException {         return parseNameOrNamespace(HeaderParser::isExtended, &quot;ERROR_MissingCapabilityName&quot;, &quot;ERROR_InvalidCapabilityName&quot;, (char) 0);     }      /**      * Parses version at the current position.      */     public String version() throws MetadataException {         int versionStart = -1;         int partCount = 0;         boolean partContents = false;         if (isEmpty()) {             throw metaErr(&quot;ERROR_InvalidVersion&quot;);         }         boolean dash = false;         while (!isEmpty()) {             char c = ch();              if (Character.isWhitespace(c)) {                 if (versionStart != -1) {                     break;                 }                 advance();                 continue;             }              if (c == ';') {                 break;             }             advance();             if (c == '.') {                 if (++partCount &gt; 3 || !partContents) {                     throw metaErr(&quot;ERROR_InvalidVersion&quot;);                 }                 partContents = false;                 dash = false;                 continue;             }             if (partCount &gt; 0 &amp;&amp; partContents &amp;&amp; c == '-') {                 dash = true;                 continue;             }             if (c &gt;= '0' &amp;&amp; c &lt;= '9') {                 if (versionStart == -1) {                     versionStart = pos - 1;                 }             } else {                 if (partCount &lt; 1) {                     throw metaErr(&quot;ERROR_InvalidVersion&quot;);                 }                 boolean err = false;                 if (partCount &gt;= 3 || dash) {                     err = !isToken(c);                 } else {                     err = true;                 }                 if (err) {                     throw metaErr(&quot;ERROR_InvalidVersion&quot;);                 }             }             partContents = true;         }         String v = cut();         skipWhitespaces();         if (!isEmpty() || !partContents) {             throw metaErr(&quot;ERROR_InvalidVersion&quot;);         }          return v;     }      private String readExtendedName() {         skipWhitespaces();         while (!isEmpty()) {             char c = ch();             if (isExtended(c)) {                 advance();             } else if (Character.isWhitespace(c) || c == ':' || c == '=') {                 break;             } else {                 throw metaEx(&quot;ERROR_InvalidParameterName&quot;);             }         }         return returnCut();     }      private void parseParameters() {         while (!isEmpty()) {             String paramOrDirectiveName = readExtendedName();             if (paramOrDirectiveName.isEmpty()) {                 throw metaEx(&quot;ERROR_InvalidParameterName&quot;);             }             directiveOrParameterName = paramOrDirectiveName;              char c = ch();             boolean dcolon = c == ':'; // NOI18N             if (dcolon) {                 advance();             }             c = next();             if (c != '=') { // NOI18N                 throw metaEx(&quot;ERROR_InvalidParameterSyntax&quot;, paramOrDirectiveName);             }             (dcolon ? directives : parameters).put(paramOrDirectiveName, parseArgument());         }     }      private void replaceInputText(String text) {         this.header = text;         this.pos = 0;     }      private MetadataException metaErr(String key, Object... args) throws MetadataException {         throw metaEx(key, args);     }      private MetadataException filterError() throws MetadataException {         throw metaErr(&quot;ERROR_InvalidFilterSpecification&quot;);     }      private void parseFilterConjunction() {         skipWhitespaces();         char c = next();         while (c == '(') {             parseFilterContent();             c = next();         }         if (c != ')') {             throw filterError();         }     }      private void parseFilterClause() {         skipWhitespaces();         int lastPos = -1;         W: while (!isEmpty()) {             char c = ch();             if (Character.isWhitespace(c)) {                 if (lastPos == -1) {                     lastPos = pos;                 }                 continue;             }             switch (c) {                 case '=':                 case '&lt;':                 case '&gt;':                 case '~':                 case '(':                 case ')':                     break W;             }             lastPos = -1;             advance();         }          String attributeName = returnCut();         char c = next();         if (c != '=') {             throw metaErr(&quot;ERROR_UnsupportedFilterOperation&quot;);         }         c = ch();         if (c == '*') {             throw metaErr(&quot;ERROR_UnsupportedFilterOperation&quot;);         }         markContent();         while (!isEmpty()) {             c = next();             if (c == ')') {                 addFilterAttribute(attributeName, cut(1));                 skipWhitespaces();                 return;             }              switch (c) {                 case '\\':                     c = next();                     if (c == 0) {                         throw filterError();                     }                     break;                 case '*':                     throw metaErr(&quot;ERROR_UnsupportedFilterOperation&quot;);                 case '(':                 case '&lt;':                 case '&gt;':                 case '~':                 case '=':                     throw filterError();             }         }         throw filterError();     }      private void parseFilterContent() {         skipWhitespaces();         char o = ch();         if (o == '&amp;') {             advance();             parseFilterConjunction();         } else if (isExtended(o)) {             parseFilterClause();         } else {             throw metaErr(&quot;ERROR_InvalidFilterSpecification&quot;);         }     }      private void parseFilterSpecification() {         skipWhitespaces();         if (isEmpty()) {             throw filterError();         }         char c = next();         if (c == '(') {             parseFilterContent();             skipWhitespaces();             if (!isEmpty()) {                 throw metaErr(&quot;ERROR_InvalidFilterSpecification&quot;);             }         } else {             throw filterError();         }     }      /**      * Parses required capabilities string.      *      * org.graalvm; filter:=&quot;(&amp;(graalvm_version=0.32)(os_name=linux)(os_arch=amd64))&quot;      *       * @return graal capabilities      * @throws MetadataException      */     public Map parseRequiredCapabilities() {         String namespace = parseNamespace();          char c = next();         if (c != ';' &amp;&amp; c != 0) {             throw metaErr(&quot;ERROR_InvalidFilterSpecification&quot;);         }          if (!BundleConstants.GRAALVM_CAPABILITY.equals(namespace)) {             // unsupported capability             throw new DependencyException(namespace, null, null, feedback.l10n(&quot;ERROR_UnknownCapability&quot;));         }         parseParameters();          if (!parameters.isEmpty()) {             throw metaErr(&quot;ERROR_UnsupportedParameters&quot;);         }         versionFilter = directives.remove(DIRECTIVE_FILTER);         if (!directives.isEmpty()) {             throw metaErr(&quot;ERROR_UnsupportedDirectives&quot;);         }         if (versionFilter == null) {             throw metaErr(&quot;ERROR_MissingVersionFilter&quot;);         }          // replace the input text, the rest of header will be ignored         replaceInputText(versionFilter);         parseFilterSpecification();          return filterValue;     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;data class,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11873</td>
    <td align="left">https://github.com/oracle/graal/blob/4deb681aaaa79c248115037fc8e399c9876619fd/vm/src/org.graalvm.component.installer/src/org/graalvm/component/installer/persist/HeaderParser.java/#L39-L528</td>
    <td align="right">1</td>
    <td align="right">4484</td>
    <td align="right">11873</td>
  </tr>
  <tr valign="top">
    <td align="right">4521</td>
    <td align="left">{   &quot;result&quot;: &quot;YES I found bad smells&quot;,   &quot;the bad smells are&quot;: [     &quot;Long Method&quot;,     &quot;Blob&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TopicSubscription extends AbstractSubscription {      private static final Logger LOG = LoggerFactory.getLogger(TopicSubscription.class);     private static final AtomicLong CURSOR_NAME_COUNTER = new AtomicLong(0);      protected PendingMessageCursor matched;     protected final SystemUsage usageManager;     boolean singleDestination = true;     Destination destination;     private final Scheduler scheduler;      private int maximumPendingMessages = -1;     private MessageEvictionStrategy messageEvictionStrategy = new OldestMessageEvictionStrategy();     private int discarded;     private final Object matchedListMutex = new Object();     private int memoryUsageHighWaterMark = 95;     // allow duplicate suppression in a ring network of brokers     protected int maxProducersToAudit = 1024;     protected int maxAuditDepth = 1000;     protected boolean enableAudit = false;     protected ActiveMQMessageAudit audit;     protected boolean active = false;     protected boolean discarding = false;     private boolean useTopicSubscriptionInflightStats = true;      //Used for inflight message size calculations     protected final Object dispatchLock = new Object();     protected final List dispatched = new ArrayList&lt;&gt;();      public TopicSubscription(Broker broker,ConnectionContext context, ConsumerInfo info, SystemUsage usageManager) throws Exception {         super(broker, context, info);         this.usageManager = usageManager;         String matchedName = &quot;TopicSubscription:&quot; + CURSOR_NAME_COUNTER.getAndIncrement() + &quot;[&quot; + info.getConsumerId().toString() + &quot;]&quot;;         if (info.getDestination().isTemporary() || broker.getTempDataStore()==null ) {             this.matched = new VMPendingMessageCursor(false);         } else {             this.matched = new FilePendingMessageCursor(broker,matchedName,false);         }          this.scheduler = broker.getScheduler();     }      public void init() throws Exception {         this.matched.setSystemUsage(usageManager);         this.matched.setMemoryUsageHighWaterMark(getCursorMemoryHighWaterMark());         this.matched.start();         if (enableAudit) {             audit= new ActiveMQMessageAudit(maxAuditDepth, maxProducersToAudit);         }         this.active=true;     }      @Override     public void add(MessageReference node) throws Exception {         if (isDuplicate(node)) {             return;         }         // Lets use an indirect reference so that we can associate a unique         // locator /w the message.         node = new IndirectMessageReference(node.getMessage());         getSubscriptionStatistics().getEnqueues().increment();         synchronized (matchedListMutex) {             // if this subscriber is already discarding a message, we don't want to add             // any more messages to it as those messages can only be advisories generated in the process,             // which can trigger the recursive call loop             if (discarding) return;              if (!isFull() &amp;&amp; matched.isEmpty()) {                 // if maximumPendingMessages is set we will only discard messages which                 // have not been dispatched (i.e. we allow the prefetch buffer to be filled)                 dispatch(node);                 setSlowConsumer(false);             } else {                 if (info.getPrefetchSize() &gt; 1 &amp;&amp; matched.size() &gt; info.getPrefetchSize()) {                     // Slow consumers should log and set their state as such.                     if (!isSlowConsumer()) {                         LOG.warn(&quot;{}: has twice its prefetch limit pending, without an ack; it appears to be slow&quot;, toString());                         setSlowConsumer(true);                         for (Destination dest: destinations) {                             dest.slowConsumer(getContext(), this);                         }                     }                 }                 if (maximumPendingMessages != 0) {                     boolean warnedAboutWait = false;                     while (active) {                         while (matched.isFull()) {                             if (getContext().getStopping().get()) {                                 LOG.warn(&quot;{}: stopped waiting for space in pendingMessage cursor for: {}&quot;, toString(), node.getMessageId());                                 getSubscriptionStatistics().getEnqueues().decrement();                                 return;                             }                             if (!warnedAboutWait) {                                 LOG.info(&quot;{}: Pending message cursor [{}] is full, temp usag ({}%) or memory usage ({}%) limit reached, blocking message add() pending the release of resources.&quot;,                                         new Object[]{                                                 toString(),                                                 matched,                                                 matched.getSystemUsage().getTempUsage().getPercentUsage(),                                                 matched.getSystemUsage().getMemoryUsage().getPercentUsage()                                         });                                 warnedAboutWait = true;                             }                             matchedListMutex.wait(20);                         }                         // Temporary storage could be full - so just try to add the message                         // see https://issues.apache.org/activemq/browse/AMQ-2475                         if (matched.tryAddMessageLast(node, 10)) {                             break;                         }                     }                     if (maximumPendingMessages &gt; 0) {                         // calculate the high water mark from which point we                         // will eagerly evict expired messages                         int max = messageEvictionStrategy.getEvictExpiredMessagesHighWatermark();                         if (maximumPendingMessages &gt; 0 &amp;&amp; maximumPendingMessages &lt; max) {                             max = maximumPendingMessages;                         }                         if (!matched.isEmpty() &amp;&amp; matched.size() &gt; max) {                             removeExpiredMessages();                         }                         // lets discard old messages as we are a slow consumer                         while (!matched.isEmpty() &amp;&amp; matched.size() &gt; maximumPendingMessages) {                             int pageInSize = matched.size() - maximumPendingMessages;                             // only page in a 1000 at a time - else we could blow the memory                             pageInSize = Math.max(1000, pageInSize);                             LinkedList list = null;                             MessageReference[] oldMessages=null;                             synchronized(matched){                                 list = matched.pageInList(pageInSize);                                 oldMessages = messageEvictionStrategy.evictMessages(list);                                 for (MessageReference ref : list) {                                     ref.decrementReferenceCount();                                 }                             }                             int messagesToEvict = 0;                             if (oldMessages != null){                                 messagesToEvict = oldMessages.length;                                 for (int i = 0; i &lt; messagesToEvict; i++) {                                     MessageReference oldMessage = oldMessages[i];                                     discard(oldMessage);                                 }                             }                             // lets avoid an infinite loop if we are given a bad eviction strategy                             // for a bad strategy lets just not evict                             if (messagesToEvict == 0) {                                 LOG.warn(&quot;No messages to evict returned for {} from eviction strategy: {} out of {} candidates&quot;, new Object[]{                                         destination, messageEvictionStrategy, list.size()                                 });                                 break;                             }                         }                     }                     dispatchMatched();                 }             }         }     }      private boolean isDuplicate(MessageReference node) {         boolean duplicate = false;         if (enableAudit &amp;&amp; audit != null) {             duplicate = audit.isDuplicate(node);             if (LOG.isDebugEnabled()) {                 if (duplicate) {                     LOG.debug(&quot;{}, ignoring duplicate add: {}&quot;, this, node.getMessageId());                 }             }         }         return duplicate;     }      /**      * Discard any expired messages from the matched list. Called from a      * synchronized block.      *      * @throws IOException      */     protected void removeExpiredMessages() throws IOException {         try {             matched.reset();             while (matched.hasNext()) {                 MessageReference node = matched.next();                 node.decrementReferenceCount();                 if (node.isExpired()) {                     matched.remove();                     node.decrementReferenceCount();                     if (broker.isExpired(node)) {                         ((Destination) node.getRegionDestination()).getDestinationStatistics().getExpired().increment();                         broker.messageExpired(getContext(), node, this);                     }                     break;                 }             }         } finally {             matched.release();         }     }      @Override     public void processMessageDispatchNotification(MessageDispatchNotification mdn) {         synchronized (matchedListMutex) {             try {                 matched.reset();                 while (matched.hasNext()) {                     MessageReference node = matched.next();                     node.decrementReferenceCount();                     if (node.getMessageId().equals(mdn.getMessageId())) {                         synchronized(dispatchLock) {                             matched.remove();                             getSubscriptionStatistics().getDispatched().increment();                             if (isUseTopicSubscriptionInflightStats()) {                                 dispatched.add(new DispatchedNode(node));                                 getSubscriptionStatistics().getInflightMessageSize().addSize(node.getSize());                             }                             node.decrementReferenceCount();                         }                         break;                     }                 }             } finally {                 matched.release();             }         }     }      @Override     public synchronized void acknowledge(final ConnectionContext context, final MessageAck ack) throws Exception {         super.acknowledge(context, ack);          if (ack.isStandardAck()) {             updateStatsOnAck(context, ack);         } else if (ack.isPoisonAck()) {             if (ack.isInTransaction()) {                 throw new JMSException(&quot;Poison ack cannot be transacted: &quot; + ack);             }             updateStatsOnAck(context, ack);             contractPrefetchExtension(ack.getMessageCount());         } else if (ack.isIndividualAck()) {             updateStatsOnAck(context, ack);             if (ack.isInTransaction()) {                 expandPrefetchExtension(1);             }         } else if (ack.isExpiredAck()) {             updateStatsOnAck(ack);             contractPrefetchExtension(ack.getMessageCount());         } else if (ack.isDeliveredAck()) {             // Message was delivered but not acknowledged: update pre-fetch counters.            expandPrefetchExtension(ack.getMessageCount());         } else if (ack.isRedeliveredAck()) {             // No processing for redelivered needed             return;         } else {             throw new JMSException(&quot;Invalid acknowledgment: &quot; + ack);         }          dispatchMatched();     }      private void updateStatsOnAck(final ConnectionContext context, final MessageAck ack) {         if (context.isInTransaction()) {             context.getTransaction().addSynchronization(new Synchronization() {                  @Override                 public void afterRollback() {                     contractPrefetchExtension(ack.getMessageCount());                 }                  @Override                 public void afterCommit() throws Exception {                     contractPrefetchExtension(ack.getMessageCount());                     updateStatsOnAck(ack);                     dispatchMatched();                 }             });         } else {             updateStatsOnAck(ack);         }     }      @Override     public Response pullMessage(ConnectionContext context, final MessagePull pull) throws Exception {          // The slave should not deliver pull messages.         if (getPrefetchSize() == 0) {              final long currentDispatchedCount = getSubscriptionStatistics().getDispatched().getCount();             prefetchExtension.set(pull.getQuantity());             dispatchMatched();              // If there was nothing dispatched.. we may need to setup a timeout.             if (currentDispatchedCount == getSubscriptionStatistics().getDispatched().getCount() || pull.isAlwaysSignalDone()) {                  // immediate timeout used by receiveNoWait()                 if (pull.getTimeout() == -1) {                     // Send a NULL message to signal nothing pending.                     dispatch(null);                     prefetchExtension.set(0);                 }                  if (pull.getTimeout() &gt; 0) {                     scheduler.executeAfterDelay(new Runnable() {                          @Override                         public void run() {                             pullTimeout(currentDispatchedCount, pull.isAlwaysSignalDone());                         }                     }, pull.getTimeout());                 }             }         }         return null;     }      /**      * Occurs when a pull times out. If nothing has been dispatched since the      * timeout was setup, then send the NULL message.      */     private final void pullTimeout(long currentDispatchedCount, boolean alwaysSendDone) {         synchronized (matchedListMutex) {             if (currentDispatchedCount == getSubscriptionStatistics().getDispatched().getCount() || alwaysSendDone) {                 try {                     dispatch(null);                 } catch (Exception e) {                     context.getConnection().serviceException(e);                 } finally {                     prefetchExtension.set(0);                 }             }         }     }      /**      * Update the statistics on message ack.      * @param ack      */     private void updateStatsOnAck(final MessageAck ack) {         //Allow disabling inflight stats to save memory usage         if (isUseTopicSubscriptionInflightStats()) {             synchronized(dispatchLock) {                 boolean inAckRange = false;                 List removeList = new ArrayList&lt;&gt;();                 for (final DispatchedNode node : dispatched) {                     MessageId messageId = node.getMessageId();                     if (ack.getFirstMessageId() == null                             || ack.getFirstMessageId().equals(messageId)) {                         inAckRange = true;                     }                     if (inAckRange) {                         removeList.add(node);                         if (ack.getLastMessageId().equals(messageId)) {                             break;                         }                     }                 }                  for (final DispatchedNode node : removeList) {                     dispatched.remove(node);                     getSubscriptionStatistics().getInflightMessageSize().addSize(-node.getSize());                      final Destination destination = node.getDestination();                     incrementStatsOnAck(destination, ack, 1);                     if (!ack.isInTransaction()) {                         contractPrefetchExtension(1);                     }                 }             }         } else {             if (singleDestination &amp;&amp; destination != null) {                 incrementStatsOnAck(destination, ack, ack.getMessageCount());             }             if (!ack.isInTransaction()) {                 contractPrefetchExtension(ack.getMessageCount());             }         }     }      private void incrementStatsOnAck(final Destination destination, final MessageAck ack, final int count) {         getSubscriptionStatistics().getDequeues().add(count);         destination.getDestinationStatistics().getDequeues().add(count);         destination.getDestinationStatistics().getInflight().subtract(count);         if (info.isNetworkSubscription()) {             destination.getDestinationStatistics().getForwards().add(count);         }         if (ack.isExpiredAck()) {             destination.getDestinationStatistics().getExpired().add(count);         }     }      @Override     public int countBeforeFull() {         return getPrefetchSize() == 0 ? prefetchExtension.get() : info.getPrefetchSize() + prefetchExtension.get() - getDispatchedQueueSize();     }      @Override     public int getPendingQueueSize() {         return matched();     }      @Override     public long getPendingMessageSize() {         synchronized (matchedListMutex) {             return matched.messageSize();         }     }      @Override     public int getDispatchedQueueSize() {         return (int)(getSubscriptionStatistics().getDispatched().getCount() -                      getSubscriptionStatistics().getDequeues().getCount());     }      public int getMaximumPendingMessages() {         return maximumPendingMessages;     }      @Override     public long getDispatchedCounter() {         return getSubscriptionStatistics().getDispatched().getCount();     }      @Override     public long getEnqueueCounter() {         return getSubscriptionStatistics().getEnqueues().getCount();     }      @Override     public long getDequeueCounter() {         return getSubscriptionStatistics().getDequeues().getCount();     }      /**      * @return the number of messages discarded due to being a slow consumer      */     public int discarded() {         synchronized (matchedListMutex) {             return discarded;         }     }      /**      * @return the number of matched messages (messages targeted for the      *         subscription but not yet able to be dispatched due to the      *         prefetch buffer being full).      */     public int matched() {         synchronized (matchedListMutex) {             return matched.size();         }     }      /**      * Sets the maximum number of pending messages that can be matched against      * this consumer before old messages are discarded.      */     public void setMaximumPendingMessages(int maximumPendingMessages) {         this.maximumPendingMessages = maximumPendingMessages;     }      public MessageEvictionStrategy getMessageEvictionStrategy() {         return messageEvictionStrategy;     }      /**      * Sets the eviction strategy used to decide which message to evict when the      * slow consumer needs to discard messages      */     public void setMessageEvictionStrategy(MessageEvictionStrategy messageEvictionStrategy) {         this.messageEvictionStrategy = messageEvictionStrategy;     }      public int getMaxProducersToAudit() {         return maxProducersToAudit;     }      public synchronized void setMaxProducersToAudit(int maxProducersToAudit) {         this.maxProducersToAudit = maxProducersToAudit;         if (audit != null) {             audit.setMaximumNumberOfProducersToTrack(maxProducersToAudit);         }     }      public int getMaxAuditDepth() {         return maxAuditDepth;     }      public synchronized void setMaxAuditDepth(int maxAuditDepth) {         this.maxAuditDepth = maxAuditDepth;         if (audit != null) {             audit.setAuditDepth(maxAuditDepth);         }     }      public boolean isEnableAudit() {         return enableAudit;     }      public synchronized void setEnableAudit(boolean enableAudit) {         this.enableAudit = enableAudit;         if (enableAudit &amp;&amp; audit == null) {             audit = new ActiveMQMessageAudit(maxAuditDepth,maxProducersToAudit);         }     }      // Implementation methods     // -------------------------------------------------------------------------     @Override     public boolean isFull() {         return getPrefetchSize() == 0 ? prefetchExtension.get() == 0 : getDispatchedQueueSize() - prefetchExtension.get() &gt;= info.getPrefetchSize();     }      @Override     public int getInFlightSize() {         return getDispatchedQueueSize();     }      /**      * @return true when 60% or more room is left for dispatching messages      */     @Override     public boolean isLowWaterMark() {         return (getDispatchedQueueSize() - prefetchExtension.get()) &lt;= (info.getPrefetchSize() * .4);     }      /**      * @return true when 10% or less room is left for dispatching messages      */     @Override     public boolean isHighWaterMark() {         return (getDispatchedQueueSize() - prefetchExtension.get()) &gt;= (info.getPrefetchSize() * .9);     }      /**      * @param memoryUsageHighWaterMark the memoryUsageHighWaterMark to set      */     public void setMemoryUsageHighWaterMark(int memoryUsageHighWaterMark) {         this.memoryUsageHighWaterMark = memoryUsageHighWaterMark;     }      /**      * @return the memoryUsageHighWaterMark      */     public int getMemoryUsageHighWaterMark() {         return this.memoryUsageHighWaterMark;     }      /**      * @return the usageManager      */     public SystemUsage getUsageManager() {         return this.usageManager;     }      /**      * @return the matched      */     public PendingMessageCursor getMatched() {         return this.matched;     }      /**      * @param matched the matched to set      */     public void setMatched(PendingMessageCursor matched) {         this.matched = matched;     }      /**      * inform the MessageConsumer on the client to change it's prefetch      *      * @param newPrefetch      */     @Override     public void updateConsumerPrefetch(int newPrefetch) {         if (context != null &amp;&amp; context.getConnection() != null &amp;&amp; context.getConnection().isManageable()) {             ConsumerControl cc = new ConsumerControl();             cc.setConsumerId(info.getConsumerId());             cc.setPrefetch(newPrefetch);             context.getConnection().dispatchAsync(cc);         }     }      private void dispatchMatched() throws IOException {         synchronized (matchedListMutex) {             if (!matched.isEmpty() &amp;&amp; !isFull()) {                 try {                     matched.reset();                      while (matched.hasNext() &amp;&amp; !isFull()) {                         MessageReference message = matched.next();                         message.decrementReferenceCount();                         matched.remove();                         // Message may have been sitting in the matched list a while                         // waiting for the consumer to ak the message.                         if (message.isExpired()) {                             discard(message);                             continue; // just drop it.                         }                         dispatch(message);                     }                 } finally {                     matched.release();                 }             }         }     }      private void dispatch(final MessageReference node) throws IOException {         Message message = node != null ? node.getMessage() : null;         if (node != null) {             node.incrementReferenceCount();         }         // Make sure we can dispatch a message.         MessageDispatch md = new MessageDispatch();         md.setMessage(message);         md.setConsumerId(info.getConsumerId());         if (node != null) {             md.setDestination(((Destination)node.getRegionDestination()).getActiveMQDestination());             synchronized(dispatchLock) {                 getSubscriptionStatistics().getDispatched().increment();                 if (isUseTopicSubscriptionInflightStats()) {                     dispatched.add(new DispatchedNode(node));                     getSubscriptionStatistics().getInflightMessageSize().addSize(node.getSize());                 }             }              // Keep track if this subscription is receiving messages from a single destination.             if (singleDestination) {                 if (destination == null) {                     destination = (Destination)node.getRegionDestination();                 } else {                     if (destination != node.getRegionDestination()) {                         singleDestination = false;                     }                 }             }              if (getPrefetchSize() == 0) {                 decrementPrefetchExtension(1);             }         }          if (info.isDispatchAsync()) {             if (node != null) {                 md.setTransmitCallback(new TransmitCallback() {                      @Override                     public void onSuccess() {                         Destination regionDestination = (Destination) node.getRegionDestination();                         regionDestination.getDestinationStatistics().getDispatched().increment();                         regionDestination.getDestinationStatistics().getInflight().increment();                         node.decrementReferenceCount();                     }                      @Override                     public void onFailure() {                         Destination regionDestination = (Destination) node.getRegionDestination();                         regionDestination.getDestinationStatistics().getDispatched().increment();                         regionDestination.getDestinationStatistics().getInflight().increment();                         node.decrementReferenceCount();                     }                 });             }             context.getConnection().dispatchAsync(md);         } else {             context.getConnection().dispatchSync(md);             if (node != null) {                 Destination regionDestination = (Destination) node.getRegionDestination();                 regionDestination.getDestinationStatistics().getDispatched().increment();                 regionDestination.getDestinationStatistics().getInflight().increment();                 node.decrementReferenceCount();             }         }     }      private void discard(MessageReference message) {         discarding = true;         try {             message.decrementReferenceCount();             matched.remove(message);             discarded++;             if (destination != null) {                 destination.getDestinationStatistics().getDequeues().increment();             }             LOG.debug(&quot;{}, discarding message {}&quot;, this, message);             Destination dest = (Destination) message.getRegionDestination();             if (dest != null) {                 dest.messageDiscarded(getContext(), this, message);             }             broker.getRoot().sendToDeadLetterQueue(getContext(), message, this, new Throwable(&quot;TopicSubDiscard. ID:&quot; + info.getConsumerId()));         } finally {             discarding = false;         }     }      @Override     public String toString() {         return &quot;TopicSubscription:&quot; + &quot; consumer=&quot; + info.getConsumerId() + &quot;, destinations=&quot; + destinations.size() + &quot;, dispatched=&quot; + getDispatchedQueueSize() + &quot;, delivered=&quot;                 + getDequeueCounter() + &quot;, matched=&quot; + matched() + &quot;, discarded=&quot; + discarded() + &quot;, prefetchExtension=&quot; + prefetchExtension.get()                 + &quot;, usePrefetchExtension=&quot; + isUsePrefetchExtension();     }      @Override     public void destroy() {         this.active=false;         synchronized (matchedListMutex) {             try {                 matched.destroy();             } catch (Exception e) {                 LOG.warn(&quot;Failed to destroy cursor&quot;, e);             }         }         setSlowConsumer(false);         synchronized(dispatchLock) {             dispatched.clear();         }     }      @Override     public int getPrefetchSize() {         return info.getPrefetchSize();     }      @Override     public void setPrefetchSize(int newSize) {         info.setPrefetchSize(newSize);         try {             dispatchMatched();         } catch(Exception e) {             LOG.trace(&quot;Caught exception on dispatch after prefetch size change.&quot;);         }     }      public boolean isUseTopicSubscriptionInflightStats() {         return useTopicSubscriptionInflightStats;     }      public void setUseTopicSubscriptionInflightStats(boolean useTopicSubscriptionInflightStats) {         this.useTopicSubscriptionInflightStats = useTopicSubscriptionInflightStats;     }      private static class DispatchedNode {         private final int size;         private final MessageId messageId;         private final Destination destination;          public DispatchedNode(final MessageReference node) {             super();             this.size = node.getSize();             this.messageId = node.getMessageId();             this.destination = node.getRegionDestination() instanceof Destination ?                     ((Destination)node.getRegionDestination()) : null;         }          public long getSize() {             return size;         }          public MessageId getMessageId() {             return messageId;         }          public Destination getDestination() {             return destination;         }     }  }</td>
    <td align="left">blob</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11993</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-broker/src/main/java/org/apache/activemq/broker/region/TopicSubscription.java/#L51-L817</td>
    <td align="right">1</td>
    <td align="right">4521</td>
    <td align="right">11993</td>
  </tr>
  <tr valign="top">
    <td align="right">4734</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Feature Envy&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DebugInfoDecoder {     /** encoded debug info */     private final byte[] encoded;      /** positions decoded */     private final ArrayList positions;      /** locals decoded */     private final ArrayList locals;      /** size of code block in code units */     private final int codesize;      /** indexed by register, the last local variable live in a reg */     private final LocalEntry[] lastEntryForReg;      /** method descriptor of method this debug info is for */     private final Prototype desc;      /** true if method is static */     private final boolean isStatic;      /** dex file this debug info will be stored in */     private final DexFile file;      /**      * register size, in register units, of the register space      * used by this method      */     private final int regSize;      /** current decoding state: line number */     private int line = 1;      /** current decoding state: bytecode address */     private int address = 0;      /** string index of the string &quot;this&quot; */     private final int thisStringIdx;      /**      * Constructs an instance.      *      * @param encoded encoded debug info      * @param codesize size of code block in code units      * @param regSize register size, in register units, of the register space      * used by this method      * @param isStatic true if method is static      * @param ref method descriptor of method this debug info is for      * @param file dex file this debug info will be stored in      */     DebugInfoDecoder(byte[] encoded, int codesize, int regSize,             boolean isStatic, CstMethodRef ref, DexFile file) {         if (encoded == null) {             throw new NullPointerException(&quot;encoded == null&quot;);         }          this.encoded = encoded;         this.isStatic = isStatic;         this.desc = ref.getPrototype();         this.file = file;         this.regSize = regSize;          positions = new ArrayList();         locals = new ArrayList();         this.codesize = codesize;         lastEntryForReg = new LocalEntry[regSize];          int idx = -1;          try {             idx = file.getStringIds().indexOf(new CstString(&quot;this&quot;));         } catch (IllegalArgumentException ex) {             /*              * Silently tolerate not finding &quot;this&quot;. It just means that              * no method has local variable info that looks like              * a standard instance method.              */         }          thisStringIdx = idx;     }      /**      * An entry in the resulting postions table      */     static private class PositionEntry {         /** bytecode address */         public int address;          /** line number */         public int line;          public PositionEntry(int address, int line) {             this.address = address;             this.line = line;         }     }      /**      * An entry in the resulting locals table      */     static private class LocalEntry {         /** address of event */         public int address;          /** {@code true} iff it's a local start */         public boolean isStart;          /** register number */         public int reg;          /** index of name in strings table */         public int nameIndex;          /** index of type in types table */         public int typeIndex;          /** index of type signature in strings table */         public int signatureIndex;          public LocalEntry(int address, boolean isStart, int reg, int nameIndex,                 int typeIndex, int signatureIndex) {             this.address        = address;             this.isStart        = isStart;             this.reg            = reg;             this.nameIndex      = nameIndex;             this.typeIndex      = typeIndex;             this.signatureIndex = signatureIndex;         }          public String toString() {             return String.format(&quot;[%x %s v%d %04x %04x %04x]&quot;,                     address, isStart ? &quot;start&quot; : &quot;end&quot;, reg,                     nameIndex, typeIndex, signatureIndex);         }     }      /**      * Gets the decoded positions list.      * Valid after calling {@code decode}.      *      * @return positions list in ascending address order.      */     public List getPositionList() {         return positions;     }      /**      * Gets the decoded locals list, in ascending start-address order.      * Valid after calling {@code decode}.      *      * @return locals list in ascending address order.      */     public List getLocals() {         return locals;     }      /**      * Decodes the debug info sequence.      */     public void decode() {         try {             decode0();         } catch (Exception ex) {             throw ExceptionWithContext.withContext(ex,                     &quot;...while decoding debug info&quot;);         }     }      /**      * Reads a string index. String indicies are offset by 1, and a 0 value      * in the stream (-1 as returned by this method) means &quot;null&quot;      *      * @return index into file's string ids table, -1 means null      * @throws IOException      */     private int readStringIndex(ByteInput bs) throws IOException {         int offsetIndex = Leb128.readUnsignedLeb128(bs);          return offsetIndex - 1;     }      /**      * Gets the register that begins the method's parameter range (including      * the 'this' parameter for non-static methods). The range continues until      * {@code regSize}      *      * @return register as noted above.      */     private int getParamBase() {         return regSize                 - desc.getParameterTypes().getWordCount() - (isStatic? 0 : 1);     }      private void decode0() throws IOException {         ByteInput bs = new ByteArrayByteInput(encoded);          line = Leb128.readUnsignedLeb128(bs);         int szParams = Leb128.readUnsignedLeb128(bs);         StdTypeList params = desc.getParameterTypes();         int curReg = getParamBase();          if (szParams != params.size()) {             throw new RuntimeException(                     &quot;Mismatch between parameters_size and prototype&quot;);         }          if (!isStatic) {             // Start off with implicit 'this' entry             LocalEntry thisEntry =                 new LocalEntry(0, true, curReg, thisStringIdx, 0, 0);             locals.add(thisEntry);             lastEntryForReg[curReg] = thisEntry;             curReg++;         }          for (int i = 0; i &lt; szParams; i++) {             Type paramType = params.getType(i);             LocalEntry le;              int nameIdx = readStringIndex(bs);              if (nameIdx == -1) {                 /*                  * Unnamed parameter; often but not always filled in by an                  * extended start op after the prologue                  */                 le = new LocalEntry(0, true, curReg, -1, 0, 0);             } else {                 // TODO: Final 0 should be idx of paramType.getDescriptor().                 le = new LocalEntry(0, true, curReg, nameIdx, 0, 0);             }              locals.add(le);             lastEntryForReg[curReg] = le;             curReg += paramType.getCategory();         }          for (;;) {             int opcode = bs.readByte() &amp; 0xff;              switch (opcode) {                 case DBG_START_LOCAL: {                     int reg = Leb128.readUnsignedLeb128(bs);                     int nameIdx = readStringIndex(bs);                     int typeIdx = readStringIndex(bs);                     LocalEntry le = new LocalEntry(                             address, true, reg, nameIdx, typeIdx, 0);                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_START_LOCAL_EXTENDED: {                     int reg = Leb128.readUnsignedLeb128(bs);                     int nameIdx = readStringIndex(bs);                     int typeIdx = readStringIndex(bs);                     int sigIdx = readStringIndex(bs);                     LocalEntry le = new LocalEntry(                             address, true, reg, nameIdx, typeIdx, sigIdx);                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_RESTART_LOCAL: {                     int reg = Leb128.readUnsignedLeb128(bs);                     LocalEntry prevle;                     LocalEntry le;                      try {                         prevle = lastEntryForReg[reg];                          if (prevle.isStart) {                             throw new RuntimeException(&quot;nonsensical &quot;                                     + &quot;RESTART_LOCAL on live register v&quot;                                     + reg);                         }                          le = new LocalEntry(address, true, reg,                                 prevle.nameIndex, prevle.typeIndex, 0);                     } catch (NullPointerException ex) {                         throw new RuntimeException(                                 &quot;Encountered RESTART_LOCAL on new v&quot; + reg);                     }                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_END_LOCAL: {                     int reg = Leb128.readUnsignedLeb128(bs);                     LocalEntry prevle;                     LocalEntry le;                      try {                         prevle = lastEntryForReg[reg];                          if (!prevle.isStart) {                             throw new RuntimeException(&quot;nonsensical &quot;                                     + &quot;END_LOCAL on dead register v&quot; + reg);                         }                          le = new LocalEntry(address, false, reg,                                 prevle.nameIndex, prevle.typeIndex,                                 prevle.signatureIndex);                     } catch (NullPointerException ex) {                         throw new RuntimeException(                                 &quot;Encountered END_LOCAL on new v&quot; + reg);                     }                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_END_SEQUENCE:                     // all done                 return;                  case DBG_ADVANCE_PC:                     address += Leb128.readUnsignedLeb128(bs);                 break;                  case DBG_ADVANCE_LINE:                     line += Leb128.readSignedLeb128(bs);                 break;                  case DBG_SET_PROLOGUE_END:                     //TODO do something with this.                 break;                  case DBG_SET_EPILOGUE_BEGIN:                     //TODO do something with this.                 break;                  case DBG_SET_FILE:                     //TODO do something with this.                 break;                  default:                     if (opcode &lt; DBG_FIRST_SPECIAL) {                         throw new RuntimeException(                                 &quot;Invalid extended opcode encountered &quot;                                         + opcode);                     }                      int adjopcode = opcode - DBG_FIRST_SPECIAL;                      address += adjopcode / DBG_LINE_RANGE;                     line += DBG_LINE_BASE + (adjopcode % DBG_LINE_RANGE);                      positions.add(new PositionEntry(address, line));                 break;              }         }     }      /**      * Validates an encoded debug info stream against data used to encode it,      * throwing an exception if they do not match. Used to validate the      * encoder.      *      * @param info encoded debug info      * @param file {@code non-null;} file to refer to during decoding      * @param ref {@code non-null;} method whose info is being decoded      * @param code {@code non-null;} original code object that was encoded      * @param isStatic whether the method is static      */     public static void validateEncode(byte[] info, DexFile file,             CstMethodRef ref, DalvCode code, boolean isStatic) {         PositionList pl = code.getPositions();         LocalList ll = code.getLocals();         DalvInsnList insns = code.getInsns();         int codeSize = insns.codeSize();         int countRegisters = insns.getRegistersSize();          try {             validateEncode0(info, codeSize, countRegisters,                     isStatic, ref, file, pl, ll);         } catch (RuntimeException ex) {             System.err.println(&quot;instructions:&quot;);             insns.debugPrint(System.err, &quot;  &quot;, true);             System.err.println(&quot;local list:&quot;);             ll.debugPrint(System.err, &quot;  &quot;);             throw ExceptionWithContext.withContext(ex,                     &quot;while processing &quot; + ref.toHuman());         }     }      private static void validateEncode0(byte[] info, int codeSize,             int countRegisters, boolean isStatic, CstMethodRef ref,             DexFile file, PositionList pl, LocalList ll) {         DebugInfoDecoder decoder                 = new DebugInfoDecoder(info, codeSize, countRegisters,                     isStatic, ref, file);          decoder.decode();          /*          * Go through the decoded position entries, matching up          * with original entries.          */          List decodedEntries = decoder.getPositionList();          if (decodedEntries.size() != pl.size()) {             throw new RuntimeException(                     &quot;Decoded positions table not same size was &quot;                     + decodedEntries.size() + &quot; expected &quot; + pl.size());         }          for (PositionEntry entry : decodedEntries) {             boolean found = false;             for (int i = pl.size() - 1; i &gt;= 0; i--) {                 PositionList.Entry ple = pl.get(i);                  if (entry.line == ple.getPosition().getLine()                         &amp;&amp; entry.address == ple.getAddress()) {                     found = true;                     break;                 }             }              if (!found) {                 throw new RuntimeException (&quot;Could not match position entry: &quot;                         + entry.address + &quot;, &quot; + entry.line);             }         }          /*          * Go through the original local list, in order, matching up          * with decoded entries.          */          List decodedLocals = decoder.getLocals();         int thisStringIdx = decoder.thisStringIdx;         int decodedSz = decodedLocals.size();         int paramBase = decoder.getParamBase();          /*          * Preflight to fill in any parameters that were skipped in          * the prologue (including an implied &quot;this&quot;) but then          * identified by full signature.          */         for (int i = 0; i &lt; decodedSz; i++) {             LocalEntry entry = decodedLocals.get(i);             int idx = entry.nameIndex;              if ((idx &lt; 0) || (idx == thisStringIdx)) {                 for (int j = i + 1; j &lt; decodedSz; j++) {                     LocalEntry e2 = decodedLocals.get(j);                     if (e2.address != 0) {                         break;                     }                     if ((entry.reg == e2.reg) &amp;&amp; e2.isStart) {                         decodedLocals.set(i, e2);                         decodedLocals.remove(j);                         decodedSz--;                         break;                     }                 }             }         }          int origSz = ll.size();         int decodeAt = 0;         boolean problem = false;          for (int i = 0; i &lt; origSz; i++) {             LocalList.Entry origEntry = ll.get(i);              if (origEntry.getDisposition()                     == LocalList.Disposition.END_REPLACED) {                 /*                  * The encoded list doesn't represent replacements, so                  * ignore them for the sake of comparison.                  */                 continue;             }              LocalEntry decodedEntry;              do {                 decodedEntry = decodedLocals.get(decodeAt);                 if (decodedEntry.nameIndex &gt;= 0) {                     break;                 }                 /*                  * A negative name index means this is an anonymous                  * parameter, and we shouldn't expect to see it in the                  * original list. So, skip it.                  */                 decodeAt++;             } while (decodeAt &lt; decodedSz);              int decodedAddress = decodedEntry.address;              if (decodedEntry.reg != origEntry.getRegister()) {                 System.err.println(&quot;local register mismatch at orig &quot; + i +                         &quot; / decoded &quot; + decodeAt);                 problem = true;                 break;             }              if (decodedEntry.isStart != origEntry.isStart()) {                 System.err.println(&quot;local start/end mismatch at orig &quot; + i +                         &quot; / decoded &quot; + decodeAt);                 problem = true;                 break;             }              /*              * The secondary check here accounts for the fact that a              * parameter might not be marked as starting at 0 in the              * original list.              */             if ((decodedAddress != origEntry.getAddress())                     &amp;&amp; !((decodedAddress == 0)                             &amp;&amp; (decodedEntry.reg &gt;= paramBase))) {                 System.err.println(&quot;local address mismatch at orig &quot; + i +                         &quot; / decoded &quot; + decodeAt);                 problem = true;                 break;             }              decodeAt++;         }          if (problem) {             System.err.println(&quot;decoded locals:&quot;);             for (LocalEntry e : decodedLocals) {                 System.err.println(&quot;  &quot; + e);             }             throw new RuntimeException(&quot;local table problem&quot;);         }     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, feature envy</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;feature envy</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12715</td>
    <td align="left">https://github.com/facebook/buck/blob/1bc8d383ea5cb153ca9bf4f2807e6be498648523/third-party/java/dx/src/com/android/dx/dex/file/DebugInfoDecoder.java/#L54-L596</td>
    <td align="right">1</td>
    <td align="right">4734</td>
    <td align="right">12715</td>
  </tr>
  <tr valign="top">
    <td align="right">5057</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class AbstractControllerService extends AbstractConfigurableComponent implements ControllerService {      private String identifier;     private ControllerServiceLookup serviceLookup;     private ComponentLog logger;     private StateManager stateManager;     private volatile ConfigurationContext configurationContext;     private volatile boolean enabled = false;      @Override     public final void initialize(final ControllerServiceInitializationContext context) throws InitializationException {         this.identifier = context.getIdentifier();         serviceLookup = context.getControllerServiceLookup();         logger = context.getLogger();         stateManager = context.getStateManager();         init(context);     }      @Override     public String getIdentifier() {         return identifier;     }      /**      * @return the {@link ControllerServiceLookup} that was passed to the      * {@link #init(ControllerServiceInitializationContext)} method      */     protected final ControllerServiceLookup getControllerServiceLookup() {         return serviceLookup;     }      /**      * Provides a mechanism by which subclasses can perform initialization of      * the Controller Service before it is scheduled to be run      *      * @param config of initialization context      * @throws InitializationException if unable to init      */     protected void init(final ControllerServiceInitializationContext config) throws InitializationException {     }      @OnEnabled     public final void enabled() {         this.enabled = true;     }      @OnDisabled     public final void disabled() {         this.enabled = false;     }      public boolean isEnabled() {         return this.enabled;     }      /**      * @return the logger that has been provided to the component by the      * framework in its initialize method      */     protected ComponentLog getLogger() {         return logger;     }      /**      * @return the StateManager that can be used to store and retrieve state for this Controller Service      */     protected StateManager getStateManager() {         return stateManager;     }      @OnEnabled     public final void abstractStoreConfigContext(final ConfigurationContext configContext) {         this.configurationContext = configContext;     }      @OnDisabled     public final void abstractClearConfigContext() {         this.configurationContext = null;     }      protected ConfigurationContext getConfigurationContext() {         final ConfigurationContext context = this.configurationContext;         if (context == null) {             throw new IllegalStateException(&quot;No Configuration Context exists&quot;);         }          return configurationContext;     }      protected PropertyValue getProperty(final PropertyDescriptor descriptor) {         return getConfigurationContext().getProperty(descriptor);     } }</td>
    <td align="left">blob</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14131</td>
    <td align="left">https://github.com/apache/nifi/blob/c8eff590efa3babcda0b755009224dcac168708b/nifi-api/src/main/java/org/apache/nifi/controller/AbstractControllerService.java/#L28-L120</td>
    <td align="right">1</td>
    <td align="right">5057</td>
    <td align="right">14131</td>
  </tr>
  <tr valign="top">
    <td align="right">5176</td>
    <td align="left">{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Blob&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@InterfaceAudience.Private @Metrics(context=&quot;metricssystem&quot;) public class MetricsSystemImpl extends MetricsSystem implements MetricsSource {    static final Log LOG = LogFactory.getLog(MetricsSystemImpl.class);   static final String MS_NAME = &quot;MetricsSystem&quot;;   static final String MS_STATS_NAME = MS_NAME +&quot;,sub=Stats&quot;;   static final String MS_STATS_DESC = &quot;Metrics system metrics&quot;;   static final String MS_CONTROL_NAME = MS_NAME +&quot;,sub=Control&quot;;   static final String MS_INIT_MODE_KEY = &quot;hadoop.metrics.init.mode&quot;;    enum InitMode { NORMAL, STANDBY }    private final Map sources;   private final Map allSources;   private final Map sinks;   private final Map allSinks;   private final List callbacks;   private final MetricsCollectorImpl collector;   private final MetricsRegistry registry = new MetricsRegistry(MS_NAME);   @Metric({&quot;Snapshot&quot;, &quot;Snapshot stats&quot;}) MutableStat snapshotStat;   @Metric({&quot;Publish&quot;, &quot;Publishing stats&quot;}) MutableStat publishStat;   @Metric(&quot;Dropped updates by all sinks&quot;) MutableCounterLong droppedPubAll;    private final List injectedTags;    // Things that are changed by init()/start()/stop()   private String prefix;   private MetricsFilter sourceFilter;   private MetricsConfig config;   private Map sourceConfigs, sinkConfigs;   private boolean monitoring = false;   private Timer timer;   private int period; // seconds   private long logicalTime; // number of timer invocations * period   private ObjectName mbeanName;   private boolean publishSelfMetrics = true;   private MetricsSourceAdapter sysSource;   private int refCount = 0; // for mini cluster mode    /**    * Construct the metrics system    * @param prefix  for the system    */   public MetricsSystemImpl(String prefix) {     this.prefix = prefix;     allSources = Maps.newHashMap();     sources = Maps.newLinkedHashMap();     allSinks = Maps.newHashMap();     sinks = Maps.newLinkedHashMap();     sourceConfigs = Maps.newHashMap();     sinkConfigs = Maps.newHashMap();     callbacks = Lists.newArrayList();     injectedTags = Lists.newArrayList();     collector = new MetricsCollectorImpl();     if (prefix != null) {       // prefix could be null for default ctor, which requires init later       initSystemMBean();     }   }    /**    * Construct the system but not initializing (read config etc.) it.    */   public MetricsSystemImpl() {     this(null);   }    /**    * Initialized the metrics system with a prefix.    * @param prefix  the system will look for configs with the prefix    * @return the metrics system object itself    */   @Override   public synchronized MetricsSystem init(String prefix) {     if (monitoring &amp;&amp; !DefaultMetricsSystem.inMiniClusterMode()) {       LOG.warn(this.prefix +&quot; metrics system already initialized!&quot;);       return this;     }     this.prefix = checkNotNull(prefix, &quot;prefix&quot;);     ++refCount;     if (monitoring) {       // in mini cluster mode       LOG.info(this.prefix +&quot; metrics system started (again)&quot;);       return this;     }     switch (initMode()) {       case NORMAL:         try { start(); }         catch (MetricsConfigException e) {           // Configuration errors (e.g., typos) should not be fatal.           // We can always start the metrics system later via JMX.           LOG.warn(&quot;Metrics system not started: &quot;+ e.getMessage());           LOG.debug(&quot;Stacktrace: &quot;, e);         }         break;       case STANDBY:         LOG.info(prefix +&quot; metrics system started in standby mode&quot;);     }     initSystemMBean();     return this;   }    @Override   public synchronized void start() {     checkNotNull(prefix, &quot;prefix&quot;);     if (monitoring) {       LOG.warn(prefix +&quot; metrics system already started!&quot;,                new MetricsException(&quot;Illegal start&quot;));       return;     }     for (Callback cb : callbacks) cb.preStart();     configure(prefix);     startTimer();     monitoring = true;     LOG.info(prefix +&quot; metrics system started&quot;);     for (Callback cb : callbacks) cb.postStart();   }    @Override   public synchronized void stop() {     if (!monitoring &amp;&amp; !DefaultMetricsSystem.inMiniClusterMode()) {       LOG.warn(prefix +&quot; metrics system not yet started!&quot;,                new MetricsException(&quot;Illegal stop&quot;));       return;     }     if (!monitoring) {       // in mini cluster mode       LOG.info(prefix +&quot; metrics system stopped (again)&quot;);       return;     }     for (Callback cb : callbacks) cb.preStop();     LOG.info(&quot;Stopping &quot;+ prefix +&quot; metrics system...&quot;);     stopTimer();     stopSources();     stopSinks();     clearConfigs();     monitoring = false;     LOG.info(prefix +&quot; metrics system stopped.&quot;);     for (Callback cb : callbacks) cb.postStop();   }    @Override public synchronized    T register(String name, String desc, T source) {     MetricsSourceBuilder sb = MetricsAnnotations.newSourceBuilder(source);     final MetricsSource s = sb.build();     MetricsInfo si = sb.info();     String name2 = name == null ? si.name() : name;     final String finalDesc = desc == null ? si.description() : desc;     final String finalName = // be friendly to non-metrics tests         DefaultMetricsSystem.sourceName(name2, !monitoring);     allSources.put(finalName, s);     LOG.debug(finalName +&quot;, &quot;+ finalDesc);     if (monitoring) {       registerSource(finalName, finalDesc, s);     }     // We want to re-register the source to pick up new config when the     // metrics system restarts.     register(new AbstractCallback() {       @Override public void postStart() {         registerSource(finalName, finalDesc, s);       }     });     return source;   }    @Override public synchronized   void unregisterSource(String name) {     if (sources.containsKey(name)) {       sources.get(name).stop();       sources.remove(name);     }     if (allSources.containsKey(name)) {       allSources.remove(name);     }   }    synchronized   void registerSource(String name, String desc, MetricsSource source) {     checkNotNull(config, &quot;config&quot;);     MetricsConfig conf = sourceConfigs.get(name);     MetricsSourceAdapter sa = new MetricsSourceAdapter(prefix, name, desc,         source, injectedTags, period, conf != null ? conf             : config.subset(SOURCE_KEY));     sources.put(name, sa);     sa.start();     LOG.debug(&quot;Registered source &quot;+ name);   }    @Override public synchronized    T register(final String name, final String description, final T sink) {     LOG.debug(name +&quot;, &quot;+ description);     if (allSinks.containsKey(name)) {       LOG.warn(&quot;Sink &quot;+ name +&quot; already exists!&quot;);       return sink;     }     allSinks.put(name, sink);     if (config != null) {       registerSink(name, description, sink);     }     // We want to re-register the sink to pick up new config     // when the metrics system restarts.     register(new AbstractCallback() {       @Override public void postStart() {         register(name, description, sink);       }     });     return sink;   }    synchronized void registerSink(String name, String desc, MetricsSink sink) {     checkNotNull(config, &quot;config&quot;);     MetricsConfig conf = sinkConfigs.get(name);     MetricsSinkAdapter sa = conf != null         ? newSink(name, desc, sink, conf)         : newSink(name, desc, sink, config.subset(SINK_KEY));     sinks.put(name, sa);     sa.start();     LOG.info(&quot;Registered sink &quot;+ name);   }    @Override   public synchronized void register(final Callback callback) {     callbacks.add((Callback) Proxy.newProxyInstance(         callback.getClass().getClassLoader(), new Class[] { Callback.class },         new InvocationHandler() {           @Override           public Object invoke(Object proxy, Method method, Object[] args)               throws Throwable {             try {               return method.invoke(callback, args);             } catch (Exception e) {               // These are not considered fatal.               LOG.warn(&quot;Caught exception in callback &quot;+ method.getName(), e);             }             return null;           }         }));   }    @Override   public synchronized void startMetricsMBeans() {     for (MetricsSourceAdapter sa : sources.values()) {       sa.startMBeans();     }   }    @Override   public synchronized void stopMetricsMBeans() {     for (MetricsSourceAdapter sa : sources.values()) {       sa.stopMBeans();     }   }    @Override   public synchronized String currentConfig() {     PropertiesConfiguration saver = new PropertiesConfiguration();     StringWriter writer = new StringWriter();     saver.copy(config);     try { saver.save(writer); }     catch (Exception e) {       throw new MetricsConfigException(&quot;Error stringify config&quot;, e);     }     return writer.toString();   }    private synchronized void startTimer() {     if (timer != null) {       LOG.warn(prefix +&quot; metrics system timer already started!&quot;);       return;     }     logicalTime = 0;     long millis = period * 1000;     timer = new Timer(&quot;Timer for '&quot;+ prefix +&quot;' metrics system&quot;, true);     timer.scheduleAtFixedRate(new TimerTask() {           @Override           public void run() {             try {               onTimerEvent();             } catch (Exception e) {               LOG.warn(e);             }           }         }, millis, millis);     LOG.info(&quot;Scheduled snapshot period at &quot;+ period +&quot; second(s).&quot;);   }    synchronized void onTimerEvent() {     logicalTime += period;     if (sinks.size() &gt; 0) {       publishMetrics(sampleMetrics(), false);     }   }      /**    * Requests an immediate publish of all metrics from sources to sinks.    */   @Override   public void publishMetricsNow() {     if (sinks.size() &gt; 0) {       publishMetrics(sampleMetrics(), true);     }       }    /**    * Sample all the sources for a snapshot of metrics/tags    * @return  the metrics buffer containing the snapshot    */   synchronized MetricsBuffer sampleMetrics() {     collector.clear();     MetricsBufferBuilder bufferBuilder = new MetricsBufferBuilder();      for (Entry entry : sources.entrySet()) {       if (sourceFilter == null || sourceFilter.accepts(entry.getKey())) {         snapshotMetrics(entry.getValue(), bufferBuilder);       }     }     if (publishSelfMetrics) {       snapshotMetrics(sysSource, bufferBuilder);     }     MetricsBuffer buffer = bufferBuilder.get();     return buffer;   }    private void snapshotMetrics(MetricsSourceAdapter sa,                                MetricsBufferBuilder bufferBuilder) {     long startTime = Time.now();     bufferBuilder.add(sa.name(), sa.getMetrics(collector, true));     collector.clear();     snapshotStat.add(Time.now() - startTime);     LOG.debug(&quot;Snapshotted source &quot;+ sa.name());   }    /**    * Publish a metrics snapshot to all the sinks    * @param buffer  the metrics snapshot to publish    * @param immediate  indicates that we should publish metrics immediately    *                   instead of using a separate thread.    */   synchronized void publishMetrics(MetricsBuffer buffer, boolean immediate) {     int dropped = 0;     for (MetricsSinkAdapter sa : sinks.values()) {       long startTime = Time.now();       boolean result;       if (immediate) {         result = sa.putMetricsImmediate(buffer);        } else {         result = sa.putMetrics(buffer, logicalTime);       }       dropped += result ? 0 : 1;       publishStat.add(Time.now() - startTime);     }     droppedPubAll.incr(dropped);   }    private synchronized void stopTimer() {     if (timer == null) {       LOG.warn(prefix +&quot; metrics system timer already stopped!&quot;);       return;     }     timer.cancel();     timer = null;   }    private synchronized void stopSources() {     for (Entry entry : sources.entrySet()) {       MetricsSourceAdapter sa = entry.getValue();       LOG.debug(&quot;Stopping metrics source &quot;+ entry.getKey() +           &quot;: class=&quot; + sa.source().getClass());       sa.stop();     }     sysSource.stop();     sources.clear();   }    private synchronized void stopSinks() {     for (Entry entry : sinks.entrySet()) {       MetricsSinkAdapter sa = entry.getValue();       LOG.debug(&quot;Stopping metrics sink &quot;+ entry.getKey() +           &quot;: class=&quot; + sa.sink().getClass());       sa.stop();     }     sinks.clear();   }    private synchronized void configure(String prefix) {     config = MetricsConfig.create(prefix);     configureSinks();     configureSources();     configureSystem();   }    private synchronized void configureSystem() {     injectedTags.add(Interns.tag(MsInfo.Hostname, getHostname()));   }    private synchronized void configureSinks() {     sinkConfigs = config.getInstanceConfigs(SINK_KEY);     int confPeriod = 0;     for (Entry entry : sinkConfigs.entrySet()) {       MetricsConfig conf = entry.getValue();       int sinkPeriod = conf.getInt(PERIOD_KEY, PERIOD_DEFAULT);       confPeriod = confPeriod == 0 ? sinkPeriod                                    : ArithmeticUtils.gcd(confPeriod, sinkPeriod);       String clsName = conf.getClassName(&quot;&quot;);       if (clsName == null) continue;  // sink can be registered later on       String sinkName = entry.getKey();       try {         MetricsSinkAdapter sa = newSink(sinkName,             conf.getString(DESC_KEY, sinkName), conf);         sa.start();         sinks.put(sinkName, sa);       } catch (Exception e) {         LOG.warn(&quot;Error creating sink '&quot;+ sinkName +&quot;'&quot;, e);       }     }     period = confPeriod &gt; 0 ? confPeriod                             : config.getInt(PERIOD_KEY, PERIOD_DEFAULT);   }    static MetricsSinkAdapter newSink(String name, String desc, MetricsSink sink,                                     MetricsConfig conf) {     return new MetricsSinkAdapter(name, desc, sink, conf.getString(CONTEXT_KEY),         conf.getFilter(SOURCE_FILTER_KEY),         conf.getFilter(RECORD_FILTER_KEY),         conf.getFilter(METRIC_FILTER_KEY),         conf.getInt(PERIOD_KEY, PERIOD_DEFAULT),         conf.getInt(QUEUE_CAPACITY_KEY, QUEUE_CAPACITY_DEFAULT),         conf.getInt(RETRY_DELAY_KEY, RETRY_DELAY_DEFAULT),         conf.getFloat(RETRY_BACKOFF_KEY, RETRY_BACKOFF_DEFAULT),         conf.getInt(RETRY_COUNT_KEY, RETRY_COUNT_DEFAULT));   }    static MetricsSinkAdapter newSink(String name, String desc,                                     MetricsConfig conf) {     return newSink(name, desc, (MetricsSink) conf.getPlugin(&quot;&quot;), conf);   }    private void configureSources() {     sourceFilter = config.getFilter(PREFIX_DEFAULT + SOURCE_FILTER_KEY);     sourceConfigs = config.getInstanceConfigs(SOURCE_KEY);     registerSystemSource();   }    private void clearConfigs() {     sinkConfigs.clear();     sourceConfigs.clear();     injectedTags.clear();     config = null;   }    static String getHostname() {     try {       return InetAddress.getLocalHost().getHostName();     } catch (Exception e) {       LOG.error(&quot;Error getting localhost name. Using 'localhost'...&quot;, e);     }     return &quot;localhost&quot;;   }    private void registerSystemSource() {     MetricsConfig sysConf = sourceConfigs.get(MS_NAME);     sysSource = new MetricsSourceAdapter(prefix, MS_STATS_NAME, MS_STATS_DESC,         MetricsAnnotations.makeSource(this), injectedTags, period,         sysConf == null ? config.subset(SOURCE_KEY) : sysConf);     sysSource.start();   }    @Override   public synchronized void getMetrics(MetricsCollector builder, boolean all) {     MetricsRecordBuilder rb = builder.addRecord(MS_NAME)         .addGauge(MsInfo.NumActiveSources, sources.size())         .addGauge(MsInfo.NumAllSources, allSources.size())         .addGauge(MsInfo.NumActiveSinks, sinks.size())         .addGauge(MsInfo.NumAllSinks, allSinks.size());      for (MetricsSinkAdapter sa : sinks.values()) {       sa.snapshot(rb, all);     }     registry.snapshot(rb, all);   }    private void initSystemMBean() {     checkNotNull(prefix, &quot;prefix should not be null here!&quot;);     if (mbeanName == null) {       mbeanName = MBeans.register(prefix, MS_CONTROL_NAME, this);     }   }    @Override   public synchronized boolean shutdown() {     LOG.debug(&quot;refCount=&quot;+ refCount);     if (refCount &lt;= 0) {       LOG.debug(&quot;Redundant shutdown&quot;, new Throwable());       return true; // already shutdown     }     if (--refCount &gt; 0) return false;     if (monitoring) {       try { stop(); }       catch (Exception e) {         LOG.warn(&quot;Error stopping the metrics system&quot;, e);       }     }     allSources.clear();     allSinks.clear();     callbacks.clear();     if (mbeanName != null) {       MBeans.unregister(mbeanName);       mbeanName = null;     }     LOG.info(prefix +&quot; metrics system shutdown complete.&quot;);     return true;   }    @Override   public MetricsSource getSource(String name) {     return allSources.get(name);   }    @VisibleForTesting   MetricsSourceAdapter getSourceAdapter(String name) {     return sources.get(name);   }    private InitMode initMode() {     LOG.debug(&quot;from system property: &quot;+ System.getProperty(MS_INIT_MODE_KEY));     LOG.debug(&quot;from environment variable: &quot;+ System.getenv(MS_INIT_MODE_KEY));     String m = System.getProperty(MS_INIT_MODE_KEY);     String m2 = m == null ? System.getenv(MS_INIT_MODE_KEY) : m;     return InitMode.valueOf((m2 == null ? InitMode.NORMAL.name() : m2)                             .toUpperCase(Locale.US));   } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14479</td>
    <td align="left">https://github.com/apache/hadoop-common/blob/42a61a4fbc88303913c4681f0d40ffcc737e70b5/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/metrics2/impl/MetricsSystemImpl.java/#L69-L601</td>
    <td align="right">1</td>
    <td align="right">5176</td>
    <td align="right">14479</td>
  </tr>
  <tr valign="top">
    <td align="right">5299</td>
    <td align="left">{     &quot;input_code&quot;: &quot;public class Example { public void foo() { System.out.println(\&quot;Hello, World!\&quot;); } }&quot;,     &quot;common_code_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Feature Envy&quot;, &quot;Long Method&quot;],     &quot;detected_bad_smells&quot;: {         &quot;blob&quot;: false,         &quot;data_class&quot;: false,         &quot;feature_envy&quot;: false,         &quot;long_method&quot;: true     } }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
None</td>
    <td align="left">blob</td>
    <td align="left">blob: false, data_class: false, feature_envy: false, long_method: true</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;data_class: false,  feature_envy: false,  long_method: true</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14830</td>
    <td align="left">https://github.com/apache/airavata/blob/391843a00eefa7b6213e845f2f044b4e042894d5/airavata-api/airavata-api-stubs/src/main/java/org/apache/airavata/api/Airavata.java/#L33809-L33879</td>
    <td align="right">1</td>
    <td align="right">5299</td>
    <td align="right">14830</td>
  </tr>
  <tr valign="top">
    <td align="right">5337</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DefaultHotSpotLoweringProvider extends DefaultJavaLoweringProvider implements HotSpotLoweringProvider {      protected final HotSpotGraalRuntimeProvider runtime;     protected final HotSpotRegistersProvider registers;     protected final HotSpotConstantReflectionProvider constantReflection;      protected InstanceOfSnippets.Templates instanceofSnippets;     protected NewObjectSnippets.Templates newObjectSnippets;     protected MonitorSnippets.Templates monitorSnippets;     protected WriteBarrierSnippets.Templates writeBarrierSnippets;     protected LoadExceptionObjectSnippets.Templates exceptionObjectSnippets;     protected UnsafeLoadSnippets.Templates unsafeLoadSnippets;     protected AssertionSnippets.Templates assertionSnippets;     protected ArrayCopySnippets.Templates arraycopySnippets;     protected StringToBytesSnippets.Templates stringToBytesSnippets;     protected HashCodeSnippets.Templates hashCodeSnippets;     protected ResolveConstantSnippets.Templates resolveConstantSnippets;     protected ProfileSnippets.Templates profileSnippets;      protected ObjectCloneSnippets.Templates objectCloneSnippets;     protected ForeignCallSnippets.Templates foreignCallSnippets;      public DefaultHotSpotLoweringProvider(HotSpotGraalRuntimeProvider runtime, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls, HotSpotRegistersProvider registers,                     HotSpotConstantReflectionProvider constantReflection, TargetDescription target) {         super(metaAccess, foreignCalls, target, runtime.getVMConfig().useCompressedOops);         this.runtime = runtime;         this.registers = registers;         this.constantReflection = constantReflection;     }      @Override     public void initialize(OptionValues options, Iterable factories, HotSpotProviders providers, GraalHotSpotVMConfig config) {         super.initialize(options, factories, runtime, providers, providers.getSnippetReflection());          assert target == providers.getCodeCache().getTarget();         instanceofSnippets = new InstanceOfSnippets.Templates(options, factories, runtime, providers, target);         newObjectSnippets = new NewObjectSnippets.Templates(options, factories, runtime, providers, target, config);         monitorSnippets = new MonitorSnippets.Templates(options, factories, runtime, providers, target, config.useFastLocking);         writeBarrierSnippets = new WriteBarrierSnippets.Templates(options, factories, runtime, providers, target, config);         exceptionObjectSnippets = new LoadExceptionObjectSnippets.Templates(options, factories, providers, target);         unsafeLoadSnippets = new UnsafeLoadSnippets.Templates(options, factories, providers, target);         assertionSnippets = new AssertionSnippets.Templates(options, factories, providers, target);         arraycopySnippets = new ArrayCopySnippets.Templates(new HotSpotArraycopySnippets(), options, factories, runtime, providers, providers.getSnippetReflection(), target);         stringToBytesSnippets = new StringToBytesSnippets.Templates(options, factories, providers, target);         hashCodeSnippets = new HashCodeSnippets.Templates(options, factories, providers, target);         resolveConstantSnippets = new ResolveConstantSnippets.Templates(options, factories, providers, target);         if (!JavaVersionUtil.Java8OrEarlier) {             profileSnippets = new ProfileSnippets.Templates(options, factories, providers, target);         }         objectCloneSnippets = new ObjectCloneSnippets.Templates(options, factories, providers, target);         foreignCallSnippets = new ForeignCallSnippets.Templates(options, factories, providers, target);     }      public MonitorSnippets.Templates getMonitorSnippets() {         return monitorSnippets;     }      @Override     @SuppressWarnings(&quot;try&quot;)     public void lower(Node n, LoweringTool tool) {         StructuredGraph graph = (StructuredGraph) n.graph();         try (DebugCloseable context = n.withNodeSourcePosition()) {             if (n instanceof Invoke) {                 lowerInvoke((Invoke) n, tool, graph);             } else if (n instanceof LoadMethodNode) {                 lowerLoadMethodNode((LoadMethodNode) n);             } else if (n instanceof GetClassNode) {                 lowerGetClassNode((GetClassNode) n, tool, graph);             } else if (n instanceof StoreHubNode) {                 lowerStoreHubNode((StoreHubNode) n, graph);             } else if (n instanceof OSRStartNode) {                 lowerOSRStartNode((OSRStartNode) n);             } else if (n instanceof BytecodeExceptionNode) {                 lowerBytecodeExceptionNode((BytecodeExceptionNode) n);             } else if (n instanceof InstanceOfNode) {                 InstanceOfNode instanceOfNode = (InstanceOfNode) n;                 if (graph.getGuardsStage().areDeoptsFixed()) {                     instanceofSnippets.lower(instanceOfNode, tool);                 } else {                     if (instanceOfNode.allowsNull()) {                         ValueNode object = instanceOfNode.getValue();                         LogicNode newTypeCheck = graph.addOrUniqueWithInputs(InstanceOfNode.create(instanceOfNode.type(), object, instanceOfNode.profile(), instanceOfNode.getAnchor()));                         LogicNode newNode = LogicNode.or(graph.unique(IsNullNode.create(object)), newTypeCheck, GraalDirectives.UNLIKELY_PROBABILITY);                         instanceOfNode.replaceAndDelete(newNode);                     }                 }             } else if (n instanceof InstanceOfDynamicNode) {                 InstanceOfDynamicNode instanceOfDynamicNode = (InstanceOfDynamicNode) n;                 if (graph.getGuardsStage().areDeoptsFixed()) {                     instanceofSnippets.lower(instanceOfDynamicNode, tool);                 } else {                     ValueNode mirror = instanceOfDynamicNode.getMirrorOrHub();                     if (mirror.stamp(NodeView.DEFAULT).getStackKind() == JavaKind.Object) {                         ClassGetHubNode classGetHub = graph.unique(new ClassGetHubNode(mirror));                         instanceOfDynamicNode.setMirror(classGetHub);                     }                      if (instanceOfDynamicNode.allowsNull()) {                         ValueNode object = instanceOfDynamicNode.getObject();                         LogicNode newTypeCheck = graph.addOrUniqueWithInputs(                                         InstanceOfDynamicNode.create(graph.getAssumptions(), tool.getConstantReflection(), instanceOfDynamicNode.getMirrorOrHub(), object, false));                         LogicNode newNode = LogicNode.or(graph.unique(IsNullNode.create(object)), newTypeCheck, GraalDirectives.UNLIKELY_PROBABILITY);                         instanceOfDynamicNode.replaceAndDelete(newNode);                     }                 }             } else if (n instanceof ClassIsAssignableFromNode) {                 if (graph.getGuardsStage().areDeoptsFixed()) {                     instanceofSnippets.lower((ClassIsAssignableFromNode) n, tool);                 }             } else if (n instanceof NewInstanceNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     newObjectSnippets.lower((NewInstanceNode) n, registers, tool);                 }             } else if (n instanceof DynamicNewInstanceNode) {                 DynamicNewInstanceNode newInstanceNode = (DynamicNewInstanceNode) n;                 if (newInstanceNode.getClassClass() == null) {                     JavaConstant classClassMirror = constantReflection.asJavaClass(metaAccess.lookupJavaType(Class.class));                     ConstantNode classClass = ConstantNode.forConstant(classClassMirror, tool.getMetaAccess(), graph);                     newInstanceNode.setClassClass(classClass);                 }                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     newObjectSnippets.lower(newInstanceNode, registers, tool);                 }             } else if (n instanceof NewArrayNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     newObjectSnippets.lower((NewArrayNode) n, registers, tool);                 }             } else if (n instanceof DynamicNewArrayNode) {                 DynamicNewArrayNode dynamicNewArrayNode = (DynamicNewArrayNode) n;                 if (dynamicNewArrayNode.getVoidClass() == null) {                     JavaConstant voidClassMirror = constantReflection.asJavaClass(metaAccess.lookupJavaType(void.class));                     ConstantNode voidClass = ConstantNode.forConstant(voidClassMirror, tool.getMetaAccess(), graph);                     dynamicNewArrayNode.setVoidClass(voidClass);                 }                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     newObjectSnippets.lower(dynamicNewArrayNode, registers, tool);                 }             } else if (n instanceof VerifyHeapNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     newObjectSnippets.lower((VerifyHeapNode) n, registers, tool);                 }             } else if (n instanceof RawMonitorEnterNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     monitorSnippets.lower((RawMonitorEnterNode) n, registers, tool);                 }             } else if (n instanceof MonitorExitNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     monitorSnippets.lower((MonitorExitNode) n, registers, tool);                 }             } else if (n instanceof ArrayCopyNode) {                 arraycopySnippets.lower((ArrayCopyNode) n, tool);             } else if (n instanceof ArrayCopyWithSlowPathNode) {                 arraycopySnippets.lower((ArrayCopyWithSlowPathNode) n, tool);             } else if (n instanceof G1PreWriteBarrier) {                 writeBarrierSnippets.lower((G1PreWriteBarrier) n, registers, tool);             } else if (n instanceof G1PostWriteBarrier) {                 writeBarrierSnippets.lower((G1PostWriteBarrier) n, registers, tool);             } else if (n instanceof G1ReferentFieldReadBarrier) {                 writeBarrierSnippets.lower((G1ReferentFieldReadBarrier) n, registers, tool);             } else if (n instanceof SerialWriteBarrier) {                 writeBarrierSnippets.lower((SerialWriteBarrier) n, tool);             } else if (n instanceof SerialArrayRangeWriteBarrier) {                 writeBarrierSnippets.lower((SerialArrayRangeWriteBarrier) n, tool);             } else if (n instanceof G1ArrayRangePreWriteBarrier) {                 writeBarrierSnippets.lower((G1ArrayRangePreWriteBarrier) n, registers, tool);             } else if (n instanceof G1ArrayRangePostWriteBarrier) {                 writeBarrierSnippets.lower((G1ArrayRangePostWriteBarrier) n, registers, tool);             } else if (n instanceof NewMultiArrayNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     newObjectSnippets.lower((NewMultiArrayNode) n, tool);                 }             } else if (n instanceof LoadExceptionObjectNode) {                 exceptionObjectSnippets.lower((LoadExceptionObjectNode) n, registers, tool);             } else if (n instanceof AssertionNode) {                 assertionSnippets.lower((AssertionNode) n, tool);             } else if (n instanceof StringToBytesNode) {                 if (graph.getGuardsStage().areDeoptsFixed()) {                     stringToBytesSnippets.lower((StringToBytesNode) n, tool);                 }             } else if (n instanceof IntegerDivRemNode) {                 // Nothing to do for division nodes. The HotSpot signal handler catches divisions by                 // zero and the MIN_VALUE / -1 cases.             } else if (n instanceof AbstractDeoptimizeNode || n instanceof UnwindNode || n instanceof RemNode || n instanceof SafepointNode) {                 /* No lowering, we generate LIR directly for these nodes. */             } else if (n instanceof ClassGetHubNode) {                 lowerClassGetHubNode((ClassGetHubNode) n, tool);             } else if (n instanceof HubGetClassNode) {                 lowerHubGetClassNode((HubGetClassNode) n, tool);             } else if (n instanceof KlassLayoutHelperNode) {                 lowerKlassLayoutHelperNode((KlassLayoutHelperNode) n, tool);             } else if (n instanceof ComputeObjectAddressNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     lowerComputeObjectAddressNode((ComputeObjectAddressNode) n);                 }             } else if (n instanceof IdentityHashCodeNode) {                 hashCodeSnippets.lower((IdentityHashCodeNode) n, tool);             } else if (n instanceof ResolveDynamicConstantNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     resolveConstantSnippets.lower((ResolveDynamicConstantNode) n, tool);                 }             } else if (n instanceof ResolveConstantNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     resolveConstantSnippets.lower((ResolveConstantNode) n, tool);                 }             } else if (n instanceof ResolveMethodAndLoadCountersNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     resolveConstantSnippets.lower((ResolveMethodAndLoadCountersNode) n, tool);                 }             } else if (n instanceof InitializeKlassNode) {                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {                     resolveConstantSnippets.lower((InitializeKlassNode) n, tool);                 }             } else if (n instanceof ProfileNode) {                 profileSnippets.lower((ProfileNode) n, tool);             } else {                 super.lower(n, tool);             }         }     }      private static void lowerComputeObjectAddressNode(ComputeObjectAddressNode n) {         /*          * Lower the node into a ComputeObjectAddress node and an Add but ensure that it's below any          * potential safepoints and above it's uses.          */         for (Node use : n.usages().snapshot()) {             if (use instanceof FixedNode) {                 FixedNode fixed = (FixedNode) use;                 StructuredGraph graph = n.graph();                 GetObjectAddressNode address = graph.add(new GetObjectAddressNode(n.getObject()));                 graph.addBeforeFixed(fixed, address);                 AddNode add = graph.addOrUnique(new AddNode(address, n.getOffset()));                 use.replaceFirstInput(n, add);             } else {                 throw GraalError.shouldNotReachHere(&quot;Unexpected floating use of ComputeObjectAddressNode &quot; + n);             }         }         GraphUtil.unlinkFixedNode(n);         n.safeDelete();     }      private void lowerKlassLayoutHelperNode(KlassLayoutHelperNode n, LoweringTool tool) {         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {             return;         }         StructuredGraph graph = n.graph();         assert !n.getHub().isConstant();         AddressNode address = createOffsetAddress(graph, n.getHub(), runtime.getVMConfig().klassLayoutHelperOffset);         n.replaceAtUsagesAndDelete(graph.unique(new FloatingReadNode(address, KLASS_LAYOUT_HELPER_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE)));     }      private void lowerHubGetClassNode(HubGetClassNode n, LoweringTool tool) {         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {             return;         }          ValueNode hub = n.getHub();         GraalHotSpotVMConfig vmConfig = runtime.getVMConfig();         StructuredGraph graph = n.graph();         assert !hub.isConstant() || GraalOptions.ImmutableCode.getValue(graph.getOptions());         AddressNode mirrorAddress = createOffsetAddress(graph, hub, vmConfig.classMirrorOffset);         FloatingReadNode read = graph.unique(                         new FloatingReadNode(mirrorAddress, CLASS_MIRROR_LOCATION, null, vmConfig.classMirrorIsHandle ? StampFactory.forKind(target.wordJavaKind) : n.stamp(NodeView.DEFAULT),                                         null, BarrierType.NONE));         if (vmConfig.classMirrorIsHandle) {             AddressNode address = createOffsetAddress(graph, read, 0);             read = graph.unique(new FloatingReadNode(address, CLASS_MIRROR_HANDLE_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE));         }         n.replaceAtUsagesAndDelete(read);     }      private void lowerClassGetHubNode(ClassGetHubNode n, LoweringTool tool) {         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {             return;         }          StructuredGraph graph = n.graph();         assert !n.getValue().isConstant();         AddressNode address = createOffsetAddress(graph, n.getValue(), runtime.getVMConfig().klassOffset);         FloatingReadNode read = graph.unique(new FloatingReadNode(address, CLASS_KLASS_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE));         n.replaceAtUsagesAndDelete(read);     }      private void lowerInvoke(Invoke invoke, LoweringTool tool, StructuredGraph graph) {         if (invoke.callTarget() instanceof MethodCallTargetNode) {             MethodCallTargetNode callTarget = (MethodCallTargetNode) invoke.callTarget();             NodeInputList parameters = callTarget.arguments();             ValueNode receiver = parameters.size() &lt;= 0 ? null : parameters.get(0);             if (!callTarget.isStatic() &amp;&amp; receiver.stamp(NodeView.DEFAULT) instanceof ObjectStamp &amp;&amp; !StampTool.isPointerNonNull(receiver)) {                 ValueNode nonNullReceiver = createNullCheckedValue(receiver, invoke.asNode(), tool);                 parameters.set(0, nonNullReceiver);                 receiver = nonNullReceiver;             }             JavaType[] signature = callTarget.targetMethod().getSignature().toParameterTypes(callTarget.isStatic() ? null : callTarget.targetMethod().getDeclaringClass());              LoweredCallTargetNode loweredCallTarget = null;             OptionValues options = graph.getOptions();             if (InlineVTableStubs.getValue(options) &amp;&amp; callTarget.invokeKind().isIndirect() &amp;&amp; (AlwaysInlineVTableStubs.getValue(options) || invoke.isPolymorphic())) {                 HotSpotResolvedJavaMethod hsMethod = (HotSpotResolvedJavaMethod) callTarget.targetMethod();                 ResolvedJavaType receiverType = invoke.getReceiverType();                 if (hsMethod.isInVirtualMethodTable(receiverType)) {                     JavaKind wordKind = runtime.getTarget().wordJavaKind;                     ValueNode hub = createReadHub(graph, receiver, tool);                      ReadNode metaspaceMethod = createReadVirtualMethod(graph, hub, hsMethod, receiverType);                     // We use LocationNode.ANY_LOCATION for the reads that access the                     // compiled code entry as HotSpot does not guarantee they are final                     // values.                     int methodCompiledEntryOffset = runtime.getVMConfig().methodCompiledEntryOffset;                     AddressNode address = createOffsetAddress(graph, metaspaceMethod, methodCompiledEntryOffset);                     ReadNode compiledEntry = graph.add(new ReadNode(address, any(), StampFactory.forKind(wordKind), BarrierType.NONE));                      loweredCallTarget = graph.add(new HotSpotIndirectCallTargetNode(metaspaceMethod, compiledEntry, parameters.toArray(new ValueNode[parameters.size()]), callTarget.returnStamp(),                                     signature, callTarget.targetMethod(),                                     HotSpotCallingConventionType.JavaCall, callTarget.invokeKind()));                      graph.addBeforeFixed(invoke.asNode(), metaspaceMethod);                     graph.addAfterFixed(metaspaceMethod, compiledEntry);                 }             }              if (loweredCallTarget == null) {                 loweredCallTarget = graph.add(new HotSpotDirectCallTargetNode(parameters.toArray(new ValueNode[parameters.size()]), callTarget.returnStamp(),                                 signature, callTarget.targetMethod(),                                 HotSpotCallingConventionType.JavaCall,                                 callTarget.invokeKind()));             }             callTarget.replaceAndDelete(loweredCallTarget);         }     }      private CompressEncoding getOopEncoding() {         return runtime.getVMConfig().getOopEncoding();     }      @Override     protected Stamp loadCompressedStamp(ObjectStamp stamp) {         return HotSpotNarrowOopStamp.compressed(stamp, getOopEncoding());     }      @Override     protected ValueNode newCompressionNode(CompressionOp op, ValueNode value) {         return new HotSpotCompressionNode(op, value, getOopEncoding());     }      @Override     public ValueNode staticFieldBase(StructuredGraph graph, ResolvedJavaField f) {         HotSpotResolvedJavaField field = (HotSpotResolvedJavaField) f;         JavaConstant base = constantReflection.asJavaClass(field.getDeclaringClass());         return ConstantNode.forConstant(base, metaAccess, graph);     }      @Override     protected ValueNode createReadArrayComponentHub(StructuredGraph graph, ValueNode arrayHub, FixedNode anchor) {         /*          * Anchor the read of the element klass to the cfg, because it is only valid when arrayClass          * is an object class, which might not be the case in other parts of the compiled method.          */         AddressNode address = createOffsetAddress(graph, arrayHub, runtime.getVMConfig().arrayClassElementOffset);         return graph.unique(new FloatingReadNode(address, OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION, null, KlassPointerStamp.klassNonNull(), AbstractBeginNode.prevBegin(anchor)));     }      @Override     protected void lowerUnsafeLoadNode(RawLoadNode load, LoweringTool tool) {         StructuredGraph graph = load.graph();         if (!(load instanceof GuardedUnsafeLoadNode) &amp;&amp; !graph.getGuardsStage().allowsFloatingGuards() &amp;&amp; addReadBarrier(load)) {             unsafeLoadSnippets.lower(load, tool);         } else {             super.lowerUnsafeLoadNode(load, tool);         }     }      private void lowerLoadMethodNode(LoadMethodNode loadMethodNode) {         StructuredGraph graph = loadMethodNode.graph();         HotSpotResolvedJavaMethod method = (HotSpotResolvedJavaMethod) loadMethodNode.getMethod();         ReadNode metaspaceMethod = createReadVirtualMethod(graph, loadMethodNode.getHub(), method, loadMethodNode.getReceiverType());         graph.replaceFixed(loadMethodNode, metaspaceMethod);     }      private static void lowerGetClassNode(GetClassNode getClass, LoweringTool tool, StructuredGraph graph) {         StampProvider stampProvider = tool.getStampProvider();         LoadHubNode hub = graph.unique(new LoadHubNode(stampProvider, getClass.getObject()));         HubGetClassNode hubGetClass = graph.unique(new HubGetClassNode(tool.getMetaAccess(), hub));         getClass.replaceAtUsagesAndDelete(hubGetClass);         hub.lower(tool);         hubGetClass.lower(tool);     }      private void lowerStoreHubNode(StoreHubNode storeHub, StructuredGraph graph) {         WriteNode hub = createWriteHub(graph, storeHub.getObject(), storeHub.getValue());         graph.replaceFixed(storeHub, hub);     }      @Override     public BarrierType fieldInitializationBarrier(JavaKind entryKind) {         return (entryKind == JavaKind.Object &amp;&amp; !runtime.getVMConfig().useDeferredInitBarriers) ? BarrierType.IMPRECISE : BarrierType.NONE;     }      @Override     public BarrierType arrayInitializationBarrier(JavaKind entryKind) {         return (entryKind == JavaKind.Object &amp;&amp; !runtime.getVMConfig().useDeferredInitBarriers) ? BarrierType.PRECISE : BarrierType.NONE;     }      private void lowerOSRStartNode(OSRStartNode osrStart) {         StructuredGraph graph = osrStart.graph();         if (graph.getGuardsStage() == StructuredGraph.GuardsStage.FIXED_DEOPTS) {             StartNode newStart = graph.add(new StartNode());             ParameterNode buffer = graph.addWithoutUnique(new ParameterNode(0, StampPair.createSingle(StampFactory.forKind(runtime.getTarget().wordJavaKind))));             ForeignCallNode migrationEnd = graph.add(new ForeignCallNode(foreignCalls, OSR_MIGRATION_END, buffer));             migrationEnd.setStateAfter(osrStart.stateAfter());             newStart.setNext(migrationEnd);             FixedNode next = osrStart.next();             osrStart.setNext(null);             migrationEnd.setNext(next);             graph.setStart(newStart);              final int wordSize = target.wordSize;              // @formatter:off             // taken from c2 locals_addr = osr_buf + (max_locals-1)*wordSize)             // @formatter:on             int localsOffset = (graph.method().getMaxLocals() - 1) * wordSize;             for (OSRLocalNode osrLocal : graph.getNodes(OSRLocalNode.TYPE)) {                 int size = osrLocal.getStackKind().getSlotCount();                 int offset = localsOffset - (osrLocal.index() + size - 1) * wordSize;                 AddressNode address = createOffsetAddress(graph, buffer, offset);                 ReadNode load = graph.add(new ReadNode(address, any(), osrLocal.stamp(NodeView.DEFAULT), BarrierType.NONE));                 osrLocal.replaceAndDelete(load);                 graph.addBeforeFixed(migrationEnd, load);             }              // @formatter:off             // taken from c2 monitors_addr = osr_buf + (max_locals+mcnt*2-1)*wordSize);             // @formatter:on             final int lockCount = osrStart.stateAfter().locksSize();             final int locksOffset = (graph.method().getMaxLocals() + lockCount * 2 - 1) * wordSize;              // first initialize the lock slots for all enters with the displaced marks read from the             // buffer             for (OSRMonitorEnterNode osrMonitorEnter : graph.getNodes(OSRMonitorEnterNode.TYPE)) {                 MonitorIdNode monitorID = osrMonitorEnter.getMonitorId();                 OSRLockNode lock = (OSRLockNode) osrMonitorEnter.object();                 final int index = lock.index();                  final int offsetDisplacedHeader = locksOffset - ((index * 2) + 1) * wordSize;                 final int offsetLockObject = locksOffset - index * 2 * wordSize;                  // load the displaced mark from the osr buffer                 AddressNode addressDisplacedHeader = createOffsetAddress(graph, buffer, offsetDisplacedHeader);                 ReadNode loadDisplacedHeader = graph.add(new ReadNode(addressDisplacedHeader, any(), lock.stamp(NodeView.DEFAULT), BarrierType.NONE));                 graph.addBeforeFixed(migrationEnd, loadDisplacedHeader);                  // we need to initialize the stack slot for the lock                 BeginLockScopeNode beginLockScope = graph.add(new BeginLockScopeNode(lock.getStackKind(), monitorID.getLockDepth()));                 graph.addBeforeFixed(migrationEnd, beginLockScope);                  // write the displaced mark to the correct stack slot                 AddressNode addressDisplacedMark = createOffsetAddress(graph, beginLockScope, runtime.getVMConfig().basicLockDisplacedHeaderOffset);                 WriteNode writeStackSlot = graph.add(new WriteNode(addressDisplacedMark, DISPLACED_MARK_WORD_LOCATION, loadDisplacedHeader, BarrierType.NONE));                 graph.addBeforeFixed(migrationEnd, writeStackSlot);                  // load the lock object from the osr buffer                 AddressNode addressLockObject = createOffsetAddress(graph, buffer, offsetLockObject);                 ReadNode loadObject = graph.add(new ReadNode(addressLockObject, any(), lock.stamp(NodeView.DEFAULT), BarrierType.NONE));                 lock.replaceAndDelete(loadObject);                 graph.addBeforeFixed(migrationEnd, loadObject);             }              osrStart.replaceAtUsagesAndDelete(newStart);         }     }      static final class Exceptions {         protected static final EnumMap cachedExceptions;          static {             cachedExceptions = new EnumMap&lt;&gt;(BytecodeExceptionKind.class);             cachedExceptions.put(BytecodeExceptionKind.NULL_POINTER, clearStackTrace(new NullPointerException()));             cachedExceptions.put(BytecodeExceptionKind.OUT_OF_BOUNDS, clearStackTrace(new ArrayIndexOutOfBoundsException()));             cachedExceptions.put(BytecodeExceptionKind.CLASS_CAST, clearStackTrace(new ClassCastException()));             cachedExceptions.put(BytecodeExceptionKind.ARRAY_STORE, clearStackTrace(new ArrayStoreException()));             cachedExceptions.put(BytecodeExceptionKind.DIVISION_BY_ZERO, clearStackTrace(new ArithmeticException()));         }          private static RuntimeException clearStackTrace(RuntimeException ex) {             ex.setStackTrace(new StackTraceElement[0]);             return ex;         }     }      public static final class RuntimeCalls {         public static final EnumMap runtimeCalls;          static {             runtimeCalls = new EnumMap&lt;&gt;(BytecodeExceptionKind.class);             runtimeCalls.put(BytecodeExceptionKind.ARRAY_STORE, new ForeignCallDescriptor(&quot;createArrayStoreException&quot;, ArrayStoreException.class, Object.class));             runtimeCalls.put(BytecodeExceptionKind.CLASS_CAST, new ForeignCallDescriptor(&quot;createClassCastException&quot;, ClassCastException.class, Object.class, KlassPointer.class));             runtimeCalls.put(BytecodeExceptionKind.NULL_POINTER, new ForeignCallDescriptor(&quot;createNullPointerException&quot;, NullPointerException.class));             runtimeCalls.put(BytecodeExceptionKind.OUT_OF_BOUNDS, new ForeignCallDescriptor(&quot;createOutOfBoundsException&quot;, ArrayIndexOutOfBoundsException.class, int.class, int.class));             runtimeCalls.put(BytecodeExceptionKind.DIVISION_BY_ZERO, new ForeignCallDescriptor(&quot;createDivisionByZeroException&quot;, ArithmeticException.class));             runtimeCalls.put(BytecodeExceptionKind.INTEGER_EXACT_OVERFLOW, new ForeignCallDescriptor(&quot;createIntegerExactOverflowException&quot;, ArithmeticException.class));             runtimeCalls.put(BytecodeExceptionKind.LONG_EXACT_OVERFLOW, new ForeignCallDescriptor(&quot;createLongExactOverflowException&quot;, ArithmeticException.class));         }     }      private void throwCachedException(BytecodeExceptionNode node) {         if (IS_IN_NATIVE_IMAGE) {             throw new InternalError(&quot;Can't throw exception from SVM object&quot;);         }         Throwable exception = Exceptions.cachedExceptions.get(node.getExceptionKind());         assert exception != null;          StructuredGraph graph = node.graph();         FloatingNode exceptionNode = ConstantNode.forConstant(constantReflection.forObject(exception), metaAccess, graph);         graph.replaceFixedWithFloating(node, exceptionNode);     }      private void lowerBytecodeExceptionNode(BytecodeExceptionNode node) {         if (OmitHotExceptionStacktrace.getValue(node.getOptions())) {             throwCachedException(node);             return;         }          ForeignCallDescriptor descriptor = RuntimeCalls.runtimeCalls.get(node.getExceptionKind());         assert descriptor != null;          StructuredGraph graph = node.graph();         ForeignCallNode foreignCallNode = graph.add(new ForeignCallNode(foreignCalls, descriptor, node.stamp(NodeView.DEFAULT), node.getArguments()));         graph.replaceFixedWithFixed(node, foreignCallNode);     }      private boolean addReadBarrier(RawLoadNode load) {         if (runtime.getVMConfig().useG1GC &amp;&amp; load.graph().getGuardsStage() == StructuredGraph.GuardsStage.FIXED_DEOPTS &amp;&amp; load.object().getStackKind() == JavaKind.Object &amp;&amp;                         load.accessKind() == JavaKind.Object &amp;&amp; !StampTool.isPointerAlwaysNull(load.object())) {             ResolvedJavaType type = StampTool.typeOrNull(load.object());             if (type != null &amp;&amp; !type.isArray()) {                 return true;             }         }         return false;     }      private ReadNode createReadVirtualMethod(StructuredGraph graph, ValueNode hub, HotSpotResolvedJavaMethod method, ResolvedJavaType receiverType) {         return createReadVirtualMethod(graph, hub, method.vtableEntryOffset(receiverType));     }      private ReadNode createReadVirtualMethod(StructuredGraph graph, ValueNode hub, int vtableEntryOffset) {         assert vtableEntryOffset &gt; 0;         // We use LocationNode.ANY_LOCATION for the reads that access the vtable         // entry as HotSpot does not guarantee that this is a final value.         Stamp methodStamp = MethodPointerStamp.methodNonNull();         AddressNode address = createOffsetAddress(graph, hub, vtableEntryOffset);         ReadNode metaspaceMethod = graph.add(new ReadNode(address, any(), methodStamp, BarrierType.NONE));         return metaspaceMethod;     }      @Override     protected ValueNode createReadHub(StructuredGraph graph, ValueNode object, LoweringTool tool) {         if (tool.getLoweringStage() != LoweringTool.StandardLoweringStage.LOW_TIER) {             return graph.unique(new LoadHubNode(tool.getStampProvider(), object));         }         assert !object.isConstant() || object.isNullConstant();          KlassPointerStamp hubStamp = KlassPointerStamp.klassNonNull();         if (runtime.getVMConfig().useCompressedClassPointers) {             hubStamp = hubStamp.compressed(runtime.getVMConfig().getKlassEncoding());         }          AddressNode address = createOffsetAddress(graph, object, runtime.getVMConfig().hubOffset);         LocationIdentity hubLocation = runtime.getVMConfig().useCompressedClassPointers ? COMPRESSED_HUB_LOCATION : HUB_LOCATION;         FloatingReadNode memoryRead = graph.unique(new FloatingReadNode(address, hubLocation, null, hubStamp, null, BarrierType.NONE));         if (runtime.getVMConfig().useCompressedClassPointers) {             return HotSpotCompressionNode.uncompress(memoryRead, runtime.getVMConfig().getKlassEncoding());         } else {             return memoryRead;         }     }      private WriteNode createWriteHub(StructuredGraph graph, ValueNode object, ValueNode value) {         assert !object.isConstant() || object.asConstant().isDefaultForKind();          ValueNode writeValue = value;         if (runtime.getVMConfig().useCompressedClassPointers) {             writeValue = HotSpotCompressionNode.compress(value, runtime.getVMConfig().getKlassEncoding());         }          AddressNode address = createOffsetAddress(graph, object, runtime.getVMConfig().hubOffset);         return graph.add(new WriteNode(address, HUB_WRITE_LOCATION, writeValue, BarrierType.NONE));     }      @Override     protected BarrierType fieldLoadBarrierType(ResolvedJavaField f) {         HotSpotResolvedJavaField loadField = (HotSpotResolvedJavaField) f;         BarrierType barrierType = BarrierType.NONE;         if (runtime.getVMConfig().useG1GC &amp;&amp; loadField.getJavaKind() == JavaKind.Object &amp;&amp; metaAccess.lookupJavaType(Reference.class).equals(loadField.getDeclaringClass()) &amp;&amp;                         loadField.getName().equals(&quot;referent&quot;)) {             barrierType = BarrierType.PRECISE;         }         return barrierType;     }      @Override     public int fieldOffset(ResolvedJavaField f) {         return f.getOffset();     }      @Override     public int arrayLengthOffset() {         return runtime.getVMConfig().arrayOopDescLengthOffset();     }      @Override     protected final JavaKind getStorageKind(ResolvedJavaField field) {         return field.getJavaKind();     }      @Override     public ObjectCloneSnippets.Templates getObjectCloneSnippets() {         return objectCloneSnippets;     }      @Override     public ForeignCallSnippets.Templates getForeignCallSnippets() {         return foreignCallSnippets;     } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15001</td>
    <td align="left">https://github.com/oracle/graal/blob/4deb681aaaa79c248115037fc8e399c9876619fd/compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/DefaultHotSpotLoweringProvider.java/#L184-L809</td>
    <td align="right">1</td>
    <td align="right">5337</td>
    <td align="right">15001</td>
  </tr>
  <tr valign="top">
    <td align="right">5343</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [         &quot;Blob&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SuppressWarnings({&quot;cast&quot;, &quot;rawtypes&quot;, &quot;serial&quot;, &quot;unchecked&quot;, &quot;unused&quot;}) @javax.annotation.Generated(value = &quot;Autogenerated by Thrift Compiler (0.12.0)&quot;) public class Assignment implements org.apache.storm.thrift.TBase, java.io.Serializable, Cloneable, Comparable {   private static final org.apache.storm.thrift.protocol.TStruct STRUCT_DESC = new org.apache.storm.thrift.protocol.TStruct(&quot;Assignment&quot;);    private static final org.apache.storm.thrift.protocol.TField MASTER_CODE_DIR_FIELD_DESC = new org.apache.storm.thrift.protocol.TField(&quot;master_code_dir&quot;, org.apache.storm.thrift.protocol.TType.STRING, (short)1);   private static final org.apache.storm.thrift.protocol.TField NODE_HOST_FIELD_DESC = new org.apache.storm.thrift.protocol.TField(&quot;node_host&quot;, org.apache.storm.thrift.protocol.TType.MAP, (short)2);   private static final org.apache.storm.thrift.protocol.TField EXECUTOR_NODE_PORT_FIELD_DESC = new org.apache.storm.thrift.protocol.TField(&quot;executor_node_port&quot;, org.apache.storm.thrift.protocol.TType.MAP, (short)3);   private static final org.apache.storm.thrift.protocol.TField EXECUTOR_START_TIME_SECS_FIELD_DESC = new org.apache.storm.thrift.protocol.TField(&quot;executor_start_time_secs&quot;, org.apache.storm.thrift.protocol.TType.MAP, (short)4);   private static final org.apache.storm.thrift.protocol.TField WORKER_RESOURCES_FIELD_DESC = new org.apache.storm.thrift.protocol.TField(&quot;worker_resources&quot;, org.apache.storm.thrift.protocol.TType.MAP, (short)5);   private static final org.apache.storm.thrift.protocol.TField TOTAL_SHARED_OFF_HEAP_FIELD_DESC = new org.apache.storm.thrift.protocol.TField(&quot;total_shared_off_heap&quot;, org.apache.storm.thrift.protocol.TType.MAP, (short)6);   private static final org.apache.storm.thrift.protocol.TField OWNER_FIELD_DESC = new org.apache.storm.thrift.protocol.TField(&quot;owner&quot;, org.apache.storm.thrift.protocol.TType.STRING, (short)7);    private static final org.apache.storm.thrift.scheme.SchemeFactory STANDARD_SCHEME_FACTORY = new AssignmentStandardSchemeFactory();   private static final org.apache.storm.thrift.scheme.SchemeFactory TUPLE_SCHEME_FACTORY = new AssignmentTupleSchemeFactory();    private @org.apache.storm.thrift.annotation.Nullable java.lang.String master_code_dir; // required   private @org.apache.storm.thrift.annotation.Nullable java.util.Map node_host; // optional   private @org.apache.storm.thrift.annotation.Nullable java.util.Map,NodeInfo&gt; executor_node_port; // optional   private @org.apache.storm.thrift.annotation.Nullable java.util.Map,java.lang.Long&gt; executor_start_time_secs; // optional   private @org.apache.storm.thrift.annotation.Nullable java.util.Map worker_resources; // optional   private @org.apache.storm.thrift.annotation.Nullable java.util.Map total_shared_off_heap; // optional   private @org.apache.storm.thrift.annotation.Nullable java.lang.String owner; // optional    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */   public enum _Fields implements org.apache.storm.thrift.TFieldIdEnum {     MASTER_CODE_DIR((short)1, &quot;master_code_dir&quot;),     NODE_HOST((short)2, &quot;node_host&quot;),     EXECUTOR_NODE_PORT((short)3, &quot;executor_node_port&quot;),     EXECUTOR_START_TIME_SECS((short)4, &quot;executor_start_time_secs&quot;),     WORKER_RESOURCES((short)5, &quot;worker_resources&quot;),     TOTAL_SHARED_OFF_HEAP((short)6, &quot;total_shared_off_heap&quot;),     OWNER((short)7, &quot;owner&quot;);      private static final java.util.Map byName = new java.util.HashMap();      static {       for (_Fields field : java.util.EnumSet.allOf(_Fields.class)) {         byName.put(field.getFieldName(), field);       }     }      /**      * Find the _Fields constant that matches fieldId, or null if its not found.      */     @org.apache.storm.thrift.annotation.Nullable     public static _Fields findByThriftId(int fieldId) {       switch(fieldId) {         case 1: // MASTER_CODE_DIR           return MASTER_CODE_DIR;         case 2: // NODE_HOST           return NODE_HOST;         case 3: // EXECUTOR_NODE_PORT           return EXECUTOR_NODE_PORT;         case 4: // EXECUTOR_START_TIME_SECS           return EXECUTOR_START_TIME_SECS;         case 5: // WORKER_RESOURCES           return WORKER_RESOURCES;         case 6: // TOTAL_SHARED_OFF_HEAP           return TOTAL_SHARED_OFF_HEAP;         case 7: // OWNER           return OWNER;         default:           return null;       }     }      /**      * Find the _Fields constant that matches fieldId, throwing an exception      * if it is not found.      */     public static _Fields findByThriftIdOrThrow(int fieldId) {       _Fields fields = findByThriftId(fieldId);       if (fields == null) throw new java.lang.IllegalArgumentException(&quot;Field &quot; + fieldId + &quot; doesn't exist!&quot;);       return fields;     }      /**      * Find the _Fields constant that matches name, or null if its not found.      */     @org.apache.storm.thrift.annotation.Nullable     public static _Fields findByName(java.lang.String name) {       return byName.get(name);     }      private final short _thriftId;     private final java.lang.String _fieldName;      _Fields(short thriftId, java.lang.String fieldName) {       _thriftId = thriftId;       _fieldName = fieldName;     }      public short getThriftFieldId() {       return _thriftId;     }      public java.lang.String getFieldName() {       return _fieldName;     }   }    // isset id assignments   private static final _Fields optionals[] = {_Fields.NODE_HOST,_Fields.EXECUTOR_NODE_PORT,_Fields.EXECUTOR_START_TIME_SECS,_Fields.WORKER_RESOURCES,_Fields.TOTAL_SHARED_OFF_HEAP,_Fields.OWNER};   public static final java.util.Map&lt;_Fields, org.apache.storm.thrift.meta_data.FieldMetaData&gt; metaDataMap;   static {     java.util.Map&lt;_Fields, org.apache.storm.thrift.meta_data.FieldMetaData&gt; tmpMap = new java.util.EnumMap&lt;_Fields, org.apache.storm.thrift.meta_data.FieldMetaData&gt;(_Fields.class);     tmpMap.put(_Fields.MASTER_CODE_DIR, new org.apache.storm.thrift.meta_data.FieldMetaData(&quot;master_code_dir&quot;, org.apache.storm.thrift.TFieldRequirementType.REQUIRED,          new org.apache.storm.thrift.meta_data.FieldValueMetaData(org.apache.storm.thrift.protocol.TType.STRING)));     tmpMap.put(_Fields.NODE_HOST, new org.apache.storm.thrift.meta_data.FieldMetaData(&quot;node_host&quot;, org.apache.storm.thrift.TFieldRequirementType.OPTIONAL,          new org.apache.storm.thrift.meta_data.MapMetaData(org.apache.storm.thrift.protocol.TType.MAP,              new org.apache.storm.thrift.meta_data.FieldValueMetaData(org.apache.storm.thrift.protocol.TType.STRING),              new org.apache.storm.thrift.meta_data.FieldValueMetaData(org.apache.storm.thrift.protocol.TType.STRING))));     tmpMap.put(_Fields.EXECUTOR_NODE_PORT, new org.apache.storm.thrift.meta_data.FieldMetaData(&quot;executor_node_port&quot;, org.apache.storm.thrift.TFieldRequirementType.OPTIONAL,          new org.apache.storm.thrift.meta_data.MapMetaData(org.apache.storm.thrift.protocol.TType.MAP,              new org.apache.storm.thrift.meta_data.ListMetaData(org.apache.storm.thrift.protocol.TType.LIST,                  new org.apache.storm.thrift.meta_data.FieldValueMetaData(org.apache.storm.thrift.protocol.TType.I64)),              new org.apache.storm.thrift.meta_data.StructMetaData(org.apache.storm.thrift.protocol.TType.STRUCT, NodeInfo.class))));     tmpMap.put(_Fields.EXECUTOR_START_TIME_SECS, new org.apache.storm.thrift.meta_data.FieldMetaData(&quot;executor_start_time_secs&quot;, org.apache.storm.thrift.TFieldRequirementType.OPTIONAL,          new org.apache.storm.thrift.meta_data.MapMetaData(org.apache.storm.thrift.protocol.TType.MAP,              new org.apache.storm.thrift.meta_data.ListMetaData(org.apache.storm.thrift.protocol.TType.LIST,                  new org.apache.storm.thrift.meta_data.FieldValueMetaData(org.apache.storm.thrift.protocol.TType.I64)),              new org.apache.storm.thrift.meta_data.FieldValueMetaData(org.apache.storm.thrift.protocol.TType.I64))));     tmpMap.put(_Fields.WORKER_RESOURCES, new org.apache.storm.thrift.meta_data.FieldMetaData(&quot;worker_resources&quot;, org.apache.storm.thrift.TFieldRequirementType.OPTIONAL,          new org.apache.storm.thrift.meta_data.MapMetaData(org.apache.storm.thrift.protocol.TType.MAP,              new org.apache.storm.thrift.meta_data.StructMetaData(org.apache.storm.thrift.protocol.TType.STRUCT, NodeInfo.class),              new org.apache.storm.thrift.meta_data.StructMetaData(org.apache.storm.thrift.protocol.TType.STRUCT, WorkerResources.class))));     tmpMap.put(_Fields.TOTAL_SHARED_OFF_HEAP, new org.apache.storm.thrift.meta_data.FieldMetaData(&quot;total_shared_off_heap&quot;, org.apache.storm.thrift.TFieldRequirementType.OPTIONAL,          new org.apache.storm.thrift.meta_data.MapMetaData(org.apache.storm.thrift.protocol.TType.MAP,              new org.apache.storm.thrift.meta_data.FieldValueMetaData(org.apache.storm.thrift.protocol.TType.STRING),              new org.apache.storm.thrift.meta_data.FieldValueMetaData(org.apache.storm.thrift.protocol.TType.DOUBLE))));     tmpMap.put(_Fields.OWNER, new org.apache.storm.thrift.meta_data.FieldMetaData(&quot;owner&quot;, org.apache.storm.thrift.TFieldRequirementType.OPTIONAL,          new org.apache.storm.thrift.meta_data.FieldValueMetaData(org.apache.storm.thrift.protocol.TType.STRING)));     metaDataMap = java.util.Collections.unmodifiableMap(tmpMap);     org.apache.storm.thrift.meta_data.FieldMetaData.addStructMetaDataMap(Assignment.class, metaDataMap);   }    public Assignment() {     this.node_host = new java.util.HashMap();      this.executor_node_port = new java.util.HashMap,NodeInfo&gt;();      this.executor_start_time_secs = new java.util.HashMap,java.lang.Long&gt;();      this.worker_resources = new java.util.HashMap();      this.total_shared_off_heap = new java.util.HashMap();    }    public Assignment(     java.lang.String master_code_dir)   {     this();     this.master_code_dir = master_code_dir;   }    /**    * Performs a deep copy on other.    */   public Assignment(Assignment other) {     if (other.is_set_master_code_dir()) {       this.master_code_dir = other.master_code_dir;     }     if (other.is_set_node_host()) {       java.util.Map __this__node_host = new java.util.HashMap(other.node_host);       this.node_host = __this__node_host;     }     if (other.is_set_executor_node_port()) {       java.util.Map,NodeInfo&gt; __this__executor_node_port = new java.util.HashMap,NodeInfo&gt;(other.executor_node_port.size());       for (java.util.Map.Entry, NodeInfo&gt; other_element : other.executor_node_port.entrySet()) {          java.util.List other_element_key = other_element.getKey();         NodeInfo other_element_value = other_element.getValue();          java.util.List __this__executor_node_port_copy_key = new java.util.ArrayList(other_element_key);          NodeInfo __this__executor_node_port_copy_value = new NodeInfo(other_element_value);          __this__executor_node_port.put(__this__executor_node_port_copy_key, __this__executor_node_port_copy_value);       }       this.executor_node_port = __this__executor_node_port;     }     if (other.is_set_executor_start_time_secs()) {       java.util.Map,java.lang.Long&gt; __this__executor_start_time_secs = new java.util.HashMap,java.lang.Long&gt;(other.executor_start_time_secs.size());       for (java.util.Map.Entry, java.lang.Long&gt; other_element : other.executor_start_time_secs.entrySet()) {          java.util.List other_element_key = other_element.getKey();         java.lang.Long other_element_value = other_element.getValue();          java.util.List __this__executor_start_time_secs_copy_key = new java.util.ArrayList(other_element_key);          java.lang.Long __this__executor_start_time_secs_copy_value = other_element_value;          __this__executor_start_time_secs.put(__this__executor_start_time_secs_copy_key, __this__executor_start_time_secs_copy_value);       }       this.executor_start_time_secs = __this__executor_start_time_secs;     }     if (other.is_set_worker_resources()) {       java.util.Map __this__worker_resources = new java.util.HashMap(other.worker_resources.size());       for (java.util.Map.Entry other_element : other.worker_resources.entrySet()) {          NodeInfo other_element_key = other_element.getKey();         WorkerResources other_element_value = other_element.getValue();          NodeInfo __this__worker_resources_copy_key = new NodeInfo(other_element_key);          WorkerResources __this__worker_resources_copy_value = new WorkerResources(other_element_value);          __this__worker_resources.put(__this__worker_resources_copy_key, __this__worker_resources_copy_value);       }       this.worker_resources = __this__worker_resources;     }     if (other.is_set_total_shared_off_heap()) {       java.util.Map __this__total_shared_off_heap = new java.util.HashMap(other.total_shared_off_heap);       this.total_shared_off_heap = __this__total_shared_off_heap;     }     if (other.is_set_owner()) {       this.owner = other.owner;     }   }    public Assignment deepCopy() {     return new Assignment(this);   }    @Override   public void clear() {     this.master_code_dir = null;     this.node_host = new java.util.HashMap();      this.executor_node_port = new java.util.HashMap,NodeInfo&gt;();      this.executor_start_time_secs = new java.util.HashMap,java.lang.Long&gt;();      this.worker_resources = new java.util.HashMap();      this.total_shared_off_heap = new java.util.HashMap();      this.owner = null;   }    @org.apache.storm.thrift.annotation.Nullable   public java.lang.String get_master_code_dir() {     return this.master_code_dir;   }    public void set_master_code_dir(@org.apache.storm.thrift.annotation.Nullable java.lang.String master_code_dir) {     this.master_code_dir = master_code_dir;   }    public void unset_master_code_dir() {     this.master_code_dir = null;   }    /** Returns true if field master_code_dir is set (has been assigned a value) and false otherwise */   public boolean is_set_master_code_dir() {     return this.master_code_dir != null;   }    public void set_master_code_dir_isSet(boolean value) {     if (!value) {       this.master_code_dir = null;     }   }    public int get_node_host_size() {     return (this.node_host == null) ? 0 : this.node_host.size();   }    public void put_to_node_host(java.lang.String key, java.lang.String val) {     if (this.node_host == null) {       this.node_host = new java.util.HashMap();     }     this.node_host.put(key, val);   }    @org.apache.storm.thrift.annotation.Nullable   public java.util.Map get_node_host() {     return this.node_host;   }    public void set_node_host(@org.apache.storm.thrift.annotation.Nullable java.util.Map node_host) {     this.node_host = node_host;   }    public void unset_node_host() {     this.node_host = null;   }    /** Returns true if field node_host is set (has been assigned a value) and false otherwise */   public boolean is_set_node_host() {     return this.node_host != null;   }    public void set_node_host_isSet(boolean value) {     if (!value) {       this.node_host = null;     }   }    public int get_executor_node_port_size() {     return (this.executor_node_port == null) ? 0 : this.executor_node_port.size();   }    public void put_to_executor_node_port(java.util.List key, NodeInfo val) {     if (this.executor_node_port == null) {       this.executor_node_port = new java.util.HashMap,NodeInfo&gt;();     }     this.executor_node_port.put(key, val);   }    @org.apache.storm.thrift.annotation.Nullable   public java.util.Map,NodeInfo&gt; get_executor_node_port() {     return this.executor_node_port;   }    public void set_executor_node_port(@org.apache.storm.thrift.annotation.Nullable java.util.Map,NodeInfo&gt; executor_node_port) {     this.executor_node_port = executor_node_port;   }    public void unset_executor_node_port() {     this.executor_node_port = null;   }    /** Returns true if field executor_node_port is set (has been assigned a value) and false otherwise */   public boolean is_set_executor_node_port() {     return this.executor_node_port != null;   }    public void set_executor_node_port_isSet(boolean value) {     if (!value) {       this.executor_node_port = null;     }   }    public int get_executor_start_time_secs_size() {     return (this.executor_start_time_secs == null) ? 0 : this.executor_start_time_secs.size();   }    public void put_to_executor_start_time_secs(java.util.List key, long val) {     if (this.executor_start_time_secs == null) {       this.executor_start_time_secs = new java.util.HashMap,java.lang.Long&gt;();     }     this.executor_start_time_secs.put(key, val);   }    @org.apache.storm.thrift.annotation.Nullable   public java.util.Map,java.lang.Long&gt; get_executor_start_time_secs() {     return this.executor_start_time_secs;   }    public void set_executor_start_time_secs(@org.apache.storm.thrift.annotation.Nullable java.util.Map,java.lang.Long&gt; executor_start_time_secs) {     this.executor_start_time_secs = executor_start_time_secs;   }    public void unset_executor_start_time_secs() {     this.executor_start_time_secs = null;   }    /** Returns true if field executor_start_time_secs is set (has been assigned a value) and false otherwise */   public boolean is_set_executor_start_time_secs() {     return this.executor_start_time_secs != null;   }    public void set_executor_start_time_secs_isSet(boolean value) {     if (!value) {       this.executor_start_time_secs = null;     }   }    public int get_worker_resources_size() {     return (this.worker_resources == null) ? 0 : this.worker_resources.size();   }    public void put_to_worker_resources(NodeInfo key, WorkerResources val) {     if (this.worker_resources == null) {       this.worker_resources = new java.util.HashMap();     }     this.worker_resources.put(key, val);   }    @org.apache.storm.thrift.annotation.Nullable   public java.util.Map get_worker_resources() {     return this.worker_resources;   }    public void set_worker_resources(@org.apache.storm.thrift.annotation.Nullable java.util.Map worker_resources) {     this.worker_resources = worker_resources;   }    public void unset_worker_resources() {     this.worker_resources = null;   }    /** Returns true if field worker_resources is set (has been assigned a value) and false otherwise */   public boolean is_set_worker_resources() {     return this.worker_resources != null;   }    public void set_worker_resources_isSet(boolean value) {     if (!value) {       this.worker_resources = null;     }   }    public int get_total_shared_off_heap_size() {     return (this.total_shared_off_heap == null) ? 0 : this.total_shared_off_heap.size();   }    public void put_to_total_shared_off_heap(java.lang.String key, double val) {     if (this.total_shared_off_heap == null) {       this.total_shared_off_heap = new java.util.HashMap();     }     this.total_shared_off_heap.put(key, val);   }    @org.apache.storm.thrift.annotation.Nullable   public java.util.Map get_total_shared_off_heap() {     return this.total_shared_off_heap;   }    public void set_total_shared_off_heap(@org.apache.storm.thrift.annotation.Nullable java.util.Map total_shared_off_heap) {     this.total_shared_off_heap = total_shared_off_heap;   }    public void unset_total_shared_off_heap() {     this.total_shared_off_heap = null;   }    /** Returns true if field total_shared_off_heap is set (has been assigned a value) and false otherwise */   public boolean is_set_total_shared_off_heap() {     return this.total_shared_off_heap != null;   }    public void set_total_shared_off_heap_isSet(boolean value) {     if (!value) {       this.total_shared_off_heap = null;     }   }    @org.apache.storm.thrift.annotation.Nullable   public java.lang.String get_owner() {     return this.owner;   }    public void set_owner(@org.apache.storm.thrift.annotation.Nullable java.lang.String owner) {     this.owner = owner;   }    public void unset_owner() {     this.owner = null;   }    /** Returns true if field owner is set (has been assigned a value) and false otherwise */   public boolean is_set_owner() {     return this.owner != null;   }    public void set_owner_isSet(boolean value) {     if (!value) {       this.owner = null;     }   }    public void setFieldValue(_Fields field, @org.apache.storm.thrift.annotation.Nullable java.lang.Object value) {     switch (field) {     case MASTER_CODE_DIR:       if (value == null) {         unset_master_code_dir();       } else {         set_master_code_dir((java.lang.String)value);       }       break;      case NODE_HOST:       if (value == null) {         unset_node_host();       } else {         set_node_host((java.util.Map)value);       }       break;      case EXECUTOR_NODE_PORT:       if (value == null) {         unset_executor_node_port();       } else {         set_executor_node_port((java.util.Map,NodeInfo&gt;)value);       }       break;      case EXECUTOR_START_TIME_SECS:       if (value == null) {         unset_executor_start_time_secs();       } else {         set_executor_start_time_secs((java.util.Map,java.lang.Long&gt;)value);       }       break;      case WORKER_RESOURCES:       if (value == null) {         unset_worker_resources();       } else {         set_worker_resources((java.util.Map)value);       }       break;      case TOTAL_SHARED_OFF_HEAP:       if (value == null) {         unset_total_shared_off_heap();       } else {         set_total_shared_off_heap((java.util.Map)value);       }       break;      case OWNER:       if (value == null) {         unset_owner();       } else {         set_owner((java.lang.String)value);       }       break;      }   }    @org.apache.storm.thrift.annotation.Nullable   public java.lang.Object getFieldValue(_Fields field) {     switch (field) {     case MASTER_CODE_DIR:       return get_master_code_dir();      case NODE_HOST:       return get_node_host();      case EXECUTOR_NODE_PORT:       return get_executor_node_port();      case EXECUTOR_START_TIME_SECS:       return get_executor_start_time_secs();      case WORKER_RESOURCES:       return get_worker_resources();      case TOTAL_SHARED_OFF_HEAP:       return get_total_shared_off_heap();      case OWNER:       return get_owner();      }     throw new java.lang.IllegalStateException();   }    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */   public boolean isSet(_Fields field) {     if (field == null) {       throw new java.lang.IllegalArgumentException();     }      switch (field) {     case MASTER_CODE_DIR:       return is_set_master_code_dir();     case NODE_HOST:       return is_set_node_host();     case EXECUTOR_NODE_PORT:       return is_set_executor_node_port();     case EXECUTOR_START_TIME_SECS:       return is_set_executor_start_time_secs();     case WORKER_RESOURCES:       return is_set_worker_resources();     case TOTAL_SHARED_OFF_HEAP:       return is_set_total_shared_off_heap();     case OWNER:       return is_set_owner();     }     throw new java.lang.IllegalStateException();   }    @Override   public boolean equals(java.lang.Object that) {     if (that == null)       return false;     if (that instanceof Assignment)       return this.equals((Assignment)that);     return false;   }    public boolean equals(Assignment that) {     if (that == null)       return false;     if (this == that)       return true;      boolean this_present_master_code_dir = true &amp;&amp; this.is_set_master_code_dir();     boolean that_present_master_code_dir = true &amp;&amp; that.is_set_master_code_dir();     if (this_present_master_code_dir || that_present_master_code_dir) {       if (!(this_present_master_code_dir &amp;&amp; that_present_master_code_dir))         return false;       if (!this.master_code_dir.equals(that.master_code_dir))         return false;     }      boolean this_present_node_host = true &amp;&amp; this.is_set_node_host();     boolean that_present_node_host = true &amp;&amp; that.is_set_node_host();     if (this_present_node_host || that_present_node_host) {       if (!(this_present_node_host &amp;&amp; that_present_node_host))         return false;       if (!this.node_host.equals(that.node_host))         return false;     }      boolean this_present_executor_node_port = true &amp;&amp; this.is_set_executor_node_port();     boolean that_present_executor_node_port = true &amp;&amp; that.is_set_executor_node_port();     if (this_present_executor_node_port || that_present_executor_node_port) {       if (!(this_present_executor_node_port &amp;&amp; that_present_executor_node_port))         return false;       if (!this.executor_node_port.equals(that.executor_node_port))         return false;     }      boolean this_present_executor_start_time_secs = true &amp;&amp; this.is_set_executor_start_time_secs();     boolean that_present_executor_start_time_secs = true &amp;&amp; that.is_set_executor_start_time_secs();     if (this_present_executor_start_time_secs || that_present_executor_start_time_secs) {       if (!(this_present_executor_start_time_secs &amp;&amp; that_present_executor_start_time_secs))         return false;       if (!this.executor_start_time_secs.equals(that.executor_start_time_secs))         return false;     }      boolean this_present_worker_resources = true &amp;&amp; this.is_set_worker_resources();     boolean that_present_worker_resources = true &amp;&amp; that.is_set_worker_resources();     if (this_present_worker_resources || that_present_worker_resources) {       if (!(this_present_worker_resources &amp;&amp; that_present_worker_resources))         return false;       if (!this.worker_resources.equals(that.worker_resources))         return false;     }      boolean this_present_total_shared_off_heap = true &amp;&amp; this.is_set_total_shared_off_heap();     boolean that_present_total_shared_off_heap = true &amp;&amp; that.is_set_total_shared_off_heap();     if (this_present_total_shared_off_heap || that_present_total_shared_off_heap) {       if (!(this_present_total_shared_off_heap &amp;&amp; that_present_total_shared_off_heap))         return false;       if (!this.total_shared_off_heap.equals(that.total_shared_off_heap))         return false;     }      boolean this_present_owner = true &amp;&amp; this.is_set_owner();     boolean that_present_owner = true &amp;&amp; that.is_set_owner();     if (this_present_owner || that_present_owner) {       if (!(this_present_owner &amp;&amp; that_present_owner))         return false;       if (!this.owner.equals(that.owner))         return false;     }      return true;   }    @Override   public int hashCode() {     int hashCode = 1;      hashCode = hashCode * 8191 + ((is_set_master_code_dir()) ? 131071 : 524287);     if (is_set_master_code_dir())       hashCode = hashCode * 8191 + master_code_dir.hashCode();      hashCode = hashCode * 8191 + ((is_set_node_host()) ? 131071 : 524287);     if (is_set_node_host())       hashCode = hashCode * 8191 + node_host.hashCode();      hashCode = hashCode * 8191 + ((is_set_executor_node_port()) ? 131071 : 524287);     if (is_set_executor_node_port())       hashCode = hashCode * 8191 + executor_node_port.hashCode();      hashCode = hashCode * 8191 + ((is_set_executor_start_time_secs()) ? 131071 : 524287);     if (is_set_executor_start_time_secs())       hashCode = hashCode * 8191 + executor_start_time_secs.hashCode();      hashCode = hashCode * 8191 + ((is_set_worker_resources()) ? 131071 : 524287);     if (is_set_worker_resources())       hashCode = hashCode * 8191 + worker_resources.hashCode();      hashCode = hashCode * 8191 + ((is_set_total_shared_off_heap()) ? 131071 : 524287);     if (is_set_total_shared_off_heap())       hashCode = hashCode * 8191 + total_shared_off_heap.hashCode();      hashCode = hashCode * 8191 + ((is_set_owner()) ? 131071 : 524287);     if (is_set_owner())       hashCode = hashCode * 8191 + owner.hashCode();      return hashCode;   }    @Override   public int compareTo(Assignment other) {     if (!getClass().equals(other.getClass())) {       return getClass().getName().compareTo(other.getClass().getName());     }      int lastComparison = 0;      lastComparison = java.lang.Boolean.valueOf(is_set_master_code_dir()).compareTo(other.is_set_master_code_dir());     if (lastComparison != 0) {       return lastComparison;     }     if (is_set_master_code_dir()) {       lastComparison = org.apache.storm.thrift.TBaseHelper.compareTo(this.master_code_dir, other.master_code_dir);       if (lastComparison != 0) {         return lastComparison;       }     }     lastComparison = java.lang.Boolean.valueOf(is_set_node_host()).compareTo(other.is_set_node_host());     if (lastComparison != 0) {       return lastComparison;     }     if (is_set_node_host()) {       lastComparison = org.apache.storm.thrift.TBaseHelper.compareTo(this.node_host, other.node_host);       if (lastComparison != 0) {         return lastComparison;       }     }     lastComparison = java.lang.Boolean.valueOf(is_set_executor_node_port()).compareTo(other.is_set_executor_node_port());     if (lastComparison != 0) {       return lastComparison;     }     if (is_set_executor_node_port()) {       lastComparison = org.apache.storm.thrift.TBaseHelper.compareTo(this.executor_node_port, other.executor_node_port);       if (lastComparison != 0) {         return lastComparison;       }     }     lastComparison = java.lang.Boolean.valueOf(is_set_executor_start_time_secs()).compareTo(other.is_set_executor_start_time_secs());     if (lastComparison != 0) {       return lastComparison;     }     if (is_set_executor_start_time_secs()) {       lastComparison = org.apache.storm.thrift.TBaseHelper.compareTo(this.executor_start_time_secs, other.executor_start_time_secs);       if (lastComparison != 0) {         return lastComparison;       }     }     lastComparison = java.lang.Boolean.valueOf(is_set_worker_resources()).compareTo(other.is_set_worker_resources());     if (lastComparison != 0) {       return lastComparison;     }     if (is_set_worker_resources()) {       lastComparison = org.apache.storm.thrift.TBaseHelper.compareTo(this.worker_resources, other.worker_resources);       if (lastComparison != 0) {         return lastComparison;       }     }     lastComparison = java.lang.Boolean.valueOf(is_set_total_shared_off_heap()).compareTo(other.is_set_total_shared_off_heap());     if (lastComparison != 0) {       return lastComparison;     }     if (is_set_total_shared_off_heap()) {       lastComparison = org.apache.storm.thrift.TBaseHelper.compareTo(this.total_shared_off_heap, other.total_shared_off_heap);       if (lastComparison != 0) {         return lastComparison;       }     }     lastComparison = java.lang.Boolean.valueOf(is_set_owner()).compareTo(other.is_set_owner());     if (lastComparison != 0) {       return lastComparison;     }     if (is_set_owner()) {       lastComparison = org.apache.storm.thrift.TBaseHelper.compareTo(this.owner, other.owner);       if (lastComparison != 0) {         return lastComparison;       }     }     return 0;   }    @org.apache.storm.thrift.annotation.Nullable   public _Fields fieldForId(int fieldId) {     return _Fields.findByThriftId(fieldId);   }    public void read(org.apache.storm.thrift.protocol.TProtocol iprot) throws org.apache.storm.thrift.TException {     scheme(iprot).read(iprot, this);   }    public void write(org.apache.storm.thrift.protocol.TProtocol oprot) throws org.apache.storm.thrift.TException {     scheme(oprot).write(oprot, this);   }    @Override   public java.lang.String toString() {     java.lang.StringBuilder sb = new java.lang.StringBuilder(&quot;Assignment(&quot;);     boolean first = true;      sb.append(&quot;master_code_dir:&quot;);     if (this.master_code_dir == null) {       sb.append(&quot;null&quot;);     } else {       sb.append(this.master_code_dir);     }     first = false;     if (is_set_node_host()) {       if (!first) sb.append(&quot;, &quot;);       sb.append(&quot;node_host:&quot;);       if (this.node_host == null) {         sb.append(&quot;null&quot;);       } else {         sb.append(this.node_host);       }       first = false;     }     if (is_set_executor_node_port()) {       if (!first) sb.append(&quot;, &quot;);       sb.append(&quot;executor_node_port:&quot;);       if (this.executor_node_port == null) {         sb.append(&quot;null&quot;);       } else {         sb.append(this.executor_node_port);       }       first = false;     }     if (is_set_executor_start_time_secs()) {       if (!first) sb.append(&quot;, &quot;);       sb.append(&quot;executor_start_time_secs:&quot;);       if (this.executor_start_time_secs == null) {         sb.append(&quot;null&quot;);       } else {         sb.append(this.executor_start_time_secs);       }       first = false;     }     if (is_set_worker_resources()) {       if (!first) sb.append(&quot;, &quot;);       sb.append(&quot;worker_resources:&quot;);       if (this.worker_resources == null) {         sb.append(&quot;null&quot;);       } else {         sb.append(this.worker_resources);       }       first = false;     }     if (is_set_total_shared_off_heap()) {       if (!first) sb.append(&quot;, &quot;);       sb.append(&quot;total_shared_off_heap:&quot;);       if (this.total_shared_off_heap == null) {         sb.append(&quot;null&quot;);       } else {         sb.append(this.total_shared_off_heap);       }       first = false;     }     if (is_set_owner()) {       if (!first) sb.append(&quot;, &quot;);       sb.append(&quot;owner:&quot;);       if (this.owner == null) {         sb.append(&quot;null&quot;);       } else {         sb.append(this.owner);       }       first = false;     }     sb.append(&quot;)&quot;);     return sb.toString();   }    public void validate() throws org.apache.storm.thrift.TException {     // check for required fields     if (!is_set_master_code_dir()) {       throw new org.apache.storm.thrift.protocol.TProtocolException(&quot;Required field 'master_code_dir' is unset! Struct:&quot; + toString());     }      // check for sub-struct validity   }    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {     try {       write(new org.apache.storm.thrift.protocol.TCompactProtocol(new org.apache.storm.thrift.transport.TIOStreamTransport(out)));     } catch (org.apache.storm.thrift.TException te) {       throw new java.io.IOException(te);     }   }    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException {     try {       read(new org.apache.storm.thrift.protocol.TCompactProtocol(new org.apache.storm.thrift.transport.TIOStreamTransport(in)));     } catch (org.apache.storm.thrift.TException te) {       throw new java.io.IOException(te);     }   }    private static class AssignmentStandardSchemeFactory implements org.apache.storm.thrift.scheme.SchemeFactory {     public AssignmentStandardScheme getScheme() {       return new AssignmentStandardScheme();     }   }    private static class AssignmentStandardScheme extends org.apache.storm.thrift.scheme.StandardScheme {      public void read(org.apache.storm.thrift.protocol.TProtocol iprot, Assignment struct) throws org.apache.storm.thrift.TException {       org.apache.storm.thrift.protocol.TField schemeField;       iprot.readStructBegin();       while (true)       {         schemeField = iprot.readFieldBegin();         if (schemeField.type == org.apache.storm.thrift.protocol.TType.STOP) {            break;         }         switch (schemeField.id) {           case 1: // MASTER_CODE_DIR             if (schemeField.type == org.apache.storm.thrift.protocol.TType.STRING) {               struct.master_code_dir = iprot.readString();               struct.set_master_code_dir_isSet(true);             } else {                org.apache.storm.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);             }             break;           case 2: // NODE_HOST             if (schemeField.type == org.apache.storm.thrift.protocol.TType.MAP) {               {                 org.apache.storm.thrift.protocol.TMap _map686 = iprot.readMapBegin();                 struct.node_host = new java.util.HashMap(2*_map686.size);                 @org.apache.storm.thrift.annotation.Nullable java.lang.String _key687;                 @org.apache.storm.thrift.annotation.Nullable java.lang.String _val688;                 for (int _i689 = 0; _i689 &lt; _map686.size; ++_i689)                 {                   _key687 = iprot.readString();                   _val688 = iprot.readString();                   struct.node_host.put(_key687, _val688);                 }                 iprot.readMapEnd();               }               struct.set_node_host_isSet(true);             } else {                org.apache.storm.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);             }             break;           case 3: // EXECUTOR_NODE_PORT             if (schemeField.type == org.apache.storm.thrift.protocol.TType.MAP) {               {                 org.apache.storm.thrift.protocol.TMap _map690 = iprot.readMapBegin();                 struct.executor_node_port = new java.util.HashMap,NodeInfo&gt;(2*_map690.size);                 @org.apache.storm.thrift.annotation.Nullable java.util.List _key691;                 @org.apache.storm.thrift.annotation.Nullable NodeInfo _val692;                 for (int _i693 = 0; _i693 &lt; _map690.size; ++_i693)                 {                   {                     org.apache.storm.thrift.protocol.TList _list694 = iprot.readListBegin();                     _key691 = new java.util.ArrayList(_list694.size);                     long _elem695;                     for (int _i696 = 0; _i696 &lt; _list694.size; ++_i696)                     {                       _elem695 = iprot.readI64();                       _key691.add(_elem695);                     }                     iprot.readListEnd();                   }                   _val692 = new NodeInfo();                   _val692.read(iprot);                   struct.executor_node_port.put(_key691, _val692);                 }                 iprot.readMapEnd();               }               struct.set_executor_node_port_isSet(true);             } else {                org.apache.storm.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);             }             break;           case 4: // EXECUTOR_START_TIME_SECS             if (schemeField.type == org.apache.storm.thrift.protocol.TType.MAP) {               {                 org.apache.storm.thrift.protocol.TMap _map697 = iprot.readMapBegin();                 struct.executor_start_time_secs = new java.util.HashMap,java.lang.Long&gt;(2*_map697.size);                 @org.apache.storm.thrift.annotation.Nullable java.util.List _key698;                 long _val699;                 for (int _i700 = 0; _i700 &lt; _map697.size; ++_i700)                 {                   {                     org.apache.storm.thrift.protocol.TList _list701 = iprot.readListBegin();                     _key698 = new java.util.ArrayList(_list701.size);                     long _elem702;                     for (int _i703 = 0; _i703 &lt; _list701.size; ++_i703)                     {                       _elem702 = iprot.readI64();                       _key698.add(_elem702);                     }                     iprot.readListEnd();                   }                   _val699 = iprot.readI64();                   struct.executor_start_time_secs.put(_key698, _val699);                 }                 iprot.readMapEnd();               }               struct.set_executor_start_time_secs_isSet(true);             } else {                org.apache.storm.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);             }             break;           case 5: // WORKER_RESOURCES             if (schemeField.type == org.apache.storm.thrift.protocol.TType.MAP) {               {                 org.apache.storm.thrift.protocol.TMap _map704 = iprot.readMapBegin();                 struct.worker_resources = new java.util.HashMap(2*_map704.size);                 @org.apache.storm.thrift.annotation.Nullable NodeInfo _key705;                 @org.apache.storm.thrift.annotation.Nullable WorkerResources _val706;                 for (int _i707 = 0; _i707 &lt; _map704.size; ++_i707)                 {                   _key705 = new NodeInfo();                   _key705.read(iprot);                   _val706 = new WorkerResources();                   _val706.read(iprot);                   struct.worker_resources.put(_key705, _val706);                 }                 iprot.readMapEnd();               }               struct.set_worker_resources_isSet(true);             } else {                org.apache.storm.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);             }             break;           case 6: // TOTAL_SHARED_OFF_HEAP             if (schemeField.type == org.apache.storm.thrift.protocol.TType.MAP) {               {                 org.apache.storm.thrift.protocol.TMap _map708 = iprot.readMapBegin();                 struct.total_shared_off_heap = new java.util.HashMap(2*_map708.size);                 @org.apache.storm.thrift.annotation.Nullable java.lang.String _key709;                 double _val710;                 for (int _i711 = 0; _i711 &lt; _map708.size; ++_i711)                 {                   _key709 = iprot.readString();                   _val710 = iprot.readDouble();                   struct.total_shared_off_heap.put(_key709, _val710);                 }                 iprot.readMapEnd();               }               struct.set_total_shared_off_heap_isSet(true);             } else {                org.apache.storm.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);             }             break;           case 7: // OWNER             if (schemeField.type == org.apache.storm.thrift.protocol.TType.STRING) {               struct.owner = iprot.readString();               struct.set_owner_isSet(true);             } else {                org.apache.storm.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);             }             break;           default:             org.apache.storm.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);         }         iprot.readFieldEnd();       }       iprot.readStructEnd();       struct.validate();     }      public void write(org.apache.storm.thrift.protocol.TProtocol oprot, Assignment struct) throws org.apache.storm.thrift.TException {       struct.validate();        oprot.writeStructBegin(STRUCT_DESC);       if (struct.master_code_dir != null) {         oprot.writeFieldBegin(MASTER_CODE_DIR_FIELD_DESC);         oprot.writeString(struct.master_code_dir);         oprot.writeFieldEnd();       }       if (struct.node_host != null) {         if (struct.is_set_node_host()) {           oprot.writeFieldBegin(NODE_HOST_FIELD_DESC);           {             oprot.writeMapBegin(new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.STRING, org.apache.storm.thrift.protocol.TType.STRING, struct.node_host.size()));             for (java.util.Map.Entry _iter712 : struct.node_host.entrySet())             {               oprot.writeString(_iter712.getKey());               oprot.writeString(_iter712.getValue());             }             oprot.writeMapEnd();           }           oprot.writeFieldEnd();         }       }       if (struct.executor_node_port != null) {         if (struct.is_set_executor_node_port()) {           oprot.writeFieldBegin(EXECUTOR_NODE_PORT_FIELD_DESC);           {             oprot.writeMapBegin(new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.LIST, org.apache.storm.thrift.protocol.TType.STRUCT, struct.executor_node_port.size()));             for (java.util.Map.Entry, NodeInfo&gt; _iter713 : struct.executor_node_port.entrySet())             {               {                 oprot.writeListBegin(new org.apache.storm.thrift.protocol.TList(org.apache.storm.thrift.protocol.TType.I64, _iter713.getKey().size()));                 for (long _iter714 : _iter713.getKey())                 {                   oprot.writeI64(_iter714);                 }                 oprot.writeListEnd();               }               _iter713.getValue().write(oprot);             }             oprot.writeMapEnd();           }           oprot.writeFieldEnd();         }       }       if (struct.executor_start_time_secs != null) {         if (struct.is_set_executor_start_time_secs()) {           oprot.writeFieldBegin(EXECUTOR_START_TIME_SECS_FIELD_DESC);           {             oprot.writeMapBegin(new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.LIST, org.apache.storm.thrift.protocol.TType.I64, struct.executor_start_time_secs.size()));             for (java.util.Map.Entry, java.lang.Long&gt; _iter715 : struct.executor_start_time_secs.entrySet())             {               {                 oprot.writeListBegin(new org.apache.storm.thrift.protocol.TList(org.apache.storm.thrift.protocol.TType.I64, _iter715.getKey().size()));                 for (long _iter716 : _iter715.getKey())                 {                   oprot.writeI64(_iter716);                 }                 oprot.writeListEnd();               }               oprot.writeI64(_iter715.getValue());             }             oprot.writeMapEnd();           }           oprot.writeFieldEnd();         }       }       if (struct.worker_resources != null) {         if (struct.is_set_worker_resources()) {           oprot.writeFieldBegin(WORKER_RESOURCES_FIELD_DESC);           {             oprot.writeMapBegin(new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.STRUCT, org.apache.storm.thrift.protocol.TType.STRUCT, struct.worker_resources.size()));             for (java.util.Map.Entry _iter717 : struct.worker_resources.entrySet())             {               _iter717.getKey().write(oprot);               _iter717.getValue().write(oprot);             }             oprot.writeMapEnd();           }           oprot.writeFieldEnd();         }       }       if (struct.total_shared_off_heap != null) {         if (struct.is_set_total_shared_off_heap()) {           oprot.writeFieldBegin(TOTAL_SHARED_OFF_HEAP_FIELD_DESC);           {             oprot.writeMapBegin(new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.STRING, org.apache.storm.thrift.protocol.TType.DOUBLE, struct.total_shared_off_heap.size()));             for (java.util.Map.Entry _iter718 : struct.total_shared_off_heap.entrySet())             {               oprot.writeString(_iter718.getKey());               oprot.writeDouble(_iter718.getValue());             }             oprot.writeMapEnd();           }           oprot.writeFieldEnd();         }       }       if (struct.owner != null) {         if (struct.is_set_owner()) {           oprot.writeFieldBegin(OWNER_FIELD_DESC);           oprot.writeString(struct.owner);           oprot.writeFieldEnd();         }       }       oprot.writeFieldStop();       oprot.writeStructEnd();     }    }    private static class AssignmentTupleSchemeFactory implements org.apache.storm.thrift.scheme.SchemeFactory {     public AssignmentTupleScheme getScheme() {       return new AssignmentTupleScheme();     }   }    private static class AssignmentTupleScheme extends org.apache.storm.thrift.scheme.TupleScheme {      @Override     public void write(org.apache.storm.thrift.protocol.TProtocol prot, Assignment struct) throws org.apache.storm.thrift.TException {       org.apache.storm.thrift.protocol.TTupleProtocol oprot = (org.apache.storm.thrift.protocol.TTupleProtocol) prot;       oprot.writeString(struct.master_code_dir);       java.util.BitSet optionals = new java.util.BitSet();       if (struct.is_set_node_host()) {         optionals.set(0);       }       if (struct.is_set_executor_node_port()) {         optionals.set(1);       }       if (struct.is_set_executor_start_time_secs()) {         optionals.set(2);       }       if (struct.is_set_worker_resources()) {         optionals.set(3);       }       if (struct.is_set_total_shared_off_heap()) {         optionals.set(4);       }       if (struct.is_set_owner()) {         optionals.set(5);       }       oprot.writeBitSet(optionals, 6);       if (struct.is_set_node_host()) {         {           oprot.writeI32(struct.node_host.size());           for (java.util.Map.Entry _iter719 : struct.node_host.entrySet())           {             oprot.writeString(_iter719.getKey());             oprot.writeString(_iter719.getValue());           }         }       }       if (struct.is_set_executor_node_port()) {         {           oprot.writeI32(struct.executor_node_port.size());           for (java.util.Map.Entry, NodeInfo&gt; _iter720 : struct.executor_node_port.entrySet())           {             {               oprot.writeI32(_iter720.getKey().size());               for (long _iter721 : _iter720.getKey())               {                 oprot.writeI64(_iter721);               }             }             _iter720.getValue().write(oprot);           }         }       }       if (struct.is_set_executor_start_time_secs()) {         {           oprot.writeI32(struct.executor_start_time_secs.size());           for (java.util.Map.Entry, java.lang.Long&gt; _iter722 : struct.executor_start_time_secs.entrySet())           {             {               oprot.writeI32(_iter722.getKey().size());               for (long _iter723 : _iter722.getKey())               {                 oprot.writeI64(_iter723);               }             }             oprot.writeI64(_iter722.getValue());           }         }       }       if (struct.is_set_worker_resources()) {         {           oprot.writeI32(struct.worker_resources.size());           for (java.util.Map.Entry _iter724 : struct.worker_resources.entrySet())           {             _iter724.getKey().write(oprot);             _iter724.getValue().write(oprot);           }         }       }       if (struct.is_set_total_shared_off_heap()) {         {           oprot.writeI32(struct.total_shared_off_heap.size());           for (java.util.Map.Entry _iter725 : struct.total_shared_off_heap.entrySet())           {             oprot.writeString(_iter725.getKey());             oprot.writeDouble(_iter725.getValue());           }         }       }       if (struct.is_set_owner()) {         oprot.writeString(struct.owner);       }     }      @Override     public void read(org.apache.storm.thrift.protocol.TProtocol prot, Assignment struct) throws org.apache.storm.thrift.TException {       org.apache.storm.thrift.protocol.TTupleProtocol iprot = (org.apache.storm.thrift.protocol.TTupleProtocol) prot;       struct.master_code_dir = iprot.readString();       struct.set_master_code_dir_isSet(true);       java.util.BitSet incoming = iprot.readBitSet(6);       if (incoming.get(0)) {         {           org.apache.storm.thrift.protocol.TMap _map726 = new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.STRING, org.apache.storm.thrift.protocol.TType.STRING, iprot.readI32());           struct.node_host = new java.util.HashMap(2*_map726.size);           @org.apache.storm.thrift.annotation.Nullable java.lang.String _key727;           @org.apache.storm.thrift.annotation.Nullable java.lang.String _val728;           for (int _i729 = 0; _i729 &lt; _map726.size; ++_i729)           {             _key727 = iprot.readString();             _val728 = iprot.readString();             struct.node_host.put(_key727, _val728);           }         }         struct.set_node_host_isSet(true);       }       if (incoming.get(1)) {         {           org.apache.storm.thrift.protocol.TMap _map730 = new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.LIST, org.apache.storm.thrift.protocol.TType.STRUCT, iprot.readI32());           struct.executor_node_port = new java.util.HashMap,NodeInfo&gt;(2*_map730.size);           @org.apache.storm.thrift.annotation.Nullable java.util.List _key731;           @org.apache.storm.thrift.annotation.Nullable NodeInfo _val732;           for (int _i733 = 0; _i733 &lt; _map730.size; ++_i733)           {             {               org.apache.storm.thrift.protocol.TList _list734 = new org.apache.storm.thrift.protocol.TList(org.apache.storm.thrift.protocol.TType.I64, iprot.readI32());               _key731 = new java.util.ArrayList(_list734.size);               long _elem735;               for (int _i736 = 0; _i736 &lt; _list734.size; ++_i736)               {                 _elem735 = iprot.readI64();                 _key731.add(_elem735);               }             }             _val732 = new NodeInfo();             _val732.read(iprot);             struct.executor_node_port.put(_key731, _val732);           }         }         struct.set_executor_node_port_isSet(true);       }       if (incoming.get(2)) {         {           org.apache.storm.thrift.protocol.TMap _map737 = new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.LIST, org.apache.storm.thrift.protocol.TType.I64, iprot.readI32());           struct.executor_start_time_secs = new java.util.HashMap,java.lang.Long&gt;(2*_map737.size);           @org.apache.storm.thrift.annotation.Nullable java.util.List _key738;           long _val739;           for (int _i740 = 0; _i740 &lt; _map737.size; ++_i740)           {             {               org.apache.storm.thrift.protocol.TList _list741 = new org.apache.storm.thrift.protocol.TList(org.apache.storm.thrift.protocol.TType.I64, iprot.readI32());               _key738 = new java.util.ArrayList(_list741.size);               long _elem742;               for (int _i743 = 0; _i743 &lt; _list741.size; ++_i743)               {                 _elem742 = iprot.readI64();                 _key738.add(_elem742);               }             }             _val739 = iprot.readI64();             struct.executor_start_time_secs.put(_key738, _val739);           }         }         struct.set_executor_start_time_secs_isSet(true);       }       if (incoming.get(3)) {         {           org.apache.storm.thrift.protocol.TMap _map744 = new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.STRUCT, org.apache.storm.thrift.protocol.TType.STRUCT, iprot.readI32());           struct.worker_resources = new java.util.HashMap(2*_map744.size);           @org.apache.storm.thrift.annotation.Nullable NodeInfo _key745;           @org.apache.storm.thrift.annotation.Nullable WorkerResources _val746;           for (int _i747 = 0; _i747 &lt; _map744.size; ++_i747)           {             _key745 = new NodeInfo();             _key745.read(iprot);             _val746 = new WorkerResources();             _val746.read(iprot);             struct.worker_resources.put(_key745, _val746);           }         }         struct.set_worker_resources_isSet(true);       }       if (incoming.get(4)) {         {           org.apache.storm.thrift.protocol.TMap _map748 = new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.STRING, org.apache.storm.thrift.protocol.TType.DOUBLE, iprot.readI32());           struct.total_shared_off_heap = new java.util.HashMap(2*_map748.size);           @org.apache.storm.thrift.annotation.Nullable java.lang.String _key749;           double _val750;           for (int _i751 = 0; _i751 &lt; _map748.size; ++_i751)           {             _key749 = iprot.readString();             _val750 = iprot.readDouble();             struct.total_shared_off_heap.put(_key749, _val750);           }         }         struct.set_total_shared_off_heap_isSet(true);       }       if (incoming.get(5)) {         struct.owner = iprot.readString();         struct.set_owner_isSet(true);       }     }   }    private static  S scheme(org.apache.storm.thrift.protocol.TProtocol proto) {     return (org.apache.storm.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();   } }</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15015</td>
    <td align="left">https://github.com/apache/storm/blob/dc56e32f3dcdd9396a827a85029d60ed97474786/storm-client/src/jvm/org/apache/storm/generated/Assignment.java/#L26-L1404</td>
    <td align="right">1</td>
    <td align="right">5343</td>
    <td align="right">15015</td>
  </tr>
  <tr valign="top">
    <td align="right">5399</td>
    <td align="left">{   &quot;response&quot;: &quot;YES, I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;Blob&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
None</td>
    <td align="left">blob</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15171</td>
    <td align="left">https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/standalone-metastore/metastore-common/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/ThriftHiveMetastore.java/#L233896-L233981</td>
    <td align="right">1</td>
    <td align="right">5399</td>
    <td align="right">15171</td>
  </tr>
</table>
<p>(110 rows)<br />
</p>
