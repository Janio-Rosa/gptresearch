<table border="1">
  <tr>
    <th align="center">id</th>
    <th align="center">chat_gpt_response</th>
    <th align="center">question</th>
    <th align="center">badsmell_base</th>
    <th align="center">bad_smell_gpt</th>
    <th align="center">found_any</th>
    <th align="center">valid_bad_smell</th>
    <th align="center">bad_smell_in_base</th>
    <th align="center">bad_smell_not_in_the_base</th>
    <th align="center">bad_smell_not_found</th>
    <th align="center">index</th>
    <th align="center">index_base</th>
    <th align="center">url_github</th>
    <th align="center">nr_question</th>
    <th align="center">id_source_code</th>
    <th align="center">id_base</th>
  </tr>
  <tr valign="top">
    <td align="right">5382</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{             &quot;output&quot;: &quot;YES I found bad smells the bad smells are:&quot;,         &quot;detected_bad_smells&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ObjectInFolderListImpl extends AbstractExtensionData implements ObjectInFolderList {      private static final long serialVersionUID = 1L;      private List objects;     private Boolean hasMoreItems = Boolean.FALSE;     private BigInteger numItems;      @Override     public List getObjects() {         if (objects == null) {             objects = new ArrayList(0);         }          return objects;     }      public void setObjects(List objects) {         this.objects = objects;     }      @Override     public Boolean hasMoreItems() {         return hasMoreItems;     }      public void setHasMoreItems(Boolean hasMoreItems) {         this.hasMoreItems = hasMoreItems;     }      @Override     public BigInteger getNumItems() {         return numItems;     }      public void setNumItems(BigInteger numItems) {         this.numItems = numItems;     }      @Override     public String toString() {         return &quot;ObjectInFolder List [objects=&quot; + objects + &quot;, has more items=&quot; + hasMoreItems + &quot;, num items=&quot;                 + numItems + &quot;]&quot; + super.toString();     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15137</td>
    <td align="left">https://github.com/apache/chemistry-opencmis/blob/ef8513d708e5e21710afe5cafb8b32a62a0ae532/chemistry-opencmis-commons/chemistry-opencmis-commons-impl/src/main/java/org/apache/chemistry/opencmis/commons/impl/dataobjects/ObjectInFolderListImpl.java/#L31-L75</td>
    <td align="right">1</td>
    <td align="right">5382</td>
    <td align="right">15137</td>
  </tr>
  <tr valign="top">
    <td align="right">2609</td>
    <td align="left">{      &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class BasicAttributeSensor extends BasicSensor implements AttributeSensor {     private static final long serialVersionUID = -2493209215974820300L;          private final SensorPersistenceMode persistence;      public BasicAttributeSensor(Class type, String name) {         this(type, name, name);     }          public BasicAttributeSensor(Class type, String name, String description) {         this(type, name, description, SensorPersistenceMode.REQUIRED);     }          public BasicAttributeSensor(TypeToken typeToken, String name) {         this(typeToken, name, name);     }     public BasicAttributeSensor(TypeToken typeToken, String name, String description) {         this(typeToken, name, description, SensorPersistenceMode.REQUIRED);     }          public BasicAttributeSensor(Class type, String name, String description, SensorPersistenceMode persistence) {         this(type, null, name, description, persistence);     }     public BasicAttributeSensor(TypeToken typeToken, String name, String description, SensorPersistenceMode persistence) {         this(null, typeToken, name, description, persistence);     }     public BasicAttributeSensor(Class type, TypeToken typeToken, String name, String description, SensorPersistenceMode persistence) {         super(type, typeToken, name, description);         this.persistence = checkNotNull(persistence, &quot;persistence&quot;);     }      @Override     public SensorPersistenceMode getPersistenceMode() {         // persistence could be null if deserializing state written by an old version; in which case default to 'required'         return (persistence != null) ? persistence : SensorPersistenceMode.REQUIRED;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15033</td>
    <td align="left">https://github.com/apache/brooklyn-server/blob/880eb1da00f6358d7fd76d065322e3685bfb1a04/core/src/main/java/org/apache/brooklyn/core/sensor/BasicAttributeSensor.java/#L31-L67</td>
    <td align="right">1</td>
    <td align="right">2609</td>
    <td align="right">15033</td>
  </tr>
  <tr valign="top">
    <td align="right">4</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [         &quot;Long method&quot;,         &quot;Long parameter list&quot;,         &quot;Data class&quot;,         &quot;Feature envy&quot;     ]   }</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells).<br />
 Could you please identify which smells occur in the following code? However, do not describe the smells,<br />
 just list them. <br />
Please start your answer with &quot;YES I found bad smells&quot; when you find any bad smell. <br />
Otherwise, start your answer with &quot;NO, I did not find any bad smell&quot;. <br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells<br />
are:&quot; amongst the text your answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class MailChimpServiceImpl implements MailChimpService {      private static Logger logger = LoggerFactory.getLogger(MailChimpServiceImpl.class);      private static final String ACCEPT = &quot;Accept&quot;;     private static final String AUTHORIZATION = &quot;Authorization&quot;;     private static final String LISTS = &quot;lists&quot;;     private static final String ID = &quot;id&quot;;     private static final String NAME = &quot;name&quot;;     private static final String MERGE_FIELDS = &quot;merge_fields&quot;;     private static final String EMAIL_TYPE = &quot;email_type&quot;;     private static final String EMAIL_ADDRESS = &quot;email_address&quot;;     private static final String EMAIL = &quot;email&quot;;     private static final String ERRORS = &quot;errors&quot;;     private static final String LIST_IDENTIFIER = &quot;listIdentifier&quot;;     private static final String STATUS = &quot;status&quot;;     private static final String SUBSCRIBED = &quot;subscribed&quot;;     private static final String UNSUBSCRIBED = &quot;unsubscribed&quot;;     private static final String TAG = &quot;tag&quot;;     private static final String TYPE = &quot;type&quot;;     private static final String UNOMI_ID = &quot;unomiId&quot;;     private static final String MC_SUB_TAG_NAME = &quot;mcSubTagName&quot;;     private static final String ADDR_1 = &quot;addr1&quot;;     private static final String ADDR_2 = &quot;addr2&quot;;     private static final String CITY = &quot;city&quot;;     private static final String COUNTRY = &quot;country&quot;;     private static final String STATE = &quot;state&quot;;     private static final String ZIP = &quot;zip&quot;;     private static final String ADDRESS = &quot;address&quot;;     private static final String DATE_FORMAT = &quot;date_format&quot;;     private static final String OPTIONS = &quot;options&quot;;     private static final String DATE = &quot;date&quot;;     private static final String MC_MM_DD_YYYY = &quot;MM/DD/YYYY&quot;;     private static final String MM_DD_YYYY = &quot;MM/dd/yyyy&quot;;     private static final String DD_MM_YYYY = &quot;dd/MM/yyyy&quot;;     private static final String BIRTHDAY = &quot;birthday&quot;;     private static final String MC_MM_DD = &quot;MM/DD&quot;;     private static final String MM_DD = &quot;MM/dd&quot;;     private static final String DD_MM = &quot;dd/MM&quot;;     private static final String SEPARATOR_CHARS_PROPERTIES = &quot;,&quot;;     private static final String SEPARATOR_CHARS_PROPERTY = &quot;&lt;=&gt;&quot;;      private String apiKey;     private String urlSubDomain;     private Map&gt;&gt; listMergeFieldMapping;     private Boolean isMergeFieldsActivate;     private CloseableHttpClient httpClient;       @Override     public List&gt; getAllLists() {         List&gt; mcLists = new ArrayList&lt;&gt;();         if (isMailChimpConnectorConfigured()) {             JsonNode response = HttpUtils.executeGetRequest(httpClient, getBaseUrl() + &quot;/lists&quot;, getHeaders(), false);             if (response != null) {                 if (response.has(LISTS) &amp;&amp; response.get(LISTS).size() &gt; 0) {                     for (JsonNode list : response.get(LISTS)) {                         if (list.has(ID) &amp;&amp; list.has(NAME)) {                             HashMap mcListInfo = new HashMap&lt;&gt;();                             mcListInfo.put(ID, list.get(ID).asText());                             mcListInfo.put(NAME, list.get(NAME).asText());                             mcLists.add(mcListInfo);                         } else {                             logger.warn(&quot;Missing mandatory information for list, {}&quot;, list.asText());                         }                     }                 } else {                     logger.debug(&quot;No list to return, response was {}&quot;, response.asText());                 }             }         }         return mcLists;     }      @Override     public MailChimpResult addToMCList(Profile profile, Action action) {         if (!isMailChimpConnectorConfigured() || profile.getProperty(EMAIL) == null) {             logger.error(&quot;The visitor does not have an email address&quot;);             return MailChimpResult.ERROR;         }          String listIdentifier = (String) action.getParameterValues().get(LIST_IDENTIFIER);         JsonNode currentMember = isMemberOfMailChimpList(profile, listIdentifier);         JSONObject mergeFields = new JSONObject();          if (currentMember != null &amp;&amp; currentMember.has(STATUS)) {             JSONObject body = new JSONObject();             if (currentMember.get(STATUS).asText().equals(UNSUBSCRIBED)) {                 logger.debug(&quot;The visitor is already in the MailChimp list, his status is unsubscribed&quot;);                 body.put(STATUS, SUBSCRIBED);             }              if (isMergeFieldsActivate &amp;&amp; addProfilePropertiesToMergeFieldsObject(profile, listIdentifier, mergeFields) == MailChimpResult.SUCCESS) {                 body.put(MERGE_FIELDS, mergeFields);             }             return updateSubscription(listIdentifier, body.toString(), currentMember, true);         }          JSONObject userData = new JSONObject();         userData.put(EMAIL_TYPE, &quot;html&quot;);         userData.put(EMAIL_ADDRESS, profile.getProperty(EMAIL).toString());         userData.put(STATUS, SUBSCRIBED);          if (isMergeFieldsActivate) {             addProfilePropertiesToMergeFieldsObject(profile, listIdentifier, mergeFields);         }         userData.put(MERGE_FIELDS, mergeFields);          JsonNode response = HttpUtils.executePostRequest(httpClient, getBaseUrl() + &quot;/lists/&quot; + listIdentifier + &quot;/members&quot;, getHeaders(), userData.toString());         if (response == null || (response.has(ERRORS) &amp;&amp; response.get(ERRORS).size() &gt; 0)) {             logger.error(&quot;Error when adding user to MailChimp list, list identifier was {} and response was {}&quot;, listIdentifier, response);             return MailChimpResult.ERROR;         }          return MailChimpResult.UPDATED;     }      @Override     public MailChimpResult removeFromMCList(Profile profile, Action action) {         if (!isMailChimpConnectorConfigured() || profile.getProperty(EMAIL) == null) {             return MailChimpResult.ERROR;         }          String listIdentifier = (String) action.getParameterValues().get(LIST_IDENTIFIER);         if (StringUtils.isBlank(listIdentifier)) {             logger.warn(&quot;Couldn't get the list identifier from Unomi&quot;);             return MailChimpResult.ERROR;         }          JsonNode currentMember = isMemberOfMailChimpList(profile, listIdentifier);         if (currentMember == null) {             return MailChimpResult.NO_CHANGE;         }          JsonNode response = HttpUtils.executeDeleteRequest(httpClient, getBaseUrl() + &quot;/lists/&quot; + listIdentifier + &quot;/members/&quot; + currentMember.get(ID).asText(), getHeaders());         if (response == null || (response.has(ERRORS) &amp;&amp; response.get(ERRORS).size() &gt; 0)) {             logger.error(&quot;Couldn't remove the visitor from the MailChimp list, list identifier was {} and response was {}&quot;, listIdentifier, response);             return MailChimpResult.ERROR;         }          return MailChimpResult.REMOVED;     }      @Override     public MailChimpResult unsubscribeFromMCList(Profile profile, Action action) {         if (!isMailChimpConnectorConfigured() || profile.getProperty(EMAIL) == null) {             return MailChimpResult.ERROR;         }          String listIdentifier = (String) action.getParameterValues().get(LIST_IDENTIFIER);         if (StringUtils.isBlank(listIdentifier)) {             logger.warn(&quot;Couldn't get the list identifier from Unomi&quot;);             return MailChimpResult.ERROR;         }          JsonNode currentMember = isMemberOfMailChimpList(profile, listIdentifier);         if (currentMember == null) {             return MailChimpResult.REMOVED;         }         if (currentMember.get(STATUS).asText().equals(UNSUBSCRIBED)) {             return MailChimpResult.NO_CHANGE;         }          JSONObject body = new JSONObject();         body.put(STATUS, UNSUBSCRIBED);         return updateSubscription(listIdentifier, body.toString(), currentMember, false);     }       @Override     public MailChimpResult updateMCProfileProperties(Profile profile, Action action) {         if (!isMailChimpConnectorConfigured() || profile.getProperty(EMAIL) == null) {             return MailChimpResult.ERROR;         }          String listIdentifier = (String) action.getParameterValues().get(LIST_IDENTIFIER);         if (StringUtils.isBlank(listIdentifier)) {             logger.warn(&quot;MailChimp list identifier not found&quot;);             return MailChimpResult.ERROR;         }          JsonNode currentMember = isMemberOfMailChimpList(profile, listIdentifier);         if (currentMember == null) {             logger.warn(&quot;The visitor was not part of the list&quot;);             return MailChimpResult.NO_CHANGE;         }           JSONObject mergeFields = new JSONObject();         MailChimpResult result = addProfilePropertiesToMergeFieldsObject(profile, listIdentifier, mergeFields);         if (result != MailChimpResult.SUCCESS) {             return result;         }          JSONObject body = new JSONObject();         body.put(MERGE_FIELDS, mergeFields);          JsonNode response = HttpUtils.executePatchRequest(httpClient, getBaseUrl() + &quot;/lists/&quot; + listIdentifier + &quot;/members/&quot; + currentMember.get(ID).asText(), getHeaders(), body.toString());         if (response == null || (response.has(ERRORS) &amp;&amp; response.get(ERRORS).size() &gt; 0)) {             logger.error(&quot;Error when updating visitor properties to MailChimp list, list identifier was {} and response was {}&quot;, listIdentifier, response);             return MailChimpResult.ERROR;         }          return MailChimpResult.UPDATED;     }      private MailChimpResult addProfilePropertiesToMergeFieldsObject(Profile profile, String listIdentifier, JSONObject mergeFields) {         if (listMergeFieldMapping.isEmpty()) {             logger.error(&quot;List of merge fields is not correctly configured&quot;);             return MailChimpResult.ERROR;         }          JsonNode mergeFieldsDefinitions = getMCListProperties(listIdentifier);         if (mergeFieldsDefinitions == null) {             logger.error(&quot;Could not get MailChimp list's merge fields&quot;);             return MailChimpResult.ERROR;         }          for (JsonNode mergeFieldDefinition : mergeFieldsDefinitions.get(MERGE_FIELDS)) {             if (mergeFieldDefinition.has(TAG) &amp;&amp; mergeFieldDefinition.has(TYPE)) {                 String mcTagName = mergeFieldDefinition.get(TAG).asText();                 if (listMergeFieldMapping.containsKey(mcTagName)) {                     List&gt; fields = listMergeFieldMapping.get(mcTagName);                     for (Map fieldInfo : fields) {                         String unomiId = fieldInfo.get(UNOMI_ID);                         if (profile.getProperty(unomiId) != null) {                             switch (mergeFieldDefinition.get(TYPE).asText()) {                                 case ADDRESS:                                     if (mergeFields.has(mcTagName)) {                                         mergeFields.getJSONObject(mcTagName).put(fieldInfo.get(MC_SUB_TAG_NAME), profile.getProperty(unomiId));                                     } else {                                         JSONObject address = new JSONObject();                                         address.put(ADDR_1, &quot;&quot;);                                         address.put(ADDR_2, &quot;&quot;);                                         address.put(CITY, &quot;&quot;);                                         address.put(COUNTRY, &quot;&quot;);                                         address.put(STATE, &quot;&quot;);                                         address.put(ZIP, &quot;&quot;);                                         address.put(fieldInfo.get(MC_SUB_TAG_NAME), profile.getProperty(unomiId));                                         mergeFields.put(mcTagName, address);                                     }                                     break;                                 case DATE:                                     if (mergeFieldDefinition.has(OPTIONS) &amp;&amp; mergeFieldDefinition.get(OPTIONS).has(DATE_FORMAT)) {                                         mergeFields.put(mcTagName, formatDate(mergeFieldDefinition.get(OPTIONS).get(DATE_FORMAT).asText(), profile.getProperty(unomiId)));                                     }                                     break;                                 case BIRTHDAY:                                     if (mergeFieldDefinition.has(OPTIONS) &amp;&amp; mergeFieldDefinition.get(OPTIONS).has(DATE_FORMAT)) {                                         mergeFields.put(mcTagName, formatDate(mergeFieldDefinition.get(OPTIONS).get(DATE_FORMAT).asText(), profile.getProperty(unomiId)));                                     }                                     break;                                 default:                                     mergeFields.put(mcTagName, profile.getProperty(unomiId));                                     break;                             }                         }                     }                     if (mergeFieldDefinition.get(TYPE).asText().equals(ADDRESS) &amp;&amp; mergeFields.has(mcTagName)                             &amp;&amp; (StringUtils.isBlank(mergeFields.getJSONObject(mcTagName).get(ADDR_1).toString())                             || StringUtils.isBlank(mergeFields.getJSONObject(mcTagName).get(ZIP).toString())                             || StringUtils.isBlank(mergeFields.getJSONObject(mcTagName).get(CITY).toString())                             || StringUtils.isBlank(mergeFields.getJSONObject(mcTagName).get(COUNTRY).toString()))) {                         mergeFields.remove(mcTagName);                         logger.debug(&quot;Can't map the address property {}, one of the mandatory field is missing (addr1, zip, city, country)&quot;, mcTagName);                     }                 } else {                     logger.debug(&quot;Found property {} in MC list, if you need this property please update mapping or add the property to your MC list&quot;, mcTagName);                 }             }         }          return MailChimpResult.SUCCESS;     }      private String formatDate(String mcDateFormat, Object date) {         DateTime dateTime = new DateTime(date);         if (StringUtils.contains(mcDateFormat, &quot;/YYYY&quot;)) {             return DateTimeFormat.forPattern((mcDateFormat.equals(MC_MM_DD_YYYY) ? MM_DD_YYYY : DD_MM_YYYY)).print(dateTime);         } else {             return DateTimeFormat.forPattern((mcDateFormat.equals(MC_MM_DD) ? MM_DD : DD_MM)).print(dateTime);         }     }       private JsonNode getMCListProperties(String listIdentifier) {         JsonNode currentMergeFields = HttpUtils.executeGetRequest(httpClient, getBaseUrl() + &quot;/lists/&quot; + listIdentifier + &quot;/merge-fields&quot;, getHeaders(), false);         if (currentMergeFields == null || !currentMergeFields.has(MERGE_FIELDS)) {             logger.error(&quot;Can't find merge_fields from the response, the response was {}&quot;, currentMergeFields);             return null;         }          return currentMergeFields;     }       private void initHttpClient() {         if (httpClient == null) {             httpClient = HttpUtils.initHttpClient();         }     }      private boolean isMailChimpConnectorConfigured() {         if (StringUtils.isNotBlank(apiKey) &amp;&amp; StringUtils.isNotBlank(urlSubDomain)) {             initHttpClient();             return true;         }         logger.error(&quot;MailChimp extension isn't correctly configured, please check cfg file.&quot;);         return false;     }      private JsonNode isMemberOfMailChimpList(Profile profile, String listIdentifier) {         String email = profile.getProperty(EMAIL).toString().toLowerCase();         String md5Hex = DigestUtils.md5Hex(email);          JsonNode response = HttpUtils.executeGetRequest(httpClient, getBaseUrl() + &quot;/lists/&quot; + listIdentifier + &quot;/members/&quot; + md5Hex, getHeaders(), true);         if (response != null) {             if (response.has(EMAIL_ADDRESS)) {                 if (response.get(EMAIL_ADDRESS).asText().toLowerCase().equals(email)) {                     return response;                 }             }         }         return null;     }      private MailChimpResult updateSubscription(String listIdentifier, String jsonData, JsonNode member, boolean toSubscribe) {         JsonNode response = HttpUtils.executePatchRequest(httpClient, getBaseUrl() + &quot;/lists/&quot; + listIdentifier + &quot;/members/&quot; + member.get(ID).asText(), getHeaders(), jsonData);         if (response != null) {             if (response.has(STATUS)) {                 String responseStatus = response.get(STATUS).asText();                 if ((toSubscribe &amp;&amp; responseStatus.equals(SUBSCRIBED)) || (!toSubscribe &amp;&amp; responseStatus.equals(UNSUBSCRIBED))) {                     return MailChimpResult.UPDATED;                 } else {                     return MailChimpResult.NO_CHANGE;                 }             }         }         logger.error(&quot;Couldn't update the subscription of the visitor&quot;);         return MailChimpResult.ERROR;     }      private String getBaseUrl() {         return &quot;https://&quot; + urlSubDomain + &quot;.api.mailchimp.com/3.0&quot;;     }      private HashMap getHeaders() {         HashMap headers = new HashMap&lt;&gt;();         headers.put(ACCEPT, &quot;application/json&quot;);         headers.put(AUTHORIZATION, &quot;apikey &quot; + apiKey);         return headers;     }      public void setApiKey(String apiKey) {         this.apiKey = apiKey;     }      public void setUrlSubDomain(String urlSubDomain) {         this.urlSubDomain = urlSubDomain;     }      public void setListMergeFieldMapping(String listMergeFields) {         this.listMergeFieldMapping = new HashMap&lt;&gt;();         if (StringUtils.isNotBlank(listMergeFields)) {             String mergeFields[] = StringUtils.split(listMergeFields, SEPARATOR_CHARS_PROPERTIES);             if (mergeFields.length &gt; 0) {                 for (String mergeField : mergeFields) {                     if (StringUtils.isNotBlank(mergeField)) {                         String mergeFieldInfo[] = StringUtils.split(mergeField, SEPARATOR_CHARS_PROPERTY);                         if (mergeFieldInfo.length &gt; 0) {                             Map fieldInfo = new HashMap&lt;&gt;();                             fieldInfo.put(UNOMI_ID, mergeFieldInfo[0]);                             if (mergeFieldInfo.length == 3) {                                 fieldInfo.put(MC_SUB_TAG_NAME, mergeFieldInfo[2]);                             }                              String mcTagName = mergeFieldInfo[1];                             if (listMergeFieldMapping.containsKey(mcTagName)) {                                 listMergeFieldMapping.get(mcTagName).add(fieldInfo);                             } else {                                 List&gt; fields = new ArrayList&lt;&gt;();                                 fields.add(fieldInfo);                                 listMergeFieldMapping.put(mcTagName, fields);                             }                         }                     }                 }             }         }     }      public void setIsMergeFieldsActivate(Boolean isMergeFieldsActivate) {         this.isMergeFieldsActivate = isMergeFieldsActivate;     } }</td>
    <td align="left">data class</td>
    <td align="left">'Long method', 'Long parameter list', 'Data class', 'Feature envy'</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">{',L,o,n,g,&quot; &quot;,m,e,t,h,o,d,',&quot;,&quot;,&quot; &quot;,',L,o,n,g,&quot; &quot;,p,a,r,a,m,e,t,e,r,&quot; &quot;,l,i,s,t,',&quot;,&quot;,&quot; &quot;,',D,a,t,a,&quot; &quot;,c,l,a,s,s,',&quot;,&quot;,&quot; &quot;,',F,e,a,t,u,r,e,&quot; &quot;,e,n,v,y,'}</td>
    <td align="left">{',o,n,g,&quot; &quot;,m,t,h,o,d,',&quot;,&quot;,&quot; &quot;,',o,n,g,&quot; &quot;,p,r,m,t,r,&quot; &quot;,i,t,',&quot;,&quot;,&quot; &quot;,',D,t,&quot; &quot;,c,',&quot;,&quot;,&quot; &quot;,',t,u,r,&quot; &quot;,n,v,y,'}</td>
    <td align="right">0</td>
    <td align="right">555</td>
    <td align="left">https://github.com/apache/unomi/blob/1745c5221401a05e66ebf80fbe9cce2790442b3a/extensions/unomi-mailchimp/services/src/main/java/org/apache/unomi/mailchimp/services/internal/MailChimpServiceImpl.java/#L40-L434</td>
    <td align="right">2</td>
    <td align="right">4</td>
    <td align="right">555</td>
  </tr>
  <tr valign="top">
    <td align="right">1414</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: {         &quot;1&quot;: &quot;Blob&quot;,         &quot;2&quot;: &quot;Data Class&quot;     } }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Singleton public class CheProductInfoDataProvider extends ProductInfoDataProviderImpl {    private final LocalizationConstant locale;   private final Resources resources;    @Inject   public CheProductInfoDataProvider(LocalizationConstant locale, Resources resources) {     this.locale = locale;     this.resources = resources;   }    @Override   public String getName() {     return locale.getProductName();   }    @Override   public String getSupportLink() {     return locale.getSupportLink();   }    @Override   public String getDocumentTitle() {     return locale.cheTabTitle();   }    @Override   public String getDocumentTitle(String workspaceName) {     return locale.cheTabTitle(workspaceName);   }    @Override   public SVGResource getLogo() {     return resources.logo();   }    @Override   public SVGResource getWaterMarkLogo() {     return resources.waterMarkLogo();   }    @Override   public String getSupportTitle() {     return locale.supportTitle();   } }</td>
    <td align="left">data class</td>
    <td align="left">1: blob, 2: data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1: blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10909</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/plugins/plugin-product-info/src/main/java/org/eclipse/che/plugin/product/info/client/CheProductInfoDataProvider.java/#L26-L72</td>
    <td align="right">1</td>
    <td align="right">1414</td>
    <td align="right">10909</td>
  </tr>
  <tr valign="top">
    <td align="right">853</td>
    <td align="left">&nbsp;&nbsp;{   &quot;response&quot;: &quot;YES, I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Long Method&quot;,     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class IntermediateModel {     private final Metadata metadata;      private final Map operations;      private final Map shapes;      private final CustomizationConfig customizationConfig;      private final ServiceExamples examples;      private final Map customAuthorizers;      @JsonIgnore     private final Optional endpointOperation;      @JsonIgnore     private final Map paginators;      @JsonIgnore     private final NamingStrategy namingStrategy;      @JsonCreator     public IntermediateModel(         @JsonProperty(&quot;metadata&quot;) Metadata metadata,         @JsonProperty(&quot;operations&quot;) Map operations,         @JsonProperty(&quot;shapes&quot;) Map shapes,         @JsonProperty(&quot;customizationConfig&quot;) CustomizationConfig customizationConfig,         @JsonProperty(&quot;serviceExamples&quot;) ServiceExamples examples) {          this(metadata, operations, shapes, customizationConfig, examples, null,              Collections.emptyMap(), Collections.emptyMap(), null);     }      public IntermediateModel(         Metadata metadata,         Map operations,         Map shapes,         CustomizationConfig customizationConfig,         ServiceExamples examples,         OperationModel endpointOperation,         Map customAuthorizers,         Map paginators,         NamingStrategy namingStrategy) {         this.metadata = metadata;         this.operations = operations;         this.shapes = shapes;         this.customizationConfig = customizationConfig;         this.examples = examples;         this.endpointOperation = Optional.ofNullable(endpointOperation);         this.customAuthorizers = customAuthorizers;         this.paginators = paginators;         this.namingStrategy = namingStrategy;     }      public Metadata getMetadata() {         return metadata;     }      public Map getOperations() {         return operations;     }      public OperationModel getOperation(String operationName) {         return getOperations().get(operationName);     }      public Map getShapes() {         return shapes;     }      public ShapeModel getShapeByC2jName(String c2jName) {         return Utils.findShapeModelByC2jName(this, c2jName);     }      public CustomizationConfig getCustomizationConfig() {         return customizationConfig;     }      public ServiceExamples getExamples() {         return examples;     }      public Map getPaginators() {         return paginators;     }      public NamingStrategy getNamingStrategy() {         return namingStrategy;     }      public String getCustomRetryPolicy() {         return customizationConfig.getCustomRetryPolicy();     }      public String getSdkModeledExceptionBaseFqcn() {         return String.format(&quot;%s.%s&quot;,                              metadata.getFullModelPackageName(),                              getSdkModeledExceptionBaseClassName());     }      public String getSdkModeledExceptionBaseClassName() {         if (customizationConfig.getSdkModeledExceptionBaseClassName() != null) {             return customizationConfig.getSdkModeledExceptionBaseClassName();         } else {             return metadata.getBaseExceptionName();         }     }      public String getSdkRequestBaseClassName() {         if (customizationConfig.getSdkRequestBaseClassName() != null) {             return customizationConfig.getSdkRequestBaseClassName();         } else {             return metadata.getBaseRequestName();         }     }      public String getSdkResponseBaseClassName() {         if (customizationConfig.getSdkResponseBaseClassName() != null) {             return customizationConfig.getSdkResponseBaseClassName();         } else {             return metadata.getBaseResponseName();         }     }      public String getFileHeader() throws IOException {         return loadDefaultFileHeader();     }      private String loadDefaultFileHeader() throws IOException {         try (InputStream inputStream = getClass()             .getResourceAsStream(&quot;/software/amazon/awssdk/codegen/DefaultFileHeader.txt&quot;)) {             return IoUtils.toUtf8String(inputStream)                           .replaceFirst(&quot;%COPYRIGHT_DATE_RANGE%&quot;, getCopyrightDateRange());         }     }      private String getCopyrightDateRange() {         int currentYear = ZonedDateTime.now().getYear();         int copyrightStartYear = currentYear - 5;         return String.format(&quot;%d-%d&quot;, copyrightStartYear, currentYear);     }      public String getSdkBaseResponseFqcn() {         if (metadata.getProtocol() == Protocol.API_GATEWAY) {             return &quot;software.amazon.awssdk.opensdk.BaseResult&quot;;         } else {             return String.format(&quot;%s&lt;%s&gt;&quot;,                                  AwsResponse.class.getName(),                                  getResponseMetadataClassName());         }     }      private String getResponseMetadataClassName() {         return AwsResponseMetadata.class.getName();     }      @JsonIgnore     public List simpleMethodsRequiringTesting() {         return getOperations().values().stream()                               .filter(v -&gt; v.getInputShape().isSimpleMethod())                               .collect(Collectors.toList());     }      public Map getCustomAuthorizers() {         return customAuthorizers;     }      public Optional getEndpointOperation() {         return endpointOperation;     }      public boolean hasPaginators() {         return paginators.size() &gt; 0;     }      public boolean containsRequestSigners() {         return getShapes().values().stream()                           .filter(ShapeModel::isRequestSignerAware)                           .findAny()                           .isPresent();     }      public boolean containsRequestEventStreams() {         return getOperations().values().stream()                               .filter(opModel -&gt; opModel.hasEventStreamInput())                               .findAny()                               .isPresent();     } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7877</td>
    <td align="left">https://github.com/aws/aws-sdk-java-v2/blob/1d5d11e8087c93ab1a3a2d35193052e526fd123c/codegen/src/main/java/software/amazon/awssdk/codegen/model/intermediate/IntermediateModel.java/#L37-L226</td>
    <td align="right">1</td>
    <td align="right">853</td>
    <td align="right">7877</td>
  </tr>
  <tr valign="top">
    <td align="right">1335</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  static class DynamicPackageEntry {      // public:     //     // DynamicPackageEntry() =default;      DynamicPackageEntry(String package_name, int package_id) {       this.package_name = package_name;       this.package_id = package_id;     }      String package_name;     int package_id = 0;   }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10724</td>
    <td align="left">https://github.com/robolectric/robolectric/blob/525bfcfc0e0ed1653ad57341b564c6857e11dc50/resources/src/main/java/org/robolectric/res/android/LoadedArsc.java/#L62-L75</td>
    <td align="right">1</td>
    <td align="right">1335</td>
    <td align="right">10724</td>
  </tr>
  <tr valign="top">
    <td align="right">936</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TfsGitTreeEntriesJson {     private final String objectId;     private final List treeEntries;     private final int size;      @JsonCreator     public TfsGitTreeEntriesJson(         @JsonProperty(&quot;objectId&quot;) final String objectId,         @JsonProperty(&quot;treeEntries&quot;) final List treeEntries,         @JsonProperty(&quot;size&quot;) final int size) throws JsonProcessingException {         this.objectId = objectId;         this.treeEntries = treeEntries;         this.size = size;     }      public String getObjectId() {         return objectId;     }      public List getTreeEntries() {         return treeEntries;     }      public int getSize() {         return size;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8410</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.client.common/src/com/microsoft/tfs/client/common/git/json/TfsGitTreeEntriesJson.java/#L12-L38</td>
    <td align="right">1</td>
    <td align="right">936</td>
    <td align="right">8410</td>
  </tr>
  <tr valign="top">
    <td align="right">1766</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{       &quot;output&quot;: &quot;YES I found bad smells&quot;,       &quot;bad smells are&quot;: [&quot;Data Class&quot;]    }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@ConfigurationProperties(prefix = &quot;camel.opentracing&quot;) public class OpenTracingConfigurationProperties {      /**      * Sets exclude pattern(s) that will disable tracing for Camel messages that      * matches the pattern.      */     private Set excludePatterns;     /**      * Activate or deactivate dash encoding in headers (required by JMS) for      * messaging      */     private Boolean encoding;      public Set getExcludePatterns() {         return excludePatterns;     }      public void setExcludePatterns(Set excludePatterns) {         this.excludePatterns = excludePatterns;     }      public Boolean getEncoding() {         return encoding;     }      public void setEncoding(Boolean encoding) {         this.encoding = encoding;     } }</td>
    <td align="left">data class</td>
    <td align="left">Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11911</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/platforms/spring-boot/components-starter/camel-opentracing-starter/src/main/java/org/apache/camel/opentracing/starter/OpenTracingConfigurationProperties.java/#L23-L52</td>
    <td align="right">1</td>
    <td align="right">1766</td>
    <td align="right">11911</td>
  </tr>
  <tr valign="top">
    <td align="right">830</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
        private static class GridMBeanServerData {             /** Set of grid names for selected MBeanServer. */             private Collection igniteInstanceNames = new HashSet&lt;&gt;();              /** */             private ObjectName mbean;              /** Count of grid instances. */             private int cnt;              /**              * Create data container.              *              * @param mbean Object name of MBean.              */             GridMBeanServerData(ObjectName mbean) {                 assert mbean != null;                  this.mbean = mbean;             }              /**              * Add Ignite instance name.              *              * @param igniteInstanceName Ignite instance name.              */             public void addIgniteInstance(String igniteInstanceName) {                 igniteInstanceNames.add(igniteInstanceName);             }              /**              * Remove Ignite instance name.              *              * @param igniteInstanceName Ignite instance name.              */             public void removeIgniteInstance(String igniteInstanceName) {                 igniteInstanceNames.remove(igniteInstanceName);             }              /**              * Returns {@code true} if data contains the specified              * Ignite instance name.              *              * @param igniteInstanceName Ignite instance name.              * @return {@code true} if data contains the specified Ignite instance name.              */             public boolean containsIgniteInstance(String igniteInstanceName) {                 return igniteInstanceNames.contains(igniteInstanceName);             }              /**              * Gets name used in MBean server.              *              * @return Object name of MBean.              */             public ObjectName getMbean() {                 return mbean;             }              /**              * Gets number of grid instances working with MBeanServer.              *              * @return Number of grid instances.              */             public int getCounter() {                 return cnt;             }              /**              * Sets number of grid instances working with MBeanServer.              *              * @param cnt Number of grid instances.              */             public void setCounter(int cnt) {                 this.cnt = cnt;             }         }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7736</td>
    <td align="left">https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/core/src/main/java/org/apache/ignite/internal/IgnitionEx.java/#L2796-L2872</td>
    <td align="right">1</td>
    <td align="right">830</td>
    <td align="right">7736</td>
  </tr>
  <tr valign="top">
    <td align="right">246</td>
    <td align="left">&nbsp;&nbsp;	{ 		&quot;message&quot;: &quot;YES I found bad smells&quot;, 		&quot;bad_smells_are&quot;: [&quot;1. Data Class&quot;] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DefaultTypeDeclaration extends AbstractDeclaration implements TypeDeclaration {      private final Element m_componentMetadata;     private final String m_componentName;     private final String m_componentVersion;     private final String m_extension;     private boolean visible = true;      public DefaultTypeDeclaration(BundleContext bundleContext, Element componentMetadata) {         super(bundleContext, TypeDeclaration.class);         m_componentMetadata = componentMetadata;         visible = initVisible();         m_componentName = initComponentName();         m_componentVersion = initComponentVersion(bundleContext);         m_extension = initExtension();     }      private String initExtension() {         if (m_componentMetadata.getNameSpace() == null) {             return m_componentMetadata.getName();         }         return m_componentMetadata.getNameSpace() + &quot;:&quot; + m_componentMetadata.getName();     }      private String initComponentVersion(BundleContext bundleContext) {         String version = m_componentMetadata.getAttribute(&quot;version&quot;);         if (version != null) {             if (&quot;bundle&quot;.equalsIgnoreCase(version)) {                 return bundleContext.getBundle().getHeaders().get(Constants.BUNDLE_VERSION);             }         }         return version;     }      private String initComponentName() {         String name = m_componentMetadata.getAttribute(&quot;name&quot;);         if (name == null) {             name = m_componentMetadata.getAttribute(&quot;classname&quot;);         }         return name;     }      private boolean initVisible() {         String publicAttribute = m_componentMetadata.getAttribute(&quot;public&quot;);         return (publicAttribute == null) || !publicAttribute.equalsIgnoreCase(&quot;false&quot;);     }      public String getComponentName() {         return m_componentName;     }      public String getComponentVersion() {         return m_componentVersion;     }      public String getExtension() {         return m_extension;     }      public Element getComponentMetadata() {         return m_componentMetadata;     }      public boolean isPublic() {         return visible;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2654</td>
    <td align="left">https://github.com/apache/felix/blob/a132994b250751d4ba3b115ee070ba397d9840ca/ipojo/runtime/core/src/main/java/org/apache/felix/ipojo/extender/internal/declaration/DefaultTypeDeclaration.java/#L30-L96</td>
    <td align="right">1</td>
    <td align="right">246</td>
    <td align="right">2654</td>
  </tr>
  <tr valign="top">
    <td align="right">1492</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public class TypeRefWithoutModifiersElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.n4js.ts.TypeExpressions.TypeRefWithoutModifiers&quot;); 		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1); 		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0); 		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0); 		private final RuleCall cParameterizedTypeRefParserRuleCall_0_0_0 = (RuleCall)cAlternatives_0_0.eContents().get(0); 		private final RuleCall cThisTypeRefParserRuleCall_0_0_1 = (RuleCall)cAlternatives_0_0.eContents().get(1); 		private final Assignment cDynamicAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1); 		private final Keyword cDynamicPlusSignKeyword_0_1_0 = (Keyword)cDynamicAssignment_0_1.eContents().get(0); 		private final RuleCall cTypeTypeRefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1); 		private final RuleCall cFunctionTypeExpressionOLDParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2); 		private final RuleCall cUnionTypeExpressionOLDParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3); 		private final RuleCall cIntersectionTypeExpressionOLDParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4); 		 		//TypeRefWithoutModifiers StaticBaseTypeRef: 		//	(ParameterizedTypeRef | ThisTypeRef) =&gt; dynamic?='+'? | TypeTypeRef 		//	| FunctionTypeExpressionOLD 		//	| UnionTypeExpressionOLD 		//	| IntersectionTypeExpressionOLD; 		@Override public ParserRule getRule() { return rule; } 		 		//(ParameterizedTypeRef | ThisTypeRef) =&gt; dynamic?='+'? | TypeTypeRef | FunctionTypeExpressionOLD | UnionTypeExpressionOLD 		//| IntersectionTypeExpressionOLD 		public Alternatives getAlternatives() { return cAlternatives; } 		 		//(ParameterizedTypeRef | ThisTypeRef) =&gt; dynamic?='+'? 		public Group getGroup_0() { return cGroup_0; } 		 		//ParameterizedTypeRef | ThisTypeRef 		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; } 		 		//ParameterizedTypeRef 		public RuleCall getParameterizedTypeRefParserRuleCall_0_0_0() { return cParameterizedTypeRefParserRuleCall_0_0_0; } 		 		//ThisTypeRef 		public RuleCall getThisTypeRefParserRuleCall_0_0_1() { return cThisTypeRefParserRuleCall_0_0_1; } 		 		//=&gt; dynamic?='+'? 		public Assignment getDynamicAssignment_0_1() { return cDynamicAssignment_0_1; } 		 		//'+' 		public Keyword getDynamicPlusSignKeyword_0_1_0() { return cDynamicPlusSignKeyword_0_1_0; } 		 		//TypeTypeRef 		public RuleCall getTypeTypeRefParserRuleCall_1() { return cTypeTypeRefParserRuleCall_1; } 		 		//FunctionTypeExpressionOLD 		public RuleCall getFunctionTypeExpressionOLDParserRuleCall_2() { return cFunctionTypeExpressionOLDParserRuleCall_2; } 		 		//UnionTypeExpressionOLD 		public RuleCall getUnionTypeExpressionOLDParserRuleCall_3() { return cUnionTypeExpressionOLDParserRuleCall_3; } 		 		//IntersectionTypeExpressionOLD 		public RuleCall getIntersectionTypeExpressionOLDParserRuleCall_4() { return cIntersectionTypeExpressionOLDParserRuleCall_4; } 	}</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11118</td>
    <td align="left">https://github.com/eclipse/n4js/blob/f715912fce0352ab574ff878086f77d17a78c908/plugins/org.eclipse.n4js.ts/src-gen/org/eclipse/n4js/ts/services/TypeExpressionsGrammarAccess.java/#L201-L255</td>
    <td align="right">1</td>
    <td align="right">1492</td>
    <td align="right">11118</td>
  </tr>
  <tr valign="top">
    <td align="right">1109</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class RabbitGatewaySupport implements InitializingBean {  	/** Logger available to subclasses. */ 	protected final Log logger = LogFactory.getLog(getClass()); // NOSONAR  	private RabbitOperations rabbitOperations;  	/** 	 * Set the Rabbit connection factory to be used by the gateway. 	 * Will automatically create a RabbitTemplate for the given ConnectionFactory. 	 * @param connectionFactory The connection factory. 	 * @see #createRabbitTemplate 	 * @see #setConnectionFactory(org.springframework.amqp.rabbit.connection.ConnectionFactory) 	 */ 	public final void setConnectionFactory(ConnectionFactory connectionFactory) { 		this.rabbitOperations = createRabbitTemplate(connectionFactory); 	}  	/** 	 * Create a RabbitTemplate for the given ConnectionFactory. 	 * Only invoked if populating the gateway with a ConnectionFactory reference. 	 * 	 * @param connectionFactory the Rabbit ConnectionFactory to create a RabbitTemplate for 	 * @return the new RabbitTemplate instance 	 * @see #setConnectionFactory 	 */ 	protected RabbitTemplate createRabbitTemplate(ConnectionFactory connectionFactory) { 		return new RabbitTemplate(connectionFactory); 	}  	/** 	 * @return The Rabbit ConnectionFactory used by the gateway. 	 */ 	@Nullable 	public final ConnectionFactory getConnectionFactory() { 		return (this.rabbitOperations != null ? this.rabbitOperations.getConnectionFactory() : null); 	}  	/** 	 * Set the {@link RabbitOperations} for the gateway. 	 * @param rabbitOperations The Rabbit operations. 	 * @see #setConnectionFactory(org.springframework.amqp.rabbit.connection.ConnectionFactory) 	 */ 	public final void setRabbitOperations(RabbitOperations rabbitOperations) { 		this.rabbitOperations = rabbitOperations; 	}  	/** 	 * @return The {@link RabbitOperations} for the gateway. 	 */ 	public final RabbitOperations getRabbitOperations() { 		return this.rabbitOperations; 	}  	@Override 	public final void afterPropertiesSet() throws IllegalArgumentException, BeanInitializationException { 		if (this.rabbitOperations == null) { 			throw new IllegalArgumentException(&quot;'connectionFactory' or 'rabbitTemplate' is required&quot;); 		} 		try { 			initGateway(); 		} 		catch (Exception ex) { 			throw new BeanInitializationException(&quot;Initialization of Rabbit gateway failed: &quot; + ex.getMessage(), ex); 		} 	}  	/** 	 * Subclasses can override this for custom initialization behavior. 	 * Gets called after population of this instance's bean properties. 	 */ 	protected void initGateway() { 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9883</td>
    <td align="left">https://github.com/spring-projects/spring-amqp/blob/1614a4b0532b83e29b2a2fdb8dac102576b8aa51/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/RabbitGatewaySupport.java/#L43-L117</td>
    <td align="right">1</td>
    <td align="right">1109</td>
    <td align="right">9883</td>
  </tr>
  <tr valign="top">
    <td align="right">413</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class OsgiRequirementAdapter implements Requirement { 	private static final Logger logger = LoggerFactory.getLogger(OsgiRequirementAdapter.class); 	 	private final org.osgi.resource.Requirement requirement; 	 	public OsgiRequirementAdapter(org.osgi.resource.Requirement requirement) { 		if (requirement == null) 			throw new NullPointerException(&quot;Missing required parameter: requirement&quot;); 		this.requirement = requirement; 	}  	public String getComment() { 		return null; 	}  	public String getFilter() { 		return requirement.getDirectives().get(Constants.FILTER_DIRECTIVE); 	}  	public String getName() { 		return NamespaceTranslator.translate(requirement.getNamespace()); 	}  	public boolean isExtend() { 		return false; 	}  	public boolean isMultiple() { 		String multiple = requirement.getDirectives().get(Namespace.REQUIREMENT_CARDINALITY_DIRECTIVE); 		return Namespace.CARDINALITY_MULTIPLE.equals(multiple); 	}  	public boolean isOptional() { 		String resolution = requirement.getDirectives().get(Constants.RESOLUTION_DIRECTIVE); 		return Constants.RESOLUTION_OPTIONAL.equals(resolution); 	}  	public boolean isSatisfied(Capability capability) { 		logger.debug(LOG_ENTRY, &quot;isSatisfied&quot;, capability); 		boolean result = ResourceHelper.matches(requirement, new FelixCapabilityAdapter(capability, null)); 		logger.debug(LOG_EXIT, &quot;isSatisfied&quot;, result); 		return result; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4217</td>
    <td align="left">https://github.com/apache/aries/blob/52293d20268de7c98833846ded2b70d6476773de/subsystem/subsystem-obr/src/main/java/org/apache/aries/subsystem/util/felix/OsgiRequirementAdapter.java/#L28-L72</td>
    <td align="right">1</td>
    <td align="right">413</td>
    <td align="right">4217</td>
  </tr>
  <tr valign="top">
    <td align="right">2654</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SubProcessCommandLineArgs {    // Parameters to pass to the sub-process   private List parameters = Lists.newArrayList();    public void addCommand(Integer position, String value) {     parameters.add(new Command(position, value));   }    public void putCommand(Command command) {     parameters.add(command);   }    public List getParameters() {     return parameters;   }    /** Class used to store the SubProcces parameters. */   public static class Command {      // The ordinal position of the command to pass to the sub-process     int ordinalPosition;     String value;      @SuppressWarnings(&quot;unused&quot;)     private Command() {}      public Command(int ordinalPosition, String value) {       this.ordinalPosition = ordinalPosition;       this.value = value;     }      public int getKey() {       return ordinalPosition;     }      public void setKey(int key) {       this.ordinalPosition = key;     }      public String getValue() {       return value;     }      public void setValue(String value) {       this.value = value;     }   } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15180</td>
    <td align="left">https://github.com/apache/beam/blob/a956ff77a8448e5f2c12f6695fec608348b5ab60/examples/java/src/main/java/org/apache/beam/examples/subprocess/kernel/SubProcessCommandLineArgs.java/#L24-L72</td>
    <td align="right">1</td>
    <td align="right">2654</td>
    <td align="right">15180</td>
  </tr>
  <tr valign="top">
    <td align="right">641</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement(name = &quot;realm&quot;) @XmlType public class RealmTO implements EntityTO, TemplatableTO {      private static final long serialVersionUID = 516330662956254391L;      private String key;      private String name;      private String parent;      private String fullPath;      private String accountPolicy;      private String passwordPolicy;      private final List actions = new ArrayList&lt;&gt;();      @XmlJavaTypeAdapter(XmlGenericMapAdapter.class)     private final Map templates = new HashMap&lt;&gt;();      private final Set resources = new HashSet&lt;&gt;();      @Override     public String getKey() {         return key;     }      @Override     public void setKey(final String key) {         this.key = key;     }      public String getName() {         return name;     }      public void setName(final String name) {         this.name = name;     }      public String getParent() {         return parent;     }      public void setParent(final String parent) {         this.parent = parent;     }      public String getFullPath() {         return fullPath;     }      @PathParam(&quot;fullPath&quot;)     public void setFullPath(final String fullPath) {         this.fullPath = fullPath;     }      public String getAccountPolicy() {         return accountPolicy;     }      public void setAccountPolicy(final String accountPolicy) {         this.accountPolicy = accountPolicy;     }      public String getPasswordPolicy() {         return passwordPolicy;     }      public void setPasswordPolicy(final String passwordPolicy) {         this.passwordPolicy = passwordPolicy;     }      @XmlElementWrapper(name = &quot;actions&quot;)     @XmlElement(name = &quot;action&quot;)     @JsonProperty(&quot;actions&quot;)     public List getActions() {         return actions;     }      @JsonProperty     @Override     public Map getTemplates() {         return templates;     }      @XmlElementWrapper(name = &quot;resources&quot;)     @XmlElement(name = &quot;resource&quot;)     @JsonProperty(&quot;resources&quot;)     public Set getResources() {         return resources;     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6352</td>
    <td align="left">https://github.com/apache/syncope/blob/114c412afbfba24ffb4fbc804e5308a823a16a78/common/idrepo/lib/src/main/java/org/apache/syncope/common/lib/to/RealmTO.java/#L36-L132</td>
    <td align="right">1</td>
    <td align="right">641</td>
    <td align="right">6352</td>
  </tr>
  <tr valign="top">
    <td align="right">4535</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
class CFRouteImpl implements CFRoute {  	final private String domain; 	final private String host; 	final private String path; 	final private int port; 	final private String fullRoute;  	CFRouteImpl(String domain, String host, String path, int port, String fullRoute)  { 		super(); 		this.domain = domain; 		this.host = host; 		this.path = path; 		this.port = port; 		this.fullRoute = fullRoute; 	}  	public String getDomain() { 		return domain; 	}  	public String getHost() { 		return host; 	}  	public String getPath() { 		return path; 	}  	public int getPort() { 		return port; 	}  	public String getRoute() { 		return fullRoute; 	}  	@Override 	public String toString() { 		return &quot;CFRoute [domain=&quot; + domain + &quot;, host=&quot; + host + &quot;, path=&quot; + path + &quot;, port=&quot; + port  +&quot;]&quot;; 	}   	@Override 	public int hashCode() { 		final int prime = 31; 		int result = 1; 		result = prime * result + ((domain == null) ? 0 : domain.hashCode()); 		result = prime * result + ((fullRoute == null) ? 0 : fullRoute.hashCode()); 		result = prime * result + ((host == null) ? 0 : host.hashCode()); 		result = prime * result + ((path == null) ? 0 : path.hashCode()); 		result = prime * result + port; 		return result; 	}  	@Override 	public boolean equals(Object obj) { 		if (this == obj) 			return true; 		if (obj == null) 			return false; 		if (getClass() != obj.getClass()) 			return false; 		CFRouteImpl other = (CFRouteImpl) obj; 		if (domain == null) { 			if (other.domain != null) 				return false; 		} else if (!domain.equals(other.domain)) 			return false; 		if (fullRoute == null) { 			if (other.fullRoute != null) 				return false; 		} else if (!fullRoute.equals(other.fullRoute)) 			return false; 		if (host == null) { 			if (other.host != null) 				return false; 		} else if (!host.equals(other.host)) 			return false; 		if (path == null) { 			if (other.path != null) 				return false; 		} else if (!path.equals(other.path)) 			return false; 		if (port != other.port) 			return false; 		return true; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12036</td>
    <td align="left">https://github.com/spring-projects/sts4/blob/46e9e985b0c5e28ea1952d9fc640ec12fd9c8fdd/headless-services/commons/commons-cf/src/main/java/org/springframework/ide/vscode/commons/cloudfoundry/client/CFRouteImpl.java/#L3-L92</td>
    <td align="right">1</td>
    <td align="right">4535</td>
    <td align="right">12036</td>
  </tr>
  <tr valign="top">
    <td align="right">2399</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{       &quot;message&quot;: &quot;YES I found bad smells&quot;,       &quot;bad smells are&quot;: [          &quot;1. Data Class&quot;       ]    }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class StableValue {      private final T value;     private final Assumption assumption;      public StableValue(T value, String name) {         this.value = value;         this.assumption = Truffle.getRuntime().createAssumption(name);     }      public T getValue() {         return value;     }      public Assumption getAssumption() {         return assumption;     }      @Override     public String toString() {         return &quot;[&quot; + value + &quot;, &quot; + assumption + &quot;]&quot;;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14378</td>
    <td align="left">https://github.com/oracle/fastr/blob/a1ee49060317621c0c9eceea8ec60040aca59b2d/com.oracle.truffle.r.runtime/src/com/oracle/truffle/r/runtime/StableValue.java/#L28-L50</td>
    <td align="right">1</td>
    <td align="right">2399</td>
    <td align="right">14378</td>
  </tr>
  <tr valign="top">
    <td align="right">2288</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class Value {         int        count = 0;         BigInteger txid;     }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13898</td>
    <td align="left">https://github.com/alibaba/jstorm/blob/5d6cde22dbca7df3d6e6830bf94f98a6639ab559/example/sequence-split-merge/src/main/java/com/alipay/dw/jstorm/transcation/TransactionalGlobalCount.java/#L93-L96</td>
    <td align="right">1</td>
    <td align="right">2288</td>
    <td align="right">13898</td>
  </tr>
  <tr valign="top">
    <td align="right">2623</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ItemContent {  	private String defaultName = &quot;&quot;; //$NON-NLS-1$ 	private String displayName = &quot;&quot;; //$NON-NLS-1$ 	private String customName = &quot;&quot;; //$NON-NLS-1$ 	private String description = &quot;&quot;; //$NON-NLS-1$  	public ItemContent( String string ) 	{ 		super( ); 		this.setCustomName( string ); 	}  	/** 	 *  	 * @return Return the default name of ItemContent 	 */ 	public String getDefaultName( ) 	{ 		return defaultName; 	}  	/** 	 *  	 * @return Returns the display name of the ItemContent 	 */ 	public String getDisplayName( ) 	{ 		return displayName; 	}  	/** 	 * Set default name for ItemContent 	 *  	 * @param string 	 */ 	public void setDefaultName( String string ) 	{ 		defaultName = string.trim( ); 	}  	/** 	 * Sets the display name for the ItemContent 	 *  	 * @param string 	 */ 	public void setDisplayName( String string ) 	{ 		displayName = string.trim( ); 	}  	/** 	 *  	 * @return custom name of ItemContent 	 */ 	public String getCustomName( ) 	{ 		return customName; 	}  	/** 	 * Set custom name for ItemContent 	 *  	 * @param string 	 */ 	public void setCustomName( String string ) 	{ 		customName = string.trim( ); 	}  	/** 	 *  	 * @return the description of ItemContent 	 */ 	public String getDescription( ) 	{ 		return description; 	}  	/** 	 * Set the description for ItemContent 	 *  	 * @param string 	 */ 	public void setDescription( String string ) 	{ 		description = string.trim( ); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15063</td>
    <td align="left">https://github.com/eclipse/birt/blob/f89264810347de98702db45386a822aabc0fadbf/UI/org.eclipse.birt.report.designer.ui/src/org/eclipse/birt/report/designer/ui/preferences/ItemContent.java/#L22-L112</td>
    <td align="right">1</td>
    <td align="right">2623</td>
    <td align="right">15063</td>
  </tr>
  <tr valign="top">
    <td align="right">2511</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{             &quot;message&quot;: &quot;YES I found bad smells&quot;,             &quot;bad smells are&quot;: [                 &quot;Blob&quot;,                 &quot;Data Class&quot;             ]         }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class AssemblerConfig {  	// Private Member Variables ------------------------------------------------  	/** The portlet app descriptor, which is usually WEB-INF/portlet.xml. */     private File portletDescriptor;      /** The webapp descriptor to assemble, which is usually WEB-INF/web.xml. */     private File webappDescriptor;      /** The assemble destination, which points to the assembled WAR file. */     private File destination;      /** The class of the servlet that will handle portlet requests */     private String dispatchServletClass;      /** The source archive to assemble */     private File source;          /** Assembler sink buffer size.  Defaults to 4096 bytes. */     private int assemblerSinkBuflen = 1024 * 4; // 4kb      // Public Methods ----------------------------------------------------------      public File getPortletDescriptor() {         return portletDescriptor;     }      public void setPortletDescriptor(File portletDescriptor) {         this.portletDescriptor = portletDescriptor;     }      public File getWebappDescriptor() {         return webappDescriptor;     }      public void setWebappDescriptor(File webappDescriptor) {         this.webappDescriptor = webappDescriptor;     }      public File getDestination() {         return destination;     }      public void setDestination(File destination) {         this.destination = destination;     }      public String getDispatchServletClass() {         return dispatchServletClass;     }      public void setDispatchServletClass(String dispatchServletClass) {         this.dispatchServletClass = dispatchServletClass;     }      /**      * @deprecated use setSource(File) instead.      */     public void setWarSource(File source) {         this.source = source;     }          public void setSource(File source) {         this.source = source;     }          /**      * @deprecated use getSource() instead.      */     public File getWarSource() {         return source;     }          public File getSource() {         return source;     }          public int getAssemblerSinkBuflen() {         return assemblerSinkBuflen;     }          public void setAssemblerSinkBuflen(int buflen) {         this.assemblerSinkBuflen = buflen;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14687</td>
    <td align="left">https://github.com/apache/portals-pluto/blob/4db5ddd26fb2ce642be7b0894858e664c6076a3b/pluto-util/src/main/java/org/apache/pluto/util/assemble/AssemblerConfig.java/#L25-L110</td>
    <td align="right">1</td>
    <td align="right">2511</td>
    <td align="right">14687</td>
  </tr>
  <tr valign="top">
    <td align="right">2247</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  @JsonDeserialize(using = AggregationsDeserializer.class)   static class Aggregations implements Iterable {      private final List aggregations;     private Map aggregationsAsMap;      Aggregations(List aggregations) {       this.aggregations = Objects.requireNonNull(aggregations, &quot;aggregations&quot;);     }      /**      * Iterates over the {@link Aggregation}s.      */     @Override public final Iterator iterator() {       return asList().iterator();     }      /**      * The list of {@link Aggregation}s.      */     final List asList() {       return Collections.unmodifiableList(aggregations);     }      /**      * Returns the {@link Aggregation}s keyed by aggregation name. Lazy init.      */     final Map asMap() {       if (aggregationsAsMap == null) {         Map map = new LinkedHashMap&lt;&gt;(aggregations.size());         for (Aggregation aggregation : aggregations) {           map.put(aggregation.getName(), aggregation);         }         this.aggregationsAsMap = unmodifiableMap(map);       }       return aggregationsAsMap;     }      /**      * Returns the aggregation that is associated with the specified name.      */     @SuppressWarnings(&quot;unchecked&quot;)     public final  A get(String name) {       return (A) asMap().get(name);     }      @Override public final boolean equals(Object obj) {       if (obj == null || getClass() != obj.getClass()) {         return false;       }       return aggregations.equals(((Aggregations) obj).aggregations);     }      @Override public final int hashCode() {       return Objects.hash(getClass(), aggregations);     }    }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13660</td>
    <td align="left">https://github.com/apache/calcite/blob/a648f9c12309cc253628930b0cab98591caa66ab/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchJson.java/#L390-L447</td>
    <td align="right">1</td>
    <td align="right">2247</td>
    <td align="right">13660</td>
  </tr>
  <tr valign="top">
    <td align="right">2073</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class ZoneOffsetTransitionRule implements Serializable {      /**      * Serialization version.      */     private static final long serialVersionUID = 6889046316657758795L;      /**      * The month of the month-day of the first day of the cutover week.      * The actual date will be adjusted by the dowChange field.      */     private final Month month;     /**      * The day-of-month of the month-day of the cutover week.      * If positive, it is the start of the week where the cutover can occur.      * If negative, it represents the end of the week where cutover can occur.      * The value is the number of days from the end of the month, such that      * {@code -1} is the last day of the month, {@code -2} is the second      * to last day, and so on.      */     private final byte dom;     /**      * The cutover day-of-week, null to retain the day-of-month.      */     private final DayOfWeek dow;     /**      * The cutover time in the 'before' offset.      */     private final LocalTime time;     /**      * Whether the cutover time is midnight at the end of day.      */     private final boolean timeEndOfDay;     /**      * The definition of how the local time should be interpreted.      */     private final TimeDefinition timeDefinition;     /**      * The standard offset at the cutover.      */     private final ZoneOffset standardOffset;     /**      * The offset before the cutover.      */     private final ZoneOffset offsetBefore;     /**      * The offset after the cutover.      */     private final ZoneOffset offsetAfter;      /**      * Obtains an instance defining the yearly rule to create transitions between two offsets.      *       * Applications should normally obtain an instance from {@link ZoneRules}.      * This factory is only intended for use when creating {@link ZoneRules}.      *      * @param month  the month of the month-day of the first day of the cutover week, not null      * @param dayOfMonthIndicator  the day of the month-day of the cutover week, positive if the week is that      *  day or later, negative if the week is that day or earlier, counting from the last day of the month,      *  from -28 to 31 excluding 0      * @param dayOfWeek  the required day-of-week, null if the month-day should not be changed      * @param time  the cutover time in the 'before' offset, not null      * @param timeEndOfDay  whether the time is midnight at the end of day      * @param timeDefnition  how to interpret the cutover      * @param standardOffset  the standard offset in force at the cutover, not null      * @param offsetBefore  the offset before the cutover, not null      * @param offsetAfter  the offset after the cutover, not null      * @return the rule, not null      * @throws IllegalArgumentException if the day of month indicator is invalid      * @throws IllegalArgumentException if the end of day flag is true when the time is not midnight      * @throws IllegalArgumentException if {@code time.getNano()} returns non-zero value      */     public static ZoneOffsetTransitionRule of(             Month month,             int dayOfMonthIndicator,             DayOfWeek dayOfWeek,             LocalTime time,             boolean timeEndOfDay,             TimeDefinition timeDefnition,             ZoneOffset standardOffset,             ZoneOffset offsetBefore,             ZoneOffset offsetAfter) {         Objects.requireNonNull(month, &quot;month&quot;);         Objects.requireNonNull(time, &quot;time&quot;);         Objects.requireNonNull(timeDefnition, &quot;timeDefnition&quot;);         Objects.requireNonNull(standardOffset, &quot;standardOffset&quot;);         Objects.requireNonNull(offsetBefore, &quot;offsetBefore&quot;);         Objects.requireNonNull(offsetAfter, &quot;offsetAfter&quot;);         if (dayOfMonthIndicator &lt; -28 || dayOfMonthIndicator &gt; 31 || dayOfMonthIndicator == 0) {             throw new IllegalArgumentException(&quot;Day of month indicator must be between -28 and 31 inclusive excluding zero&quot;);         }         if (timeEndOfDay &amp;&amp; time.equals(LocalTime.MIDNIGHT) == false) {             throw new IllegalArgumentException(&quot;Time must be midnight when end of day flag is true&quot;);         }         if (time.getNano() != 0) {             throw new IllegalArgumentException(&quot;Time's nano-of-second must be zero&quot;);         }         return new ZoneOffsetTransitionRule(month, dayOfMonthIndicator, dayOfWeek, time, timeEndOfDay, timeDefnition, standardOffset, offsetBefore, offsetAfter);     }      /**      * Creates an instance defining the yearly rule to create transitions between two offsets.      *      * @param month  the month of the month-day of the first day of the cutover week, not null      * @param dayOfMonthIndicator  the day of the month-day of the cutover week, positive if the week is that      *  day or later, negative if the week is that day or earlier, counting from the last day of the month,      *  from -28 to 31 excluding 0      * @param dayOfWeek  the required day-of-week, null if the month-day should not be changed      * @param time  the cutover time in the 'before' offset, not null      * @param timeEndOfDay  whether the time is midnight at the end of day      * @param timeDefnition  how to interpret the cutover      * @param standardOffset  the standard offset in force at the cutover, not null      * @param offsetBefore  the offset before the cutover, not null      * @param offsetAfter  the offset after the cutover, not null      * @throws IllegalArgumentException if the day of month indicator is invalid      * @throws IllegalArgumentException if the end of day flag is true when the time is not midnight      */     ZoneOffsetTransitionRule(             Month month,             int dayOfMonthIndicator,             DayOfWeek dayOfWeek,             LocalTime time,             boolean timeEndOfDay,             TimeDefinition timeDefnition,             ZoneOffset standardOffset,             ZoneOffset offsetBefore,             ZoneOffset offsetAfter) {         assert time.getNano() == 0;         this.month = month;         this.dom = (byte) dayOfMonthIndicator;         this.dow = dayOfWeek;         this.time = time;         this.timeEndOfDay = timeEndOfDay;         this.timeDefinition = timeDefnition;         this.standardOffset = standardOffset;         this.offsetBefore = offsetBefore;         this.offsetAfter = offsetAfter;     }      //-----------------------------------------------------------------------     /**      * Defend against malicious streams.      *      * @param s the stream to read      * @throws InvalidObjectException always      */     private void readObject(ObjectInputStream s) throws InvalidObjectException {         throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);     }      /**      * Writes the object using a      * dedicated serialized form.      * @serialData      * Refer to the serialized form of      * ZoneRules.writeReplace      * for the encoding of epoch seconds and offsets.      * {@code      *      *      out.writeByte(3);                // identifies a ZoneOffsetTransition      *      final int timeSecs = (timeEndOfDay ? 86400 : time.toSecondOfDay());      *      final int stdOffset = standardOffset.getTotalSeconds();      *      final int beforeDiff = offsetBefore.getTotalSeconds() - stdOffset;      *      final int afterDiff = offsetAfter.getTotalSeconds() - stdOffset;      *      final int timeByte = (timeSecs % 3600 == 0 ? (timeEndOfDay ? 24 : time.getHour()) : 31);      *      final int stdOffsetByte = (stdOffset % 900 == 0 ? stdOffset / 900 + 128 : 255);      *      final int beforeByte = (beforeDiff == 0 || beforeDiff == 1800 || beforeDiff == 3600 ? beforeDiff / 1800 : 3);      *      final int afterByte = (afterDiff == 0 || afterDiff == 1800 || afterDiff == 3600 ? afterDiff / 1800 : 3);      *      final int dowByte = (dow == null ? 0 : dow.getValue());      *      int b = (month.getValue() &lt;&lt; 28) +          // 4 bits      *              ((dom + 32) &lt;&lt; 22) +                // 6 bits      *              (dowByte &lt;&lt; 19) +                   // 3 bits      *              (timeByte &lt;&lt; 14) +                  // 5 bits      *              (timeDefinition.ordinal() &lt;&lt; 12) +  // 2 bits      *              (stdOffsetByte &lt;&lt; 4) +              // 8 bits      *              (beforeByte &lt;&lt; 2) +                 // 2 bits      *              afterByte;                          // 2 bits      *      out.writeInt(b);      *      if (timeByte == 31) {      *          out.writeInt(timeSecs);      *      }      *      if (stdOffsetByte == 255) {      *          out.writeInt(stdOffset);      *      }      *      if (beforeByte == 3) {      *          out.writeInt(offsetBefore.getTotalSeconds());      *      }      *      if (afterByte == 3) {      *          out.writeInt(offsetAfter.getTotalSeconds());      *      }      * }      *       *      * @return the replacing object, not null      */     private Object writeReplace() {         return new Ser(Ser.ZOTRULE, this);     }      /**      * Writes the state to the stream.      *      * @param out  the output stream, not null      * @throws IOException if an error occurs      */     void writeExternal(DataOutput out) throws IOException {         final int timeSecs = (timeEndOfDay ? 86400 : time.toSecondOfDay());         final int stdOffset = standardOffset.getTotalSeconds();         final int beforeDiff = offsetBefore.getTotalSeconds() - stdOffset;         final int afterDiff = offsetAfter.getTotalSeconds() - stdOffset;         final int timeByte = (timeSecs % 3600 == 0 ? (timeEndOfDay ? 24 : time.getHour()) : 31);         final int stdOffsetByte = (stdOffset % 900 == 0 ? stdOffset / 900 + 128 : 255);         final int beforeByte = (beforeDiff == 0 || beforeDiff == 1800 || beforeDiff == 3600 ? beforeDiff / 1800 : 3);         final int afterByte = (afterDiff == 0 || afterDiff == 1800 || afterDiff == 3600 ? afterDiff / 1800 : 3);         final int dowByte = (dow == null ? 0 : dow.getValue());         int b = (month.getValue() &lt;&lt; 28) +          // 4 bits                 ((dom + 32) &lt;&lt; 22) +                // 6 bits                 (dowByte &lt;&lt; 19) +                   // 3 bits                 (timeByte &lt;&lt; 14) +                  // 5 bits                 (timeDefinition.ordinal() &lt;&lt; 12) +  // 2 bits                 (stdOffsetByte &lt;&lt; 4) +              // 8 bits                 (beforeByte &lt;&lt; 2) +                 // 2 bits                 afterByte;                          // 2 bits         out.writeInt(b);         if (timeByte == 31) {             out.writeInt(timeSecs);         }         if (stdOffsetByte == 255) {             out.writeInt(stdOffset);         }         if (beforeByte == 3) {             out.writeInt(offsetBefore.getTotalSeconds());         }         if (afterByte == 3) {             out.writeInt(offsetAfter.getTotalSeconds());         }     }      /**      * Reads the state from the stream.      *      * @param in  the input stream, not null      * @return the created object, not null      * @throws IOException if an error occurs      */     static ZoneOffsetTransitionRule readExternal(DataInput in) throws IOException {         int data = in.readInt();         Month month = Month.of(data &gt;&gt;&gt; 28);         int dom = ((data &amp; (63 &lt;&lt; 22)) &gt;&gt;&gt; 22) - 32;         int dowByte = (data &amp; (7 &lt;&lt; 19)) &gt;&gt;&gt; 19;         DayOfWeek dow = dowByte == 0 ? null : DayOfWeek.of(dowByte);         int timeByte = (data &amp; (31 &lt;&lt; 14)) &gt;&gt;&gt; 14;         TimeDefinition defn = TimeDefinition.values()[(data &amp; (3 &lt;&lt; 12)) &gt;&gt;&gt; 12];         int stdByte = (data &amp; (255 &lt;&lt; 4)) &gt;&gt;&gt; 4;         int beforeByte = (data &amp; (3 &lt;&lt; 2)) &gt;&gt;&gt; 2;         int afterByte = (data &amp; 3);         LocalTime time = (timeByte == 31 ? LocalTime.ofSecondOfDay(in.readInt()) : LocalTime.of(timeByte % 24, 0));         ZoneOffset std = (stdByte == 255 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds((stdByte - 128) * 900));         ZoneOffset before = (beforeByte == 3 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds(std.getTotalSeconds() + beforeByte * 1800));         ZoneOffset after = (afterByte == 3 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds(std.getTotalSeconds() + afterByte * 1800));         return ZoneOffsetTransitionRule.of(month, dom, dow, time, timeByte == 24, defn, std, before, after);     }      //-----------------------------------------------------------------------     /**      * Gets the month of the transition.      *       * If the rule defines an exact date then the month is the month of that date.      *       * If the rule defines a week where the transition might occur, then the month      * if the month of either the earliest or latest possible date of the cutover.      *      * @return the month of the transition, not null      */     public Month getMonth() {         return month;     }      /**      * Gets the indicator of the day-of-month of the transition.      *       * If the rule defines an exact date then the day is the month of that date.      *       * If the rule defines a week where the transition might occur, then the day      * defines either the start of the end of the transition week.      *       * If the value is positive, then it represents a normal day-of-month, and is the      * earliest possible date that the transition can be.      * The date may refer to 29th February which should be treated as 1st March in non-leap years.      *       * If the value is negative, then it represents the number of days back from the      * end of the month where {@code -1} is the last day of the month.      * In this case, the day identified is the latest possible date that the transition can be.      *      * @return the day-of-month indicator, from -28 to 31 excluding 0      */     public int getDayOfMonthIndicator() {         return dom;     }      /**      * Gets the day-of-week of the transition.      *       * If the rule defines an exact date then this returns null.      *       * If the rule defines a week where the cutover might occur, then this method      * returns the day-of-week that the month-day will be adjusted to.      * If the day is positive then the adjustment is later.      * If the day is negative then the adjustment is earlier.      *      * @return the day-of-week that the transition occurs, null if the rule defines an exact date      */     public DayOfWeek getDayOfWeek() {         return dow;     }      /**      * Gets the local time of day of the transition which must be checked with      * {@link #isMidnightEndOfDay()}.      *       * The time is converted into an instant using the time definition.      *      * @return the local time of day of the transition, not null      */     public LocalTime getLocalTime() {         return time;     }      /**      * Is the transition local time midnight at the end of day.      *       * The transition may be represented as occurring at 24:00.      *      * @return whether a local time of midnight is at the start or end of the day      */     public boolean isMidnightEndOfDay() {         return timeEndOfDay;     }      /**      * Gets the time definition, specifying how to convert the time to an instant.      *       * The local time can be converted to an instant using the standard offset,      * the wall offset or UTC.      *      * @return the time definition, not null      */     public TimeDefinition getTimeDefinition() {         return timeDefinition;     }      /**      * Gets the standard offset in force at the transition.      *      * @return the standard offset, not null      */     public ZoneOffset getStandardOffset() {         return standardOffset;     }      /**      * Gets the offset before the transition.      *      * @return the offset before, not null      */     public ZoneOffset getOffsetBefore() {         return offsetBefore;     }      /**      * Gets the offset after the transition.      *      * @return the offset after, not null      */     public ZoneOffset getOffsetAfter() {         return offsetAfter;     }      //-----------------------------------------------------------------------     /**      * Creates a transition instance for the specified year.      *       * Calculations are performed using the ISO-8601 chronology.      *      * @param year  the year to create a transition for, not null      * @return the transition instance, not null      */     public ZoneOffsetTransition createTransition(int year) {         LocalDate date;         if (dom &lt; 0) {             date = LocalDate.of(year, month, month.length(IsoChronology.INSTANCE.isLeapYear(year)) + 1 + dom);             if (dow != null) {                 date = date.with(previousOrSame(dow));             }         } else {             date = LocalDate.of(year, month, dom);             if (dow != null) {                 date = date.with(nextOrSame(dow));             }         }         if (timeEndOfDay) {             date = date.plusDays(1);         }         LocalDateTime localDT = LocalDateTime.of(date, time);         LocalDateTime transition = timeDefinition.createDateTime(localDT, standardOffset, offsetBefore);         return new ZoneOffsetTransition(transition, offsetBefore, offsetAfter);     }      //-----------------------------------------------------------------------     /**      * Checks if this object equals another.      *       * The entire state of the object is compared.      *      * @param otherRule  the other object to compare to, null returns false      * @return true if equal      */     @Override     public boolean equals(Object otherRule) {         if (otherRule == this) {             return true;         }         if (otherRule instanceof ZoneOffsetTransitionRule) {             ZoneOffsetTransitionRule other = (ZoneOffsetTransitionRule) otherRule;             return month == other.month &amp;&amp; dom == other.dom &amp;&amp; dow == other.dow &amp;&amp;                 timeDefinition == other.timeDefinition &amp;&amp;                 time.equals(other.time) &amp;&amp;                 timeEndOfDay == other.timeEndOfDay &amp;&amp;                 standardOffset.equals(other.standardOffset) &amp;&amp;                 offsetBefore.equals(other.offsetBefore) &amp;&amp;                 offsetAfter.equals(other.offsetAfter);         }         return false;     }      /**      * Returns a suitable hash code.      *      * @return the hash code      */     @Override     public int hashCode() {         int hash = ((time.toSecondOfDay() + (timeEndOfDay ? 1 : 0)) &lt;&lt; 15) +                 (month.ordinal() &lt;&lt; 11) + ((dom + 32) &lt;&lt; 5) +                 ((dow == null ? 7 : dow.ordinal()) &lt;&lt; 2) + (timeDefinition.ordinal());         return hash ^ standardOffset.hashCode() ^                 offsetBefore.hashCode() ^ offsetAfter.hashCode();     }      //-----------------------------------------------------------------------     /**      * Returns a string describing this object.      *      * @return a string for debugging, not null      */     @Override     public String toString() {         StringBuilder buf = new StringBuilder();         buf.append(&quot;TransitionRule[&quot;)             .append(offsetBefore.compareTo(offsetAfter) &gt; 0 ? &quot;Gap &quot; : &quot;Overlap &quot;)             .append(offsetBefore).append(&quot; to &quot;).append(offsetAfter).append(&quot;, &quot;);         if (dow != null) {             if (dom == -1) {                 buf.append(dow.name()).append(&quot; on or before last day of &quot;).append(month.name());             } else if (dom &lt; 0) {                 buf.append(dow.name()).append(&quot; on or before last day minus &quot;).append(-dom - 1).append(&quot; of &quot;).append(month.name());             } else {                 buf.append(dow.name()).append(&quot; on or after &quot;).append(month.name()).append(' ').append(dom);             }         } else {             buf.append(month.name()).append(' ').append(dom);         }         buf.append(&quot; at &quot;).append(timeEndOfDay ? &quot;24:00&quot; : time.toString())             .append(&quot; &quot;).append(timeDefinition)             .append(&quot;, standard offset &quot;).append(standardOffset)             .append(']');         return buf.toString();     }      //-----------------------------------------------------------------------     /**      * A definition of the way a local time can be converted to the actual      * transition date-time.      *       * Time zone rules are expressed in one of three ways:      *       * Relative to UTC      * Relative to the standard offset in force      * Relative to the wall offset (what you would see on a clock on the wall)      *       */     public static enum TimeDefinition {         /** The local date-time is expressed in terms of the UTC offset. */         UTC,         /** The local date-time is expressed in terms of the wall offset. */         WALL,         /** The local date-time is expressed in terms of the standard offset. */         STANDARD;          /**          * Converts the specified local date-time to the local date-time actually          * seen on a wall clock.          *           * This method converts using the type of this enum.          * The output is defined relative to the 'before' offset of the transition.          *           * The UTC type uses the UTC offset.          * The STANDARD type uses the standard offset.          * The WALL type returns the input date-time.          * The result is intended for use with the wall-offset.          *          * @param dateTime  the local date-time, not null          * @param standardOffset  the standard offset, not null          * @param wallOffset  the wall offset, not null          * @return the date-time relative to the wall/before offset, not null          */         public LocalDateTime createDateTime(LocalDateTime dateTime, ZoneOffset standardOffset, ZoneOffset wallOffset) {             switch (this) {                 case UTC: {                     int difference = wallOffset.getTotalSeconds() - ZoneOffset.UTC.getTotalSeconds();                     return dateTime.plusSeconds(difference);                 }                 case STANDARD: {                     int difference = wallOffset.getTotalSeconds() - standardOffset.getTotalSeconds();                     return dateTime.plusSeconds(difference);                 }                 default:  // WALL                     return dateTime;             }         }     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13034</td>
    <td align="left">https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/java.base/share/classes/java/time/zone/ZoneOffsetTransitionRule.java/#L100-L632</td>
    <td align="right">1</td>
    <td align="right">2073</td>
    <td align="right">13034</td>
  </tr>
  <tr valign="top">
    <td align="right">1919</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;faces-config-propertyType&quot;, propOrder = {     &quot;descriptions&quot;,     &quot;displayNames&quot;,     &quot;icon&quot;,     &quot;propertyName&quot;,     &quot;propertyClass&quot;,     &quot;defaultValue&quot;,     &quot;suggestedValue&quot;,     &quot;propertyExtension&quot; }) public class FacesProperty {      @XmlTransient     protected TextMap description = new TextMap();     @XmlTransient     protected TextMap displayName = new TextMap();     @XmlElement(name = &quot;icon&quot;, required = true)     protected LocalCollection icon = new LocalCollection();     @XmlElement(name = &quot;property-name&quot;, required = true)     protected java.lang.String propertyName;     @XmlElement(name = &quot;property-class&quot;, required = true)     protected java.lang.String propertyClass;     @XmlElement(name = &quot;default-value&quot;)     protected java.lang.String defaultValue;     @XmlElement(name = &quot;suggested-value&quot;)     protected java.lang.String suggestedValue;     @XmlElement(name = &quot;property-extension&quot;)     protected List propertyExtension;     @XmlAttribute     @XmlJavaTypeAdapter(CollapsedStringAdapter.class)     @XmlID     @XmlSchemaType(name = &quot;ID&quot;)     protected java.lang.String id;      @XmlElement(name = &quot;description&quot;, required = true)     public Text[] getDescriptions() {         return description.toArray();     }      public void setDescriptions(Text[] text) {         description.set(text);     }      public String getDescription() {         return description.get();     }      @XmlElement(name = &quot;display-name&quot;, required = true)     public Text[] getDisplayNames() {         return displayName.toArray();     }      public void setDisplayNames(Text[] text) {         displayName.set(text);     }      public String getDisplayName() {         return displayName.get();     }      public Collection getIcons() {         if (icon == null) {             icon = new LocalCollection();         }         return icon;     }      public Map getIconMap() {         if (icon == null) {             icon = new LocalCollection();         }         return icon.toMap();     }      public Icon getIcon() {         return icon.getLocal();     }      /**      * Gets the value of the propertyName property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getPropertyName() {         return propertyName;     }      /**      * Sets the value of the propertyName property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setPropertyName(java.lang.String value) {         this.propertyName = value;     }      /**      * Gets the value of the propertyClass property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getPropertyClass() {         return propertyClass;     }      /**      * Sets the value of the propertyClass property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setPropertyClass(java.lang.String value) {         this.propertyClass = value;     }      /**      * Gets the value of the defaultValue property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getDefaultValue() {         return defaultValue;     }      /**      * Sets the value of the defaultValue property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setDefaultValue(java.lang.String value) {         this.defaultValue = value;     }      /**      * Gets the value of the suggestedValue property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getSuggestedValue() {         return suggestedValue;     }      /**      * Sets the value of the suggestedValue property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setSuggestedValue(java.lang.String value) {         this.suggestedValue = value;     }      /**      * Gets the value of the propertyExtension property.      *       *       * This accessor method returns a reference to the live list,      * not a snapshot. Therefore any modification you make to the      * returned list will be present inside the JAXB object.      * This is why there is not a set method for the propertyExtension property.      *       *       * For example, to add a new item, do as follows:      *       *    getPropertyExtension().add(newItem);      *       *       *       *       * Objects of the following type(s) are allowed in the list      * {@link FacesPropertyExtension }      *       *       */     public List getPropertyExtension() {         if (propertyExtension == null) {             propertyExtension = new ArrayList();         }         return this.propertyExtension;     }      /**      * Gets the value of the id property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getId() {         return id;     }      /**      * Sets the value of the id property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setId(java.lang.String value) {         this.id = value;     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12412</td>
    <td align="left">https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/container/openejb-jee/src/main/java/org/apache/openejb/jee/FacesProperty.java/#L70-L298</td>
    <td align="right">1</td>
    <td align="right">1919</td>
    <td align="right">12412</td>
  </tr>
  <tr valign="top">
    <td align="right">2159</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class KerningRecord implements IDataType {     private int code1;     private int code2;     private int adjustment;      /**      * @return the code1      */     public int getCode1()     {         return code1;     }      /**      * @param code1 the code1 to set      */     public void setCode1(int code1)     {         this.code1 = code1;     }      /**      * @return the code2      */     public int getCode2()     {         return code2;     }      /**      * @param code2 the code2 to set      */     public void setCode2(int code2)     {         this.code2 = code2;     }      /**      * @return the adjustment      */     public int getAdjustment()     {         return adjustment;     }      /**      * @param adjustment the adjustment to set      */     public void setAdjustment(int adjustment)     {         this.adjustment = adjustment;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13318</td>
    <td align="left">https://github.com/apache/royale-compiler/blob/fbd9bc3b9e48c80dbd8c1d32a6f83221e314efdd/compiler/src/main/java/org/apache/royale/swf/types/KerningRecord.java/#L30-L83</td>
    <td align="right">1</td>
    <td align="right">2159</td>
    <td align="right">13318</td>
  </tr>
  <tr valign="top">
    <td align="right">2691</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;output&quot;: &quot;YES, I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       {         &quot;1&quot;: &quot;Data Class&quot;       },       {         &quot;2&quot;: &quot;Long Method&quot;       }     ]   } </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class ScanOptions extends CommonOpts {      @Parameter(names = &quot;-s&quot;, description = &quot;Start row (inclusive) of scan&quot;)     private String startRow;      @Parameter(names = &quot;-e&quot;, description = &quot;End row (inclusive) of scan&quot;)     private String endRow;      @Parameter(names = &quot;-c&quot;, description = &quot;Columns of scan in comma separated format: &quot;         + &quot;&lt;[:]{,[:]}&gt; &quot;)     private List columns;      @Parameter(names = &quot;-r&quot;, description = &quot;Exact row to scan&quot;)     private String exactRow;      @Parameter(names = &quot;-p&quot;, description = &quot;Row prefix to scan&quot;)     private String rowPrefix;      @Parameter(names = {&quot;-esc&quot;, &quot;--escape-non-ascii&quot;}, help = true,         description = &quot;Hex encode non ascii bytes&quot;, arity = 1)     public boolean hexEncNonAscii = true;      @Parameter(names = &quot;--raw&quot;, help = true,         description = &quot;Show underlying key/values stored in Accumulo. Interprets the data using Fluo &quot;             + &quot;internal schema, making it easier to comprehend.&quot;)     public boolean scanAccumuloTable = false;      @Parameter(names = &quot;--json&quot;, help = true,         description = &quot;Export key/values stored in Accumulo as JSON file.&quot;)     public boolean exportAsJson = false;      @Parameter(names = &quot;--ntfy&quot;, help = true, description = &quot;Scan active notifications&quot;)     public boolean scanNtfy = false;      public String getStartRow() {       return startRow;     }      public String getEndRow() {       return endRow;     }      public String getExactRow() {       return exactRow;     }      public String getRowPrefix() {       return rowPrefix;     }      public List getColumns() {       if (columns == null) {         return Collections.emptyList();       }       return columns;     }      /**      * Check if the parameters informed can be used together.      */     private void checkScanOptions() {       if (this.scanAccumuloTable &amp;&amp; this.exportAsJson) {         throw new IllegalArgumentException(             &quot;Both \&quot;--raw\&quot; and \&quot;--json\&quot; can not be set together.&quot;);       }        if (this.scanAccumuloTable &amp;&amp; this.scanNtfy) {         throw new IllegalArgumentException(             &quot;Both \&quot;--raw\&quot; and \&quot;--ntfy\&quot; can not be set together.&quot;);       }     }      public ScanUtil.ScanOpts getScanOpts() {       EnumSet flags = EnumSet.noneOf(ScanFlags.class);        ScanUtil.setFlag(flags, help, ScanFlags.HELP);       ScanUtil.setFlag(flags, hexEncNonAscii, ScanFlags.HEX);       ScanUtil.setFlag(flags, scanAccumuloTable, ScanFlags.ACCUMULO);       ScanUtil.setFlag(flags, exportAsJson, ScanFlags.JSON);       ScanUtil.setFlag(flags, scanNtfy, ScanFlags.NTFY);        return new ScanUtil.ScanOpts(startRow, endRow, columns, exactRow, rowPrefix, flags);     }      public static ScanOptions parse(String[] args) {       ScanOptions opts = new ScanOptions();       parse(&quot;fluo scan&quot;, opts, args);       return opts;     }   }</td>
    <td align="left">data class</td>
    <td align="left">1: data class, 2: long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;2: long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15300</td>
    <td align="left">https://github.com/apache/fluo/blob/8e06204d4167651e2d3b5219b8c1397644e6ba6e/modules/command/src/main/java/org/apache/fluo/command/FluoScan.java/#L33-L122</td>
    <td align="right">1</td>
    <td align="right">2691</td>
    <td align="right">15300</td>
  </tr>
  <tr valign="top">
    <td align="right">1376</td>
    <td align="left">{       &quot;response&quot;: &quot;YES I found bad smells the bad smells are:&quot;,       &quot;detected_bad_smells&quot;: [           &quot;1. Data Class&quot;       ]   }  </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
/*package*/ class WafFolderContent {   private final WafFolder rootFolder;   private final List subFolders;   private final List files;    /**    * Creates instance of the folder content.    * @param rootFolder root folder    * @param subFolders sub folders    * @param files files    */   public WafFolderContent(WafFolder rootFolder, List subFolders, List files) {     this.rootFolder = rootFolder;     this.subFolders = subFolders;     this.files = files;   }    /**    * Gets root folder.    * @return root folder    */   public WafFolder getRootFolder() {     return rootFolder;   }    /**    * Gets sub folders.    * @return sub folders    */   public List getSubFolders() {     return subFolders;   }    /**    * Gets files.    * @return files    */   public List getFiles() {     return files;   }       }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10810</td>
    <td align="left">https://github.com/Esri/geoportal-server-harvester/blob/b8c69260e3d6ec10df6514c201219e690cfba048/geoportal-connectors/geoportal-harvester-waf/src/main/java/com/esri/geoportal/harvester/waf/WafFolderContent.java/#L23-L65</td>
    <td align="right">1</td>
    <td align="right">1376</td>
    <td align="right">10810</td>
  </tr>
  <tr valign="top">
    <td align="right">933</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES, I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class NewItemFinishEvent extends NewItemEvent {          private static final String EVENT_DESCRIPTION = &quot;finish&quot;;          private Serializable result;          public NewItemFinishEvent(final T item, final AjaxRequestTarget target) {             super(item, target);         }          @Override         public String getEventDescription() {             return NewItemFinishEvent.EVENT_DESCRIPTION;         }          public NewItemFinishEvent setResult(final Serializable result) {             this.result = result;             return this;         }          public Serializable getResult() {             return result;         }     }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8372</td>
    <td align="left">https://github.com/apache/syncope/blob/114c412afbfba24ffb4fbc804e5308a823a16a78/client/idrepo/ui/src/main/java/org/apache/syncope/client/ui/commons/wizards/AjaxWizard.java/#L344-L367</td>
    <td align="right">1</td>
    <td align="right">933</td>
    <td align="right">8372</td>
  </tr>
  <tr valign="top">
    <td align="right">2061</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells the bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Capability implements IConvertible {     private String virtualCores;      private String memorySize;      private String memory;      public String getVirtualCores() {         return virtualCores;     }      public void setVirtualCores(String virtualCores) {         this.virtualCores = virtualCores;     }      public String getMemorySize() {         return memorySize;     }      public void setMemorySize(String memorySize) {         this.memorySize = memorySize;     }      public String getMemory() {         return memory;     }      public void setMemory(String memory) {         this.memory = memory;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">&nbsp; </td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">12970</td>
    <td align="left">https://github.com/Microsoft/azure-tools-for-java/blob/d121e8ac9cc3ab400e5b49c8b372280ae332f3fb/Utils/hdinsight-node-common/src/com/microsoft/azure/hdinsight/sdk/rest/yarn/rm/Capability.java/#L26-L56</td>
    <td align="right">1</td>
    <td align="right">2061</td>
    <td align="right">12970</td>
  </tr>
  <tr valign="top">
    <td align="right">1108</td>
    <td align="left">&nbsp;&nbsp;{&quot;answer&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}  </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TableAliasImpl extends SQLSyntaxElementBase     implements TableAlias {     private final String _tableAlias;      private final ColumnNameList _columnAliases;      public TableAliasImpl( SQLProcessorAggregator processor, String tableAlias, ColumnNameList columnNames )     {         this( processor, TableAlias.class, tableAlias, columnNames );     }      protected TableAliasImpl( SQLProcessorAggregator processor, Class implementingClass,                               String tableAlias, ColumnNameList columnNames )     {         super( processor, implementingClass );         Objects.requireNonNull( tableAlias, &quot;table alias table name&quot; );         this._tableAlias = tableAlias;         this._columnAliases = columnNames;     }      public ColumnNameList getColumnAliases()     {         return this._columnAliases;     }      public String getTableAlias()     {         return this._tableAlias;     }      @Override     protected boolean doesEqual( TableAlias another )     {         return this._tableAlias.equals( another.getTableAlias() )                &amp;&amp; bothNullOrEquals( this._columnAliases, another.getColumnAliases() );     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9882</td>
    <td align="left">https://github.com/apache/attic-polygene-java/blob/031beef870302a0bd01bd5895ce849e00f2d5d5b/libraries/sql-generator/src/main/java/org/apache/polygene/library/sql/generator/implementation/grammar/query/TableAliasImpl.java/#L31-L68</td>
    <td align="right">1</td>
    <td align="right">1108</td>
    <td align="right">9882</td>
  </tr>
  <tr valign="top">
    <td align="right">990</td>
    <td align="left">YES I found bad smells, the bad smells are: 1. Long method, 2. Data class</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
    private static class MigrationLink {         int source;         int target;         Migration[] migrations;         public MigrationLink(int source, int target, Migration[] migrations) {             this.source = source;             this.target = target;             this.migrations = migrations;         }     }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method, 2 Data class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">. Long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9019</td>
    <td align="left">https://github.com/apache/ode/blob/b2ddc6436891f84f716ffcbed8c1cd1e374bd805/bpel-runtime/src/main/java/org/apache/ode/bpel/engine/migration/MigrationHandler.java/#L113-L122</td>
    <td align="right">2</td>
    <td align="right">990</td>
    <td align="right">9019</td>
  </tr>
  <tr valign="top">
    <td align="right">1134</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class JdbVariable implements Variable {   private final LocalVariable jdiVariable;   private final SimpleValue value;    public JdbVariable(StackFrame jdiStackFrame, LocalVariable jdiVariable) {     Value jdiValue = jdiStackFrame.getValue(jdiVariable);      this.jdiVariable = jdiVariable;     this.value = jdiValue == null ? new JdbNullValue() : new JdbValue(jdiValue, getVariablePath());   }    public JdbVariable(SimpleValue value, LocalVariable jdiVariable) {     this.jdiVariable = jdiVariable;     this.value = value;   }    @Override   public String getName() {     return jdiVariable.name();   }    @Override   public boolean isPrimitive() {     return JdbType.isPrimitive(jdiVariable.signature());   }    @Override   public SimpleValue getValue() {     return value;   }    @Override   public String getType() {     return jdiVariable.typeName();   }    @Override   public VariablePath getVariablePath() {     return new VariablePathImpl(getName());   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10054</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/plugins/plugin-java-debugger/che-plugin-java-debugger-server/src/main/java/org/eclipse/che/plugin/jdb/server/model/JdbVariable.java/#L27-L67</td>
    <td align="right">1</td>
    <td align="right">1134</td>
    <td align="right">10054</td>
  </tr>
  <tr valign="top">
    <td align="right">1685</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MultiDexConfig {      private String name;      public MultiDexConfig(String name) {         this.name = name;     }      @Config(title = &quot;Whether to enable fast&quot;, message = &quot;Enable atlas , true/false&quot;, order = 0, group = &quot;atlas&quot;)     private boolean fastMultiDex = false;      @Config(title = &quot;The extra first dex class list&quot;, message = &quot;The custom needs to be placed in the entry class in the first dex&quot;, order = 3, group = &quot;atlas&quot;)     private Set firstDexClasses = Sets.newHashSet();     /**      * dex The number of subcontracting, 0 No restrictions, no two merges      */     @Config(title = &quot;dexThe number of&quot;, message = &quot;0unlimited&quot;, order = 1, group = &quot;atlas&quot;)     private int dexCount;      public int getMainDexListCount() {         return mainDexListCount;     }      public void setMainDexListCount(int mainDexListCount) {         this.mainDexListCount = mainDexListCount;     }      private int mainDexListCount;      @Config(title = &quot;dexSeparated rules&quot;, message = &quot;a,b;c,d&quot;, order = 2, group = &quot;atlas&quot;)     private String dexSplitRules;      @Config(title = &quot;Does not enter the list of the first dex's blacklist&quot;, message = &quot;a&quot;, order = 2, group = &quot;atlas&quot;)     private Set mainDexBlackList = Sets.newHashSet();      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public boolean isFastMultiDex() {         return fastMultiDex;     }      public void setFastMultiDex(boolean fastMultiDex) {         this.fastMultiDex = fastMultiDex;     }      public Set getMainDexBlackList() {         return mainDexBlackList;     }      public void setMainDexBlackList(Set mainDexBlackList) {         this.mainDexBlackList = mainDexBlackList;     }      public Set getFirstDexClasses() {         return firstDexClasses;     }      public void setFirstDexClasses(Set firstDexClasses) {         this.firstDexClasses = firstDexClasses;     }      public int getDexCount() {         return dexCount;     }      public void setDexCount(int dexCount) {         this.dexCount = dexCount;     }      public String getDexSplitRules() {         return dexSplitRules;     }      public void setDexSplitRules(String dexSplitRules) {         this.dexSplitRules = dexSplitRules;     } }</td>
    <td align="left">data class</td>
    <td align="left">Blob, Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">Blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11686</td>
    <td align="left">https://github.com/alibaba/atlas/blob/e8c7b3f1ff14b2a1df64321c6992b796cae7d732/atlas-gradle-plugin/atlas-plugin/src/main/java/com/taobao/android/builder/extension/MultiDexConfig.java/#L220-L302</td>
    <td align="right">1</td>
    <td align="right">1685</td>
    <td align="right">11686</td>
  </tr>
  <tr valign="top">
    <td align="right">79</td>
    <td align="left">&nbsp;	{ 	    &quot;response&quot;: &quot;YES I found bad smells&quot;, 	    &quot;bad smells are&quot;: [ 	        &quot;Long Method&quot;, 	        &quot;Data Class&quot; 	    ] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private final static class DuplicatableProgressTrackingInputStream             extends ProgressTrackingInputStream implements DuplicatableInputStream {          private DuplicatableProgressTrackingInputStream(                 final InputStream source, final ProgressTracker progressTracker) {             super(source, progressTracker);              if (!(source instanceof DuplicatableInputStream)) {                 throw new IllegalStateException(&quot;Source MUST be a DuplicatableInputStream&quot;);             }         }          /**          * The progress tracking input stream resulting from this call will re-use the progress tracker from the parent          * progress tracking input stream after resetting it, thus invalidating the progress tracked by the parent          * stream until now. To ensure correctness of the progress tracking functionality, do NOT read from the parent          * stream after duplicating from it.          * @return The duplicated progress tracking input stream.          */         @Override         public InputStream duplicate() {             return ProgressTrackingInputStreamFactory.create(                     ((DuplicatableInputStream) getSource()).duplicate(),                     getProgressTracker().reset());         }     }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1169</td>
    <td align="left">https://github.com/oracle/oci-java-sdk/blob/76e9cecd7b309d9f12e5efe96c74167c66a98872/bmc-objectstorage/bmc-objectstorage-extensions/src/main/java/com/oracle/bmc/objectstorage/transfer/ProgressTrackingInputStreamFactory.java/#L95-L120</td>
    <td align="right">1</td>
    <td align="right">79</td>
    <td align="right">1169</td>
  </tr>
  <tr valign="top">
    <td align="right">991</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class BaseColumnInfo implements Serializable {      /**      * Serial version id.      */     private static final long serialVersionUID = 1L;      /**      * The table and alias info encapsulated in a different class.      */     private TableAliasInfo tabAlias;      /**      * The metastore column information. The column can be null      * and that denotes that the expression is dependent on the row      * of the table and not particular column. This can happen in case      * of count(1).      */     private FieldSchema column;      /**      * @return the tabAlias      */     public TableAliasInfo getTabAlias() {       return tabAlias;     }      /**      * @param tabAlias the tabAlias to set      */     public void setTabAlias(TableAliasInfo tabAlias) {       this.tabAlias = tabAlias;     }      /**      * @return the column      */     public FieldSchema getColumn() {       return column;     }      /**      * @param column the column to set      */     public void setColumn(FieldSchema column) {       this.column = column;     }      @Override     public String toString() {       return tabAlias + &quot;:&quot; + column;     }      @Override     public int hashCode() {       return (column != null ? column.hashCode() : 7)         + (tabAlias != null ? tabAlias.hashCode() : 11);     }      @Override     public boolean equals(Object obj) {       if (this == obj) {         return true;       }       if (!(obj instanceof BaseColumnInfo)) {         return false;       }       BaseColumnInfo ci = (BaseColumnInfo) obj;       return (column == null ? ci.column == null : column.equals(ci.column))         &amp;&amp; (tabAlias == null ? ci.tabAlias == null : tabAlias.equals(ci.tabAlias));     }   }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9033</td>
    <td align="left">https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/ql/src/java/org/apache/hadoop/hive/ql/hooks/LineageInfo.java/#L217-L288</td>
    <td align="right">1</td>
    <td align="right">991</td>
    <td align="right">9033</td>
  </tr>
  <tr valign="top">
    <td align="right">730</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;1. Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class RealRowResultSetStatistics  	extends RealNoPutResultSetStatistics {  	/* Leave these fields public for object inspectors */ 	public int rowsReturned;  	// CONSTRUCTORS 	/** 	 *  	 * 	 */     public	RealRowResultSetStatistics( 										int numOpens, 										int rowsSeen, 										int rowsFiltered, 										long constructorTime, 										long openTime, 										long nextTime, 										long closeTime, 										int resultSetNumber, 										int rowsReturned, 										double optimizerEstimatedRowCount, 										double optimizerEstimatedCost 									) 	{ 		super( 			numOpens, 			rowsSeen, 			rowsFiltered, 			constructorTime, 			openTime, 			nextTime, 			closeTime, 			resultSetNumber, 			optimizerEstimatedRowCount, 			optimizerEstimatedCost 			); 		this.rowsReturned = rowsReturned; 	}  	// ResultSetStatistics methods  	/** 	 * Return the statement execution plan as a String. 	 * 	 * @param depth	Indentation level. 	 * 	 * @return String	The statement execution plan as a String. 	 */ 	public String getStatementExecutionPlanText(int depth) 	{ 		initFormatInfo(depth);  		return 			indent + MessageService.getTextMessage(SQLState.RTS_ROW_RS) + 				&quot;:\n&quot; + 			indent + MessageService.getTextMessage(SQLState.RTS_NUM_OPENS) + 				&quot; = &quot; + numOpens + &quot;\n&quot; + 			indent + MessageService.getTextMessage( 												SQLState.RTS_ROWS_RETURNED) + 				&quot; = &quot; + rowsReturned + &quot;\n&quot; + 			dumpTimeStats(indent, subIndent) + &quot;\n&quot; + 			dumpEstimatedCosts(subIndent) + &quot;\n&quot;; 	}  	/** 	 * Return information on the scan nodes from the statement execution  	 * plan as a String. 	 * 	 * @param depth	Indentation level. 	 * @param tableName if not NULL then print information for this table only 	 * 	 * @return String	The information on the scan nodes from the  	 *					statement execution plan as a String. 	 */ 	public String getScanStatisticsText(String tableName, int depth) 	{ 		return &quot;&quot;; 	}    	// Class implementation 	 	public String toString() 	{ 		return getStatementExecutionPlanText(0); 	} 	/**    * Format for display, a name for this node. 	 * 	 */   public String getNodeName(){     return MessageService.getTextMessage(SQLState.RTS_ROW_RS);   }      // -----------------------------------------------------   // XPLAINable Implementation   // -----------------------------------------------------        public void accept(XPLAINVisitor visitor) {                  // I have no children, inform my visitor about that         visitor.setNumberOfChildren(0);         // pre-order, depth-first traversal         // me first         visitor.visit(this);         // I'm a leaf node, I have no children ...              }      public String getRSXplainType() { return XPLAINUtil.OP_ROW; }     public Object getResultSetDescriptor(Object rsID, Object parentID,             Object scanID, Object sortID, Object stmtID, Object timingID)     {         return new XPLAINResultSetDescriptor(            (UUID)rsID,            getRSXplainType(),            getRSXplainDetails(),            this.numOpens,            null,                              // the number of index updates             null,                           // lock mode            null,                           // lock granularity            (UUID)parentID,            this.optimizerEstimatedRowCount,            this.optimizerEstimatedCost,            null,                              // the affected rows            null,                              // the deferred rows            null,                              // the input rows            this.rowsSeen,            null,                              // the seen rows right            this.rowsFiltered,            this.rowsReturned,            null,                              // the empty right rows            null,                           // index key optimization            (UUID)scanID,            (UUID)sortID,            (UUID)stmtID,            (UUID)timingID);     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6866</td>
    <td align="left">https://github.com/apache/derby/blob/bd246fc89d4fce3f82f8344074ecb8a4713418df/java/org.apache.derby.engine/org/apache/derby/impl/sql/execute/rts/RealRowResultSetStatistics.java/#L46-L187</td>
    <td align="right">1</td>
    <td align="right">730</td>
    <td align="right">6866</td>
  </tr>
  <tr valign="top">
    <td align="right">3855</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Long Method&quot;,       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private class MouseObservationEvent extends ObservationEvent     {         private int deltaX;         private int deltaY;         private int deltaZ;          public MouseObservationEvent(int deltaX, int deltaY, int deltaZ)         {             super();             this.deltaX = deltaX;             this.deltaY = deltaY;             this.deltaZ = deltaZ;         }          @Override         public JsonObject getJSON()         {             JsonObject jsonEvent = new JsonObject();             jsonEvent.addProperty(&quot;time&quot;, this.timestamp);             jsonEvent.addProperty(&quot;type&quot;, &quot;mouse&quot;);             jsonEvent.addProperty(&quot;deltaX&quot;, this.deltaX);             jsonEvent.addProperty(&quot;deltaY&quot;, this.deltaY);             jsonEvent.addProperty(&quot;deltaZ&quot;, this.deltaZ);             return jsonEvent;         }     }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10011</td>
    <td align="left">https://github.com/Microsoft/malmo/blob/91b1a7a01ec0dd883f81a51048badac0398695f7/Minecraft/src/main/java/com/microsoft/Malmo/MissionHandlers/ObservationFromHumanImplementation.java/#L29-L54</td>
    <td align="right">1</td>
    <td align="right">3855</td>
    <td align="right">10011</td>
  </tr>
  <tr valign="top">
    <td align="right">4237</td>
    <td align="left">&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detectedBadSmells&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Subchannel extends Pipe { 	/** 	 *  	 * Number of fuel rods contained within. 	 *  	 *  	 */ 	private int numRods;  	/** 	 *  	 * Diameter of the subchannel fuel rods (this assumes uniform rod sizes). 	 *  	 *  	 */ 	private double rodDiameter;  	/** 	 *  	 * Pitch of the fuel rod bundle (distance between adjacent rod centers). 	 *  	 *  	 */ 	private double pitch;  	/** 	 *  	 * Nullary constructor. 	 *  	 *  	 */ 	public Subchannel() {  		// Set the name, description and ID. 		setName(&quot;Subchannel 1&quot;); 		setDescription(&quot;A subchannel plant component for reactors&quot;); 		setId(1);  		// Set the default number of rods, rod diameter and pitch. 		setNumRods(1); 		setRodDiameter(1.0); 		setPitch(1.5); 		// Note: Pitch must always be set after diameter, as setPitch method 		// checks that pitch &gt;= rodDiameter.  		return; 	}  	/** 	 *  	 * Parameterized constructor. 	 *  	 *  	 * @param numRods 	 *             	 *            Number of rods contained. 	 *             	 * @param rodDiameter 	 *             	 *            Diameter of the (uniformly-sized) fuel rods. 	 *             	 * @param pitch 	 *             	 *            Pitch of the fuel rods. 	 *             	 */ 	public Subchannel(int numRods, double rodDiameter, double pitch) {  		// Set the name, description and ID. 		setName(&quot;Subchannel 1&quot;); 		setDescription(&quot;A subchannel plant component for reactors&quot;); 		setId(1);  		// Set the default number of rods, rod diameter and pitch. 		setNumRods(numRods); 		setRodDiameter(rodDiameter); 		setPitch(pitch);  		return; 	}  	/** 	 * @return the numRods 	 */ 	public int getNumRods() { 		return numRods; 	}  	/** 	 * @param numRods 	 *            the numRods to set 	 */ 	public void setNumRods(int numRods) {  		// Check the input is valid. 		if (numRods &gt;= 1) { 			this.numRods = numRods; 		} else { 			throw new InvalidParameterException(&quot;Subchannel error: The number &quot; 					+ &quot;of rods must greater than or equal to 1.&quot;); 		} 		return; 	}  	/** 	 * @return the rodDiameter 	 */ 	public double getRodDiameter() { 		return rodDiameter; 	}  	/** 	 * @param rodDiameter 	 *            the rodDiameter to set 	 */ 	public void setRodDiameter(double rodDiameter) {  		// Check the input is valid. 		if (rodDiameter &gt; 0) { 			this.rodDiameter = rodDiameter; 		} else { 			throw new InvalidParameterException(&quot;Subchannel error: The rod &quot; 					+ &quot;diameter must be non-negative.&quot;); 		} 		return; 	}  	/** 	 * @return the pitch 	 */ 	public double getPitch() { 		return pitch; 	}  	/** 	 * @param pitch 	 *            the pitch to set 	 */ 	public void setPitch(double pitch) {  		// Check that the input is valid. 		if (pitch &gt;= rodDiameter) { 			this.pitch = pitch; 		} else { 			throw new InvalidParameterException(&quot;Subchannel error: The rod &quot; 					+ &quot;pitch cannot be smaller than the rod diameter.&quot;); 		} 	}  	/** 	 *  	 * Performs an equality check between two Objects. 	 *  	 *  	 * @param otherObject 	 *             	 *            The other Object to compare against. 	 *             	 * @return  	 *         Returns true if the two objects are equal, otherwise false. 	 *          	 */ 	@Override 	public boolean equals(Object otherObject) {  		// By default, the objects are not equivalent. 		boolean equals = false;  		// Check the reference. 		if (this == otherObject) { 			equals = true; 		} 		// Check the information stored in the other object. 		else if (otherObject != null &amp;&amp; otherObject instanceof Subchannel) {  			// Cast the other object. 			Subchannel component = (Subchannel) otherObject;  			// Compare all the variables. (Save the biggest for last; Java 			// should 			// short-circuit the logical operators as soon as a mismatch is 			// found) 			equals = (super.equals(component) &amp;&amp; numRods == component.numRods 					&amp;&amp; rodDiameter == component.rodDiameter &amp;&amp; pitch == component.pitch); 		}  		return equals; 	}  	/** 	 *  	 * Performs a deep copy and returns a newly instantiated Object. 	 *  	 *  	 * @return  	 *         The newly instantiated Object. 	 *          	 */ 	@Override 	public Object clone() {  		// Initialize a new object. 		Subchannel object = new Subchannel();  		// Copy the contents from this one. 		object.copy(this);  		// Return the newly instantiated object. 		return object; 	}  	/** 	 *  	 * Deep copies the contents of otherObject. 	 *  	 *  	 * @param otherObject 	 *             	 *            The other object to copy the contents from. 	 *             	 */ 	public void copy(Subchannel otherObject) {  		// Check the otherObject is valid. 		if (otherObject == null) { 			return; 		} 		// Copy the other object. 		super.copy(otherObject); 		numRods = otherObject.numRods; 		rodDiameter = otherObject.rodDiameter; 		pitch = otherObject.pitch;  		return; 	}  	/** 	 *  	 * Returns the hashCode of the object. 	 *  	 *  	 * @return  	 *         The hashCode of the Object. 	 *          	 */ 	@Override 	public int hashCode() {  		// Call the super's hashCode. 		int hash = super.hashCode();  		// Add local hashes. 		hash = 31 * hash + numRods; 		hash = 31 * hash + new Double(rodDiameter).hashCode(); 		hash = 31 * hash + new Double(pitch).hashCode();  		return hash; 	}  	/** 	 *  	 * Accepts PlantComponentVisitors to reveal the type of a PlantComponent. 	 *  	 *  	 * @param visitor 	 *             	 *            The PlantComponent's visitor. 	 *             	 */ 	@Override 	public void accept(IPlantComponentVisitor visitor) {  		// Only accept valid visitors. 		if (visitor != null) { 			visitor.visit(this); 		} 		return; 	} }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11155</td>
    <td align="left">https://github.com/eclipse/ice/blob/3f6e0265f5b476ff90a660397ce83992944142c4/org.eclipse.ice.reactor.plant/src/org/eclipse/ice/reactor/plant/Subchannel.java/#L25-L303</td>
    <td align="right">1</td>
    <td align="right">4237</td>
    <td align="right">11155</td>
  </tr>
  <tr valign="top">
    <td align="right">2423</td>
    <td align="left">{       &quot;message&quot;: &quot;YES I found bad smells&quot;,       &quot;bad smells are&quot;: [           &quot;Data Class&quot;       ]   }  </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement(name = &quot;pagedResult&quot;) @XmlType public class PagedResult implements Serializable {      private static final long serialVersionUID = 3472875885259250934L;      private URI prev;      private URI next;      private final List result = new ArrayList&lt;&gt;();      private int page;      private int size;      private int totalCount;      public URI getPrev() {         return prev;     }      public void setPrev(final URI prev) {         this.prev = prev;     }      public URI getNext() {         return next;     }      public void setNext(final URI next) {         this.next = next;     }      @XmlElementWrapper(name = &quot;result&quot;)     @XmlElement(name = &quot;item&quot;)     @JsonProperty(&quot;result&quot;)     @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = &quot;@class&quot;)     public List getResult() {         return result;     }      public int getPage() {         return page;     }      public void setPage(final int page) {         this.page = page;     }      public int getSize() {         return size;     }      public void setSize(final int size) {         this.size = size;     }      public int getTotalCount() {         return totalCount;     }      public void setTotalCount(final int totalCount) {         this.totalCount = totalCount;     }      @Override     public int hashCode() {         return new HashCodeBuilder().                 append(prev).                 append(next).                 append(result).                 append(page).                 append(size).                 append(totalCount).                 build();     }      @Override     public boolean equals(final Object obj) {         if (this == obj) {             return true;         }         if (obj == null) {             return false;         }         if (getClass() != obj.getClass()) {             return false;         }         @SuppressWarnings(&quot;unchecked&quot;)         final PagedResult other = (PagedResult) obj;         return new EqualsBuilder().                 append(prev, other.prev).                 append(next, other.next).                 append(result, other.result).                 append(page, other.page).                 append(size, other.size).                 append(totalCount, other.totalCount).                 build();     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14441</td>
    <td align="left">https://github.com/apache/syncope/blob/114c412afbfba24ffb4fbc804e5308a823a16a78/common/idrepo/lib/src/main/java/org/apache/syncope/common/lib/to/PagedResult.java/#L35-L135</td>
    <td align="right">1</td>
    <td align="right">2423</td>
    <td align="right">14441</td>
  </tr>
  <tr valign="top">
    <td align="right">534</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells the bad smells are: 2. Data class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class HandleConfigDriveIsoCommand extends Command {      @LogLevel(LogLevel.Log4jLevel.Off)     private String isoData;      private String isoFile;     private boolean create = false;     private DataStoreTO destStore;      public HandleConfigDriveIsoCommand(String isoFile, String isoData, DataStoreTO destStore, boolean create) {         this.isoFile = isoFile;         this.isoData = isoData;         this.destStore = destStore;         this.create = create;     }      @Override     public boolean executeInSequence() {         return false;     }      public String getIsoData() {         return isoData;     }      public boolean isCreate() {         return create;     }      public DataStoreTO getDestStore() {         return destStore;     }      public String getIsoFile() {         return isoFile;     } }</td>
    <td align="left">data class</td>
    <td align="left">2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">&nbsp; </td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">5480</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/core/src/main/java/com/cloud/agent/api/HandleConfigDriveIsoCommand.java/#L24-L60</td>
    <td align="right">1</td>
    <td align="right">534</td>
    <td align="right">5480</td>
  </tr>
  <tr valign="top">
    <td align="right">2318</td>
    <td align="left">&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface ReplicatedLevelDBStoreViewMBean {      @MBeanInfo(&quot;The address of the ZooKeeper server.&quot;)     String getZkAddress();     @MBeanInfo(&quot;The path in ZooKeeper to hold master elections.&quot;)     String getZkPath();     @MBeanInfo(&quot;The ZooKeeper session timeout.&quot;)     String getZkSessionTimeout();     @MBeanInfo(&quot;The address and port the master will bind for the replication protocol.&quot;)     String getBind();     @MBeanInfo(&quot;The number of replication nodes that will be part of the replication cluster.&quot;)     int getReplicas();      @MBeanInfo(&quot;The role of this node in the replication cluster.&quot;)     String getNodeRole();      @MBeanInfo(&quot;The replication status.&quot;)     String getStatus();      @MBeanInfo(&quot;The status of the connected slaves.&quot;)     CompositeData[] getSlaves();      @MBeanInfo(&quot;The current position of the replication log.&quot;)     Long getPosition();      @MBeanInfo(&quot;When the last entry was added to the replication log.&quot;)     Long getPositionDate();      @MBeanInfo(&quot;The directory holding the data.&quot;)     String getDirectory();      @MBeanInfo(&quot;The sync strategy to use.&quot;)     String getSync();      @MBeanInfo(&quot;The node id of this replication node.&quot;)     String getNodeId(); }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14124</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-leveldb-store/src/main/java/org/apache/activemq/leveldb/replicated/ReplicatedLevelDBStoreViewMBean.java/#L30-L66</td>
    <td align="right">1</td>
    <td align="right">2318</td>
    <td align="right">14124</td>
  </tr>
  <tr valign="top">
    <td align="right">538</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;1. Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LiteralKey {      private Object value;      private String type;      private String lang;      public LiteralKey(Object value, String type, String lang) {         this.value = value;         this.type = type != null ? type.intern() : null;         this.lang = lang != null ? lang.intern() : null;     }      public String getLang() {         return lang;     }      public String getType() {         return type;     }      public Object getValue() {         return value;     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (o == null || getClass() != o.getClass()) return false;          LiteralKey that = (LiteralKey) o;          if (lang != null ? !lang.equals(that.lang) : that.lang != null) return false;         if (type != null ? !type.equals(that.type) : that.type != null) return false;         return value.equals(that.value);      }      @Override     public int hashCode() {         int result = value.hashCode();         result = 31 * result + (type != null ? type.hashCode() : 0);         result = 31 * result + (lang != null ? lang.hashCode() : 0);         return result;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">&nbsp; </td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">5500</td>
    <td align="left">https://github.com/apache/marmotta/blob/28c9b8b0791ea1693578af302981a1358e56933d/commons/marmotta-commons/src/main/java/org/apache/marmotta/commons/sesame/model/LiteralKey.java/#L25-L71</td>
    <td align="right">1</td>
    <td align="right">538</td>
    <td align="right">5500</td>
  </tr>
  <tr valign="top">
    <td align="right">2140</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class NexmarkQueryTransform     extends PTransform, PCollection&gt; {    private transient PCollection&gt; sideInput = null;    protected NexmarkQueryTransform(String name) {     super(name);   }    /** Whether this query expects a side input to be populated. Defaults to {@code false}. */   public boolean needsSideInput() {     return false;   }    /**    * Set the side input for the query.    *    * Note that due to the nature of side inputs, this instance of the query is now fixed and can    * only be safely applied in the pipeline where the side input was created.    */   public void setSideInput(PCollection&gt; sideInput) {     this.sideInput = sideInput;   }    /** Get the side input, if any. */   public @Nullable PCollection&gt; getSideInput() {     return sideInput;   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13264</td>
    <td align="left">https://github.com/apache/beam/blob/a956ff77a8448e5f2c12f6695fec608348b5ab60/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/NexmarkQueryTransform.java/#L34-L62</td>
    <td align="right">1</td>
    <td align="right">2140</td>
    <td align="right">13264</td>
  </tr>
  <tr valign="top">
    <td align="right">217</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SubProcessCommandLineArgs {    // Parameters to pass to the sub-process   private List parameters = Lists.newArrayList();    public void addCommand(Integer position, String value) {     parameters.add(new Command(position, value));   }    public void putCommand(Command command) {     parameters.add(command);   }    public List getParameters() {     return parameters;   }    /** Class used to store the SubProcces parameters. */   public static class Command {      // The ordinal position of the command to pass to the sub-process     int ordinalPosition;     String value;      @SuppressWarnings(&quot;unused&quot;)     private Command() {}      public Command(int ordinalPosition, String value) {       this.ordinalPosition = ordinalPosition;       this.value = value;     }      public int getKey() {       return ordinalPosition;     }      public void setKey(int key) {       this.ordinalPosition = key;     }      public String getValue() {       return value;     }      public void setValue(String value) {       this.value = value;     }   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2368</td>
    <td align="left">https://github.com/apache/beam/blob/a956ff77a8448e5f2c12f6695fec608348b5ab60/examples/java/src/main/java/org/apache/beam/examples/subprocess/kernel/SubProcessCommandLineArgs.java/#L24-L72</td>
    <td align="right">1</td>
    <td align="right">217</td>
    <td align="right">2368</td>
  </tr>
  <tr valign="top">
    <td align="right">2158</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &quot;message&quot;: &quot;YES I found bad smells. the bad smells are: 1. Long Method, 2. Data Class&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class PartitionDescriptor extends Descriptor {    /** Type token for ser/de partition descriptor list */   private static final Type DESCRIPTOR_LIST_TYPE = new TypeToken&gt;(){}.getType();    @Getter   private final DatasetDescriptor dataset;    public PartitionDescriptor(String name, DatasetDescriptor dataset) {     super(name);     this.dataset = dataset;   }    @Override   public PartitionDescriptor copy() {     return new PartitionDescriptor(getName(), dataset);   }    public PartitionDescriptor copyWithNewDataset(DatasetDescriptor dataset) {     return new PartitionDescriptor(getName(), dataset);   }    @Override   public boolean equals(Object o) {     if (this == o) {       return true;     }     if (o == null || getClass() != o.getClass()) {       return false;     }      PartitionDescriptor that = (PartitionDescriptor) o;     return dataset.equals(that.dataset) &amp;&amp; getName().equals(that.getName());   }    @Override   public int hashCode() {     int result = dataset.hashCode();     result = 31 * result + getName().hashCode();     return result;   }    /**    * Serialize a list of partition descriptors as json string    */   public static String toPartitionJsonList(List descriptors) {     return Descriptor.GSON.toJson(descriptors, DESCRIPTOR_LIST_TYPE);   }    /**    * Deserialize the string, resulted from {@link #toPartitionJsonList(List)}, to a list of partition descriptors    */   public static List fromPartitionJsonList(String jsonList) {     return Descriptor.GSON.fromJson(jsonList, DESCRIPTOR_LIST_TYPE);   } }</td>
    <td align="left">data class</td>
    <td align="left">1. long method, 2. data class </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13316</td>
    <td align="left">https://github.com/apache/incubator-gobblin/blob/b0d130757669a5fed7c368d44f23f8a9c0d3ed4a/gobblin-api/src/main/java/org/apache/gobblin/dataset/PartitionDescriptor.java/#L32-L87</td>
    <td align="right">1</td>
    <td align="right">2158</td>
    <td align="right">13316</td>
  </tr>
  <tr valign="top">
    <td align="right">1978</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SQLDropTableStatement extends SQLStatementImpl implements SQLDropStatement {     private List hints;      protected List tableSources = new ArrayList();      private boolean                    purge;      protected boolean                  cascade      = false;     protected boolean                  restrict     = false;     protected boolean                  ifExists     = false;     private boolean                    temporary    = false;      public SQLDropTableStatement(){      }          public SQLDropTableStatement(String dbType){         super (dbType);     }      public SQLDropTableStatement(SQLName name, String dbType){         this(new SQLExprTableSource(name), dbType);     }          public SQLDropTableStatement(SQLName name){         this (name, null);     }          public SQLDropTableStatement(SQLExprTableSource tableSource){         this (tableSource, null);     }      public SQLDropTableStatement(SQLExprTableSource tableSource, String dbType){         this (dbType);         this.tableSources.add(tableSource);     }      public List getTableSources() {         return tableSources;     }          public void addPartition(SQLExprTableSource tableSource) {         if (tableSource != null) {             tableSource.setParent(this);         }         this.tableSources.add(tableSource);     }      public void setName(SQLName name) {         this.addTableSource(new SQLExprTableSource(name));     }      public void addTableSource(SQLName name) {         this.addTableSource(new SQLExprTableSource(name));     }      public void addTableSource(SQLExprTableSource tableSource) {         tableSources.add(tableSource);     }      @Override     protected void accept0(SQLASTVisitor visitor) {         if (visitor.visit(this)) {             this.acceptChild(visitor, tableSources);         }         visitor.endVisit(this);     }      @Override     public List getChildren() {         return this.tableSources;     }      public boolean isPurge() {         return purge;     }      public void setPurge(boolean purge) {         this.purge = purge;     }      public boolean isIfExists() {         return ifExists;     }      public void setIfExists(boolean ifExists) {         this.ifExists = ifExists;     }      public boolean isCascade() {         return cascade;     }      public void setCascade(boolean cascade) {         this.cascade = cascade;     }      public boolean isRestrict() {         return restrict;     }      public void setRestrict(boolean restrict) {         this.restrict = restrict;     }      public boolean isTemporary() {         return temporary;     }      public void setTemporary(boolean temporary) {         this.temporary = temporary;     }      public List getHints() {         return hints;     }      public void setHints(List hints) {         this.hints = hints;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12631</td>
    <td align="left">https://github.com/alibaba/druid/blob/768469fe4d1340efe1036453366a58c9ab7e30d1/src/main/java/com/alibaba/druid/sql/ast/statement/SQLDropTableStatement.java/#L26-L146</td>
    <td align="right">1</td>
    <td align="right">1978</td>
    <td align="right">12631</td>
  </tr>
  <tr valign="top">
    <td align="right">30</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SignatureSupportingConfigProperties {      private String sharedSecret;     private String keyPath;     private long tokenExpirationSeconds = 600L;     private String certificatePath;      /**      * Gets the secret used for creating and validating HmacSHA256 based signatures.      *       * @return The secret or {@code null} if not set.      */     public final String getSharedSecret() {         return sharedSecret;     }      /**      * Sets the secret to use for creating and validating HmacSHA256 based signatures.      *       * @param secret The shared secret.      * @throws NullPointerException if secret is {@code null}.      * @throws IllegalArgumentException if the secret is &lt; 32 bytes.      */     public final void setSharedSecret(final String secret) {         if (Objects.requireNonNull(secret).getBytes(StandardCharsets.UTF_8).length &lt; 32) {             throw new IllegalArgumentException(&quot;shared secret must be at least 32 bytes&quot;);         }         this.sharedSecret = secret;     }      /**      * Sets the path to the file containing the private key to be used      * for creating SHA256withRSA based signatures.      *       * The file must be in PKCS8 PEM format.      *       * @param keyPath The path to the PEM file.      * @throws NullPointerException if the path is {@code null}.      */     public final void setKeyPath(final String keyPath) {         this.keyPath = Objects.requireNonNull(keyPath);     }      /**      * Gets the path to the file containing the private key to be used      * for validating RSA based signatures.      *       * @return The path to the file or {@code null} if not set.      */     public final String getKeyPath() {         return keyPath;     }      /**      * Gets the period of time after which tokens created using this configuration should expire.      *       * @return The number of seconds after which tokens expire.      */     public final long getTokenExpiration() {         return tokenExpirationSeconds;     }      /**      * Sets the period of time after which tokens created using this configuration should expire.      *       * The default value is 600 seconds (10 minutes).      *       * @param seconds The number of seconds after which tokens expire.      * @throws IllegalArgumentException if seconds is &lt;= 0.      */     public final void setTokenExpiration(final long seconds) {         if (seconds &lt;= 0) {             throw new IllegalArgumentException(&quot;token expiration must be &gt; 0&quot;);         }         this.tokenExpirationSeconds = seconds;     }      /**      * Sets the path to the X.509 certificate containing the public key to be used      * for validating SHA256withRSA based signatures.      *       * The file must be in PKCS8 PEM format.      *       * @param certPath The path to the PEM file.      * @throws NullPointerException if the path is {@code null}.      */     public final void setCertPath(final String certPath) {         this.certificatePath = Objects.requireNonNull(certPath);     }      /**      * Gets the path to the X.509 certificate containing the public key to be used      * for validating RSA based signatures.      *       * @return The path to the file or {@code null} if not set.      */     public final String getCertPath() {         return certificatePath;     }      /**      * Checks if this configuration contains enough information for creating assertions.      *       * @return {@code true} if any of sharedSecret or keyPath is not {@code null}.      */     public final boolean isAppropriateForCreating() {         return sharedSecret != null || keyPath != null;     }      /**      * Checks if this configuration contains enough information for validating assertions.      *       * @return {@code true} if any of sharedSecret or certificatePath is not {@code null}.      */     public final boolean isAppropriateForValidating() {         return sharedSecret != null || certificatePath != null;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">719</td>
    <td align="left">https://github.com/eclipse/hono/blob/ec84947227564c6459801f708bdeabd7687a8bf0/core/src/main/java/org/eclipse/hono/config/SignatureSupportingConfigProperties.java/#L22-L139</td>
    <td align="right">1</td>
    <td align="right">30</td>
    <td align="right">719</td>
  </tr>
  <tr valign="top">
    <td align="right">1212</td>
    <td align="left">&nbsp;	{ 		&quot;message&quot;: &quot;YES I found bad smells&quot;, 		&quot;bad smells are&quot;: [ 			&quot;Data Class&quot;, 			&quot;Long Method&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class AbstractControllerService extends AbstractConfigurableComponent implements ControllerService {      private String identifier;     private ControllerServiceLookup serviceLookup;     private ComponentLog logger;     private StateManager stateManager;     private volatile ConfigurationContext configurationContext;     private volatile boolean enabled = false;      @Override     public final void initialize(final ControllerServiceInitializationContext context) throws InitializationException {         this.identifier = context.getIdentifier();         serviceLookup = context.getControllerServiceLookup();         logger = context.getLogger();         stateManager = context.getStateManager();         init(context);     }      @Override     public String getIdentifier() {         return identifier;     }      /**      * @return the {@link ControllerServiceLookup} that was passed to the      * {@link #init(ControllerServiceInitializationContext)} method      */     protected final ControllerServiceLookup getControllerServiceLookup() {         return serviceLookup;     }      /**      * Provides a mechanism by which subclasses can perform initialization of      * the Controller Service before it is scheduled to be run      *      * @param config of initialization context      * @throws InitializationException if unable to init      */     protected void init(final ControllerServiceInitializationContext config) throws InitializationException {     }      @OnEnabled     public final void enabled() {         this.enabled = true;     }      @OnDisabled     public final void disabled() {         this.enabled = false;     }      public boolean isEnabled() {         return this.enabled;     }      /**      * @return the logger that has been provided to the component by the      * framework in its initialize method      */     protected ComponentLog getLogger() {         return logger;     }      /**      * @return the StateManager that can be used to store and retrieve state for this Controller Service      */     protected StateManager getStateManager() {         return stateManager;     }      @OnEnabled     public final void abstractStoreConfigContext(final ConfigurationContext configContext) {         this.configurationContext = configContext;     }      @OnDisabled     public final void abstractClearConfigContext() {         this.configurationContext = null;     }      protected ConfigurationContext getConfigurationContext() {         final ConfigurationContext context = this.configurationContext;         if (context == null) {             throw new IllegalStateException(&quot;No Configuration Context exists&quot;);         }          return configurationContext;     }      protected PropertyValue getProperty(final PropertyDescriptor descriptor) {         return getConfigurationContext().getProperty(descriptor);     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10312</td>
    <td align="left">https://github.com/apache/nifi/blob/c8eff590efa3babcda0b755009224dcac168708b/nifi-api/src/main/java/org/apache/nifi/controller/AbstractControllerService.java/#L28-L120</td>
    <td align="right">1</td>
    <td align="right">1212</td>
    <td align="right">10312</td>
  </tr>
  <tr valign="top">
    <td align="right">1093</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class XelatexRunner extends LatexRunner {      /**      * Create a new ProgramRunner.      */     public XelatexRunner() {         super();     }          protected String getWindowsProgramName() {         return &quot;xelatex.exe&quot;;     }          protected String getUnixProgramName() {         return &quot;xelatex&quot;;     }          public String getDescription() {         return &quot;XeLatex program&quot;;     }          /**      * Enable SyncTeX      */     public String getDefaultArguments() {         return &quot;-synctex=1 &quot;+super.getDefaultArguments();     }      /**      * @return output file format (pdf)      */     public String getOutputFormat() {         return TexlipseProperties.OUTPUT_FORMAT_PDF;     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9748</td>
    <td align="left">https://github.com/eclipse/texlipse/blob/1bc72f856d4144ad0bc9baaa9575457bd7b68e1a/org.eclipse.texlipse/source/org/eclipse/texlipse/builder/XelatexRunner.java/#L20-L55</td>
    <td align="right">1</td>
    <td align="right">1093</td>
    <td align="right">9748</td>
  </tr>
  <tr valign="top">
    <td align="right">409</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells the bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Device {  	private String id;  	private String deviceType;  	private String name;  	private Authentication authentication;  	public String getId() { 		return id; 	}  	public void setId(String id) { 		this.id = id; 	}  	public String getDeviceType() { 		return deviceType; 	}  	public void setDeviceType(String deviceType) { 		this.deviceType = deviceType; 	}  	public String getName() { 		return name; 	}  	public void setName(String name) { 		this.name = name; 	}  	public Authentication getAuthentication() { 		return authentication; 	}  	public void setAuthentication(Authentication authentication) { 		this.authentication = authentication; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4159</td>
    <td align="left">https://github.com/SAP/iot-starterkit/blob/f0d9ce06a1a98569a5a4eed76a2ec0aa87c1a1df/neo/apps/java/authentication/com.sap.iot.starterkit.cert/src/main/java/com/sap/iot/starterkit/cert/type/Device.java/#L3-L45</td>
    <td align="right">1</td>
    <td align="right">409</td>
    <td align="right">4159</td>
  </tr>
  <tr valign="top">
    <td align="right">822</td>
    <td align="left">{&quot;output&quot;: &quot;YES, I found bad smells\nthe bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class _RepositorySoap_LabelItem     implements ElementSerializable {     // No attributes          // Elements     protected String workspaceName;     protected String workspaceOwner;     protected _VersionControlLabel label;     protected _LabelItemSpec[] labelSpecs;     protected _LabelChildOption children;      public _RepositorySoap_LabelItem()     {         super();     }      public _RepositorySoap_LabelItem(         final String workspaceName,         final String workspaceOwner,         final _VersionControlLabel label,         final _LabelItemSpec[] labelSpecs,         final _LabelChildOption children)     {         // TODO : Call super() instead of setting all fields directly?         setWorkspaceName(workspaceName);         setWorkspaceOwner(workspaceOwner);         setLabel(label);         setLabelSpecs(labelSpecs);         setChildren(children);     }      public String getWorkspaceName()     {         return this.workspaceName;     }      public void setWorkspaceName(String value)     {         this.workspaceName = value;     }      public String getWorkspaceOwner()     {         return this.workspaceOwner;     }      public void setWorkspaceOwner(String value)     {         this.workspaceOwner = value;     }      public _VersionControlLabel getLabel()     {         return this.label;     }      public void setLabel(_VersionControlLabel value)     {         this.label = value;     }      public _LabelItemSpec[] getLabelSpecs()     {         return this.labelSpecs;     }      public void setLabelSpecs(_LabelItemSpec[] value)     {         this.labelSpecs = value;     }      public _LabelChildOption getChildren()     {         return this.children;     }      public void setChildren(_LabelChildOption value)     {         if (value == null)         {             throw new IllegalArgumentException(&quot;'children' is a required element, its value cannot be null&quot;);         }          this.children = value;     }      public void writeAsElement(         final XMLStreamWriter writer,         final String name)         throws XMLStreamException     {         writer.writeStartElement(name);          // Elements         XMLStreamWriterHelper.writeElement(             writer,             &quot;workspaceName&quot;,             this.workspaceName);         XMLStreamWriterHelper.writeElement(             writer,             &quot;workspaceOwner&quot;,             this.workspaceOwner);          if (this.label != null)         {             this.label.writeAsElement(                 writer,                 &quot;label&quot;);         }          if (this.labelSpecs != null)         {             /*              * The element type is an array.              */             writer.writeStartElement(&quot;labelSpecs&quot;);              for (int iterator0 = 0; iterator0 &lt; this.labelSpecs.length; iterator0++)             {                 this.labelSpecs[iterator0].writeAsElement(                     writer,                     &quot;LabelItemSpec&quot;);             }              writer.writeEndElement();         }          this.children.writeAsElement(             writer,             &quot;children&quot;);          writer.writeEndElement();     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7701</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core.ws/generated-src/ms/tfs/versioncontrol/clientservices/_03/_RepositorySoap_LabelItem.java/#L42-L176</td>
    <td align="right">1</td>
    <td align="right">822</td>
    <td align="right">7701</td>
  </tr>
  <tr valign="top">
    <td align="right">977</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class NodeValueString extends NodeValue {     // A plain string, with no language tag, or an xsd:string.          private String string ;           public NodeValueString(String str)         { string = str ; }      public NodeValueString(String str, Node n) { super(n) ; string = str ; }          @Override     public boolean isString() { return true ; }          @Override     public String getString() { return string ; }      @Override     public String asString() { return string ; }          @Override     public String toString()     {          if ( getNode() != null )         {             // Can be a plain string or an xsd:string.             return FmtUtils.stringForNode(getNode()) ;         }         return '&quot;'+string+'&quot;'  ;     }          @Override     protected Node makeNode()     { return NodeFactory.createLiteral(string) ; }          @Override     public void visit(NodeValueVisitor visitor) { visitor.visit(this) ; } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8825</td>
    <td align="left">https://github.com/apache/jena/blob/1cca775bbf0bb0fd3ee8ac55e31f0f30cdde3b77/jena-arq/src/main/java/org/apache/jena/sparql/expr/nodevalue/NodeValueString.java/#L27-L62</td>
    <td align="right">1</td>
    <td align="right">977</td>
    <td align="right">8825</td>
  </tr>
  <tr valign="top">
    <td align="right">2490</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;,  &quot;bad_smells&quot;: [     &quot;Data Class&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SSLConfigClient extends SSLConfig {    private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(SSLConfigClient.class);    private final Properties properties;   private final boolean userSslEnabled;   private final String trustStoreType;   private final String trustStorePath;   private final String trustStorePassword;   private final boolean disableHostVerification;   private final boolean disableCertificateVerification;   private final boolean useSystemTrustStore;   private final String protocol;   private final int handshakeTimeout;   private final String provider;    private final String emptyString = new String();    public SSLConfigClient(Properties properties) throws DrillException {     this.properties = properties;     userSslEnabled = getBooleanProperty(DrillProperties.ENABLE_TLS);     trustStoreType = getStringProperty(DrillProperties.TRUSTSTORE_TYPE, &quot;JKS&quot;);     trustStorePath = getStringProperty(DrillProperties.TRUSTSTORE_PATH, &quot;&quot;);     trustStorePassword = getStringProperty(DrillProperties.TRUSTSTORE_PASSWORD, &quot;&quot;);     disableHostVerification = getBooleanProperty(DrillProperties.DISABLE_HOST_VERIFICATION);     disableCertificateVerification = getBooleanProperty(DrillProperties.DISABLE_CERT_VERIFICATION);     useSystemTrustStore = getBooleanProperty(DrillProperties.USE_SYSTEM_TRUSTSTORE);     protocol = getStringProperty(DrillProperties.TLS_PROTOCOL, DEFAULT_SSL_PROTOCOL);     int hsTimeout = getIntProperty(DrillProperties.TLS_HANDSHAKE_TIMEOUT, DEFAULT_SSL_HANDSHAKE_TIMEOUT_MS);     if (hsTimeout &lt;= 0) {       hsTimeout = DEFAULT_SSL_HANDSHAKE_TIMEOUT_MS;     }     handshakeTimeout = hsTimeout;     // If provider is OPENSSL then to debug or run this code in an IDE, you will need to enable     // the dependency on netty-tcnative with the correct classifier for the platform you use.     // This can be done by enabling the openssl profile.     // If the IDE is Eclipse, it requires you to install an additional Eclipse plugin available here:     // http://repo1.maven.org/maven2/kr/motd/maven/os-maven-plugin/1.6.1/os-maven-plugin-1.6.1.jar     // or from your local maven repository:     // ~/.m2/repository/kr/motd/maven/os-maven-plugin/1.6.1/os-maven-plugin-1.6.1.jar     // Note that installing this plugin may require you to start with a new workspace     provider = getStringProperty(DrillProperties.TLS_PROVIDER, DEFAULT_SSL_PROVIDER);   }    private boolean getBooleanProperty(String propName) {     return (properties != null) &amp;&amp; (properties.containsKey(propName))         &amp;&amp; (properties.getProperty(propName).compareToIgnoreCase(&quot;true&quot;) == 0);   }    private String getStringProperty(String name, String defaultValue) {     String value = &quot;&quot;;     if ( (properties != null) &amp;&amp; (properties.containsKey(name))) {       value = properties.getProperty(name);     }     if (value.isEmpty()) {       value = defaultValue;     }     value = value.trim();     return value;   }    private int getIntProperty(String name, int defaultValue) {     int value = defaultValue;     if (properties != null) {       String property = properties.getProperty(name);       if (property != null &amp;&amp; property.length() &gt; 0) {         value = Integer.decode(property);       }     }     return value;   }    public void validateKeyStore() throws DrillException {    }    @Override   public SslContext initNettySslContext() throws DrillException {     final SslContext sslCtx;      if (!userSslEnabled) {       return null;     }      TrustManagerFactory tmf;     try {       tmf = initializeTrustManagerFactory();       sslCtx = SslContextBuilder.forClient()           .sslProvider(getProvider())           .trustManager(tmf)           .protocols(protocol)           .build();     } catch (Exception e) {       // Catch any SSL initialization Exceptions here and abort.       throw new DrillException(new StringBuilder()           .append(&quot;SSL is enabled but cannot be initialized due to the following exception: &quot;)           .append(&quot;[ &quot;)           .append(e.getMessage())           .append(&quot;]. &quot;)           .toString());     }     this.nettySslContext = sslCtx;     return sslCtx;   }    @Override   public SSLContext initJDKSSLContext() throws DrillException {     final SSLContext sslCtx;      if (!userSslEnabled) {       return null;     }      TrustManagerFactory tmf;     try {       tmf = initializeTrustManagerFactory();       sslCtx = SSLContext.getInstance(protocol);       sslCtx.init(null, tmf.getTrustManagers(), null);     } catch (Exception e) {       // Catch any SSL initialization Exceptions here and abort.       throw new DrillException(new StringBuilder()           .append(&quot;SSL is enabled but cannot be initialized due to the following exception: &quot;)           .append(&quot;[ &quot;)           .append(e.getMessage())           .append(&quot;]. &quot;)           .toString());     }     this.jdkSSlContext = sslCtx;     return sslCtx;   }    @Override   public SSLEngine createSSLEngine(BufferAllocator allocator, String peerHost, int peerPort) {     SSLEngine engine = super.createSSLEngine(allocator, peerHost, peerPort);      if (!this.disableHostVerification()) {       SSLParameters sslParameters = engine.getSSLParameters();       // only available since Java 7       sslParameters.setEndpointIdentificationAlgorithm(&quot;HTTPS&quot;);       engine.setSSLParameters(sslParameters);     }      engine.setUseClientMode(true);      try {       engine.setEnableSessionCreation(true);     } catch (Exception e) {       // Openssl implementation may throw this.       logger.debug(&quot;Session creation not enabled. Exception: {}&quot;, e.getMessage());     }      return engine;   }    @Override   public boolean isUserSslEnabled() {     return userSslEnabled;   }    @Override   public boolean isHttpsEnabled() {     return false;   }    @Override   public String getKeyStoreType() {     return emptyString;   }    @Override   public String getKeyStorePath() {     return emptyString;   }    @Override   public String getKeyStorePassword() {     return emptyString;   }    @Override   public String getKeyPassword() {     return emptyString;   }    @Override   public String getTrustStoreType() {     return trustStoreType;   }    @Override   public boolean hasTrustStorePath() {     return !trustStorePath.isEmpty();   }    @Override   public String getTrustStorePath() {     return trustStorePath;   }    @Override   public boolean hasTrustStorePassword() {     return !trustStorePassword.isEmpty();   }    @Override   public String getTrustStorePassword() {     return trustStorePassword;   }    @Override   public String getProtocol() {     return protocol;   }    @Override   public SslProvider getProvider() {     return provider.equalsIgnoreCase(&quot;JDK&quot;) ? SslProvider.JDK : SslProvider.OPENSSL;   }    @Override   public int getHandshakeTimeout() {     return handshakeTimeout;   }    @Override   public Mode getMode() {     return Mode.CLIENT;   }    @Override   public boolean disableHostVerification() {     return disableHostVerification;   }    @Override   public boolean disableCertificateVerification() {     return disableCertificateVerification;   }    @Override   public boolean useSystemTrustStore() {     return useSystemTrustStore;   }    public boolean isSslValid() {     return true;   }  }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14617</td>
    <td align="left">https://github.com/apache/drill/blob/5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3/exec/java-exec/src/main/java/org/apache/drill/exec/ssl/SSLConfigClient.java/#L33-L281</td>
    <td align="right">1</td>
    <td align="right">2490</td>
    <td align="right">14617</td>
  </tr>
  <tr valign="top">
    <td align="right">1157</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Long Method&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
		public Action getBinaryBitwiseExpressionLhsAction_1_0_0_0() { return cBinaryBitwiseExpressionLhsAction_1_0_0_0; } 		 		//op=BitwiseOROperator 		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; } 		 		//BitwiseOROperator 		public RuleCall getOpBitwiseOROperatorParserRuleCall_1_0_0_1_0() { return cOpBitwiseOROperatorParserRuleCall_1_0_0_1_0; } 		 		//rhs=BitwiseXORExpression 		public Assignment getRhsAssignment_1_1() { return cRhsAssignment_1_1; } 		 		//BitwiseXORExpression 		public RuleCall getRhsBitwiseXORExpressionParserRuleCall_1_1_0() { return cRhsBitwiseXORExpressionParserRuleCall_1_1_0; } 	} 	public class BitwiseOROperatorElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.n4js.N4JS.BitwiseOROperator&quot;); 		private final Keyword cVerticalLineKeyword = (Keyword)rule.eContents().get(1); 		 		//BitwiseOROperator BinaryBitwiseOperator: 		//	'|'; 		@Override public ParserRule getRule() { return rule; } 		 		//'|' 		public Keyword getVerticalLineKeyword() { return cVerticalLineKeyword; } 	} 	public class LogicalANDExpressionElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.n4js.N4JS.LogicalANDExpression&quot;); 		private final Group cGroup = (Group)rule.eContents().get(1); 		private final RuleCall cBitwiseORExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0); 		private final Group cGroup_1 = (Group)cGroup.eContents().get(1); 		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0); 		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0); 		private final Action cBinaryLogicalExpressionLhsAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0); 		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1); 		private final RuleCall cOpLogicalANDOperatorParserRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0); 		private final Assignment cRhsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1); 		private final RuleCall cRhsBitwiseORExpressionParserRuleCall_1_1_0 = (RuleCall)cRhsAssignment_1_1.eContents().get(0); 		 		//// $ (=&gt; ({BinaryLogicalExpression.lhs=current} op=LogicalANDOperator) 		//	rhs=BitwiseORExpression)*; 		@Override public ParserRule getRule() { return rule; } 		 		//BitwiseORExpression (=&gt; ({BinaryLogicalExpression.lhs=current} op=LogicalANDOperator) 		//rhs=BitwiseORExpression)* 		public Group getGroup() { return cGroup; } 		 		//BitwiseORExpression 		public RuleCall getBitwiseORExpressionParserRuleCall_0() { return cBitwiseORExpressionParserRuleCall_0; } 		</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10144</td>
    <td align="left">https://github.com/eclipse/n4js/blob/f715912fce0352ab574ff878086f77d17a78c908/plugins/org.eclipse.n4js/src-gen/org/eclipse/n4js/services/N4JSGrammarAccess.java/#L6096-L6144</td>
    <td align="right">1</td>
    <td align="right">1157</td>
    <td align="right">10144</td>
  </tr>
  <tr valign="top">
    <td align="right">2346</td>
    <td align="left">&nbsp;YES I found bad smells The bad smells are: 1. Data class 2. Lack of encapsulation 3. Long method 4. Feature envy</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
   public class Header {        public String key;       public String val;        public Header(String key, String val) {          this.key = key;          this.val = val;       }        public String getEncodedKey() {          return encode(key);       }        public String getEncodedValue() {          return encode(val);       }    }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Data class2 Lack of encapsulation3 Long method4 Feature envy</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14193</td>
    <td align="left">https://github.com/apache/activemq-artemis/blob/5bd5c610195d6f4a3dd1ac28170727003f8a5a54/artemis-protocols/artemis-stomp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/stomp/StompFrame.java/#L158-L175</td>
    <td align="right">2</td>
    <td align="right">2346</td>
    <td align="right">14193</td>
  </tr>
  <tr valign="top">
    <td align="right">667</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;output&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class AbstractSimpleExtractor implements Extractor {    private static final Logger LOG = LoggerFactory.getLogger(AbstractSimpleExtractor.class);   private static final int LOG_ERROR_LIMIT = 100;      private int errors;   private boolean errorOnLast;   private final T defaultValue;   private final TokenizerFactory scannerFactory;      protected AbstractSimpleExtractor(T defaultValue) {     this(defaultValue, TokenizerFactory.getDefaultInstance());   }      protected AbstractSimpleExtractor(T defaultValue, TokenizerFactory scannerFactory) {     this.defaultValue = defaultValue;     this.scannerFactory = scannerFactory;   }    @Override   public void initialize() {     this.errors = 0;     this.errorOnLast = false;   }      @Override   public T extract(String input) {     errorOnLast = false;     T res = defaultValue;     try {       res = doExtract(scannerFactory.create(input));     } catch (Exception e) {       errorOnLast = true;       errors++;       if (errors &lt; LOG_ERROR_LIMIT) {         LOG.error(&quot;Error occurred parsing input '{}' using extractor {}&quot;, input, this);       }     }     return res;   }    @Override   public boolean errorOnLastRecord() {     return errorOnLast;   }      @Override   public T getDefaultValue() {     return defaultValue;   }      @Override   public ExtractorStats getStats() {     return new ExtractorStats(errors);   }      /**    * Subclasses must override this method to return a new instance of the    * class that this {@code Extractor} instance is designed to parse.    * Any runtime parsing exceptions from the given {@code Tokenizer} instance    * should be thrown so that they may be caught by the error handling logic    * inside of this class.    *     * @param tokenizer The {@code Tokenizer} instance for the current record    * @return A new instance of the type defined for this class    */   protected abstract T doExtract(Tokenizer tokenizer); }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6549</td>
    <td align="left">https://github.com/apache/crunch/blob/9b8849cfd89f1e7f187b99914163509060692aa5/crunch-contrib/src/main/java/org/apache/crunch/contrib/text/AbstractSimpleExtractor.java/#L28-L95</td>
    <td align="right">1</td>
    <td align="right">667</td>
    <td align="right">6549</td>
  </tr>
  <tr valign="top">
    <td align="right">2642</td>
    <td align="left">{&quot;message&quot;: &quot;YES, I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
 		protected int height; 		protected int width;  		public ImageSource( int width, int height ) 		{ 			this.width = width; 			this.height = height; 		}  		public int getHeight( ) 		{ 			return height; 		}  		public int getWidth( ) 		{ 			return width; 		}  		public abstract int getRGB( int x, int y ); 	}  	public class ArrayImageSource extends ImageSource</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15145</td>
    <td align="left">https://github.com/eclipse/birt/blob/f89264810347de98702db45386a822aabc0fadbf/engine/org.eclipse.birt.report.engine.emitter.postscript/src/org/eclipse/birt/report/engine/emitter/postscript/PostscriptWriter.java/#L1340-L1363</td>
    <td align="right">1</td>
    <td align="right">2642</td>
    <td align="right">15145</td>
  </tr>
  <tr valign="top">
    <td align="right">2347</td>
    <td align="left">&nbsp;{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Long Method&quot;,     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class FieldAttributeModel {    /** Typescript value of the type of the field */   private final String typeName;    /** For Map, List object, need to initialize field first. Like new Field&lt;&gt;() */   private boolean needInitialize;    /** Name of the field */   private String fieldName;    /** Java Type of the object (used internally) */   private Type type;    /** This field type is a List of objects ? */   private boolean isList;    /** This field type is a simple primitive */   private boolean isPrimitive;    /** This field type is a map */   private boolean isMap;    /** This list type is in fact a list of DTOs */   private boolean isListOfDto;    /** This map type is a map of DTOs */   private boolean isMapOfDto;    /**    * The type is a DTO or a list of DTO and then this value is the name of the DTO implementation    */   private String dtoImpl;    /** type is a DTO object. */   private boolean isDto;    /** type is a Enum object. */   private boolean isEnum;    /** Map key type */   private String mapKeyType;    /** Map value type */   private String mapValueType;    /** Dto type for d.ts */   private String dtsType;    /** Dto class where this field declared */   private Class declarationClass;    /**    * Build a new field model based on the name and Java type    *    * @param fieldName the name of the field    * @param type the Java raw type that will allow further analyzes    * @param declarationClass    */   public FieldAttributeModel(String fieldName, Type type, Class declarationClass) {     this.fieldName = fieldName;     this.type = type;     this.typeName = convertType(type);     this.dtsType = convertTypeForDTS(declarationClass, type);     this.declarationClass = declarationClass;      if (typeName.startsWith(&quot;Array&lt;&quot;) || typeName.startsWith(&quot;Map&lt;&quot;)) {       this.needInitialize = true;     }      if (this.type instanceof ParameterizedType) {       ParameterizedType parameterizedType = (ParameterizedType) this.type;       Type rawType = parameterizedType.getRawType();       analyzeParametrizedType(parameterizedType, rawType);     } else if (Primitives.isPrimitive(this.type)         || Primitives.isWrapperType(this.type)         || String.class.equals(this.type)) {       this.isPrimitive = true;     } else if (this.type instanceof Class &amp;&amp; ((Class) this.type).isAnnotationPresent(DTO.class)) {       this.isDto = true;       dtoImpl = this.type.getTypeName() + &quot;Impl&quot;;     } else if (this.type instanceof Class &amp;&amp; ((Class) this.type).isEnum()) {       this.isEnum = true;     }   }    /**    * Analyze a complex parametrized type attribute (which can be a list or map for example)    *    * @param parameterizedType    * @param rawType    */   protected void analyzeParametrizedType(ParameterizedType parameterizedType, Type rawType) {     if (List.class.equals(rawType)) {       this.isList = true;       if (parameterizedType.getActualTypeArguments()[0] instanceof Class           &amp;&amp; ((Class) parameterizedType.getActualTypeArguments()[0])               .isAnnotationPresent(DTO.class)) {         isListOfDto = true;         dtoImpl = convertType(parameterizedType.getActualTypeArguments()[0]) + &quot;Impl&quot;;       }     } else if (Map.class.equals(rawType)) {       isMap = true;       mapKeyType =           convertTypeForDTS(declarationClass, parameterizedType.getActualTypeArguments()[0]);       if (parameterizedType.getActualTypeArguments()[1] instanceof Class           &amp;&amp; ((Class) parameterizedType.getActualTypeArguments()[1])               .isAnnotationPresent(DTO.class)) {          isMapOfDto = true;         dtoImpl = convertType(parameterizedType.getActualTypeArguments()[1]) + &quot;Impl&quot;;       }        mapValueType =           convertTypeForDTS(declarationClass, parameterizedType.getActualTypeArguments()[1]);     }   }    public String getTypeName() {     return typeName;   }    public String getFieldName() {     return fieldName;   }    public Type getType() {     return type;   }    public boolean isList() {     return isList;   }    public boolean isPrimitive() {     return isPrimitive;   }    public boolean isMap() {     return isMap;   }    public boolean isListOfDto() {     return isListOfDto;   }    public boolean isMapOfDto() {     return isMapOfDto;   }    public String getDtoImpl() {     return dtoImpl;   }    public boolean isDto() {     return isDto;   }    public boolean isNeedInitialize() {     return needInitialize;   }    public boolean isEnum() {     return isEnum;   }    public String getName() {     return this.fieldName;   }    public String getSimpleType() {     return this.typeName;   }    public String getMapKeyType() {     return mapKeyType;   }    public String getMapValueType() {     return mapValueType;   }    public String getDtsType() {     return dtsType;   } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14196</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/core/che-core-typescript-dto-maven-plugin/src/main/java/org/eclipse/che/plugin/typescript/dto/model/FieldAttributeModel.java/#L29-L214</td>
    <td align="right">1</td>
    <td align="right">2347</td>
    <td align="right">14196</td>
  </tr>
  <tr valign="top">
    <td align="right">2031</td>
    <td align="left">&nbsp;&nbsp;YES I found bad smells The bad smells are: 1. Long method (computeContentSummary) 2. Feature envy (in computeContentSummary and computeQuotaUsage methods) 3. Duplicate code (in computeQuotaUsage method) 4. Data class (INodeReference class has only private fields and getters/setters) 5. Primitive obsession (use of bytes instead of a custom class for names) 6. Refused bequest (overriding methods unnecessarily in WithName class) 7. Null checks and fail-fast behavior (in cleanSubtree and destroyAndCollectBlocks methods) 8. Intensive coupling (reliance on specific methods and classes) 9. Inconsistent naming of methods and variables 10. Use of final keyword unnecessarily.</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
  public static class WithName extends INodeReference {      private final byte[] name;      /**      * The id of the last snapshot in the src tree when this WithName node was       * generated. When calculating the quota usage of the referred node, only       * the files/dirs existing when this snapshot was taken will be counted for       * this WithName node and propagated along its ancestor path.      */     private final int lastSnapshotId;          public WithName(INodeDirectory parent, WithCount referred, byte[] name,         int lastSnapshotId) {       super(parent, referred);       this.name = name;       this.lastSnapshotId = lastSnapshotId;       referred.addReference(this);     }      @Override     public final byte[] getLocalNameBytes() {       return name;     }      @Override     public final void setLocalName(byte[] name) {       throw new UnsupportedOperationException(&quot;Cannot set name: &quot; + getClass()           + &quot; is immutable.&quot;);     }          public int getLastSnapshotId() {       return lastSnapshotId;     }          @Override     public final ContentSummaryComputationContext computeContentSummary(         int snapshotId, ContentSummaryComputationContext summary) {       final int s = snapshotId &lt; lastSnapshotId ? snapshotId : lastSnapshotId;       // only count storagespace for WithName       final QuotaCounts q = computeQuotaUsage(           summary.getBlockStoragePolicySuite(), getStoragePolicyID(), false, s);       summary.getCounts().addContent(Content.DISKSPACE, q.getStorageSpace());       summary.getCounts().addTypeSpaces(q.getTypeSpaces());       return summary;     }      @Override     public final QuotaCounts computeQuotaUsage(BlockStoragePolicySuite bsps,         byte blockStoragePolicyId, boolean useCache, int lastSnapshotId) {       // if this.lastSnapshotId &lt; lastSnapshotId, the rename of the referred       // node happened before the rename of its ancestor. This should be       // impossible since for WithName node we only count its children at the       // time of the rename.       Preconditions.checkState(lastSnapshotId == Snapshot.CURRENT_STATE_ID           || this.lastSnapshotId &gt;= lastSnapshotId);       final INode referred = this.getReferredINode().asReference()           .getReferredINode();       // We will continue the quota usage computation using the same snapshot id       // as time line (if the given snapshot id is valid). Also, we cannot use        // cache for the referred node since its cached quota may have already        // been updated by changes in the current tree.       int id = lastSnapshotId != Snapshot.CURRENT_STATE_ID ?            lastSnapshotId : this.lastSnapshotId;       return referred.computeQuotaUsage(bsps, blockStoragePolicyId, false, id);     }          @Override     public void cleanSubtree(ReclaimContext reclaimContext, final int snapshot,         int prior) {       // since WithName node resides in deleted list acting as a snapshot copy,       // the parameter snapshot must be non-null       Preconditions.checkArgument(snapshot != Snapshot.CURRENT_STATE_ID);       // if prior is NO_SNAPSHOT_ID, we need to check snapshot belonging to the       // previous WithName instance       if (prior == Snapshot.NO_SNAPSHOT_ID) {         prior = getPriorSnapshot(this);       }              if (prior != Snapshot.NO_SNAPSHOT_ID           &amp;&amp; Snapshot.ID_INTEGER_COMPARATOR.compare(snapshot, prior) &lt;= 0) {         return;       }        // record the old quota delta       QuotaCounts old = reclaimContext.quotaDelta().getCountsCopy();       getReferredINode().cleanSubtree(reclaimContext, snapshot, prior);       INodeReference ref = getReferredINode().getParentReference();       if (ref != null) {         QuotaCounts current = reclaimContext.quotaDelta().getCountsCopy();         current.subtract(old);         // we need to update the quota usage along the parent path from ref         reclaimContext.quotaDelta().addUpdatePath(ref, current);       }              if (snapshot &lt; lastSnapshotId) {         // for a WithName node, when we compute its quota usage, we only count         // in all the nodes existing at the time of the corresponding rename op.         // Thus if we are deleting a snapshot before/at the snapshot associated          // with lastSnapshotId, we do not need to update the quota upwards.         reclaimContext.quotaDelta().setCounts(old);       }     }          @Override     public void destroyAndCollectBlocks(ReclaimContext reclaimContext) {       int snapshot = getSelfSnapshot();       reclaimContext.quotaDelta().add(computeQuotaUsage(reclaimContext.bsps));       if (removeReference(this) &lt;= 0) {         getReferredINode().destroyAndCollectBlocks(reclaimContext.getCopy());       } else {         int prior = getPriorSnapshot(this);         INode referred = getReferredINode().asReference().getReferredINode();          if (snapshot != Snapshot.NO_SNAPSHOT_ID) {           if (prior != Snapshot.NO_SNAPSHOT_ID &amp;&amp; snapshot &lt;= prior) {             // the snapshot to be deleted has been deleted while traversing              // the src tree of the previous rename operation. This usually              // happens when rename's src and dst are under the same              // snapshottable directory. E.g., the following operation sequence:             // 1. create snapshot s1 on /test             // 2. rename /test/foo/bar to /test/foo2/bar             // 3. create snapshot s2 on /test             // 4. rename foo2 again             // 5. delete snapshot s2             return;           }           ReclaimContext newCtx = reclaimContext.getCopy();           referred.cleanSubtree(newCtx, snapshot, prior);           INodeReference ref = getReferredINode().getParentReference();           if (ref != null) {             // we need to update the quota usage along the parent path from ref             reclaimContext.quotaDelta().addUpdatePath(ref,                 newCtx.quotaDelta().getCountsCopy());           }         }       }     }          private int getSelfSnapshot() {       INode referred = getReferredINode().asReference().getReferredINode();       int snapshot = Snapshot.NO_SNAPSHOT_ID;       if (referred.isFile() &amp;&amp; referred.asFile().isWithSnapshot()) {         snapshot = referred.asFile().getDiffs().getPrior(lastSnapshotId);       } else if (referred.isDirectory()) {         DirectoryWithSnapshotFeature sf = referred.asDirectory()             .getDirectoryWithSnapshotFeature();         if (sf != null) {           snapshot = sf.getDiffs().getPrior(lastSnapshotId);         }       }       return snapshot;     }   }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method (computeContentSummary)2 Feature envy (in computeContentSummary and computeQuotaUsage methods)3 Duplicate code (in computeQuotaUsage method)4 Data class (INodeReference class has only private fields and getters/setters)5 Primitive obsession (use of bytes instead of a custom class for names)6 Refused bequest (overriding methods unnecessarily in WithName class)7 Null checks and fail-fast behavior (in cleanSubtree and destroyAndCollectBlocks methods)8 Intensive coupling (reliance on specific methods and classes)9 Inconsistent naming of methods and variables</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12811</td>
    <td align="left">https://github.com/apache/hadoop/blob/128dd91e10080bdcbcd7d555fa3c4105e55a6b51/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeReference.java/#L466-L619</td>
    <td align="right">2</td>
    <td align="right">2031</td>
    <td align="right">12811</td>
  </tr>
  <tr valign="top">
    <td align="right">98</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{ &quot;answer&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [ &quot;Data Class&quot;, &quot;Long Method&quot; ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class _BuildWebServiceSoap_UpdateBuildDefinitions     implements ElementSerializable {     // No attributes          // Elements     protected _BuildDefinition[] updates;      public _BuildWebServiceSoap_UpdateBuildDefinitions()     {         super();     }      public _BuildWebServiceSoap_UpdateBuildDefinitions(final _BuildDefinition[] updates)     {         // TODO : Call super() instead of setting all fields directly?         setUpdates(updates);     }      public _BuildDefinition[] getUpdates()     {         return this.updates;     }      public void setUpdates(_BuildDefinition[] value)     {         this.updates = value;     }      public void writeAsElement(         final XMLStreamWriter writer,         final String name)         throws XMLStreamException     {         writer.writeStartElement(name);          // Elements         if (this.updates != null)         {             /*              * The element type is an array.              */             writer.writeStartElement(&quot;updates&quot;);              for (int iterator0 = 0; iterator0 &lt; this.updates.length; iterator0++)             {                 this.updates[iterator0].writeAsElement(                     writer,                     &quot;BuildDefinition&quot;);             }              writer.writeEndElement();         }          writer.writeEndElement();     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1293</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core.ws/generated-src/ms/tfs/build/buildservice/_03/_BuildWebServiceSoap_UpdateBuildDefinitions.java/#L45-L101</td>
    <td align="right">1</td>
    <td align="right">98</td>
    <td align="right">1293</td>
  </tr>
  <tr valign="top">
    <td align="right">2060</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;,  &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;EObject&quot;, propOrder = { &quot;extensions&quot; }) public class EObject {  	@XmlElement(name = &quot;Extension&quot;, namespace = &quot;http://www.omg.org/XMI&quot;) 	protected List extensions; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	@XmlJavaTypeAdapter(CollapsedStringAdapter.class) 	@XmlID 	protected String id; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected QName type; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected String version; 	@XmlAttribute 	protected String href; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	@XmlIDREF 	protected Object idref; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected String label; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected String uuid;  	/** 	 * Gets the value of the extensions property. 	 *  	 *  	 * This accessor method returns a reference to the live list, not a 	 * snapshot. Therefore any modification you make to the returned list will 	 * be present inside the JAXB object. This is why there is not a 	 * set method for the extensions property. 	 *  	 *  	 * For example, to add a new item, do as follows: 	 *  	 *  	 * getExtensions().add(newItem); 	 *  	 *  	 *  	 *  	 * Objects of the following type(s) are allowed in the list 	 * {@link Extension } 	 *  	 *  	 */ 	public List getExtensions() { 		if (extensions == null) { 			extensions = new ArrayList(); 		} 		return this.extensions; 	}  	/** 	 * Gets the value of the id property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getId() { 		return id; 	}  	/** 	 * Sets the value of the id property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setId(String value) { 		this.id = value; 	}  	/** 	 * Gets the value of the type property. 	 *  	 * @return possible object is {@link QName } 	 *  	 */ 	public QName getType() { 		return type; 	}  	/** 	 * Sets the value of the type property. 	 *  	 * @param value 	 *            allowed object is {@link QName } 	 *  	 */ 	public void setType(QName value) { 		this.type = value; 	}  	/** 	 * Gets the value of the version property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getVersion() { 		if (version == null) { 			return &quot;2.0&quot;; 		} else { 			return version; 		} 	}  	/** 	 * Sets the value of the version property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setVersion(String value) { 		this.version = value; 	}  	/** 	 * Gets the value of the href property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getHref() { 		return href; 	}  	/** 	 * Sets the value of the href property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setHref(String value) { 		this.href = value; 	}  	/** 	 * Gets the value of the idref property. 	 *  	 * @return possible object is {@link Object } 	 *  	 */ 	public Object getIdref() { 		return idref; 	}  	/** 	 * Sets the value of the idref property. 	 *  	 * @param value 	 *            allowed object is {@link Object } 	 *  	 */ 	public void setIdref(Object value) { 		this.idref = value; 	}  	/** 	 * Gets the value of the label property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getLabel() { 		return label; 	}  	/** 	 * Sets the value of the label property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setLabel(String value) { 		this.label = value; 	}  	/** 	 * Gets the value of the uuid property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getUuid() { 		return uuid; 	}  	/** 	 * Sets the value of the uuid property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setUuid(String value) { 		this.uuid = value; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12964</td>
    <td align="left">https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/container/openejb-jee/src/main/java/org/apache/openejb/jee/was/v6/ecore/EObject.java/#L57-L262</td>
    <td align="right">1</td>
    <td align="right">2060</td>
    <td align="right">12964</td>
  </tr>
  <tr valign="top">
    <td align="right">3962</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class RestConfiguration {      public static final String CORS_ACCESS_CONTROL_ALLOW_ORIGIN = &quot;*&quot;;     public static final String CORS_ACCESS_CONTROL_ALLOW_METHODS = &quot;GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, CONNECT, PATCH&quot;;     public static final String CORS_ACCESS_CONTROL_MAX_AGE = &quot;3600&quot;;     public static final String CORS_ACCESS_CONTROL_ALLOW_HEADERS = &quot;Origin, Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers&quot;;      public enum RestBindingMode {         auto, off, json, xml, json_xml     }      public enum RestHostNameResolver {         allLocalIp, localIp, localHostName     }      private String component;     private String apiComponent;     private String producerComponent;     private String producerApiDoc;     private String scheme;     private String host;     private boolean useXForwardHeaders = true;     private String apiHost;     private int port;     private String contextPath;     private String apiContextPath;     private String apiContextRouteId;     private String apiContextIdPattern;     private boolean apiContextListing;     private boolean apiVendorExtension;     private RestHostNameResolver hostNameResolver = RestHostNameResolver.allLocalIp;     private RestBindingMode bindingMode = RestBindingMode.off;     private boolean skipBindingOnErrorCode = true;     private boolean clientRequestValidation;     private boolean enableCORS;     private String jsonDataFormat;     private String xmlDataFormat;     private Map componentProperties;     private Map endpointProperties;     private Map consumerProperties;     private Map dataFormatProperties;     private Map apiProperties;     private Map corsHeaders;      /**      * Gets the name of the Camel component to use as the REST consumer      *      * @return the component name, or null to let Camel search the {@link Registry} to find suitable implementation      */     public String getComponent() {         return component;     }      /**      * Sets the name of the Camel component to use as the REST consumer      *      * @param componentName the name of the component (such as restlet, spark-rest, etc.)      */     public void setComponent(String componentName) {         this.component = componentName;     }      /**      * Gets the name of the Camel component to use as the REST API (such as swagger)      *      * @return the component name, or null to let Camel use the default name swagger      */     public String getApiComponent() {         return apiComponent;     }      /**      * Sets the name of the Camel component to use as the REST API (such as swagger)      *      * @param apiComponent the name of the component (such as swagger)      */     public void setApiComponent(String apiComponent) {         this.apiComponent = apiComponent;     }      /**      * Gets the name of the Camel component to use as the REST producer      *      * @return the component name, or null to let Camel search the {@link Registry} to find suitable implementation      */     public String getProducerComponent() {         return producerComponent;     }      /**      * Sets the name of the Camel component to use as the REST producer      *      * @param componentName the name of the component (such as restlet, jetty, etc.)      */     public void setProducerComponent(String componentName) {         this.producerComponent = componentName;     }      /**      * Gets the location of the api document (swagger api) the REST producer will use      * to validate the REST uri and query parameters are valid accordingly to the api document.      */     public String getProducerApiDoc() {         return producerApiDoc;     }      /**      * Sets the location of the api document (swagger api) the REST producer will use      * to validate the REST uri and query parameters are valid accordingly to the api document.      * This requires adding camel-swagger-java to the classpath, and any miss configuration      * will let Camel fail on startup and report the error(s).      *       * The location of the api document is loaded from classpath by default, but you can use      * file: or http: to refer to resources to load from file or http url.      */     public void setProducerApiDoc(String producerApiDoc) {         this.producerApiDoc = producerApiDoc;     }      /**      * Gets the hostname to use by the REST consumer      *      * @return the hostname, or null to use default hostname      */     public String getHost() {         return host;     }      /**      * Sets the hostname to use by the REST consumer      *      * @param host the hostname      */     public void setHost(String host) {         this.host = host;     }      /**      * WWhether to use X-Forward headers to set host etc. for Swagger.      *       * This option is default true.      */     public boolean isUseXForwardHeaders() {         return useXForwardHeaders;     }      /**      * WWhether to use X-Forward headers to set host etc. for Swagger.      *       * This option is default true.      *       * @param useXForwardHeaders whether to use X-Forward headers      */     public void setUseXForwardHeaders(boolean useXForwardHeaders) {         this.useXForwardHeaders = useXForwardHeaders;     }      public String getApiHost() {         return apiHost;     }      /**      * To use an specific hostname for the API documentation (eg swagger)      *       * This can be used to override the generated host with this configured hostname      */     public void setApiHost(String apiHost) {         this.apiHost = apiHost;     }      /**      * Gets the scheme to use by the REST consumer      *      * @return the scheme, or null to use default scheme      */     public String getScheme() {         return scheme;     }      /**      * Sets the scheme to use by the REST consumer      *      * @param scheme the scheme      */     public void setScheme(String scheme) {         this.scheme = scheme;     }      /**      * Gets the port to use by the REST consumer      *      * @return the port, or 0 or -1 to use default port      */     public int getPort() {         return port;     }      /**      * Sets the port to use by the REST consumer      *      * @param port the port number      */     public void setPort(int port) {         this.port = port;     }      /**      * Gets the configured context-path      *      * @return the context path, or null if none configured.      */     public String getContextPath() {         return contextPath;     }      /**      * Sets a leading context-path the REST services will be using.      *       * This can be used when using components such as camel-servlet where the deployed web application      * is deployed using a context-path. Or for components such as camel-jetty or camel-netty4-http      * that includes a HTTP server.      *      * @param contextPath the context path      */     public void setContextPath(String contextPath) {         this.contextPath = contextPath;     }      public String getApiContextPath() {         return apiContextPath;     }      /**      * Sets a leading API context-path the REST API services will be using.      *       * This can be used when using components such as camel-servlet where the deployed web application      * is deployed using a context-path.      *      * @param contextPath the API context path      */     public void setApiContextPath(String contextPath) {         this.apiContextPath = contextPath;     }      public String getApiContextRouteId() {         return apiContextRouteId;     }      /**      * Sets the route id to use for the route that services the REST API.      *       * The route will by default use an auto assigned route id.      *      * @param apiContextRouteId  the route id      */     public void setApiContextRouteId(String apiContextRouteId) {         this.apiContextRouteId = apiContextRouteId;     }      public String getApiContextIdPattern() {         return apiContextIdPattern;     }      /**      * Optional CamelContext id pattern to only allow Rest APIs from rest services within CamelContext's which name matches the pattern.      *       * The pattern #name# refers to the CamelContext name, to match on the current CamelContext only.      * For any other value, the pattern uses the rules from {@link org.apache.camel.support.EndpointHelper#matchPattern(String, String)}      *      * @param apiContextIdPattern  the pattern      */     public void setApiContextIdPattern(String apiContextIdPattern) {         this.apiContextIdPattern = apiContextIdPattern;     }      public boolean isApiContextListing() {         return apiContextListing;     }      /**      * Sets whether listing of all available CamelContext's with REST services in the JVM is enabled. If enabled it allows to discover      * these contexts, if false then only the current CamelContext is in use.      */     public void setApiContextListing(boolean apiContextListing) {         this.apiContextListing = apiContextListing;     }      public boolean isApiVendorExtension() {         return apiVendorExtension;     }      /**      * Whether vendor extension is enabled in the Rest APIs. If enabled then Camel will include additional information      * as vendor extension (eg keys starting with x-) such as route ids, class names etc.      * Not all 3rd party API gateways and tools supports vendor-extensions when importing your API docs.      */     public void setApiVendorExtension(boolean apiVendorExtension) {         this.apiVendorExtension = apiVendorExtension;     }      /**      * Gets the resolver to use for resolving hostname      *      * @return the resolver      */     public RestHostNameResolver getHostNameResolver() {         return hostNameResolver;     }      /**      * Sets the resolver to use for resolving hostname      *      * @param hostNameResolver the resolver      */     public void setHostNameResolver(RestHostNameResolver hostNameResolver) {         this.hostNameResolver = hostNameResolver;     }      /**      * Sets the resolver to use for resolving hostname      *      * @param hostNameResolver the resolver      */     public void setHostNameResolver(String hostNameResolver) {         this.hostNameResolver = RestHostNameResolver.valueOf(hostNameResolver);     }      /**      * Gets the binding mode used by the REST consumer      *      * @return the binding mode      */     public RestBindingMode getBindingMode() {         return bindingMode;     }      /**      * Sets the binding mode to be used by the REST consumer      *      * @param bindingMode the binding mode      */     public void setBindingMode(RestBindingMode bindingMode) {         this.bindingMode = bindingMode;     }      /**      * Sets the binding mode to be used by the REST consumer      *      * @param bindingMode the binding mode      */     public void setBindingMode(String bindingMode) {         this.bindingMode = RestBindingMode.valueOf(bindingMode);     }      /**      * Whether to skip binding output if there is a custom HTTP error code, and instead use the response body as-is.      *       * This option is default true.      *      * @return whether to skip binding on error code      */     public boolean isSkipBindingOnErrorCode() {         return skipBindingOnErrorCode;     }      /**      * Whether to skip binding output if there is a custom HTTP error code, and instead use the response body as-is.      *       * This option is default true.      *      * @param skipBindingOnErrorCode whether to skip binding on error code      */     public void setSkipBindingOnErrorCode(boolean skipBindingOnErrorCode) {         this.skipBindingOnErrorCode = skipBindingOnErrorCode;     }      public boolean isClientRequestValidation() {         return clientRequestValidation;     }      /**      * Whether to enable validation of the client request to check whether the Content-Type and Accept headers from      * the client is supported by the Rest-DSL configuration of its consumes/produces settings.      *       * This can be turned on, to enable this check. In case of validation error, then HTTP Status codes 415 or 406 is returned.      *       * The default value is false.      */     public void setClientRequestValidation(boolean clientRequestValidation) {         this.clientRequestValidation = clientRequestValidation;     }      /**      * To specify whether to enable CORS which means Camel will automatic include CORS in the HTTP headers in the response.      *       * This option is default false      *      * @return whether CORS is enabled or not      */     public boolean isEnableCORS() {         return enableCORS;     }      /**      * To specify whether to enable CORS which means Camel will automatic include CORS in the HTTP headers in the response.      *       * This option is default false      *      * @param enableCORS true to enable CORS      */     public void setEnableCORS(boolean enableCORS) {         this.enableCORS = enableCORS;     }      /**      * Gets the name of the json data format.      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @return the name, or null to use default      */     public String getJsonDataFormat() {         return jsonDataFormat;     }      /**      * Sets a custom json data format to be used      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @param name name of the data format      */     public void setJsonDataFormat(String name) {         this.jsonDataFormat = name;     }      /**      * Gets the name of the xml data format.      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @return the name, or null to use default      */     public String getXmlDataFormat() {         return xmlDataFormat;     }      /**      * Sets a custom xml data format to be used.      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @param name name of the data format      */     public void setXmlDataFormat(String name) {         this.xmlDataFormat = name;     }      /**      * Gets additional options on component level      *      * @return additional options      */     public Map getComponentProperties() {         return componentProperties;     }      /**      * Sets additional options on component level      *      * @param componentProperties the options      */     public void setComponentProperties(Map componentProperties) {         this.componentProperties = componentProperties;     }      /**      * Gets additional options on endpoint level      *      * @return additional options      */     public Map getEndpointProperties() {         return endpointProperties;     }      /**      * Sets additional options on endpoint level      *      * @param endpointProperties the options      */     public void setEndpointProperties(Map endpointProperties) {         this.endpointProperties = endpointProperties;     }      /**      * Gets additional options on consumer level      *      * @return additional options      */     public Map getConsumerProperties() {         return consumerProperties;     }      /**      * Sets additional options on consumer level      *      * @param consumerProperties the options      */     public void setConsumerProperties(Map consumerProperties) {         this.consumerProperties = consumerProperties;     }      /**      * Gets additional options on data format level      *      * @return additional options      */     public Map getDataFormatProperties() {         return dataFormatProperties;     }      /**      * Sets additional options on data format level      *      * @param dataFormatProperties the options      */     public void setDataFormatProperties(Map dataFormatProperties) {         this.dataFormatProperties = dataFormatProperties;     }      public Map getApiProperties() {         return apiProperties;     }      /**      * Sets additional options on api level      *      * @param apiProperties the options      */     public void setApiProperties(Map apiProperties) {         this.apiProperties = apiProperties;     }      /**      * Gets the CORS headers to use if CORS has been enabled.      *      * @return the CORS headers      */     public Map getCorsHeaders() {         return corsHeaders;     }      /**      * Sets the CORS headers to use if CORS has been enabled.      *      * @param corsHeaders the CORS headers      */     public void setCorsHeaders(Map corsHeaders) {         this.corsHeaders = corsHeaders;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10380</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/core/camel-api/src/main/java/org/apache/camel/spi/RestConfiguration.java/#L25-L585</td>
    <td align="right">1</td>
    <td align="right">3962</td>
    <td align="right">10380</td>
  </tr>
  <tr valign="top">
    <td align="right">2176</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;&quot;, propOrder = {     &quot;content&quot; }) @XmlRootElement(name = &quot;cache-policy-conf-other&quot;) public class CachePolicyConfOther {      @XmlMixed     @XmlAnyElement     protected List content;      /**      * Gets the value of the content property.      *       *       * This accessor method returns a reference to the live list,      * not a snapshot. Therefore any modification you make to the      * returned list will be present inside the JAXB object.      * This is why there is not a set method for the content property.      *       *       * For example, to add a new item, do as follows:      *       *    getContent().add(newItem);      *       *       *       *       * Objects of the following type(s) are allowed in the list      * {@link Element }      * {@link String }      */     public List getContent() {         if (content == null) {             content = new ArrayList();         }         return this.content;     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13404</td>
    <td align="left">https://github.com/apache/tomee/blob/d21933b313aff812fe5188b57bf572a9ad649148/container/openejb-jee/src/main/java/org/apache/openejb/jee/jba/CachePolicyConfOther.java/#L32-L71</td>
    <td align="right">1</td>
    <td align="right">2176</td>
    <td align="right">13404</td>
  </tr>
  <tr valign="top">
    <td align="right">794</td>
    <td align="left">&nbsp;{&quot;message&quot;:&quot;YES I found bad smells&quot;,&quot;bad smells&quot;:[&quot;Long Method&quot;,&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DataBinder implements PropertyEditorRegistry, TypeConverter {  	/** Default object name used for binding: &quot;target&quot;. */ 	public static final String DEFAULT_OBJECT_NAME = &quot;target&quot;;  	/** Default limit for array and collection growing: 256. */ 	public static final int DEFAULT_AUTO_GROW_COLLECTION_LIMIT = 256;   	/** 	 * We'll create a lot of DataBinder instances: Let's use a static logger. 	 */ 	protected static final Log logger = LogFactory.getLog(DataBinder.class);  	@Nullable 	private final Object target;  	private final String objectName;  	@Nullable 	private AbstractPropertyBindingResult bindingResult;  	@Nullable 	private SimpleTypeConverter typeConverter;  	private boolean ignoreUnknownFields = true;  	private boolean ignoreInvalidFields = false;  	private boolean autoGrowNestedPaths = true;  	private int autoGrowCollectionLimit = DEFAULT_AUTO_GROW_COLLECTION_LIMIT;  	@Nullable 	private String[] allowedFields;  	@Nullable 	private String[] disallowedFields;  	@Nullable 	private String[] requiredFields;  	@Nullable 	private ConversionService conversionService;  	@Nullable 	private MessageCodesResolver messageCodesResolver;  	private BindingErrorProcessor bindingErrorProcessor = new DefaultBindingErrorProcessor();  	private final List validators = new ArrayList&lt;&gt;();   	/** 	 * Create a new DataBinder instance, with default object name. 	 * @param target the target object to bind onto (or {@code null} 	 * if the binder is just used to convert a plain parameter value) 	 * @see #DEFAULT_OBJECT_NAME 	 */ 	public DataBinder(@Nullable Object target) { 		this(target, DEFAULT_OBJECT_NAME); 	}  	/** 	 * Create a new DataBinder instance. 	 * @param target the target object to bind onto (or {@code null} 	 * if the binder is just used to convert a plain parameter value) 	 * @param objectName the name of the target object 	 */ 	public DataBinder(@Nullable Object target, String objectName) { 		this.target = ObjectUtils.unwrapOptional(target); 		this.objectName = objectName; 	}   	/** 	 * Return the wrapped target object. 	 */ 	@Nullable 	public Object getTarget() { 		return this.target; 	}  	/** 	 * Return the name of the bound object. 	 */ 	public String getObjectName() { 		return this.objectName; 	}  	/** 	 * Set whether this binder should attempt to &quot;auto-grow&quot; a nested path that contains a null value. 	 * If &quot;true&quot;, a null path location will be populated with a default object value and traversed 	 * instead of resulting in an exception. This flag also enables auto-growth of collection elements 	 * when accessing an out-of-bounds index. 	 * Default is &quot;true&quot; on a standard DataBinder. Note that since Spring 4.1 this feature is supported 	 * for bean property access (DataBinder's default mode) and field access. 	 * @see #initBeanPropertyAccess() 	 * @see org.springframework.beans.BeanWrapper#setAutoGrowNestedPaths 	 */ 	public void setAutoGrowNestedPaths(boolean autoGrowNestedPaths) { 		Assert.state(this.bindingResult == null, 				&quot;DataBinder is already initialized - call setAutoGrowNestedPaths before other configuration methods&quot;); 		this.autoGrowNestedPaths = autoGrowNestedPaths; 	}  	/** 	 * Return whether &quot;auto-growing&quot; of nested paths has been activated. 	 */ 	public boolean isAutoGrowNestedPaths() { 		return this.autoGrowNestedPaths; 	}  	/** 	 * Specify the limit for array and collection auto-growing. 	 * Default is 256, preventing OutOfMemoryErrors in case of large indexes. 	 * Raise this limit if your auto-growing needs are unusually high. 	 * @see #initBeanPropertyAccess() 	 * @see org.springframework.beans.BeanWrapper#setAutoGrowCollectionLimit 	 */ 	public void setAutoGrowCollectionLimit(int autoGrowCollectionLimit) { 		Assert.state(this.bindingResult == null, 				&quot;DataBinder is already initialized - call setAutoGrowCollectionLimit before other configuration methods&quot;); 		this.autoGrowCollectionLimit = autoGrowCollectionLimit; 	}  	/** 	 * Return the current limit for array and collection auto-growing. 	 */ 	public int getAutoGrowCollectionLimit() { 		return this.autoGrowCollectionLimit; 	}  	/** 	 * Initialize standard JavaBean property access for this DataBinder. 	 * This is the default; an explicit call just leads to eager initialization. 	 * @see #initDirectFieldAccess() 	 * @see #createBeanPropertyBindingResult() 	 */ 	public void initBeanPropertyAccess() { 		Assert.state(this.bindingResult == null, 				&quot;DataBinder is already initialized - call initBeanPropertyAccess before other configuration methods&quot;); 		this.bindingResult = createBeanPropertyBindingResult(); 	}  	/** 	 * Create the {@link AbstractPropertyBindingResult} instance using standard 	 * JavaBean property access. 	 * @since 4.2.1 	 */ 	protected AbstractPropertyBindingResult createBeanPropertyBindingResult() { 		BeanPropertyBindingResult result = new BeanPropertyBindingResult(getTarget(), 				getObjectName(), isAutoGrowNestedPaths(), getAutoGrowCollectionLimit());  		if (this.conversionService != null) { 			result.initConversion(this.conversionService); 		} 		if (this.messageCodesResolver != null) { 			result.setMessageCodesResolver(this.messageCodesResolver); 		}  		return result; 	}  	/** 	 * Initialize direct field access for this DataBinder, 	 * as alternative to the default bean property access. 	 * @see #initBeanPropertyAccess() 	 * @see #createDirectFieldBindingResult() 	 */ 	public void initDirectFieldAccess() { 		Assert.state(this.bindingResult == null, 				&quot;DataBinder is already initialized - call initDirectFieldAccess before other configuration methods&quot;); 		this.bindingResult = createDirectFieldBindingResult(); 	}  	/** 	 * Create the {@link AbstractPropertyBindingResult} instance using direct 	 * field access. 	 * @since 4.2.1 	 */ 	protected AbstractPropertyBindingResult createDirectFieldBindingResult() { 		DirectFieldBindingResult result = new DirectFieldBindingResult(getTarget(), 				getObjectName(), isAutoGrowNestedPaths());  		if (this.conversionService != null) { 			result.initConversion(this.conversionService); 		} 		if (this.messageCodesResolver != null) { 			result.setMessageCodesResolver(this.messageCodesResolver); 		}  		return result; 	}  	/** 	 * Return the internal BindingResult held by this DataBinder, 	 * as an AbstractPropertyBindingResult. 	 */ 	protected AbstractPropertyBindingResult getInternalBindingResult() { 		if (this.bindingResult == null) { 			initBeanPropertyAccess(); 		} 		return this.bindingResult; 	}  	/** 	 * Return the underlying PropertyAccessor of this binder's BindingResult. 	 */ 	protected ConfigurablePropertyAccessor getPropertyAccessor() { 		return getInternalBindingResult().getPropertyAccessor(); 	}  	/** 	 * Return this binder's underlying SimpleTypeConverter. 	 */ 	protected SimpleTypeConverter getSimpleTypeConverter() { 		if (this.typeConverter == null) { 			this.typeConverter = new SimpleTypeConverter(); 			if (this.conversionService != null) { 				this.typeConverter.setConversionService(this.conversionService); 			} 		} 		return this.typeConverter; 	}  	/** 	 * Return the underlying TypeConverter of this binder's BindingResult. 	 */ 	protected PropertyEditorRegistry getPropertyEditorRegistry() { 		if (getTarget() != null) { 			return getInternalBindingResult().getPropertyAccessor(); 		} 		else { 			return getSimpleTypeConverter(); 		} 	}  	/** 	 * Return the underlying TypeConverter of this binder's BindingResult. 	 */ 	protected TypeConverter getTypeConverter() { 		if (getTarget() != null) { 			return getInternalBindingResult().getPropertyAccessor(); 		} 		else { 			return getSimpleTypeConverter(); 		} 	}  	/** 	 * Return the BindingResult instance created by this DataBinder. 	 * This allows for convenient access to the binding results after 	 * a bind operation. 	 * @return the BindingResult instance, to be treated as BindingResult 	 * or as Errors instance (Errors is a super-interface of BindingResult) 	 * @see Errors 	 * @see #bind 	 */ 	public BindingResult getBindingResult() { 		return getInternalBindingResult(); 	}   	/** 	 * Set whether to ignore unknown fields, that is, whether to ignore bind 	 * parameters that do not have corresponding fields in the target object. 	 * Default is &quot;true&quot;. Turn this off to enforce that all bind parameters 	 * must have a matching field in the target object. 	 * Note that this setting only applies to binding operations 	 * on this DataBinder, not to retrieving values via its 	 * {@link #getBindingResult() BindingResult}. 	 * @see #bind 	 */ 	public void setIgnoreUnknownFields(boolean ignoreUnknownFields) { 		this.ignoreUnknownFields = ignoreUnknownFields; 	}  	/** 	 * Return whether to ignore unknown fields when binding. 	 */ 	public boolean isIgnoreUnknownFields() { 		return this.ignoreUnknownFields; 	}  	/** 	 * Set whether to ignore invalid fields, that is, whether to ignore bind 	 * parameters that have corresponding fields in the target object which are 	 * not accessible (for example because of null values in the nested path). 	 * Default is &quot;false&quot;. Turn this on to ignore bind parameters for 	 * nested objects in non-existing parts of the target object graph. 	 * Note that this setting only applies to binding operations 	 * on this DataBinder, not to retrieving values via its 	 * {@link #getBindingResult() BindingResult}. 	 * @see #bind 	 */ 	public void setIgnoreInvalidFields(boolean ignoreInvalidFields) { 		this.ignoreInvalidFields = ignoreInvalidFields; 	}  	/** 	 * Return whether to ignore invalid fields when binding. 	 */ 	public boolean isIgnoreInvalidFields() { 		return this.ignoreInvalidFields; 	}  	/** 	 * Register fields that should be allowed for binding. Default is all 	 * fields. Restrict this for example to avoid unwanted modifications 	 * by malicious users when binding HTTP request parameters. 	 * Supports &quot;xxx*&quot;, &quot;*xxx&quot; and &quot;*xxx*&quot; patterns. More sophisticated matching 	 * can be implemented by overriding the {@code isAllowed} method. 	 * Alternatively, specify a list of disallowed fields. 	 * @param allowedFields array of field names 	 * @see #setDisallowedFields 	 * @see #isAllowed(String) 	 */ 	public void setAllowedFields(@Nullable String... allowedFields) { 		this.allowedFields = PropertyAccessorUtils.canonicalPropertyNames(allowedFields); 	}  	/** 	 * Return the fields that should be allowed for binding. 	 * @return array of field names 	 */ 	@Nullable 	public String[] getAllowedFields() { 		return this.allowedFields; 	}  	/** 	 * Register fields that should not be allowed for binding. Default is none. 	 * Mark fields as disallowed for example to avoid unwanted modifications 	 * by malicious users when binding HTTP request parameters. 	 * Supports &quot;xxx*&quot;, &quot;*xxx&quot; and &quot;*xxx*&quot; patterns. More sophisticated matching 	 * can be implemented by overriding the {@code isAllowed} method. 	 * Alternatively, specify a list of allowed fields. 	 * @param disallowedFields array of field names 	 * @see #setAllowedFields 	 * @see #isAllowed(String) 	 */ 	public void setDisallowedFields(@Nullable String... disallowedFields) { 		this.disallowedFields = PropertyAccessorUtils.canonicalPropertyNames(disallowedFields); 	}  	/** 	 * Return the fields that should not be allowed for binding. 	 * @return array of field names 	 */ 	@Nullable 	public String[] getDisallowedFields() { 		return this.disallowedFields; 	}  	/** 	 * Register fields that are required for each binding process. 	 * If one of the specified fields is not contained in the list of 	 * incoming property values, a corresponding &quot;missing field&quot; error 	 * will be created, with error code &quot;required&quot; (by the default 	 * binding error processor). 	 * @param requiredFields array of field names 	 * @see #setBindingErrorProcessor 	 * @see DefaultBindingErrorProcessor#MISSING_FIELD_ERROR_CODE 	 */ 	public void setRequiredFields(@Nullable String... requiredFields) { 		this.requiredFields = PropertyAccessorUtils.canonicalPropertyNames(requiredFields); 		if (logger.isDebugEnabled()) { 			logger.debug(&quot;DataBinder requires binding of required fields [&quot; + 					StringUtils.arrayToCommaDelimitedString(requiredFields) + &quot;]&quot;); 		} 	}  	/** 	 * Return the fields that are required for each binding process. 	 * @return array of field names 	 */ 	@Nullable 	public String[] getRequiredFields() { 		return this.requiredFields; 	}  	/** 	 * Set the strategy to use for resolving errors into message codes. 	 * Applies the given strategy to the underlying errors holder. 	 * Default is a DefaultMessageCodesResolver. 	 * @see BeanPropertyBindingResult#setMessageCodesResolver 	 * @see DefaultMessageCodesResolver 	 */ 	public void setMessageCodesResolver(@Nullable MessageCodesResolver messageCodesResolver) { 		Assert.state(this.messageCodesResolver == null, &quot;DataBinder is already initialized with MessageCodesResolver&quot;); 		this.messageCodesResolver = messageCodesResolver; 		if (this.bindingResult != null &amp;&amp; messageCodesResolver != null) { 			this.bindingResult.setMessageCodesResolver(messageCodesResolver); 		} 	}  	/** 	 * Set the strategy to use for processing binding errors, that is, 	 * required field errors and {@code PropertyAccessException}s. 	 * Default is a DefaultBindingErrorProcessor. 	 * @see DefaultBindingErrorProcessor 	 */ 	public void setBindingErrorProcessor(BindingErrorProcessor bindingErrorProcessor) { 		Assert.notNull(bindingErrorProcessor, &quot;BindingErrorProcessor must not be null&quot;); 		this.bindingErrorProcessor = bindingErrorProcessor; 	}  	/** 	 * Return the strategy for processing binding errors. 	 */ 	public BindingErrorProcessor getBindingErrorProcessor() { 		return this.bindingErrorProcessor; 	}  	/** 	 * Set the Validator to apply after each binding step. 	 * @see #addValidators(Validator...) 	 * @see #replaceValidators(Validator...) 	 */ 	public void setValidator(@Nullable Validator validator) { 		assertValidators(validator); 		this.validators.clear(); 		if (validator != null) { 			this.validators.add(validator); 		} 	}  	private void assertValidators(Validator... validators) { 		Object target = getTarget(); 		for (Validator validator : validators) { 			if (validator != null &amp;&amp; (target != null &amp;&amp; !validator.supports(target.getClass()))) { 				throw new IllegalStateException(&quot;Invalid target for Validator [&quot; + validator + &quot;]: &quot; + target); 			} 		} 	}  	/** 	 * Add Validators to apply after each binding step. 	 * @see #setValidator(Validator) 	 * @see #replaceValidators(Validator...) 	 */ 	public void addValidators(Validator... validators) { 		assertValidators(validators); 		this.validators.addAll(Arrays.asList(validators)); 	}  	/** 	 * Replace the Validators to apply after each binding step. 	 * @see #setValidator(Validator) 	 * @see #addValidators(Validator...) 	 */ 	public void replaceValidators(Validator... validators) { 		assertValidators(validators); 		this.validators.clear(); 		this.validators.addAll(Arrays.asList(validators)); 	}  	/** 	 * Return the primary Validator to apply after each binding step, if any. 	 */ 	@Nullable 	public Validator getValidator() { 		return (!this.validators.isEmpty() ? this.validators.get(0) : null); 	}  	/** 	 * Return the Validators to apply after data binding. 	 */ 	public List getValidators() { 		return Collections.unmodifiableList(this.validators); 	}   	//--------------------------------------------------------------------- 	// Implementation of PropertyEditorRegistry/TypeConverter interface 	//---------------------------------------------------------------------  	/** 	 * Specify a Spring 3.0 ConversionService to use for converting 	 * property values, as an alternative to JavaBeans PropertyEditors. 	 */ 	public void setConversionService(@Nullable ConversionService conversionService) { 		Assert.state(this.conversionService == null, &quot;DataBinder is already initialized with ConversionService&quot;); 		this.conversionService = conversionService; 		if (this.bindingResult != null &amp;&amp; conversionService != null) { 			this.bindingResult.initConversion(conversionService); 		} 	}  	/** 	 * Return the associated ConversionService, if any. 	 */ 	@Nullable 	public ConversionService getConversionService() { 		return this.conversionService; 	}  	/** 	 * Add a custom formatter, applying it to all fields matching the 	 * {@link Formatter}-declared type. 	 * Registers a corresponding {@link PropertyEditor} adapter underneath the covers. 	 * @param formatter the formatter to add, generically declared for a specific type 	 * @since 4.2 	 * @see #registerCustomEditor(Class, PropertyEditor) 	 */ 	public void addCustomFormatter(Formatter formatter) { 		FormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter); 		getPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter); 	}  	/** 	 * Add a custom formatter for the field type specified in {@link Formatter} class, 	 * applying it to the specified fields only, if any, or otherwise to all fields. 	 * Registers a corresponding {@link PropertyEditor} adapter underneath the covers. 	 * @param formatter the formatter to add, generically declared for a specific type 	 * @param fields the fields to apply the formatter to, or none if to be applied to all 	 * @since 4.2 	 * @see #registerCustomEditor(Class, String, PropertyEditor) 	 */ 	public void addCustomFormatter(Formatter formatter, String... fields) { 		FormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter); 		Class fieldType = adapter.getFieldType(); 		if (ObjectUtils.isEmpty(fields)) { 			getPropertyEditorRegistry().registerCustomEditor(fieldType, adapter); 		} 		else { 			for (String field : fields) { 				getPropertyEditorRegistry().registerCustomEditor(fieldType, field, adapter); 			} 		} 	}  	/** 	 * Add a custom formatter, applying it to the specified field types only, if any, 	 * or otherwise to all fields matching the {@link Formatter}-declared type. 	 * Registers a corresponding {@link PropertyEditor} adapter underneath the covers. 	 * @param formatter the formatter to add (does not need to generically declare a 	 * field type if field types are explicitly specified as parameters) 	 * @param fieldTypes the field types to apply the formatter to, or none if to be 	 * derived from the given {@link Formatter} implementation class 	 * @since 4.2 	 * @see #registerCustomEditor(Class, PropertyEditor) 	 */ 	public void addCustomFormatter(Formatter formatter, Class... fieldTypes) { 		FormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter); 		if (ObjectUtils.isEmpty(fieldTypes)) { 			getPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter); 		} 		else { 			for (Class fieldType : fieldTypes) { 				getPropertyEditorRegistry().registerCustomEditor(fieldType, adapter); 			} 		} 	}  	@Override 	public void registerCustomEditor(Class requiredType, PropertyEditor propertyEditor) { 		getPropertyEditorRegistry().registerCustomEditor(requiredType, propertyEditor); 	}  	@Override 	public void registerCustomEditor(@Nullable Class requiredType, @Nullable String field, PropertyEditor propertyEditor) { 		getPropertyEditorRegistry().registerCustomEditor(requiredType, field, propertyEditor); 	}  	@Override 	@Nullable 	public PropertyEditor findCustomEditor(@Nullable Class requiredType, @Nullable String propertyPath) { 		return getPropertyEditorRegistry().findCustomEditor(requiredType, propertyPath); 	}  	@Override 	@Nullable 	public  T convertIfNecessary(@Nullable Object value, @Nullable Class requiredType) throws TypeMismatchException { 		return getTypeConverter().convertIfNecessary(value, requiredType); 	}  	@Override 	@Nullable 	public  T convertIfNecessary(@Nullable Object value, @Nullable Class requiredType, 			@Nullable MethodParameter methodParam) throws TypeMismatchException {  		return getTypeConverter().convertIfNecessary(value, requiredType, methodParam); 	}  	@Override 	@Nullable 	public  T convertIfNecessary(@Nullable Object value, @Nullable Class requiredType, @Nullable Field field) 			throws TypeMismatchException {  		return getTypeConverter().convertIfNecessary(value, requiredType, field); 	}  	@Nullable 	@Override 	public  T convertIfNecessary(@Nullable Object value, @Nullable Class requiredType, 			@Nullable TypeDescriptor typeDescriptor) throws TypeMismatchException {  		return getTypeConverter().convertIfNecessary(value, requiredType, typeDescriptor); 	}   	/** 	 * Bind the given property values to this binder's target. 	 * This call can create field errors, representing basic binding 	 * errors like a required field (code &quot;required&quot;), or type mismatch 	 * between value and bean property (code &quot;typeMismatch&quot;). 	 * Note that the given PropertyValues should be a throwaway instance: 	 * For efficiency, it will be modified to just contain allowed fields if it 	 * implements the MutablePropertyValues interface; else, an internal mutable 	 * copy will be created for this purpose. Pass in a copy of the PropertyValues 	 * if you want your original instance to stay unmodified in any case. 	 * @param pvs property values to bind 	 * @see #doBind(org.springframework.beans.MutablePropertyValues) 	 */ 	public void bind(PropertyValues pvs) { 		MutablePropertyValues mpvs = (pvs instanceof MutablePropertyValues ? 				(MutablePropertyValues) pvs : new MutablePropertyValues(pvs)); 		doBind(mpvs); 	}  	/** 	 * Actual implementation of the binding process, working with the 	 * passed-in MutablePropertyValues instance. 	 * @param mpvs the property values to bind, 	 * as MutablePropertyValues instance 	 * @see #checkAllowedFields 	 * @see #checkRequiredFields 	 * @see #applyPropertyValues 	 */ 	protected void doBind(MutablePropertyValues mpvs) { 		checkAllowedFields(mpvs); 		checkRequiredFields(mpvs); 		applyPropertyValues(mpvs); 	}  	/** 	 * Check the given property values against the allowed fields, 	 * removing values for fields that are not allowed. 	 * @param mpvs the property values to be bound (can be modified) 	 * @see #getAllowedFields 	 * @see #isAllowed(String) 	 */ 	protected void checkAllowedFields(MutablePropertyValues mpvs) { 		PropertyValue[] pvs = mpvs.getPropertyValues(); 		for (PropertyValue pv : pvs) { 			String field = PropertyAccessorUtils.canonicalPropertyName(pv.getName()); 			if (!isAllowed(field)) { 				mpvs.removePropertyValue(pv); 				getBindingResult().recordSuppressedField(field); 				if (logger.isDebugEnabled()) { 					logger.debug(&quot;Field [&quot; + field + &quot;] has been removed from PropertyValues &quot; + 							&quot;and will not be bound, because it has not been found in the list of allowed fields&quot;); 				} 			} 		} 	}  	/** 	 * Return if the given field is allowed for binding. 	 * Invoked for each passed-in property value. 	 * The default implementation checks for &quot;xxx*&quot;, &quot;*xxx&quot; and &quot;*xxx*&quot; matches, 	 * as well as direct equality, in the specified lists of allowed fields and 	 * disallowed fields. A field matching a disallowed pattern will not be accepted 	 * even if it also happens to match a pattern in the allowed list. 	 * Can be overridden in subclasses. 	 * @param field the field to check 	 * @return if the field is allowed 	 * @see #setAllowedFields 	 * @see #setDisallowedFields 	 * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String) 	 */ 	protected boolean isAllowed(String field) { 		String[] allowed = getAllowedFields(); 		String[] disallowed = getDisallowedFields(); 		return ((ObjectUtils.isEmpty(allowed) || PatternMatchUtils.simpleMatch(allowed, field)) &amp;&amp; 				(ObjectUtils.isEmpty(disallowed) || !PatternMatchUtils.simpleMatch(disallowed, field))); 	}  	/** 	 * Check the given property values against the required fields, 	 * generating missing field errors where appropriate. 	 * @param mpvs the property values to be bound (can be modified) 	 * @see #getRequiredFields 	 * @see #getBindingErrorProcessor 	 * @see BindingErrorProcessor#processMissingFieldError 	 */ 	protected void checkRequiredFields(MutablePropertyValues mpvs) { 		String[] requiredFields = getRequiredFields(); 		if (!ObjectUtils.isEmpty(requiredFields)) { 			Map propertyValues = new HashMap&lt;&gt;(); 			PropertyValue[] pvs = mpvs.getPropertyValues(); 			for (PropertyValue pv : pvs) { 				String canonicalName = PropertyAccessorUtils.canonicalPropertyName(pv.getName()); 				propertyValues.put(canonicalName, pv); 			} 			for (String field : requiredFields) { 				PropertyValue pv = propertyValues.get(field); 				boolean empty = (pv == null || pv.getValue() == null); 				if (!empty) { 					if (pv.getValue() instanceof String) { 						empty = !StringUtils.hasText((String) pv.getValue()); 					} 					else if (pv.getValue() instanceof String[]) { 						String[] values = (String[]) pv.getValue(); 						empty = (values.length == 0 || !StringUtils.hasText(values[0])); 					} 				} 				if (empty) { 					// Use bind error processor to create FieldError. 					getBindingErrorProcessor().processMissingFieldError(field, getInternalBindingResult()); 					// Remove property from property values to bind: 					// It has already caused a field error with a rejected value. 					if (pv != null) { 						mpvs.removePropertyValue(pv); 						propertyValues.remove(field); 					} 				} 			} 		} 	}  	/** 	 * Apply given property values to the target object. 	 * Default implementation applies all of the supplied property 	 * values as bean property values. By default, unknown fields will 	 * be ignored. 	 * @param mpvs the property values to be bound (can be modified) 	 * @see #getTarget 	 * @see #getPropertyAccessor 	 * @see #isIgnoreUnknownFields 	 * @see #getBindingErrorProcessor 	 * @see BindingErrorProcessor#processPropertyAccessException 	 */ 	protected void applyPropertyValues(MutablePropertyValues mpvs) { 		try { 			// Bind request parameters onto target object. 			getPropertyAccessor().setPropertyValues(mpvs, isIgnoreUnknownFields(), isIgnoreInvalidFields()); 		} 		catch (PropertyBatchUpdateException ex) { 			// Use bind error processor to create FieldErrors. 			for (PropertyAccessException pae : ex.getPropertyAccessExceptions()) { 				getBindingErrorProcessor().processPropertyAccessException(pae, getInternalBindingResult()); 			} 		} 	}   	/** 	 * Invoke the specified Validators, if any. 	 * @see #setValidator(Validator) 	 * @see #getBindingResult() 	 */ 	public void validate() { 		Object target = getTarget(); 		Assert.state(target != null, &quot;No target to validate&quot;); 		BindingResult bindingResult = getBindingResult(); 		// Call each validator with the same binding result 		for (Validator validator : getValidators()) { 			validator.validate(target, bindingResult); 		} 	}  	/** 	 * Invoke the specified Validators, if any, with the given validation hints. 	 * Note: Validation hints may get ignored by the actual target Validator. 	 * @param validationHints one or more hint objects to be passed to a {@link SmartValidator} 	 * @since 3.1 	 * @see #setValidator(Validator) 	 * @see SmartValidator#validate(Object, Errors, Object...) 	 */ 	public void validate(Object... validationHints) { 		Object target = getTarget(); 		Assert.state(target != null, &quot;No target to validate&quot;); 		BindingResult bindingResult = getBindingResult(); 		// Call each validator with the same binding result 		for (Validator validator : getValidators()) { 			if (!ObjectUtils.isEmpty(validationHints) &amp;&amp; validator instanceof SmartValidator) { 				((SmartValidator) validator).validate(target, bindingResult, validationHints); 			} 			else if (validator != null) { 				validator.validate(target, bindingResult); 			} 		} 	}  	/** 	 * Close this DataBinder, which may result in throwing 	 * a BindException if it encountered any errors. 	 * @return the model Map, containing target object and Errors instance 	 * @throws BindException if there were any errors in the bind operation 	 * @see BindingResult#getModel() 	 */ 	public Map close() throws BindException { 		if (getBindingResult().hasErrors()) { 			throw new BindException(getBindingResult()); 		} 		return getBindingResult().getModel(); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">7554</td>
    <td align="left">https://github.com/spring-projects/spring-framework/blob/3a0f309e2c9fdbbf7fb2d348be861528177f8555/spring-context/src/main/java/org/springframework/validation/DataBinder.java/#L110-L911</td>
    <td align="right">1</td>
    <td align="right">794</td>
    <td align="right">7554</td>
  </tr>
  <tr valign="top">
    <td align="right">1422</td>
    <td align="left">&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [         &quot;1. Long Method&quot;,         &quot;2. Blob&quot;,         &quot;3. Data Class&quot;,         &quot;4. Feature Envy&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class AbstractAzureMojo extends AbstractMojo implements TelemetryConfiguration, AuthConfiguration {     public static final String PLUGIN_NAME_KEY = &quot;pluginName&quot;;     public static final String PLUGIN_VERSION_KEY = &quot;pluginVersion&quot;;     public static final String INSTALLATION_ID_KEY = &quot;installationId&quot;;     public static final String SESSION_ID_KEY = &quot;sessionId&quot;;     public static final String SUBSCRIPTION_ID_KEY = &quot;subscriptionId&quot;;     public static final String AUTH_TYPE = &quot;authType&quot;;     public static final String TELEMETRY_NOT_ALLOWED = &quot;TelemetryNotAllowed&quot;;     public static final String INIT_FAILURE = &quot;InitFailure&quot;;     public static final String AZURE_INIT_FAIL = &quot;Failed to authenticate with Azure. Please check your configuration.&quot;;     public static final String FAILURE_REASON = &quot;failureReason&quot;;     private static final String CONFIGURATION_PATH = Paths.get(System.getProperty(&quot;user.home&quot;),         &quot;.azure&quot;, &quot;mavenplugins.properties&quot;).toString();     private static final String FIRST_RUN_KEY = &quot;first.run&quot;;     private static final String PRIVACY_STATEMENT = &quot;\nData/Telemetry\n&quot; +         &quot;---------\n&quot; +         &quot;This project collects usage data and sends it to Microsoft to help improve our products and services.\n&quot; +         &quot;Read Microsoft's privacy statement to learn more: https://privacy.microsoft.com/en-us/privacystatement.&quot; +         &quot;\n\nYou can change your telemetry configuration through 'allowTelemetry' property.\n&quot; +         &quot;For more information, please go to https://aka.ms/azure-maven-config.\n&quot;;      //region Properties      @Parameter(defaultValue = &quot;${project}&quot;, readonly = true, required = true)     protected MavenProject project;      @Parameter(defaultValue = &quot;${session}&quot;, readonly = true, required = true)     protected MavenSession session;      @Parameter(defaultValue = &quot;${project.build.directory}&quot;, readonly = true, required = true)     protected File buildDirectory;      @Parameter(defaultValue = &quot;${plugin}&quot;, readonly = true, required = true)     protected PluginDescriptor plugin;      /**      * The system settings for Maven. This is the instance resulting from      * merging global and user-level settings files.      */     @Parameter(defaultValue = &quot;${settings}&quot;, readonly = true, required = true)     protected Settings settings;      @Component(role = MavenResourcesFiltering.class, hint = &quot;default&quot;)     protected MavenResourcesFiltering mavenResourcesFiltering;      /**      * Authentication setting for Azure Management API.      * Below are the supported sub-elements within {@code }. You can use one of them to authenticate      * with azure      * {@code } specifies the credentials of your Azure service principal, by referencing a server definition      * in Maven's settings.xml      * {@code } specifies the absolute path of your authentication file for Azure.      *      * @since 0.1.0      */     @Parameter     protected AuthenticationSetting authentication;      /**      * Azure subscription Id. You only need to specify it when:      *       * you are using authentication file      * there are more than one subscription in the authentication file      *       *      * @since 0.1.0      */     @Parameter     protected String subscriptionId = &quot;&quot;;      /**      * Boolean flag to turn on/off telemetry within current Maven plugin.      *      * @since 0.1.0      */     @Parameter(property = &quot;allowTelemetry&quot;, defaultValue = &quot;true&quot;)     protected boolean allowTelemetry;      /**      * Boolean flag to control whether throwing exception from current Maven plugin when meeting any error.      * If set to true, the exception from current Maven plugin will fail the current Maven run.      *      * @since 0.1.0      */     @Parameter(property = &quot;failsOnError&quot;, defaultValue = &quot;true&quot;)     protected boolean failsOnError;      /**      * Use a HTTP proxy host for the Azure Auth Client      */     @Parameter(property = &quot;httpProxyHost&quot;, readonly = false, required = false)     protected String httpProxyHost;      /**      * Use a HTTP proxy port for the Azure Auth Client      */     @Parameter(property = &quot;httpProxyPort&quot;, defaultValue = &quot;80&quot;)     protected int httpProxyPort;      private AzureAuthHelper azureAuthHelper = new AzureAuthHelper(this);      private Azure azure;      private TelemetryProxy telemetryProxy;      private String sessionId = UUID.randomUUID().toString();      private String installationId = GetHashMac.getHashMac();      //endregion      //region Getter      public MavenProject getProject() {         return project;     }      public MavenSession getSession() {         return session;     }      public String getBuildDirectoryAbsolutePath() {         return buildDirectory.getAbsolutePath();     }      public MavenResourcesFiltering getMavenResourcesFiltering() {         return mavenResourcesFiltering;     }      public Settings getSettings() {         return settings;     }      public AuthenticationSetting getAuthenticationSetting() {         return authentication;     }      public String getSubscriptionId() {         return subscriptionId;     }      public boolean isTelemetryAllowed() {         return allowTelemetry;     }      public boolean isFailingOnError() {         return failsOnError;     }      public String getSessionId() {         return sessionId;     }      public String getInstallationId() {         return installationId == null ? &quot;&quot; : installationId;     }      public String getPluginName() {         return plugin.getArtifactId();     }      public String getPluginVersion() {         return plugin.getVersion();     }      public String getUserAgent() {         return isTelemetryAllowed() ? String.format(&quot;%s/%s %s:%s %s:%s&quot;, getPluginName(), getPluginVersion(),                         INSTALLATION_ID_KEY, getInstallationId(), SESSION_ID_KEY, getSessionId())                 : String.format(&quot;%s/%s&quot;, getPluginName(), getPluginVersion());     }      public String getHttpProxyHost() {         return httpProxyHost;     }            public int getHttpProxyPort() {         return httpProxyPort;     }       public Azure getAzureClient() throws AzureAuthFailureException {         if (azure == null) {             azure = azureAuthHelper.getAzureClient();             if (azure == null) {                 getTelemetryProxy().trackEvent(INIT_FAILURE);                 throw new AzureAuthFailureException(AZURE_INIT_FAIL);             } else {                 // Repopulate subscriptionId in case it is not configured.                 getTelemetryProxy().addDefaultProperty(SUBSCRIPTION_ID_KEY, azure.subscriptionId());             }         }         return azure;     }      public TelemetryProxy getTelemetryProxy() {         if (telemetryProxy == null) {             initTelemetry();         }         return telemetryProxy;     }      protected void initTelemetry() {         telemetryProxy = new AppInsightsProxy(this);         if (!isTelemetryAllowed()) {             telemetryProxy.trackEvent(TELEMETRY_NOT_ALLOWED);             telemetryProxy.disable();         }     }      //endregion      //region Telemetry Configuration Interface      public Map getTelemetryProperties() {         final Map map = new HashMap&lt;&gt;();         map.put(INSTALLATION_ID_KEY, getInstallationId());         map.put(PLUGIN_NAME_KEY, getPluginName());         map.put(PLUGIN_VERSION_KEY, getPluginVersion());         map.put(SUBSCRIPTION_ID_KEY, getSubscriptionId());         map.put(SESSION_ID_KEY, getSessionId());         map.put(AUTH_TYPE, getAuthType());         return map;     }      // TODO:     // Add AuthType ENUM and move to AzureAuthHelper.     public String getAuthType() {         final AuthenticationSetting authSetting = getAuthenticationSetting();         if (authSetting == null) {             return &quot;AzureCLI&quot;;         }         if (StringUtils.isNotEmpty(authSetting.getServerId())) {             return &quot;ServerId&quot;;         }         if (authSetting.getFile() != null) {             return &quot;AuthFile&quot;;         }         return &quot;Unknown&quot;;     }      //endregion      //region Entry Point      @Override     public void execute() throws MojoExecutionException {         try {             // Work around for Application Insights Java SDK:             // Sometimes, NoClassDefFoundError will be thrown even after Maven build is completed successfully.             // An issue has been filed at https://github.com/Microsoft/ApplicationInsights-Java/issues/416             // Before this issue is fixed, set default uncaught exception handler for all threads as work around.             Thread.setDefaultUncaughtExceptionHandler(new DefaultUncaughtExceptionHandler());              final Properties prop = new Properties();             if (isFirstRun(prop)) {                 infoWithMultipleLines(PRIVACY_STATEMENT);                 updateConfigurationFile(prop);             }              if (isSkipMojo()) {                 info(&quot;Skip execution.&quot;);                 trackMojoSkip();             } else {                 trackMojoStart();                  doExecute();                  trackMojoSuccess();             }         } catch (Exception e) {             handleException(e);         } finally {             // When maven goal executes too quick, The HTTPClient of AI SDK may not fully initialized and will step             // into endless loop when close, we need to call it in main thread.             // Refer here for detail codes: https://github.com/Microsoft/ApplicationInsights-Java/blob/master/core/src             // /main/java/com/microsoft/applicationinsights/internal/channel/common/ApacheSender43.java#L103             ApacheSenderFactory.INSTANCE.create().close();         }     }      /**      * Sub-class can override this method to decide whether skip execution.      *      * @return Boolean to indicate whether skip execution.      */     protected boolean isSkipMojo() {         return false;     }      /**      * Entry point of sub-class. Sub-class should implement this method to do real work.      *      * @throws Exception      */     protected abstract void doExecute() throws Exception;      //endregion      //region Telemetry      protected void trackMojoSkip() {         getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + &quot;.skip&quot;);     }      protected void trackMojoStart() {         getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + &quot;.start&quot;);     }      protected void trackMojoSuccess() {         getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + &quot;.success&quot;);     }      protected void trackMojoFailure(final String message) {         final HashMap failureReason = new HashMap&lt;&gt;();         failureReason.put(FAILURE_REASON, message);         getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + &quot;.failure&quot;, failureReason);     }      //endregion      //region Helper methods      protected void handleException(final Exception exception) throws MojoExecutionException {         String message = exception.getMessage();         if (StringUtils.isEmpty(message)) {             message = exception.toString();         }         trackMojoFailure(message);          if (isFailingOnError()) {             throw new MojoExecutionException(message, exception);         } else {             error(message);         }     }      private boolean isFirstRun(Properties prop) {         try {             final File configurationFile = new File(CONFIGURATION_PATH);             if (configurationFile.exists()) {                 try (InputStream input = new FileInputStream(CONFIGURATION_PATH)) {                     prop.load(input);                     final String firstRunValue = prop.getProperty(FIRST_RUN_KEY);                     if (firstRunValue != null &amp;&amp; !firstRunValue.isEmpty() &amp;&amp; firstRunValue.equalsIgnoreCase(&quot;false&quot;)) {                         return false;                     }                 }             } else {                 configurationFile.getParentFile().mkdirs();                 configurationFile.createNewFile();             }         } catch (Exception e) {             // catch exceptions here to avoid blocking mojo execution.             debug(e.getMessage());         }         return true;     }      private void updateConfigurationFile(Properties prop) {         try (OutputStream output = new FileOutputStream(CONFIGURATION_PATH)) {             prop.setProperty(FIRST_RUN_KEY, &quot;false&quot;);             prop.store(output, &quot;Azure Maven Plugin configurations&quot;);         } catch (Exception e) {             // catch exceptions here to avoid blocking mojo execution.             debug(e.getMessage());         }     }      protected class DefaultUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {         @Override         public void uncaughtException(Thread t, Throwable e) {             debug(&quot;uncaughtException: &quot; + e);         }     }      //endregion      //region Logging      public void debug(final String message) {         getLog().debug(message);     }      public void info(final String message) {         getLog().info(message);     }      public void infoWithMultipleLines(final String messages) {         final String[] messageArray = messages.split(&quot;\\n&quot;);         for (final String line : messageArray) {             getLog().info(line);         }     }      public void warning(final String message) {         getLog().warn(message);     }      public void error(final String message) {         getLog().error(message);     }      //endregion }</td>
    <td align="left">data class</td>
    <td align="left">1 Long Method, 2 Blob, 3 Data Class, 4 Feature Envy</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">1. Long Method,  2. Blob,  4. Feature Envy</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10932</td>
    <td align="left">https://github.com/Microsoft/azure-maven-plugins/blob/d3e0b6fa0e00f38c04b622589a939fb3bae2227e/azure-maven-plugin-lib/src/main/java/com/microsoft/azure/maven/AbstractAzureMojo.java/#L45-L447</td>
    <td align="right">1</td>
    <td align="right">1422</td>
    <td align="right">10932</td>
  </tr>
  <tr valign="top">
    <td align="right">749</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;answer&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: &quot;the bad smells are: 1. Blob, 2. Data Class&quot;     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;}) public final class None extends Option {     private static final None INSTANCE = new None&lt;&gt;();      /**      * Get the static instance.      * @param  The type of this no-value object.      * @return the static instance      */     public static final  None getInstance() {         return INSTANCE;     }      /**      * Default constructor, does nothing.      */     public None() {         // super(null);         // no-op     }      @Override     public boolean hasValue() {         return false;     }      @Override     public T getValue() {         throw new NoSuchElementException(&quot;None does not contain a value&quot;);     }      @Override     public String toString() {         return &quot;None()&quot;;     }      @Override     public boolean equals(Object other) {         return (other == null || other.getClass() != None.class) ? false : true;     }      @Override     public int hashCode() {         return -31;     }  }</td>
    <td align="left">data class</td>
    <td align="left">the bad smells are: 1. blob, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">the bad smells are: 1. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7022</td>
    <td align="left">https://github.com/apache/pivot/blob/568543f3396648a646341fe077a714eb06d556c0/core/src/org/apache/pivot/functional/monad/None.java/#L24-L70</td>
    <td align="right">1</td>
    <td align="right">749</td>
    <td align="right">7022</td>
  </tr>
  <tr valign="top">
    <td align="right">476</td>
    <td align="left">{&quot;output&quot;: &quot;YES, I found bad smells. The bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class ConfigBoolean extends ConfigVariable {     public ConfigBoolean(OptionSpec spec)     {         super(spec);          this.enabled = false;         this.isSet = false;     }      public ConfigBoolean(OptionSpec spec, boolean enabled)     {         super(spec);         this.set(enabled);     }          private boolean enabled;     private boolean isSet;       public void set(boolean value)     {         this.enabled = value;         this.isSet = true;     }      public void set(String value)     {         this.enabled = parseValue(value);         this.isSet = true;     }      public boolean isSet()     {     	return isSet;     	}      public void addToCommandline(Commandline cmdline)     {         if (isSet)             cmdline.createArgument(true).setValue(&quot;-&quot; + spec.getFullName() + &quot;=&quot; + enabled);     }      private boolean parseValue(String value)     {         return value.toLowerCase().matches(&quot;\\s*(true|yes|on)\\s*&quot;);     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">&nbsp; </td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">4588</td>
    <td align="left">https://github.com/apache/royale-compiler/blob/fbd9bc3b9e48c80dbd8c1d32a6f83221e314efdd/royale-ant-tasks/src/main/java/org/apache/royale/compiler/ant/config/ConfigBoolean.java/#L28-L75</td>
    <td align="right">1</td>
    <td align="right">476</td>
    <td align="right">4588</td>
  </tr>
  <tr valign="top">
    <td align="right">227</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  @JsonDeserialize(using = AggregationsDeserializer.class)   static class Aggregations implements Iterable {      private final List aggregations;     private Map aggregationsAsMap;      Aggregations(List aggregations) {       this.aggregations = Objects.requireNonNull(aggregations, &quot;aggregations&quot;);     }      /**      * Iterates over the {@link Aggregation}s.      */     @Override public final Iterator iterator() {       return asList().iterator();     }      /**      * The list of {@link Aggregation}s.      */     final List asList() {       return Collections.unmodifiableList(aggregations);     }      /**      * Returns the {@link Aggregation}s keyed by aggregation name. Lazy init.      */     final Map asMap() {       if (aggregationsAsMap == null) {         Map map = new LinkedHashMap&lt;&gt;(aggregations.size());         for (Aggregation aggregation : aggregations) {           map.put(aggregation.getName(), aggregation);         }         this.aggregationsAsMap = unmodifiableMap(map);       }       return aggregationsAsMap;     }      /**      * Returns the aggregation that is associated with the specified name.      */     @SuppressWarnings(&quot;unchecked&quot;)     public final  A get(String name) {       return (A) asMap().get(name);     }      @Override public final boolean equals(Object obj) {       if (obj == null || getClass() != obj.getClass()) {         return false;       }       return aggregations.equals(((Aggregations) obj).aggregations);     }      @Override public final int hashCode() {       return Objects.hash(getClass(), aggregations);     }    }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2450</td>
    <td align="left">https://github.com/apache/calcite/blob/a648f9c12309cc253628930b0cab98591caa66ab/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchJson.java/#L390-L447</td>
    <td align="right">1</td>
    <td align="right">227</td>
    <td align="right">2450</td>
  </tr>
  <tr valign="top">
    <td align="right">798</td>
    <td align="left">&nbsp;	{ 		&quot;message&quot;: &quot;YES I found bad smells&quot;, 		&quot;bad smells are&quot;: [ 			&quot;Data Class&quot;, 			&quot;Long Method&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class RowReadSupport extends ReadSupport {  	private TypeInformation returnTypeInfo;  	@Override 	public ReadContext init(InitContext initContext) { 		checkNotNull(initContext, &quot;initContext&quot;); 		returnTypeInfo = ParquetSchemaConverter.fromParquetType(initContext.getFileSchema()); 		return new ReadContext(initContext.getFileSchema()); 	}  	@Override 	public RecordMaterializer prepareForRead( 		Configuration configuration, Map keyValueMetaData, 		MessageType fileSchema, ReadContext readContext) { 		return new RowMaterializer(readContext.getRequestedSchema(), returnTypeInfo); 	} }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7569</td>
    <td align="left">https://github.com/apache/flink/blob/8068c8775ad067d75828e6360e7e0994348da9b9/flink-formats/flink-parquet/src/main/java/org/apache/flink/formats/parquet/utils/RowReadSupport.java/#L37-L54</td>
    <td align="right">1</td>
    <td align="right">798</td>
    <td align="right">7569</td>
  </tr>
  <tr valign="top">
    <td align="right">549</td>
    <td align="left">&nbsp;YES I found bad smells the bad smells are: 1. Data class 2. Feature envy</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
@Entity public class Tower extends Item {      private Fit fit;     private String tubing;      public static enum Fit {         Custom,         Exact,         Universal     }      public Fit getFit() {         return fit;     }      public void setFit(Fit fit) {         this.fit = fit;     }      public String getTubing() {         return tubing;     }      public void setTubing(String tubing) {         this.tubing = tubing;     }      ; }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Data class2 Feature envy</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5558</td>
    <td align="left">https://github.com/apache/tomee/blob/d21933b313aff812fe5188b57bf572a9ad649148/examples/webservice-inheritance/src/main/java/org/superbiz/inheritance/Tower.java/#L21-L50</td>
    <td align="right">2</td>
    <td align="right">549</td>
    <td align="right">5558</td>
  </tr>
  <tr valign="top">
    <td align="right">1754</td>
    <td align="left">&nbsp;YES I found bad smells the bad smells are: 1. Data class 2. Repeated code for getters and setters</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class LaunchRequest { 	private String jobName;  	String jobParameters;  	public String getJobName() { 		return jobName; 	}  	public void setJobName(String jobName) { 		this.jobName = jobName; 	}  	public String getJobParameters() { 		return jobParameters; 	}  	public void setJobParameters(String jobParameters) { 		this.jobParameters = jobParameters; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Data class2 Repeated code for getters and setters</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11867</td>
    <td align="left">https://github.com/spring-projects/spring-batch-admin/blob/9e3ad8bff99b8fad8da62426aa7d2959eb841bcf/spring-batch-admin-manager/src/main/java/org/springframework/batch/admin/web/LaunchRequest.java/#L21-L42</td>
    <td align="right">2</td>
    <td align="right">1754</td>
    <td align="right">11867</td>
  </tr>
  <tr valign="top">
    <td align="right">304</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement public class Book {      private int id;     private String name;      public Book() {}      public Book(int bookId, String name) {         this.id = bookId;         this.name = name;     }      public int getId() {         return id;     }      public void setId(int id) {         this.id = id;     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3183</td>
    <td align="left">https://github.com/apache/tomee/blob/d21933b313aff812fe5188b57bf572a9ad649148/examples/mp-rest-client/src/main/java/org/superbiz/rest/Book.java/#L22-L50</td>
    <td align="right">1</td>
    <td align="right">304</td>
    <td align="right">3183</td>
  </tr>
  <tr valign="top">
    <td align="right">111</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [&quot;Data Class&quot;]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class BaseObject {  	/** Type identifier of the object */ 	public String type;  	/** 	 * Constructs an empty object 	 */ 	public BaseObject() { 		type = this.getClass().getCanonicalName(); 	}  	/** 	 * Constructs object with a given type 	 * @param type the type identifier 	 */ 	public BaseObject(String type) { 		this.type = type; 	}  	/** 	 * Get type of this object. 	 * @return type of the object 	 */ 	public String getType() { 		return type; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1461</td>
    <td align="left">https://github.com/spring-projects/spring-hadoop/blob/cda92b8ab6b5e8a8defe8ae5822e966e0a9d34eb/spring-yarn/spring-yarn-integration/src/main/java/org/springframework/yarn/integration/ip/mind/binding/BaseObject.java/#L24-L52</td>
    <td align="right">1</td>
    <td align="right">111</td>
    <td align="right">1461</td>
  </tr>
  <tr valign="top">
    <td align="right">2271</td>
    <td align="left">&nbsp;&nbsp;	{ 	&quot;output&quot;: &quot;YES I found bad smells&quot;, 	&quot;bad smells are&quot;: [&quot;Data Class&quot;] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class BaseObject {  	/** Type identifier of the object */ 	public String type;  	/** 	 * Constructs an empty object 	 */ 	public BaseObject() { 		type = this.getClass().getCanonicalName(); 	}  	/** 	 * Constructs object with a given type 	 * @param type the type identifier 	 */ 	public BaseObject(String type) { 		this.type = type; 	}  	/** 	 * Get type of this object. 	 * @return type of the object 	 */ 	public String getType() { 		return type; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13766</td>
    <td align="left">https://github.com/spring-projects/spring-hadoop/blob/cda92b8ab6b5e8a8defe8ae5822e966e0a9d34eb/spring-yarn/spring-yarn-integration/src/main/java/org/springframework/yarn/integration/ip/mind/binding/BaseObject.java/#L24-L52</td>
    <td align="right">1</td>
    <td align="right">2271</td>
    <td align="right">13766</td>
  </tr>
  <tr valign="top">
    <td align="right">1249</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Implements(NfcAdapter.class) public class ShadowNfcAdapter {   @RealObject NfcAdapter nfcAdapter;   private static boolean hardwareExists = true;   private boolean enabled;   private Activity enabledActivity;   private PendingIntent intent;   private IntentFilter[] filters;   private String[][] techLists;   private Activity disabledActivity;   private NdefMessage ndefPushMessage;   private boolean ndefPushMessageSet;   private NfcAdapter.CreateNdefMessageCallback ndefPushMessageCallback;   private NfcAdapter.OnNdefPushCompleteCallback onNdefPushCompleteCallback;    @Implementation   protected static NfcAdapter getNfcAdapter(Context context) {     if (!hardwareExists) {       return null;     }     return ReflectionHelpers.callConstructor(NfcAdapter.class);   }    @Implementation   protected void enableForegroundDispatch(       Activity activity, PendingIntent intent, IntentFilter[] filters, String[][] techLists) {     this.enabledActivity = activity;     this.intent = intent;     this.filters = filters;     this.techLists = techLists;   }    @Implementation   protected void disableForegroundDispatch(Activity activity) {     disabledActivity = activity;   }    /**    * Mocks setting NDEF push message so that it could be verified in the test. Use {@link    * #getNdefPushMessage()} to verify that message was set.    */   @Implementation   protected void setNdefPushMessage(       NdefMessage message, Activity activity, Activity... activities) {     if (activity == null) {       throw new NullPointerException(&quot;activity cannot be null&quot;);     }     for (Activity a : activities) {       if (a == null) {         throw new NullPointerException(&quot;activities cannot contain null&quot;);       }     }     this.ndefPushMessage = message;     this.ndefPushMessageSet = true;   }    @Implementation   protected void setNdefPushMessageCallback(       NfcAdapter.CreateNdefMessageCallback callback, Activity activity, Activity... activities) {     this.ndefPushMessageCallback = callback;   }    /**    * Sets callback that should be used on successful Android Beam (TM).    *    * The last registered callback is recalled and can be fetched using {@link    * #getOnNdefPushCompleteCallback}.    */   @Implementation   protected void setOnNdefPushCompleteCallback(       NfcAdapter.OnNdefPushCompleteCallback callback, Activity activity, Activity... activities) {     if (activity == null) {       throw new NullPointerException(&quot;activity cannot be null&quot;);     }     for (Activity a : activities) {       if (a == null) {         throw new NullPointerException(&quot;activities cannot contain null&quot;);       }     }     this.onNdefPushCompleteCallback = callback;   }    @Implementation   protected boolean isEnabled() {     return enabled;   }    /**    * Modifies behavior of {@link #getNfcAdapter(Context)} to return {@code null}, to simulate    * absence of NFC hardware.    */   public static void setNfcHardwareExists(boolean hardwareExists) {     ShadowNfcAdapter.hardwareExists = hardwareExists;   }    public void setEnabled(boolean enabled) {     this.enabled = enabled;   }    public Activity getEnabledActivity() {     return enabledActivity;   }    public PendingIntent getIntent() {     return intent;   }    public IntentFilter[] getFilters() {     return filters;   }    public String[][] getTechLists() {     return techLists;   }    public Activity getDisabledActivity() {     return disabledActivity;   }    /** Returns last registered callback, or {@code null} if none was set. */   public NfcAdapter.CreateNdefMessageCallback getNdefPushMessageCallback() {     return ndefPushMessageCallback;   }    public NfcAdapter.OnNdefPushCompleteCallback getOnNdefPushCompleteCallback() {     return onNdefPushCompleteCallback;   }    /** Returns last set NDEF message, or throws {@code IllegalStateException} if it was never set. */   public NdefMessage getNdefPushMessage() {     if (!ndefPushMessageSet) {       throw new IllegalStateException();     }     return ndefPushMessage;   }    @Resetter   public static synchronized void reset() {     hardwareExists = true;   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10434</td>
    <td align="left">https://github.com/robolectric/robolectric/blob/525bfcfc0e0ed1653ad57341b564c6857e11dc50/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNfcAdapter.java/#L15-L155</td>
    <td align="right">1</td>
    <td align="right">1249</td>
    <td align="right">10434</td>
  </tr>
  <tr valign="top">
    <td align="right">789</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES, I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;1. Blob&quot;,       &quot;2. Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class DAOAttachment {         private final AttachmentId attachmentId;         private final BlobId blobId;         private final String type;         private final long size;          private DAOAttachment(AttachmentId attachmentId, BlobId blobId, String type, long size) {             this.attachmentId = attachmentId;             this.blobId = blobId;             this.type = type;             this.size = size;         }          public AttachmentId getAttachmentId() {             return attachmentId;         }          public BlobId getBlobId() {             return blobId;         }          public String getType() {             return type;         }          public long getSize() {             return size;         }          public Attachment toAttachment(byte[] data) {             return Attachment.builder()                 .attachmentId(attachmentId)                 .type(type)                 .bytes(data)                 .build();         }          @Override         public final boolean equals(Object o) {             if (o instanceof DAOAttachment) {                 DAOAttachment that = (DAOAttachment) o;                  return Objects.equals(this.size, that.size)                     &amp;&amp; Objects.equals(this.attachmentId, that.attachmentId)                     &amp;&amp; Objects.equals(this.blobId, that.blobId)                     &amp;&amp; Objects.equals(this.type, that.type);             }             return false;         }          @Override         public final int hashCode() {             return Objects.hash(attachmentId, blobId, type, size);         }     }</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7520</td>
    <td align="left">https://github.com/apache/james-project/blob/fa24a096a5853459c3769a34ccc68feb91626bfa/mailbox/cassandra/src/main/java/org/apache/james/mailbox/cassandra/mail/CassandraAttachmentDAOV2.java/#L50-L104</td>
    <td align="right">1</td>
    <td align="right">789</td>
    <td align="right">7520</td>
  </tr>
  <tr valign="top">
    <td align="right">2421</td>
    <td align="left">&nbsp;{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;bad_smells&quot;: [     &quot;Long Method&quot;,     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class FieldAttributeModel {    /** Typescript value of the type of the field */   private final String typeName;    /** For Map, List object, need to initialize field first. Like new Field&lt;&gt;() */   private boolean needInitialize;    /** Name of the field */   private String fieldName;    /** Java Type of the object (used internally) */   private Type type;    /** This field type is a List of objects ? */   private boolean isList;    /** This field type is a simple primitive */   private boolean isPrimitive;    /** This field type is a map */   private boolean isMap;    /** This list type is in fact a list of DTOs */   private boolean isListOfDto;    /** This map type is a map of DTOs */   private boolean isMapOfDto;    /**    * The type is a DTO or a list of DTO and then this value is the name of the DTO implementation    */   private String dtoImpl;    /** type is a DTO object. */   private boolean isDto;    /** type is a Enum object. */   private boolean isEnum;    /** Map key type */   private String mapKeyType;    /** Map value type */   private String mapValueType;    /** Dto type for d.ts */   private String dtsType;    /** Dto class where this field declared */   private Class declarationClass;    /**    * Build a new field model based on the name and Java type    *    * @param fieldName the name of the field    * @param type the Java raw type that will allow further analyzes    * @param declarationClass    */   public FieldAttributeModel(String fieldName, Type type, Class declarationClass) {     this.fieldName = fieldName;     this.type = type;     this.typeName = convertType(type);     this.dtsType = convertTypeForDTS(declarationClass, type);     this.declarationClass = declarationClass;      if (typeName.startsWith(&quot;Array&lt;&quot;) || typeName.startsWith(&quot;Map&lt;&quot;)) {       this.needInitialize = true;     }      if (this.type instanceof ParameterizedType) {       ParameterizedType parameterizedType = (ParameterizedType) this.type;       Type rawType = parameterizedType.getRawType();       analyzeParametrizedType(parameterizedType, rawType);     } else if (Primitives.isPrimitive(this.type)         || Primitives.isWrapperType(this.type)         || String.class.equals(this.type)) {       this.isPrimitive = true;     } else if (this.type instanceof Class &amp;&amp; ((Class) this.type).isAnnotationPresent(DTO.class)) {       this.isDto = true;       dtoImpl = this.type.getTypeName() + &quot;Impl&quot;;     } else if (this.type instanceof Class &amp;&amp; ((Class) this.type).isEnum()) {       this.isEnum = true;     }   }    /**    * Analyze a complex parametrized type attribute (which can be a list or map for example)    *    * @param parameterizedType    * @param rawType    */   protected void analyzeParametrizedType(ParameterizedType parameterizedType, Type rawType) {     if (List.class.equals(rawType)) {       this.isList = true;       if (parameterizedType.getActualTypeArguments()[0] instanceof Class           &amp;&amp; ((Class) parameterizedType.getActualTypeArguments()[0])               .isAnnotationPresent(DTO.class)) {         isListOfDto = true;         dtoImpl = convertType(parameterizedType.getActualTypeArguments()[0]) + &quot;Impl&quot;;       }     } else if (Map.class.equals(rawType)) {       isMap = true;       mapKeyType =           convertTypeForDTS(declarationClass, parameterizedType.getActualTypeArguments()[0]);       if (parameterizedType.getActualTypeArguments()[1] instanceof Class           &amp;&amp; ((Class) parameterizedType.getActualTypeArguments()[1])               .isAnnotationPresent(DTO.class)) {          isMapOfDto = true;         dtoImpl = convertType(parameterizedType.getActualTypeArguments()[1]) + &quot;Impl&quot;;       }        mapValueType =           convertTypeForDTS(declarationClass, parameterizedType.getActualTypeArguments()[1]);     }   }    public String getTypeName() {     return typeName;   }    public String getFieldName() {     return fieldName;   }    public Type getType() {     return type;   }    public boolean isList() {     return isList;   }    public boolean isPrimitive() {     return isPrimitive;   }    public boolean isMap() {     return isMap;   }    public boolean isListOfDto() {     return isListOfDto;   }    public boolean isMapOfDto() {     return isMapOfDto;   }    public String getDtoImpl() {     return dtoImpl;   }    public boolean isDto() {     return isDto;   }    public boolean isNeedInitialize() {     return needInitialize;   }    public boolean isEnum() {     return isEnum;   }    public String getName() {     return this.fieldName;   }    public String getSimpleType() {     return this.typeName;   }    public String getMapKeyType() {     return mapKeyType;   }    public String getMapValueType() {     return mapValueType;   }    public String getDtsType() {     return dtsType;   } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14434</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/core/che-core-typescript-dto-maven-plugin/src/main/java/org/eclipse/che/plugin/typescript/dto/model/FieldAttributeModel.java/#L29-L214</td>
    <td align="right">1</td>
    <td align="right">2421</td>
    <td align="right">14434</td>
  </tr>
  <tr valign="top">
    <td align="right">2199</td>
    <td align="left">{     &quot;answer&quot;: &quot;YES I found bad smells&quot;,     &quot;bad_smells&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
None</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13495</td>
    <td align="left">https://github.com/apache/accumulo/blob/f896c98c2356a52dfa2235d2cc02ae556ab17909/proxy/src/main/java/org/apache/accumulo/proxy/thrift/AccumuloProxy.java/#L30526-L31009</td>
    <td align="right">1</td>
    <td align="right">2199</td>
    <td align="right">13495</td>
  </tr>
  <tr valign="top">
    <td align="right">1130</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Long Method&quot;,       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ImportImpl extends ElementImpl implements Import {   /**    * The default value of the '{@link #getImportedNamespace() Imported Namespace}' attribute.    *     *     * @see #getImportedNamespace()    * @generated    * @ordered    */   protected static final String IMPORTED_NAMESPACE_EDEFAULT = null;    /**    * The cached value of the '{@link #getImportedNamespace() Imported Namespace}' attribute.    *     *     * @see #getImportedNamespace()    * @generated    * @ordered    */   protected String importedNamespace = IMPORTED_NAMESPACE_EDEFAULT;    /**    *     *     * @generated    */   protected ImportImpl()   {     super();   }    /**    *     *     * @generated    */   @Override   protected EClass eStaticClass()   {     return SDomainPackage.Literals.IMPORT;   }    /**    *     *     * @generated    */   public String getImportedNamespace()   {     return importedNamespace;   }    /**    *     *     * @generated    */   public void setImportedNamespace(String newImportedNamespace)   {     String oldImportedNamespace = importedNamespace;     importedNamespace = newImportedNamespace;     if (eNotificationRequired())       eNotify(new ENotificationImpl(this, Notification.SET, SDomainPackage.IMPORT__IMPORTED_NAMESPACE, oldImportedNamespace, importedNamespace));   }    /**    *     *     * @generated    */   @Override   public Object eGet(int featureID, boolean resolve, boolean coreType)   {     switch (featureID)     {       case SDomainPackage.IMPORT__IMPORTED_NAMESPACE:         return getImportedNamespace();     }     return super.eGet(featureID, resolve, coreType);   }    /**    *     *     * @generated    */   @Override   public void eSet(int featureID, Object newValue)   {     switch (featureID)     {       case SDomainPackage.IMPORT__IMPORTED_NAMESPACE:         setImportedNamespace((String)newValue);         return;     }     super.eSet(featureID, newValue);   }    /**    *     *     * @generated    */   @Override   public void eUnset(int featureID)   {     switch (featureID)     {       case SDomainPackage.IMPORT__IMPORTED_NAMESPACE:         setImportedNamespace(IMPORTED_NAMESPACE_EDEFAULT);         return;     }     super.eUnset(featureID);   }    /**    *     *     * @generated    */   @Override   public boolean eIsSet(int featureID)   {     switch (featureID)     {       case SDomainPackage.IMPORT__IMPORTED_NAMESPACE:         return IMPORTED_NAMESPACE_EDEFAULT == null ? importedNamespace != null : !IMPORTED_NAMESPACE_EDEFAULT.equals(importedNamespace);     }     return super.eIsSet(featureID);   }    /**    *     *     * @generated    */   @Override   public String toString()   {     if (eIsProxy()) return super.toString();      StringBuffer result = new StringBuffer(super.toString());     result.append(&quot; (importedNamespace: &quot;);     result.append(importedNamespace);     result.append(')');     return result.toString();   }  } //ImportImpl</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10018</td>
    <td align="left">https://github.com/eclipse/xtext-idea/blob/3aa1424ae35f1942dd7c3a457057006f9131de5e/org.eclipse.xtext.idea.sdomain/src-gen/org/eclipse/xtext/idea/sdomain/sDomain/impl/ImportImpl.java/#L34-L183</td>
    <td align="right">1</td>
    <td align="right">1130</td>
    <td align="right">10018</td>
  </tr>
  <tr valign="top">
    <td align="right">472</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class AccessRoleCreatorImpl extends AbstractKapuaEntityCreator implements AccessRoleCreator {      private static final long serialVersionUID = 972154225756734130L;      private KapuaId accessInfo;     private KapuaId roleId;      /**      * Constructor      *       * @param scopeId      */     public AccessRoleCreatorImpl(KapuaId scopeId) {         super(scopeId);     }      @Override     public KapuaId getAccessInfoId() {         return accessInfo;     }      @Override     public void setAccessInfoId(KapuaId accessInfo) {         this.accessInfo = accessInfo;     }      @Override     public KapuaId getRoleId() {         return roleId;     }      @Override     public void setRoleId(KapuaId roleId) {         this.roleId = roleId;     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4574</td>
    <td align="left">https://github.com/eclipse/kapua/blob/11e610c657f7e473b52882833e33a2261bd3d67d/service/security/shiro/src/main/java/org/eclipse/kapua/service/authorization/access/shiro/AccessRoleCreatorImpl.java/#L25-L61</td>
    <td align="right">1</td>
    <td align="right">472</td>
    <td align="right">4574</td>
  </tr>
  <tr valign="top">
    <td align="right">761</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class DQ_EvaluationMethodTypeCode         extends CodeListAdapter {     /**      * Empty constructor for JAXB only.      */     public DQ_EvaluationMethodTypeCode() {     }      /**      * Creates a new adapter for the given value.      */     private DQ_EvaluationMethodTypeCode(final CodeListUID value) {         super(value);     }      /**      * {@inheritDoc}      *      * @return the wrapper for the code list value.      */     @Override     protected DQ_EvaluationMethodTypeCode wrap(final CodeListUID value) {         return new DQ_EvaluationMethodTypeCode(value);     }      /**      * {@inheritDoc}      *      * @return the code list class.      */     @Override     protected Class getCodeListClass() {         return EvaluationMethodType.class;     }      /**      * Invoked by JAXB on marshalling.      *      * @return the value to be marshalled.      */     @Override     @XmlElement(name = &quot;DQ_EvaluationMethodTypeCode&quot;, namespace = Namespaces.MDQ)     public CodeListUID getElement() {         return identifier;     }      /**      * Invoked by JAXB on unmarshalling.      *      * @param  value  the unmarshalled value.      */     public void setElement(final CodeListUID value) {         identifier = value;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7110</td>
    <td align="left">https://github.com/apache/sis/blob/002121abc9b9826fbd51fac7150b3ee0c02cc88b/core/sis-metadata/src/main/java/org/apache/sis/internal/jaxb/code/DQ_EvaluationMethodTypeCode.java/#L36-L91</td>
    <td align="right">1</td>
    <td align="right">761</td>
    <td align="right">7110</td>
  </tr>
  <tr valign="top">
    <td align="right">2379</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             {                 &quot;the bad smells are&quot;: [                     &quot;Data Class&quot;                 ]             }         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SparkVersion {   private static final Logger logger = LoggerFactory.getLogger(SparkVersion.class);    public static final SparkVersion SPARK_1_6_0 = SparkVersion.fromVersionString(&quot;1.6.0&quot;);    public static final SparkVersion SPARK_2_0_0 = SparkVersion.fromVersionString(&quot;2.0.0&quot;);   public static final SparkVersion SPARK_2_3_0 = SparkVersion.fromVersionString(&quot;2.3.0&quot;);   public static final SparkVersion SPARK_2_3_1 = SparkVersion.fromVersionString(&quot;2.3.1&quot;);   public static final SparkVersion SPARK_2_4_0 = SparkVersion.fromVersionString(&quot;2.4.0&quot;);   public static final SparkVersion SPARK_3_0_0 = SparkVersion.fromVersionString(&quot;3.0.0&quot;);    public static final SparkVersion MIN_SUPPORTED_VERSION =  SPARK_1_6_0;   public static final SparkVersion UNSUPPORTED_FUTURE_VERSION = SPARK_3_0_0;    private int version;   private int majorVersion;   private int minorVersion;   private int patchVersion;   private String versionString;    SparkVersion(String versionString) {     this.versionString = versionString;      try {       int pos = versionString.indexOf('-');        String numberPart = versionString;       if (pos &gt; 0) {         numberPart = versionString.substring(0, pos);       }        String versions[] = numberPart.split(&quot;\\.&quot;);       this.majorVersion = Integer.parseInt(versions[0]);       this.minorVersion = Integer.parseInt(versions[1]);       this.patchVersion = Integer.parseInt(versions[2]);       // version is always 5 digits. (e.g. 2.0.0 -&gt; 20000, 1.6.2 -&gt; 10602)       version = Integer.parseInt(String.format(&quot;%d%02d%02d&quot;, majorVersion, minorVersion, patchVersion));     } catch (Exception e) {       logger.error(&quot;Can not recognize Spark version &quot; + versionString +           &quot;. Assume it's a future release&quot;, e);        // assume it is future release       version = 99999;     }   }    public int toNumber() {     return version;   }    public String toString() {     return versionString;   }    public boolean isUnsupportedVersion() {     return olderThan(MIN_SUPPORTED_VERSION) || newerThanEquals(UNSUPPORTED_FUTURE_VERSION);   }    public static SparkVersion fromVersionString(String versionString) {     return new SparkVersion(versionString);   }    public boolean isSpark2() {     return this.newerThanEquals(SPARK_2_0_0);   }    public boolean isSecretSocketSupported() {     return this.newerThanEquals(SparkVersion.SPARK_2_4_0) ||             this.newerThanEqualsPatchVersion(SPARK_2_3_1) ||             this.newerThanEqualsPatchVersion(SparkVersion.fromVersionString(&quot;2.2.2&quot;)) ||             this.newerThanEqualsPatchVersion(SparkVersion.fromVersionString(&quot;2.1.3&quot;));   }    public boolean equals(Object versionToCompare) {     return version == ((SparkVersion) versionToCompare).version;   }    public boolean newerThan(SparkVersion versionToCompare) {     return version &gt; versionToCompare.version;   }    public boolean newerThanEquals(SparkVersion versionToCompare) {     return version &gt;= versionToCompare.version;   }    public boolean newerThanEqualsPatchVersion(SparkVersion versionToCompare) {     return majorVersion == versionToCompare.majorVersion &amp;&amp;             minorVersion == versionToCompare.minorVersion &amp;&amp;             patchVersion &gt;= versionToCompare.patchVersion;   }    public boolean olderThan(SparkVersion versionToCompare) {     return version &lt; versionToCompare.version;   }    public boolean olderThanEquals(SparkVersion versionToCompare) {     return version &lt;= versionToCompare.version;   } }</td>
    <td align="left">data class</td>
    <td align="left">the bad smells are: data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14336</td>
    <td align="left">https://github.com/apache/zeppelin/blob/4219d552349f8f7f3e6de34505b8a8ae9835f98b/spark/interpreter/src/main/java/org/apache/zeppelin/spark/SparkVersion.java/#L25-L123</td>
    <td align="right">1</td>
    <td align="right">2379</td>
    <td align="right">14336</td>
  </tr>
  <tr valign="top">
    <td align="right">1072</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{       &quot;output&quot;: &quot;YES I found bad smells. The bad smells are: 1. Data Class&quot;   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class EnsemblExonVO extends EnsemblDBBaseVO {      @JsonProperty(value = &quot;version&quot;)     private Integer version;      @JsonProperty(value = &quot;assembly_name&quot;)     private String assemblyName;      @JsonProperty(value = &quot;seq_region_name&quot;)     private String seqRegionName;      @JsonProperty(value = &quot;strand&quot;)     private String strand;      public Integer getVersion() {         return version;     }      public void setVersion(Integer version) {         this.version = version;     }      public String getAssemblyName() {         return assemblyName;     }      public void setAssemblyName(String assemblyName) {         this.assemblyName = assemblyName;     }      public String getSeqRegionName() {         return seqRegionName;     }      public void setSeqRegionName(String seqRegionName) {         this.seqRegionName = seqRegionName;     }      public String getStrand() {         return strand;     }      public void setStrand(String strand) {         this.strand = strand;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class   </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9608</td>
    <td align="left">https://github.com/epam/NGB/blob/340504529fc576eeec92fbae636e437ce486cc4a/server/catgenome/src/main/java/com/epam/catgenome/controller/vo/externaldb/ensemblevo/EnsemblExonVO.java/#L40-L85</td>
    <td align="right">1</td>
    <td align="right">1072</td>
    <td align="right">9608</td>
  </tr>
  <tr valign="top">
    <td align="right">1017</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Long Method&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TfsGitBranchJson {      private final static String REFS_HEADS = &quot;refs/heads/&quot;; //$NON-NLS-1$      private final String objectId;     private final String fullName;      @JsonCreator     public TfsGitBranchJson(         @JsonProperty(&quot;objectId&quot;) final String objectId,         @JsonProperty(&quot;name&quot;) final String fullName) {         this.objectId = objectId;         this.fullName = fullName;     }      public String getObjectId() {         return objectId;     }      public String getName() {         if (fullName.startsWith(REFS_HEADS)) {             return fullName.substring(REFS_HEADS.length());         } else {             return fullName;         }     }      public String getFullName() {         return fullName;     } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9315</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.client.common/src/com/microsoft/tfs/client/common/git/json/TfsGitBranchJson.java/#L9-L39</td>
    <td align="right">1</td>
    <td align="right">1017</td>
    <td align="right">9315</td>
  </tr>
  <tr valign="top">
    <td align="right">1409</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Job20LineHistoryEventEmitter extends HistoryEventEmitter {    static List nonFinals =       new LinkedList();   static List finals = new LinkedList();    Long originalSubmitTime = null;    static {     nonFinals.add(new JobSubmittedEventEmitter());     nonFinals.add(new JobPriorityChangeEventEmitter());     nonFinals.add(new JobStatusChangedEventEmitter());     nonFinals.add(new JobInitedEventEmitter());     nonFinals.add(new JobInfoChangeEventEmitter());      finals.add(new JobUnsuccessfulCompletionEventEmitter());     finals.add(new JobFinishedEventEmitter());   }    Job20LineHistoryEventEmitter() {     super();   }    static private class JobSubmittedEventEmitter extends SingleEventEmitter {     HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName,         HistoryEventEmitter thatg) {       JobID jobID = JobID.forName(jobIDName);        if (jobIDName == null) {         return null;       }        String submitTime = line.get(&quot;SUBMIT_TIME&quot;);       String jobConf = line.get(&quot;JOBCONF&quot;);       String user = line.get(&quot;USER&quot;);       if (user == null) {         user = &quot;nulluser&quot;;       }       String jobName = line.get(&quot;JOBNAME&quot;);       String jobQueueName = line.get(&quot;JOB_QUEUE&quot;);// could be null       String workflowId = line.get(&quot;WORKFLOW_ID&quot;);       if (workflowId == null) {         workflowId = &quot;&quot;;       }       String workflowName = line.get(&quot;WORKFLOW_NAME&quot;);       if (workflowName == null) {         workflowName = &quot;&quot;;       }       String workflowNodeName = line.get(&quot;WORKFLOW_NODE_NAME&quot;);       if (workflowNodeName == null) {         workflowNodeName = &quot;&quot;;       }       String workflowAdjacencies = line.get(&quot;WORKFLOW_ADJACENCIES&quot;);       if (workflowAdjacencies == null) {         workflowAdjacencies = &quot;&quot;;       }       String workflowTags = line.get(&quot;WORKFLOW_TAGS&quot;);       if (workflowTags == null) {         workflowTags = &quot;&quot;;       }               if (submitTime != null) {         Job20LineHistoryEventEmitter that =             (Job20LineHistoryEventEmitter) thatg;          that.originalSubmitTime = Long.parseLong(submitTime);          Map jobACLs =           new HashMap();         return new JobSubmittedEvent(jobID, jobName, user,             that.originalSubmitTime, jobConf, jobACLs, jobQueueName,             workflowId, workflowName, workflowNodeName, workflowAdjacencies,             workflowTags);       }        return null;     }   }    static private class JobPriorityChangeEventEmitter extends SingleEventEmitter {     HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName,         HistoryEventEmitter thatg) {       JobID jobID = JobID.forName(jobIDName);        if (jobIDName == null) {         return null;       }        String priority = line.get(&quot;JOB_PRIORITY&quot;);        if (priority != null) {         return new JobPriorityChangeEvent(jobID, JobPriority.valueOf(priority));       }        return null;     }   }    static private class JobInitedEventEmitter extends SingleEventEmitter {     HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName,         HistoryEventEmitter thatg) {       if (jobIDName == null) {         return null;       }        JobID jobID = JobID.forName(jobIDName);        String launchTime = line.get(&quot;LAUNCH_TIME&quot;);       String status = line.get(&quot;JOB_STATUS&quot;);       String totalMaps = line.get(&quot;TOTAL_MAPS&quot;);       String totalReduces = line.get(&quot;TOTAL_REDUCES&quot;);       String uberized = line.get(&quot;UBERIZED&quot;);        if (launchTime != null &amp;&amp; totalMaps != null &amp;&amp; totalReduces != null) {         return new JobInitedEvent(jobID, Long.parseLong(launchTime), Integer             .parseInt(totalMaps), Integer.parseInt(totalReduces), status,             Boolean.parseBoolean(uberized));       }        return null;     }   }    static private class JobStatusChangedEventEmitter extends SingleEventEmitter {     HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName,         HistoryEventEmitter thatg) {       if (jobIDName == null) {         return null;       }        JobID jobID = JobID.forName(jobIDName);        String status = line.get(&quot;JOB_STATUS&quot;);        if (status != null) {         return new JobStatusChangedEvent(jobID, status);       }        return null;     }   }    static private class JobInfoChangeEventEmitter extends SingleEventEmitter {     HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName,         HistoryEventEmitter thatg) {       if (jobIDName == null) {         return null;       }        JobID jobID = JobID.forName(jobIDName);        String launchTime = line.get(&quot;LAUNCH_TIME&quot;);        if (launchTime != null) {         Job20LineHistoryEventEmitter that =             (Job20LineHistoryEventEmitter) thatg;         return new JobInfoChangeEvent(jobID, that.originalSubmitTime, Long             .parseLong(launchTime));       }        return null;     }   }    static private class JobUnsuccessfulCompletionEventEmitter extends       SingleEventEmitter {     HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName,         HistoryEventEmitter thatg) {       if (jobIDName == null) {         return null;       }        JobID jobID = JobID.forName(jobIDName);        String finishTime = line.get(&quot;FINISH_TIME&quot;);        String status = line.get(&quot;JOB_STATUS&quot;);        String finishedMaps = line.get(&quot;FINISHED_MAPS&quot;);       String finishedReduces = line.get(&quot;FINISHED_REDUCES&quot;);        if (status != null &amp;&amp; !status.equalsIgnoreCase(&quot;success&quot;)           &amp;&amp; finishTime != null &amp;&amp; finishedMaps != null           &amp;&amp; finishedReduces != null) {         return new JobUnsuccessfulCompletionEvent(jobID, Long             .parseLong(finishTime), Integer.parseInt(finishedMaps), Integer             .parseInt(finishedReduces), -1, -1, -1, -1, status);       }        return null;     }   }    static private class JobFinishedEventEmitter extends SingleEventEmitter {     HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName,         HistoryEventEmitter thatg) {       if (jobIDName == null) {         return null;       }        JobID jobID = JobID.forName(jobIDName);        String finishTime = line.get(&quot;FINISH_TIME&quot;);        String status = line.get(&quot;JOB_STATUS&quot;);        String finishedMaps = line.get(&quot;FINISHED_MAPS&quot;);       String finishedReduces = line.get(&quot;FINISHED_REDUCES&quot;);        String failedMaps = line.get(&quot;FAILED_MAPS&quot;);       String failedReduces = line.get(&quot;FAILED_REDUCES&quot;);        String counters = line.get(&quot;COUNTERS&quot;);        if (status != null &amp;&amp; status.equalsIgnoreCase(&quot;success&quot;)           &amp;&amp; finishTime != null &amp;&amp; finishedMaps != null           &amp;&amp; finishedReduces != null) {         return new JobFinishedEvent(jobID, Long.parseLong(finishTime), Integer             .parseInt(finishedMaps), Integer.parseInt(finishedReduces), Integer             .parseInt(failedMaps), Integer.parseInt(failedReduces), -1, -1,             null, null, maybeParseCounters(counters));       }        return null;     }   }    @Override   List finalSEEs() {     return finals;   }    @Override   List nonFinalSEEs() {     return nonFinals;   }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10897</td>
    <td align="left">https://github.com/apache/hadoop/blob/128dd91e10080bdcbcd7d555fa3c4105e55a6b51/hadoop-tools/hadoop-rumen/src/main/java/org/apache/hadoop/tools/rumen/Job20LineHistoryEventEmitter.java/#L39-L277</td>
    <td align="right">1</td>
    <td align="right">1409</td>
    <td align="right">10897</td>
  </tr>
  <tr valign="top">
    <td align="right">2058</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
class CFRouteImpl implements CFRoute {  	final private String domain; 	final private String host; 	final private String path; 	final private int port; 	final private String fullRoute;  	CFRouteImpl(String domain, String host, String path, int port, String fullRoute)  { 		super(); 		this.domain = domain; 		this.host = host; 		this.path = path; 		this.port = port; 		this.fullRoute = fullRoute; 	}  	public String getDomain() { 		return domain; 	}  	public String getHost() { 		return host; 	}  	public String getPath() { 		return path; 	}  	public int getPort() { 		return port; 	}  	public String getRoute() { 		return fullRoute; 	}  	@Override 	public String toString() { 		return &quot;CFRoute [domain=&quot; + domain + &quot;, host=&quot; + host + &quot;, path=&quot; + path + &quot;, port=&quot; + port  +&quot;]&quot;; 	}   	@Override 	public int hashCode() { 		final int prime = 31; 		int result = 1; 		result = prime * result + ((domain == null) ? 0 : domain.hashCode()); 		result = prime * result + ((fullRoute == null) ? 0 : fullRoute.hashCode()); 		result = prime * result + ((host == null) ? 0 : host.hashCode()); 		result = prime * result + ((path == null) ? 0 : path.hashCode()); 		result = prime * result + port; 		return result; 	}  	@Override 	public boolean equals(Object obj) { 		if (this == obj) 			return true; 		if (obj == null) 			return false; 		if (getClass() != obj.getClass()) 			return false; 		CFRouteImpl other = (CFRouteImpl) obj; 		if (domain == null) { 			if (other.domain != null) 				return false; 		} else if (!domain.equals(other.domain)) 			return false; 		if (fullRoute == null) { 			if (other.fullRoute != null) 				return false; 		} else if (!fullRoute.equals(other.fullRoute)) 			return false; 		if (host == null) { 			if (other.host != null) 				return false; 		} else if (!host.equals(other.host)) 			return false; 		if (path == null) { 			if (other.path != null) 				return false; 		} else if (!path.equals(other.path)) 			return false; 		if (port != other.port) 			return false; 		return true; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12960</td>
    <td align="left">https://github.com/spring-projects/sts4/blob/46e9e985b0c5e28ea1952d9fc640ec12fd9c8fdd/headless-services/commons/commons-cf/src/main/java/org/springframework/ide/vscode/commons/cloudfoundry/client/CFRouteImpl.java/#L3-L92</td>
    <td align="right">1</td>
    <td align="right">2058</td>
    <td align="right">12960</td>
  </tr>
  <tr valign="top">
    <td align="right">2655</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@APICommand(name = &quot;updateNetwork&quot;, description = &quot;Updates a network&quot;, responseObject = NetworkResponse.class, responseView = ResponseView.Restricted, entityType = {Network.class},         requestHasSensitiveInfo = false, responseHasSensitiveInfo = false) public class UpdateNetworkCmd extends BaseAsyncCustomIdCmd {     public static final Logger s_logger = Logger.getLogger(UpdateNetworkCmd.class.getName());      private static final String s_name = &quot;updatenetworkresponse&quot;;      /////////////////////////////////////////////////////     //////////////// API parameters /////////////////////     /////////////////////////////////////////////////////     @ACL(accessType = AccessType.OperateEntry)     @Parameter(name=ApiConstants.ID, type=CommandType.UUID, entityType = NetworkResponse.class,             required=true, description=&quot;the ID of the network&quot;)     protected Long id;      @Parameter(name = ApiConstants.NAME, type = CommandType.STRING, description = &quot;the new name for the network&quot;)     private String name;      @Parameter(name = ApiConstants.DISPLAY_TEXT, type = CommandType.STRING, description = &quot;the new display text for the network&quot;)     private String displayText;      @Parameter(name = ApiConstants.NETWORK_DOMAIN, type = CommandType.STRING, description = &quot;network domain&quot;)     private String networkDomain;      @Parameter(name = ApiConstants.CHANGE_CIDR, type = CommandType.BOOLEAN, description = &quot;Force update even if CIDR type is different&quot;)     private Boolean changeCidr;      @Parameter(name = ApiConstants.NETWORK_OFFERING_ID, type = CommandType.UUID, entityType = NetworkOfferingResponse.class, description = &quot;network offering ID&quot;)     private Long networkOfferingId;      @Parameter(name = ApiConstants.GUEST_VM_CIDR, type = CommandType.STRING, description = &quot;CIDR for guest VMs, CloudStack allocates IPs to guest VMs only from this CIDR&quot;)     private String guestVmCidr;      @Parameter(name =ApiConstants.Update_IN_SEQUENCE, type=CommandType.BOOLEAN, description = &quot;if true, we will update the routers one after the other. applicable only for redundant router based networks using virtual router as provider&quot;)     private Boolean updateInSequence;      @Parameter(name = ApiConstants.DISPLAY_NETWORK,                type = CommandType.BOOLEAN,  description = &quot;an optional field, whether to the display the network to the end user or not.&quot;, authorized = {RoleType.Admin})     private Boolean displayNetwork;      @Parameter(name= ApiConstants.FORCED, type = CommandType.BOOLEAN, description = &quot;Setting this to true will cause a forced network update,&quot;, authorized = {RoleType.Admin})     private Boolean forced;      /////////////////////////////////////////////////////     /////////////////// Accessors ///////////////////////     /////////////////////////////////////////////////////      public Long getId() {         return id;     }      public String getNetworkName() {         return name;     }      public String getDisplayText() {         return displayText;     }      public String getNetworkDomain() {         return networkDomain;     }      public Long getNetworkOfferingId() {         return networkOfferingId;     }      public Boolean getChangeCidr() {         if (changeCidr != null) {             return changeCidr;         }         return false;     }      public String getGuestVmCidr() {         return guestVmCidr;     }      public Boolean getDisplayNetwork() {         return displayNetwork;     }      public Boolean getUpdateInSequence(){         if(updateInSequence ==null)             return false;         else             return updateInSequence;     }      public boolean getForced(){         if(forced==null){             return false;         }         return forced;     }     /////////////////////////////////////////////////////     /////////////// API Implementation///////////////////     /////////////////////////////////////////////////////      @Override     public String getCommandName() {         return s_name;     }      @Override     public long getEntityOwnerId() {         Network network = _networkService.getNetwork(id);         if (network == null) {             throw new InvalidParameterValueException(&quot;Networkd ID=&quot; + id + &quot; doesn't exist&quot;);         } else {             return _networkService.getNetwork(id).getAccountId();         }     }      @Override     public void execute() throws InsufficientCapacityException, ConcurrentOperationException {         User callerUser = _accountService.getActiveUser(CallContext.current().getCallingUserId());         Account callerAccount = _accountService.getActiveAccountById(callerUser.getAccountId());         Network network = _networkService.getNetwork(id);         if (network == null) {             throw new InvalidParameterValueException(&quot;Couldn't find network by ID&quot;);         }          Network result =             _networkService.updateGuestNetwork(getId(), getNetworkName(), getDisplayText(), callerAccount, callerUser, getNetworkDomain(), getNetworkOfferingId(),                 getChangeCidr(), getGuestVmCidr(), getDisplayNetwork(), getCustomId(), getUpdateInSequence(), getForced());          if (result != null) {             NetworkResponse response = _responseGenerator.createNetworkResponse(ResponseView.Restricted, result);             response.setResponseName(getCommandName());             setResponseObject(response);         } else {             throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, &quot;Failed to update network&quot;);         }     }      @Override     public String getEventDescription() {         StringBuilder eventMsg = new StringBuilder(&quot;Updating network: &quot; + getId());         if (getNetworkOfferingId() != null) {             Network network = _networkService.getNetwork(getId());             if (network == null) {                 throw new InvalidParameterValueException(&quot;Networkd ID=&quot; + id + &quot; doesn't exist&quot;);             }             if (network.getNetworkOfferingId() != getNetworkOfferingId()) {                 NetworkOffering oldOff = _entityMgr.findById(NetworkOffering.class, network.getNetworkOfferingId());                 NetworkOffering newOff = _entityMgr.findById(NetworkOffering.class, getNetworkOfferingId());                 if (newOff == null) {                     throw new InvalidParameterValueException(&quot;Networkd offering ID supplied is invalid&quot;);                 }                  eventMsg.append(&quot;. Original network offering ID: &quot; + oldOff.getUuid() + &quot;, new network offering ID: &quot; + newOff.getUuid());             }         }          return eventMsg.toString();     }      @Override     public String getEventType() {         return EventTypes.EVENT_NETWORK_UPDATE;     }      @Override     public String getSyncObjType() {         return BaseAsyncCmd.networkSyncObject;     }      @Override     public Long getSyncObjId() {         return id;     }      @Override     public void checkUuid() {         if (getCustomId() != null) {             _uuidMgr.checkUuid(getCustomId(), Network.class);         }     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15181</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/api/src/main/java/org/apache/cloudstack/api/command/user/network/UpdateNetworkCmd.java/#L45-L225</td>
    <td align="right">1</td>
    <td align="right">2655</td>
    <td align="right">15181</td>
  </tr>
  <tr valign="top">
    <td align="right">2886</td>
    <td align="left">{&quot;response&quot;:&quot;YES I found bad smells&quot;,&quot;the bad smells are&quot;:[&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class ExternalLoadBalancerDeviceManagerImpl extends AdapterBase implements ExternalLoadBalancerDeviceManager, ResourceStateAdapter {      @Inject     NetworkExternalLoadBalancerDao _networkExternalLBDao;     @Inject     ExternalLoadBalancerDeviceDao _externalLoadBalancerDeviceDao;     @Inject     HostDao _hostDao;     @Inject     DataCenterDao _dcDao;     @Inject     NetworkModel _networkModel;     @Inject     NetworkOrchestrationService _networkMgr;     @Inject     InlineLoadBalancerNicMapDao _inlineLoadBalancerNicMapDao;     @Inject     NicDao _nicDao;     @Inject     AgentManager _agentMgr;     @Inject     ResourceManager _resourceMgr;     @Inject     IPAddressDao _ipAddressDao;     @Inject     VlanDao _vlanDao;     @Inject     NetworkOfferingDao _networkOfferingDao;     @Inject     AccountDao _accountDao;     @Inject     PhysicalNetworkDao _physicalNetworkDao;     @Inject     PhysicalNetworkServiceProviderDao _physicalNetworkServiceProviderDao;     @Inject     AccountManager _accountMgr;     @Inject     UserStatisticsDao _userStatsDao;     @Inject     NetworkDao _networkDao;     @Inject     DomainRouterDao _routerDao;     @Inject     LoadBalancerDao _loadBalancerDao;     @Inject     PortForwardingRulesDao _portForwardingRulesDao;     @Inject     ConfigurationDao _configDao;     @Inject     HostDetailsDao _hostDetailDao;     @Inject     NetworkExternalLoadBalancerDao _networkLBDao;     @Inject     NetworkServiceMapDao _ntwkSrvcProviderDao;     @Inject     NetworkExternalFirewallDao _networkExternalFirewallDao;     @Inject     ExternalFirewallDeviceDao _externalFirewallDeviceDao;     @Inject     protected HostPodDao _podDao = null;     @Inject     IpAddressManager _ipAddrMgr;     @Inject     protected     VirtualMachineManager _itMgr;     @Inject     VMInstanceDao _vmDao;     @Inject     VMTemplateDao _templateDao;     @Inject     ServiceOfferingDao _serviceOfferingDao;     @Inject     PhysicalNetworkServiceProviderDao _physicalProviderDao;     @Inject     VirtualRouterProviderDao _vrProviderDao;      private long _defaultLbCapacity;     private static final org.apache.log4j.Logger s_logger = Logger.getLogger(ExternalLoadBalancerDeviceManagerImpl.class);      @Override     @DB     public ExternalLoadBalancerDeviceVO addExternalLoadBalancer(long physicalNetworkId, String url, String username, String password, final String deviceName,         ServerResource resource, final boolean gslbProvider, final boolean exclusiveGslbProivider,         final String gslbSitePublicIp, final String gslbSitePrivateIp) {          PhysicalNetworkVO pNetwork = null;         final NetworkDevice ntwkDevice = NetworkDevice.getNetworkDevice(deviceName);         long zoneId;          if ((ntwkDevice == null) || (url == null) || (username == null) || (resource == null) || (password == null)) {             throw new InvalidParameterValueException(&quot;Atleast one of the required parameters (url, username, password,&quot;                 + &quot; server resource, zone id/physical network id) is not specified or a valid parameter.&quot;);         }          pNetwork = _physicalNetworkDao.findById(physicalNetworkId);         if (pNetwork == null) {             throw new InvalidParameterValueException(&quot;Could not find phyical network with ID: &quot; + physicalNetworkId);         }          zoneId = pNetwork.getDataCenterId();         PhysicalNetworkServiceProviderVO ntwkSvcProvider =             _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), ntwkDevice.getNetworkServiceProvder());          ntwkSvcProvider = _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), ntwkDevice.getNetworkServiceProvder());         if (ntwkSvcProvider == null) {             throw new CloudRuntimeException(&quot;Network Service Provider: &quot; + ntwkDevice.getNetworkServiceProvder() + &quot; is not enabled in the physical network: &quot; +                 physicalNetworkId + &quot;to add this device&quot;);         } else if (ntwkSvcProvider.getState() == PhysicalNetworkServiceProvider.State.Shutdown) {             throw new CloudRuntimeException(&quot;Network Service Provider: &quot; + ntwkSvcProvider.getProviderName() + &quot; is in shutdown state in the physical network: &quot; +                 physicalNetworkId + &quot;to add this device&quot;);         }          if (gslbProvider) {             ExternalLoadBalancerDeviceVO zoneGslbProvider =                 _externalLoadBalancerDeviceDao.findGslbServiceProvider(physicalNetworkId, ntwkDevice.getNetworkServiceProvder());             if (zoneGslbProvider != null) {                 throw new CloudRuntimeException(&quot;There is a GSLB service provider configured in the zone alredy.&quot;);             }         }          URI uri;         try {             uri = new URI(url);         } catch (Exception e) {             s_logger.debug(e);             throw new InvalidParameterValueException(e.getMessage());         }          String ipAddress = uri.getHost();         Map hostDetails = new HashMap();         String hostName = getExternalLoadBalancerResourceGuid(pNetwork.getId(), deviceName, ipAddress);         hostDetails.put(&quot;name&quot;, hostName);         hostDetails.put(&quot;guid&quot;, UUID.randomUUID().toString());         hostDetails.put(&quot;zoneId&quot;, String.valueOf(pNetwork.getDataCenterId()));         hostDetails.put(&quot;ip&quot;, ipAddress);         hostDetails.put(&quot;physicalNetworkId&quot;, String.valueOf(pNetwork.getId()));         hostDetails.put(&quot;username&quot;, username);         hostDetails.put(&quot;password&quot;, password);         hostDetails.put(&quot;deviceName&quot;, deviceName);          // leave parameter validation to be part server resource configure         Map configParams = new HashMap();         UrlUtil.parseQueryParameters(uri.getQuery(), false, configParams);         hostDetails.putAll(configParams);          try {             resource.configure(hostName, hostDetails);              final Host host = _resourceMgr.addHost(zoneId, resource, Host.Type.ExternalLoadBalancer, hostDetails);             if (host != null) {                  final boolean dedicatedUse =                     (configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_DEDICATED) != null) ? Boolean.parseBoolean(configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_DEDICATED))                         : false;                 long capacity = NumbersUtil.parseLong(configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_CAPACITY), 0);                 if (capacity == 0) {                     capacity = _defaultLbCapacity;                 }                  final long capacityFinal = capacity;                 final PhysicalNetworkVO pNetworkFinal = pNetwork;                 return Transaction.execute(new TransactionCallback() {                     @Override                     public ExternalLoadBalancerDeviceVO doInTransaction(TransactionStatus status) {                         ExternalLoadBalancerDeviceVO lbDeviceVO =                             new ExternalLoadBalancerDeviceVO(host.getId(), pNetworkFinal.getId(), ntwkDevice.getNetworkServiceProvder(), deviceName, capacityFinal,                                 dedicatedUse, gslbProvider);                         if (gslbProvider) {                             lbDeviceVO.setGslbSitePublicIP(gslbSitePublicIp);                             lbDeviceVO.setGslbSitePrivateIP(gslbSitePrivateIp);                             lbDeviceVO.setExclusiveGslbProvider(exclusiveGslbProivider);                         }                         _externalLoadBalancerDeviceDao.persist(lbDeviceVO);                         DetailVO hostDetail = new DetailVO(host.getId(), ApiConstants.LOAD_BALANCER_DEVICE_ID, String.valueOf(lbDeviceVO.getId()));                         _hostDetailDao.persist(hostDetail);                          return lbDeviceVO;                     }                 });             } else {                 throw new CloudRuntimeException(&quot;Failed to add load balancer device due to internal error.&quot;);             }         } catch (ConfigurationException e) {             throw new CloudRuntimeException(e.getMessage());         }     }      @Override     public boolean deleteExternalLoadBalancer(long hostId) {         HostVO externalLoadBalancer = _hostDao.findById(hostId);         if (externalLoadBalancer == null) {             throw new InvalidParameterValueException(&quot;Could not find an external load balancer with ID: &quot; + hostId);         }          DetailVO lbHostDetails = _hostDetailDao.findDetail(hostId, ApiConstants.LOAD_BALANCER_DEVICE_ID);         long lbDeviceId = Long.parseLong(lbHostDetails.getValue());          ExternalLoadBalancerDeviceVO lbDeviceVo = _externalLoadBalancerDeviceDao.findById(lbDeviceId);         if (lbDeviceVo.getAllocationState() == LBDeviceAllocationState.Provider) {             // check if cloudstack has provisioned any load balancer appliance on the device before deleting             List lbDevices = _externalLoadBalancerDeviceDao.listAll();             if (lbDevices != null) {                 for (ExternalLoadBalancerDeviceVO lbDevice : lbDevices) {                     if (lbDevice.getParentHostId() == hostId) {                         throw new CloudRuntimeException(                             &quot;This load balancer device can not be deleted as there are one or more load balancers applainces provisioned by cloudstack on the device.&quot;);                     }                 }             }         } else {             // check if any networks are using this load balancer device             List networks = _networkLBDao.listByLoadBalancerDeviceId(lbDeviceId);             if ((networks != null) &amp;&amp; !networks.isEmpty()) {                 throw new CloudRuntimeException(&quot;Delete can not be done as there are networks using this load balancer device &quot;);             }         }          try {             // put the host in maintenance state in order for it to be deleted             externalLoadBalancer.setResourceState(ResourceState.Maintenance);             _hostDao.update(hostId, externalLoadBalancer);             _resourceMgr.deleteHost(hostId, false, false);              // delete the external load balancer entry             _externalLoadBalancerDeviceDao.remove(lbDeviceId);              return true;         } catch (Exception e) {             s_logger.debug(e);             return false;         }     }      @Override     public List listExternalLoadBalancers(long physicalNetworkId, String deviceName) {         List lbHosts = new ArrayList();         NetworkDevice lbNetworkDevice = NetworkDevice.getNetworkDevice(deviceName);         PhysicalNetworkVO pNetwork = null;          pNetwork = _physicalNetworkDao.findById(physicalNetworkId);          if ((pNetwork == null) || (lbNetworkDevice == null)) {             throw new InvalidParameterValueException(&quot;Atleast one of the required parameter physical networkId, device name is invalid.&quot;);         }          PhysicalNetworkServiceProviderVO ntwkSvcProvider =             _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), lbNetworkDevice.getNetworkServiceProvder());         // if provider not configured in to physical network, then there can be no instances         if (ntwkSvcProvider == null) {             return null;         }          List lbDevices =             _externalLoadBalancerDeviceDao.listByPhysicalNetworkAndProvider(physicalNetworkId, ntwkSvcProvider.getProviderName());         for (ExternalLoadBalancerDeviceVO provderInstance : lbDevices) {             lbHosts.add(_hostDao.findById(provderInstance.getHostId()));         }         return lbHosts;     }      public ExternalLoadBalancerResponse createExternalLoadBalancerResponse(Host externalLoadBalancer) {         Map lbDetails = _hostDetailDao.findDetails(externalLoadBalancer.getId());         ExternalLoadBalancerResponse response = new ExternalLoadBalancerResponse();         response.setId(externalLoadBalancer.getUuid());         response.setIpAddress(externalLoadBalancer.getPrivateIpAddress());         response.setUsername(lbDetails.get(&quot;username&quot;));         response.setPublicInterface(lbDetails.get(&quot;publicInterface&quot;));         response.setPrivateInterface(lbDetails.get(&quot;privateInterface&quot;));         response.setNumRetries(lbDetails.get(&quot;numRetries&quot;));         return response;     }      public String getExternalLoadBalancerResourceGuid(long physicalNetworkId, String deviceName, String ip) {         return physicalNetworkId + &quot;-&quot; + deviceName + &quot;-&quot; + ip;     }      @Override     public ExternalLoadBalancerDeviceVO getExternalLoadBalancerForNetwork(Network network) {         NetworkExternalLoadBalancerVO lbDeviceForNetwork = _networkExternalLBDao.findByNetworkId(network.getId());         if (lbDeviceForNetwork != null) {             long lbDeviceId = lbDeviceForNetwork.getExternalLBDeviceId();             ExternalLoadBalancerDeviceVO lbDeviceVo = _externalLoadBalancerDeviceDao.findById(lbDeviceId);             assert (lbDeviceVo != null);             return lbDeviceVo;         }         return null;     }      public void setExternalLoadBalancerForNetwork(Network network, long externalLBDeviceID) {         NetworkExternalLoadBalancerVO lbDeviceForNetwork = new NetworkExternalLoadBalancerVO(network.getId(), externalLBDeviceID);         _networkExternalLBDao.persist(lbDeviceForNetwork);     }      @DB     protected ExternalLoadBalancerDeviceVO allocateLoadBalancerForNetwork(final Network guestConfig) throws InsufficientCapacityException {         boolean retry = true;         boolean tryLbProvisioning = false;         ExternalLoadBalancerDeviceVO lbDevice = null;         long physicalNetworkId = guestConfig.getPhysicalNetworkId();         NetworkOfferingVO offering = _networkOfferingDao.findById(guestConfig.getNetworkOfferingId());         String provider = _ntwkSrvcProviderDao.getProviderForServiceInNetwork(guestConfig.getId(), Service.Lb);          while (retry) {             GlobalLock deviceMapLock = GlobalLock.getInternLock(&quot;LoadBalancerAllocLock&quot;);             try {                 if (deviceMapLock.lock(120)) {                     try {                         final boolean dedicatedLB = offering.isDedicatedLB(); // does network offering supports a dedicated load balancer?                          try {                             lbDevice = Transaction.execute(new TransactionCallbackWithException() {                                 @Override                                 public ExternalLoadBalancerDeviceVO doInTransaction(TransactionStatus status) throws InsufficientCapacityException {                                     // FIXME: should the device allocation be done during network implement phase or do a                                     // lazy allocation when first rule for the network is configured??                                      // find a load balancer device for this network as per the network offering                                     ExternalLoadBalancerDeviceVO lbDevice = findSuitableLoadBalancerForNetwork(guestConfig, dedicatedLB);                                     long lbDeviceId = lbDevice.getId();                                      // persist the load balancer device id that will be used for this network. Once a network                                     // is implemented on a LB device then later on all rules will be programmed on to same device                                     NetworkExternalLoadBalancerVO networkLB = new NetworkExternalLoadBalancerVO(guestConfig.getId(), lbDeviceId);                                     _networkExternalLBDao.persist(networkLB);                                      // mark device to be either dedicated or shared use                                     lbDevice.setAllocationState(dedicatedLB ? LBDeviceAllocationState.Dedicated : LBDeviceAllocationState.Shared);                                     _externalLoadBalancerDeviceDao.update(lbDeviceId, lbDevice);                                     return lbDevice;                                 }                             });                              // allocated load balancer for the network, so skip retry                             tryLbProvisioning = false;                             retry = false;                         } catch (InsufficientCapacityException exception) {                             // if already attempted to provision load balancer then throw out of capacity exception,                             if (tryLbProvisioning) {                                 retry = false;                                 // TODO: throwing warning instead of error for now as its possible another provider can service this network                                 s_logger.warn(&quot;There are no load balancer device with the capacity for implementing this network&quot;);                                 throw exception;                             } else {                                 tryLbProvisioning = true; // if possible provision a LB appliance in to the physical network                             }                         }                     } finally {                         deviceMapLock.unlock();                     }                 }             } finally {                 deviceMapLock.releaseRef();             }              // there are no LB devices or there is no free capacity on the devices in the physical network so provision a new LB appliance             if (tryLbProvisioning) {                 // check if LB appliance can be dynamically provisioned                 List providerLbDevices =                     _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Provider);                 if ((providerLbDevices != null) &amp;&amp; (!providerLbDevices.isEmpty())) {                     for (ExternalLoadBalancerDeviceVO lbProviderDevice : providerLbDevices) {                         if (lbProviderDevice.getState() == LBDeviceState.Enabled) {                             // acquire a private IP from the data center which will be used as management IP of provisioned LB appliance,                             DataCenterIpAddressVO dcPrivateIp = _dcDao.allocatePrivateIpAddress(guestConfig.getDataCenterId(), lbProviderDevice.getUuid());                             if (dcPrivateIp == null) {                                 throw new InsufficientNetworkCapacityException(&quot;failed to acquire a priavate IP in the zone &quot; + guestConfig.getDataCenterId() +                                     &quot; needed for management IP of the load balancer appliance&quot;, DataCenter.class, guestConfig.getDataCenterId());                             }                             Pod pod = _podDao.findById(dcPrivateIp.getPodId());                             String lbIP = dcPrivateIp.getIpAddress();                             String netmask = NetUtils.getCidrNetmask(pod.getCidrSize());                             String gateway = pod.getGateway();                              // send CreateLoadBalancerApplianceCommand to the host capable of provisioning                             CreateLoadBalancerApplianceCommand lbProvisionCmd = new CreateLoadBalancerApplianceCommand(lbIP, netmask, gateway);                             CreateLoadBalancerApplianceAnswer createLbAnswer = null;                             try {                                 createLbAnswer = (CreateLoadBalancerApplianceAnswer)_agentMgr.easySend(lbProviderDevice.getHostId(), lbProvisionCmd);                                 if (createLbAnswer == null || !createLbAnswer.getResult()) {                                     s_logger.error(&quot;Could not provision load balancer instance on the load balancer device &quot; + lbProviderDevice.getId());                                     continue;                                 }                             } catch (Exception agentException) {                                 s_logger.error(&quot;Could not provision load balancer instance on the load balancer device &quot; + lbProviderDevice.getId() + &quot; due to &quot; +                                     agentException.getMessage());                                 continue;                             }                              String username = createLbAnswer.getUsername();                             String password = createLbAnswer.getPassword();                             String publicIf = createLbAnswer.getPublicInterface();                             String privateIf = createLbAnswer.getPrivateInterface();                              // we have provisioned load balancer so add the appliance as cloudstack provisioned external load balancer                             String dedicatedLb = offering.isDedicatedLB() ? &quot;true&quot; : &quot;false&quot;;                             String capacity = Long.toString(lbProviderDevice.getCapacity());                              // acquire a public IP to associate with lb appliance (used as subnet IP to make the appliance part of private network)                             PublicIp publicIp =                                 _ipAddrMgr.assignPublicIpAddress(guestConfig.getDataCenterId(), null, _accountMgr.getSystemAccount(), VlanType.VirtualNetwork, null,                                     null, false, false);                             String publicIPNetmask = publicIp.getVlanNetmask();                             String publicIPgateway = publicIp.getVlanGateway();                             String publicIP = publicIp.getAddress().toString();                             String publicIPVlanTag=&quot;&quot;;                             try {                                 publicIPVlanTag = BroadcastDomainType.getValue(publicIp.getVlanTag());                             } catch (URISyntaxException e) {                                 s_logger.error(&quot;Failed to parse public ip vlan tag&quot; + e.getMessage());                             }                              String url =                                 &quot;https://&quot; + lbIP + &quot;?publicinterface=&quot; + publicIf + &quot;&amp;privateinterface=&quot; + privateIf + &quot;&amp;lbdevicededicated=&quot; + dedicatedLb +                                     &quot;&amp;cloudmanaged=true&quot; + &quot;&amp;publicip=&quot; + publicIP + &quot;&amp;publicipnetmask=&quot; + publicIPNetmask + &quot;&amp;lbdevicecapacity=&quot; + capacity +                                     &quot;&amp;publicipvlan=&quot; + publicIPVlanTag + &quot;&amp;publicipgateway=&quot; + publicIPgateway;                             ExternalLoadBalancerDeviceVO lbAppliance = null;                             try {                                 lbAppliance =                                     addExternalLoadBalancer(physicalNetworkId, url, username, password, createLbAnswer.getDeviceName(),                                         createLbAnswer.getServerResource(), false, false, null, null);                             } catch (Exception e) {                                 s_logger.error(&quot;Failed to add load balancer appliance in to cloudstack due to &quot; + e.getMessage() +                                     &quot;. So provisioned load balancer appliance will be destroyed.&quot;);                             }                              if (lbAppliance != null) {                                 // mark the load balancer as cloudstack managed and set parent host id on which lb appliance is provisioned                                 ExternalLoadBalancerDeviceVO managedLb = _externalLoadBalancerDeviceDao.findById(lbAppliance.getId());                                 managedLb.setIsManagedDevice(true);                                 managedLb.setParentHostId(lbProviderDevice.getHostId());                                 _externalLoadBalancerDeviceDao.update(lbAppliance.getId(), managedLb);                             } else {                                 // failed to add the provisioned load balancer into cloudstack so destroy the appliance                                 DestroyLoadBalancerApplianceCommand lbDeleteCmd = new DestroyLoadBalancerApplianceCommand(lbIP);                                 DestroyLoadBalancerApplianceAnswer answer = null;                                 try {                                     answer = (DestroyLoadBalancerApplianceAnswer)_agentMgr.easySend(lbProviderDevice.getHostId(), lbDeleteCmd);                                     if (answer == null || !answer.getResult()) {                                         s_logger.warn(&quot;Failed to destroy load balancer appliance created&quot;);                                     } else {                                         // release the public &amp; private IP back to dc pool, as the load balancer appliance is now destroyed                                         _dcDao.releasePrivateIpAddress(lbIP, guestConfig.getDataCenterId(), null);                                         _ipAddrMgr.disassociatePublicIpAddress(publicIp.getId(), _accountMgr.getSystemUser().getId(), _accountMgr.getSystemAccount());                                     }                                 } catch (Exception e) {                                     s_logger.warn(&quot;Failed to destroy load balancer appliance created for the network&quot; + guestConfig.getId() + &quot; due to &quot; + e.getMessage());                                 }                             }                         }                     }                 }             }         }          return lbDevice;     }      @Override     public ExternalLoadBalancerDeviceVO findSuitableLoadBalancerForNetwork(Network network, boolean dedicatedLb) throws InsufficientCapacityException {         long physicalNetworkId = network.getPhysicalNetworkId();         List lbDevices = null;         String provider = _ntwkSrvcProviderDao.getProviderForServiceInNetwork(network.getId(), Service.Lb);         assert (provider != null);          if (dedicatedLb) {             lbDevices = _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Free);             if (lbDevices != null &amp;&amp; !lbDevices.isEmpty()) {                 // return first device that is free, fully configured and meant for dedicated use                 for (ExternalLoadBalancerDeviceVO lbdevice : lbDevices) {                     if (lbdevice.getState() == LBDeviceState.Enabled &amp;&amp; lbdevice.getIsDedicatedDevice()) {                         return lbdevice;                     }                 }             }         } else {             // get the LB devices that are already allocated for shared use             lbDevices = _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Shared);              if (lbDevices != null) {                  ExternalLoadBalancerDeviceVO maxFreeCapacityLbdevice = null;                 long maxFreeCapacity = 0;                  // loop through the LB device in the physical network and pick the one with maximum free capacity                 for (ExternalLoadBalancerDeviceVO lbdevice : lbDevices) {                      // skip if device is not enabled                     if (lbdevice.getState() != LBDeviceState.Enabled) {                         continue;                     }                      // get the used capacity from the list of guest networks that are mapped to this load balancer                     List mappedNetworks = _networkExternalLBDao.listByLoadBalancerDeviceId(lbdevice.getId());                     long usedCapacity = ((mappedNetworks == null) || (mappedNetworks.isEmpty())) ? 0 : mappedNetworks.size();                      // get the configured capacity for this device                     long fullCapacity = lbdevice.getCapacity();                     if (fullCapacity == 0) {                         fullCapacity = _defaultLbCapacity; // if capacity not configured then use the default                     }                      long freeCapacity = fullCapacity - usedCapacity;                     if (freeCapacity &gt; 0) {                         if (maxFreeCapacityLbdevice == null) {                             maxFreeCapacityLbdevice = lbdevice;                             maxFreeCapacity = freeCapacity;                         } else if (freeCapacity &gt; maxFreeCapacity) {                             maxFreeCapacityLbdevice = lbdevice;                             maxFreeCapacity = freeCapacity;                         }                     }                 }                  // return the device with maximum free capacity and is meant for shared use                 if (maxFreeCapacityLbdevice != null) {                     return maxFreeCapacityLbdevice;                 }             }              // if we are here then there are no existing LB devices in shared use or the devices in shared use has no // free capacity left             // so allocate a new load balancer configured for shared use from the pool of free LB devices             lbDevices = _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Free);             if (lbDevices != null &amp;&amp; !lbDevices.isEmpty()) {                 for (ExternalLoadBalancerDeviceVO lbdevice : lbDevices) {                     if (lbdevice.getState() == LBDeviceState.Enabled &amp;&amp; !lbdevice.getIsDedicatedDevice()) {                         return lbdevice;                     }                 }             }         }          // there are no devices which capacity         throw new InsufficientNetworkCapacityException(&quot;Unable to find a load balancing provider with sufficient capcity &quot; + &quot; to implement the network&quot;, Network.class,             network.getId());     }      @DB     protected boolean freeLoadBalancerForNetwork(final Network guestConfig) {         GlobalLock deviceMapLock = GlobalLock.getInternLock(&quot;LoadBalancerAllocLock&quot;);          try {             if (deviceMapLock.lock(120)) {                 ExternalLoadBalancerDeviceVO lbDevice = Transaction.execute(new TransactionCallback() {                     @Override                     public ExternalLoadBalancerDeviceVO doInTransaction(TransactionStatus status) {                         // since network is shutdown remove the network mapping to the load balancer device                         NetworkExternalLoadBalancerVO networkLBDevice = _networkExternalLBDao.findByNetworkId(guestConfig.getId());                         long lbDeviceId = networkLBDevice.getExternalLBDeviceId();                         _networkExternalLBDao.remove(networkLBDevice.getId());                          List ntwksMapped = _networkExternalLBDao.listByLoadBalancerDeviceId(networkLBDevice.getExternalLBDeviceId());                         ExternalLoadBalancerDeviceVO lbDevice = _externalLoadBalancerDeviceDao.findById(lbDeviceId);                         boolean lbInUse = !(ntwksMapped == null || ntwksMapped.isEmpty());                         boolean lbCloudManaged = lbDevice.getIsManagedDevice();                          if (!lbInUse &amp;&amp; !lbCloudManaged) {                             // this is the last network mapped to the load balancer device so set device allocation state to be free                             lbDevice.setAllocationState(LBDeviceAllocationState.Free);                             _externalLoadBalancerDeviceDao.update(lbDevice.getId(), lbDevice);                         }                          // commit the changes before sending agent command to destroy cloudstack managed LB                         if (!lbInUse &amp;&amp; lbCloudManaged) {                             return lbDevice;                         } else {                             return null;                         }                     }                 });                  if (lbDevice != null) {                     // send DestroyLoadBalancerApplianceCommand to the host where load balancer appliance is provisioned                     Host lbHost = _hostDao.findById(lbDevice.getHostId());                     String lbIP = lbHost.getPrivateIpAddress();                     DestroyLoadBalancerApplianceCommand lbDeleteCmd = new DestroyLoadBalancerApplianceCommand(lbIP);                     DestroyLoadBalancerApplianceAnswer answer = null;                     try {                         answer = (DestroyLoadBalancerApplianceAnswer)_agentMgr.easySend(lbDevice.getParentHostId(), lbDeleteCmd);                         if (answer == null || !answer.getResult()) {                             s_logger.warn(&quot;Failed to destoy load balancer appliance used by the network&quot;                                     + guestConfig.getId() + &quot; due to &quot; + answer == null ? &quot;communication error with agent&quot;                                     : answer.getDetails());                         }                     } catch (Exception e) {                         s_logger.warn(&quot;Failed to destroy load balancer appliance used by the network&quot; + guestConfig.getId() + &quot; due to &quot; + e.getMessage());                     }                      if (s_logger.isDebugEnabled()) {                         s_logger.debug(&quot;Successfully destroyed load balancer appliance used for the network&quot; + guestConfig.getId());                     }                     deviceMapLock.unlock();                      // remove the provisioned load balancer appliance from cloudstack                     deleteExternalLoadBalancer(lbHost.getId());                      // release the private IP back to dc pool, as the load balancer appliance is now destroyed                     _dcDao.releasePrivateIpAddress(lbHost.getPrivateIpAddress(), guestConfig.getDataCenterId(), null);                      // release the public IP allocated for this LB appliance                     DetailVO publicIpDetail = _hostDetailDao.findDetail(lbHost.getId(), &quot;publicip&quot;);                     IPAddressVO ipVo = _ipAddressDao.findByIpAndDcId(guestConfig.getDataCenterId(), publicIpDetail.toString());                     _ipAddrMgr.disassociatePublicIpAddress(ipVo.getId(), _accountMgr.getSystemUser().getId(), _accountMgr.getSystemAccount());                 } else {                     deviceMapLock.unlock();                 }                  return true;             } else {                 s_logger.error(&quot;Failed to release load balancer device for the network&quot; + guestConfig.getId() + &quot;as failed to acquire lock &quot;);                 return false;             }         } catch (Exception exception) {             s_logger.error(&quot;Failed to release load balancer device for the network&quot; + guestConfig.getId() + &quot; due to &quot; + exception.getMessage());         } finally {             deviceMapLock.releaseRef();         }          return false;     }      private void applyStaticNatRuleForInlineLBRule(DataCenterVO zone, Network network, boolean revoked, String publicIp, String privateIp)         throws ResourceUnavailableException {         List staticNats = new ArrayList();         IPAddressVO ipVO = _ipAddressDao.listByDcIdIpAddress(zone.getId(), publicIp).get(0);         StaticNatImpl staticNat = new StaticNatImpl(ipVO.getAllocatedToAccountId(), ipVO.getAllocatedInDomainId(), network.getId(), ipVO.getId(), privateIp, revoked);         staticNats.add(staticNat);         StaticNatServiceProvider element = _networkMgr.getStaticNatProviderForNetwork(network);         element.applyStaticNats(network, staticNats);     }      private enum MappingState {         Create, Remove, Unchanged,     };      private class MappingNic {         private Nic nic;         private MappingState state;          public Nic getNic() {             return nic;         }          public void setNic(Nic nic) {             this.nic = nic;         }          public MappingState getState() {             return state;         }          public void setState(MappingState state) {             this.state = state;         }     };      private MappingNic getLoadBalancingIpNic(DataCenterVO zone, Network network, long sourceIpId, boolean revoked, String existedGuestIp)         throws ResourceUnavailableException {         String srcIp = _networkModel.getIp(sourceIpId).getAddress().addr();         InlineLoadBalancerNicMapVO mapping = _inlineLoadBalancerNicMapDao.findByPublicIpAddress(srcIp);         Nic loadBalancingIpNic = null;         MappingNic nic = new MappingNic();         nic.setState(MappingState.Unchanged);         if (!revoked) {             if (mapping == null) {                 // Acquire a new guest IP address and save it as the load balancing IP address                 String loadBalancingIpAddress = existedGuestIp;                  if (loadBalancingIpAddress == null) {                     if (network.getGuestType() == Network.GuestType.Isolated) {                         loadBalancingIpAddress = _ipAddrMgr.acquireGuestIpAddress(network, null);                     } else if (network.getGuestType() == Network.GuestType.Shared) {                         try {                             PublicIp directIp =                                 _ipAddrMgr.assignPublicIpAddress(network.getDataCenterId(), null, _accountDao.findById(network.getAccountId()), VlanType.DirectAttached,                                     network.getId(), null, true, false);                             loadBalancingIpAddress = directIp.getAddress().addr();                         } catch (InsufficientCapacityException capException) {                             String msg = &quot;Ran out of guest IP addresses from the shared network.&quot;;                             s_logger.error(msg);                             throw new ResourceUnavailableException(msg, DataCenter.class, network.getDataCenterId());                         }                     }                 }                  if (loadBalancingIpAddress == null) {                     String msg = &quot;Ran out of guest IP addresses.&quot;;                     s_logger.error(msg);                     throw new ResourceUnavailableException(msg, DataCenter.class, network.getDataCenterId());                 }                  // If a NIC doesn't exist for the load balancing IP address, create one                 loadBalancingIpNic = _nicDao.findByIp4AddressAndNetworkId(loadBalancingIpAddress, network.getId());                 if (loadBalancingIpNic == null) {                     loadBalancingIpNic = _networkMgr.savePlaceholderNic(network, loadBalancingIpAddress, null, null);                 }                  // Save a mapping between the source IP address and the load balancing IP address NIC                 mapping = new InlineLoadBalancerNicMapVO(srcIp, loadBalancingIpNic.getId());                 _inlineLoadBalancerNicMapDao.persist(mapping);                  // On the firewall provider for the network, create a static NAT rule between the source IP                 // address and the load balancing IP address                 try {                     applyStaticNatRuleForInlineLBRule(zone, network, revoked, srcIp, loadBalancingIpNic.getIPv4Address());                 } catch (ResourceUnavailableException ex) {                     // Rollback db operation                     _inlineLoadBalancerNicMapDao.expunge(mapping.getId());                     _nicDao.expunge(loadBalancingIpNic.getId());                     throw ex;                 }                  s_logger.debug(&quot;Created static nat rule for inline load balancer&quot;);                 nic.setState(MappingState.Create);             } else {                 loadBalancingIpNic = _nicDao.findById(mapping.getNicId());             }         } else {             if (mapping != null) {                 // Find the NIC that the mapping refers to                 loadBalancingIpNic = _nicDao.findById(mapping.getNicId());                  int count = _ipAddrMgr.getRuleCountForIp(sourceIpId, Purpose.LoadBalancing, FirewallRule.State.Active);                 if (count == 0) {                     // On the firewall provider for the network, delete the static NAT rule between the source IP                     // address and the load balancing IP address                     applyStaticNatRuleForInlineLBRule(zone, network, revoked, srcIp, loadBalancingIpNic.getIPv4Address());                      // Delete the mapping between the source IP address and the load balancing IP address                     _inlineLoadBalancerNicMapDao.expunge(mapping.getId());                      // Delete the NIC                     _nicDao.expunge(loadBalancingIpNic.getId());                      s_logger.debug(&quot;Revoked static nat rule for inline load balancer&quot;);                     nic.setState(MappingState.Remove);                 }             } else {                 s_logger.debug(&quot;Revoking a rule for an inline load balancer that has not been programmed yet.&quot;);                 nic.setNic(null);                 return nic;             }         }          nic.setNic(loadBalancingIpNic);         return nic;     }      public boolean isNccServiceProvider(Network network) {         NetworkOffering networkOffering = _networkOfferingDao.findById(network.getNetworkOfferingId());         if(null!= networkOffering &amp;&amp; networkOffering.getServicePackage() != null ) {             return true;         }         else {             return false;         }     }      public HostVO getNetScalerControlCenterForNetwork(Network guestConfig) {         long zoneId = guestConfig.getDataCenterId();         return _hostDao.findByTypeNameAndZoneId(zoneId, &quot;NetscalerControlCenter&quot;, Type.NetScalerControlCenter);     }      @Override     public boolean applyLoadBalancerRules(Network network, List loadBalancingRules) throws ResourceUnavailableException {         // Find the external load balancer in this zone         long zoneId = network.getDataCenterId();         DataCenterVO zone = _dcDao.findById(zoneId);          if (loadBalancingRules == null || loadBalancingRules.isEmpty()) {             return true;         }          HostVO externalLoadBalancer = null;          if(isNccServiceProvider(network)) {             externalLoadBalancer  = getNetScalerControlCenterForNetwork(network);         } else {             ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(network);             if (lbDeviceVO == null) {                 s_logger.warn(&quot;There is no external load balancer device assigned to this network either network is not implement are already shutdown so just returning&quot;);                 return true;             } else {                 externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());             }         }            boolean externalLoadBalancerIsInline = _networkMgr.isNetworkInlineMode(network);          if (network.getState() == Network.State.Allocated) {             s_logger.debug(&quot;External load balancer was asked to apply LB rules for network with ID &quot; + network.getId() +                 &quot;; this network is not implemented. Skipping backend commands.&quot;);             return true;         }          List loadBalancersToApply = new ArrayList();         List mappingStates = new ArrayList();         for (int i = 0; i &lt; loadBalancingRules.size(); i++) {             LoadBalancingRule rule = loadBalancingRules.get(i);              boolean revoked = (rule.getState().equals(FirewallRule.State.Revoke));             String protocol = rule.getProtocol();             String algorithm = rule.getAlgorithm();             String uuid = rule.getUuid();             String srcIp = rule.getSourceIp().addr();             String srcIpVlan = null;             String srcIpGateway = null;             String srcIpNetmask = null;             Long vlanid =  _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getVlanId();             if(vlanid != null ) {               VlanVO publicVlan =   _vlanDao.findById(vlanid);               srcIpVlan =  publicVlan.getVlanTag();               srcIpGateway = publicVlan.getVlanGateway();               srcIpNetmask = publicVlan.getVlanNetmask();             }             int srcPort = rule.getSourcePortStart();             List destinations = rule.getDestinations();              if (externalLoadBalancerIsInline) {                 long ipId = _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getId();                 MappingNic nic = getLoadBalancingIpNic(zone, network, ipId, revoked, null);                 mappingStates.add(nic.getState());                 Nic loadBalancingIpNic = nic.getNic();                 if (loadBalancingIpNic == null) {                     continue;                 }                  // Change the source IP address for the load balancing rule to be the load balancing IP address                 srcIp = loadBalancingIpNic.getIPv4Address();             }              if ((destinations != null &amp;&amp; !destinations.isEmpty()) || rule.isAutoScaleConfig()) {                 boolean inline = _networkMgr.isNetworkInlineMode(network);                 LoadBalancerTO loadBalancer =                     new LoadBalancerTO(uuid, srcIp, srcPort, protocol, algorithm, revoked, false, inline, destinations, rule.getStickinessPolicies(),                         rule.getHealthCheckPolicies(), rule.getLbSslCert(), rule.getLbProtocol());                 loadBalancer.setNetworkId(network.getId());                 loadBalancer.setSrcIpVlan(srcIpVlan);                 loadBalancer.setSrcIpNetmask(srcIpNetmask);                 loadBalancer.setSrcIpGateway(srcIpGateway);                 if (rule.isAutoScaleConfig()) {                     loadBalancer.setAutoScaleVmGroup(rule.getAutoScaleVmGroup());                 }                 loadBalancersToApply.add(loadBalancer);             }         }          try {             if (loadBalancersToApply.size() &gt; 0) {                 int numLoadBalancersForCommand = loadBalancersToApply.size();                 LoadBalancerTO[] loadBalancersForCommand = loadBalancersToApply.toArray(new LoadBalancerTO[numLoadBalancersForCommand]);                 LoadBalancerConfigCommand cmd = new LoadBalancerConfigCommand(loadBalancersForCommand, null);                 long guestVlanTag = Integer.parseInt(BroadcastDomainType.getValue(network.getBroadcastUri()));                 cmd.setAccessDetail(NetworkElementCommand.GUEST_VLAN_TAG, String.valueOf(guestVlanTag));                 Answer answer = _agentMgr.easySend(externalLoadBalancer.getId(), cmd);                 if (answer == null || !answer.getResult()) {                     String details = (answer != null) ? answer.getDetails() : &quot;details unavailable&quot;;                     String msg = &quot;Unable to apply load balancer rules to the external load balancer appliance in zone &quot; + zone.getName() + &quot; due to: &quot; + details + &quot;.&quot;;                     s_logger.error(msg);                     throw new ResourceUnavailableException(msg, DataCenter.class, network.getDataCenterId());                 }             }         } catch (Exception ex) {             if (externalLoadBalancerIsInline) {                 s_logger.error(&quot;Rollbacking static nat operation of inline mode load balancing due to error on applying LB rules!&quot;);                 String existedGuestIp = loadBalancersToApply.get(0).getSrcIp();                 // Rollback static NAT operation in current session                 for (int i = 0; i &lt; loadBalancingRules.size(); i++) {                     LoadBalancingRule rule = loadBalancingRules.get(i);                     MappingState state = mappingStates.get(i);                     boolean revoke;                     if (state == MappingState.Create) {                         revoke = true;                     } else if (state == MappingState.Remove) {                         revoke = false;                     } else {                         continue;                     }                     long sourceIpId = _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getId();                     getLoadBalancingIpNic(zone, network, sourceIpId, revoke, existedGuestIp);                 }             }             throw new ResourceUnavailableException(ex.getMessage(), DataCenter.class, network.getDataCenterId());         }          return true;     }      @Override     public boolean manageGuestNetworkWithExternalLoadBalancer(boolean add, Network guestConfig) throws ResourceUnavailableException, InsufficientCapacityException {         if (guestConfig.getTrafficType() != TrafficType.Guest) {             s_logger.trace(&quot;External load balancer can only be used for guest networks.&quot;);             return false;         }          long zoneId = guestConfig.getDataCenterId();         DataCenterVO zone = _dcDao.findById(zoneId);         HostVO externalLoadBalancer = null;          if (add) {             ExternalLoadBalancerDeviceVO lbDeviceVO = null;             // on restart network, device could have been allocated already, skip allocation if a device is assigned             lbDeviceVO = getExternalLoadBalancerForNetwork(guestConfig);             if (lbDeviceVO == null) {                 // allocate a load balancer device for the network                 lbDeviceVO = allocateLoadBalancerForNetwork(guestConfig);                 if (lbDeviceVO == null) {                     String msg = &quot;failed to alloacate a external load balancer for the network &quot; + guestConfig.getId();                     s_logger.error(msg);                     throw new InsufficientNetworkCapacityException(msg, DataCenter.class, guestConfig.getDataCenterId());                 }             }             externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());             s_logger.debug(&quot;Allocated external load balancer device:&quot; + lbDeviceVO.getId() + &quot; for the network: &quot; + guestConfig.getId());         } else {             // find the load balancer device allocated for the network             ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(guestConfig);             if (lbDeviceVO == null) {                 s_logger.warn(&quot;Network shutdwon requested on external load balancer element, which did not implement the network.&quot;                     + &quot; Either network implement failed half way through or already network shutdown is completed. So just returning.&quot;);                 return true;             }              externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());             assert (externalLoadBalancer != null) : &quot;There is no device assigned to this network how did shutdown network ended up here??&quot;;         }          // Send a command to the external load balancer to implement or shutdown the guest network         String guestVlanTag = BroadcastDomainType.getValue(guestConfig.getBroadcastUri());         String selfIp = null;         String guestVlanNetmask = NetUtils.cidr2Netmask(guestConfig.getCidr());         Integer networkRate = _networkModel.getNetworkRate(guestConfig.getId(), null);          if (add) {             // on restart network, network could have already been implemented. If already implemented then return             Nic selfipNic = getPlaceholderNic(guestConfig);             if (selfipNic != null) {                 return true;             }              // Acquire a self-ip address from the guest network IP address range             selfIp = _ipAddrMgr.acquireGuestIpAddress(guestConfig, null);             if (selfIp == null) {                 String msg = &quot;failed to acquire guest IP address so not implementing the network on the external load balancer &quot;;                 s_logger.error(msg);                 throw new InsufficientNetworkCapacityException(msg, Network.class, guestConfig.getId());             }         } else {             // get the self-ip used by the load balancer             Nic selfipNic = getPlaceholderNic(guestConfig);             if (selfipNic == null) {                 s_logger.warn(&quot;Network shutdwon requested on external load balancer element, which did not implement the network.&quot;                     + &quot; Either network implement failed half way through or already network shutdown is completed. So just returning.&quot;);                 return true;             }             selfIp = selfipNic.getIPv4Address();         }          // It's a hack, using isOneToOneNat field for indicate if it's inline or not         boolean inline = _networkMgr.isNetworkInlineMode(guestConfig);         IpAddressTO ip =             new IpAddressTO(guestConfig.getAccountId(), null, add, false, true, guestVlanTag, selfIp, guestVlanNetmask, null, networkRate, inline);         IpAddressTO[] ips = new IpAddressTO[1];         ips[0] = ip;         IpAssocCommand cmd = new IpAssocCommand(ips);         Answer answer = _agentMgr.easySend(externalLoadBalancer.getId(), cmd);          if (answer == null || !answer.getResult()) {             String action = add ? &quot;implement&quot; : &quot;shutdown&quot;;             String answerDetails = (answer != null) ? answer.getDetails() : null;             answerDetails = (answerDetails != null) ? &quot; due to &quot; + answerDetails : &quot;&quot;;             String msg = &quot;External load balancer was unable to &quot; + action + &quot; the guest network on the external load balancer in zone &quot; + zone.getName() + answerDetails;             s_logger.error(msg);             throw new ResourceUnavailableException(msg, Network.class, guestConfig.getId());         }          if (add) {             // Insert a new NIC for this guest network to reserve the self IP             _networkMgr.savePlaceholderNic(guestConfig, selfIp, null, null);         } else {             // release the self-ip obtained from guest network             Nic selfipNic = getPlaceholderNic(guestConfig);             _nicDao.remove(selfipNic.getId());              // release the load balancer allocated for the network             boolean releasedLB = freeLoadBalancerForNetwork(guestConfig);             if (!releasedLB) {                 String msg = &quot;Failed to release the external load balancer used for the network: &quot; + guestConfig.getId();                 s_logger.error(msg);             }         }          if (s_logger.isDebugEnabled()) {             Account account = _accountDao.findByIdIncludingRemoved(guestConfig.getAccountId());             String action = add ? &quot;implemented&quot; : &quot;shut down&quot;;             s_logger.debug(&quot;External load balancer has &quot; + action + &quot; the guest network for account &quot; + account.getAccountName() + &quot;(id = &quot; + account.getAccountId() +                 &quot;) with VLAN tag &quot; + guestVlanTag);         }          return true;     }      @Override     public boolean configure(String name, Map params) throws ConfigurationException {         super.configure(name, params);         _defaultLbCapacity = NumbersUtil.parseLong(_configDao.getValue(Config.DefaultExternalLoadBalancerCapacity.key()), 50);         _resourceMgr.registerResourceStateAdapter(this.getClass().getSimpleName(), this);         return true;     }      @Override     public boolean start() {         return true;     }      @Override     public boolean stop() {         return true;     }      @Override     public HostVO createHostVOForConnectedAgent(HostVO host, StartupCommand[] cmd) {         // TODO Auto-generated method stub         return null;     }      @Override     public HostVO createHostVOForDirectConnectAgent(HostVO host, StartupCommand[] startup, ServerResource resource, Map details, List hostTags) {         if (!(startup[0] instanceof StartupExternalLoadBalancerCommand)) {             return null;         }         if(host.getName().equalsIgnoreCase(&quot;NetScalerControlCenter&quot;)) {             host.setType(Host.Type.NetScalerControlCenter);         }         else {             host.setType(Host.Type.ExternalLoadBalancer);         }         return host;     }      @Override     public DeleteHostAnswer deleteHost(HostVO host, boolean isForced, boolean isForceDeleteStorage) throws UnableDeleteHostException {         if (host.getType() != com.cloud.host.Host.Type.ExternalLoadBalancer) {             return null;         }         return new DeleteHostAnswer(true);     }      protected IpDeployer getIpDeployerForInlineMode(Network network) {         //We won't deploy IP, instead the firewall in front of us would do it         List providers = _networkMgr.getProvidersForServiceInNetwork(network, Service.Firewall);         //Only support one provider now         if (providers == null) {             s_logger.error(&quot;Cannot find firewall provider for network &quot; + network.getId());             return null;         }         if (providers.size() != 1) {             s_logger.error(&quot;Found &quot; + providers.size() + &quot; firewall provider for network &quot; + network.getId());             return null;         }          NetworkElement element = _networkModel.getElementImplementingProvider(providers.get(0).getName());         if (!(element instanceof IpDeployer)) {             s_logger.error(&quot;The firewall provider for network &quot; + network.getName() + &quot; don't have ability to deploy IP address!&quot;);             return null;         }         s_logger.info(&quot;Let &quot; + element.getName() + &quot; handle ip association for &quot; + getName() + &quot; in network &quot; + network.getId());         return (IpDeployer)element;     }      @Override     public List getLBHealthChecks(Network network, List loadBalancingRules) throws ResourceUnavailableException {          // Find the external load balancer in this zone         long zoneId = network.getDataCenterId();         DataCenterVO zone = _dcDao.findById(zoneId);          if (loadBalancingRules == null || loadBalancingRules.isEmpty()) {             return null;         }          HostVO externalLoadBalancer = null;          if(isNccServiceProvider(network)) {             externalLoadBalancer  = getNetScalerControlCenterForNetwork(network);         } else {             ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(network);             if (lbDeviceVO == null) {                 s_logger.warn(&quot;There is no external load balancer device assigned to this network either network is not implement are already shutdown so just returning&quot;);                 return null;             } else {                 externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());             }         }          boolean externalLoadBalancerIsInline = _networkMgr.isNetworkInlineMode(network);          if (network.getState() == Network.State.Allocated) {             s_logger.debug(&quot;External load balancer was asked to apply LB rules for network with ID &quot; + network.getId() +                 &quot;; this network is not implemented. Skipping backend commands.&quot;);             return null;         }          List loadBalancersToApply = new ArrayList();         List mappingStates = new ArrayList();         for (final LoadBalancingRule rule : loadBalancingRules) {             boolean revoked = (FirewallRule.State.Revoke.equals(rule.getState()));             String protocol = rule.getProtocol();             String algorithm = rule.getAlgorithm();             String uuid = rule.getUuid();             String srcIp = rule.getSourceIp().addr();             int srcPort = rule.getSourcePortStart();             List destinations = rule.getDestinations();              if (externalLoadBalancerIsInline) {                 long sourceIpId = _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getId();                 MappingNic nic = getLoadBalancingIpNic(zone, network, sourceIpId, revoked, null);                 mappingStates.add(nic.getState());                 Nic loadBalancingIpNic = nic.getNic();                 if (loadBalancingIpNic == null) {                     continue;                 }                  // Change the source IP address for the load balancing rule to                 // be the load balancing IP address                 srcIp = loadBalancingIpNic.getIPv4Address();             }              if ((destinations != null &amp;&amp; !destinations.isEmpty()) || !rule.isAutoScaleConfig()) {                 boolean inline = _networkMgr.isNetworkInlineMode(network);                 LoadBalancerTO loadBalancer =                     new LoadBalancerTO(uuid, srcIp, srcPort, protocol, algorithm, revoked, false, inline, destinations, rule.getStickinessPolicies(),                         rule.getHealthCheckPolicies(), rule.getLbSslCert(), rule.getLbProtocol());                 loadBalancersToApply.add(loadBalancer);             }         }          try {             if (loadBalancersToApply.size() &gt; 0) {                 int numLoadBalancersForCommand = loadBalancersToApply.size();                 LoadBalancerTO[] loadBalancersForCommand = loadBalancersToApply.toArray(new LoadBalancerTO[numLoadBalancersForCommand]);                 HealthCheckLBConfigCommand cmd = new HealthCheckLBConfigCommand(loadBalancersForCommand, network.getId());                 long guestVlanTag = Integer.parseInt(BroadcastDomainType.getValue(network.getBroadcastUri()));                 cmd.setAccessDetail(NetworkElementCommand.GUEST_VLAN_TAG, String.valueOf(guestVlanTag));                  HealthCheckLBConfigAnswer answer = (HealthCheckLBConfigAnswer) _agentMgr.easySend(externalLoadBalancer.getId(), cmd);                 // easySend will return null on error                 return answer == null ? null : answer.getLoadBalancers();             }         } catch (Exception ex) {             s_logger.error(&quot;Exception Occured &quot;, ex);         }         //null return is handled by clients         return null;     }      private NicVO getPlaceholderNic(Network network) {         List guestIps = _nicDao.listByNetworkId(network.getId());         for (NicVO guestIp : guestIps) {             // only external firewall and external load balancer will create NicVO with PlaceHolder reservation strategy             if (guestIp.getReservationStrategy().equals(ReservationStrategy.PlaceHolder) &amp;&amp; guestIp.getVmType() == null &amp;&amp; guestIp.getReserver() == null &amp;&amp;                 !guestIp.getIPv4Address().equals(network.getGateway())) {                 return guestIp;             }         }         return null;     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2054</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/server/src/main/java/com/cloud/network/ExternalLoadBalancerDeviceManagerImpl.java/#L141-L1311</td>
    <td align="right">1</td>
    <td align="right">2886</td>
    <td align="right">2054</td>
  </tr>
  <tr valign="top">
    <td align="right">396</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES, I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    static class Cause {         final Tuple tuple ;         final Mapping     mapping ;          public Cause(Tuple tuple, Mapping mapping) {             super() ;             this.tuple = tuple ;             this.mapping = mapping ;         }     }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4035</td>
    <td align="left">https://github.com/apache/jena/blob/1cca775bbf0bb0fd3ee8ac55e31f0f30cdde3b77/jena-arq/src/main/java/org/apache/jena/sparql/util/IsoMatcher.java/#L113-L122</td>
    <td align="right">1</td>
    <td align="right">396</td>
    <td align="right">4035</td>
  </tr>
  <tr valign="top">
    <td align="right">1779</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [       &quot;Long method&quot;,       &quot;Data class&quot;,       &quot;Message chain&quot;,       &quot;Data clumps&quot;,       &quot;Primitive obsession&quot;,       &quot;Feature envy&quot;     ]   }</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells).<br />
 Could you please identify which smells occur in the following code? However, do not describe the smells,<br />
 just list them. <br />
Please start your answer with &quot;YES I found bad smells&quot; when you find any bad smell. <br />
Otherwise, start your answer with &quot;NO, I did not find any bad smell&quot;. <br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells<br />
are:&quot; amongst the text your answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class DataSourceLoginService extends AbstractLoginService {     private static final Logger LOG = Log.getLogger(DataSourceLoginService.class);      private String _jndiName = &quot;javax.sql.DataSource/default&quot;;     private DataSource _datasource;     private Server _server;     private String _userTableName = &quot;users&quot;;     private String _userTableKey = &quot;id&quot;;     private String _userTableUserField = &quot;username&quot;;     private String _userTablePasswordField = &quot;pwd&quot;;     private String _roleTableName = &quot;roles&quot;;     private String _roleTableKey = &quot;id&quot;;     private String _roleTableRoleField = &quot;role&quot;;     private String _userRoleTableName = &quot;user_roles&quot;;     private String _userRoleTableUserKey = &quot;user_id&quot;;     private String _userRoleTableRoleKey = &quot;role_id&quot;;     private String _userSql;     private String _roleSql;     private boolean _createTables = false;               /**      * DBUser      */     public class DBUserPrincipal extends UserPrincipal     {         private int _key;                  public DBUserPrincipal(String name, Credential credential, int key)         {             super(name, credential);             _key = key;         }                  public int getKey ()         {             return _key;         }              }      /* ------------------------------------------------------------ */     public DataSourceLoginService()     {     }      /* ------------------------------------------------------------ */     public DataSourceLoginService(String name)     {         setName(name);     }      /* ------------------------------------------------------------ */     public DataSourceLoginService(String name, IdentityService identityService)     {         setName(name);         setIdentityService(identityService);     }      /* ------------------------------------------------------------ */     public void setJndiName (String jndi)     {         _jndiName = jndi;     }      /* ------------------------------------------------------------ */     public String getJndiName ()     {         return _jndiName;     }      /* ------------------------------------------------------------ */     public void setServer (Server server)     {         _server=server;     }      /* ------------------------------------------------------------ */     public Server getServer()     {         return _server;     }      /* ------------------------------------------------------------ */     public void setCreateTables(boolean createTables)     {         _createTables = createTables;     }      /* ------------------------------------------------------------ */     public boolean getCreateTables()     {         return _createTables;     }      /* ------------------------------------------------------------ */     public void setUserTableName (String name)     {         _userTableName=name;     }      /* ------------------------------------------------------------ */     public String getUserTableName()     {         return _userTableName;     }      /* ------------------------------------------------------------ */     public String getUserTableKey()     {         return _userTableKey;     }       /* ------------------------------------------------------------ */     public void setUserTableKey(String tableKey)     {         _userTableKey = tableKey;     }       /* ------------------------------------------------------------ */     public String getUserTableUserField()     {         return _userTableUserField;     }       /* ------------------------------------------------------------ */     public void setUserTableUserField(String tableUserField)     {         _userTableUserField = tableUserField;     }       /* ------------------------------------------------------------ */     public String getUserTablePasswordField()     {         return _userTablePasswordField;     }       /* ------------------------------------------------------------ */     public void setUserTablePasswordField(String tablePasswordField)     {         _userTablePasswordField = tablePasswordField;     }       /* ------------------------------------------------------------ */     public String getRoleTableName()     {         return _roleTableName;     }       /* ------------------------------------------------------------ */     public void setRoleTableName(String tableName)     {         _roleTableName = tableName;     }       /* ------------------------------------------------------------ */     public String getRoleTableKey()     {         return _roleTableKey;     }       /* ------------------------------------------------------------ */     public void setRoleTableKey(String tableKey)     {         _roleTableKey = tableKey;     }       /* ------------------------------------------------------------ */     public String getRoleTableRoleField()     {         return _roleTableRoleField;     }       /* ------------------------------------------------------------ */     public void setRoleTableRoleField(String tableRoleField)     {         _roleTableRoleField = tableRoleField;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableName()     {         return _userRoleTableName;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableName(String roleTableName)     {         _userRoleTableName = roleTableName;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableUserKey()     {         return _userRoleTableUserKey;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableUserKey(String roleTableUserKey)     {         _userRoleTableUserKey = roleTableUserKey;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableRoleKey()     {         return _userRoleTableRoleKey;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableRoleKey(String roleTableRoleKey)     {         _userRoleTableRoleKey = roleTableRoleKey;     }              /* ------------------------------------------------------------ */     @Override     public UserPrincipal loadUserInfo (String username)     {         try         {             try (Connection connection = getConnection();                     PreparedStatement statement1 = connection.prepareStatement(_userSql))             {                 statement1.setObject(1, username);                 try (ResultSet rs1 = statement1.executeQuery())                 {                     if (rs1.next())                     {                         int key = rs1.getInt(_userTableKey);                         String credentials = rs1.getString(_userTablePasswordField);                                                  return new DBUserPrincipal(username, Credential.getCredential(credentials), key);                     }                 }             }         }         catch (NamingException e)         {             LOG.warn(&quot;No datasource for &quot;+_jndiName, e);         }         catch (SQLException e)         {             LOG.warn(&quot;Problem loading user info for &quot;+username, e);         }         return null;     }               /* ------------------------------------------------------------ */     @Override     public String[] loadRoleInfo (UserPrincipal user)     {         DBUserPrincipal dbuser = (DBUserPrincipal)user;          try         {             try (Connection connection = getConnection();                     PreparedStatement statement2 = connection.prepareStatement(_roleSql))             {                  List roles = new ArrayList();                  statement2.setInt(1, dbuser.getKey());                 try (ResultSet rs2 = statement2.executeQuery())                 {                     while (rs2.next())                     {                         roles.add(rs2.getString(_roleTableRoleField));                     }                                          return roles.toArray(new String[roles.size()]);                 }             }         }         catch (NamingException e)         {             LOG.warn(&quot;No datasource for &quot;+_jndiName, e);         }         catch (SQLException e)         {             LOG.warn(&quot;Problem loading user info for &quot;+user.getName(), e);         }         return null;     }             /* ------------------------------------------------------------ */     /**      * Lookup the datasource for the jndiName and formulate the      * necessary sql query strings based on the configured table      * and column names.      *      * @throws NamingException if unable to init jndi      * @throws SQLException if unable to init database      */     public void initDb() throws NamingException, SQLException     {         if (_datasource != null)             return;          @SuppressWarnings(&quot;unused&quot;)         InitialContext ic = new InitialContext();         assert ic!=null;          // TODO Should we try webapp scope too?          // try finding the datasource in the Server scope         if (_server != null)         {             try             {                 _datasource = (DataSource)NamingEntryUtil.lookup(_server, _jndiName);             }             catch (NameNotFoundException e)             {                 //next try the jvm scope             }         }           //try finding the datasource in the jvm scope         if (_datasource==null)         {             _datasource = (DataSource)NamingEntryUtil.lookup(null, _jndiName);         }          // set up the select statements based on the table and column names configured         _userSql = &quot;select &quot; + _userTableKey + &quot;,&quot; + _userTablePasswordField                   + &quot; from &quot; + _userTableName                   + &quot; where &quot;+ _userTableUserField + &quot; = ?&quot;;          _roleSql = &quot;select r.&quot; + _roleTableRoleField                   + &quot; from &quot; + _roleTableName + &quot; r, &quot; + _userRoleTableName                   + &quot; u where u.&quot;+ _userRoleTableUserKey + &quot; = ?&quot;                   + &quot; and r.&quot; + _roleTableKey + &quot; = u.&quot; + _userRoleTableRoleKey;          prepareTables();     }      /* ------------------------------------------------------------ */     /**      * @throws NamingException      * @throws SQLException      */     private void prepareTables()     throws NamingException, SQLException     {         if (_createTables)         {             boolean autocommit = true;             Connection connection = getConnection();             try (Statement stmt = connection.createStatement())             {                 autocommit = connection.getAutoCommit();                 connection.setAutoCommit(false);                 DatabaseMetaData metaData = connection.getMetaData();                  //check if tables exist                 String tableName = (metaData.storesLowerCaseIdentifiers()? _userTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userTableName.toUpperCase(Locale.ENGLISH): _userTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //user table default                         /*                          * create table _userTableName (_userTableKey integer,                          * _userTableUserField varchar(100) not null unique,                          * _userTablePasswordField varchar(20) not null, primary key(_userTableKey));                          */                         stmt.executeUpdate(&quot;create table &quot;+_userTableName+ &quot;(&quot;+_userTableKey+&quot; integer,&quot;+                                 _userTableUserField+&quot; varchar(100) not null unique,&quot;+                                 _userTablePasswordField+&quot; varchar(20) not null, primary key(&quot;+_userTableKey+&quot;))&quot;);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_userTableName);                     }                 }                  tableName = (metaData.storesLowerCaseIdentifiers()? _roleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_roleTableName.toUpperCase(Locale.ENGLISH): _roleTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //role table default                         /*                          * create table _roleTableName (_roleTableKey integer,                          * _roleTableRoleField varchar(100) not null unique, primary key(_roleTableKey));                          */                         String str = &quot;create table &quot;+_roleTableName+&quot; (&quot;+_roleTableKey+&quot; integer, &quot;+                         _roleTableRoleField+&quot; varchar(100) not null unique, primary key(&quot;+_roleTableKey+&quot;))&quot;;                         stmt.executeUpdate(str);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_roleTableName);                     }                 }                  tableName = (metaData.storesLowerCaseIdentifiers()? _userRoleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userRoleTableName.toUpperCase(Locale.ENGLISH): _userRoleTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //user-role table                         /*                          * create table _userRoleTableName (_userRoleTableUserKey integer,                          * _userRoleTableRoleKey integer,                          * primary key (_userRoleTableUserKey, _userRoleTableRoleKey));                          *                          * create index idx_user_role on _userRoleTableName (_userRoleTableUserKey);                          */                         stmt.executeUpdate(&quot;create table &quot;+_userRoleTableName+&quot; (&quot;+_userRoleTableUserKey+&quot; integer, &quot;+                                 _userRoleTableRoleKey+&quot; integer, &quot;+                                 &quot;primary key (&quot;+_userRoleTableUserKey+&quot;, &quot;+_userRoleTableRoleKey+&quot;))&quot;);                         stmt.executeUpdate(&quot;create index indx_user_role on &quot;+_userRoleTableName+&quot;(&quot;+_userRoleTableUserKey+&quot;)&quot;);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_userRoleTableName +&quot; and index&quot;);                     }                 }                 connection.commit();             }             finally             {                 try                 {                     connection.setAutoCommit(autocommit);                 }                 catch (SQLException e)                 {                     if (LOG.isDebugEnabled()) LOG.debug(&quot;Prepare tables&quot;, e);                 }                 finally                 {                     try                     {                         connection.close();                     }                     catch (SQLException e)                     {                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Prepare tables&quot;, e);                     }                 }             }         }         else if (LOG.isDebugEnabled())         {             LOG.debug(&quot;createTables false&quot;);         }     }      /* ------------------------------------------------------------ */     /**      * @return      * @throws NamingException      * @throws SQLException      */     private Connection getConnection ()     throws NamingException, SQLException     {         initDb();         return _datasource.getConnection();     } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class, message chain, data clumps, primitive obsession, feature envy</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method,  message chain,  data clumps,  primitive obsession,  feature envy</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11959</td>
    <td align="left">https://github.com/eclipse/jetty.project/blob/65528f76c5ef6ddca11385f9721c8f0bc5f2eed7/jetty-plus/src/main/java/org/eclipse/jetty/plus/security/DataSourceLoginService.java/#L52-L530</td>
    <td align="right">2</td>
    <td align="right">1779</td>
    <td align="right">11959</td>
  </tr>
  <tr valign="top">
    <td align="right">1252</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DebugInfoDecoder {     /** encoded debug info */     private final byte[] encoded;      /** positions decoded */     private final ArrayList positions;      /** locals decoded */     private final ArrayList locals;      /** size of code block in code units */     private final int codesize;      /** indexed by register, the last local variable live in a reg */     private final LocalEntry[] lastEntryForReg;      /** method descriptor of method this debug info is for */     private final Prototype desc;      /** true if method is static */     private final boolean isStatic;      /** dex file this debug info will be stored in */     private final DexFile file;      /**      * register size, in register units, of the register space      * used by this method      */     private final int regSize;      /** current decoding state: line number */     private int line = 1;      /** current decoding state: bytecode address */     private int address = 0;      /** string index of the string &quot;this&quot; */     private final int thisStringIdx;      /**      * Constructs an instance.      *      * @param encoded encoded debug info      * @param codesize size of code block in code units      * @param regSize register size, in register units, of the register space      * used by this method      * @param isStatic true if method is static      * @param ref method descriptor of method this debug info is for      * @param file dex file this debug info will be stored in      */     DebugInfoDecoder(byte[] encoded, int codesize, int regSize,             boolean isStatic, CstMethodRef ref, DexFile file) {         if (encoded == null) {             throw new NullPointerException(&quot;encoded == null&quot;);         }          this.encoded = encoded;         this.isStatic = isStatic;         this.desc = ref.getPrototype();         this.file = file;         this.regSize = regSize;          positions = new ArrayList();         locals = new ArrayList();         this.codesize = codesize;         lastEntryForReg = new LocalEntry[regSize];          int idx = -1;          try {             idx = file.getStringIds().indexOf(new CstString(&quot;this&quot;));         } catch (IllegalArgumentException ex) {             /*              * Silently tolerate not finding &quot;this&quot;. It just means that              * no method has local variable info that looks like              * a standard instance method.              */         }          thisStringIdx = idx;     }      /**      * An entry in the resulting postions table      */     static private class PositionEntry {         /** bytecode address */         public int address;          /** line number */         public int line;          public PositionEntry(int address, int line) {             this.address = address;             this.line = line;         }     }      /**      * An entry in the resulting locals table      */     static private class LocalEntry {         /** address of event */         public int address;          /** {@code true} iff it's a local start */         public boolean isStart;          /** register number */         public int reg;          /** index of name in strings table */         public int nameIndex;          /** index of type in types table */         public int typeIndex;          /** index of type signature in strings table */         public int signatureIndex;          public LocalEntry(int address, boolean isStart, int reg, int nameIndex,                 int typeIndex, int signatureIndex) {             this.address        = address;             this.isStart        = isStart;             this.reg            = reg;             this.nameIndex      = nameIndex;             this.typeIndex      = typeIndex;             this.signatureIndex = signatureIndex;         }          public String toString() {             return String.format(&quot;[%x %s v%d %04x %04x %04x]&quot;,                     address, isStart ? &quot;start&quot; : &quot;end&quot;, reg,                     nameIndex, typeIndex, signatureIndex);         }     }      /**      * Gets the decoded positions list.      * Valid after calling {@code decode}.      *      * @return positions list in ascending address order.      */     public List getPositionList() {         return positions;     }      /**      * Gets the decoded locals list, in ascending start-address order.      * Valid after calling {@code decode}.      *      * @return locals list in ascending address order.      */     public List getLocals() {         return locals;     }      /**      * Decodes the debug info sequence.      */     public void decode() {         try {             decode0();         } catch (Exception ex) {             throw ExceptionWithContext.withContext(ex,                     &quot;...while decoding debug info&quot;);         }     }      /**      * Reads a string index. String indicies are offset by 1, and a 0 value      * in the stream (-1 as returned by this method) means &quot;null&quot;      *      * @return index into file's string ids table, -1 means null      * @throws IOException      */     private int readStringIndex(ByteInput bs) throws IOException {         int offsetIndex = Leb128.readUnsignedLeb128(bs);          return offsetIndex - 1;     }      /**      * Gets the register that begins the method's parameter range (including      * the 'this' parameter for non-static methods). The range continues until      * {@code regSize}      *      * @return register as noted above.      */     private int getParamBase() {         return regSize                 - desc.getParameterTypes().getWordCount() - (isStatic? 0 : 1);     }      private void decode0() throws IOException {         ByteInput bs = new ByteArrayByteInput(encoded);          line = Leb128.readUnsignedLeb128(bs);         int szParams = Leb128.readUnsignedLeb128(bs);         StdTypeList params = desc.getParameterTypes();         int curReg = getParamBase();          if (szParams != params.size()) {             throw new RuntimeException(                     &quot;Mismatch between parameters_size and prototype&quot;);         }          if (!isStatic) {             // Start off with implicit 'this' entry             LocalEntry thisEntry =                 new LocalEntry(0, true, curReg, thisStringIdx, 0, 0);             locals.add(thisEntry);             lastEntryForReg[curReg] = thisEntry;             curReg++;         }          for (int i = 0; i &lt; szParams; i++) {             Type paramType = params.getType(i);             LocalEntry le;              int nameIdx = readStringIndex(bs);              if (nameIdx == -1) {                 /*                  * Unnamed parameter; often but not always filled in by an                  * extended start op after the prologue                  */                 le = new LocalEntry(0, true, curReg, -1, 0, 0);             } else {                 // TODO: Final 0 should be idx of paramType.getDescriptor().                 le = new LocalEntry(0, true, curReg, nameIdx, 0, 0);             }              locals.add(le);             lastEntryForReg[curReg] = le;             curReg += paramType.getCategory();         }          for (;;) {             int opcode = bs.readByte() &amp; 0xff;              switch (opcode) {                 case DBG_START_LOCAL: {                     int reg = Leb128.readUnsignedLeb128(bs);                     int nameIdx = readStringIndex(bs);                     int typeIdx = readStringIndex(bs);                     LocalEntry le = new LocalEntry(                             address, true, reg, nameIdx, typeIdx, 0);                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_START_LOCAL_EXTENDED: {                     int reg = Leb128.readUnsignedLeb128(bs);                     int nameIdx = readStringIndex(bs);                     int typeIdx = readStringIndex(bs);                     int sigIdx = readStringIndex(bs);                     LocalEntry le = new LocalEntry(                             address, true, reg, nameIdx, typeIdx, sigIdx);                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_RESTART_LOCAL: {                     int reg = Leb128.readUnsignedLeb128(bs);                     LocalEntry prevle;                     LocalEntry le;                      try {                         prevle = lastEntryForReg[reg];                          if (prevle.isStart) {                             throw new RuntimeException(&quot;nonsensical &quot;                                     + &quot;RESTART_LOCAL on live register v&quot;                                     + reg);                         }                          le = new LocalEntry(address, true, reg,                                 prevle.nameIndex, prevle.typeIndex, 0);                     } catch (NullPointerException ex) {                         throw new RuntimeException(                                 &quot;Encountered RESTART_LOCAL on new v&quot; + reg);                     }                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_END_LOCAL: {                     int reg = Leb128.readUnsignedLeb128(bs);                     LocalEntry prevle;                     LocalEntry le;                      try {                         prevle = lastEntryForReg[reg];                          if (!prevle.isStart) {                             throw new RuntimeException(&quot;nonsensical &quot;                                     + &quot;END_LOCAL on dead register v&quot; + reg);                         }                          le = new LocalEntry(address, false, reg,                                 prevle.nameIndex, prevle.typeIndex,                                 prevle.signatureIndex);                     } catch (NullPointerException ex) {                         throw new RuntimeException(                                 &quot;Encountered END_LOCAL on new v&quot; + reg);                     }                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_END_SEQUENCE:                     // all done                 return;                  case DBG_ADVANCE_PC:                     address += Leb128.readUnsignedLeb128(bs);                 break;                  case DBG_ADVANCE_LINE:                     line += Leb128.readSignedLeb128(bs);                 break;                  case DBG_SET_PROLOGUE_END:                     //TODO do something with this.                 break;                  case DBG_SET_EPILOGUE_BEGIN:                     //TODO do something with this.                 break;                  case DBG_SET_FILE:                     //TODO do something with this.                 break;                  default:                     if (opcode &lt; DBG_FIRST_SPECIAL) {                         throw new RuntimeException(                                 &quot;Invalid extended opcode encountered &quot;                                         + opcode);                     }                      int adjopcode = opcode - DBG_FIRST_SPECIAL;                      address += adjopcode / DBG_LINE_RANGE;                     line += DBG_LINE_BASE + (adjopcode % DBG_LINE_RANGE);                      positions.add(new PositionEntry(address, line));                 break;              }         }     }      /**      * Validates an encoded debug info stream against data used to encode it,      * throwing an exception if they do not match. Used to validate the      * encoder.      *      * @param info encoded debug info      * @param file {@code non-null;} file to refer to during decoding      * @param ref {@code non-null;} method whose info is being decoded      * @param code {@code non-null;} original code object that was encoded      * @param isStatic whether the method is static      */     public static void validateEncode(byte[] info, DexFile file,             CstMethodRef ref, DalvCode code, boolean isStatic) {         PositionList pl = code.getPositions();         LocalList ll = code.getLocals();         DalvInsnList insns = code.getInsns();         int codeSize = insns.codeSize();         int countRegisters = insns.getRegistersSize();          try {             validateEncode0(info, codeSize, countRegisters,                     isStatic, ref, file, pl, ll);         } catch (RuntimeException ex) {             System.err.println(&quot;instructions:&quot;);             insns.debugPrint(System.err, &quot;  &quot;, true);             System.err.println(&quot;local list:&quot;);             ll.debugPrint(System.err, &quot;  &quot;);             throw ExceptionWithContext.withContext(ex,                     &quot;while processing &quot; + ref.toHuman());         }     }      private static void validateEncode0(byte[] info, int codeSize,             int countRegisters, boolean isStatic, CstMethodRef ref,             DexFile file, PositionList pl, LocalList ll) {         DebugInfoDecoder decoder                 = new DebugInfoDecoder(info, codeSize, countRegisters,                     isStatic, ref, file);          decoder.decode();          /*          * Go through the decoded position entries, matching up          * with original entries.          */          List decodedEntries = decoder.getPositionList();          if (decodedEntries.size() != pl.size()) {             throw new RuntimeException(                     &quot;Decoded positions table not same size was &quot;                     + decodedEntries.size() + &quot; expected &quot; + pl.size());         }          for (PositionEntry entry : decodedEntries) {             boolean found = false;             for (int i = pl.size() - 1; i &gt;= 0; i--) {                 PositionList.Entry ple = pl.get(i);                  if (entry.line == ple.getPosition().getLine()                         &amp;&amp; entry.address == ple.getAddress()) {                     found = true;                     break;                 }             }              if (!found) {                 throw new RuntimeException (&quot;Could not match position entry: &quot;                         + entry.address + &quot;, &quot; + entry.line);             }         }          /*          * Go through the original local list, in order, matching up          * with decoded entries.          */          List decodedLocals = decoder.getLocals();         int thisStringIdx = decoder.thisStringIdx;         int decodedSz = decodedLocals.size();         int paramBase = decoder.getParamBase();          /*          * Preflight to fill in any parameters that were skipped in          * the prologue (including an implied &quot;this&quot;) but then          * identified by full signature.          */         for (int i = 0; i &lt; decodedSz; i++) {             LocalEntry entry = decodedLocals.get(i);             int idx = entry.nameIndex;              if ((idx &lt; 0) || (idx == thisStringIdx)) {                 for (int j = i + 1; j &lt; decodedSz; j++) {                     LocalEntry e2 = decodedLocals.get(j);                     if (e2.address != 0) {                         break;                     }                     if ((entry.reg == e2.reg) &amp;&amp; e2.isStart) {                         decodedLocals.set(i, e2);                         decodedLocals.remove(j);                         decodedSz--;                         break;                     }                 }             }         }          int origSz = ll.size();         int decodeAt = 0;         boolean problem = false;          for (int i = 0; i &lt; origSz; i++) {             LocalList.Entry origEntry = ll.get(i);              if (origEntry.getDisposition()                     == LocalList.Disposition.END_REPLACED) {                 /*                  * The encoded list doesn't represent replacements, so                  * ignore them for the sake of comparison.                  */                 continue;             }              LocalEntry decodedEntry;              do {                 decodedEntry = decodedLocals.get(decodeAt);                 if (decodedEntry.nameIndex &gt;= 0) {                     break;                 }                 /*                  * A negative name index means this is an anonymous                  * parameter, and we shouldn't expect to see it in the                  * original list. So, skip it.                  */                 decodeAt++;             } while (decodeAt &lt; decodedSz);              int decodedAddress = decodedEntry.address;              if (decodedEntry.reg != origEntry.getRegister()) {                 System.err.println(&quot;local register mismatch at orig &quot; + i +                         &quot; / decoded &quot; + decodeAt);                 problem = true;                 break;             }              if (decodedEntry.isStart != origEntry.isStart()) {                 System.err.println(&quot;local start/end mismatch at orig &quot; + i +                         &quot; / decoded &quot; + decodeAt);                 problem = true;                 break;             }              /*              * The secondary check here accounts for the fact that a              * parameter might not be marked as starting at 0 in the              * original list.              */             if ((decodedAddress != origEntry.getAddress())                     &amp;&amp; !((decodedAddress == 0)                             &amp;&amp; (decodedEntry.reg &gt;= paramBase))) {                 System.err.println(&quot;local address mismatch at orig &quot; + i +                         &quot; / decoded &quot; + decodeAt);                 problem = true;                 break;             }              decodeAt++;         }          if (problem) {             System.err.println(&quot;decoded locals:&quot;);             for (LocalEntry e : decodedLocals) {                 System.err.println(&quot;  &quot; + e);             }             throw new RuntimeException(&quot;local table problem&quot;);         }     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10442</td>
    <td align="left">https://github.com/facebook/buck/blob/1bc8d383ea5cb153ca9bf4f2807e6be498648523/third-party/java/dx/src/com/android/dx/dex/file/DebugInfoDecoder.java/#L54-L596</td>
    <td align="right">1</td>
    <td align="right">1252</td>
    <td align="right">10442</td>
  </tr>
  <tr valign="top">
    <td align="right">3909</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells&quot;: [         &quot;1. Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class WizardUIInfoPage { 	 	private int order; 	 	private String description; 	 	public int getOrder() { 		return order; 	} 	 	public String getDescription() { 		return description; 	} 	 	public static WizardUIInfoPage getDefaultPage(int order) { 		WizardUIInfoPage page = new WizardUIInfoPage(); 		page.order = order; 		page.description = &quot;&quot;; 		return page; 	} 	 }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10235</td>
    <td align="left">https://github.com/spring-projects/spring-ide/blob/915fe9bffd50db45ee0b8fb993416e45dee68179/plugins/org.springframework.ide.eclipse.wizard/src/org/springframework/ide/eclipse/wizard/template/infrastructure/ui/WizardUIInfoPage.java/#L18-L39</td>
    <td align="right">1</td>
    <td align="right">3909</td>
    <td align="right">10235</td>
  </tr>
  <tr valign="top">
    <td align="right">2287</td>
    <td align="left">&nbsp;&nbsp;YES I found bad smells The bad smells are: 1. Long class 2. Data class 3. Primitive obsession</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class ReportInstance extends AbstractDTOBase {      private String id;     private ReportStatusEnum status;     private String url;     private String ownerId;     private Boolean hasDetailRows;     private ZonedDateTime completionDate;     private ZonedDateTime requestDate;      public String getId() {         return id;     }      public void setId(String id) {         this.id = id;     }      public ReportStatusEnum getStatus() {         return status;     }      public void setStatus(ReportStatusEnum status) {         this.status = status;     }      public String getUrl() {         return url;     }      public void setUrl(String url) {         this.url = url;     }      public String getOwnerId() {         return ownerId;     }      public void setOwnerId(String ownerId) {         this.ownerId = ownerId;     }      public Boolean getHasDetailRows() {         return hasDetailRows;     }      public void setHasDetailRows(Boolean hasDetailRows) {         this.hasDetailRows = hasDetailRows;     }      public ZonedDateTime getCompletionDate() {         return completionDate;     }      public void setCompletionDate(ZonedDateTime completionDate) {         this.completionDate = completionDate;     }      public ZonedDateTime getRequestDate() {         return requestDate;     }      public void setRequestDate(ZonedDateTime requestDate) {         this.requestDate = requestDate;     } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long class2 Data class3 Primitive obsession</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13890</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/api/dto/analytics/reports/ReportInstance.java/#L26-L91</td>
    <td align="right">2</td>
    <td align="right">2287</td>
    <td align="right">13890</td>
  </tr>
  <tr valign="top">
    <td align="right">1714</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{             &quot;message&quot;: &quot;YES I found bad smells&quot;,             &quot;bad smells are&quot;: [                 &quot;Data Class&quot;             ]         }     </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Document public class Customer extends AbstractDocument {  	private String firstname, lastname;  	@Field(&quot;email&quot;) 	@Indexed(unique = true) 	private EmailAddress emailAddress; 	private Set addresses = new HashSet();  	/** 	 * Creates a new {@link Customer} from the given firstname and lastname. 	 *  	 * @param firstname must not be {@literal null} or empty. 	 * @param lastname must not be {@literal null} or empty. 	 */ 	public Customer(String firstname, String lastname) {  		Assert.hasText(firstname); 		Assert.hasText(lastname);  		this.firstname = firstname; 		this.lastname = lastname; 	}  	protected Customer() {  	}  	/** 	 * Adds the given {@link Address} to the {@link Customer}. 	 *  	 * @param address must not be {@literal null}. 	 */ 	public void add(Address address) {  		Assert.notNull(address); 		this.addresses.add(address); 	}  	/** 	 * Returns the firstname of the {@link Customer}. 	 *  	 * @return 	 */ 	public String getFirstname() { 		return firstname; 	}  	/** 	 * Returns the lastname of the {@link Customer}. 	 *  	 * @return 	 */ 	public String getLastname() { 		return lastname; 	}  	/** 	 * Sets the lastname of the {@link Customer}. 	 *  	 * @param lastname 	 */ 	public void setLastname(String lastname) { 		this.lastname = lastname; 	}  	/** 	 * Returns the {@link EmailAddress} of the {@link Customer}. 	 *  	 * @return 	 */ 	public EmailAddress getEmailAddress() { 		return emailAddress; 	}  	/** 	 * Sets the {@link Customer}'s {@link EmailAddress}. 	 *  	 * @param emailAddress must not be {@literal null}. 	 */ 	public void setEmailAddress(EmailAddress emailAddress) { 		this.emailAddress = emailAddress; 	}  	/** 	 * Return the {@link Customer}'s addresses. 	 *  	 * @return 	 */ 	public Set getAddresses() { 		return Collections.unmodifiableSet(addresses); 	} }</td>
    <td align="left">data class</td>
    <td align="left">Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11776</td>
    <td align="left">https://github.com/spring-projects/spring-data-book/blob/3a9d2e35184d5361f1d305f4eb84b5febf87b992/mongodb/src/main/java/com/oreilly/springdata/mongodb/core/Customer.java/#L32-L125</td>
    <td align="right">1</td>
    <td align="right">1714</td>
    <td align="right">11776</td>
  </tr>
  <tr valign="top">
    <td align="right">1231</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;the bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ErrorDataException extends Exception {      /** serialVersionUID. */     private static final long serialVersionUID = -9052741930614009382L;          /** The rpc data package. */     private RpcDataPackage rpcDataPackage;          /** The error code. */     private int errorCode;          /**      * Gets the error code.      *      * @return the error code      */     public int getErrorCode() {         return errorCode;     }      /**      * Sets the error code.      *      * @param errorCode the new error code      */     public void setErrorCode(int errorCode) {         this.errorCode = errorCode;     }      /**      * Gets the rpc data package.      *      * @return the rpc data package      */     public RpcDataPackage getRpcDataPackage() {         return rpcDataPackage;     }      /**      * Sets the rpc data package.      *      * @param rpcDataPackage the new rpc data package      */     public void setRpcDataPackage(RpcDataPackage rpcDataPackage) {         this.rpcDataPackage = rpcDataPackage;     }      /**      * Instantiates a new error data exception.      */     public ErrorDataException() {         super();     }      /**      * Instantiates a new error data exception.      *      * @param message the message      * @param cause the cause      */     public ErrorDataException(String message, Throwable cause) {         super(message, cause);     }          /**      * Instantiates a new error data exception.      *      * @param message the message      * @param cause the cause      * @param errorCode the error code      */     public ErrorDataException(String message, Throwable cause, int errorCode) {         super(message, cause);         this.errorCode = errorCode;     }      /**      * Instantiates a new error data exception.      *      * @param message the message      */     public ErrorDataException(String message) {         super(message);     }      /**      * Instantiates a new error data exception.      *      * @param message the message      * @param errorCode the error code      */     public ErrorDataException(String message, int errorCode) {         super(message);         this.errorCode = errorCode;     }          /**      * Instantiates a new error data exception.      *      * @param cause the cause      */     public ErrorDataException(Throwable cause) {         super(cause);     }          /**      * Instantiates a new error data exception.      *      * @param cause the cause      * @param errorCode the error code      */     public ErrorDataException(Throwable cause, int errorCode) {         super(cause);         this.errorCode = errorCode;     }       }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10364</td>
    <td align="left">https://github.com/baidu/Jprotobuf-rpc-socket/blob/4422e24c725eaf1f76646f674718bcc8750a4e1d/jprotobuf-rpc-core/src/main/java/com/baidu/jprotobuf/pbrpc/ErrorDataException.java/#L28-L145</td>
    <td align="right">1</td>
    <td align="right">1231</td>
    <td align="right">10364</td>
  </tr>
  <tr valign="top">
    <td align="right">585</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES, I found bad smells&quot;,         &quot;the bad smells are&quot;: [             &quot;Long Method&quot;,             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SuppressWarnings(&quot;rawtypes&quot;) public interface FlowableRxInvoker extends RxInvoker {      @Override     Flowable get();      @Override      Flowable get(Class responseType);      @Override      Flowable get(GenericType responseType);      @Override     Flowable put(Entity entity);      @Override      Flowable put(Entity entity, Class clazz);      @Override      Flowable put(Entity entity, GenericType type);      @Override     Flowable post(Entity entity);      @Override      Flowable post(Entity entity, Class clazz);      @Override      Flowable post(Entity entity, GenericType type);      @Override     Flowable delete();      @Override      Flowable delete(Class responseType);      @Override      Flowable delete(GenericType responseType);      @Override     Flowable head();      @Override     Flowable options();      @Override      Flowable options(Class responseType);      @Override      Flowable options(GenericType responseType);      @Override     Flowable trace();      @Override      Flowable trace(Class responseType);      @Override      Flowable trace(GenericType responseType);      @Override     Flowable method(String name);      @Override      Flowable method(String name, Class responseType);      @Override      Flowable method(String name, GenericType responseType);      @Override     Flowable method(String name, Entity entity);      @Override      Flowable method(String name, Entity entity, Class responseType);      @Override      Flowable method(String name, Entity entity, GenericType responseType); }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5805</td>
    <td align="left">https://github.com/apache/cxf/blob/6bf89e9c8804c8845ec4d38583dd33eea8256439/rt/rs/extensions/rx2/src/main/java/org/apache/cxf/jaxrs/rx2/client/FlowableRxInvoker.java/#L29-L106</td>
    <td align="right">1</td>
    <td align="right">585</td>
    <td align="right">5805</td>
  </tr>
  <tr valign="top">
    <td align="right">2510</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ChannelTypeXmlResult {      private ChannelType channelType;     private ConfigDescription configDescription;     private boolean system;      public ChannelTypeXmlResult(ChannelType channelType, ConfigDescription configDescription) {         this(channelType, configDescription, false);     }      public ChannelTypeXmlResult(ChannelType channelType, ConfigDescription configDescription, boolean system) {         this.channelType = channelType;         this.configDescription = configDescription;         this.system = system;     }      public ChannelType toChannelType() {         return this.channelType;     }      public ConfigDescription getConfigDescription() {         return this.configDescription;     }      public boolean isSystem() {         return system;     }      @Override     public String toString() {         return &quot;ChannelTypeXmlResult [channelType=&quot; + channelType + &quot;, configDescription=&quot; + configDescription + &quot;]&quot;;     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14684</td>
    <td align="left">https://github.com/eclipse/smarthome/blob/b8455de15d65512e8fac4e94d42de6ab2fccf1c5/bundles/core/org.eclipse.smarthome.core.thing.xml/src/main/java/org/eclipse/smarthome/core/thing/xml/internal/ChannelTypeXmlResult.java/#L28-L61</td>
    <td align="right">1</td>
    <td align="right">2510</td>
    <td align="right">14684</td>
  </tr>
  <tr valign="top">
    <td align="right">269</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Graph extends GraphShapeElement { 	public enum Alignment { 		HORIZONTAL, VERTICAL 	}  	private List nodes = new ArrayList&lt;&gt;(); 	private Set edges = new HashSet&lt;&gt;(); 	private Set subgraphs = new HashSet&lt;&gt;(); 	private Alignment alignment = Alignment.VERTICAL;  	/** 	 * Constructs a Graph that uses the specified GraphEventManager to handle 	 * any user generated events on GraphElements. 	 *  	 * @param eventManager 	 */ 	public Graph(GraphController graphController) { 		super(graphController); 	}  	/** 	 * Adds an edge to the Graph and sets its parent to be this Graph. 	 *  	 * @param edge 	 *            the edge to add 	 */ 	public void addEdge(GraphEdge edge) { 		edge.setParent(this); 		edges.add(edge); 	}  	/** 	 * Adds a node to the Graph and sets its parent to be this Graph. 	 *  	 * @param node 	 *            the node to add 	 */ 	public void addNode(GraphNode node) { 		node.setParent(this); 		nodes.add(node); 	}  	/** 	 * Adds a subgraph to the Graph and sets its parent to be this Graph. 	 *  	 * @param subgraph 	 *            the subgraph to add 	 */ 	public void addSubgraph(Graph subgraph) { 		subgraph.setParent(this); 		subgraphs.add(subgraph); 	}  	/** 	 * Returns the alignment of the Graph. 	 *  	 * @return the alignment of the Graph 	 */ 	public Alignment getAlignment() { 		return alignment; 	}  	/** 	 * Returns the edges contained in the Graph. 	 *  	 * @return the edges contained in the Graph 	 */ 	public Set getEdges() { 		return Collections.unmodifiableSet(edges); 	}  	/** 	 * Returns the nodes contained in the Graph. 	 *  	 * @return the nodes contained in the Graph 	 */ 	public List getNodes() { 		return Collections.unmodifiableList(nodes); 	}  	/** 	 * Returns the subgraphs contained in the Graph. 	 *  	 * @return the subgraphs contained in the Graph 	 */ 	public Set getSubgraphs() { 		return Collections.unmodifiableSet(subgraphs); 	}  	/** 	 * Removes an edge from the Graph. 	 *  	 * @param edge 	 *            the edge to remove 	 * @return true if the edge is removed from the Graph 	 */ 	public boolean removeEdge(GraphEdge edge) { 		return edges.remove(edge); 	}  	/** 	 * Removes a node from the Graph. 	 *  	 * @param node 	 *            the node to remove 	 * @return true if the node is removed from the Graph 	 */ 	public boolean removeNode(GraphNode node) { 		return nodes.remove(node); 	}  	/** 	 * Removes a subgraph from the Graph. 	 *  	 * @param subgraph 	 *            the subgraph to remove 	 * @return true if the subgraph is removed from the Graph 	 */ 	public boolean removeSubgraph(Graph subgraph) { 		return subgraphs.remove(subgraph); 	}  	/** 	 * Sets the alignment of the Graph. 	 *  	 * @param alignment 	 *            the new alignment 	 */ 	public void setAlignment(Alignment alignment) { 		this.alignment = alignment; 	} }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2890</td>
    <td align="left">https://github.com/apache/incubator-taverna-workbench/blob/2b74964ac1ee22e56c5dad3321869d84f7052dcf/taverna-graph-model/src/main/java/org/apache/taverna/workbench/models/graph/Graph.java/#L30-L161</td>
    <td align="right">1</td>
    <td align="right">269</td>
    <td align="right">2890</td>
  </tr>
  <tr valign="top">
    <td align="right">2184</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Blob&quot;,             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SuppressWarnings(&quot;serial&quot;) public class ObjectRetrievalFailureException extends DataRetrievalFailureException {  	@Nullable 	private final Object persistentClass;  	@Nullable 	private final Object identifier;   	/** 	 * Create a general ObjectRetrievalFailureException with the given message, 	 * without any information on the affected object. 	 * @param msg the detail message 	 * @param cause the source exception 	 */ 	public ObjectRetrievalFailureException(String msg, Throwable cause) { 		super(msg, cause); 		this.persistentClass = null; 		this.identifier = null; 	}  	/** 	 * Create a new ObjectRetrievalFailureException for the given object, 	 * with the default &quot;not found&quot; message. 	 * @param persistentClass the persistent class 	 * @param identifier the ID of the object that should have been retrieved 	 */ 	public ObjectRetrievalFailureException(Class persistentClass, Object identifier) { 		this(persistentClass, identifier, 				&quot;Object of class [&quot; + persistentClass.getName() + &quot;] with identifier [&quot; + identifier + &quot;]: not found&quot;, 				null); 	}  	/** 	 * Create a new ObjectRetrievalFailureException for the given object, 	 * with the given explicit message and exception. 	 * @param persistentClass the persistent class 	 * @param identifier the ID of the object that should have been retrieved 	 * @param msg the detail message 	 * @param cause the source exception 	 */ 	public ObjectRetrievalFailureException( 			Class persistentClass, Object identifier, String msg, @Nullable Throwable cause) {  		super(msg, cause); 		this.persistentClass = persistentClass; 		this.identifier = identifier; 	}  	/** 	 * Create a new ObjectRetrievalFailureException for the given object, 	 * with the default &quot;not found&quot; message. 	 * @param persistentClassName the name of the persistent class 	 * @param identifier the ID of the object that should have been retrieved 	 */ 	public ObjectRetrievalFailureException(String persistentClassName, Object identifier) { 		this(persistentClassName, identifier, 				&quot;Object of class [&quot; + persistentClassName + &quot;] with identifier [&quot; + identifier + &quot;]: not found&quot;, 				null); 	}  	/** 	 * Create a new ObjectRetrievalFailureException for the given object, 	 * with the given explicit message and exception. 	 * @param persistentClassName the name of the persistent class 	 * @param identifier the ID of the object that should have been retrieved 	 * @param msg the detail message 	 * @param cause the source exception 	 */ 	public ObjectRetrievalFailureException( 			String persistentClassName, Object identifier, String msg, @Nullable Throwable cause) {  		super(msg, cause); 		this.persistentClass = persistentClassName; 		this.identifier = identifier; 	}   	/** 	 * Return the persistent class of the object that was not found. 	 * If no Class was specified, this method returns null. 	 */ 	@Nullable 	public Class getPersistentClass() { 		return (this.persistentClass instanceof Class ? (Class) this.persistentClass : null); 	}  	/** 	 * Return the name of the persistent class of the object that was not found. 	 * Will work for both Class objects and String names. 	 */ 	@Nullable 	public String getPersistentClassName() { 		if (this.persistentClass instanceof Class) { 			return ((Class) this.persistentClass).getName(); 		} 		return (this.persistentClass != null ? this.persistentClass.toString() : null); 	}  	/** 	 * Return the identifier of the object that was not found. 	 */ 	@Nullable 	public Object getIdentifier() { 		return this.identifier; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13426</td>
    <td align="left">https://github.com/spring-projects/spring-framework/blob/3a0f309e2c9fdbbf7fb2d348be861528177f8555/spring-orm/src/main/java/org/springframework/orm/ObjectRetrievalFailureException.java/#L29-L137</td>
    <td align="right">1</td>
    <td align="right">2184</td>
    <td align="right">13426</td>
  </tr>
  <tr valign="top">
    <td align="right">140</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells the bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ElementImpl extends MinimalEObjectImpl.Container implements Element {   /**    * The default value of the '{@link #isA() A}' attribute.    *     *     * @see #isA()    * @generated    * @ordered    */   protected static final boolean A_EDEFAULT = false;    /**    * The cached value of the '{@link #isA() A}' attribute.    *     *     * @see #isA()    * @generated    * @ordered    */   protected boolean a = A_EDEFAULT;    /**    * The default value of the '{@link #getName() Name}' attribute.    *     *     * @see #getName()    * @generated    * @ordered    */   protected static final String NAME_EDEFAULT = null;    /**    * The cached value of the '{@link #getName() Name}' attribute.    *     *     * @see #getName()    * @generated    * @ordered    */   protected String name = NAME_EDEFAULT;    /**    * The cached value of the '{@link #getElements() Elements}' containment reference list.    *     *     * @see #getElements()    * @generated    * @ordered    */   protected EList elements;    /**    *     *     * @generated    */   protected ElementImpl()   {     super();   }    /**    *     *     * @generated    */   @Override   protected EClass eStaticClass()   {     return Bug305397Package.Literals.ELEMENT;   }    /**    *     *     * @generated    */   public boolean isA()   {     return a;   }    /**    *     *     * @generated    */   public void setA(boolean newA)   {     boolean oldA = a;     a = newA;     if (eNotificationRequired())       eNotify(new ENotificationImpl(this, Notification.SET, Bug305397Package.ELEMENT__A, oldA, a));   }    /**    *     *     * @generated    */   public String getName()   {     return name;   }    /**    *     *     * @generated    */   public void setName(String newName)   {     String oldName = name;     name = newName;     if (eNotificationRequired())       eNotify(new ENotificationImpl(this, Notification.SET, Bug305397Package.ELEMENT__NAME, oldName, name));   }    /**    *     *     * @generated    */   public EList getElements()   {     if (elements == null)     {       elements = new EObjectContainmentEList(Element.class, this, Bug305397Package.ELEMENT__ELEMENTS);     }     return elements;   }    /**    *     *     * @generated    */   @Override   public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)   {     switch (featureID)     {       case Bug305397Package.ELEMENT__ELEMENTS:         return ((InternalEList)getElements()).basicRemove(otherEnd, msgs);     }     return super.eInverseRemove(otherEnd, featureID, msgs);   }    /**    *     *     * @generated    */   @Override   public Object eGet(int featureID, boolean resolve, boolean coreType)   {     switch (featureID)     {       case Bug305397Package.ELEMENT__A:         return isA();       case Bug305397Package.ELEMENT__NAME:         return getName();       case Bug305397Package.ELEMENT__ELEMENTS:         return getElements();     }     return super.eGet(featureID, resolve, coreType);   }    /**    *     *     * @generated    */   @SuppressWarnings(&quot;unchecked&quot;)   @Override   public void eSet(int featureID, Object newValue)   {     switch (featureID)     {       case Bug305397Package.ELEMENT__A:         setA((Boolean)newValue);         return;       case Bug305397Package.ELEMENT__NAME:         setName((String)newValue);         return;       case Bug305397Package.ELEMENT__ELEMENTS:         getElements().clear();         getElements().addAll((Collection)newValue);         return;     }     super.eSet(featureID, newValue);   }    /**    *     *     * @generated    */   @Override   public void eUnset(int featureID)   {     switch (featureID)     {       case Bug305397Package.ELEMENT__A:         setA(A_EDEFAULT);         return;       case Bug305397Package.ELEMENT__NAME:         setName(NAME_EDEFAULT);         return;       case Bug305397Package.ELEMENT__ELEMENTS:         getElements().clear();         return;     }     super.eUnset(featureID);   }    /**    *     *     * @generated    */   @Override   public boolean eIsSet(int featureID)   {     switch (featureID)     {       case Bug305397Package.ELEMENT__A:         return a != A_EDEFAULT;       case Bug305397Package.ELEMENT__NAME:         return NAME_EDEFAULT == null ? name != null : !NAME_EDEFAULT.equals(name);       case Bug305397Package.ELEMENT__ELEMENTS:         return elements != null &amp;&amp; !elements.isEmpty();     }     return super.eIsSet(featureID);   }    /**    *     *     * @generated    */   @Override   public String toString()   {     if (eIsProxy()) return super.toString();      StringBuffer result = new StringBuffer(super.toString());     result.append(&quot; (a: &quot;);     result.append(a);     result.append(&quot;, name: &quot;);     result.append(name);     result.append(')');     return result.toString();   }  } //ElementImpl</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1770</td>
    <td align="left">https://github.com/eclipse/xtext-core/blob/e04964e4c2a3e0338c0079bd8333688835e77c31/org.eclipse.xtext.tests/src-gen/org/eclipse/xtext/parsetree/impl/bug305397/impl/ElementImpl.java/#L40-L296</td>
    <td align="right">1</td>
    <td align="right">140</td>
    <td align="right">1770</td>
  </tr>
  <tr valign="top">
    <td align="right">2052</td>
    <td align="left">{     &quot;YES I found bad smells&quot;: true,     &quot;the bad smells are&quot;: [         &quot;Long Method&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Mojo( name = &quot;check&quot;, defaultPhase = LifecyclePhase.VERIFY, requiresDependencyResolution = ResolutionScope.TEST,        threadSafe = true ) public class CheckstyleViolationCheckMojo     extends AbstractMojo {      private static final String JAVA_FILES = &quot;**\\/*.java&quot;;     private static final String DEFAULT_CONFIG_LOCATION = &quot;sun_checks.xml&quot;;      /**      * Specifies the path and filename to save the Checkstyle output. The format      * of the output file is determined by the outputFileFormat      * parameter.      */     @Parameter( property = &quot;checkstyle.output.file&quot;, defaultValue = &quot;${project.build.directory}/checkstyle-result.xml&quot; )     private File outputFile;      /**      * Specifies the format of the output to be used when writing to the output      * file. Valid values are &quot;plain&quot; and &quot;xml&quot;.      */     @Parameter( property = &quot;checkstyle.output.format&quot;, defaultValue = &quot;xml&quot; )     private String outputFileFormat;      /**      * Fail the build on a violation. The goal checks for the violations      * after logging them (if {@link #logViolationsToConsole} is {@code true}).      * Compare this to {@link #failsOnError} which fails the build immediately      * before examining the output log.      */     @Parameter( property = &quot;checkstyle.failOnViolation&quot;, defaultValue = &quot;true&quot; )     private boolean failOnViolation;      /**      * The maximum number of allowed violations. The execution fails only if the      * number of violations is above this limit.      *      * @since 2.3      */     @Parameter( property = &quot;checkstyle.maxAllowedViolations&quot;, defaultValue = &quot;0&quot; )     private int maxAllowedViolations;      /**      * The lowest severity level that is considered a violation.      * Valid values are &quot;error&quot;, &quot;warning&quot; and &quot;info&quot;.      *      * @since 2.2      */     @Parameter( property = &quot;checkstyle.violationSeverity&quot;, defaultValue = &quot;error&quot; )     private String violationSeverity = &quot;error&quot;;      /**      * Violations to ignore. This is a comma-separated list, each value being either      * a rule name, a rule category or a java package name of rule class.      *      * @since 2.13      */     @Parameter( property = &quot;checkstyle.violation.ignore&quot; )     private String violationIgnore;      /**      * Skip entire check.      *      * @since 2.2      */     @Parameter( property = &quot;checkstyle.skip&quot;, defaultValue = &quot;false&quot; )     private boolean skip;      /**      * Skip Checkstyle execution will only scan the outputFile.      *      * @since 2.5      */     @Parameter( property = &quot;checkstyle.skipExec&quot;, defaultValue = &quot;false&quot; )     private boolean skipExec;      /**      * Output the detected violations to the console.      *      * @since 2.3      */     @Parameter( property = &quot;checkstyle.console&quot;, defaultValue = &quot;true&quot; )     private boolean logViolationsToConsole;      /**      * Specifies the location of the resources to be used for Checkstyle.      *      * @since 2.11      */     @Parameter( defaultValue = &quot;${project.resources}&quot;, readonly = true )     protected List resources;          /**      * Specifies the location of the test resources to be used for Checkstyle.      *      * @since 2.16      */     @Parameter( defaultValue = &quot;${project.testResources}&quot;, readonly = true )     protected List testResources;      /**      *       * Specifies the location of the XML configuration to use.      *       * Potential values are a filesystem path, a URL, or a classpath resource.      * This parameter expects that the contents of the location conform to the      * xml format (Checkstyle Checker      * module) configuration of rulesets.      *       * This parameter is resolved as resource, URL, then file. If successfully      * resolved, the contents of the configuration is copied into the      * ${project.build.directory}/checkstyle-configuration.xml      * file before being passed to Checkstyle as a configuration.      *       * There are 2 predefined rulesets.      *       * sun_checks.xml: Sun Checks.      * google_checks.xml: Google Checks.      *       *      * @since 2.5      */     @Parameter( property = &quot;checkstyle.config.location&quot;, defaultValue = DEFAULT_CONFIG_LOCATION )     private String configLocation;      /**      *       * Specifies the location of the properties file.      *       * This parameter is resolved as URL, File then resource. If successfully      * resolved, the contents of the properties location is copied into the      * ${project.build.directory}/checkstyle-checker.properties      * file before being passed to Checkstyle for loading.      *       * The contents of the propertiesLocation will be made      * available to Checkstyle for specifying values for parameters within the      * xml configuration (specified in the configLocation      * parameter).      *      * @since 2.5      */     @Parameter( property = &quot;checkstyle.properties.location&quot; )     private String propertiesLocation;      /**      * Allows for specifying raw property expansion information.      */     @Parameter     private String propertyExpansion;      /**      *       * Specifies the location of the License file (a.k.a. the header file) that      * can be used by Checkstyle to verify that source code has the correct      * license header.      *       * You need to use ${checkstyle.header.file} in your Checkstyle xml      * configuration to reference the name of this header file.      *       * For instance:      *       * &lt;module name=&quot;RegexpHeader&quot;&gt;      *   &lt;property name=&quot;headerFile&quot; value=&quot;${checkstyle.header.file}&quot;/&gt;      * &lt;/module&gt;      *       *      * @since 2.0-beta-2      */     @Parameter( property = &quot;checkstyle.header.file&quot;, defaultValue = &quot;LICENSE.txt&quot; )     private String headerLocation;      /**      * Specifies the cache file used to speed up Checkstyle on successive runs.      */     @Parameter( defaultValue = &quot;${project.build.directory}/checkstyle-cachefile&quot; )     private String cacheFile;      /**      * The key to be used in the properties for the suppressions file.      *      * @since 2.1      */     @Parameter( property = &quot;checkstyle.suppression.expression&quot;, defaultValue = &quot;checkstyle.suppressions.file&quot; )     private String suppressionsFileExpression;      /**      *       * Specifies the location of the suppressions XML file to use.      *       * This parameter is resolved as resource, URL, then file. If successfully      * resolved, the contents of the suppressions XML is copied into the      * ${project.build.directory}/checkstyle-suppressions.xml file      * before being passed to Checkstyle for loading.      *       * See suppressionsFileExpression for the property that will      * be made available to your Checkstyle configuration.      *      * @since 2.0-beta-2      */     @Parameter( property = &quot;checkstyle.suppressions.location&quot; )     private String suppressionsLocation;      /**      * The file encoding to use when reading the source files. If the property project.build.sourceEncoding      * is not set, the platform default encoding is used. Note: This parameter always overrides the      * property charset from Checkstyle's TreeWalker module.      *      * @since 2.2      */     @Parameter( property = &quot;encoding&quot;, defaultValue = &quot;${project.build.sourceEncoding}&quot; )     private String encoding;      /**      * @since 2.5      */     @Component( role = CheckstyleExecutor.class, hint = &quot;default&quot; )     protected CheckstyleExecutor checkstyleExecutor;      /**      * Output errors to console.      */     @Parameter( property = &quot;checkstyle.consoleOutput&quot;, defaultValue = &quot;false&quot; )     private boolean consoleOutput;      /**      * The Maven Project Object.      */     @Parameter ( defaultValue = &quot;${project}&quot;, readonly = true, required = true )     protected MavenProject project;          /**      * The Plugin Descriptor      */     @Parameter( defaultValue = &quot;${plugin}&quot;, readonly = true, required = true )     private PluginDescriptor plugin;      /**      * If null, the Checkstyle plugin will display violations on stdout.      * Otherwise, a text file will be created with the violations.      */     @Parameter     private File useFile;      /**      * Specifies the names filter of the source files to be excluded for      * Checkstyle.      */     @Parameter( property = &quot;checkstyle.excludes&quot; )     private String excludes;      /**      * Specifies the names filter of the source files to be used for Checkstyle.      */     @Parameter( property = &quot;checkstyle.includes&quot;, defaultValue = JAVA_FILES, required = true )     private String includes;      /**      * Specifies the names filter of the files to be excluded for      * Checkstyle when checking resources.      * @since 2.11      */     @Parameter( property = &quot;checkstyle.resourceExcludes&quot; )     private String resourceExcludes;      /**      * Specifies the names filter of the files to be used for Checkstyle when checking resources.      * @since 2.11      */     @Parameter( property = &quot;checkstyle.resourceIncludes&quot;, defaultValue = &quot;**/*.properties&quot;, required = true )     private String resourceIncludes;      /**      * If this is true, and Checkstyle reported any violations or errors,      * the build fails immediately after running Checkstyle, before checking the log      * for {@link #logViolationsToConsole}. If you want to use {@link #logViolationsToConsole},      * use {@link #failOnViolation} instead of this.      */     @Parameter( defaultValue = &quot;false&quot; )     private boolean failsOnError;      /**      * Specifies the location of the test source directory to be used for Checkstyle.      *      * @since 2.2      * @deprecated instead use {@link #testSourceDirectories}. For version 3.0.0, this parameter is only defined to      *             break the build if you use it!      */     @Deprecated     @Parameter     private File testSourceDirectory;      /**      * Specifies the location of the test source directories to be used for Checkstyle.      * Default value is ${project.testCompileSourceRoots}.      * @since 2.13      */     // Compatibility with all Maven 3: default of 'project.testCompileSourceRoots' is done manually because of MNG-5440     @Parameter     private List testSourceDirectories;      /**      * Include or not the test source directory to be used for Checkstyle.      *      * @since 2.2      */     @Parameter( defaultValue = &quot;false&quot; )     private boolean includeTestSourceDirectory;      /**      * Specifies the location of the source directory to be used for Checkstyle.      *       * @deprecated instead use {@link #sourceDirectories}. For version 3.0.0, this parameter is only defined to break      *             the build if you use it!      */     @Deprecated     @Parameter     private File sourceDirectory;      /**      * Specifies the location of the source directories to be used for Checkstyle.      * Default value is ${project.compileSourceRoots}.      * @since 2.13      */     // Compatibility with all Maven 3: default of 'project.compileSourceRoots' is done manually because of MNG-5440     @Parameter     private List sourceDirectories;      /**      * Whether to apply Checkstyle to resource directories.      * @since 2.11      */     @Parameter( property = &quot;checkstyle.includeResources&quot;, defaultValue = &quot;true&quot;, required = true )     private boolean includeResources = true;      /**      * Whether to apply Checkstyle to test resource directories.      * @since 2.11      */     @Parameter( property = &quot;checkstyle.includeTestResources&quot;, defaultValue = &quot;true&quot;, required = true )     private boolean includeTestResources = true;      /**      * By using this property, you can specify the whole Checkstyle rules      * inline directly inside this pom.      *      *       * &lt;plugin&gt;      *   ...      *   &lt;configuration&gt;      *     &lt;checkstyleRules&gt;      *       &lt;module name=&quot;Checker&quot;&gt;      *         &lt;module name=&quot;FileTabCharacter&quot;&gt;      *           &lt;property name=&quot;eachLine&quot; value=&quot;true&quot; /&gt;      *         &lt;/module&gt;      *         &lt;module name=&quot;TreeWalker&quot;&gt;      *           &lt;module name=&quot;EmptyBlock&quot;/&gt;      *         &lt;/module&gt;      *       &lt;/module&gt;      *     &lt;/checkstyleRules&gt;      *   &lt;/configuration&gt;      *   ...      *       *      * @since 2.12      */     @Parameter     private PlexusConfiguration checkstyleRules;      /**      * Dump file for inlined Checkstyle rules.       */     @Parameter( property = &quot;checkstyle.output.rules.file&quot;,                     defaultValue = &quot;${project.build.directory}/checkstyle-rules.xml&quot; )     private File rulesFiles;      /**      * The header to use for the inline configuration.      * Only used when you specify {@code checkstyleRules}.      */     @Parameter( defaultValue = &quot;\n&quot;             + &quot;\n&quot; )     private String checkstyleRulesHeader;      /**      * Specifies whether modules with a configured severity of ignore should be omitted during Checkstyle      * invocation.      *       * @since 3.0.0      */     @Parameter( defaultValue = &quot;false&quot; )     private boolean omitIgnoredModules;      private ByteArrayOutputStream stringOutputStream;      private File outputXmlFile;      /** {@inheritDoc} */     public void execute()         throws MojoExecutionException, MojoFailureException     {         checkDeprecatedParameterUsage( sourceDirectory, &quot;sourceDirectory&quot;, &quot;sourceDirectories&quot; );         checkDeprecatedParameterUsage( testSourceDirectory, &quot;testSourceDirectory&quot;, &quot;testSourceDirectories&quot; );         if ( skip )         {             return;         }          outputXmlFile = outputFile;          if ( !skipExec )         {             if ( checkstyleRules != null )             {                 if ( !DEFAULT_CONFIG_LOCATION.equals( configLocation ) )                 {                     throw new MojoExecutionException( &quot;If you use inline configuration for rules, don't specify &quot;                         + &quot;a configLocation&quot; );                 }                 if ( checkstyleRules.getChildCount() &gt; 1 )                 {                     throw new MojoExecutionException( &quot;Currently only one root module is supported&quot; );                 }                  PlexusConfiguration checkerModule = checkstyleRules.getChild( 0 );                  try                 {                     FileUtils.forceMkdir( rulesFiles.getParentFile() );                     FileUtils.fileWrite( rulesFiles, checkstyleRulesHeader + checkerModule.toString() );                 }                 catch ( final IOException e )                 {                     throw new MojoExecutionException( e.getMessage(), e );                 }                 configLocation = rulesFiles.getAbsolutePath();             }              ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();              try             {                 CheckstyleExecutorRequest request = new CheckstyleExecutorRequest();                 request.setConsoleListener( getConsoleListener() ).setConsoleOutput( consoleOutput )                     .setExcludes( excludes ).setFailsOnError( failsOnError ).setIncludes( includes )                     .setResourceIncludes( resourceIncludes )                     .setResourceExcludes( resourceExcludes )                     .setIncludeResources( includeResources )                     .setIncludeTestResources( includeTestResources )                     .setIncludeTestSourceDirectory( includeTestSourceDirectory ).setListener( getListener() )                     .setProject( project ).setSourceDirectories( getSourceDirectories() )                     .setResources( resources ).setTestResources( testResources )                     .setStringOutputStream( stringOutputStream ).setSuppressionsLocation( suppressionsLocation )                     .setTestSourceDirectories( getTestSourceDirectories() ).setConfigLocation( configLocation )                     .setConfigurationArtifacts( collectArtifacts( &quot;config&quot; ) )                     .setPropertyExpansion( propertyExpansion )                     .setHeaderLocation( headerLocation ).setLicenseArtifacts( collectArtifacts( &quot;license&quot; ) )                     .setCacheFile( cacheFile ).setSuppressionsFileExpression( suppressionsFileExpression )                     .setEncoding( encoding ).setPropertiesLocation( propertiesLocation )                     .setOmitIgnoredModules( omitIgnoredModules );                 checkstyleExecutor.executeCheckstyle( request );              }             catch ( CheckstyleException e )             {                 throw new MojoExecutionException( &quot;Failed during checkstyle configuration&quot;, e );             }             catch ( CheckstyleExecutorException e )             {                 throw new MojoExecutionException( &quot;Failed during checkstyle execution&quot;, e );             }             finally             {                 //be sure to restore original context classloader                 Thread.currentThread().setContextClassLoader( currentClassLoader );             }         }          if ( !&quot;xml&quot;.equals( outputFileFormat ) &amp;&amp; skipExec )         {             throw new MojoExecutionException( &quot;Output format is '&quot; + outputFileFormat                 + &quot;', checkstyle:check requires format to be 'xml' when using skipExec.&quot; );         }          if ( !outputXmlFile.exists() )         {             getLog().info( &quot;Unable to perform checkstyle:check, unable to find checkstyle:checkstyle outputFile.&quot; );             return;         }          try ( Reader reader = new BufferedReader( ReaderFactory.newXmlReader( outputXmlFile ) ) )         {             XmlPullParser xpp = new MXParser();             xpp.setInput( reader );              int violations = countViolations( xpp );              if ( violations &gt; maxAllowedViolations )             {                 if ( failOnViolation )                 {                     String msg =                         &quot;You have &quot; + violations + &quot; Checkstyle violation&quot; + ( ( violations &gt; 1 ) ? &quot;s&quot; : &quot;&quot; ) + &quot;.&quot;;                     if ( maxAllowedViolations &gt; 0 )                     {                         msg += &quot; The maximum number of allowed violations is &quot; + maxAllowedViolations + &quot;.&quot;;                     }                     throw new MojoFailureException( msg );                 }                  getLog().warn( &quot;checkstyle:check violations detected but failOnViolation set to false&quot; );             }         }         catch ( IOException | XmlPullParserException e )         {             throw new MojoExecutionException( &quot;Unable to read Checkstyle results xml: &quot;                 + outputXmlFile.getAbsolutePath(), e );         }     }      private void checkDeprecatedParameterUsage( Object parameter, String name, String replacement )         throws MojoFailureException     {         if ( parameter != null )         {             throw new MojoFailureException( &quot;You are using '&quot; + name + &quot;' which has been removed&quot;                 + &quot; from the maven-checkstyle-plugin. &quot; + &quot;Please use '&quot; + replacement                 + &quot;' and refer to the &gt;&gt;Major Version Upgrade to version 3.0.0&lt;&lt; &quot; + &quot;on the plugin site.&quot; );         }     }      private int countViolations( XmlPullParser xpp )         throws XmlPullParserException, IOException     {         int count = 0;         int ignoreCount = 0;         List ignores = violationIgnore == null ? Collections.emptyList()                         : RuleUtil.parseMatchers( violationIgnore.split( &quot;,&quot; ) );          String basedir = project.getBasedir().getAbsolutePath();         String file = &quot;&quot;;         for ( int eventType = xpp.getEventType(); eventType != XmlPullParser.END_DOCUMENT; eventType = xpp.next() )         {             if ( eventType != XmlPullParser.START_TAG )             {                 continue;             }             else if ( &quot;file&quot;.equals( xpp.getName() ) )             {                 file = PathTool.getRelativeFilePath( basedir, xpp.getAttributeValue( &quot;&quot;, &quot;name&quot; ) );                 //file = file.substring( file.lastIndexOf( File.separatorChar ) + 1 );             }             else if ( &quot;error&quot;.equals( xpp.getName() ) )             {                 String severity = xpp.getAttributeValue( &quot;&quot;, &quot;severity&quot; );                  if ( !isViolation( severity ) )                 {                     continue;                 }                  String source = xpp.getAttributeValue( &quot;&quot;, &quot;source&quot; );                  if ( ignore( ignores, source ) )                 {                     ignoreCount++;                 }                 else                 {                     count++;                      if ( logViolationsToConsole )                     {                         String line = xpp.getAttributeValue( &quot;&quot;, &quot;line&quot; );                         String column = xpp.getAttributeValue( &quot;&quot;, &quot;column&quot; );                         String message = xpp.getAttributeValue( &quot;&quot;, &quot;message&quot; );                         String rule = RuleUtil.getName( source );                         String category = RuleUtil.getCategory( source );                          log( severity, file + &quot;:[&quot; + line + ( ( column == null ) ? &quot;&quot; : ( ',' + column ) ) + &quot;] (&quot;                             + category + &quot;) &quot; + rule + &quot;: &quot; + message );                     }                 }             }         }          if ( ignoreCount &gt; 0 )         {             getLog().info( &quot;Ignored &quot; + ignoreCount + &quot; error&quot; + ( ( ignoreCount &gt; 1 ) ? &quot;s&quot; : &quot;&quot; ) + &quot;, &quot; + count                                + &quot; violation&quot; + ( ( count &gt; 1 ) ? &quot;s&quot; : &quot;&quot; ) + &quot; remaining.&quot; );         }          return count;     }      private void log( String severity, String message )     {         if ( &quot;info&quot;.equals( severity ) )         {             getLog().info( message );         }         else if ( &quot;warning&quot;.equals( severity ) )         {             getLog().warn( message );         }         else         {             getLog().error( message );         }     }      /**      * Checks if the given severity is considered a violation.      *      * @param severity The severity to check      * @return true if the given severity is a violation, otherwise false      */     private boolean isViolation( String severity )     {         if ( &quot;error&quot;.equals( severity ) )         {             return &quot;error&quot;.equals( violationSeverity ) || &quot;warning&quot;.equals( violationSeverity )                 || &quot;info&quot;.equals( violationSeverity );         }         else if ( &quot;warning&quot;.equals( severity ) )         {             return &quot;warning&quot;.equals( violationSeverity ) || &quot;info&quot;.equals( violationSeverity );         }         else if ( &quot;info&quot;.equals( severity ) )         {             return &quot;info&quot;.equals( violationSeverity );         }         else         {             return false;         }     }      private boolean ignore( List ignores, String source )     {         for ( RuleUtil.Matcher ignore : ignores )         {             if ( ignore.match( source ) )             {                 return true;             }         }         return false;     }      private DefaultLogger getConsoleListener()         throws MojoExecutionException     {         DefaultLogger consoleListener;          if ( useFile == null )         {             stringOutputStream = new ByteArrayOutputStream();             consoleListener = new DefaultLogger( stringOutputStream, false );         }         else         {             OutputStream out = getOutputStream( useFile );              consoleListener = new DefaultLogger( out, true );         }          return consoleListener;     }      private OutputStream getOutputStream( File file )         throws MojoExecutionException     {         File parentFile = file.getAbsoluteFile().getParentFile();          if ( !parentFile.exists() )         {             parentFile.mkdirs();         }          FileOutputStream fileOutputStream;         try         {             fileOutputStream = new FileOutputStream( file );         }         catch ( FileNotFoundException e )         {             throw new MojoExecutionException( &quot;Unable to create output stream: &quot; + file, e );         }         return fileOutputStream;     }      private AuditListener getListener()         throws MojoFailureException, MojoExecutionException     {         AuditListener listener = null;          if ( StringUtils.isNotEmpty( outputFileFormat ) )         {             File resultFile = outputFile;              OutputStream out = getOutputStream( resultFile );              if ( &quot;xml&quot;.equals( outputFileFormat ) )             {                 listener = new XMLLogger( out, true );             }             else if ( &quot;plain&quot;.equals( outputFileFormat ) )             {                 try                 {                     // Write a plain output file to the standard output file,                     // and write an XML output file to the temp directory that can be used to count violations                     outputXmlFile = File.createTempFile( &quot;checkstyle-result&quot;, &quot;.xml&quot; );                     outputXmlFile.deleteOnExit();                     OutputStream xmlOut = getOutputStream( outputXmlFile );                     CompositeAuditListener compoundListener = new CompositeAuditListener();                     compoundListener.addListener( new XMLLogger( xmlOut, true ) );                     compoundListener.addListener( new DefaultLogger( out, true ) );                     listener = compoundListener;                 }                 catch ( IOException e )                 {                     throw new MojoExecutionException( &quot;Unable to create temporary file&quot;, e );                 }             }             else             {                 throw new MojoFailureException( &quot;Invalid output file format: (&quot; + outputFileFormat                     + &quot;). Must be 'plain' or 'xml'.&quot; );             }         }          return listener;     }          private List collectArtifacts( String hint )     {         List artifacts = new ArrayList&lt;&gt;();          PluginManagement pluginManagement = project.getBuild().getPluginManagement();         if ( pluginManagement != null )         {             artifacts.addAll( getCheckstylePluginDependenciesAsArtifacts( pluginManagement.getPluginsAsMap(), hint ) );         }          artifacts.addAll( getCheckstylePluginDependenciesAsArtifacts( project.getBuild().getPluginsAsMap(), hint ) );          return artifacts;     }      private List getCheckstylePluginDependenciesAsArtifacts( Map plugins, String hint )     {         List artifacts = new ArrayList&lt;&gt;();                  Plugin checkstylePlugin = plugins.get( plugin.getGroupId() + &quot;:&quot; + plugin.getArtifactId() );         if ( checkstylePlugin != null )         {             for ( Dependency dep : checkstylePlugin.getDependencies() )             {              // @todo if we can filter on hints, it should be done here...                 String depKey = dep.getGroupId() + &quot;:&quot; + dep.getArtifactId();                 artifacts.add( (Artifact) plugin.getArtifactMap().get( depKey ) );             }         }         return artifacts;     }          private List getSourceDirectories()     {         if ( sourceDirectories == null )         {             sourceDirectories = project.getCompileSourceRoots();         }         List sourceDirs = new ArrayList&lt;&gt;( sourceDirectories.size() );         for ( String sourceDir : sourceDirectories )         {             sourceDirs.add( FileUtils.resolveFile( project.getBasedir(), sourceDir ) );         }         return sourceDirs;     }          private List getTestSourceDirectories()     {         if ( testSourceDirectories == null )         {             testSourceDirectories = project.getTestCompileSourceRoots();         }         List testSourceDirs = new ArrayList&lt;&gt;( testSourceDirectories.size() );         for ( String testSourceDir : testSourceDirectories )         {             testSourceDirs.add( FileUtils.resolveFile( project.getBasedir(), testSourceDir ) );         }         return testSourceDirs;     }      }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12902</td>
    <td align="left">https://github.com/apache/maven-checkstyle-plugin/blob/eee0ba18a70e6d6bd51797c70a83cf844f882286/src/main/java/org/apache/maven/plugins/checkstyle/CheckstyleViolationCheckMojo.java/#L75-L872</td>
    <td align="right">1</td>
    <td align="right">2052</td>
    <td align="right">12902</td>
  </tr>
  <tr valign="top">
    <td align="right">1527</td>
    <td align="left">&nbsp;{        &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SuppressWarnings(&quot;serial&quot;) public abstract class MqttMessageDeliveryEvent extends MqttIntegrationEvent {  	private final int messageId;  	private final String clientId;  	private final int clientInstance;  	public MqttMessageDeliveryEvent(Object source, int messageId, String clientId, int clientInstance) { 		super(source); 		this.messageId = messageId; 		this.clientId = clientId; 		this.clientInstance = clientInstance; 	}  	public int getMessageId() { 		return this.messageId; 	}  	public String getClientId() { 		return this.clientId; 	}  	public int getClientInstance() { 		return this.clientInstance; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11193</td>
    <td align="left">https://github.com/spring-projects/spring-integration/blob/872302de6e98c1fd34e3192d8e4de244008ca857/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/event/MqttMessageDeliveryEvent.java/#L28-L56</td>
    <td align="right">1</td>
    <td align="right">1527</td>
    <td align="right">11193</td>
  </tr>
  <tr valign="top">
    <td align="right">1123</td>
    <td align="left">&nbsp;{&quot;answer&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ExtendedCompletionList {   private boolean inComplete;   private List items;    public ExtendedCompletionList(boolean incomplete, List items) {     this.inComplete = incomplete;     this.items = items;   }    public ExtendedCompletionList() {}    public List getItems() {     return items;   }    public void setItems(List items) {     this.items = items;   }    public boolean isInComplete() {     return inComplete;   }    public void setInComplete(boolean inComplete) {     this.inComplete = inComplete;   } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9994</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/wsagent/che-core-api-languageserver-shared/src/main/java/org/eclipse/che/api/languageserver/shared/model/ExtendedCompletionList.java/#L22-L48</td>
    <td align="right">1</td>
    <td align="right">1123</td>
    <td align="right">9994</td>
  </tr>
  <tr valign="top">
    <td align="right">1601</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  static class OfflineIteratorEnvironment implements IteratorEnvironment {      private final Authorizations authorizations;     private AccumuloConfiguration conf;     private boolean useSample;     private SamplerConfiguration sampleConf;      public OfflineIteratorEnvironment(Authorizations auths, AccumuloConfiguration acuTableConf,         boolean useSample, SamplerConfiguration samplerConf) {       this.authorizations = auths;       this.conf = acuTableConf;       this.useSample = useSample;       this.sampleConf = samplerConf;     }      @Deprecated     @Override     public AccumuloConfiguration getConfig() {       return conf;     }      @Override     public IteratorScope getIteratorScope() {       return IteratorScope.scan;     }      @Override     public boolean isFullMajorCompaction() {       return false;     }      @Override     public boolean isUserCompaction() {       return false;     }      private ArrayList&gt; topLevelIterators = new ArrayList&lt;&gt;();      @Deprecated     @Override     public void registerSideChannel(SortedKeyValueIterator iter) {       topLevelIterators.add(iter);     }      @Override     public Authorizations getAuthorizations() {       return authorizations;     }      SortedKeyValueIterator getTopLevelIterator(SortedKeyValueIterator iter) {       if (topLevelIterators.isEmpty())         return iter;       ArrayList&gt; allIters = new ArrayList&lt;&gt;(topLevelIterators);       allIters.add(iter);       return new MultiIterator(allIters, false);     }      @Override     public boolean isSamplingEnabled() {       return useSample;     }      @Override     public SamplerConfiguration getSamplerConfiguration() {       return sampleConf;     }      @Override     public IteratorEnvironment cloneWithSamplingEnabled() {       if (sampleConf == null)         throw new SampleNotPresentException();       return new OfflineIteratorEnvironment(authorizations, conf, true, sampleConf);     }   }</td>
    <td align="left">data class</td>
    <td align="left">Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11429</td>
    <td align="left">https://github.com/apache/accumulo/blob/f896c98c2356a52dfa2235d2cc02ae556ab17909/core/src/main/java/org/apache/accumulo/core/clientImpl/OfflineIterator.java/#L70-L143</td>
    <td align="right">1</td>
    <td align="right">1601</td>
    <td align="right">11429</td>
  </tr>
  <tr valign="top">
    <td align="right">71</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;output&quot;: &quot;YES, I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class XPathConstants {      /**      * Private constructor to prevent instantiation.      */     private XPathConstants() { }      /**      * The XPath 1.0 number data type.      *      * Maps to Java {@link Double}.      */     public static final QName NUMBER = new QName(&quot;http://www.w3.org/1999/XSL/Transform&quot;, &quot;NUMBER&quot;);      /**      * The XPath 1.0 string data type.      *      * Maps to Java {@link String}.      */     public static final QName STRING = new QName(&quot;http://www.w3.org/1999/XSL/Transform&quot;, &quot;STRING&quot;);      /**      * The XPath 1.0 boolean data type.      *      * Maps to Java {@link Boolean}.      */     public static final QName BOOLEAN = new QName(&quot;http://www.w3.org/1999/XSL/Transform&quot;, &quot;BOOLEAN&quot;);      /**      * The XPath 1.0 NodeSet data type.      *      * Maps to Java {@link org.w3c.dom.NodeList}.      */     public static final QName NODESET = new QName(&quot;http://www.w3.org/1999/XSL/Transform&quot;, &quot;NODESET&quot;);      /**      * The XPath 1.0 NodeSet data type.      *      * Maps to Java {@link org.w3c.dom.Node}.      */     public static final QName NODE = new QName(&quot;http://www.w3.org/1999/XSL/Transform&quot;, &quot;NODE&quot;);      /**      * The URI for the DOM object model, &quot;http://java.sun.com/jaxp/xpath/dom&quot;.      */     public static final String DOM_OBJECT_MODEL = &quot;http://java.sun.com/jaxp/xpath/dom&quot;; }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1103</td>
    <td align="left">https://github.com/google/j2objc/blob/471504a735b48d5d4ace51afa1542cc4790a921a/jre_emul/android/platform/libcore/luni/src/main/java/javax/xml/xpath/XPathConstants.java/#L32-L78</td>
    <td align="right">1</td>
    <td align="right">71</td>
    <td align="right">1103</td>
  </tr>
  <tr valign="top">
    <td align="right">2373</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;output&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             &quot;Long Method&quot;,             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ActionNamesAction extends ActionSupport {      private static final long serialVersionUID = -5389385242431387840L;      private Set actionNames;     private String namespace = &quot;&quot;;     private Set namespaces;     private String extension;      protected ConfigurationHelper configHelper;      @Inject     public void setConfigurationHelper(ConfigurationHelper cfg) {         this.configHelper = cfg;     }      public Set getActionNames() {         return actionNames;     }      public String getNamespace() {         return StringEscapeUtils.escapeHtml4(namespace);     }      public void setNamespace(String namespace) {         this.namespace = namespace;     }      @Inject(StrutsConstants.STRUTS_ACTION_EXTENSION)     public void setExtension(String ext) {         this.extension = ext;     }      public ActionConfig getConfig(String actionName) {         return configHelper.getActionConfig(namespace, actionName);     }      public Set getNamespaces() {         return namespaces;     }      public String getExtension() {         if (extension == null) {             return &quot;action&quot;;         }         if (extension.contains(&quot;,&quot;)) {             return extension.substring(0, extension.indexOf(&quot;,&quot;));         }         return extension;     }      public String execute() throws Exception {         namespaces = configHelper.getNamespaces();         if (namespaces.size() == 0) {             addActionError(&quot;There are no namespaces in this configuration&quot;);             return ERROR;         }         if (namespace == null) {             namespace = &quot;&quot;;         }         actionNames = new TreeSet(configHelper.getActionNames(namespace));         return SUCCESS;     }      /**      * Index action to support cooperation with REST plugin      *      * @return action result      * @throws Exception      */     public String index() throws Exception {         return execute();     }      public String redirect() {         return SUCCESS;     }  }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14312</td>
    <td align="left">https://github.com/apache/struts/blob/e82c5a207f62fdb1bb6e8da690325b5a109c924f/plugins/config-browser/src/main/java/org/apache/struts2/config_browser/ActionNamesAction.java/#L33-L111</td>
    <td align="right">1</td>
    <td align="right">2373</td>
    <td align="right">14312</td>
  </tr>
  <tr valign="top">
    <td align="right">751</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class JavaTimeSupplementary_es_AR extends OpenListResourceBundle {     @Override     protected final Object[][] getContents() {         final String[] sharedAmPmMarkers = {             &quot;a.m.&quot;,             &quot;p.m.&quot;,         };          final String[] sharedDatePatterns = {             &quot;GGGG y MMMM d, EEEE&quot;,             &quot;GGGG y MMMM d&quot;,             &quot;GGGG y MMM d&quot;,             &quot;dd/MM/yy G&quot;,         };          final String[] sharedDayNarrows = {             &quot;d&quot;,             &quot;l&quot;,             &quot;m&quot;,             &quot;m&quot;,             &quot;j&quot;,             &quot;v&quot;,             &quot;s&quot;,         };          final String[] sharedTimePatterns = {             &quot;HH:mm:ss zzzz&quot;,             &quot;HH:mm:ss z&quot;,             &quot;HH:mm:ss&quot;,             &quot;HH:mm&quot;,         };          final String[] sharedJavaTimeDatePatterns = {             &quot;G y MMMM d, EEEE&quot;,             &quot;G y MMMM d&quot;,             &quot;G y MMM d&quot;,             &quot;dd/MM/yy GGGGG&quot;,         };          return new Object[][] {             { &quot;field.dayperiod&quot;,                 &quot;a.m./p.m.&quot; },             { &quot;islamic.AmPmMarkers&quot;,                 sharedAmPmMarkers },             { &quot;islamic.DatePatterns&quot;,                 sharedDatePatterns },             { &quot;islamic.DayNarrows&quot;,                 sharedDayNarrows },             { &quot;islamic.TimePatterns&quot;,                 sharedTimePatterns },             { &quot;islamic.abbreviated.AmPmMarkers&quot;,                 sharedAmPmMarkers },             { &quot;islamic.narrow.AmPmMarkers&quot;,                 sharedAmPmMarkers },             { &quot;java.time.buddhist.DatePatterns&quot;,                 sharedJavaTimeDatePatterns },             { &quot;java.time.islamic.DatePatterns&quot;,                 sharedJavaTimeDatePatterns },             { &quot;java.time.roc.DatePatterns&quot;,                 sharedJavaTimeDatePatterns },             { &quot;roc.AmPmMarkers&quot;,                 sharedAmPmMarkers },             { &quot;roc.DatePatterns&quot;,                 sharedDatePatterns },             { &quot;roc.DayNarrows&quot;,                 sharedDayNarrows },             { &quot;roc.MonthAbbreviations&quot;,                 new String[] {                     &quot;ene.&quot;,                     &quot;feb.&quot;,                     &quot;mar.&quot;,                     &quot;abr.&quot;,                     &quot;may.&quot;,                     &quot;jun.&quot;,                     &quot;jul.&quot;,                     &quot;ago.&quot;,                     &quot;sep.&quot;,                     &quot;oct.&quot;,                     &quot;nov.&quot;,                     &quot;dic.&quot;,                     &quot;&quot;,                 }             },             { &quot;roc.MonthNarrows&quot;,                 new String[] {                     &quot;e&quot;,                     &quot;f&quot;,                     &quot;m&quot;,                     &quot;a&quot;,                     &quot;m&quot;,                     &quot;j&quot;,                     &quot;j&quot;,                     &quot;a&quot;,                     &quot;s&quot;,                     &quot;o&quot;,                     &quot;n&quot;,                     &quot;d&quot;,                     &quot;&quot;,                 }             },             { &quot;roc.TimePatterns&quot;,                 sharedTimePatterns },             { &quot;roc.abbreviated.AmPmMarkers&quot;,                 sharedAmPmMarkers },             { &quot;roc.narrow.AmPmMarkers&quot;,                 sharedAmPmMarkers },         };     } }</td>
    <td align="left">data class</td>
    <td align="left">long method, blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method,  blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7030</td>
    <td align="left">https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/jdk.localedata/share/classes/sun/text/resources/ext/JavaTimeSupplementary_es_AR.java/#L72-L180</td>
    <td align="right">1</td>
    <td align="right">751</td>
    <td align="right">7030</td>
  </tr>
  <tr valign="top">
    <td align="right">501</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;response&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             &quot;Feature Envy&quot;,             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@JacksonXmlRootElement @JsonIgnoreProperties(ignoreUnknown = true) public class User implements Serializable {      private static final long serialVersionUID = 4247427179764560935L;      private Integer id;     private String username;     private String name;     @JsonProperty(&quot;first_name&quot;)     private String firstName;     @JsonProperty(&quot;last_name&quot;)     private String lastName;     private String email;     private String url;     private String description;     private String link;     private String locale;     private String nickname;     private String slug;     @JsonProperty(&quot;registered_date&quot;)     private String registeredDate;     private List roles;     private Map capabilities;     @JsonProperty(&quot;extra_capabilities&quot;)     private Map extraCapabilities;     @JsonProperty(&quot;avatar_urls&quot;)     private Map avatarUrls;     @JsonProperty(&quot;meta&quot;)     private List&gt; meta;      public User() {      }      public Integer getId() {         return id;     }      public void setId(Integer id) {         this.id = id;     }      public String getUsername() {         return username;     }      public void setUsername(String username) {         this.username = username;     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public String getFirstName() {         return firstName;     }      public void setFirstName(String firstName) {         this.firstName = firstName;     }      public String getLastName() {         return lastName;     }      public void setLastName(String lastName) {         this.lastName = lastName;     }      public String getEmail() {         return email;     }      public void setEmail(String email) {         this.email = email;     }      public String getUrl() {         return url;     }      public void setUrl(String url) {         this.url = url;     }      public String getDescription() {         return description;     }      public void setDescription(String description) {         this.description = description;     }      public String getLink() {         return link;     }      public void setLink(String link) {         this.link = link;     }      public String getLocale() {         return locale;     }      public void setLocale(String locale) {         this.locale = locale;     }      public String getNickname() {         return nickname;     }      public void setNickname(String nickname) {         this.nickname = nickname;     }      public String getSlug() {         return slug;     }      public void setSlug(String slug) {         this.slug = slug;     }      public String getRegisteredDate() {         return registeredDate;     }      public void setRegisteredDate(String registeredDate) {         this.registeredDate = registeredDate;     }      public List getRoles() {         return roles;     }      public void setRoles(List roles) {         this.roles = roles;     }      public Map getCapabilities() {         return capabilities;     }      public void setCapabilities(Map capabilities) {         this.capabilities = capabilities;     }      public Map getExtraCapabilities() {         return extraCapabilities;     }      public void setExtraCapabilities(Map extraCapabilities) {         this.extraCapabilities = extraCapabilities;     }      public Map getAvatarUrls() {         return avatarUrls;     }      public void setAvatarUrls(Map avatarUrls) {         this.avatarUrls = avatarUrls;     }      public List&gt; getMeta() {         return meta;     }      public void setMeta(List&gt; meta) {         this.meta = meta;     }      @Override     public String toString() {         return toStringHelper(this).addValue(this.id).addValue(this.username).addValue(this.email).addValue(this.name).toString();     }  }</td>
    <td align="left">data class</td>
    <td align="left">feature envy, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">feature envy</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">5079</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-wordpress/src/main/java/org/apache/camel/component/wordpress/api/model/User.java/#L29-L213</td>
    <td align="right">1</td>
    <td align="right">501</td>
    <td align="right">5079</td>
  </tr>
  <tr valign="top">
    <td align="right">1941</td>
    <td align="left">&nbsp;&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;1. Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ElementImpl extends MinimalEObjectImpl.Container implements Element {   /**    * The default value of the '{@link #isA() A}' attribute.    *     *     * @see #isA()    * @generated    * @ordered    */   protected static final boolean A_EDEFAULT = false;    /**    * The cached value of the '{@link #isA() A}' attribute.    *     *     * @see #isA()    * @generated    * @ordered    */   protected boolean a = A_EDEFAULT;    /**    * The default value of the '{@link #getName() Name}' attribute.    *     *     * @see #getName()    * @generated    * @ordered    */   protected static final String NAME_EDEFAULT = null;    /**    * The cached value of the '{@link #getName() Name}' attribute.    *     *     * @see #getName()    * @generated    * @ordered    */   protected String name = NAME_EDEFAULT;    /**    * The cached value of the '{@link #getElements() Elements}' containment reference list.    *     *     * @see #getElements()    * @generated    * @ordered    */   protected EList elements;    /**    *     *     * @generated    */   protected ElementImpl()   {     super();   }    /**    *     *     * @generated    */   @Override   protected EClass eStaticClass()   {     return Bug305397Package.Literals.ELEMENT;   }    /**    *     *     * @generated    */   public boolean isA()   {     return a;   }    /**    *     *     * @generated    */   public void setA(boolean newA)   {     boolean oldA = a;     a = newA;     if (eNotificationRequired())       eNotify(new ENotificationImpl(this, Notification.SET, Bug305397Package.ELEMENT__A, oldA, a));   }    /**    *     *     * @generated    */   public String getName()   {     return name;   }    /**    *     *     * @generated    */   public void setName(String newName)   {     String oldName = name;     name = newName;     if (eNotificationRequired())       eNotify(new ENotificationImpl(this, Notification.SET, Bug305397Package.ELEMENT__NAME, oldName, name));   }    /**    *     *     * @generated    */   public EList getElements()   {     if (elements == null)     {       elements = new EObjectContainmentEList(Element.class, this, Bug305397Package.ELEMENT__ELEMENTS);     }     return elements;   }    /**    *     *     * @generated    */   @Override   public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)   {     switch (featureID)     {       case Bug305397Package.ELEMENT__ELEMENTS:         return ((InternalEList)getElements()).basicRemove(otherEnd, msgs);     }     return super.eInverseRemove(otherEnd, featureID, msgs);   }    /**    *     *     * @generated    */   @Override   public Object eGet(int featureID, boolean resolve, boolean coreType)   {     switch (featureID)     {       case Bug305397Package.ELEMENT__A:         return isA();       case Bug305397Package.ELEMENT__NAME:         return getName();       case Bug305397Package.ELEMENT__ELEMENTS:         return getElements();     }     return super.eGet(featureID, resolve, coreType);   }    /**    *     *     * @generated    */   @SuppressWarnings(&quot;unchecked&quot;)   @Override   public void eSet(int featureID, Object newValue)   {     switch (featureID)     {       case Bug305397Package.ELEMENT__A:         setA((Boolean)newValue);         return;       case Bug305397Package.ELEMENT__NAME:         setName((String)newValue);         return;       case Bug305397Package.ELEMENT__ELEMENTS:         getElements().clear();         getElements().addAll((Collection)newValue);         return;     }     super.eSet(featureID, newValue);   }    /**    *     *     * @generated    */   @Override   public void eUnset(int featureID)   {     switch (featureID)     {       case Bug305397Package.ELEMENT__A:         setA(A_EDEFAULT);         return;       case Bug305397Package.ELEMENT__NAME:         setName(NAME_EDEFAULT);         return;       case Bug305397Package.ELEMENT__ELEMENTS:         getElements().clear();         return;     }     super.eUnset(featureID);   }    /**    *     *     * @generated    */   @Override   public boolean eIsSet(int featureID)   {     switch (featureID)     {       case Bug305397Package.ELEMENT__A:         return a != A_EDEFAULT;       case Bug305397Package.ELEMENT__NAME:         return NAME_EDEFAULT == null ? name != null : !NAME_EDEFAULT.equals(name);       case Bug305397Package.ELEMENT__ELEMENTS:         return elements != null &amp;&amp; !elements.isEmpty();     }     return super.eIsSet(featureID);   }    /**    *     *     * @generated    */   @Override   public String toString()   {     if (eIsProxy()) return super.toString();      StringBuffer result = new StringBuffer(super.toString());     result.append(&quot; (a: &quot;);     result.append(a);     result.append(&quot;, name: &quot;);     result.append(name);     result.append(')');     return result.toString();   }  } //ElementImpl</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">&nbsp; </td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">12485</td>
    <td align="left">https://github.com/eclipse/xtext-core/blob/e04964e4c2a3e0338c0079bd8333688835e77c31/org.eclipse.xtext.tests/src-gen/org/eclipse/xtext/parsetree/impl/bug305397/impl/ElementImpl.java/#L40-L296</td>
    <td align="right">1</td>
    <td align="right">1941</td>
    <td align="right">12485</td>
  </tr>
  <tr valign="top">
    <td align="right">2467</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
        final int v1;         final int v2;         ModifierOp(int type, int v1, int v2) {             super(type);             this.v1 = v1;             this.v2 = v2;         }         int getData() {             return this.v1;         }         int getData2() {             return this.v2;         }     }     // ================================================================</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14568</td>
    <td align="left">https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xpath/regex/Op.java/#L204-L218</td>
    <td align="right">1</td>
    <td align="right">2467</td>
    <td align="right">14568</td>
  </tr>
  <tr valign="top">
    <td align="right">101</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells the bad smells are:&quot;, &quot;detected_bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	private static class CountPageable implements Pageable {  		private Pageable delegate;  		public CountPageable(Pageable delegate) { 			this.delegate = delegate; 		}  		public int getPageNumber() { 			return delegate.getPageNumber(); 		}  		public int getPageSize() { 			return delegate.getPageSize(); 		}  		public long getOffset() { 			return delegate.getOffset(); 		}  		public Sort getSort() { 		  // Sorting is not allowed on aggregate count queries. 			return Sort.unsorted(); 		}  		public Pageable next() { 			return delegate.next(); 		}  		public Pageable previousOrFirst() { 			return delegate.previousOrFirst(); 		}  		public Pageable first() { 			return delegate.first(); 		}  		public boolean hasPrevious() { 			return delegate.hasPrevious(); 		}  	}</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1307</td>
    <td align="left">https://github.com/spring-projects/spring-data-couchbase/blob/2f4500e9c76541bbbd6a612f7b9283d2455a2dc6/src/main/java/org/springframework/data/couchbase/repository/query/N1qlCountQueryCreator.java/#L83-L124</td>
    <td align="right">1</td>
    <td align="right">101</td>
    <td align="right">1307</td>
  </tr>
  <tr valign="top">
    <td align="right">362</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Listener(clustered = false, sync = false) public class InfinispanAsyncLocalEventListener extends InfinispanSyncLocalEventListener {     public InfinispanAsyncLocalEventListener(InfinispanConsumer consumer, Set eventTypes) {         super(consumer, eventTypes);     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3707</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-infinispan/src/main/java/org/apache/camel/component/infinispan/embedded/InfinispanAsyncLocalEventListener.java/#L24-L29</td>
    <td align="right">1</td>
    <td align="right">362</td>
    <td align="right">3707</td>
  </tr>
  <tr valign="top">
    <td align="right">296</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class BaseClassInfo {     //~ Instance fields ----------------------------------------------------------------------------------------------------------      protected String name;     protected String nameAndLoader; // A combinarion of class name and loader, uniquely identifying this ClassInfo      // Management of multiple versions for the same-named (but possibly not same-code) class, loaded by different classloaders     protected int classLoaderId; // IDs of all loaders with which versions of this class are loaded      // Data used by our object allocation instrumentation mechanism: integer class ID     private int instrClassId;      //~ Constructors -------------------------------------------------------------------------------------------------------------      public BaseClassInfo(String className, int classLoaderId) {         this.name = className.intern();         this.classLoaderId = classLoaderId;         nameAndLoader = (name + &quot;#&quot; + classLoaderId).intern(); // NOI18N         instrClassId = -1;     }      //~ Methods ------------------------------------------------------------------------------------------------------------------      public void setInstrClassId(int id) {         instrClassId = id;     }      public int getInstrClassId() {         return instrClassId;     }      public void setLoaderId(int loaderId) {         classLoaderId = loaderId;     }      public int getLoaderId() {         return classLoaderId;     }      public String getName() {         return name;     }      public String getNameAndLoader() {         return nameAndLoader;     }      public String toString() {         return name;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3115</td>
    <td align="left">https://github.com/oracle/visualvm/blob/d9b10575b53d535e10c6e8c41831ebe38483c65b/visualvm/libs.profiler/lib.profiler/src/org/graalvm/visualvm/lib/jfluid/classfile/BaseClassInfo.java/#L53-L103</td>
    <td align="right">1</td>
    <td align="right">296</td>
    <td align="right">3115</td>
  </tr>
  <tr valign="top">
    <td align="right">2634</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{       &quot;response&quot;: &quot;YES I found bad smells&quot;,       &quot;bad smells are&quot;: [&quot;Data Class&quot;]    }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
class FloatFilterFunction extends AbstractFloatValue {   private final FloatValue baseExpr;   private final BooleanValue filterExpr;   public static final String name = FilterFunction.name;   private final String exprStr;   private final ExpressionType funcType;      public FloatFilterFunction(FloatValue baseExpr, BooleanValue filterExpr) throws SolrException {     this.baseExpr = baseExpr;     this.filterExpr = filterExpr;     this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);     this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);   }      boolean exists = false;    @Override   public float getFloat() {     float value = baseExpr.getFloat();     exists = baseExpr.exists() &amp;&amp; filterExpr.getBoolean() &amp;&amp; filterExpr.exists();     return value;   }   @Override   public boolean exists() {     return exists;   }      @Override   public String getName() {     return name;   }   @Override   public String getExpressionStr() {     return exprStr;   }   @Override   public ExpressionType getExpressionType() {     return funcType;   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15114</td>
    <td align="left">https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/FilterFunction.java/#L462-L501</td>
    <td align="right">1</td>
    <td align="right">2634</td>
    <td align="right">15114</td>
  </tr>
  <tr valign="top">
    <td align="right">2348</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class AvroWrapper {   private T datum;    /** Wrap null. Construct {@link AvroWrapper} wrapping no datum. */   public AvroWrapper() { this(null); }    /** Wrap a datum. */   public AvroWrapper(T datum) { this.datum = datum; }    /** Return the wrapped datum. */   public T datum() { return datum; }    /** Set the wrapped datum. */   public void datum(T datum) { this.datum = datum; }    @Override   public int hashCode() {     return (datum == null) ? 0 : datum.hashCode();   }    @Override   public boolean equals(Object obj) {     if (this == obj)       return true;     if (obj == null)       return false;     if (getClass() != obj.getClass())       return false;     AvroWrapper that = (AvroWrapper)obj;     if (this.datum == null) {       return that.datum == null;     } else return datum.equals(that.datum);   }    /** Get the wrapped datum as JSON. */   @Override   public String toString() {     return datum.toString();   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14198</td>
    <td align="left">https://github.com/apache/avro/blob/1119b6eb5b92730b27e9798793bc67f192591c15/lang/java/mapred/src/main/java/org/apache/avro/mapred/AvroWrapper.java/#L22-L61</td>
    <td align="right">1</td>
    <td align="right">2348</td>
    <td align="right">14198</td>
  </tr>
  <tr valign="top">
    <td align="right">1304</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;answer&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             &quot;1. Long Method&quot;,             &quot;2. Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LockMode extends TypesafeEnum {     private LockMode(final int value) {         super(value);     }      /**      * Do not perform any locking. Items are opened for read or write without      * regard to concurrent access by other processes.      */     public static final LockMode NONE = new LockMode(0);      /**      * Wait forever to acquire the lock (or until the thread is interrupted).      */     public static final LockMode WAIT_FOREVER = new LockMode(1);      /**      * Attempt to acquire the lock but return immediately if it could not be      * acquired.      */     public static final LockMode NO_WAIT = new LockMode(2); }</td>
    <td align="left">data class</td>
    <td align="left">1. long method, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10672</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core/src/com/microsoft/tfs/core/persistence/LockMode.java/#L15-L36</td>
    <td align="right">1</td>
    <td align="right">1304</td>
    <td align="right">10672</td>
  </tr>
  <tr valign="top">
    <td align="right">2366</td>
    <td align="left">&nbsp;&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Named @RequestScoped public class UserUpdateBean {     private String name;          private String surname;          private int age;          private String userName;          private String password;          private @Inject @Default UserController controller;          private @Inject @Default SessionTracker tracker;          public UserUpdateBean()     {              }      public String showInfo()     {         //Just show how can access session webbeans         User user = this.controller.getUser(tracker.getUser().getId());                  setName(user.getName());         setSurname(user.getSurname());         setAge(user.getAge());         setUserName(user.getUserName());         setPassword(user.getPassword());                          return &quot;toUpdatePage&quot;;     }      public String clear()     {         setName(&quot;&quot;);         setSurname(&quot;&quot;);         setAge(0);         setUserName(&quot;&quot;);         setPassword(&quot;&quot;);                  return null;     }          public String update()     {         this.controller.updateUserInfo(tracker.getUser().getId(), name, surname, age, userName, password);                  JSFUtility.addInfoMessage(&quot;Personal information is succesfully updated.&quot;, &quot;&quot;);                  return null;     }          /**      * @return the name      */     public String getName()     {         return name;     }      /**      * @param name the name to set      */     public void setName(String name)     {         this.name = name;     }      /**      * @return the surname      */     public String getSurname()     {         return surname;     }      /**      * @param surname the surname to set      */     public void setSurname(String surname)     {         this.surname = surname;     }      /**      * @return the age      */     public int getAge()     {         return age;     }      /**      * @param age the age to set      */     public void setAge(int age)     {         this.age = age;     }      /**      * @return the userName      */     public String getUserName()     {         return userName;     }      /**      * @param userName the userName to set      */     public void setUserName(String userName)     {         this.userName = userName;     }      /**      * @return the password      */     public String getPassword()     {         return password;     }      /**      * @param password the password to set      */     public void setPassword(String password)     {         this.password = password;     }           }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14296</td>
    <td align="left">https://github.com/apache/openwebbeans/blob/7831798861478a035c9e9dcca151b5a67e4a28a3/samples/reservation/src/main/java/org/apache/webbeans/reservation/beans/user/UserUpdateBean.java/#L31-L169</td>
    <td align="right">1</td>
    <td align="right">2366</td>
    <td align="right">14296</td>
  </tr>
  <tr valign="top">
    <td align="right">2054</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SubProcessCommandLineArgs {    // Parameters to pass to the sub-process   private List parameters = Lists.newArrayList();    public void addCommand(Integer position, String value) {     parameters.add(new Command(position, value));   }    public void putCommand(Command command) {     parameters.add(command);   }    public List getParameters() {     return parameters;   }    /** Class used to store the SubProcces parameters. */   public static class Command {      // The ordinal position of the command to pass to the sub-process     int ordinalPosition;     String value;      @SuppressWarnings(&quot;unused&quot;)     private Command() {}      public Command(int ordinalPosition, String value) {       this.ordinalPosition = ordinalPosition;       this.value = value;     }      public int getKey() {       return ordinalPosition;     }      public void setKey(int key) {       this.ordinalPosition = key;     }      public String getValue() {       return value;     }      public void setValue(String value) {       this.value = value;     }   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12922</td>
    <td align="left">https://github.com/apache/beam/blob/a956ff77a8448e5f2c12f6695fec608348b5ab60/examples/java/src/main/java/org/apache/beam/examples/subprocess/kernel/SubProcessCommandLineArgs.java/#L24-L72</td>
    <td align="right">1</td>
    <td align="right">2054</td>
    <td align="right">12922</td>
  </tr>
  <tr valign="top">
    <td align="right">2416</td>
    <td align="left">{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Data Class&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DebugInfoDecoder {     /** encoded debug info */     private final byte[] encoded;      /** positions decoded */     private final ArrayList positions;      /** locals decoded */     private final ArrayList locals;      /** size of code block in code units */     private final int codesize;      /** indexed by register, the last local variable live in a reg */     private final LocalEntry[] lastEntryForReg;      /** method descriptor of method this debug info is for */     private final Prototype desc;      /** true if method is static */     private final boolean isStatic;      /** dex file this debug info will be stored in */     private final DexFile file;      /**      * register size, in register units, of the register space      * used by this method      */     private final int regSize;      /** current decoding state: line number */     private int line = 1;      /** current decoding state: bytecode address */     private int address = 0;      /** string index of the string &quot;this&quot; */     private final int thisStringIdx;      /**      * Constructs an instance.      *      * @param encoded encoded debug info      * @param codesize size of code block in code units      * @param regSize register size, in register units, of the register space      * used by this method      * @param isStatic true if method is static      * @param ref method descriptor of method this debug info is for      * @param file dex file this debug info will be stored in      */     DebugInfoDecoder(byte[] encoded, int codesize, int regSize,             boolean isStatic, CstMethodRef ref, DexFile file) {         if (encoded == null) {             throw new NullPointerException(&quot;encoded == null&quot;);         }          this.encoded = encoded;         this.isStatic = isStatic;         this.desc = ref.getPrototype();         this.file = file;         this.regSize = regSize;          positions = new ArrayList();         locals = new ArrayList();         this.codesize = codesize;         lastEntryForReg = new LocalEntry[regSize];          int idx = -1;          try {             idx = file.getStringIds().indexOf(new CstString(&quot;this&quot;));         } catch (IllegalArgumentException ex) {             /*              * Silently tolerate not finding &quot;this&quot;. It just means that              * no method has local variable info that looks like              * a standard instance method.              */         }          thisStringIdx = idx;     }      /**      * An entry in the resulting postions table      */     static private class PositionEntry {         /** bytecode address */         public int address;          /** line number */         public int line;          public PositionEntry(int address, int line) {             this.address = address;             this.line = line;         }     }      /**      * An entry in the resulting locals table      */     static private class LocalEntry {         /** address of event */         public int address;          /** {@code true} iff it's a local start */         public boolean isStart;          /** register number */         public int reg;          /** index of name in strings table */         public int nameIndex;          /** index of type in types table */         public int typeIndex;          /** index of type signature in strings table */         public int signatureIndex;          public LocalEntry(int address, boolean isStart, int reg, int nameIndex,                 int typeIndex, int signatureIndex) {             this.address        = address;             this.isStart        = isStart;             this.reg            = reg;             this.nameIndex      = nameIndex;             this.typeIndex      = typeIndex;             this.signatureIndex = signatureIndex;         }          public String toString() {             return String.format(&quot;[%x %s v%d %04x %04x %04x]&quot;,                     address, isStart ? &quot;start&quot; : &quot;end&quot;, reg,                     nameIndex, typeIndex, signatureIndex);         }     }      /**      * Gets the decoded positions list.      * Valid after calling {@code decode}.      *      * @return positions list in ascending address order.      */     public List getPositionList() {         return positions;     }      /**      * Gets the decoded locals list, in ascending start-address order.      * Valid after calling {@code decode}.      *      * @return locals list in ascending address order.      */     public List getLocals() {         return locals;     }      /**      * Decodes the debug info sequence.      */     public void decode() {         try {             decode0();         } catch (Exception ex) {             throw ExceptionWithContext.withContext(ex,                     &quot;...while decoding debug info&quot;);         }     }      /**      * Reads a string index. String indicies are offset by 1, and a 0 value      * in the stream (-1 as returned by this method) means &quot;null&quot;      *      * @return index into file's string ids table, -1 means null      * @throws IOException      */     private int readStringIndex(ByteInput bs) throws IOException {         int offsetIndex = Leb128.readUnsignedLeb128(bs);          return offsetIndex - 1;     }      /**      * Gets the register that begins the method's parameter range (including      * the 'this' parameter for non-static methods). The range continues until      * {@code regSize}      *      * @return register as noted above.      */     private int getParamBase() {         return regSize                 - desc.getParameterTypes().getWordCount() - (isStatic? 0 : 1);     }      private void decode0() throws IOException {         ByteInput bs = new ByteArrayByteInput(encoded);          line = Leb128.readUnsignedLeb128(bs);         int szParams = Leb128.readUnsignedLeb128(bs);         StdTypeList params = desc.getParameterTypes();         int curReg = getParamBase();          if (szParams != params.size()) {             throw new RuntimeException(                     &quot;Mismatch between parameters_size and prototype&quot;);         }          if (!isStatic) {             // Start off with implicit 'this' entry             LocalEntry thisEntry =                 new LocalEntry(0, true, curReg, thisStringIdx, 0, 0);             locals.add(thisEntry);             lastEntryForReg[curReg] = thisEntry;             curReg++;         }          for (int i = 0; i &lt; szParams; i++) {             Type paramType = params.getType(i);             LocalEntry le;              int nameIdx = readStringIndex(bs);              if (nameIdx == -1) {                 /*                  * Unnamed parameter; often but not always filled in by an                  * extended start op after the prologue                  */                 le = new LocalEntry(0, true, curReg, -1, 0, 0);             } else {                 // TODO: Final 0 should be idx of paramType.getDescriptor().                 le = new LocalEntry(0, true, curReg, nameIdx, 0, 0);             }              locals.add(le);             lastEntryForReg[curReg] = le;             curReg += paramType.getCategory();         }          for (;;) {             int opcode = bs.readByte() &amp; 0xff;              switch (opcode) {                 case DBG_START_LOCAL: {                     int reg = Leb128.readUnsignedLeb128(bs);                     int nameIdx = readStringIndex(bs);                     int typeIdx = readStringIndex(bs);                     LocalEntry le = new LocalEntry(                             address, true, reg, nameIdx, typeIdx, 0);                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_START_LOCAL_EXTENDED: {                     int reg = Leb128.readUnsignedLeb128(bs);                     int nameIdx = readStringIndex(bs);                     int typeIdx = readStringIndex(bs);                     int sigIdx = readStringIndex(bs);                     LocalEntry le = new LocalEntry(                             address, true, reg, nameIdx, typeIdx, sigIdx);                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_RESTART_LOCAL: {                     int reg = Leb128.readUnsignedLeb128(bs);                     LocalEntry prevle;                     LocalEntry le;                      try {                         prevle = lastEntryForReg[reg];                          if (prevle.isStart) {                             throw new RuntimeException(&quot;nonsensical &quot;                                     + &quot;RESTART_LOCAL on live register v&quot;                                     + reg);                         }                          le = new LocalEntry(address, true, reg,                                 prevle.nameIndex, prevle.typeIndex, 0);                     } catch (NullPointerException ex) {                         throw new RuntimeException(                                 &quot;Encountered RESTART_LOCAL on new v&quot; + reg);                     }                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_END_LOCAL: {                     int reg = Leb128.readUnsignedLeb128(bs);                     LocalEntry prevle;                     LocalEntry le;                      try {                         prevle = lastEntryForReg[reg];                          if (!prevle.isStart) {                             throw new RuntimeException(&quot;nonsensical &quot;                                     + &quot;END_LOCAL on dead register v&quot; + reg);                         }                          le = new LocalEntry(address, false, reg,                                 prevle.nameIndex, prevle.typeIndex,                                 prevle.signatureIndex);                     } catch (NullPointerException ex) {                         throw new RuntimeException(                                 &quot;Encountered END_LOCAL on new v&quot; + reg);                     }                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_END_SEQUENCE:                     // all done                 return;                  case DBG_ADVANCE_PC:                     address += Leb128.readUnsignedLeb128(bs);                 break;                  case DBG_ADVANCE_LINE:                     line += Leb128.readSignedLeb128(bs);                 break;                  case DBG_SET_PROLOGUE_END:                     //TODO do something with this.                 break;                  case DBG_SET_EPILOGUE_BEGIN:                     //TODO do something with this.                 break;                  case DBG_SET_FILE:                     //TODO do something with this.                 break;                  default:                     if (opcode &lt; DBG_FIRST_SPECIAL) {                         throw new RuntimeException(                                 &quot;Invalid extended opcode encountered &quot;                                         + opcode);                     }                      int adjopcode = opcode - DBG_FIRST_SPECIAL;                      address += adjopcode / DBG_LINE_RANGE;                     line += DBG_LINE_BASE + (adjopcode % DBG_LINE_RANGE);                      positions.add(new PositionEntry(address, line));                 break;              }         }     }      /**      * Validates an encoded debug info stream against data used to encode it,      * throwing an exception if they do not match. Used to validate the      * encoder.      *      * @param info encoded debug info      * @param file {@code non-null;} file to refer to during decoding      * @param ref {@code non-null;} method whose info is being decoded      * @param code {@code non-null;} original code object that was encoded      * @param isStatic whether the method is static      */     public static void validateEncode(byte[] info, DexFile file,             CstMethodRef ref, DalvCode code, boolean isStatic) {         PositionList pl = code.getPositions();         LocalList ll = code.getLocals();         DalvInsnList insns = code.getInsns();         int codeSize = insns.codeSize();         int countRegisters = insns.getRegistersSize();          try {             validateEncode0(info, codeSize, countRegisters,                     isStatic, ref, file, pl, ll);         } catch (RuntimeException ex) {             System.err.println(&quot;instructions:&quot;);             insns.debugPrint(System.err, &quot;  &quot;, true);             System.err.println(&quot;local list:&quot;);             ll.debugPrint(System.err, &quot;  &quot;);             throw ExceptionWithContext.withContext(ex,                     &quot;while processing &quot; + ref.toHuman());         }     }      private static void validateEncode0(byte[] info, int codeSize,             int countRegisters, boolean isStatic, CstMethodRef ref,             DexFile file, PositionList pl, LocalList ll) {         DebugInfoDecoder decoder                 = new DebugInfoDecoder(info, codeSize, countRegisters,                     isStatic, ref, file);          decoder.decode();          /*          * Go through the decoded position entries, matching up          * with original entries.          */          List decodedEntries = decoder.getPositionList();          if (decodedEntries.size() != pl.size()) {             throw new RuntimeException(                     &quot;Decoded positions table not same size was &quot;                     + decodedEntries.size() + &quot; expected &quot; + pl.size());         }          for (PositionEntry entry : decodedEntries) {             boolean found = false;             for (int i = pl.size() - 1; i &gt;= 0; i--) {                 PositionList.Entry ple = pl.get(i);                  if (entry.line == ple.getPosition().getLine()                         &amp;&amp; entry.address == ple.getAddress()) {                     found = true;                     break;                 }             }              if (!found) {                 throw new RuntimeException (&quot;Could not match position entry: &quot;                         + entry.address + &quot;, &quot; + entry.line);             }         }          /*          * Go through the original local list, in order, matching up          * with decoded entries.          */          List decodedLocals = decoder.getLocals();         int thisStringIdx = decoder.thisStringIdx;         int decodedSz = decodedLocals.size();         int paramBase = decoder.getParamBase();          /*          * Preflight to fill in any parameters that were skipped in          * the prologue (including an implied &quot;this&quot;) but then          * identified by full signature.          */         for (int i = 0; i &lt; decodedSz; i++) {             LocalEntry entry = decodedLocals.get(i);             int idx = entry.nameIndex;              if ((idx &lt; 0) || (idx == thisStringIdx)) {                 for (int j = i + 1; j &lt; decodedSz; j++) {                     LocalEntry e2 = decodedLocals.get(j);                     if (e2.address != 0) {                         break;                     }                     if ((entry.reg == e2.reg) &amp;&amp; e2.isStart) {                         decodedLocals.set(i, e2);                         decodedLocals.remove(j);                         decodedSz--;                         break;                     }                 }             }         }          int origSz = ll.size();         int decodeAt = 0;         boolean problem = false;          for (int i = 0; i &lt; origSz; i++) {             LocalList.Entry origEntry = ll.get(i);              if (origEntry.getDisposition()                     == LocalList.Disposition.END_REPLACED) {                 /*                  * The encoded list doesn't represent replacements, so                  * ignore them for the sake of comparison.                  */                 continue;             }              LocalEntry decodedEntry;              do {                 decodedEntry = decodedLocals.get(decodeAt);                 if (decodedEntry.nameIndex &gt;= 0) {                     break;                 }                 /*                  * A negative name index means this is an anonymous                  * parameter, and we shouldn't expect to see it in the                  * original list. So, skip it.                  */                 decodeAt++;             } while (decodeAt &lt; decodedSz);              int decodedAddress = decodedEntry.address;              if (decodedEntry.reg != origEntry.getRegister()) {                 System.err.println(&quot;local register mismatch at orig &quot; + i +                         &quot; / decoded &quot; + decodeAt);                 problem = true;                 break;             }              if (decodedEntry.isStart != origEntry.isStart()) {                 System.err.println(&quot;local start/end mismatch at orig &quot; + i +                         &quot; / decoded &quot; + decodeAt);                 problem = true;                 break;             }              /*              * The secondary check here accounts for the fact that a              * parameter might not be marked as starting at 0 in the              * original list.              */             if ((decodedAddress != origEntry.getAddress())                     &amp;&amp; !((decodedAddress == 0)                             &amp;&amp; (decodedEntry.reg &gt;= paramBase))) {                 System.err.println(&quot;local address mismatch at orig &quot; + i +                         &quot; / decoded &quot; + decodeAt);                 problem = true;                 break;             }              decodeAt++;         }          if (problem) {             System.err.println(&quot;decoded locals:&quot;);             for (LocalEntry e : decodedLocals) {                 System.err.println(&quot;  &quot; + e);             }             throw new RuntimeException(&quot;local table problem&quot;);         }     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14420</td>
    <td align="left">https://github.com/facebook/buck/blob/1bc8d383ea5cb153ca9bf4f2807e6be498648523/third-party/java/dx/src/com/android/dx/dex/file/DebugInfoDecoder.java/#L54-L596</td>
    <td align="right">1</td>
    <td align="right">2416</td>
    <td align="right">14420</td>
  </tr>
  <tr valign="top">
    <td align="right">2226</td>
    <td align="left">&nbsp;{     &quot;answer&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Blob&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
   public class Header {        public String key;       public String val;        public Header(String key, String val) {          this.key = key;          this.val = val;       }        public String getEncodedKey() {          return encode(key);       }        public String getEncodedValue() {          return encode(val);       }    }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13576</td>
    <td align="left">https://github.com/apache/activemq-artemis/blob/5bd5c610195d6f4a3dd1ac28170727003f8a5a54/artemis-protocols/artemis-stomp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/stomp/StompFrame.java/#L158-L175</td>
    <td align="right">1</td>
    <td align="right">2226</td>
    <td align="right">13576</td>
  </tr>
  <tr valign="top">
    <td align="right">350</td>
    <td align="left">&nbsp;	{ 		&quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [ 			&quot;Blob&quot;,  			&quot;Data Class&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface ClusterServiceArtifactResponse {    @ApiModelProperty(name = ArtifactResourceProvider.RESPONSE_KEY)   @SuppressWarnings(&quot;unused&quot;)   ClusterServiceArtifactResponseInfo getClusterServiceArtifactResponseInfo();    @ApiModelProperty(name = ArtifactResourceProvider.ARTIFACT_DATA_PROPERTY)   Map getArtifactData();    interface ClusterServiceArtifactResponseInfo {     @ApiModelProperty(name = ArtifactResourceProvider.ARTIFACT_NAME)     String getArtifactName();      @ApiModelProperty(name = ArtifactResourceProvider.CLUSTER_NAME)     String getClusterName();      @ApiModelProperty(name = ArtifactResourceProvider.SERVICE_NAME)     String getServiceName();   }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3597</td>
    <td align="left">https://github.com/apache/ambari/blob/2bc4779a1e6aabe638101fc8b0e28cd1963d6b13/ambari-server/src/main/java/org/apache/ambari/server/controller/ClusterServiceArtifactResponse.java/#L32-L52</td>
    <td align="right">1</td>
    <td align="right">350</td>
    <td align="right">3597</td>
  </tr>
  <tr valign="top">
    <td align="right">80</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  abstract static class RequestParamsBuilder {     T body;      public RequestParamsBuilder(T body) {       this.body = body;     }      abstract RequestParams buildRequestParams();      void setBody(T body) {       this.body = body;     }   }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1185</td>
    <td align="left">https://github.com/oracle/weblogic-kubernetes-operator/blob/1fb059d7e32b9b3514617d54e4dda41ab68e71ea/operator/src/main/java/oracle/kubernetes/operator/helpers/CallBuilder.java/#L179-L191</td>
    <td align="right">1</td>
    <td align="right">80</td>
    <td align="right">1185</td>
  </tr>
  <tr valign="top">
    <td align="right">2914</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells the bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  private static class FieldMetaData {     public final FieldInfo fieldInfo;     public final long numTerms;     public final long sumTotalTermFreq;     public final long sumDocFreq;     public final int docCount;     public final int longsSize;     public final FST dict;      public FieldMetaData(FieldInfo fieldInfo, long numTerms, long sumTotalTermFreq, long sumDocFreq, int docCount, int longsSize, FST fst) {       this.fieldInfo = fieldInfo;       this.numTerms = numTerms;       this.sumTotalTermFreq = sumTotalTermFreq;       this.sumDocFreq = sumDocFreq;       this.docCount = docCount;       this.longsSize = longsSize;       this.dict = fst;     }   }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2250</td>
    <td align="left">https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/lucene/codecs/src/java/org/apache/lucene/codecs/memory/FSTTermsWriter.java/#L229-L247</td>
    <td align="right">1</td>
    <td align="right">2914</td>
    <td align="right">2250</td>
  </tr>
  <tr valign="top">
    <td align="right">2336</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class ConfigBoolean extends ConfigVariable {     public ConfigBoolean(OptionSpec spec)     {         super(spec);          this.enabled = false;         this.isSet = false;     }      public ConfigBoolean(OptionSpec spec, boolean enabled)     {         super(spec);         this.set(enabled);     }          private boolean enabled;     private boolean isSet;       public void set(boolean value)     {         this.enabled = value;         this.isSet = true;     }      public void set(String value)     {         this.enabled = parseValue(value);         this.isSet = true;     }      public boolean isSet()     {     	return isSet;     	}      public void addToCommandline(Commandline cmdline)     {         if (isSet)             cmdline.createArgument(true).setValue(&quot;-&quot; + spec.getFullName() + &quot;=&quot; + enabled);     }      private boolean parseValue(String value)     {         return value.toLowerCase().matches(&quot;\\s*(true|yes|on)\\s*&quot;);     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14164</td>
    <td align="left">https://github.com/apache/royale-compiler/blob/fbd9bc3b9e48c80dbd8c1d32a6f83221e314efdd/royale-ant-tasks/src/main/java/org/apache/royale/compiler/ant/config/ConfigBoolean.java/#L28-L75</td>
    <td align="right">1</td>
    <td align="right">2336</td>
    <td align="right">14164</td>
  </tr>
  <tr valign="top">
    <td align="right">1116</td>
    <td align="left">&nbsp;{     &quot;output&quot;: &quot;YES, I found bad smells. The bad smells are: 1. Long method, 2. Data class&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class FileDiskCacheAttributes     extends AbstractDiskCacheAttributes {     /** Don't change. */     private static final long serialVersionUID = -7371586172678836062L;      /** Default file count limit: -1 means no limit */     public static final int DEFAULT_MAX_NUMBER_OF_FILES = -1;      /** Max number of files */     private int maxNumberOfFiles = DEFAULT_MAX_NUMBER_OF_FILES;      /** Default limit on the number of times we will retry a delete. */     public static final int DEFAULT_MAX_RETRIES_ON_DELETE = 10;      /** Max number of retries on delete */     private int maxRetriesOnDelete = DEFAULT_MAX_RETRIES_ON_DELETE;      /** Default touch rule. */     public static final boolean DEFAULT_TOUCH_ON_GET = false;      /** Default limit on the number of times we will retry a delete. */     public static final int DEFAULT_MAX_RETRIES_ON_TOUCH = 10;      /** Max number of retries on touch  */     private int maxRetriesOnTouch = DEFAULT_MAX_RETRIES_ON_TOUCH;      /**      * Should we touch on get. If so, we will reset the last modified time. If you have a max file      * size set, this will make the removal strategy LRU. If this is false, then the oldest will be      * removed.      */     private boolean touchOnGet = DEFAULT_TOUCH_ON_GET;      /**      * @param maxNumberOfFiles the maxNumberOfFiles to set      */     public void setMaxNumberOfFiles( int maxNumberOfFiles )     {         this.maxNumberOfFiles = maxNumberOfFiles;     }      /**      * @return the maxNumberOfFiles      */     public int getMaxNumberOfFiles()     {         return maxNumberOfFiles;     }      /**      * @param maxRetriesOnDelete the maxRetriesOnDelete to set      */     public void setMaxRetriesOnDelete( int maxRetriesOnDelete )     {         this.maxRetriesOnDelete = maxRetriesOnDelete;     }      /**      * @return the maxRetriesOnDelete      */     public int getMaxRetriesOnDelete()     {         return maxRetriesOnDelete;     }      /**      * @param touchOnGet the touchOnGet to set      */     public void setTouchOnGet( boolean touchOnGet )     {         this.touchOnGet = touchOnGet;     }      /**      * @return the touchOnGet      */     public boolean isTouchOnGet()     {         return touchOnGet;     }      /**      * @param maxRetriesOnTouch the maxRetriesOnTouch to set      */     public void setMaxRetriesOnTouch( int maxRetriesOnTouch )     {         this.maxRetriesOnTouch = maxRetriesOnTouch;     }      /**      * @return the maxRetriesOnTouch      */     public int getMaxRetriesOnTouch()     {         return maxRetriesOnTouch;     }      /**      * Write out the values for debugging purposes.      *       * @return String      */     @Override     public String toString()     {         StringBuilder str = new StringBuilder();         str.append( &quot;DiskFileCacheAttributes &quot; );         str.append( &quot;\n diskPath = &quot; + super.getDiskPath() );         str.append( &quot;\n maxNumberOfFiles   = &quot; + getMaxNumberOfFiles() );         str.append( &quot;\n maxRetriesOnDelete  = &quot; + getMaxRetriesOnDelete() );         return str.toString();     } }</td>
    <td align="left">data class</td>
    <td align="left">1. long method, 2. data class </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9954</td>
    <td align="left">https://github.com/apache/commons-jcs/blob/ad897014842fc830483f32fdfb903f3bb8f70289/commons-jcs-sandbox/filecache/src/main/java/org/apache/commons/jcs/auxiliary/disk/file/FileDiskCacheAttributes.java/#L27-L140</td>
    <td align="right">1</td>
    <td align="right">1116</td>
    <td align="right">9954</td>
  </tr>
  <tr valign="top">
    <td align="right">1522</td>
    <td align="left">&nbsp;		{ 			&quot;message&quot;: &quot;YES I found bad smells&quot;, 			&quot;bad smells are&quot;: [ 				&quot;Blob&quot;, 				&quot;Data Class&quot;, 				&quot;Long Method&quot; 			] 		} </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class RowRange {     private Text startRow;     private Text endRow;      public RowRange(KeyExtent ke) {       this.startRow = ke.getPrevEndRow();       this.endRow = ke.getEndRow();     }      public RowRange(TRowRange trr) {       this.startRow = ByteBufferUtil.toText(trr.startRow);       this.endRow = ByteBufferUtil.toText(trr.endRow);     }      public RowRange(Text startRow, Text endRow) {       this.startRow = startRow;       this.endRow = endRow;     }      public Range toRange() {       return new Range(startRow, false, endRow, true);     }      public TRowRange toThrift() {       return new TRowRange(TextUtil.getByteBuffer(startRow), TextUtil.getByteBuffer(endRow));     }      public Text getStartRow() {       return startRow;     }      public Text getEndRow() {       return endRow;     }      @Override     public String toString() {       return startRow + &quot; &quot; + endRow;     }   }</td>
    <td align="left">data class</td>
    <td align="left">Blob, Data Class, Long Method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">Blob,  Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11174</td>
    <td align="left">https://github.com/apache/accumulo/blob/f896c98c2356a52dfa2235d2cc02ae556ab17909/core/src/main/java/org/apache/accumulo/core/summary/Gatherer.java/#L617-L656</td>
    <td align="right">1</td>
    <td align="right">1522</td>
    <td align="right">11174</td>
  </tr>
  <tr valign="top">
    <td align="right">1229</td>
    <td align="left">&nbsp;{    &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;bad_smells&quot;: [     &quot;Data Class&quot;,     &quot;Long Method&quot;   ]  }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class ObjectLruCache extends AbstractLruCache {      /** The array of values */     Object[] values = new Object[INITIAL_SIZE];      /**      * Create a new ObjectLruCache.      * @param maxSize the maximum size the cache can grow to      */     public ObjectLruCache(int maxSize) {         super(maxSize);     }      /**      * Overridden method to return values array.      */     Object getValuesArray() {         return values;     }      /**      * Overridden method to allocate new values array.      */     void allocNewValuesArray(int newSize) {         super.allocNewValuesArray(newSize);         values = new Object[newSize];     }      /**      * Overridden method to repopulate with key plus value at given offset.      */     void put(long key, Object oldvalues, int offset) {         Object[] v = (Object[])oldvalues;         put(key, v[offset]);     }      /**      * Returns the value mapped by the given key. Also promotes this key to the most      * recently used.      * @return the value or null if it cannot be found      */     public Object get(long key) {         int index = getIndexAndPromote(key) ;         if (index != -1) {             return values[index];         }         return null;     }      /**      * Add the key/value pair to the map.      */     public void put(long key, Object value) {         int index = putIndexAndPromote(key) ;         values[index] = value;         checkRehash();     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10360</td>
    <td align="left">https://github.com/eclipse/openj9/blob/4911084853eb75b20e037c434ad4521b7317ebfb/jcl/src/openj9.dtfj/share/classes/com/ibm/dtfj/corereaders/zos/util/ObjectLruCache.java/#L32-L89</td>
    <td align="right">1</td>
    <td align="right">1229</td>
    <td align="right">10360</td>
  </tr>
  <tr valign="top">
    <td align="right">2363</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Long Method&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SuppressWarnings(&quot;serial&quot;) public class GitHubUser implements Serializable {  	private final long id;  	private final String url;  	private final String login;  	private final String avatarUrl;  	private final String gravatarId;  	private String name;  	private String email;      public GitHubUser(long id, String url, String login, String avatarUrl, String gravatarId) {         this.id = id;         this.url = url;         this.login = login;         this.avatarUrl = avatarUrl;         this.gravatarId = gravatarId;     }      public Long getId() { return id; } 	 	public String getUrl() { return url; }  	public String getLogin() { return login; }  	public String getAvatarUrl() { return avatarUrl; }  	public String getGravatarId() { return gravatarId; } 	 	public String getName() { return name; } 	 	public void setName(String name) { this.name = name; } 	 	public String getEmail() { return email; } 	 	public void setEmail(String email) { this.email = email; } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14254</td>
    <td align="left">https://github.com/spring-projects/spring-social-github/blob/7939988245be49486d27c42c30bfb0a567c6ec1b/spring-social-github/src/main/java/org/springframework/social/github/api/GitHubUser.java/#L30-L72</td>
    <td align="right">1</td>
    <td align="right">2363</td>
    <td align="right">14254</td>
  </tr>
  <tr valign="top">
    <td align="right">929</td>
    <td align="left">&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class _ParameterFieldReference     extends _ParameterValueOrFieldReference     implements ElementSerializable, ElementDeserializable {     // No attributes          // Elements     protected String parameterName;     protected String fieldAlias;      public _ParameterFieldReference()     {         super();     }      public _ParameterFieldReference(         final String parameterName,         final String fieldAlias)     {         // TODO : Call super() instead of setting all fields directly?         setParameterName(parameterName);         setFieldAlias(fieldAlias);     }      public String getParameterName()     {         return this.parameterName;     }      public void setParameterName(String value)     {         this.parameterName = value;     }      public String getFieldAlias()     {         return this.fieldAlias;     }      public void setFieldAlias(String value)     {         this.fieldAlias = value;     }      public void writeAsElement(         final XMLStreamWriter writer,         final String name)         throws XMLStreamException     {         writer.writeStartElement(name);          // Declare our type         writer.writeAttribute(             &quot;xsi&quot;,             &quot;http://www.w3.org/2001/XMLSchema-instance&quot;,             &quot;type&quot;,             &quot;ParameterFieldReference&quot;);          // Elements         XMLStreamWriterHelper.writeElement(             writer,             &quot;ParameterName&quot;,             this.parameterName);         XMLStreamWriterHelper.writeElement(             writer,             &quot;FieldAlias&quot;,             this.fieldAlias);          writer.writeEndElement();     }      public void readFromElement(final XMLStreamReader reader)         throws XMLStreamException     {         String localName;          // This object uses no attributes          // Elements         int event;          do         {             event = reader.next();              if (event == XMLStreamConstants.START_ELEMENT)             {                 localName = reader.getLocalName();                  if (localName.equalsIgnoreCase(&quot;ParameterName&quot;))                 {                     this.parameterName = reader.getElementText();                 }                 else if (localName.equalsIgnoreCase(&quot;FieldAlias&quot;))                 {                     this.fieldAlias = reader.getElementText();                 }                 else                 {                     // Read the unknown child element until its end                     XMLStreamReaderHelper.readUntilElementEnd(reader);                 }             }         }         while (event != XMLStreamConstants.END_ELEMENT);     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8340</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core.ws/generated-src/ms/sql/reporting/reportingservices/_ParameterFieldReference.java/#L31-L137</td>
    <td align="right">1</td>
    <td align="right">929</td>
    <td align="right">8340</td>
  </tr>
  <tr valign="top">
    <td align="right">4308</td>
    <td align="left">&nbsp;{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@InterfaceAudience.Private public class MetricsAssignmentManagerSourceImpl     extends BaseSourceImpl     implements MetricsAssignmentManagerSource {    private MutableGaugeLong ritGauge;   private MutableGaugeLong ritCountOverThresholdGauge;   private MutableGaugeLong ritOldestAgeGauge;   private MetricHistogram ritDurationHisto;    private MutableFastCounter operationCounter;    private OperationMetrics assignMetrics;   private OperationMetrics unassignMetrics;   private OperationMetrics moveMetrics;   private OperationMetrics reopenMetrics;   private OperationMetrics openMetrics;   private OperationMetrics closeMetrics;   private OperationMetrics splitMetrics;   private OperationMetrics mergeMetrics;    public MetricsAssignmentManagerSourceImpl() {     this(METRICS_NAME, METRICS_DESCRIPTION, METRICS_CONTEXT, METRICS_JMX_CONTEXT);   }    public MetricsAssignmentManagerSourceImpl(String metricsName,                                             String metricsDescription,                                             String metricsContext, String metricsJmxContext) {     super(metricsName, metricsDescription, metricsContext, metricsJmxContext);   }    public void init() {     ritGauge = metricsRegistry.newGauge(RIT_COUNT_NAME, RIT_COUNT_DESC, 0L);     ritCountOverThresholdGauge = metricsRegistry.newGauge(RIT_COUNT_OVER_THRESHOLD_NAME,         RIT_COUNT_OVER_THRESHOLD_DESC,0L);     ritOldestAgeGauge = metricsRegistry.newGauge(RIT_OLDEST_AGE_NAME, RIT_OLDEST_AGE_DESC, 0L);     ritDurationHisto = metricsRegistry.newTimeHistogram(RIT_DURATION_NAME, RIT_DURATION_DESC);     operationCounter = metricsRegistry.getCounter(OPERATION_COUNT_NAME, 0L);      /**      * NOTE: Please refer to HBASE-9774 and HBASE-14282. Based on these two issues, HBase is      * moving away from using Hadoop's metric2 to having independent HBase specific Metrics. Use      * {@link BaseSourceImpl#registry} to register the new metrics.      */     assignMetrics = new OperationMetrics(registry, ASSIGN_METRIC_PREFIX);     unassignMetrics = new OperationMetrics(registry, UNASSIGN_METRIC_PREFIX);     moveMetrics = new OperationMetrics(registry, MOVE_METRIC_PREFIX);     reopenMetrics = new OperationMetrics(registry, REOPEN_METRIC_PREFIX);     openMetrics = new OperationMetrics(registry, OPEN_METRIC_PREFIX);     closeMetrics = new OperationMetrics(registry, CLOSE_METRIC_PREFIX);     splitMetrics = new OperationMetrics(registry, SPLIT_METRIC_PREFIX);     mergeMetrics = new OperationMetrics(registry, MERGE_METRIC_PREFIX);   }    @Override   public void setRIT(final int ritCount) {     ritGauge.set(ritCount);   }    @Override   public void setRITCountOverThreshold(final int ritCount) {     ritCountOverThresholdGauge.set(ritCount);   }    @Override   public void setRITOldestAge(final long ritOldestAge) {     ritOldestAgeGauge.set(ritOldestAge);   }    @Override   public void incrementOperationCounter() {     operationCounter.incr();   }    @Override   public void updateRitDuration(long duration) {     ritDurationHisto.add(duration);   }    @Override   public OperationMetrics getAssignMetrics() {     return assignMetrics;   }    @Override   public OperationMetrics getUnassignMetrics() {     return unassignMetrics;   }    @Override   public OperationMetrics getSplitMetrics() {     return splitMetrics;   }    @Override   public OperationMetrics getMergeMetrics() {     return mergeMetrics;   }    @Override   public OperationMetrics getMoveMetrics() {     return moveMetrics;   }    @Override   public OperationMetrics getReopenMetrics() {     return reopenMetrics;   }    @Override   public OperationMetrics getOpenMetrics() {     return openMetrics;   }    @Override   public OperationMetrics getCloseMetrics() {     return closeMetrics;   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11355</td>
    <td align="left">https://github.com/apache/hbase/blob/44f8abd5c65c59e9d09f6ad14b3c825f145d8e4f/hbase-hadoop2-compat/src/main/java/org/apache/hadoop/hbase/master/MetricsAssignmentManagerSourceImpl.java/#L28-L146</td>
    <td align="right">1</td>
    <td align="right">4308</td>
    <td align="right">11355</td>
  </tr>
  <tr valign="top">
    <td align="right">1652</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Singleton public class CheProductInfoDataProvider extends ProductInfoDataProviderImpl {    private final LocalizationConstant locale;   private final Resources resources;    @Inject   public CheProductInfoDataProvider(LocalizationConstant locale, Resources resources) {     this.locale = locale;     this.resources = resources;   }    @Override   public String getName() {     return locale.getProductName();   }    @Override   public String getSupportLink() {     return locale.getSupportLink();   }    @Override   public String getDocumentTitle() {     return locale.cheTabTitle();   }    @Override   public String getDocumentTitle(String workspaceName) {     return locale.cheTabTitle(workspaceName);   }    @Override   public SVGResource getLogo() {     return resources.logo();   }    @Override   public SVGResource getWaterMarkLogo() {     return resources.waterMarkLogo();   }    @Override   public String getSupportTitle() {     return locale.supportTitle();   } }</td>
    <td align="left">data class</td>
    <td align="left">Data Class, Long Method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11582</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/plugins/plugin-product-info/src/main/java/org/eclipse/che/plugin/product/info/client/CheProductInfoDataProvider.java/#L26-L72</td>
    <td align="right">1</td>
    <td align="right">1652</td>
    <td align="right">11582</td>
  </tr>
  <tr valign="top">
    <td align="right">911</td>
    <td align="left">&nbsp;{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;the bad smells are:&quot;,     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;ProviderCreditReversalDetails&quot;, propOrder = {     &quot;amazonProviderCreditReversalId&quot;,     &quot;sellerId&quot;,     &quot;providerSellerId&quot;,     &quot;creditReversalReferenceId&quot;,     &quot;creditReversalAmount&quot;,     &quot;creationTimestamp&quot;,     &quot;creditReversalStatus&quot;,     &quot;creditReversalNote&quot; }) public class ProviderCreditReversalDetails {      @XmlElement(name = &quot;AmazonProviderCreditReversalId&quot;, required = true)     protected String amazonProviderCreditReversalId;     @XmlElement(name = &quot;SellerId&quot;, required = true)     protected String sellerId;     @XmlElement(name = &quot;ProviderSellerId&quot;, required = true)     protected String providerSellerId;     @XmlElement(name = &quot;CreditReversalReferenceId&quot;, required = true)     protected String creditReversalReferenceId;     @XmlElement(name = &quot;CreditReversalAmount&quot;, required = true)     protected Price creditReversalAmount;     @XmlElement(name = &quot;CreationTimestamp&quot;, required = true)     @XmlSchemaType(name = &quot;dateTime&quot;)     protected XMLGregorianCalendar creationTimestamp;     @XmlElement(name = &quot;CreditReversalStatus&quot;, required = true)     protected Status creditReversalStatus;     @XmlElement(name = &quot;CreditReversalNote&quot;)     protected String creditReversalNote;      public ProviderCreditReversalDetails() {         super();     }      /**      * Returns the amazonProviderCreditReversalId from notification      *       * @return Returns the amazonProviderCreditReversalId from notification      */     public String getAmazonProviderCreditReversalId() {         return amazonProviderCreditReversalId;     }      /**      * Returns the sellerId from notification      *       * @return Returns the sellerId from notification      */     public String getSellerId() {         return sellerId;     }      /**      * Returns the providerSellerId from notification      *       * @return Returns the providerSellerId from notification      */     public String getProviderSellerId() {         return providerSellerId;     }      /**      * Returns the creditReversalReferenceId from notification      *       * @return Returns the creditReversalReferenceId from notification      */     public String getCreditReversalReferenceId() {         return creditReversalReferenceId;     }       /**      * Returns the creditReversalAmount from notification       *       * @return Returns the creditReversalAmount from notification       */     public Price getCreditReversalAmount() {         return creditReversalAmount;     }      /**      * Returns the creationTimestamp from notification      *       * @return Returns the creationTimestamp from notification      */     public XMLGregorianCalendar getCreationTimestamp() {         return creationTimestamp;     }      /**      * Returns the creditReversalStatus from notification      *       * @return Returns the creditReversalStatus from notification      */     public Status getCreditReversalStatus() {         return creditReversalStatus;     }      /**      * Returns the creditReversalNote from notification      *       * @return Returns the creditReversalNote from notification      */     public String getCreditReversalNote() {         return creditReversalNote;     }      /**      * String representation of providerCreditReversalNotification      */     @Override     public String toString() {         return &quot;ProviderCreditReversalDetails{&quot; + &quot;amazonProviderCreditReversalId=&quot; + amazonProviderCreditReversalId                  + &quot;, sellerId=&quot; + sellerId + &quot;, providerId=&quot; + providerSellerId + &quot;, creditReversalReferenceId=&quot;                  + creditReversalReferenceId + &quot;, creditReversalAmount=&quot; + creditReversalAmount + &quot;, creationTimestamp=&quot;                  + creationTimestamp + &quot;, creditReversalStatus=&quot; + creditReversalStatus + &quot;, creditReversalNote=&quot;                  + creditReversalNote + '}';     }  }</td>
    <td align="left">data class</td>
    <td align="left">the bad smells are:, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">the bad smells are:</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8224</td>
    <td align="left">https://github.com/amzn/amazon-pay-sdk-java/blob/5a3547d00c796aab8f0c8ac12e0310f7a5c4678a/src/com/amazon/pay/response/ipn/model/ProviderCreditReversalDetails.java/#L25-L145</td>
    <td align="right">1</td>
    <td align="right">911</td>
    <td align="right">8224</td>
  </tr>
  <tr valign="top">
    <td align="right">3454</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class AbstractPmdReport     extends AbstractMavenReport {     /**      * The output directory for the intermediate XML report.      */     @Parameter( property = &quot;project.build.directory&quot;, required = true )     protected File targetDirectory;      /**      * The output directory for the final HTML report. Note that this parameter is only evaluated if the goal is run      * directly from the command line or during the default lifecycle. If the goal is run indirectly as part of a site      * generation, the output directory configured in the Maven Site Plugin is used instead.      */     @Parameter( property = &quot;project.reporting.outputDirectory&quot;, required = true )     protected File outputDirectory;      /**      * Site rendering component for generating the HTML report.      */     @Component     private Renderer siteRenderer;      /**      * The project to analyse.      */     @Parameter( defaultValue = &quot;${project}&quot;, readonly = true, required = true )     protected MavenProject project;      /**      * Set the output format type, in addition to the HTML report. Must be one of: &quot;none&quot;, &quot;csv&quot;, &quot;xml&quot;, &quot;txt&quot; or the      * full class name of the PMD renderer to use. See the net.sourceforge.pmd.renderers package javadoc for available      * renderers. XML is required if the pmd:check goal is being used.      */     @Parameter( property = &quot;format&quot;, defaultValue = &quot;xml&quot; )     protected String format = &quot;xml&quot;;      /**      * Link the violation line numbers to the source xref. Links will be created automatically if the jxr plugin is      * being used.      */     @Parameter( property = &quot;linkXRef&quot;, defaultValue = &quot;true&quot; )     private boolean linkXRef;      /**      * Location of the Xrefs to link to.      */     @Parameter( defaultValue = &quot;${project.reporting.outputDirectory}/xref&quot; )     private File xrefLocation;      /**      * Location of the Test Xrefs to link to.      */     @Parameter( defaultValue = &quot;${project.reporting.outputDirectory}/xref-test&quot; )     private File xrefTestLocation;      /**      * A list of files to exclude from checking. Can contain Ant-style wildcards and double wildcards. Note that these      * exclusion patterns only operate on the path of a source file relative to its source root directory. In other      * words, files are excluded based on their package and/or class name. If you want to exclude entire source root      * directories, use the parameter excludeRoots instead.      *      * @since 2.2      */     @Parameter     private List excludes;      /**      * A list of files to include from checking. Can contain Ant-style wildcards and double wildcards. Defaults to      * **\/*.java.      *      * @since 2.2      */     @Parameter     private List includes;      /**      * Specifies the location of the source directories to be used for PMD.      * Defaults to project.compileSourceRoots.      * @since 3.7      */     @Parameter( defaultValue = &quot;${project.compileSourceRoots}&quot; )     private List compileSourceRoots;      /**      * The directories containing the test-sources to be used for PMD.      * Defaults to project.testCompileSourceRoots      * @since 3.7      */     @Parameter( defaultValue = &quot;${project.testCompileSourceRoots}&quot; )     private List testSourceRoots;      /**      * The project source directories that should be excluded.      *      * @since 2.2      */     @Parameter     private File[] excludeRoots;      /**      * Run PMD on the tests.      *      * @since 2.2      */     @Parameter( defaultValue = &quot;false&quot; )     protected boolean includeTests;      /**      * Whether to build an aggregated report at the root, or build individual reports.      *      * @since 2.2      */     @Parameter( property = &quot;aggregate&quot;, defaultValue = &quot;false&quot; )     protected boolean aggregate;      /**      * The file encoding to use when reading the Java sources.      *      * @since 2.3      */     @Parameter( property = &quot;encoding&quot;, defaultValue = &quot;${project.build.sourceEncoding}&quot; )     private String sourceEncoding;      /**      * The file encoding when writing non-HTML reports.      *      * @since 2.5      */     @Parameter( property = &quot;outputEncoding&quot;, defaultValue = &quot;${project.reporting.outputEncoding}&quot; )     private String outputEncoding;      /**      * The projects in the reactor for aggregation report.      */     @Parameter( property = &quot;reactorProjects&quot;, readonly = true )     protected List reactorProjects;      /**      * Whether to include the xml files generated by PMD/CPD in the site.      *      * @since 3.0      */     @Parameter( defaultValue = &quot;false&quot; )     protected boolean includeXmlInSite;      /**      * Skip the PMD/CPD report generation if there are no violations or duplications found. Defaults to      * true.      *      * @since 3.1      */     @Parameter( defaultValue = &quot;true&quot; )     protected boolean skipEmptyReport;      /**      * File that lists classes and rules to be excluded from failures.      * For PMD, this is a properties file. For CPD, this      * is a text file that contains comma-separated lists of classes      * that are allowed to duplicate.      *      * @since 3.7      */     @Parameter( property = &quot;pmd.excludeFromFailureFile&quot;, defaultValue = &quot;&quot; )     protected String excludeFromFailureFile;       /** The files that are being analyzed. */     protected Map filesToProcess;      /**      * {@inheritDoc}      */     @Override     protected MavenProject getProject()     {         return project;     }      /**      * {@inheritDoc}      */     @Override     protected Renderer getSiteRenderer()     {         return siteRenderer;     }      protected String constructXRefLocation( boolean test )     {         String location = null;         if ( linkXRef )         {             File xrefLoc = test ? xrefTestLocation : xrefLocation;              String relativePath =                 PathTool.getRelativePath( outputDirectory.getAbsolutePath(), xrefLoc.getAbsolutePath() );             if ( StringUtils.isEmpty( relativePath ) )             {                 relativePath = &quot;.&quot;;             }             relativePath = relativePath + &quot;/&quot; + xrefLoc.getName();             if ( xrefLoc.exists() )             {                 // XRef was already generated by manual execution of a lifecycle binding                 location = relativePath;             }             else             {                 // Not yet generated - check if the report is on its way                 @SuppressWarnings( &quot;unchecked&quot; )                 List reportPlugins = project.getReportPlugins();                 for ( ReportPlugin plugin : reportPlugins )                 {                     String artifactId = plugin.getArtifactId();                     if ( &quot;maven-jxr-plugin&quot;.equals( artifactId ) || &quot;jxr-maven-plugin&quot;.equals( artifactId ) )                     {                         location = relativePath;                     }                 }             }              if ( location == null )             {                 getLog().warn( &quot;Unable to locate Source XRef to link to - DISABLED&quot; );             }         }         return location;     }      /**      * Convenience method to get the list of files where the PMD tool will be executed      *      * @return a List of the files where the PMD tool will be executed      * @throws IOException If an I/O error occurs during construction of the      *                     canonical pathnames of the files      */     protected Map getFilesToProcess()         throws IOException     {         if ( aggregate &amp;&amp; !project.isExecutionRoot() )         {             return Collections.emptyMap();         }          if ( excludeRoots == null )         {             excludeRoots = new File[0];         }          Collection excludeRootFiles = new HashSet&lt;&gt;( excludeRoots.length );          for ( File file : excludeRoots )         {             if ( file.isDirectory() )             {                 excludeRootFiles.add( file );             }         }          List directories = new ArrayList&lt;&gt;();          if ( null == compileSourceRoots )         {             compileSourceRoots = project.getCompileSourceRoots();         }         if ( compileSourceRoots != null )         {             for ( String root : compileSourceRoots )             {                 File sroot = new File( root );                 if ( sroot.exists() )                 {                     String sourceXref = constructXRefLocation( false );                     directories.add( new PmdFileInfo( project, sroot, sourceXref ) );                 }             }         }          if ( null == testSourceRoots )         {             testSourceRoots = project.getTestCompileSourceRoots();         }         if ( includeTests )         {             if ( testSourceRoots != null )             {                 for ( String root : testSourceRoots )                 {                     File sroot = new File( root );                     if ( sroot.exists() )                     {                         String testXref = constructXRefLocation( true );                         directories.add( new PmdFileInfo( project, sroot, testXref ) );                     }                 }             }         }         if ( aggregate )         {             for ( MavenProject localProject : reactorProjects )             {                 @SuppressWarnings( &quot;unchecked&quot; )                 List localCompileSourceRoots = localProject.getCompileSourceRoots();                 for ( String root : localCompileSourceRoots )                 {                     File sroot = new File( root );                     if ( sroot.exists() )                     {                         String sourceXref = constructXRefLocation( false );                         directories.add( new PmdFileInfo( localProject, sroot, sourceXref ) );                     }                 }                 if ( includeTests )                 {                     @SuppressWarnings( &quot;unchecked&quot; )                     List localTestCompileSourceRoots = localProject.getTestCompileSourceRoots();                     for ( String root : localTestCompileSourceRoots )                     {                         File sroot = new File( root );                         if ( sroot.exists() )                         {                             String testXref = constructXRefLocation( true );                             directories.add( new PmdFileInfo( localProject, sroot, testXref ) );                         }                     }                 }             }          }          String excluding = getExcludes();         getLog().debug( &quot;Exclusions: &quot; + excluding );         String including = getIncludes();         getLog().debug( &quot;Inclusions: &quot; + including );          Map files = new TreeMap&lt;&gt;();          for ( PmdFileInfo finfo : directories )         {             getLog().debug( &quot;Searching for files in directory &quot; + finfo.getSourceDirectory().toString() );             File sourceDirectory = finfo.getSourceDirectory();             if ( sourceDirectory.isDirectory() &amp;&amp; !isDirectoryExcluded( excludeRootFiles, sourceDirectory ) )             {                 List newfiles = FileUtils.getFiles( sourceDirectory, including, excluding );                 for ( File newfile : newfiles )                 {                     files.put( newfile.getCanonicalFile(), finfo );                 }             }         }          return files;     }      private boolean isDirectoryExcluded( Collection excludeRootFiles, File sourceDirectoryToCheck )     {         boolean returnVal = false;         for ( File excludeDir : excludeRootFiles )         {             try             {                 if ( sourceDirectoryToCheck.getCanonicalPath().startsWith( excludeDir.getCanonicalPath() ) )                 {                     getLog().debug( &quot;Directory &quot; + sourceDirectoryToCheck.getAbsolutePath()                                         + &quot; has been excluded as it matches excludeRoot &quot;                                         + excludeDir.getAbsolutePath() );                     returnVal = true;                     break;                 }             }             catch ( IOException e )             {                 getLog().warn( &quot;Error while checking &quot; + sourceDirectoryToCheck                                + &quot; whether it should be excluded.&quot;, e );             }         }         return returnVal;     }      /**      * Gets the comma separated list of effective include patterns.      *      * @return The comma separated list of effective include patterns, never null.      */     private String getIncludes()     {         Collection patterns = new LinkedHashSet&lt;&gt;();         if ( includes != null )         {             patterns.addAll( includes );         }         if ( patterns.isEmpty() )         {             patterns.add( &quot;**/*.java&quot; );         }         return StringUtils.join( patterns.iterator(), &quot;,&quot; );     }      /**      * Gets the comma separated list of effective exclude patterns.      *      * @return The comma separated list of effective exclude patterns, never null.      */     private String getExcludes()     {         Collection patterns = new LinkedHashSet&lt;&gt;( FileUtils.getDefaultExcludesAsList() );         if ( excludes != null )         {             patterns.addAll( excludes );         }         return StringUtils.join( patterns.iterator(), &quot;,&quot; );     }      protected boolean isHtml()     {         return &quot;html&quot;.equals( format );     }      protected boolean isXml()     {         return &quot;xml&quot;.equals( format );     }      /**      * {@inheritDoc}      */     @Override     public boolean canGenerateReport()     {         if ( aggregate &amp;&amp; !project.isExecutionRoot() )         {             return false;         }          if ( &quot;pom&quot;.equals( project.getPackaging() ) &amp;&amp; !aggregate )         {             return false;         }          // if format is XML, we need to output it even if the file list is empty         // so the &quot;check&quot; goals can check for failures         if ( isXml() )         {             return true;         }         try         {             filesToProcess = getFilesToProcess();             if ( filesToProcess.isEmpty() )             {                 return false;             }         }         catch ( IOException e )         {             getLog().error( e );         }         return true;     }      /**      * {@inheritDoc}      */     @Override     protected String getOutputDirectory()     {         return outputDirectory.getAbsolutePath();     }      protected String getSourceEncoding()     {         return sourceEncoding;     }      /**      * Gets the effective reporting output files encoding.      *      * @return The effective reporting output file encoding, never null.      * @since 2.5      */     protected String getOutputEncoding()     {         return ( outputEncoding != null ) ? outputEncoding : ReaderFactory.UTF_8;     }      static String getPmdVersion()     {         try         {             return (String) PMD.class.getField( &quot;VERSION&quot; ).get( null );         }         catch ( IllegalAccessException e )         {             throw new RuntimeException( &quot;PMD VERSION field not accessible&quot;, e );         }         catch ( NoSuchFieldException e )         {             throw new RuntimeException( &quot;PMD VERSION field not found&quot;, e );         }     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6936</td>
    <td align="left">https://github.com/apache/maven-plugins/blob/a007e769ed5825774d5c31ec06c0013c8ee2b4d4/maven-pmd-plugin/src/main/java/org/apache/maven/plugins/pmd/AbstractPmdReport.java/#L52-L553</td>
    <td align="right">1</td>
    <td align="right">3454</td>
    <td align="right">6936</td>
  </tr>
  <tr valign="top">
    <td align="right">776</td>
    <td align="left">{&quot;response&quot;:&quot;YES I found bad smells&quot;,&quot;bad smells are&quot;:[&quot;Data Class&quot;,&quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@UriParams public class Mina2Configuration implements Cloneable {      @UriPath @Metadata(required = true)     private String protocol;     @UriPath @Metadata(required = true)     private String host;     @UriPath @Metadata(required = true)     private int port;     @UriParam(defaultValue = &quot;true&quot;)     private boolean sync = true;     @UriParam(label = &quot;codec&quot;)     private boolean textline;     @UriParam(label = &quot;codec&quot;)     private Mina2TextLineDelimiter textlineDelimiter;     @UriParam(label = &quot;codec&quot;)     private ProtocolCodecFactory codec;     @UriParam(label = &quot;codec&quot;)     private String encoding;     @UriParam(defaultValue = &quot;10000&quot;)     private long writeTimeout = 10000;     @UriParam(defaultValue = &quot;30000&quot;)     private long timeout = 30000;     @UriParam(label = &quot;producer,advanced&quot;, defaultValue = &quot;true&quot;)     private boolean lazySessionCreation = true;     @UriParam(label = &quot;advanced&quot;)     private boolean transferExchange;     @UriParam     private boolean minaLogger;     @UriParam(label = &quot;codec&quot;, defaultValue = &quot;-1&quot;)     private int encoderMaxLineLength = -1;     @UriParam(label = &quot;codec&quot;, defaultValue = &quot;1024&quot;)     private int decoderMaxLineLength = 1024;     @UriParam(label = &quot;codec&quot;)     private List filters;     @UriParam(label = &quot;codec&quot;, defaultValue = &quot;true&quot;)     private boolean allowDefaultCodec = true;     @UriParam     private boolean disconnect;     @UriParam(label = &quot;consumer,advanced&quot;, defaultValue = &quot;true&quot;)     private boolean disconnectOnNoReply = true;     @UriParam(label = &quot;consumer,advanced&quot;, defaultValue = &quot;WARN&quot;)     private LoggingLevel noReplyLogLevel = LoggingLevel.WARN;     @UriParam(label = &quot;security&quot;)     private SSLContextParameters sslContextParameters;     @UriParam(label = &quot;security&quot;, defaultValue = &quot;true&quot;)     private boolean autoStartTls = true;     @UriParam(label = &quot;advanced&quot;, defaultValue = &quot;16&quot;)     private int maximumPoolSize = 16; // 16 is the default mina setting     @UriParam(label = &quot;advanced&quot;, defaultValue = &quot;true&quot;)     private boolean orderedThreadPoolExecutor = true;     @UriParam(label = &quot;producer,advanced&quot;, defaultValue = &quot;true&quot;)     private boolean cachedAddress = true;     @UriParam(label = &quot;consumer&quot;)     private boolean clientMode;      /**      * Returns a copy of this configuration      */     public Mina2Configuration copy() {         try {             return (Mina2Configuration) clone();         } catch (CloneNotSupportedException e) {             throw new RuntimeCamelException(e);         }     }      public String getCharsetName() {         if (encoding == null) {             return null;         }         if (!Charset.isSupported(encoding)) {             throw new IllegalArgumentException(&quot;The encoding: &quot; + encoding + &quot; is not supported&quot;);         }          return Charset.forName(encoding).name();     }      public String getProtocol() {         return protocol;     }      /**      * Protocol to use      */     public void setProtocol(String protocol) {         this.protocol = protocol;     }      public String getHost() {         return host;     }      /**      * Hostname to use. Use localhost or 0.0.0.0 for local server as consumer. For producer use the hostname or ip address of the remote server.      */     public void setHost(String host) {         this.host = host;     }      public int getPort() {         return port;     }      /**      * Port number      */     public void setPort(int port) {         this.port = port;     }      public boolean isSync() {         return sync;     }      /**      * Setting to set endpoint as one-way or request-response.      */     public void setSync(boolean sync) {         this.sync = sync;     }      public boolean isTextline() {         return textline;     }      /**      * Only used for TCP. If no codec is specified, you can use this flag to indicate a text line based codec;      * if not specified or the value is false, then Object Serialization is assumed over TCP.      */     public void setTextline(boolean textline) {         this.textline = textline;     }      public Mina2TextLineDelimiter getTextlineDelimiter() {         return textlineDelimiter;     }      /**      * Only used for TCP and if textline=true. Sets the text line delimiter to use.      * If none provided, Camel will use DEFAULT.      * This delimiter is used to mark the end of text.      */     public void setTextlineDelimiter(Mina2TextLineDelimiter textlineDelimiter) {         this.textlineDelimiter = textlineDelimiter;     }      public ProtocolCodecFactory getCodec() {         return codec;     }      /**      * To use a custom minda codec implementation.      */     public void setCodec(ProtocolCodecFactory codec) {         this.codec = codec;     }      public String getEncoding() {         return encoding;     }      /**      * You can configure the encoding (a charset name) to use for the TCP textline codec and the UDP protocol.      * If not provided, Camel will use the JVM default Charset      */     public void setEncoding(String encoding) {         this.encoding = encoding;     }      public long getWriteTimeout() {         return writeTimeout;     }      /**      * Maximum amount of time it should take to send data to the MINA session. Default is 10000 milliseconds.      */     public void setWriteTimeout(long writeTimeout) {         this.writeTimeout = writeTimeout;     }      public long getTimeout() {         return timeout;     }      /**      * You can configure the timeout that specifies how long to wait for a response from a remote server.      * The timeout unit is in milliseconds, so 60000 is 60 seconds.      */     public void setTimeout(long timeout) {         this.timeout = timeout;     }      public boolean isLazySessionCreation() {         return lazySessionCreation;     }      /**      * Sessions can be lazily created to avoid exceptions, if the remote server is not up and running when the Camel producer is started.      */     public void setLazySessionCreation(boolean lazySessionCreation) {         this.lazySessionCreation = lazySessionCreation;     }      public boolean isTransferExchange() {         return transferExchange;     }      /**      * Only used for TCP. You can transfer the exchange over the wire instead of just the body.      * The following fields are transferred: In body, Out body, fault body, In headers, Out headers, fault headers, exchange properties, exchange exception.      * This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.      */     public void setTransferExchange(boolean transferExchange) {         this.transferExchange = transferExchange;     }      /**      * To set the textline protocol encoder max line length. By default the default value of Mina itself is used which are Integer.MAX_VALUE.      */     public void setEncoderMaxLineLength(int encoderMaxLineLength) {         this.encoderMaxLineLength = encoderMaxLineLength;     }      public int getEncoderMaxLineLength() {         return encoderMaxLineLength;     }      /**      * To set the textline protocol decoder max line length. By default the default value of Mina itself is used which are 1024.      */     public void setDecoderMaxLineLength(int decoderMaxLineLength) {         this.decoderMaxLineLength = decoderMaxLineLength;     }      public int getDecoderMaxLineLength() {         return decoderMaxLineLength;     }      public boolean isMinaLogger() {         return minaLogger;     }      /**      * You can enable the Apache MINA logging filter. Apache MINA uses slf4j logging at INFO level to log all input and output.      */     public void setMinaLogger(boolean minaLogger) {         this.minaLogger = minaLogger;     }      public List getFilters() {         return filters;     }      /**      * You can set a list of Mina IoFilters to use.      */     public void setFilters(List filters) {         this.filters = filters;     }      public boolean isDatagramProtocol() {         return protocol.equals(&quot;udp&quot;);     }      /**      * The mina component installs a default codec if both, codec is null and textline is false.      * Setting allowDefaultCodec to false prevents the mina component from installing a default codec as the first element in the filter chain.      * This is useful in scenarios where another filter must be the first in the filter chain, like the SSL filter.      */     public void setAllowDefaultCodec(boolean allowDefaultCodec) {         this.allowDefaultCodec = allowDefaultCodec;     }      public boolean isAllowDefaultCodec() {         return allowDefaultCodec;     }      public boolean isDisconnect() {         return disconnect;     }      /**      * Whether or not to disconnect(close) from Mina session right after use. Can be used for both consumer and producer.      */     public void setDisconnect(boolean disconnect) {         this.disconnect = disconnect;     }      public boolean isDisconnectOnNoReply() {         return disconnectOnNoReply;     }      /**      * If sync is enabled then this option dictates MinaConsumer if it should disconnect where there is no reply to send back.      */     public void setDisconnectOnNoReply(boolean disconnectOnNoReply) {         this.disconnectOnNoReply = disconnectOnNoReply;     }      public LoggingLevel getNoReplyLogLevel() {         return noReplyLogLevel;     }      /**      * If sync is enabled this option dictates MinaConsumer which logging level to use when logging a there is no reply to send back.      */     public void setNoReplyLogLevel(LoggingLevel noReplyLogLevel) {         this.noReplyLogLevel = noReplyLogLevel;     }      public SSLContextParameters getSslContextParameters() {         return sslContextParameters;     }      /**      * To configure SSL security.      */     public void setSslContextParameters(SSLContextParameters sslContextParameters) {         this.sslContextParameters = sslContextParameters;     }      public boolean isAutoStartTls() {         return autoStartTls;     }      /**      * Whether to auto start SSL handshake.      */     public void setAutoStartTls(boolean autoStartTls) {         this.autoStartTls = autoStartTls;     }      public int getMaximumPoolSize() {         return maximumPoolSize;     }      /**      * Number of worker threads in the worker pool for TCP and UDP      */     public void setMaximumPoolSize(int maximumPoolSize) {         this.maximumPoolSize = maximumPoolSize;     }      public boolean isOrderedThreadPoolExecutor() {         return orderedThreadPoolExecutor;     }      /**      * Whether to use ordered thread pool, to ensure events are processed orderly on the same channel.      */     public void setOrderedThreadPoolExecutor(boolean orderedThreadPoolExecutor) {         this.orderedThreadPoolExecutor = orderedThreadPoolExecutor;     }      /**      * Whether to create the InetAddress once and reuse. Setting this to false allows to pickup DNS changes in the network.      */     public void setCachedAddress(boolean shouldCacheAddress) {         this.cachedAddress = shouldCacheAddress;     }      public boolean isCachedAddress() {         return cachedAddress;     }      /**      * If the clientMode is true, mina consumer will connect the address as a TCP client.      */     public void setClientMode(boolean clientMode) {         this.clientMode = clientMode;     }          public boolean isClientMode() {         return clientMode;     }      // here we just shows the option setting of host, port, protocol      public String getUriString() {         return &quot;mina2:&quot; + getProtocol() + &quot;:&quot; + getHost() + &quot;:&quot; + getPort();     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7362</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-mina2/src/main/java/org/apache/camel/component/mina2/Mina2Configuration.java/#L35-L416</td>
    <td align="right">1</td>
    <td align="right">776</td>
    <td align="right">7362</td>
  </tr>
  <tr valign="top">
    <td align="right">5381</td>
    <td align="left">{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;the bad smells are&quot;: [&quot;Data Class&quot;] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Builder {  	public static boolean isForced(Map options) { 		return Boolean.TRUE.equals(options.get(&quot;force&quot;)); 	}  	private Properties options = new Properties(); 	private BuilderExtension[] extensions = new BuilderExtension[0];  	private Logger logger = new NullLogger(); 	private ConfigurationRegistry registry; 	private ConfigObject configObject = null; 	private boolean isIncremental = false; 	private boolean enabledMetadata = false;  	private File sourceDir = null;  	/** 	 * The value is a String[] containing the relative paths of all of the build 	 * files for a given sourceDir. 	 */ 	private final Map buildFilesBySourceDir = new HashMap&lt;&gt;(); 	/*[PR 118220] Incremental builder is not called when file is deleted in base library*/ 	private final Map&gt; deleteFilesBySourceDir = new HashMap&lt;&gt;(); 	private final Map&gt; buildResourcesBySourceDir = new HashMap&lt;&gt;();  	private int buildFileCount = 0; 	private int deleteFileCount = 0; 	private int builtFileCount = 0; 	private int buildResourcesCount = 0; 	private File outputDir = null; 	private boolean verdict = false; 	private boolean includeIfUnsure = false; 	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 	private boolean isTestsBootPath = false; 	private boolean noWarnIncludeIf = false; 	private boolean noWarnInvalidFlags = false; 	private boolean multipleSources = false; 	private boolean updateAllCopyrights = false;  	/** 	 * J9 JCL Preprocessor builder constructor.  Initializes the needed extensions. 	 */ 	public Builder() { 		addExtension(new ExternalMessagesExtension()); 		addExtension(new MacroExtension()); 		addExtension(new JxeRulesExtension()); 		addExtension(new EclipseMetadataExtension()); 		addExtension(new JitAttributesExtension()); 		addExtension(new TagExtension()); 	}  	/** 	 * Sets the preprocess options. 	 * 	 * @param 		options		the preprocess options 	 */ 	public void setOptions(Properties options) { 		if (options != null) { 			this.options.putAll(options); 		} 		this.options = options; 	}  	/** 	 * Returns the preprocess options for this builder. 	 * 	 * @return		the preprocess options 	 */ 	public Properties getOptions() { 		return this.options; 	}  	/** 	 * Adds an extension to the builder. 	 * 	 * @param 		extension	the extension to add 	 */ 	public void addExtension(BuilderExtension extension) { 		if (extension == null) { 			throw new NullPointerException(); 		}  		BuilderExtension[] newExtensions = new BuilderExtension[extensions.length + 1]; 		if (extensions.length &gt; 0) { 			System.arraycopy(extensions, 0, newExtensions, 0, extensions.length); 		} 		newExtensions[newExtensions.length - 1] = extension; 		this.extensions = newExtensions;  		extension.setBuilder(this); 	}  	/** 	 * Returns the builder extensions/ 	 * 	 * @return		the builder extensions 	 */ 	public BuilderExtension[] getExtensions() { 		return extensions; 	}  	/** 	 * Returns the logger associated with this builder. 	 * 	 * @return		the logger 	 */ 	public Logger getLogger() { 		return logger; 	}  	/** 	 * Sets this builder's logger. 	 * 	 * @param 		logger		the new logger 	 */ 	public void setLogger(Logger logger) { 		this.logger = logger; 	}  	/** 	 * Sets whether the build is incremental or not. 	 * 	 * @param 		isIncremental	true if the build is incremental, false otherwise 	 */ 	public void setIncremental(boolean isIncremental) { 		this.isIncremental = isIncremental; 	}  	/** 	 * Returns wheter or not this builder will only do an incremental build. 	 * 	 * @return		true if the build is incremental, false otherwise 	 */ 	public boolean isIncremental() { 		return this.isIncremental; 	}  	/** 	 * Sets whether or not preprocessor metadata will be generated. 	 * 	 * @param 		enabledMetadata		true if metadata is to be generated, 	 * 									false otherwise 	 */ 	public void setMetadata(boolean enabledMetadata) { 		this.enabledMetadata = enabledMetadata; 	}  	/** 	 * Returns whether or not preprocessor metadata is enabled. 	 * 	 * @return		true if metadata will be written, false otherwise 	 */ 	public boolean isMetadataEnabled() { 		return this.enabledMetadata; 	}  	/** 	 * Sets whether or not the preprocessor should include files that do not 	 * have a INCLUDE-IF tag. 	 * 	 * @param 		include		true if files with no INCLUDE-IF should 	 * 							be included, false otherwise 	 */ 	public void setIncludeIfUnsure(boolean include) { 		this.includeIfUnsure = include; 	}  	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 	/** 	 * Sets whether or not the preprocessor is running to generate Tests Boot Path project 	 * 	 * @param 	isTestsBoot		true if preprocessor is running to generate Tests Boot Path project, 	 * 							false otherwise 	 */ 	public void setIsTestsBoot(boolean isTestsBoot) { 		this.isTestsBootPath = isTestsBoot; 	}  	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 	/** 	 * Sets whether or not the preprocessor should give warningsor errors about the files that do not 	 * have a INCLUDE-IF tag. 	 * 	 * @param 		warning		true if files with no INCLUDE-IF should 	 * 							be marked with warning or error, false otherwise 	 */ 	public void setNoWarnIncludeIf(boolean warning) { 		this.noWarnIncludeIf = warning; 	}  	/** 	 * Sets the configuration to preprocess. 	 * 	 * @param 		config		the configuration to preprocess 	 */ 	public void setConfiguration(ConfigObject config) { 		if (config.isSet()) { 			System.err.println(&quot;Warning: Builder is using &quot; + config + &quot;, a set, not a configuration.&quot;); 		} 		this.configObject = config; 		this.registry = config.getRegistry(); 		this.outputDir = config.getOutputDir(); 	}  	/** 	 * Returns this builder's output directory. 	 * 	 * @return		the output directory 	 */ 	public File getOutputDir() { 		return this.outputDir; 	}  	/** 	 * Sets this builder's output directory. 	 * 	 * @param 		outputDir	the new output directory 	 */ 	public void setOutputDir(File outputDir) { 		if (outputDir == null) { 			throw new NullPointerException(); 		} 		this.outputDir = outputDir; 	}  	/** 	 * Returns this builder's configuration source directories. 	 * 	 * @return		the config's source dirs 	 */ 	public File getSourceDir() { 		return this.sourceDir; 	}  	/** 	 * Sets the proprocess job's source directory. 	 * 	 * @param 		sourceDir	the source directory to preprocess 	 */ 	public void setSourceDir(File sourceDir) { 		if (sourceDir == null) { 			throw new NullPointerException(); 		} else { 			this.sourceDir = sourceDir; 		} 	}  	/** 	 * Set builder aware of other sources (to be used by the ExternalMessagesExtension). 	 * 	 * @param 		multipleSources		true if there are other sources, false otherwise 	 */ 	public void setMultipleSources(boolean multipleSources) { 		this.multipleSources = multipleSources; 	}  	/** 	 * Returns whether or not the configuration that setup this builder has multiple sources. 	 * 	 * @return		true if there are other sources, false otherwise 	 */ 	public boolean hasMultipleSources() { 		return multipleSources; 	}  	/** 	 * Performs the build. 	 */ 	public boolean build() { 		//create output dir even if no file is gonna be included in preprocess 		getOutputDir().mkdirs(); 		if (validateOptions()) { 			computeBuildFiles(); 			notifyBuildBegin();  			PreprocessorFactory factory = newPreprocessorFactory(); 			boolean force = isForced(this.options);  			//Ignore folders that do not exist (warning thrown in computeBuildFiles() 			if (sourceDir != null) { 				File metadataDir = new File(outputDir.getParentFile(), &quot;jppmd&quot;); 				String[] buildFiles = buildFilesBySourceDir.get(sourceDir); 				getLogger().log(&quot;\nPreprocessing &quot; + sourceDir.getAbsolutePath(), 1); 				builtFileCount = 0;  				for (String buildFile : buildFiles) { 					File sourceFile = new File(sourceDir, buildFile); 					File outputFile = new File(outputDir, buildFile); 					File metadataFile = new File(metadataDir, buildFile + &quot;.jppmd&quot;);  					notifyBuildFileBegin(sourceFile, outputFile, buildFile);  					try (OutputStream metadataOutput = new PhantomOutputStream(metadataFile); 						 OutputStream output = new PhantomOutputStream(outputFile, force)) {  						// configure the preprocessor and let extensions do the same 						JavaPreprocessor jpp;  						if (enabledMetadata) { 							jpp = factory.newPreprocessor(metadataOutput, sourceFile, output, outputFile); 						} else { 							jpp = factory.newPreprocessor(sourceFile, output); 						}  						Calendar cal = new GregorianCalendar(); 						if (!updateAllCopyrights) { 							cal.setTime(new Date(sourceFile.lastModified())); 						} 						jpp.setCopyrightYear(cal.get(Calendar.YEAR)); 						jpp.addValidFlags(registry.getValidFlags()); 						/*[PR 120411] Use a javadoc tag instead of TestBootpath preprocessor tag*/ 						jpp.setTestBootPath(isTestsBootPath); 						notifyConfigurePreprocessor(jpp);  						// preprocess 						boolean included = false; 						try { 							included = jpp.preprocess(); 							if (included) { 								builtFileCount++; 							} 							handlePreprocessorWarnings(jpp, sourceFile); 						} catch (Throwable t) { 							handlePreprocessorException(t, sourceFile); 						}  						if (!included &amp;&amp; outputFile.exists()) { 							outputFile.delete(); 						}  						if (!included &amp;&amp; metadataFile.exists()) { 							metadataFile.delete(); 						} 					} catch (Throwable t) { 						getLogger().log(&quot;Exception occured in file &quot; + sourceFile.getAbsolutePath() + &quot;, preprocess failed.&quot;, 3, t); 						handleBuildException(t); 					} finally { 						notifyBuildFileEnd(sourceFile, outputFile, buildFile); 					} 				}  				logger.log(builtFileCount + &quot; of &quot; + buildFileCount + &quot; file(s) included in preprocess&quot;, 1);  				/*[PR 118220] Incremental builder is not called when file is deleted in base library*/ 				List deleteFiles = deleteFilesBySourceDir.get(sourceDir); 				if (deleteFiles != null &amp;&amp; deleteFiles.size() != 0) { 					int deletedFilesCount = 0; 					for (String file : deleteFiles) { 						File deleteFile = new File(outputDir, file); 						if (deleteFile.exists()) { 							deletedFilesCount++; 							deleteFile.delete(); 						} 					} 					getLogger().log(deletedFilesCount + &quot; of &quot; + deleteFileCount 							+ &quot; file(s) deleted in preprocess from &quot; + outputDir.getAbsolutePath(), 1); 				} 			} 			/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 			List buildResources = buildResourcesBySourceDir.get(sourceDir); 			if (buildResources != null &amp;&amp; buildResources.size() != 0) { 				int copiedResourcesCount = 0; 				int deletedResorucesCount = 0; 				String outputpath; 				if (isTestsBootPath) { 					outputpath = configObject.getBootTestsOutputPath(); 				} else { 					outputpath = configObject.getTestsOutputPath(); 				} 				for (String file : buildResources) { 					File resource_out = new File(outputpath, file); 					File resource_src = new File(sourceDir, file); 					if (resource_src.exists()) { 						copyResource(resource_src, resource_out); 						copiedResourcesCount++; 					} else { 						resource_out.delete(); 						deletedResorucesCount++; 					} 				}  				getLogger().log(&quot;Total Build Resource Count : &quot; + buildResourcesCount, 1); 				getLogger().log(&quot;  - &quot; + copiedResourcesCount + &quot; resource&quot; + (copiedResourcesCount &gt; 1 ? &quot;s are &quot; : &quot; is &quot;) + &quot;copied to &quot; + outputpath, 1); 				getLogger().log(&quot;  - &quot; + deletedResorucesCount + &quot; resource&quot; + (deletedResorucesCount &gt; 1 ? &quot;s are &quot; : &quot; is &quot;) + &quot;deleted from &quot; + outputpath, 1); 			}  			notifyBuildEnd(); 		}  		if (logger.getErrorCount() == 0) { 			if (verdict) { 				getLogger().log(&quot;PREPROCESS WAS SUCCESSFUL&quot;, 1); 			} 			return true; 		} else { 			if (verdict) { 				getLogger().log(&quot;PREPROCESS WAS NOT SUCCESSFUL&quot;, 1); 			} 			return false; 		} 	}  	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 	public static void copyResource(File source, File destination) { 		destination.delete();  		try { 			SimpleCopy.copyFile(source, destination); 		} catch (IOException e) { 			System.err.println(&quot;ERROR - Could not copy the file to destination&quot;); 			System.err.println(&quot;   Source: &quot; + source.toString()); 			System.err.println(&quot;   Destination: &quot; + destination.toString()); 			e.printStackTrace(); 		} 	}  	/** 	 * Validates the build options. 	 */ 	private boolean validateOptions() { 		boolean isValid = true;  		if (configObject == null) { 			configObject = registry.getConfiguration(options.getProperty(&quot;config&quot;)); 		} 		this.options.putAll(configObject.getOptions());  		// check for the verdict option 		if (options.containsKey(&quot;verdict&quot;)) { 			this.verdict = true; 		}  		if (options.containsKey(&quot;includeifunsure&quot;)) { 			setIncludeIfUnsure(true); 		} 		if (options.containsKey(&quot;nowarnincludeif&quot;)) { 			setNoWarnIncludeIf(true); 		}  		if (options.containsKey(&quot;nowarninvalidflags&quot;)) { 			this.noWarnInvalidFlags = true; 		}  		if (options.containsKey(&quot;updateallcopyrights&quot;)) { 			this.updateAllCopyrights = true; 		}  		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				extension.validateOptions(this.options); 			} 		} catch (BuilderConfigurationException e) { 			logger.log(&quot;A configuration exception occured&quot;, Logger.SEVERITY_FATAL, e); 			isValid = false; 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking validateOptions() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 		return isValid; 	}  	/** 	 * Notifies the extensions that the build is beginning. 	 */ 	private void notifyBuildBegin() { 		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyBuildBegin(); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyBuildBegin() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Notifies the extensions that the build is ending. 	 */ 	private void notifyBuildEnd() { 		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyBuildEnd(); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyBuildEnd() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Notifies the extensions that the build is beginning on the specified 	 * file. 	 */ 	private void notifyBuildFileBegin(File sourceFile, File outputFile, String relativePath) { 		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyBuildFileBegin(sourceFile, outputFile, relativePath); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyBuildFileBegin() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Notifies the extensions that the build is ending on the specified file. 	 */ 	private void notifyBuildFileEnd(File sourceFile, File outputFile, String relativePath) { 		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyBuildFileEnd(sourceFile, outputFile, relativePath); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyBuildFileEnd() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Notifies the extensions that they should configure the preprocessor. 	 */ 	private void notifyConfigurePreprocessor(JavaPreprocessor preprocessor) { 		preprocessor.setIncludeIfUnsure(this.includeIfUnsure); 		preprocessor.setNoWarnIncludeIf(this.noWarnIncludeIf);  		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyConfigurePreprocessor(preprocessor); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyConfigurePreprocessor() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Handles exceptions thrown while building. 	 */ 	private void handleBuildException(Throwable t) { 		if (t instanceof Error) { 			logger.log(&quot;An error occured while building&quot;, Logger.SEVERITY_FATAL, t); 			throw (Error) t; 		} else { 			logger.log(&quot;An exception occured while building&quot;, Logger.SEVERITY_ERROR, t); 		} 	}  	/** 	 * Handles exceptions thrown by the preprocessor. 	 */ 	private void handlePreprocessorException(Throwable t, File sourceFile) { 		if (t instanceof Error) { 			logger.log(&quot;An error occured while invoking the preprocessor&quot;, &quot;preprocessor&quot;, Logger.SEVERITY_FATAL, sourceFile, t); 			throw (Error) t; 		} else { 			logger.log(&quot;An exception occured while invoking the preprocessor&quot;, &quot;preprocessor&quot;, Logger.SEVERITY_ERROR, sourceFile, t); 		} 	}  	/** 	 * Handles warnings generated by the preprocessor. 	 */ 	private void handlePreprocessorWarnings(JavaPreprocessor jpp, File sourceFile) { 		if (jpp.hasWarnings()) { 			for (PreprocessorWarning warning : jpp.getWarnings()) { 				int severity = warning.shouldFail() ? Logger.SEVERITY_ERROR : Logger.SEVERITY_WARNING; 				/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 				if (warning.getMessage().startsWith(&quot;No INCLUDE-IF&quot;) &amp;&amp; sourceFile.getAbsolutePath().endsWith(&quot;.java&quot;) &amp;&amp; !includeIfUnsure &amp;&amp; !isTestsBootPath) { 					severity = Logger.SEVERITY_ERROR; 				}  				if (warning.getMessage().startsWith(&quot;Ignoring copyright&quot;)) { 					severity = Logger.SEVERITY_INFO; 				}  				logger.log(warning.getMessage(), &quot;preprocessor&quot;, severity, sourceFile, warning.getLine(), warning.getCharstart(), warning.getCharend()); 			} 		}  		if (!noWarnInvalidFlags) { 			for (PreprocessorWarning warning : jpp.getInvalidFlags()) { 				logger.log(warning.getMessage(), &quot;preprocessor&quot;, Logger.SEVERITY_ERROR, sourceFile, warning.getLine(), warning.getCharstart(), warning.getCharend()); 			} 		} 	}  	/** 	 * Determines whether the specified source file should be built. 	 */ 	private boolean shouldBuild(File sourceFile, File outputFile, String relativePath) { 		// call the method for all the extensions 		for (BuilderExtension extension : extensions) { 			logger.setMessageSource(extension.getName()); 			boolean shouldBuild = extension.shouldBuild(sourceFile, outputFile, relativePath); 			logger.setMessageSource(null); 			if (!shouldBuild) { 				return false; 			} 		}  		return true; 	}  	/*[PR 118220] Incremental builder is not called when file is deleted in base library*/ 	/** 	 * Returns the deleted Files 	 */ 	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 	private List getDeletedFiles(File sourceDir) { 		// call the method for all the extensions 		for (BuilderExtension extension : extensions) { 			logger.setMessageSource(extension.getName()); 			List elements = extension.getDeleteFiles(sourceDir); 			logger.setMessageSource(null); 			if (elements != null) { 				return elements; 			} 		}  		return null; 	}  	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 	private List getBuildResources(File sourceDir) { 		// call the method for all the extensions 		for (BuilderExtension extension : extensions) { 			logger.setMessageSource(extension.getName()); 			List elements = extension.getBuildResources(sourceDir); 			logger.setMessageSource(null); 			if (elements != null) { 				return elements; 			} 		} 		return null; 	}  	/** 	 * Creates a new PreprocessorFactory object. 	 */ 	private PreprocessorFactory newPreprocessorFactory() { 		PreprocessorFactory factory = new PreprocessorFactory(); 		/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 		factory.setFlags(this.configObject.getFlagsAsArray()); 		factory.setRequiredIncludeFlags(this.configObject.getRequiredIncludeFlagSet()); 		return factory; 	}  	/** 	 * Recursively searches the given root directory to find all files. The file 	 * paths are returned, relative to the root directory. 	 */ 	private List getFiles(File rootDirectory) { 		List fileList = new ArrayList&lt;&gt;(); 		File[] files = rootDirectory.listFiles();  		if (files == null) { 			StringBuffer msg = new StringBuffer(&quot;Error reading the source directory \&quot;&quot;); 			msg.append(rootDirectory.getAbsolutePath()); 			msg.append(&quot;\&quot; - No Files copied&quot;); 			getLogger().log(msg.toString(), 2); 			verdict = false; 		} else { 			getFiles(files, &quot;&quot;, fileList); 		}  		return fileList; 	}  	/** 	 * This is a helper function to getFiles(File); 	 */ 	private static void getFiles(File[] files, String relativePath, List fileList) { 		for (File file : files) { 			if (file.isFile()) { 				fileList.add(relativePath + file.getName()); 			} else { 				String childRelativePath = relativePath + file.getName() + File.separator; 				getFiles(file.listFiles(), childRelativePath, fileList); 			} 		} 	}  	private void computeBuildFiles() { 		if (sourceDir.exists()) { 			List allFiles = getFiles(sourceDir); 			List buildFiles = new ArrayList&lt;&gt;(allFiles.size()); 			for (int j = 0; j &lt; allFiles.size(); j++) { 				String currentFile = allFiles.get(j).toString(); 				if (shouldBuild(sourceDir, outputDir, currentFile)) { 					buildFiles.add(currentFile); 				} 			}  			String[] buildFilesArray = buildFiles.toArray(new String[buildFiles.size()]); 			buildFilesBySourceDir.put(sourceDir, buildFilesArray); 			buildFileCount += buildFilesArray.length; 			/*[PR 118220] Incremental builder is not called when file is deleted in base library*/ 			/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 			List deleteFiles = getDeletedFiles(sourceDir); 			if (deleteFiles != null &amp;&amp; deleteFiles.size() != 0) { 				deleteFileCount = deleteFiles.size(); 				deleteFilesBySourceDir.put(sourceDir, deleteFiles); 			}  			List buildResources = getBuildResources(sourceDir); 			if (buildResources != null &amp;&amp; buildResources.size() != 0) { 				buildResourcesCount = buildResources.size(); 				buildResourcesBySourceDir.put(sourceDir, buildResources); 			} 		} else { 			logger.log(&quot;Error: Source directory does not exist: &quot; + sourceDir.getAbsolutePath(), Logger.SEVERITY_ERROR, new NullPointerException()); 			sourceDir = null; 		} 	}  	/** 	 * Returns the number of files preprocessed. 	 * 	 * @return		the number of files preprocessed 	 */ 	public int getBuildFileCount() { 		return buildFileCount; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15120</td>
    <td align="left">https://github.com/eclipse/openj9/blob/4911084853eb75b20e037c434ad4521b7317ebfb/sourcetools/com.ibm.jpp.preprocessor/com/ibm/jpp/om/Builder.java/#L41-L806</td>
    <td align="right">1</td>
    <td align="right">5381</td>
    <td align="right">15120</td>
  </tr>
  <tr valign="top">
    <td align="right">1724</td>
    <td align="left">&nbsp;{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Long Method&quot;,     &quot;Blob&quot;,     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class BinaryExpression implements Expression {     protected Expression left;     protected Expression right;      public BinaryExpression(Expression left, Expression right) {         this.left = left;         this.right = right;     }      public Expression getLeft() {         return left;     }      public Expression getRight() {         return right;     }       /**      * @see java.lang.Object#toString()      */     public String toString() {         return &quot;(&quot; + left.toString() + &quot; &quot; + getExpressionSymbol() + &quot; &quot; + right.toString() + &quot;)&quot;;     }      /**      * TODO: more efficient hashCode()      *      * @see java.lang.Object#hashCode()      */     public int hashCode() {         return toString().hashCode();     }      /**      * TODO: more efficient hashCode()      *      * @see java.lang.Object#equals(java.lang.Object)      */     public boolean equals(Object o) {          if (o == null || !this.getClass().equals(o.getClass())) {             return false;         }         return toString().equals(o.toString());      }      /**      * Returns the symbol that represents this binary expression.  For example, addition is      * represented by &quot;+&quot;      *      * @return      */     public abstract String getExpressionSymbol();      /**      * @param expression      */     public void setRight(Expression expression) {         right = expression;     }      /**      * @param expression      */     public void setLeft(Expression expression) {         left = expression;     }      }</td>
    <td align="left">data class</td>
    <td align="left">Long Method, Blob, Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">Long Method,  Blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11803</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-client/src/main/java/org/apache/activemq/filter/BinaryExpression.java/#L26-L96</td>
    <td align="right">1</td>
    <td align="right">1724</td>
    <td align="right">11803</td>
  </tr>
  <tr valign="top">
    <td align="right">1771</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Component public class VirtualMachineEntityImpl implements VirtualMachineEntity {      @Inject     private VMEntityManager manager;      private VMEntityVO vmEntityVO;      public VirtualMachineEntityImpl() {     }      public void init(String vmId) {         this.vmEntityVO = this.manager.loadVirtualMachine(vmId);     }      public void init(String vmId, String owner, String hostName, String displayName, int cpu, int speed, long memory, List computeTags,         List rootDiskTags, List networks) {         init(vmId);         this.vmEntityVO.setOwner(owner);         this.vmEntityVO.setHostname(hostName);         this.vmEntityVO.setDisplayname(displayName);         this.vmEntityVO.setComputeTags(computeTags);         this.vmEntityVO.setRootDiskTags(rootDiskTags);         this.vmEntityVO.setNetworkIds(networks);          manager.saveVirtualMachine(vmEntityVO);     }      public VirtualMachineEntityImpl(String vmId, VMEntityManager manager) {         this.manager = manager;         this.vmEntityVO = this.manager.loadVirtualMachine(vmId);     }      public VirtualMachineEntityImpl(String vmId, String owner, String hostName, String displayName, int cpu, int speed, long memory, List computeTags,             List rootDiskTags, List networks, VMEntityManager manager) {         this(vmId, manager);         this.vmEntityVO.setOwner(owner);         this.vmEntityVO.setHostname(hostName);         this.vmEntityVO.setDisplayname(displayName);         this.vmEntityVO.setComputeTags(computeTags);         this.vmEntityVO.setRootDiskTags(rootDiskTags);         this.vmEntityVO.setNetworkIds(networks);          manager.saveVirtualMachine(vmEntityVO);     }      @Override     public String getUuid() {         return vmEntityVO.getUuid();     }      @Override     public long getId() {         return vmEntityVO.getId();     }      @Override     public String getCurrentState() {         // TODO Auto-generated method stub         return null;     }      @Override     public String getDesiredState() {         // TODO Auto-generated method stub         return null;     }      @Override     public Date getCreatedTime() {         return vmEntityVO.getCreated();     }      @Override     public Date getLastUpdatedTime() {         return vmEntityVO.getUpdateTime();     }      @Override     public String getOwner() {         // TODO Auto-generated method stub         return null;     }      @Override     public Map getDetails() {         return vmEntityVO.getDetails();     }      @Override     public void addDetail(String name, String value) {         vmEntityVO.setDetail(name, value);     }      @Override     public void delDetail(String name, String value) {         // TODO Auto-generated method stub     }      @Override     public void updateDetail(String name, String value) {         // TODO Auto-generated method stub     }      @Override     public List getApplicableActions() {         // TODO Auto-generated method stub         return null;     }      @Override     public List listVolumeIds() {         // TODO Auto-generated method stub         return null;     }      @Override     public List listVolumes() {         // TODO Auto-generated method stub         return null;     }      @Override     public List listNicUuids() {         // TODO Auto-generated method stub         return null;     }      @Override     public List listNics() {         // TODO Auto-generated method stub         return null;     }      @Override     public TemplateEntity getTemplate() {         // TODO Auto-generated method stub         return null;     }      @Override     public List listTags() {         // TODO Auto-generated method stub         return null;     }      @Override     public void addTag() {         // TODO Auto-generated method stub      }      @Override     public void delTag() {         // TODO Auto-generated method stub      }      @Override     public String reserve(DeploymentPlanner plannerToUse, DeploymentPlan plan, ExcludeList exclude, String caller) throws InsufficientCapacityException,         ResourceUnavailableException {         return manager.reserveVirtualMachine(this.vmEntityVO, plannerToUse, plan, exclude);     }      @Override     public void migrateTo(String reservationId, String caller) {         // TODO Auto-generated method stub      }      @Override     public void deploy(String reservationId, String caller, Map params, boolean deployOnGivenHost) throws InsufficientCapacityException,         ResourceUnavailableException {         manager.deployVirtualMachine(reservationId, this.vmEntityVO, caller, params, deployOnGivenHost);     }      @Override     public boolean stop(String caller) throws ResourceUnavailableException {         return manager.stopvirtualmachine(this.vmEntityVO, caller);     }      @Override     public boolean stopForced(String caller) throws ResourceUnavailableException {         return manager.stopvirtualmachineforced(this.vmEntityVO, caller);     }      @Override     public void cleanup() {         // TODO Auto-generated method stub      }      @Override     public boolean destroy(String caller, boolean expunge) throws AgentUnavailableException, OperationTimedoutException, ConcurrentOperationException {         return manager.destroyVirtualMachine(this.vmEntityVO, caller, expunge);     }      @Override     public VirtualMachineEntity duplicate(String externalId) {         // TODO Auto-generated method stub         return null;     }      @Override     public SnapshotEntity takeSnapshotOf() {         // TODO Auto-generated method stub         return null;     }      @Override     public void attach(VolumeEntity volume, short deviceId) {         // TODO Auto-generated method stub      }      @Override     public void detach(VolumeEntity volume) {         // TODO Auto-generated method stub      }      @Override     public void connectTo(NetworkEntity network, short nicId) {         // TODO Auto-generated method stub      }      @Override     public void disconnectFrom(NetworkEntity netowrk, short nicId) {         // TODO Auto-generated method stub      }  }</td>
    <td align="left">data class</td>
    <td align="left">Long Method, Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11920</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/engine/orchestration/src/main/java/org/apache/cloudstack/engine/cloud/entity/api/VirtualMachineEntityImpl.java/#L39-L272</td>
    <td align="right">1</td>
    <td align="right">1771</td>
    <td align="right">11920</td>
  </tr>
  <tr valign="top">
    <td align="right">955</td>
    <td align="left">&nbsp;{&quot;message&quot;:&quot;YES I found bad smells&quot;,&quot;bad smells are&quot;:[&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MultiResponse200 {   private String message;    private int code;    private long t200;    public String getMessage() {     return message;   }    public void setMessage(String message) {     this.message = message;   }    public int getCode() {     return code;   }    public void setCode(int code) {     this.code = code;   }    public long getT200() {     return t200;   }    public void setT200(long t200) {     this.t200 = t200;   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8535</td>
    <td align="left">https://github.com/apache/servicecomb-java-chassis/blob/72cd0e137c4a0c3b899adfa6e19e2fd590743014/demo/demo-schema/src/main/java/org/apache/servicecomb/demo/multiErrorCode/MultiResponse200.java/#L20-L50</td>
    <td align="right">1</td>
    <td align="right">955</td>
    <td align="right">8535</td>
  </tr>
  <tr valign="top">
    <td align="right">983</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;, &quot;Data Class&quot;]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class WSS4JInInterceptorFactory {      private Properties properties;      public Properties getProperties() {         return properties;     }      public void setProperties(Properties properties) {         this.properties = properties;     }      public WSS4JInInterceptor create() {         final Map map = new HashMap();         for (Map.Entry entry : properties.entrySet()) {             map.put(entry.getKey().toString(), entry.getValue());         }         properties.clear();         return new WSS4JInInterceptor(map);     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8862</td>
    <td align="left">https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/server/openejb-cxf/src/main/java/org/apache/openejb/server/cxf/config/WSS4JInInterceptorFactory.java/#L28-L48</td>
    <td align="right">1</td>
    <td align="right">983</td>
    <td align="right">8862</td>
  </tr>
  <tr valign="top">
    <td align="right">1082</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class FileSystemFactoryBean implements InitializingBean, DisposableBean, FactoryBean {  	private FileSystem fs; 	private Configuration configuration; 	private URI uri; 	private String user; 	private boolean closeAll = false; 	private boolean close = true;  	public void afterPropertiesSet() throws Exception { 		Configuration cfg = (configuration != null ? configuration : new Configuration(true)); 		if (uri == null) { 			uri = FileSystem.getDefaultUri(cfg); 		} 		if (StringUtils.hasText(user)) { 			fs = FileSystem.get(uri, cfg, user); 		} 		else { 			fs = FileSystem.get(uri, cfg); 		} 	}  	public void destroy() throws Exception { 		if (fs != null &amp;&amp; close) { 			fs.close(); 		} 		fs = null;  		if (closeAll) { 			// TODO: potentially call close all just for the current user 			FileSystem.closeAll(); 		} 	}   	public FileSystem getObject() throws Exception { 		return fs; 	}  	public Class getObjectType() { 		return (fs != null ? fs.getClass() : FileSystem.class); 	}  	public boolean isSingleton() { 		return true; 	}  	/** 	 * Sets the Hadoop configuration for this file system. 	 *  	 * @param configuration The configuration to set. 	 */ 	public void setConfiguration(Configuration configuration) { 		this.configuration = configuration; 	}  	/** 	 * Sets the URI (if available) for this file system. 	 *  	 * @param uri The uri to set. 	 */ 	public void setUri(URI uri) { 		this.uri = uri; 	}  	/** 	 * Sets the user impersonation (optional) for creating this file-system. 	 * Should be used when running against a Hadoop Kerberos cluster.  	 *  	 * @param user user/group information 	 */ 	public void setUser(String user) { 		this.user = user; 	}  	/** 	 * Indicates whether all the Hadoop file systems should be closed once this factory is destroyed. 	 * False by default - should be turned on as a safety measure when the app controls the entire lifecycle of Hadoop inside 	 * a JVM. 	 * 	 * @param closeAll the close all 	 * @see FileSystem#closeAll() 	 */ 	public void setCloseAll(boolean closeAll) { 		this.closeAll = closeAll; 	}  	/** 	 * Indicates whether the Hadoop file systems should be closed once this factory is destroyed. 	 * True by default - should be turned off when running 'embedded' or if long running operations outlive the application context. 	 * 	 * @param close close 	 * @see FileSystem#close() 	 */ 	public void setClose(boolean close) { 		this.close = close; 	} }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9684</td>
    <td align="left">https://github.com/spring-projects/spring-hadoop/blob/cda92b8ab6b5e8a8defe8ae5822e966e0a9d34eb/spring-hadoop-core/src/main/java/org/springframework/data/hadoop/fs/FileSystemFactoryBean.java/#L34-L131</td>
    <td align="right">1</td>
    <td align="right">1082</td>
    <td align="right">9684</td>
  </tr>
  <tr valign="top">
    <td align="right">2565</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ExtendedCompletionList {   private boolean inComplete;   private List items;    public ExtendedCompletionList(boolean incomplete, List items) {     this.inComplete = incomplete;     this.items = items;   }    public ExtendedCompletionList() {}    public List getItems() {     return items;   }    public void setItems(List items) {     this.items = items;   }    public boolean isInComplete() {     return inComplete;   }    public void setInComplete(boolean inComplete) {     this.inComplete = inComplete;   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14856</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/wsagent/che-core-api-languageserver-shared/src/main/java/org/eclipse/che/api/languageserver/shared/model/ExtendedCompletionList.java/#L22-L48</td>
    <td align="right">1</td>
    <td align="right">2565</td>
    <td align="right">14856</td>
  </tr>
  <tr valign="top">
    <td align="right">1450</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: {             &quot;1. Data Class&quot;        	:         &quot;2. Long Method&quot;         }     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  @Immutable   public static final class Result {      /** Outcome categories for individual DN lines. */     public enum Outcome { OK, WARNING, ERROR }      private final int code;     private final String description;     private final Outcome outcome;      private Result(int code, String description) {       this.code = code;       this.description = description;       if (2000 &lt;= code &amp;&amp; code &lt;= 2099) {         this.outcome = Outcome.OK;       } else if (3500 &lt;= code &amp;&amp; code &lt;= 3699) {         this.outcome = Outcome.WARNING;       } else if (4500 &lt;= code &amp;&amp; code &lt;= 4699) {         this.outcome = Outcome.ERROR;       } else {         throw new IllegalArgumentException(&quot;Invalid DN result code: &quot; + code);       }     }      public int getCode() {       return code;     }      public String getDescription() {       return description;     }      public Outcome getOutcome() {       return outcome;     }      @Override     public String toString() {       return toStringHelper(this)           .add(&quot;code&quot;, code)           .add(&quot;outcome&quot;, outcome)           .add(&quot;description&quot;, description)           .toString();     }   }</td>
    <td align="left">data class</td>
    <td align="left">1. data class: 2. long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10993</td>
    <td align="left">https://github.com/google/nomulus/blob/2481704d00f10f6b5675dd26f9effaad434ddbea/java/google/registry/tmch/LordnLog.java/#L45-L89</td>
    <td align="right">1</td>
    <td align="right">1450</td>
    <td align="right">10993</td>
  </tr>
  <tr valign="top">
    <td align="right">1165</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ReloadingFileBasedConfigurationBuilder         extends FileBasedConfigurationBuilder implements ReloadingControllerSupport {     /** The default factory for creating reloading detector objects. */     private static final ReloadingDetectorFactory DEFAULT_DETECTOR_FACTORY =             new DefaultReloadingDetectorFactory();      /** The reloading controller associated with this object. */     private final ReloadingController reloadingController;      /**      * The reloading detector which does the actual reload check for the current      * result object. A new instance is created whenever a new result object      * (and thus a new current file handler) becomes available. The field must      * be volatile because it is accessed by the reloading controller probably      * from within another thread.      */     private volatile ReloadingDetector resultReloadingDetector;      /**      * Creates a new instance of {@code ReloadingFileBasedConfigurationBuilder}      * which produces result objects of the specified class and sets      * initialization parameters.      *      * @param resCls the result class (must not be null      * @param params a map with initialization parameters      * @throws IllegalArgumentException if the result class is null      */     public ReloadingFileBasedConfigurationBuilder(final Class resCls,             final Map params)     {         super(resCls, params);         reloadingController = createReloadingController();     }      /**      * Creates a new instance of {@code ReloadingFileBasedConfigurationBuilder}      * which produces result objects of the specified class and sets      * initialization parameters and the allowFailOnInit flag.      *      * @param resCls the result class (must not be null      * @param params a map with initialization parameters      * @param allowFailOnInit the allowFailOnInit flag      * @throws IllegalArgumentException if the result class is null      */     public ReloadingFileBasedConfigurationBuilder(final Class resCls,             final Map params, final boolean allowFailOnInit)     {         super(resCls, params, allowFailOnInit);         reloadingController = createReloadingController();     }      /**      * Creates a new instance of {@code ReloadingFileBasedConfigurationBuilder}      * which produces result objects of the specified class.      *      * @param resCls the result class (must not be null      * @throws IllegalArgumentException if the result class is null      */     public ReloadingFileBasedConfigurationBuilder(final Class resCls)     {         super(resCls);         reloadingController = createReloadingController();     }      /**      * Returns the {@code ReloadingController} associated with this builder.      * This controller is directly created. However, it becomes active (i.e.      * associated with a meaningful reloading detector) not before a result      * object was created.      *      * @return the {@code ReloadingController}      */     @Override     public ReloadingController getReloadingController()     {         return reloadingController;     }      /**      * {@inheritDoc} This method is overridden here to change the result type.      */     @Override     public ReloadingFileBasedConfigurationBuilder configure(             final BuilderParameters... params)     {         super.configure(params);         return this;     }      /**      * Creates a {@code ReloadingDetector} which monitors the passed in      * {@code FileHandler}. This method is called each time a new result object      * is created with the current {@code FileHandler}. This implementation      * checks whether a {@code ReloadingDetectorFactory} is specified in the      * current parameters. If this is the case, it is invoked. Otherwise, a      * default factory is used to create a {@code FileHandlerReloadingDetector}      * object. Note: This method is called from a synchronized block.      *      * @param handler the current {@code FileHandler}      * @param fbparams the object with parameters related to file-based builders      * @return a {@code ReloadingDetector} for this {@code FileHandler}      * @throws ConfigurationException if an error occurs      */     protected ReloadingDetector createReloadingDetector(final FileHandler handler,             final FileBasedBuilderParametersImpl fbparams)             throws ConfigurationException     {         return fetchDetectorFactory(fbparams).createReloadingDetector(handler,                 fbparams);     }      /**      * {@inheritDoc} This implementation also takes care that a new      * {@code ReloadingDetector} for the new current {@code FileHandler} is      * created. Also, the reloading controller's reloading state has to be      * reset; after the creation of a new result object changes in the      * underlying configuration source have to be monitored again.      */     @Override     protected void initFileHandler(final FileHandler handler)             throws ConfigurationException     {         super.initFileHandler(handler);          resultReloadingDetector =                 createReloadingDetector(handler,                         FileBasedBuilderParametersImpl.fromParameters(                                 getParameters(), true));     }      /**      * Creates the {@code ReloadingController} associated with this object. The      * controller is assigned a specialized reloading detector which delegates      * to the detector for the current result object. (      * {@code FileHandlerReloadingDetector} does not support changing the file      * handler, and {@code ReloadingController} does not support changing the      * reloading detector; therefore, this level of indirection is needed to      * change the monitored file dynamically.)      *      * @return the new {@code ReloadingController}      */     private ReloadingController createReloadingController()     {         final ReloadingDetector ctrlDetector = createReloadingDetectorForController();         final ReloadingController ctrl = new ReloadingController(ctrlDetector);         connectToReloadingController(ctrl);         return ctrl;     }      /**      * Creates a {@code ReloadingDetector} wrapper to be passed to the      * associated {@code ReloadingController}. This detector wrapper simply      * delegates to the current {@code ReloadingDetector} if it is available.      *      * @return the wrapper {@code ReloadingDetector}      */     private ReloadingDetector createReloadingDetectorForController()     {         return new ReloadingDetector()         {             @Override             public void reloadingPerformed()             {                 final ReloadingDetector detector = resultReloadingDetector;                 if (detector != null)                 {                     detector.reloadingPerformed();                 }             }              @Override             public boolean isReloadingRequired()             {                 final ReloadingDetector detector = resultReloadingDetector;                 return (detector != null) &amp;&amp; detector.isReloadingRequired();             }         };     }      /**      * Returns a {@code ReloadingDetectorFactory} either from the passed in      * parameters or a default factory.      *      * @param params the current parameters object      * @return the {@code ReloadingDetectorFactory} to be used      */     private static ReloadingDetectorFactory fetchDetectorFactory(             final FileBasedBuilderParametersImpl params)     {         final ReloadingDetectorFactory factory = params.getReloadingDetectorFactory();         return (factory != null) ? factory : DEFAULT_DETECTOR_FACTORY;     } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10183</td>
    <td align="left">https://github.com/apache/commons-configuration/blob/34357e075d63c3634310878636f9498847badcab/src/main/java/org/apache/commons/configuration2/builder/ReloadingFileBasedConfigurationBuilder.java/#L62-L255</td>
    <td align="right">1</td>
    <td align="right">1165</td>
    <td align="right">10183</td>
  </tr>
  <tr valign="top">
    <td align="right">596</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SpringComponent @VaadinSessionScope public class ManageSoftwareModuleFilters implements Serializable {      private static final long serialVersionUID = -1631725636290496525L;      private SoftwareModuleType softwareModuleType;      private String searchText;      /**      * @return the softwareModuleType      */     public Optional getSoftwareModuleType() {         return Optional.ofNullable(softwareModuleType);     }      /**      * @param softwareModuleType      *            the softwareModuleType to set      */     public void setSoftwareModuleType(final SoftwareModuleType softwareModuleType) {         this.softwareModuleType = softwareModuleType;     }      /**      * @return the searchText      */     public Optional getSearchText() {         return Optional.ofNullable(searchText);     }      /**      * @param searchText      *            the searchText to set      */     public void setSearchText(final String searchText) {         this.searchText = searchText;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5950</td>
    <td align="left">https://github.com/eclipse/hawkbit/blob/51be28147f6f575b6c1ab4a5ef84ffd9174f1209/hawkbit-ui/src/main/java/org/eclipse/hawkbit/ui/distributions/state/ManageSoftwareModuleFilters.java/#L23-L62</td>
    <td align="right">1</td>
    <td align="right">596</td>
    <td align="right">5950</td>
  </tr>
  <tr valign="top">
    <td align="right">59</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SysInfo implements Serializable {      static final long serialVersionUID = -3096346807579L;      public int numCores;     public long maxMemory;      public SysInfo(int nc, long mm) {         numCores = nc;         maxMemory = mm;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1004</td>
    <td align="left">https://github.com/google/error-prone-javac/blob/a53d069bbdb2c60232ed3811c19b65e41c3e60e0/src/jdk.compiler/share/classes/com/sun/tools/sjavac/server/SysInfo.java/#L45-L56</td>
    <td align="right">1</td>
    <td align="right">59</td>
    <td align="right">1004</td>
  </tr>
  <tr valign="top">
    <td align="right">2333</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;the bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class HistoryClientService extends AbstractService {    private static final Log LOG = LogFactory.getLog(HistoryClientService.class);    private HSClientProtocol protocolHandler;   private Server server;   private WebApp webApp;   private InetSocketAddress bindAddress;   private HistoryContext history;   private JHSDelegationTokenSecretManager jhsDTSecretManager;      public HistoryClientService(HistoryContext history,       JHSDelegationTokenSecretManager jhsDTSecretManager) {     super(&quot;HistoryClientService&quot;);     this.history = history;     this.protocolHandler = new HSClientProtocolHandler();     this.jhsDTSecretManager = jhsDTSecretManager;   }    protected void serviceStart() throws Exception {     Configuration conf = getConfig();     YarnRPC rpc = YarnRPC.create(conf);     initializeWebApp(conf);     InetSocketAddress address = conf.getSocketAddr(         JHAdminConfig.MR_HISTORY_BIND_HOST,         JHAdminConfig.MR_HISTORY_ADDRESS,         JHAdminConfig.DEFAULT_MR_HISTORY_ADDRESS,         JHAdminConfig.DEFAULT_MR_HISTORY_PORT);      server =         rpc.getServer(HSClientProtocol.class, protocolHandler, address,             conf, jhsDTSecretManager,             conf.getInt(JHAdminConfig.MR_HISTORY_CLIENT_THREAD_COUNT,                 JHAdminConfig.DEFAULT_MR_HISTORY_CLIENT_THREAD_COUNT));      // Enable service authorization?     if (conf.getBoolean(         CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHORIZATION,         false)) {       server.refreshServiceAcl(conf, new ClientHSPolicyProvider());     }          server.start();     this.bindAddress = conf.updateConnectAddr(JHAdminConfig.MR_HISTORY_BIND_HOST,                                               JHAdminConfig.MR_HISTORY_ADDRESS,                                               JHAdminConfig.DEFAULT_MR_HISTORY_ADDRESS,                                               server.getListenerAddress());     LOG.info(&quot;Instantiated HistoryClientService at &quot; + this.bindAddress);      super.serviceStart();   }    @VisibleForTesting   protected void initializeWebApp(Configuration conf) {     webApp = new HsWebApp(history);     InetSocketAddress bindAddress = MRWebAppUtil.getJHSWebBindAddress(conf);     // NOTE: there should be a .at(InetSocketAddress)     WebApps         .$for(&quot;jobhistory&quot;, HistoryClientService.class, this, &quot;ws&quot;)         .with(conf)         .withHttpSpnegoKeytabKey(             JHAdminConfig.MR_WEBAPP_SPNEGO_KEYTAB_FILE_KEY)         .withHttpSpnegoPrincipalKey(             JHAdminConfig.MR_WEBAPP_SPNEGO_USER_NAME_KEY)         .at(NetUtils.getHostPortString(bindAddress)).start(webApp);          String connectHost = MRWebAppUtil.getJHSWebappURLWithoutScheme(conf).split(&quot;:&quot;)[0];     MRWebAppUtil.setJHSWebappURLWithoutScheme(conf,         connectHost + &quot;:&quot; + webApp.getListenerAddress().getPort());   }    @Override   protected void serviceStop() throws Exception {     if (server != null) {       server.stop();     }     if (webApp != null) {       webApp.stop();     }     super.serviceStop();   }    @Private   public MRClientProtocol getClientHandler() {     return this.protocolHandler;   }    @Private   public InetSocketAddress getBindAddress() {     return this.bindAddress;   }    private class HSClientProtocolHandler implements HSClientProtocol {      private RecordFactory recordFactory = RecordFactoryProvider.getRecordFactory(null);      public InetSocketAddress getConnectAddress() {       return getBindAddress();     }          private Job verifyAndGetJob(final JobId jobID) throws IOException {       UserGroupInformation loginUgi = null;       Job job = null;       try {         loginUgi = UserGroupInformation.getLoginUser();         job = loginUgi.doAs(new PrivilegedExceptionAction() {            @Override           public Job run() throws Exception {             Job job = history.getJob(jobID);             return job;           }         });       } catch (InterruptedException e) {         throw new IOException(e);       }       if (job != null) {         JobACL operation = JobACL.VIEW_JOB;         checkAccess(job, operation);       }       return job;     }      @Override     public GetCountersResponse getCounters(GetCountersRequest request)         throws IOException {       JobId jobId = request.getJobId();       Job job = verifyAndGetJob(jobId);       GetCountersResponse response = recordFactory.newRecordInstance(GetCountersResponse.class);       response.setCounters(TypeConverter.toYarn(job.getAllCounters()));       return response;     }      @Override     public GetJobReportResponse getJobReport(GetJobReportRequest request)         throws IOException {       JobId jobId = request.getJobId();       Job job = verifyAndGetJob(jobId);       GetJobReportResponse response = recordFactory.newRecordInstance(GetJobReportResponse.class);       if (job != null) {         response.setJobReport(job.getReport());       }       else {         response.setJobReport(null);       }       return response;     }      @Override     public GetTaskAttemptReportResponse getTaskAttemptReport(         GetTaskAttemptReportRequest request) throws IOException {       TaskAttemptId taskAttemptId = request.getTaskAttemptId();       Job job = verifyAndGetJob(taskAttemptId.getTaskId().getJobId());       GetTaskAttemptReportResponse response = recordFactory.newRecordInstance(GetTaskAttemptReportResponse.class);       response.setTaskAttemptReport(job.getTask(taskAttemptId.getTaskId()).getAttempt(taskAttemptId).getReport());       return response;     }      @Override     public GetTaskReportResponse getTaskReport(GetTaskReportRequest request)         throws IOException {       TaskId taskId = request.getTaskId();       Job job = verifyAndGetJob(taskId.getJobId());       GetTaskReportResponse response = recordFactory.newRecordInstance(GetTaskReportResponse.class);       response.setTaskReport(job.getTask(taskId).getReport());       return response;     }      @Override     public GetTaskAttemptCompletionEventsResponse         getTaskAttemptCompletionEvents(             GetTaskAttemptCompletionEventsRequest request) throws IOException {       JobId jobId = request.getJobId();       int fromEventId = request.getFromEventId();       int maxEvents = request.getMaxEvents();        Job job = verifyAndGetJob(jobId);       GetTaskAttemptCompletionEventsResponse response = recordFactory.newRecordInstance(GetTaskAttemptCompletionEventsResponse.class);       response.addAllCompletionEvents(Arrays.asList(job.getTaskAttemptCompletionEvents(fromEventId, maxEvents)));       return response;     }      @Override     public KillJobResponse killJob(KillJobRequest request) throws IOException {       throw new IOException(&quot;Invalid operation on completed job&quot;);     }      @Override     public KillTaskResponse killTask(KillTaskRequest request)         throws IOException {       throw new IOException(&quot;Invalid operation on completed job&quot;);     }      @Override     public KillTaskAttemptResponse killTaskAttempt(         KillTaskAttemptRequest request) throws IOException {       throw new IOException(&quot;Invalid operation on completed job&quot;);     }      @Override     public GetDiagnosticsResponse getDiagnostics(GetDiagnosticsRequest request)         throws IOException {       TaskAttemptId taskAttemptId = request.getTaskAttemptId();        Job job = verifyAndGetJob(taskAttemptId.getTaskId().getJobId());        GetDiagnosticsResponse response = recordFactory.newRecordInstance(GetDiagnosticsResponse.class);       response.addAllDiagnostics(job.getTask(taskAttemptId.getTaskId()).getAttempt(taskAttemptId).getDiagnostics());       return response;     }      @Override     public FailTaskAttemptResponse failTaskAttempt(         FailTaskAttemptRequest request) throws IOException {       throw new IOException(&quot;Invalid operation on completed job&quot;);     }      @Override     public GetTaskReportsResponse getTaskReports(GetTaskReportsRequest request)         throws IOException {       JobId jobId = request.getJobId();       TaskType taskType = request.getTaskType();        GetTaskReportsResponse response = recordFactory.newRecordInstance(GetTaskReportsResponse.class);       Job job = verifyAndGetJob(jobId);       Collection tasks = job.getTasks(taskType).values();       for (Task task : tasks) {         response.addTaskReport(task.getReport());       }       return response;     }          @Override     public GetDelegationTokenResponse getDelegationToken(         GetDelegationTokenRequest request) throws IOException {        UserGroupInformation ugi = UserGroupInformation.getCurrentUser();        // Verify that the connection is kerberos authenticated         if (!isAllowedDelegationTokenOp()) {           throw new IOException(               &quot;Delegation Token can be issued only with kerberos authentication&quot;);         }        GetDelegationTokenResponse response = recordFactory.newRecordInstance(           GetDelegationTokenResponse.class);        String user = ugi.getUserName();       Text owner = new Text(user);       Text realUser = null;       if (ugi.getRealUser() != null) {         realUser = new Text(ugi.getRealUser().getUserName());       }       MRDelegationTokenIdentifier tokenIdentifier =           new MRDelegationTokenIdentifier(owner, new Text(             request.getRenewer()), realUser);       Token realJHSToken =           new Token(tokenIdentifier,               jhsDTSecretManager);       org.apache.hadoop.yarn.api.records.Token mrDToken =           org.apache.hadoop.yarn.api.records.Token.newInstance(             realJHSToken.getIdentifier(), realJHSToken.getKind().toString(),             realJHSToken.getPassword(), realJHSToken.getService().toString());       response.setDelegationToken(mrDToken);       return response;     }      @Override     public RenewDelegationTokenResponse renewDelegationToken(         RenewDelegationTokenRequest request) throws IOException {         if (!isAllowedDelegationTokenOp()) {           throw new IOException(               &quot;Delegation Token can be renewed only with kerberos authentication&quot;);         }          org.apache.hadoop.yarn.api.records.Token protoToken = request.getDelegationToken();         Token token =             new Token(                 protoToken.getIdentifier().array(), protoToken.getPassword()                     .array(), new Text(protoToken.getKind()), new Text(                     protoToken.getService()));          String user = UserGroupInformation.getCurrentUser().getShortUserName();         long nextExpTime = jhsDTSecretManager.renewToken(token, user);         RenewDelegationTokenResponse renewResponse = Records             .newRecord(RenewDelegationTokenResponse.class);         renewResponse.setNextExpirationTime(nextExpTime);         return renewResponse;     }      @Override     public CancelDelegationTokenResponse cancelDelegationToken(         CancelDelegationTokenRequest request) throws IOException {         if (!isAllowedDelegationTokenOp()) {           throw new IOException(               &quot;Delegation Token can be cancelled only with kerberos authentication&quot;);         }          org.apache.hadoop.yarn.api.records.Token protoToken = request.getDelegationToken();         Token token =             new Token(                 protoToken.getIdentifier().array(), protoToken.getPassword()                     .array(), new Text(protoToken.getKind()), new Text(                     protoToken.getService()));          String user = UserGroupInformation.getCurrentUser().getUserName();         jhsDTSecretManager.cancelToken(token, user);         return Records.newRecord(CancelDelegationTokenResponse.class);     }      private void checkAccess(Job job, JobACL jobOperation)         throws IOException {        UserGroupInformation callerUGI;       callerUGI = UserGroupInformation.getCurrentUser();        if (!job.checkAccess(callerUGI, jobOperation)) {         throw new IOException(new AccessControlException(&quot;User &quot;             + callerUGI.getShortUserName() + &quot; cannot perform operation &quot;             + jobOperation.name() + &quot; on &quot; + job.getID()));       }     }      private boolean isAllowedDelegationTokenOp() throws IOException {       if (UserGroupInformation.isSecurityEnabled()) {         return EnumSet.of(AuthenticationMethod.KERBEROS,                           AuthenticationMethod.KERBEROS_SSL,                           AuthenticationMethod.CERTIFICATE)             .contains(UserGroupInformation.getCurrentUser()                     .getRealAuthenticationMethod());       } else {         return true;       }     }    } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14159</td>
    <td align="left">https://github.com/apache/hadoop-common/blob/42a61a4fbc88303913c4681f0d40ffcc737e70b5/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-hs/src/main/java/org/apache/hadoop/mapreduce/v2/hs/HistoryClientService.java/#L99-L435</td>
    <td align="right">1</td>
    <td align="right">2333</td>
    <td align="right">14159</td>
  </tr>
  <tr valign="top">
    <td align="right">2439</td>
    <td align="left">&nbsp;	{ 		&quot;answer&quot;: &quot;YES I found bad smells&quot;, 		&quot;bad smells are&quot;: [ 			&quot;Blob&quot;, 			&quot;Data Class&quot;, 			&quot;Long Method&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class AssemblerConfig {  	// Private Member Variables ------------------------------------------------  	/** The portlet app descriptor, which is usually WEB-INF/portlet.xml. */     private File portletDescriptor;      /** The webapp descriptor to assemble, which is usually WEB-INF/web.xml. */     private File webappDescriptor;      /** The assemble destination, which points to the assembled WAR file. */     private File destination;      /** The class of the servlet that will handle portlet requests */     private String dispatchServletClass;      /** The source archive to assemble */     private File source;          /** Assembler sink buffer size.  Defaults to 4096 bytes. */     private int assemblerSinkBuflen = 1024 * 4; // 4kb      // Public Methods ----------------------------------------------------------      public File getPortletDescriptor() {         return portletDescriptor;     }      public void setPortletDescriptor(File portletDescriptor) {         this.portletDescriptor = portletDescriptor;     }      public File getWebappDescriptor() {         return webappDescriptor;     }      public void setWebappDescriptor(File webappDescriptor) {         this.webappDescriptor = webappDescriptor;     }      public File getDestination() {         return destination;     }      public void setDestination(File destination) {         this.destination = destination;     }      public String getDispatchServletClass() {         return dispatchServletClass;     }      public void setDispatchServletClass(String dispatchServletClass) {         this.dispatchServletClass = dispatchServletClass;     }      /**      * @deprecated use setSource(File) instead.      */     public void setWarSource(File source) {         this.source = source;     }          public void setSource(File source) {         this.source = source;     }          /**      * @deprecated use getSource() instead.      */     public File getWarSource() {         return source;     }          public File getSource() {         return source;     }          public int getAssemblerSinkBuflen() {         return assemblerSinkBuflen;     }          public void setAssemblerSinkBuflen(int buflen) {         this.assemblerSinkBuflen = buflen;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14478</td>
    <td align="left">https://github.com/apache/portals-pluto/blob/4db5ddd26fb2ce642be7b0894858e664c6076a3b/pluto-util/src/main/java/org/apache/pluto/util/assemble/AssemblerConfig.java/#L25-L110</td>
    <td align="right">1</td>
    <td align="right">2439</td>
    <td align="right">14478</td>
  </tr>
  <tr valign="top">
    <td align="right">73</td>
    <td align="left"><br />
   {<br />
      &quot;message&quot;: &quot;YES, I found bad smells&quot;,<br />
      &quot;the bad smells are&quot;: [<br />
         &quot;1. Long class&quot;,<br />
         &quot;2. Long method&quot;,<br />
         &quot;3. Feature envy&quot;,<br />
         &quot;4. Data class&quot;,<br />
         &quot;5. Message chains&quot;,<br />
         &quot;6. Shotgun surgery&quot;,<br />
         &quot;7. Comments&quot;,<br />
         &quot;8. Data clumps&quot;<br />
      ]<br />
   }</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells).<br />
 Could you please identify which smells occur in the following code? However, do not describe the smells,<br />
 just list them. <br />
Please start your answer with &quot;YES I found bad smells&quot; when you find any bad smell. <br />
Otherwise, start your answer with &quot;NO, I did not find any bad smell&quot;. <br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells<br />
are:&quot; amongst the text your answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public abstract class AbstractAzureMojo extends AbstractMojo implements TelemetryConfiguration, AuthConfiguration {     public static final String PLUGIN_NAME_KEY = &quot;pluginName&quot;;     public static final String PLUGIN_VERSION_KEY = &quot;pluginVersion&quot;;     public static final String INSTALLATION_ID_KEY = &quot;installationId&quot;;     public static final String SESSION_ID_KEY = &quot;sessionId&quot;;     public static final String SUBSCRIPTION_ID_KEY = &quot;subscriptionId&quot;;     public static final String AUTH_TYPE = &quot;authType&quot;;     public static final String TELEMETRY_NOT_ALLOWED = &quot;TelemetryNotAllowed&quot;;     public static final String INIT_FAILURE = &quot;InitFailure&quot;;     public static final String AZURE_INIT_FAIL = &quot;Failed to authenticate with Azure. Please check your configuration.&quot;;     public static final String FAILURE_REASON = &quot;failureReason&quot;;     private static final String CONFIGURATION_PATH = Paths.get(System.getProperty(&quot;user.home&quot;),         &quot;.azure&quot;, &quot;mavenplugins.properties&quot;).toString();     private static final String FIRST_RUN_KEY = &quot;first.run&quot;;     private static final String PRIVACY_STATEMENT = &quot;\nData/Telemetry\n&quot; +         &quot;---------\n&quot; +         &quot;This project collects usage data and sends it to Microsoft to help improve our products and services.\n&quot; +         &quot;Read Microsoft's privacy statement to learn more: https://privacy.microsoft.com/en-us/privacystatement.&quot; +         &quot;\n\nYou can change your telemetry configuration through 'allowTelemetry' property.\n&quot; +         &quot;For more information, please go to https://aka.ms/azure-maven-config.\n&quot;;      //region Properties      @Parameter(defaultValue = &quot;${project}&quot;, readonly = true, required = true)     protected MavenProject project;      @Parameter(defaultValue = &quot;${session}&quot;, readonly = true, required = true)     protected MavenSession session;      @Parameter(defaultValue = &quot;${project.build.directory}&quot;, readonly = true, required = true)     protected File buildDirectory;      @Parameter(defaultValue = &quot;${plugin}&quot;, readonly = true, required = true)     protected PluginDescriptor plugin;      /**      * The system settings for Maven. This is the instance resulting from      * merging global and user-level settings files.      */     @Parameter(defaultValue = &quot;${settings}&quot;, readonly = true, required = true)     protected Settings settings;      @Component(role = MavenResourcesFiltering.class, hint = &quot;default&quot;)     protected MavenResourcesFiltering mavenResourcesFiltering;      /**      * Authentication setting for Azure Management API.      * Below are the supported sub-elements within {@code }. You can use one of them to authenticate      * with azure      * {@code } specifies the credentials of your Azure service principal, by referencing a server definition      * in Maven's settings.xml      * {@code } specifies the absolute path of your authentication file for Azure.      *      * @since 0.1.0      */     @Parameter     protected AuthenticationSetting authentication;      /**      * Azure subscription Id. You only need to specify it when:      *       * you are using authentication file      * there are more than one subscription in the authentication file      *       *      * @since 0.1.0      */     @Parameter     protected String subscriptionId = &quot;&quot;;      /**      * Boolean flag to turn on/off telemetry within current Maven plugin.      *      * @since 0.1.0      */     @Parameter(property = &quot;allowTelemetry&quot;, defaultValue = &quot;true&quot;)     protected boolean allowTelemetry;      /**      * Boolean flag to control whether throwing exception from current Maven plugin when meeting any error.      * If set to true, the exception from current Maven plugin will fail the current Maven run.      *      * @since 0.1.0      */     @Parameter(property = &quot;failsOnError&quot;, defaultValue = &quot;true&quot;)     protected boolean failsOnError;      /**      * Use a HTTP proxy host for the Azure Auth Client      */     @Parameter(property = &quot;httpProxyHost&quot;, readonly = false, required = false)     protected String httpProxyHost;      /**      * Use a HTTP proxy port for the Azure Auth Client      */     @Parameter(property = &quot;httpProxyPort&quot;, defaultValue = &quot;80&quot;)     protected int httpProxyPort;      private AzureAuthHelper azureAuthHelper = new AzureAuthHelper(this);      private Azure azure;      private TelemetryProxy telemetryProxy;      private String sessionId = UUID.randomUUID().toString();      private String installationId = GetHashMac.getHashMac();      //endregion      //region Getter      public MavenProject getProject() {         return project;     }      public MavenSession getSession() {         return session;     }      public String getBuildDirectoryAbsolutePath() {         return buildDirectory.getAbsolutePath();     }      public MavenResourcesFiltering getMavenResourcesFiltering() {         return mavenResourcesFiltering;     }      public Settings getSettings() {         return settings;     }      public AuthenticationSetting getAuthenticationSetting() {         return authentication;     }      public String getSubscriptionId() {         return subscriptionId;     }      public boolean isTelemetryAllowed() {         return allowTelemetry;     }      public boolean isFailingOnError() {         return failsOnError;     }      public String getSessionId() {         return sessionId;     }      public String getInstallationId() {         return installationId == null ? &quot;&quot; : installationId;     }      public String getPluginName() {         return plugin.getArtifactId();     }      public String getPluginVersion() {         return plugin.getVersion();     }      public String getUserAgent() {         return isTelemetryAllowed() ? String.format(&quot;%s/%s %s:%s %s:%s&quot;, getPluginName(), getPluginVersion(),                         INSTALLATION_ID_KEY, getInstallationId(), SESSION_ID_KEY, getSessionId())                 : String.format(&quot;%s/%s&quot;, getPluginName(), getPluginVersion());     }      public String getHttpProxyHost() {         return httpProxyHost;     }            public int getHttpProxyPort() {         return httpProxyPort;     }       public Azure getAzureClient() throws AzureAuthFailureException {         if (azure == null) {             azure = azureAuthHelper.getAzureClient();             if (azure == null) {                 getTelemetryProxy().trackEvent(INIT_FAILURE);                 throw new AzureAuthFailureException(AZURE_INIT_FAIL);             } else {                 // Repopulate subscriptionId in case it is not configured.                 getTelemetryProxy().addDefaultProperty(SUBSCRIPTION_ID_KEY, azure.subscriptionId());             }         }         return azure;     }      public TelemetryProxy getTelemetryProxy() {         if (telemetryProxy == null) {             initTelemetry();         }         return telemetryProxy;     }      protected void initTelemetry() {         telemetryProxy = new AppInsightsProxy(this);         if (!isTelemetryAllowed()) {             telemetryProxy.trackEvent(TELEMETRY_NOT_ALLOWED);             telemetryProxy.disable();         }     }      //endregion      //region Telemetry Configuration Interface      public Map getTelemetryProperties() {         final Map map = new HashMap&lt;&gt;();         map.put(INSTALLATION_ID_KEY, getInstallationId());         map.put(PLUGIN_NAME_KEY, getPluginName());         map.put(PLUGIN_VERSION_KEY, getPluginVersion());         map.put(SUBSCRIPTION_ID_KEY, getSubscriptionId());         map.put(SESSION_ID_KEY, getSessionId());         map.put(AUTH_TYPE, getAuthType());         return map;     }      // TODO:     // Add AuthType ENUM and move to AzureAuthHelper.     public String getAuthType() {         final AuthenticationSetting authSetting = getAuthenticationSetting();         if (authSetting == null) {             return &quot;AzureCLI&quot;;         }         if (StringUtils.isNotEmpty(authSetting.getServerId())) {             return &quot;ServerId&quot;;         }         if (authSetting.getFile() != null) {             return &quot;AuthFile&quot;;         }         return &quot;Unknown&quot;;     }      //endregion      //region Entry Point      @Override     public void execute() throws MojoExecutionException {         try {             // Work around for Application Insights Java SDK:             // Sometimes, NoClassDefFoundError will be thrown even after Maven build is completed successfully.             // An issue has been filed at https://github.com/Microsoft/ApplicationInsights-Java/issues/416             // Before this issue is fixed, set default uncaught exception handler for all threads as work around.             Thread.setDefaultUncaughtExceptionHandler(new DefaultUncaughtExceptionHandler());              final Properties prop = new Properties();             if (isFirstRun(prop)) {                 infoWithMultipleLines(PRIVACY_STATEMENT);                 updateConfigurationFile(prop);             }              if (isSkipMojo()) {                 info(&quot;Skip execution.&quot;);                 trackMojoSkip();             } else {                 trackMojoStart();                  doExecute();                  trackMojoSuccess();             }         } catch (Exception e) {             handleException(e);         } finally {             // When maven goal executes too quick, The HTTPClient of AI SDK may not fully initialized and will step             // into endless loop when close, we need to call it in main thread.             // Refer here for detail codes: https://github.com/Microsoft/ApplicationInsights-Java/blob/master/core/src             // /main/java/com/microsoft/applicationinsights/internal/channel/common/ApacheSender43.java#L103             ApacheSenderFactory.INSTANCE.create().close();         }     }      /**      * Sub-class can override this method to decide whether skip execution.      *      * @return Boolean to indicate whether skip execution.      */     protected boolean isSkipMojo() {         return false;     }      /**      * Entry point of sub-class. Sub-class should implement this method to do real work.      *      * @throws Exception      */     protected abstract void doExecute() throws Exception;      //endregion      //region Telemetry      protected void trackMojoSkip() {         getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + &quot;.skip&quot;);     }      protected void trackMojoStart() {         getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + &quot;.start&quot;);     }      protected void trackMojoSuccess() {         getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + &quot;.success&quot;);     }      protected void trackMojoFailure(final String message) {         final HashMap failureReason = new HashMap&lt;&gt;();         failureReason.put(FAILURE_REASON, message);         getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + &quot;.failure&quot;, failureReason);     }      //endregion      //region Helper methods      protected void handleException(final Exception exception) throws MojoExecutionException {         String message = exception.getMessage();         if (StringUtils.isEmpty(message)) {             message = exception.toString();         }         trackMojoFailure(message);          if (isFailingOnError()) {             throw new MojoExecutionException(message, exception);         } else {             error(message);         }     }      private boolean isFirstRun(Properties prop) {         try {             final File configurationFile = new File(CONFIGURATION_PATH);             if (configurationFile.exists()) {                 try (InputStream input = new FileInputStream(CONFIGURATION_PATH)) {                     prop.load(input);                     final String firstRunValue = prop.getProperty(FIRST_RUN_KEY);                     if (firstRunValue != null &amp;&amp; !firstRunValue.isEmpty() &amp;&amp; firstRunValue.equalsIgnoreCase(&quot;false&quot;)) {                         return false;                     }                 }             } else {                 configurationFile.getParentFile().mkdirs();                 configurationFile.createNewFile();             }         } catch (Exception e) {             // catch exceptions here to avoid blocking mojo execution.             debug(e.getMessage());         }         return true;     }      private void updateConfigurationFile(Properties prop) {         try (OutputStream output = new FileOutputStream(CONFIGURATION_PATH)) {             prop.setProperty(FIRST_RUN_KEY, &quot;false&quot;);             prop.store(output, &quot;Azure Maven Plugin configurations&quot;);         } catch (Exception e) {             // catch exceptions here to avoid blocking mojo execution.             debug(e.getMessage());         }     }      protected class DefaultUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {         @Override         public void uncaughtException(Thread t, Throwable e) {             debug(&quot;uncaughtException: &quot; + e);         }     }      //endregion      //region Logging      public void debug(final String message) {         getLog().debug(message);     }      public void info(final String message) {         getLog().info(message);     }      public void infoWithMultipleLines(final String messages) {         final String[] messageArray = messages.split(&quot;\\n&quot;);         for (final String line : messageArray) {             getLog().info(line);         }     }      public void warning(final String message) {         getLog().warn(message);     }      public void error(final String message) {         getLog().error(message);     }      //endregion }</td>
    <td align="left">data class</td>
    <td align="left">1. long class, 2. long method, 3. feature envy, 4. data class, 5. message chains, 6. shotgun surgery, 7. comments, 8. data clumps</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. long class,  2. long method,  3. feature envy,  5. message chains,  6. shotgun surgery,  7. comments,  8. data clumps</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1109</td>
    <td align="left">https://github.com/Microsoft/azure-maven-plugins/blob/d3e0b6fa0e00f38c04b622589a939fb3bae2227e/azure-maven-plugin-lib/src/main/java/com/microsoft/azure/maven/AbstractAzureMojo.java/#L45-L447</td>
    <td align="right">2</td>
    <td align="right">73</td>
    <td align="right">1109</td>
  </tr>
  <tr valign="top">
    <td align="right">1301</td>
    <td align="left">&nbsp;&nbsp;YES I found bad smells the bad smells are: 1. Long method, 2. Feature envy, 3. Data class, 4. Data clumps, 5. Primitive obsession</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
  public static class RowRange {     private Text startRow;     private Text endRow;      public RowRange(KeyExtent ke) {       this.startRow = ke.getPrevEndRow();       this.endRow = ke.getEndRow();     }      public RowRange(TRowRange trr) {       this.startRow = ByteBufferUtil.toText(trr.startRow);       this.endRow = ByteBufferUtil.toText(trr.endRow);     }      public RowRange(Text startRow, Text endRow) {       this.startRow = startRow;       this.endRow = endRow;     }      public Range toRange() {       return new Range(startRow, false, endRow, true);     }      public TRowRange toThrift() {       return new TRowRange(TextUtil.getByteBuffer(startRow), TextUtil.getByteBuffer(endRow));     }      public Text getStartRow() {       return startRow;     }      public Text getEndRow() {       return endRow;     }      @Override     public String toString() {       return startRow + &quot; &quot; + endRow;     }   }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method, 2 Feature envy, 3 Data class, 4 Data clumps, 5 Primitive obsession</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">. Long method,  2. Feature envy,  4. Data clumps,  5. Primitive obsession</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10658</td>
    <td align="left">https://github.com/apache/accumulo/blob/f896c98c2356a52dfa2235d2cc02ae556ab17909/core/src/main/java/org/apache/accumulo/core/summary/Gatherer.java/#L617-L656</td>
    <td align="right">2</td>
    <td align="right">1301</td>
    <td align="right">10658</td>
  </tr>
  <tr valign="top">
    <td align="right">639</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class ShareContent         implements ShareModel {     private final Uri contentUrl;     private final List peopleIds;     private final String placeId;     private final String pageId;     private final String ref;     private final ShareHashtag hashtag;      protected ShareContent(final Builder builder) {         super();         this.contentUrl = builder.contentUrl;         this.peopleIds = builder.peopleIds;         this.placeId = builder.placeId;         this.pageId = builder.pageId;         this.ref = builder.ref;         this.hashtag = builder.hashtag;     }      protected ShareContent(final Parcel in) {         this.contentUrl = in.readParcelable(Uri.class.getClassLoader());         this.peopleIds = readUnmodifiableStringList(in);         this.placeId = in.readString();         this.pageId = in.readString();         this.ref = in.readString();         this.hashtag = new ShareHashtag.Builder().readFrom(in).build();     }      /**      * URL for the content being shared.  This URL will be checked for app link meta tags for      * linking in platform specific ways.      *       * See documentation for App Links.      *      * @return {@link android.net.Uri} representation of the content link.      */     @Nullable     public Uri getContentUrl() {         return this.contentUrl;     }      /**      * List of Ids for taggable people to tag with this content.      *       * See documentation for      *       * Taggable Friends.      *      * @return {@link java.util.List} of Ids for people to tag.      */     @Nullable     public List getPeopleIds() {         return this.peopleIds;     }      /**      * The Id for a place to tag with this content.      *      * @return The Id for the place to tag.      */     @Nullable     public String getPlaceId() {         return this.placeId;     }      /**      * For shares into Messenger, this pageID will be used to map the app to page and attach      * attribution to the share.      *      * @return The ID of the Facebook page this share is associated with.      */     @Nullable     public String getPageId() {         return this.pageId;     }      /**      * A value to be added to the referrer URL when a person follows a link from this shared      * content on feed.      *      * @return The ref for the content.      */     @Nullable     public String getRef() {         return this.ref;     }      /**      * Gets the ShareHashtag, if one has been set, for this content.      *      * @return The hashtag      */     @Nullable     public ShareHashtag getShareHashtag() {         return this.hashtag;     }      public int describeContents() {         return 0;     }      public void writeToParcel(final Parcel out, final int flags) {         out.writeParcelable(this.contentUrl, 0);         out.writeStringList(this.peopleIds);         out.writeString(this.placeId);         out.writeString(this.pageId);         out.writeString(this.ref);         out.writeParcelable(this.hashtag, 0);     }      private List readUnmodifiableStringList(final Parcel in) {         final List list = new ArrayList();         in.readStringList(list);         return (list.size() == 0 ? null : Collections.unmodifiableList(list));     }      /**      * Abstract builder for {@link com.facebook.share.model.ShareContent}      */     public abstract static class Builder             implements ShareModelBuilder {         private Uri contentUrl;         private List peopleIds;         private String placeId;         private String pageId;         private String ref;         private ShareHashtag hashtag;          /**          * Set the URL for the content being shared.          *          * @param contentUrl {@link android.net.Uri} representation of the content link.          * @return The builder.          */         public E setContentUrl(@Nullable final Uri contentUrl) {             this.contentUrl = contentUrl;             return (E) this;         }          /**          * Set the list of Ids for taggable people to tag with this content.          *          * @param peopleIds {@link java.util.List} of Ids for people to tag.          * @return The builder.          */         public E setPeopleIds(@Nullable final List peopleIds) {             this.peopleIds = (peopleIds == null ? null : Collections.unmodifiableList(peopleIds));             return (E) this;         }          /**          * Set the Id for a place to tag with this content.          *          * @param placeId The Id for the place to tag.          * @return The builder.          */         public E setPlaceId(@Nullable final String placeId) {             this.placeId = placeId;             return (E) this;         }          /**          * Set the Id of the Facebook page this share is associated with.          *          * @param pageId The Id for the Page          * @return The builder          */         public E setPageId(@Nullable final String pageId) {             this.pageId = pageId;             return (E) this;         }          /**          * Set the value to be added to the referrer URL when a person follows a link from this          * shared content on feed.          *          * @param ref The ref for the content.          * @return The builder.          */         public E setRef(@Nullable final String ref) {             this.ref = ref;             return (E) this;         }          /**          * Set the ShareHashtag for this content          *          * @param shareHashtag The hashtag for this content          * @return The builder          */         public E setShareHashtag(@Nullable final ShareHashtag shareHashtag) {             this.hashtag = shareHashtag;             return (E) this;         }          @Override         public E readFrom(final P content) {             if (content == null) {                 return (E) this;             }             return (E) this                     .setContentUrl(content.getContentUrl())                     .setPeopleIds(content.getPeopleIds())                     .setPlaceId(content.getPlaceId())                     .setPageId(content.getPageId())                     .setRef(content.getRef());         }     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6330</td>
    <td align="left">https://github.com/facebook/facebook-android-sdk/blob/81ca34a2a0f7ee391f90c6051c5a22e5bc8663c2/facebook-common/src/main/java/com/facebook/share/model/ShareContent.java/#L35-L243</td>
    <td align="right">1</td>
    <td align="right">639</td>
    <td align="right">6330</td>
  </tr>
  <tr valign="top">
    <td align="right">2515</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;response&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement(name = &quot;roles&quot;, namespace = &quot;http://org.apache.cxf.fediz/&quot;) public class Roles {      private Collection roles;      public Roles() {     }      public Roles(Collection roles) {         this.roles = roles;     }      @XmlElementRef     public Collection getRoles() {         return roles;     }      public void setRoles(Collection roles) {         this.roles = roles;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14695</td>
    <td align="left">https://github.com/apache/cxf-fediz/blob/553ae6e3adeb92b7d6300e5c0ad83ed6322e28bd/services/idp-core/src/main/java/org/apache/cxf/fediz/service/idp/rest/Roles.java/#L29-L49</td>
    <td align="right">1</td>
    <td align="right">2515</td>
    <td align="right">14695</td>
  </tr>
  <tr valign="top">
    <td align="right">683</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@ThreadSafe public final class ServiceLocation {      private final String location;     private final String name;      ServiceLocation(Element serviceLocationElement, String location) throws ServiceConfigException {         String name = serviceLocationElement.getAttribute(&quot;name&quot;).intern();         if (name.isEmpty()) {             throw new ServiceConfigException(&quot; element name attribute is empty&quot;);         }         this.name = name;         if (location.isEmpty()) {             throw new ServiceConfigException(&quot; element location attribute is empty&quot;);         }         this.location = location;     }      public String getLocation() {         return location;     }      public String getName() {         return name;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6610</td>
    <td align="left">https://github.com/apache/ofbiz/blob/7ba7f3c2e16df6c8db0d8114e124957199cea1ff/framework/service/src/main/java/org/apache/ofbiz/service/config/model/ServiceLocation.java/#L28-L53</td>
    <td align="right">1</td>
    <td align="right">683</td>
    <td align="right">6610</td>
  </tr>
  <tr valign="top">
    <td align="right">3437</td>
    <td align="left">&nbsp;{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells&quot;: [     &quot;Blob&quot;,     &quot;Data Class&quot;   ] }  </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ChannelTypeXmlResult {      private ChannelType channelType;     private ConfigDescription configDescription;     private boolean system;      public ChannelTypeXmlResult(ChannelType channelType, ConfigDescription configDescription) {         this(channelType, configDescription, false);     }      public ChannelTypeXmlResult(ChannelType channelType, ConfigDescription configDescription, boolean system) {         this.channelType = channelType;         this.configDescription = configDescription;         this.system = system;     }      public ChannelType toChannelType() {         return this.channelType;     }      public ConfigDescription getConfigDescription() {         return this.configDescription;     }      public boolean isSystem() {         return system;     }      @Override     public String toString() {         return &quot;ChannelTypeXmlResult [channelType=&quot; + channelType + &quot;, configDescription=&quot; + configDescription + &quot;]&quot;;     }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6831</td>
    <td align="left">https://github.com/eclipse/smarthome/blob/b8455de15d65512e8fac4e94d42de6ab2fccf1c5/bundles/core/org.eclipse.smarthome.core.thing.xml/src/main/java/org/eclipse/smarthome/core/thing/xml/internal/ChannelTypeXmlResult.java/#L28-L61</td>
    <td align="right">1</td>
    <td align="right">3437</td>
    <td align="right">6831</td>
  </tr>
  <tr valign="top">
    <td align="right">1626</td>
    <td align="left">{&quot;response&quot;:&quot;YES I found bad smells&quot;,&quot;the bad smells are&quot;:[&quot;Long method&quot;,&quot;Deprecated field&quot;,&quot;Low cohesion&quot;,&quot;Feature envy&quot;,&quot;Long parameter list&quot;,&quot;Data class&quot;,&quot;Large class&quot;,&quot;Message chains&quot;,&quot;Inappropriate intimacy&quot;,&quot;Data clumps&quot;,&quot;Long class&quot;]}</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells).<br />
 Could you please identify which smells occur in the following code? However, do not describe the smells,<br />
 just list them. <br />
Please start your answer with &quot;YES I found bad smells&quot; when you find any bad smell. <br />
Otherwise, start your answer with &quot;NO, I did not find any bad smell&quot;. <br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells<br />
are:&quot; amongst the text your answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
@Mojo( name = &quot;check&quot;, defaultPhase = LifecyclePhase.VERIFY, requiresDependencyResolution = ResolutionScope.TEST,        threadSafe = true ) public class CheckstyleViolationCheckMojo     extends AbstractMojo {      private static final String JAVA_FILES = &quot;**\\/*.java&quot;;     private static final String DEFAULT_CONFIG_LOCATION = &quot;sun_checks.xml&quot;;      /**      * Specifies the path and filename to save the Checkstyle output. The format      * of the output file is determined by the outputFileFormat      * parameter.      */     @Parameter( property = &quot;checkstyle.output.file&quot;, defaultValue = &quot;${project.build.directory}/checkstyle-result.xml&quot; )     private File outputFile;      /**      * Specifies the format of the output to be used when writing to the output      * file. Valid values are &quot;plain&quot; and &quot;xml&quot;.      */     @Parameter( property = &quot;checkstyle.output.format&quot;, defaultValue = &quot;xml&quot; )     private String outputFileFormat;      /**      * Fail the build on a violation. The goal checks for the violations      * after logging them (if {@link #logViolationsToConsole} is {@code true}).      * Compare this to {@link #failsOnError} which fails the build immediately      * before examining the output log.      */     @Parameter( property = &quot;checkstyle.failOnViolation&quot;, defaultValue = &quot;true&quot; )     private boolean failOnViolation;      /**      * The maximum number of allowed violations. The execution fails only if the      * number of violations is above this limit.      *      * @since 2.3      */     @Parameter( property = &quot;checkstyle.maxAllowedViolations&quot;, defaultValue = &quot;0&quot; )     private int maxAllowedViolations;      /**      * The lowest severity level that is considered a violation.      * Valid values are &quot;error&quot;, &quot;warning&quot; and &quot;info&quot;.      *      * @since 2.2      */     @Parameter( property = &quot;checkstyle.violationSeverity&quot;, defaultValue = &quot;error&quot; )     private String violationSeverity = &quot;error&quot;;      /**      * Violations to ignore. This is a comma-separated list, each value being either      * a rule name, a rule category or a java package name of rule class.      *      * @since 2.13      */     @Parameter( property = &quot;checkstyle.violation.ignore&quot; )     private String violationIgnore;      /**      * Skip entire check.      *      * @since 2.2      */     @Parameter( property = &quot;checkstyle.skip&quot;, defaultValue = &quot;false&quot; )     private boolean skip;      /**      * Skip Checkstyle execution will only scan the outputFile.      *      * @since 2.5      */     @Parameter( property = &quot;checkstyle.skipExec&quot;, defaultValue = &quot;false&quot; )     private boolean skipExec;      /**      * Output the detected violations to the console.      *      * @since 2.3      */     @Parameter( property = &quot;checkstyle.console&quot;, defaultValue = &quot;true&quot; )     private boolean logViolationsToConsole;      /**      * Specifies the location of the resources to be used for Checkstyle.      *      * @since 2.11      */     @Parameter( defaultValue = &quot;${project.resources}&quot;, readonly = true )     protected List resources;          /**      * Specifies the location of the test resources to be used for Checkstyle.      *      * @since 2.16      */     @Parameter( defaultValue = &quot;${project.testResources}&quot;, readonly = true )     protected List testResources;      /**      *       * Specifies the location of the XML configuration to use.      *       * Potential values are a filesystem path, a URL, or a classpath resource.      * This parameter expects that the contents of the location conform to the      * xml format (Checkstyle Checker      * module) configuration of rulesets.      *       * This parameter is resolved as resource, URL, then file. If successfully      * resolved, the contents of the configuration is copied into the      * ${project.build.directory}/checkstyle-configuration.xml      * file before being passed to Checkstyle as a configuration.      *       * There are 2 predefined rulesets.      *       * sun_checks.xml: Sun Checks.      * google_checks.xml: Google Checks.      *       *      * @since 2.5      */     @Parameter( property = &quot;checkstyle.config.location&quot;, defaultValue = DEFAULT_CONFIG_LOCATION )     private String configLocation;      /**      *       * Specifies the location of the properties file.      *       * This parameter is resolved as URL, File then resource. If successfully      * resolved, the contents of the properties location is copied into the      * ${project.build.directory}/checkstyle-checker.properties      * file before being passed to Checkstyle for loading.      *       * The contents of the propertiesLocation will be made      * available to Checkstyle for specifying values for parameters within the      * xml configuration (specified in the configLocation      * parameter).      *      * @since 2.5      */     @Parameter( property = &quot;checkstyle.properties.location&quot; )     private String propertiesLocation;      /**      * Allows for specifying raw property expansion information.      */     @Parameter     private String propertyExpansion;      /**      *       * Specifies the location of the License file (a.k.a. the header file) that      * can be used by Checkstyle to verify that source code has the correct      * license header.      *       * You need to use ${checkstyle.header.file} in your Checkstyle xml      * configuration to reference the name of this header file.      *       * For instance:      *       * &lt;module name=&quot;RegexpHeader&quot;&gt;      *   &lt;property name=&quot;headerFile&quot; value=&quot;${checkstyle.header.file}&quot;/&gt;      * &lt;/module&gt;      *       *      * @since 2.0-beta-2      */     @Parameter( property = &quot;checkstyle.header.file&quot;, defaultValue = &quot;LICENSE.txt&quot; )     private String headerLocation;      /**      * Specifies the cache file used to speed up Checkstyle on successive runs.      */     @Parameter( defaultValue = &quot;${project.build.directory}/checkstyle-cachefile&quot; )     private String cacheFile;      /**      * The key to be used in the properties for the suppressions file.      *      * @since 2.1      */     @Parameter( property = &quot;checkstyle.suppression.expression&quot;, defaultValue = &quot;checkstyle.suppressions.file&quot; )     private String suppressionsFileExpression;      /**      *       * Specifies the location of the suppressions XML file to use.      *       * This parameter is resolved as resource, URL, then file. If successfully      * resolved, the contents of the suppressions XML is copied into the      * ${project.build.directory}/checkstyle-suppressions.xml file      * before being passed to Checkstyle for loading.      *       * See suppressionsFileExpression for the property that will      * be made available to your Checkstyle configuration.      *      * @since 2.0-beta-2      */     @Parameter( property = &quot;checkstyle.suppressions.location&quot; )     private String suppressionsLocation;      /**      * The file encoding to use when reading the source files. If the property project.build.sourceEncoding      * is not set, the platform default encoding is used. Note: This parameter always overrides the      * property charset from Checkstyle's TreeWalker module.      *      * @since 2.2      */     @Parameter( property = &quot;encoding&quot;, defaultValue = &quot;${project.build.sourceEncoding}&quot; )     private String encoding;      /**      * @since 2.5      */     @Component( role = CheckstyleExecutor.class, hint = &quot;default&quot; )     protected CheckstyleExecutor checkstyleExecutor;      /**      * Output errors to console.      */     @Parameter( property = &quot;checkstyle.consoleOutput&quot;, defaultValue = &quot;false&quot; )     private boolean consoleOutput;      /**      * The Maven Project Object.      */     @Parameter ( defaultValue = &quot;${project}&quot;, readonly = true, required = true )     protected MavenProject project;          /**      * The Plugin Descriptor      */     @Parameter( defaultValue = &quot;${plugin}&quot;, readonly = true, required = true )     private PluginDescriptor plugin;      /**      * If null, the Checkstyle plugin will display violations on stdout.      * Otherwise, a text file will be created with the violations.      */     @Parameter     private File useFile;      /**      * Specifies the names filter of the source files to be excluded for      * Checkstyle.      */     @Parameter( property = &quot;checkstyle.excludes&quot; )     private String excludes;      /**      * Specifies the names filter of the source files to be used for Checkstyle.      */     @Parameter( property = &quot;checkstyle.includes&quot;, defaultValue = JAVA_FILES, required = true )     private String includes;      /**      * Specifies the names filter of the files to be excluded for      * Checkstyle when checking resources.      * @since 2.11      */     @Parameter( property = &quot;checkstyle.resourceExcludes&quot; )     private String resourceExcludes;      /**      * Specifies the names filter of the files to be used for Checkstyle when checking resources.      * @since 2.11      */     @Parameter( property = &quot;checkstyle.resourceIncludes&quot;, defaultValue = &quot;**/*.properties&quot;, required = true )     private String resourceIncludes;      /**      * If this is true, and Checkstyle reported any violations or errors,      * the build fails immediately after running Checkstyle, before checking the log      * for {@link #logViolationsToConsole}. If you want to use {@link #logViolationsToConsole},      * use {@link #failOnViolation} instead of this.      */     @Parameter( defaultValue = &quot;false&quot; )     private boolean failsOnError;      /**      * Specifies the location of the test source directory to be used for Checkstyle.      *      * @since 2.2      * @deprecated instead use {@link #testSourceDirectories}. For version 3.0.0, this parameter is only defined to      *             break the build if you use it!      */     @Deprecated     @Parameter     private File testSourceDirectory;      /**      * Specifies the location of the test source directories to be used for Checkstyle.      * Default value is ${project.testCompileSourceRoots}.      * @since 2.13      */     // Compatibility with all Maven 3: default of 'project.testCompileSourceRoots' is done manually because of MNG-5440     @Parameter     private List testSourceDirectories;      /**      * Include or not the test source directory to be used for Checkstyle.      *      * @since 2.2      */     @Parameter( defaultValue = &quot;false&quot; )     private boolean includeTestSourceDirectory;      /**      * Specifies the location of the source directory to be used for Checkstyle.      *       * @deprecated instead use {@link #sourceDirectories}. For version 3.0.0, this parameter is only defined to break      *             the build if you use it!      */     @Deprecated     @Parameter     private File sourceDirectory;      /**      * Specifies the location of the source directories to be used for Checkstyle.      * Default value is ${project.compileSourceRoots}.      * @since 2.13      */     // Compatibility with all Maven 3: default of 'project.compileSourceRoots' is done manually because of MNG-5440     @Parameter     private List sourceDirectories;      /**      * Whether to apply Checkstyle to resource directories.      * @since 2.11      */     @Parameter( property = &quot;checkstyle.includeResources&quot;, defaultValue = &quot;true&quot;, required = true )     private boolean includeResources = true;      /**      * Whether to apply Checkstyle to test resource directories.      * @since 2.11      */     @Parameter( property = &quot;checkstyle.includeTestResources&quot;, defaultValue = &quot;true&quot;, required = true )     private boolean includeTestResources = true;      /**      * By using this property, you can specify the whole Checkstyle rules      * inline directly inside this pom.      *      *       * &lt;plugin&gt;      *   ...      *   &lt;configuration&gt;      *     &lt;checkstyleRules&gt;      *       &lt;module name=&quot;Checker&quot;&gt;      *         &lt;module name=&quot;FileTabCharacter&quot;&gt;      *           &lt;property name=&quot;eachLine&quot; value=&quot;true&quot; /&gt;      *         &lt;/module&gt;      *         &lt;module name=&quot;TreeWalker&quot;&gt;      *           &lt;module name=&quot;EmptyBlock&quot;/&gt;      *         &lt;/module&gt;      *       &lt;/module&gt;      *     &lt;/checkstyleRules&gt;      *   &lt;/configuration&gt;      *   ...      *       *      * @since 2.12      */     @Parameter     private PlexusConfiguration checkstyleRules;      /**      * Dump file for inlined Checkstyle rules.       */     @Parameter( property = &quot;checkstyle.output.rules.file&quot;,                     defaultValue = &quot;${project.build.directory}/checkstyle-rules.xml&quot; )     private File rulesFiles;      /**      * The header to use for the inline configuration.      * Only used when you specify {@code checkstyleRules}.      */     @Parameter( defaultValue = &quot;\n&quot;             + &quot;\n&quot; )     private String checkstyleRulesHeader;      /**      * Specifies whether modules with a configured severity of ignore should be omitted during Checkstyle      * invocation.      *       * @since 3.0.0      */     @Parameter( defaultValue = &quot;false&quot; )     private boolean omitIgnoredModules;      private ByteArrayOutputStream stringOutputStream;      private File outputXmlFile;      /** {@inheritDoc} */     public void execute()         throws MojoExecutionException, MojoFailureException     {         checkDeprecatedParameterUsage( sourceDirectory, &quot;sourceDirectory&quot;, &quot;sourceDirectories&quot; );         checkDeprecatedParameterUsage( testSourceDirectory, &quot;testSourceDirectory&quot;, &quot;testSourceDirectories&quot; );         if ( skip )         {             return;         }          outputXmlFile = outputFile;          if ( !skipExec )         {             if ( checkstyleRules != null )             {                 if ( !DEFAULT_CONFIG_LOCATION.equals( configLocation ) )                 {                     throw new MojoExecutionException( &quot;If you use inline configuration for rules, don't specify &quot;                         + &quot;a configLocation&quot; );                 }                 if ( checkstyleRules.getChildCount() &gt; 1 )                 {                     throw new MojoExecutionException( &quot;Currently only one root module is supported&quot; );                 }                  PlexusConfiguration checkerModule = checkstyleRules.getChild( 0 );                  try                 {                     FileUtils.forceMkdir( rulesFiles.getParentFile() );                     FileUtils.fileWrite( rulesFiles, checkstyleRulesHeader + checkerModule.toString() );                 }                 catch ( final IOException e )                 {                     throw new MojoExecutionException( e.getMessage(), e );                 }                 configLocation = rulesFiles.getAbsolutePath();             }              ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();              try             {                 CheckstyleExecutorRequest request = new CheckstyleExecutorRequest();                 request.setConsoleListener( getConsoleListener() ).setConsoleOutput( consoleOutput )                     .setExcludes( excludes ).setFailsOnError( failsOnError ).setIncludes( includes )                     .setResourceIncludes( resourceIncludes )                     .setResourceExcludes( resourceExcludes )                     .setIncludeResources( includeResources )                     .setIncludeTestResources( includeTestResources )                     .setIncludeTestSourceDirectory( includeTestSourceDirectory ).setListener( getListener() )                     .setProject( project ).setSourceDirectories( getSourceDirectories() )                     .setResources( resources ).setTestResources( testResources )                     .setStringOutputStream( stringOutputStream ).setSuppressionsLocation( suppressionsLocation )                     .setTestSourceDirectories( getTestSourceDirectories() ).setConfigLocation( configLocation )                     .setConfigurationArtifacts( collectArtifacts( &quot;config&quot; ) )                     .setPropertyExpansion( propertyExpansion )                     .setHeaderLocation( headerLocation ).setLicenseArtifacts( collectArtifacts( &quot;license&quot; ) )                     .setCacheFile( cacheFile ).setSuppressionsFileExpression( suppressionsFileExpression )                     .setEncoding( encoding ).setPropertiesLocation( propertiesLocation )                     .setOmitIgnoredModules( omitIgnoredModules );                 checkstyleExecutor.executeCheckstyle( request );              }             catch ( CheckstyleException e )             {                 throw new MojoExecutionException( &quot;Failed during checkstyle configuration&quot;, e );             }             catch ( CheckstyleExecutorException e )             {                 throw new MojoExecutionException( &quot;Failed during checkstyle execution&quot;, e );             }             finally             {                 //be sure to restore original context classloader                 Thread.currentThread().setContextClassLoader( currentClassLoader );             }         }          if ( !&quot;xml&quot;.equals( outputFileFormat ) &amp;&amp; skipExec )         {             throw new MojoExecutionException( &quot;Output format is '&quot; + outputFileFormat                 + &quot;', checkstyle:check requires format to be 'xml' when using skipExec.&quot; );         }          if ( !outputXmlFile.exists() )         {             getLog().info( &quot;Unable to perform checkstyle:check, unable to find checkstyle:checkstyle outputFile.&quot; );             return;         }          try ( Reader reader = new BufferedReader( ReaderFactory.newXmlReader( outputXmlFile ) ) )         {             XmlPullParser xpp = new MXParser();             xpp.setInput( reader );              int violations = countViolations( xpp );              if ( violations &gt; maxAllowedViolations )             {                 if ( failOnViolation )                 {                     String msg =                         &quot;You have &quot; + violations + &quot; Checkstyle violation&quot; + ( ( violations &gt; 1 ) ? &quot;s&quot; : &quot;&quot; ) + &quot;.&quot;;                     if ( maxAllowedViolations &gt; 0 )                     {                         msg += &quot; The maximum number of allowed violations is &quot; + maxAllowedViolations + &quot;.&quot;;                     }                     throw new MojoFailureException( msg );                 }                  getLog().warn( &quot;checkstyle:check violations detected but failOnViolation set to false&quot; );             }         }         catch ( IOException | XmlPullParserException e )         {             throw new MojoExecutionException( &quot;Unable to read Checkstyle results xml: &quot;                 + outputXmlFile.getAbsolutePath(), e );         }     }      private void checkDeprecatedParameterUsage( Object parameter, String name, String replacement )         throws MojoFailureException     {         if ( parameter != null )         {             throw new MojoFailureException( &quot;You are using '&quot; + name + &quot;' which has been removed&quot;                 + &quot; from the maven-checkstyle-plugin. &quot; + &quot;Please use '&quot; + replacement                 + &quot;' and refer to the &gt;&gt;Major Version Upgrade to version 3.0.0&lt;&lt; &quot; + &quot;on the plugin site.&quot; );         }     }      private int countViolations( XmlPullParser xpp )         throws XmlPullParserException, IOException     {         int count = 0;         int ignoreCount = 0;         List ignores = violationIgnore == null ? Collections.emptyList()                         : RuleUtil.parseMatchers( violationIgnore.split( &quot;,&quot; ) );          String basedir = project.getBasedir().getAbsolutePath();         String file = &quot;&quot;;         for ( int eventType = xpp.getEventType(); eventType != XmlPullParser.END_DOCUMENT; eventType = xpp.next() )         {             if ( eventType != XmlPullParser.START_TAG )             {                 continue;             }             else if ( &quot;file&quot;.equals( xpp.getName() ) )             {                 file = PathTool.getRelativeFilePath( basedir, xpp.getAttributeValue( &quot;&quot;, &quot;name&quot; ) );                 //file = file.substring( file.lastIndexOf( File.separatorChar ) + 1 );             }             else if ( &quot;error&quot;.equals( xpp.getName() ) )             {                 String severity = xpp.getAttributeValue( &quot;&quot;, &quot;severity&quot; );                  if ( !isViolation( severity ) )                 {                     continue;                 }                  String source = xpp.getAttributeValue( &quot;&quot;, &quot;source&quot; );                  if ( ignore( ignores, source ) )                 {                     ignoreCount++;                 }                 else                 {                     count++;                      if ( logViolationsToConsole )                     {                         String line = xpp.getAttributeValue( &quot;&quot;, &quot;line&quot; );                         String column = xpp.getAttributeValue( &quot;&quot;, &quot;column&quot; );                         String message = xpp.getAttributeValue( &quot;&quot;, &quot;message&quot; );                         String rule = RuleUtil.getName( source );                         String category = RuleUtil.getCategory( source );                          log( severity, file + &quot;:[&quot; + line + ( ( column == null ) ? &quot;&quot; : ( ',' + column ) ) + &quot;] (&quot;                             + category + &quot;) &quot; + rule + &quot;: &quot; + message );                     }                 }             }         }          if ( ignoreCount &gt; 0 )         {             getLog().info( &quot;Ignored &quot; + ignoreCount + &quot; error&quot; + ( ( ignoreCount &gt; 1 ) ? &quot;s&quot; : &quot;&quot; ) + &quot;, &quot; + count                                + &quot; violation&quot; + ( ( count &gt; 1 ) ? &quot;s&quot; : &quot;&quot; ) + &quot; remaining.&quot; );         }          return count;     }      private void log( String severity, String message )     {         if ( &quot;info&quot;.equals( severity ) )         {             getLog().info( message );         }         else if ( &quot;warning&quot;.equals( severity ) )         {             getLog().warn( message );         }         else         {             getLog().error( message );         }     }      /**      * Checks if the given severity is considered a violation.      *      * @param severity The severity to check      * @return true if the given severity is a violation, otherwise false      */     private boolean isViolation( String severity )     {         if ( &quot;error&quot;.equals( severity ) )         {             return &quot;error&quot;.equals( violationSeverity ) || &quot;warning&quot;.equals( violationSeverity )                 || &quot;info&quot;.equals( violationSeverity );         }         else if ( &quot;warning&quot;.equals( severity ) )         {             return &quot;warning&quot;.equals( violationSeverity ) || &quot;info&quot;.equals( violationSeverity );         }         else if ( &quot;info&quot;.equals( severity ) )         {             return &quot;info&quot;.equals( violationSeverity );         }         else         {             return false;         }     }      private boolean ignore( List ignores, String source )     {         for ( RuleUtil.Matcher ignore : ignores )         {             if ( ignore.match( source ) )             {                 return true;             }         }         return false;     }      private DefaultLogger getConsoleListener()         throws MojoExecutionException     {         DefaultLogger consoleListener;          if ( useFile == null )         {             stringOutputStream = new ByteArrayOutputStream();             consoleListener = new DefaultLogger( stringOutputStream, false );         }         else         {             OutputStream out = getOutputStream( useFile );              consoleListener = new DefaultLogger( out, true );         }          return consoleListener;     }      private OutputStream getOutputStream( File file )         throws MojoExecutionException     {         File parentFile = file.getAbsoluteFile().getParentFile();          if ( !parentFile.exists() )         {             parentFile.mkdirs();         }          FileOutputStream fileOutputStream;         try         {             fileOutputStream = new FileOutputStream( file );         }         catch ( FileNotFoundException e )         {             throw new MojoExecutionException( &quot;Unable to create output stream: &quot; + file, e );         }         return fileOutputStream;     }      private AuditListener getListener()         throws MojoFailureException, MojoExecutionException     {         AuditListener listener = null;          if ( StringUtils.isNotEmpty( outputFileFormat ) )         {             File resultFile = outputFile;              OutputStream out = getOutputStream( resultFile );              if ( &quot;xml&quot;.equals( outputFileFormat ) )             {                 listener = new XMLLogger( out, true );             }             else if ( &quot;plain&quot;.equals( outputFileFormat ) )             {                 try                 {                     // Write a plain output file to the standard output file,                     // and write an XML output file to the temp directory that can be used to count violations                     outputXmlFile = File.createTempFile( &quot;checkstyle-result&quot;, &quot;.xml&quot; );                     outputXmlFile.deleteOnExit();                     OutputStream xmlOut = getOutputStream( outputXmlFile );                     CompositeAuditListener compoundListener = new CompositeAuditListener();                     compoundListener.addListener( new XMLLogger( xmlOut, true ) );                     compoundListener.addListener( new DefaultLogger( out, true ) );                     listener = compoundListener;                 }                 catch ( IOException e )                 {                     throw new MojoExecutionException( &quot;Unable to create temporary file&quot;, e );                 }             }             else             {                 throw new MojoFailureException( &quot;Invalid output file format: (&quot; + outputFileFormat                     + &quot;). Must be 'plain' or 'xml'.&quot; );             }         }          return listener;     }          private List collectArtifacts( String hint )     {         List artifacts = new ArrayList&lt;&gt;();          PluginManagement pluginManagement = project.getBuild().getPluginManagement();         if ( pluginManagement != null )         {             artifacts.addAll( getCheckstylePluginDependenciesAsArtifacts( pluginManagement.getPluginsAsMap(), hint ) );         }          artifacts.addAll( getCheckstylePluginDependenciesAsArtifacts( project.getBuild().getPluginsAsMap(), hint ) );          return artifacts;     }      private List getCheckstylePluginDependenciesAsArtifacts( Map plugins, String hint )     {         List artifacts = new ArrayList&lt;&gt;();                  Plugin checkstylePlugin = plugins.get( plugin.getGroupId() + &quot;:&quot; + plugin.getArtifactId() );         if ( checkstylePlugin != null )         {             for ( Dependency dep : checkstylePlugin.getDependencies() )             {              // @todo if we can filter on hints, it should be done here...                 String depKey = dep.getGroupId() + &quot;:&quot; + dep.getArtifactId();                 artifacts.add( (Artifact) plugin.getArtifactMap().get( depKey ) );             }         }         return artifacts;     }          private List getSourceDirectories()     {         if ( sourceDirectories == null )         {             sourceDirectories = project.getCompileSourceRoots();         }         List sourceDirs = new ArrayList&lt;&gt;( sourceDirectories.size() );         for ( String sourceDir : sourceDirectories )         {             sourceDirs.add( FileUtils.resolveFile( project.getBasedir(), sourceDir ) );         }         return sourceDirs;     }          private List getTestSourceDirectories()     {         if ( testSourceDirectories == null )         {             testSourceDirectories = project.getTestCompileSourceRoots();         }         List testSourceDirs = new ArrayList&lt;&gt;( testSourceDirectories.size() );         for ( String testSourceDir : testSourceDirectories )         {             testSourceDirs.add( FileUtils.resolveFile( project.getBasedir(), testSourceDir ) );         }         return testSourceDirs;     }      }</td>
    <td align="left">data class</td>
    <td align="left">long method, deprecated field, low cohesion, feature envy, long parameter list, data class, large class, message chains, inappropriate intimacy, data clumps, long class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method,  deprecated field,  low cohesion,  feature envy,  long parameter list,  large class,  message chains,  inappropriate intimacy,  data clumps,  long class</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11500</td>
    <td align="left">https://github.com/apache/maven-checkstyle-plugin/blob/eee0ba18a70e6d6bd51797c70a83cf844f882286/src/main/java/org/apache/maven/plugins/checkstyle/CheckstyleViolationCheckMojo.java/#L75-L872</td>
    <td align="right">2</td>
    <td align="right">1626</td>
    <td align="right">11500</td>
  </tr>
  <tr valign="top">
    <td align="right">1612</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ExtendedCompletionList {   private boolean inComplete;   private List items;    public ExtendedCompletionList(boolean incomplete, List items) {     this.inComplete = incomplete;     this.items = items;   }    public ExtendedCompletionList() {}    public List getItems() {     return items;   }    public void setItems(List items) {     this.items = items;   }    public boolean isInComplete() {     return inComplete;   }    public void setInComplete(boolean inComplete) {     this.inComplete = inComplete;   } }</td>
    <td align="left">data class</td>
    <td align="left">Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11467</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/wsagent/che-core-api-languageserver-shared/src/main/java/org/eclipse/che/api/languageserver/shared/model/ExtendedCompletionList.java/#L22-L48</td>
    <td align="right">1</td>
    <td align="right">1612</td>
    <td align="right">11467</td>
  </tr>
  <tr valign="top">
    <td align="right">1567</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{        &quot;response&quot;: &quot;YES I found bad smells&quot;,        &quot;bad_smells&quot;: [            &quot;Long Method&quot;,            &quot;Data Class&quot;        ]    }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity @Table(name = JPADynRealmMembership.TABLE) public class JPADynRealmMembership extends AbstractGeneratedKeyEntity implements DynRealmMembership {      private static final long serialVersionUID = 8157856850557493134L;      public static final String TABLE = &quot;DynRealmMembership&quot;;      @OneToOne     private JPADynRealm dynRealm;      @ManyToOne     private JPAAnyType anyType;      @NotNull     private String fiql;      @Override     public DynRealm getDynRealm() {         return dynRealm;     }      @Override     public void setDynRealm(final DynRealm dynRealm) {         checkType(dynRealm, JPADynRealm.class);         this.dynRealm = (JPADynRealm) dynRealm;     }      @Override     public AnyType getAnyType() {         return anyType;     }      @Override     public void setAnyType(final AnyType anyType) {         checkType(anyType, JPAAnyType.class);         this.anyType = (JPAAnyType) anyType;     }      @Override     public String getFIQLCond() {         return fiql;     }      @Override     public void setFIQLCond(final String fiql) {         this.fiql = fiql;     }  }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11329</td>
    <td align="left">https://github.com/apache/syncope/blob/114c412afbfba24ffb4fbc804e5308a823a16a78/core/persistence-jpa/src/main/java/org/apache/syncope/core/persistence/jpa/entity/JPADynRealmMembership.java/#L30-L79</td>
    <td align="right">1</td>
    <td align="right">1567</td>
    <td align="right">11329</td>
  </tr>
  <tr valign="top">
    <td align="right">2604</td>
    <td align="left">&nbsp;LFOAbstractType  YES I found bad smells the bad smells are: 1.Long method 2.Inappropriate intimacy 3.Magic Number 4.Missing comments 5.Inappropriate abbreviation 6.Bad naming 7.Dead Code 8.Data class 9.Feature envy 10.Incomplete comments 11.Missing final modifier 12.Tradition over Efficiency 13.Confusing naming 14.Large class 15.Lazy Class 16.Magic String 17.Refused bequest 18.Repeated switch 19.Variable length signal 20.Long method chain 21.Speculative Generality 22.Inappropriate type 23.Flat hierarchy 24.Nested method 25.Feature toggle 26.Lazy initialization 27.Method chain.</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
@Internal public abstract class LFOAbstractType {      protected int field_1_lsid;     protected int field_2_unused1;     protected int field_3_unused2;     protected byte field_4_clfolvl;     protected byte field_5_ibstFltAutoNum;     protected Grfhic field_6_grfhic;     protected byte field_7_unused3;      protected LFOAbstractType()     {         this.field_6_grfhic = new Grfhic();     }      protected void fillFields( byte[] data, int offset )     {         field_1_lsid                   = LittleEndian.getInt( data, 0x0 + offset );         field_2_unused1                = LittleEndian.getInt( data, 0x4 + offset );         field_3_unused2                = LittleEndian.getInt( data, 0x8 + offset );         field_4_clfolvl                = data[ 0xc + offset ];         field_5_ibstFltAutoNum         = data[ 0xd + offset ];         field_6_grfhic                 = new Grfhic( data, 0xe + offset );         field_7_unused3                = data[ 0xf + offset ];     }      public void serialize( byte[] data, int offset )     {         LittleEndian.putInt( data, 0x0 + offset, field_1_lsid );         LittleEndian.putInt( data, 0x4 + offset, field_2_unused1 );         LittleEndian.putInt( data, 0x8 + offset, field_3_unused2 );         data[ 0xc + offset ] = field_4_clfolvl;         data[ 0xd + offset ] = field_5_ibstFltAutoNum;         field_6_grfhic.serialize( data, 0xe + offset );         data[ 0xf + offset ] = field_7_unused3;     }      public byte[] serialize()     {         final byte[] result = new byte[ getSize() ];         serialize( result, 0 );         return result;     }      /**      * Size of record      */     public static int getSize()     {         return 0 + 4 + 4 + 4 + 1 + 1 + 1 + 1;     }      @Override     public boolean equals( Object obj )     {         if ( this == obj )             return true;         if ( obj == null )             return false;         if ( getClass() != obj.getClass() )             return false;         LFOAbstractType other = (LFOAbstractType) obj;         if ( field_1_lsid != other.field_1_lsid )             return false;         if ( field_2_unused1 != other.field_2_unused1 )             return false;         if ( field_3_unused2 != other.field_3_unused2 )             return false;         if ( field_4_clfolvl != other.field_4_clfolvl )             return false;         if ( field_5_ibstFltAutoNum != other.field_5_ibstFltAutoNum )             return false;         if ( field_6_grfhic == null )         {             if ( other.field_6_grfhic != null )                 return false;         }         else if ( !field_6_grfhic.equals( other.field_6_grfhic ) )             return false;         if ( field_7_unused3 != other.field_7_unused3 )             return false;         return true;     }      @Override     public int hashCode()     {         final int prime = 31;         int result = 1;         result = prime * result + field_1_lsid;         result = prime * result + field_2_unused1;         result = prime * result + field_3_unused2;         result = prime * result + field_4_clfolvl;         result = prime * result + field_5_ibstFltAutoNum;         result = prime * result                 + ((field_6_grfhic == null) ? 0 : field_6_grfhic.hashCode());         result = prime * result + field_7_unused3;         return result;     }      public String toString()     {         StringBuilder builder = new StringBuilder();          builder.append(&quot;[LFO]\n&quot;);         builder.append( &quot;    .lsid                 = &quot; );         builder.append(&quot; ( &quot;).append( field_1_lsid ).append( &quot; )\n&quot; );         builder.append( &quot;    .unused1              = &quot; );         builder.append(&quot; ( &quot;).append( field_2_unused1 ).append( &quot; )\n&quot; );         builder.append( &quot;    .unused2              = &quot; );         builder.append(&quot; ( &quot;).append( field_3_unused2 ).append( &quot; )\n&quot; );         builder.append( &quot;    .clfolvl              = &quot; );         builder.append(&quot; ( &quot;).append( field_4_clfolvl ).append( &quot; )\n&quot; );         builder.append( &quot;    .ibstFltAutoNum       = &quot; );         builder.append(&quot; ( &quot;).append( field_5_ibstFltAutoNum ).append( &quot; )\n&quot; );         builder.append( &quot;    .grfhic               = &quot; );         builder.append(&quot; ( &quot;).append( field_6_grfhic == null ? &quot;null&quot; : field_6_grfhic.toString().replaceAll( &quot;\n&quot;, &quot;\n    &quot; ) ).append( &quot; )\n&quot; );         builder.append( &quot;    .unused3              = &quot; );         builder.append(&quot; ( &quot;).append( field_7_unused3 ).append( &quot; )\n&quot; );          builder.append(&quot;[/LFO]&quot;);         return builder.toString();     }      /**      * A signed integer that specifies the list identifier of an LSTF. This LFO corresponds to the LSTF in PlfLst.rgLstf that has an lsid whose value is equal to this value..      */     @Internal     public int getLsid()     {         return field_1_lsid;     }      /**      * A signed integer that specifies the list identifier of an LSTF. This LFO corresponds to the LSTF in PlfLst.rgLstf that has an lsid whose value is equal to this value..      */     @Internal     public void setLsid( int field_1_lsid )     {         this.field_1_lsid = field_1_lsid;     }      /**      * This field MUST be ignored.      */     @Internal     public int getUnused1()     {         return field_2_unused1;     }      /**      * This field MUST be ignored.      */     @Internal     public void setUnused1( int field_2_unused1 )     {         this.field_2_unused1 = field_2_unused1;     }      /**      * This field MUST be ignored.      */     @Internal     public int getUnused2()     {         return field_3_unused2;     }      /**      * This field MUST be ignored.      */     @Internal     public void setUnused2( int field_3_unused2 )     {         this.field_3_unused2 = field_3_unused2;     }      /**      * An unsigned integer that specifies the field that this LFO represents..      */     @Internal     public byte getClfolvl()     {         return field_4_clfolvl;     }      /**      * An unsigned integer that specifies the field that this LFO represents..      */     @Internal     public void setClfolvl( byte field_4_clfolvl )     {         this.field_4_clfolvl = field_4_clfolvl;     }      /**      * Used for AUTONUM field emulation.      */     @Internal     public byte getIbstFltAutoNum()     {         return field_5_ibstFltAutoNum;     }      /**      * Used for AUTONUM field emulation.      */     @Internal     public void setIbstFltAutoNum( byte field_5_ibstFltAutoNum )     {         this.field_5_ibstFltAutoNum = field_5_ibstFltAutoNum;     }      /**      * HTML compatibility flags.      */     @Internal     public Grfhic getGrfhic()     {         return field_6_grfhic;     }      /**      * HTML compatibility flags.      */     @Internal     public void setGrfhic( Grfhic field_6_grfhic )     {         this.field_6_grfhic = field_6_grfhic;     }      /**      * This field MUST be ignored.      */     @Internal     public byte getUnused3()     {         return field_7_unused3;     }      /**      * This field MUST be ignored.      */     @Internal     public void setUnused3( byte field_7_unused3 )     {         this.field_7_unused3 = field_7_unused3;     }  }  // END OF CLASS</td>
    <td align="left">data class</td>
    <td align="left">Long method2Inappropriate intimacy3Magic Number4Missing comments5Inappropriate abbreviation6Bad naming7Dead Code8Data class9Feature envy</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15026</td>
    <td align="left">https://github.com/apache/poi/blob/351623a86924dab9c565e08e8cecfe151522c448/src/scratchpad/src/org/apache/poi/hwpf/model/types/LFOAbstractType.java/#L38-L290</td>
    <td align="right">2</td>
    <td align="right">2604</td>
    <td align="right">15026</td>
  </tr>
  <tr valign="top">
    <td align="right">2498</td>
    <td align="left">&nbsp;	{ 		&quot;response&quot;: &quot;YES I found bad smells&quot;, 		&quot;bad smells are&quot;: [&quot;Data Class&quot;] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Customer1131 {  	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id; 	private String firstName; 	private String lastName;  	protected Customer1131() {}  	public Customer1131(String firstName, String lastName) { 		this.firstName = firstName; 		this.lastName = lastName; 	}  	@Override 	public String toString() { 		return String.format(&quot;Customer1131[id=%d, firstName='%s', lastName='%s']&quot;, id, firstName, lastName); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14649</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer1131.java/#L8-L27</td>
    <td align="right">1</td>
    <td align="right">2498</td>
    <td align="right">14649</td>
  </tr>
  <tr valign="top">
    <td align="right">1589</td>
    <td align="left">&nbsp;		{ 			&quot;message&quot;: &quot;YES I found bad smells&quot;, 			&quot;bad smells are&quot;: [ 				&quot;Data Class&quot; 			] 		}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Capability implements IConvertible {     private String virtualCores;      private String memorySize;      private String memory;      public String getVirtualCores() {         return virtualCores;     }      public void setVirtualCores(String virtualCores) {         this.virtualCores = virtualCores;     }      public String getMemorySize() {         return memorySize;     }      public void setMemorySize(String memorySize) {         this.memorySize = memorySize;     }      public String getMemory() {         return memory;     }      public void setMemory(String memory) {         this.memory = memory;     } }</td>
    <td align="left">data class</td>
    <td align="left">Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11385</td>
    <td align="left">https://github.com/Microsoft/azure-tools-for-java/blob/d121e8ac9cc3ab400e5b49c8b372280ae332f3fb/Utils/hdinsight-node-common/src/com/microsoft/azure/hdinsight/sdk/rest/yarn/rm/Capability.java/#L26-L56</td>
    <td align="right">1</td>
    <td align="right">1589</td>
    <td align="right">11385</td>
  </tr>
  <tr valign="top">
    <td align="right">564</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: {         &quot;are&quot;: [             &quot;Data Class&quot;         ]     } }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class DrillScanRelBase extends TableScan implements DrillRelNode {   protected GroupScan groupScan;   protected final DrillTable drillTable;    public DrillScanRelBase(RelOptCluster cluster,                           RelTraitSet traits,                           RelOptTable table,                           final List columns) {     super(cluster, traits, table);     this.drillTable = Utilities.getDrillTable(table);     assert drillTable != null;     try {       this.groupScan = drillTable.getGroupScan().clone(columns);     } catch (final IOException e) {       throw new DrillRuntimeException(&quot;Failure creating scan.&quot;, e);     }   }    public DrillScanRelBase(RelOptCluster cluster,                           RelTraitSet traits,                           GroupScan grpScan,                           RelOptTable table) {     super(cluster, traits, table);     DrillTable unwrap = table.unwrap(DrillTable.class);     if (unwrap == null) {       unwrap = table.unwrap(DrillTranslatableTable.class).getDrillTable();     }     this.drillTable = unwrap;     assert drillTable != null;     this.groupScan = grpScan;   }    public DrillTable getDrillTable() {     return drillTable;   }    public GroupScan getGroupScan() {     return groupScan;   }    @Override public double estimateRowCount(RelMetadataQuery mq) {     return mq.getRowCount(this);   }    @Override public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {     double dRows = estimateRowCount(mq);     double dCpu = dRows + 1; // ensure non-zero cost     double dIo = 0;     return planner.getCostFactory().makeCost(dRows, dCpu, dIo);   } }</td>
    <td align="left">data class</td>
    <td align="left">are: data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5711</td>
    <td align="left">https://github.com/apache/drill/blob/5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3/exec/java-exec/src/main/java/org/apache/drill/exec/planner/common/DrillScanRelBase.java/#L39-L89</td>
    <td align="right">1</td>
    <td align="right">564</td>
    <td align="right">5711</td>
  </tr>
  <tr valign="top">
    <td align="right">2605</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Signal {   public enum Type { LEAVE_LOOP, LEAVE_ROUTINE, LEAVE_PROGRAM, SQLEXCEPTION, NOTFOUND, UNSUPPORTED_OPERATION, USERDEFINED };   Type type;   String value = &quot;&quot;;   Exception exception = null;      Signal(Type type, String value) {     this.type = type;     this.value = value;     this.exception = null;   }      Signal(Type type, String value, Exception exception) {     this.type = type;     this.value = value;     this.exception = exception;   }      /**    * Get the signal value (message text)    */   public String getValue() {     return value;   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15028</td>
    <td align="left">https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/hplsql/src/main/java/org/apache/hive/hplsql/Signal.java/#L24-L48</td>
    <td align="right">1</td>
    <td align="right">2605</td>
    <td align="right">15028</td>
  </tr>
  <tr valign="top">
    <td align="right">2595</td>
    <td align="left">&nbsp;	{ 		&quot;message&quot;: &quot;YES I found bad smells&quot;, 		&quot;the bad smells are&quot;: [ 			&quot;Long Method&quot;, 			&quot;Data Class&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SetOrderReferenceDetailsRequest extends DelegateRequest implements Serializable {      @Override     protected SetOrderReferenceDetailsRequest getThis() {         return this;     }      //required parameters     private String amazonOrderReferenceId;     private String orderAmount;     private CurrencyCode orderCurrencyCode;      //optional parameters     private String platformId;     private String sellerNote;     private String sellerOrderId;     private String storeName;     private String supplementaryData;     private String customInformation;     private Boolean requestPaymentAuthorization;      /**      *      * @param amazonOrderReferenceId      *              This value is retrieved from the Amazon Button widget      *              after the buyer has successfully authenticated with Amazon.      *      * @param orderAmount      *              Specifies the total amount of the order represented by this order reference.      */     public SetOrderReferenceDetailsRequest(String amazonOrderReferenceId, String orderAmount) {         this.amazonOrderReferenceId = amazonOrderReferenceId;         this.orderAmount = orderAmount;     }      /**      * Overrides the Client's currency code with specified currency code in SetOrderReferenceDetailsRequest      *      * @param currencyCode      *              A three-digit currency code, formatted based on the ISO 4217 standard.      *      * @return currenyCode      */     public SetOrderReferenceDetailsRequest setOrderCurrencyCode(CurrencyCode currencyCode) {         this.orderCurrencyCode = currencyCode;         return this;     }      /**      * Represents the SellerId of the Solution Provider that developed the platform.      * This value should only be provided by Solution Providers. It should not be      * provided by merchants creating their own custom integration.      *      * @param platformId Represents the SellerId of the Solution Provider that developed the platform.      *                   This value should only be provided by Solution Providers. It should      *                   not be provided by merchants creating their own custom integration.      *      * @return Returns a reference to this object so that methods can be chained together.      */     public SetOrderReferenceDetailsRequest setPlatformId(String platformId) {         this.platformId = platformId;         return this;     }      /**      * Represents a description of the order that is displayed in emails to the buyer.      *      * @param sellerNote Represents a description of the order that is displayed in emails to the buyer.      *      * @return Returns a reference to this object so that methods can be chained together.      */     public SetOrderReferenceDetailsRequest setSellerNote(String sellerNote) {         this.sellerNote = sellerNote;         return this;     }      /**      * The merchant-specified identifier of this order. This is displayed to the      * buyer in their emails and transaction history on the Amazon Pay website.      *      * @param sellerOrderId merchant-specified identifier of the order.      *      * @return the Seller Order ID      */     public SetOrderReferenceDetailsRequest setSellerOrderId(String sellerOrderId) {         this.sellerOrderId = sellerOrderId;         return this;     }      /**      * The identifier of the store from which the order was placed. This overrides      * the default value in Seller Central under Settings &gt; Account Settings. It is      * displayed to the buyer in their emails and transaction history on the      * Amazon Pay website.      *      * @param storeName the identifier of the store from which the order was placed.      *      * @return the Store Name      */     public SetOrderReferenceDetailsRequest setStoreName(String storeName) {         this.storeName = storeName;         return this;     }      /**      * Set the trusted authorization supplementary data.      * Use only as directed by Amazon Pay.      *      * @param supplementaryData Trusted authorization supplementary data (JSON string)      *      * @return Request object      */     public SetOrderReferenceDetailsRequest setSupplementaryData(final String supplementaryData) {         this.supplementaryData = supplementaryData;         return this;     }      /**      * Any additional information that you want to include with this order reference.      *      * @param customInformation Additional information that merchant wants to pass for the order.      *      * @return Custom Information      */     public SetOrderReferenceDetailsRequest setCustomInformation(String customInformation) {         this.customInformation = customInformation;         return this;     }      /**      *      * @return AmazonOrderReferenceId      */     public String getAmazonOrderReferenceId() {         return amazonOrderReferenceId;     }      /**      *      * @return OrderAmount      */     public String getOrderAmount() {         return orderAmount;     }      /**      *      * @return OrderCurrencyCode      */     public CurrencyCode getOrderCurrencyCode() {         return orderCurrencyCode;     }      /**      *      * @return PlatformId      */     public String getPlatformId() {         return platformId;     }      /**      *      * @return SellerNote      */     public String getSellerNote() {         return sellerNote;     }      /**      *      * @return SellerOrderId      */     public String getSellerOrderId() {         return sellerOrderId;     }      /**      *      * @return StoreName      */     public String getStoreName() {         return storeName;     }      /**      * Returns the trusted authorization supplementary data.      *      * @return supplementaryData as a JSON string      */     public String getSupplementaryData() {         return supplementaryData;     }      /**      *      * @return CustomInformation      */     public String getCustomInformation() {         return customInformation;     }      /**      *Check if payment authorization has been requested or not      *      * @return Value of the requestPaymentAuthorization      */     public Boolean getRequestPaymentAuthorization() {         return requestPaymentAuthorization;     }      /**      * Specifies if the merchants want their buyers to go through multi-factor authentication      *      * @param requestPaymentAuthorization flag exposed to merchants using which merchants      *                                    can enforce their buyers to through multi-factor authentication      *      * @return Value of the requestPaymentAuthorization      */     public SetOrderReferenceDetailsRequest setRequestPaymentAuthorization(Boolean requestPaymentAuthorization) {         this.requestPaymentAuthorization = requestPaymentAuthorization;         return this;     }      /**      * Returns a string representation of this object; useful for testing and      * debugging.      *      * @return A string representation of this object.      *      * @see java.lang.Object#toString()      */     @Override     public String toString() {         return &quot;SetOrderReferenceDetailsRequest{&quot;                 + &quot;amazonOrderReferenceId=&quot; + amazonOrderReferenceId                 + &quot;, orderAmount=&quot; + orderAmount                 + &quot;, orderCurrencyCode=&quot; + orderCurrencyCode                 + &quot;, platformId=&quot; + platformId                 + &quot;, sellerNote=&quot; + sellerNote                 + &quot;, sellerOrderId=&quot; + sellerOrderId                 + &quot;, storeName=&quot; + storeName                 + &quot;, supplementaryData=&quot; + supplementaryData                 + &quot;, customInformation=&quot; + customInformation                 + &quot;, mwsAuthToken=&quot; + getMwsAuthToken() + '}';     }  }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15005</td>
    <td align="left">https://github.com/amzn/amazon-pay-sdk-java/blob/5a3547d00c796aab8f0c8ac12e0310f7a5c4678a/src/com/amazon/pay/request/SetOrderReferenceDetailsRequest.java/#L25-L272</td>
    <td align="right">1</td>
    <td align="right">2595</td>
    <td align="right">15005</td>
  </tr>
  <tr valign="top">
    <td align="right">847</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;,  &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ActionNamesAction extends ActionSupport {      private static final long serialVersionUID = -5389385242431387840L;      private Set actionNames;     private String namespace = &quot;&quot;;     private Set namespaces;     private String extension;      protected ConfigurationHelper configHelper;      @Inject     public void setConfigurationHelper(ConfigurationHelper cfg) {         this.configHelper = cfg;     }      public Set getActionNames() {         return actionNames;     }      public String getNamespace() {         return StringEscapeUtils.escapeHtml4(namespace);     }      public void setNamespace(String namespace) {         this.namespace = namespace;     }      @Inject(StrutsConstants.STRUTS_ACTION_EXTENSION)     public void setExtension(String ext) {         this.extension = ext;     }      public ActionConfig getConfig(String actionName) {         return configHelper.getActionConfig(namespace, actionName);     }      public Set getNamespaces() {         return namespaces;     }      public String getExtension() {         if (extension == null) {             return &quot;action&quot;;         }         if (extension.contains(&quot;,&quot;)) {             return extension.substring(0, extension.indexOf(&quot;,&quot;));         }         return extension;     }      public String execute() throws Exception {         namespaces = configHelper.getNamespaces();         if (namespaces.size() == 0) {             addActionError(&quot;There are no namespaces in this configuration&quot;);             return ERROR;         }         if (namespace == null) {             namespace = &quot;&quot;;         }         actionNames = new TreeSet(configHelper.getActionNames(namespace));         return SUCCESS;     }      /**      * Index action to support cooperation with REST plugin      *      * @return action result      * @throws Exception      */     public String index() throws Exception {         return execute();     }      public String redirect() {         return SUCCESS;     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7836</td>
    <td align="left">https://github.com/apache/struts/blob/e82c5a207f62fdb1bb6e8da690325b5a109c924f/plugins/config-browser/src/main/java/org/apache/struts2/config_browser/ActionNamesAction.java/#L33-L111</td>
    <td align="right">1</td>
    <td align="right">847</td>
    <td align="right">7836</td>
  </tr>
  <tr valign="top">
    <td align="right">2107</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;1. Long Method&quot;,       &quot;2. Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  static class OfflineIteratorEnvironment implements IteratorEnvironment {      private final Authorizations authorizations;     private AccumuloConfiguration conf;     private boolean useSample;     private SamplerConfiguration sampleConf;      public OfflineIteratorEnvironment(Authorizations auths, AccumuloConfiguration acuTableConf,         boolean useSample, SamplerConfiguration samplerConf) {       this.authorizations = auths;       this.conf = acuTableConf;       this.useSample = useSample;       this.sampleConf = samplerConf;     }      @Deprecated     @Override     public AccumuloConfiguration getConfig() {       return conf;     }      @Override     public IteratorScope getIteratorScope() {       return IteratorScope.scan;     }      @Override     public boolean isFullMajorCompaction() {       return false;     }      @Override     public boolean isUserCompaction() {       return false;     }      private ArrayList&gt; topLevelIterators = new ArrayList&lt;&gt;();      @Deprecated     @Override     public void registerSideChannel(SortedKeyValueIterator iter) {       topLevelIterators.add(iter);     }      @Override     public Authorizations getAuthorizations() {       return authorizations;     }      SortedKeyValueIterator getTopLevelIterator(SortedKeyValueIterator iter) {       if (topLevelIterators.isEmpty())         return iter;       ArrayList&gt; allIters = new ArrayList&lt;&gt;(topLevelIterators);       allIters.add(iter);       return new MultiIterator(allIters, false);     }      @Override     public boolean isSamplingEnabled() {       return useSample;     }      @Override     public SamplerConfiguration getSamplerConfiguration() {       return sampleConf;     }      @Override     public IteratorEnvironment cloneWithSamplingEnabled() {       if (sampleConf == null)         throw new SampleNotPresentException();       return new OfflineIteratorEnvironment(authorizations, conf, true, sampleConf);     }   }</td>
    <td align="left">data class</td>
    <td align="left">1. long method, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">13177</td>
    <td align="left">https://github.com/apache/accumulo/blob/f896c98c2356a52dfa2235d2cc02ae556ab17909/core/src/main/java/org/apache/accumulo/core/clientImpl/OfflineIterator.java/#L70-L143</td>
    <td align="right">1</td>
    <td align="right">2107</td>
    <td align="right">13177</td>
  </tr>
  <tr valign="top">
    <td align="right">2865</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement( name = &quot;artifactTransferRequest&quot; ) public class ArtifactTransferRequest     extends Artifact     implements Serializable {     private String targetRepositoryId;      public String getTargetRepositoryId()     {         return targetRepositoryId;     }      public void setTargetRepositoryId( String targetRepositoryId )     {         this.targetRepositoryId = targetRepositoryId;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1975</td>
    <td align="left">https://github.com/apache/archiva/blob/d1242030bf232c0d9b68e4402188ee261924bf4b/archiva-modules/archiva-web/archiva-rest/archiva-rest-api/src/main/java/org/apache/archiva/rest/api/model/ArtifactTransferRequest.java/#L29-L45</td>
    <td align="right">1</td>
    <td align="right">2865</td>
    <td align="right">1975</td>
  </tr>
  <tr valign="top">
    <td align="right">2283</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Long Method&quot;,       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MqttConnectionState {  	// ******* Connection properties ******// 	private Integer receiveMaximum = 65535; 	private Integer maximumQoS = 2; 	private Boolean retainAvailable = true; 	private Long outgoingMaximumPacketSize = null; 	private Long incomingMaximumPacketSize = null; 	private Integer outgoingTopicAliasMaximum = 0; 	private Integer incomingTopicAliasMax = 0; 	private Boolean wildcardSubscriptionsAvailable = true; 	private Boolean subscriptionIdentifiersAvailable = true; 	private Boolean sharedSubscriptionsAvailable = true; 	private boolean sendReasonMessages = false; 	private long keepAlive = 60;  	// ******* Counters ******// 	private AtomicInteger nextOutgoingTopicAlias = new AtomicInteger(1);   	/** 	 * Clears the session and resets. This would be called when the connection has 	 * been lost and cleanStart = True. 	 */ 	public void clearConnectionState() { 		nextOutgoingTopicAlias.set(1); 	}   	public Integer getReceiveMaximum() { 		if (receiveMaximum == null) { 			return 65535; 		} 		return receiveMaximum; 	}  	public void setReceiveMaximum(Integer receiveMaximum) { 		this.receiveMaximum = receiveMaximum; 	}  	public Integer getMaximumQoS() { 		return maximumQoS; 	}  	public void setMaximumQoS(Integer maximumQoS) { 		this.maximumQoS = maximumQoS; 	}  	public Boolean isRetainAvailable() { 		return retainAvailable; 	}  	public void setRetainAvailable(Boolean retainAvailable) { 		this.retainAvailable = retainAvailable; 	}  	public Long getOutgoingMaximumPacketSize() { 		return outgoingMaximumPacketSize; 	}  	public void setOutgoingMaximumPacketSize(Long maximumPacketSize) { 		this.outgoingMaximumPacketSize = maximumPacketSize; 	} 	 	public Long getIncomingMaximumPacketSize() { 		return incomingMaximumPacketSize; 	}   	public void setIncomingMaximumPacketSize(Long incomingMaximumPacketSize) { 		this.incomingMaximumPacketSize = incomingMaximumPacketSize; 	}   	public Integer getOutgoingTopicAliasMaximum() { 		return outgoingTopicAliasMaximum; 	}  	public void setOutgoingTopicAliasMaximum(Integer topicAliasMaximum) { 		this.outgoingTopicAliasMaximum = topicAliasMaximum; 	}  	public Boolean isWildcardSubscriptionsAvailable() { 		return wildcardSubscriptionsAvailable; 	}  	public void setWildcardSubscriptionsAvailable(Boolean wildcardSubscriptionsAvailable) { 		this.wildcardSubscriptionsAvailable = wildcardSubscriptionsAvailable; 	}  	public Boolean isSubscriptionIdentifiersAvailable() { 		return subscriptionIdentifiersAvailable; 	}  	public void setSubscriptionIdentifiersAvailable(Boolean subscriptionIdentifiersAvailable) { 		this.subscriptionIdentifiersAvailable = subscriptionIdentifiersAvailable; 	}  	public Boolean isSharedSubscriptionsAvailable() { 		return sharedSubscriptionsAvailable; 	}  	public void setSharedSubscriptionsAvailable(Boolean sharedSubscriptionsAvailable) { 		this.sharedSubscriptionsAvailable = sharedSubscriptionsAvailable; 	} 	 	public Integer getNextOutgoingTopicAlias() { 		return nextOutgoingTopicAlias.getAndIncrement(); 	}   	public Integer getIncomingTopicAliasMax() { 		return incomingTopicAliasMax; 	}   	public void setIncomingTopicAliasMax(Integer incomingTopicAliasMax) { 		this.incomingTopicAliasMax = incomingTopicAliasMax; 	}   	public boolean isSendReasonMessages() { 		return sendReasonMessages; 	}   	public void setSendReasonMessages(boolean enableReasonMessages) { 		this.sendReasonMessages = enableReasonMessages; 	}   	public long getKeepAlive() { 		return keepAlive; 	}   	public void setKeepAliveSeconds(long keepAlive) { 		this.keepAlive = keepAlive * 1000; 	}   	 }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13842</td>
    <td align="left">https://github.com/eclipse/paho.mqtt.java/blob/5af7b53499e7dbe45b7227b3d41fc870089c0033/org.eclipse.paho.mqttv5.client/src/main/java/org/eclipse/paho/mqttv5/client/internal/MqttConnectionState.java/#L26-L168</td>
    <td align="right">1</td>
    <td align="right">2283</td>
    <td align="right">13842</td>
  </tr>
  <tr valign="top">
    <td align="right">3663</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class AnnotationSubstitutionType extends CustomSubstitutionType {      private final String name;      public AnnotationSubstitutionType(MetaAccessProvider metaAccess, ResolvedJavaType original) {         super(original);          assert original.getSuperclass().equals(metaAccess.lookupJavaType(Proxy.class));         assert metaAccess.lookupJavaType(Annotation.class).isAssignableFrom(original);          ResolvedJavaType annotationInterfaceType = AnnotationSupport.findAnnotationInterfaceType(original);         assert annotationInterfaceType.isAssignableFrom(original);         assert metaAccess.lookupJavaType(Annotation.class).isAssignableFrom(annotationInterfaceType);          String n = annotationInterfaceType.getName();         assert n.endsWith(&quot;;&quot;);         name = n.substring(0, n.length() - 1) + &quot;$$ProxyImpl;&quot;;     }      @Override     public String getName() {         return name;     }      @Override     public String toString() {         return &quot;AnnotationType&lt;&quot; + toJavaName(true) + &quot; -&gt; &quot; + original + &quot;&gt;&quot;;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8426</td>
    <td align="left">https://github.com/oracle/graal/blob/4deb681aaaa79c248115037fc8e399c9876619fd/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/annotation/AnnotationSubstitutionType.java/#L33-L61</td>
    <td align="right">1</td>
    <td align="right">3663</td>
    <td align="right">8426</td>
  </tr>
  <tr valign="top">
    <td align="right">1718</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SCOMMetricHelper {   private static final String SQLSERVER_PROPERTIES_FILE = &quot;sqlserver_properties.json&quot;;   private static final String JMX_PROPERTIES_FILE = &quot;jmx_properties.json&quot;;    private static final Map&gt;&gt; JMX_PROPERTY_IDS = readPropertyProviderIds(JMX_PROPERTIES_FILE);   private static final Map&gt;&gt; SQLSERVER_PROPERTY_IDS = readPropertyProviderIds(SQLSERVER_PROPERTIES_FILE);    public static Map&gt; getSqlServerPropertyIds(Resource.Type resourceType) {     return SQLSERVER_PROPERTY_IDS.get(resourceType.getInternalType());   }    public static Map&gt; getJMXPropertyIds(Resource.Type resourceType) {     return JMX_PROPERTY_IDS.get(resourceType.getInternalType());   }    protected static class Metric {     private String metric;     private boolean pointInTime;     private boolean temporal;      private Metric() {     }      protected Metric(String metric, boolean pointInTime, boolean temporal) {       this.metric = metric;       this.pointInTime = pointInTime;       this.temporal = temporal;     }      public String getMetric() {       return metric;     }      public void setMetric(String metric) {       this.metric = metric;     }      public boolean isPointInTime() {       return pointInTime;     }      public void setPointInTime(boolean pointInTime) {       this.pointInTime = pointInTime;     }      public boolean isTemporal() {       return temporal;     }      public void setTemporal(boolean temporal) {       this.temporal = temporal;     }   }    private static Map&gt;&gt; readPropertyProviderIds(String filename) {     ObjectMapper mapper = new ObjectMapper();      try {       Map&gt;&gt; resourceMetricMap =               mapper.readValue(ClassLoader.getSystemResourceAsStream(filename),                       new TypeReference&gt;&gt;&gt;() {});        Map&gt;&gt; resourceMetrics =               new HashMap&gt;&gt;();        for (Map.Entry&gt;&gt; resourceEntry : resourceMetricMap.entrySet()) {         Map&gt; componentMetrics = new HashMap&gt;();          for (Map.Entry&gt; componentEntry : resourceEntry.getValue().entrySet()) {           Map metrics = new HashMap();            for (Map.Entry metricEntry : componentEntry.getValue().entrySet()) {             String property = metricEntry.getKey();             Metric metric = metricEntry.getValue();              metrics.put(property, new PropertyInfo(metric.getMetric(), metric.isTemporal(), metric.isPointInTime()));           }           componentMetrics.put(componentEntry.getKey(), metrics);         }         resourceMetrics.put(resourceEntry.getKey(), componentMetrics);       }       return resourceMetrics;     }     catch (IOException e) {       throw new IllegalStateException(&quot;Can't read properties file &quot; + filename, e);     }   } }</td>
    <td align="left">data class</td>
    <td align="left">Data Class, Long Method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11785</td>
    <td align="left">https://github.com/apache/ambari/blob/2bc4779a1e6aabe638101fc8b0e28cd1963d6b13/contrib/ambari-scom/ambari-scom-server/src/main/java/org/apache/ambari/scom/utilities/SCOMMetricHelper.java/#L32-L119</td>
    <td align="right">1</td>
    <td align="right">1718</td>
    <td align="right">11785</td>
  </tr>
  <tr valign="top">
    <td align="right">925</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Builder {  	public static boolean isForced(Map options) { 		return Boolean.TRUE.equals(options.get(&quot;force&quot;)); 	}  	private Properties options = new Properties(); 	private BuilderExtension[] extensions = new BuilderExtension[0];  	private Logger logger = new NullLogger(); 	private ConfigurationRegistry registry; 	private ConfigObject configObject = null; 	private boolean isIncremental = false; 	private boolean enabledMetadata = false;  	private File sourceDir = null;  	/** 	 * The value is a String[] containing the relative paths of all of the build 	 * files for a given sourceDir. 	 */ 	private final Map buildFilesBySourceDir = new HashMap&lt;&gt;(); 	/*[PR 118220] Incremental builder is not called when file is deleted in base library*/ 	private final Map&gt; deleteFilesBySourceDir = new HashMap&lt;&gt;(); 	private final Map&gt; buildResourcesBySourceDir = new HashMap&lt;&gt;();  	private int buildFileCount = 0; 	private int deleteFileCount = 0; 	private int builtFileCount = 0; 	private int buildResourcesCount = 0; 	private File outputDir = null; 	private boolean verdict = false; 	private boolean includeIfUnsure = false; 	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 	private boolean isTestsBootPath = false; 	private boolean noWarnIncludeIf = false; 	private boolean noWarnInvalidFlags = false; 	private boolean multipleSources = false; 	private boolean updateAllCopyrights = false;  	/** 	 * J9 JCL Preprocessor builder constructor.  Initializes the needed extensions. 	 */ 	public Builder() { 		addExtension(new ExternalMessagesExtension()); 		addExtension(new MacroExtension()); 		addExtension(new JxeRulesExtension()); 		addExtension(new EclipseMetadataExtension()); 		addExtension(new JitAttributesExtension()); 		addExtension(new TagExtension()); 	}  	/** 	 * Sets the preprocess options. 	 * 	 * @param 		options		the preprocess options 	 */ 	public void setOptions(Properties options) { 		if (options != null) { 			this.options.putAll(options); 		} 		this.options = options; 	}  	/** 	 * Returns the preprocess options for this builder. 	 * 	 * @return		the preprocess options 	 */ 	public Properties getOptions() { 		return this.options; 	}  	/** 	 * Adds an extension to the builder. 	 * 	 * @param 		extension	the extension to add 	 */ 	public void addExtension(BuilderExtension extension) { 		if (extension == null) { 			throw new NullPointerException(); 		}  		BuilderExtension[] newExtensions = new BuilderExtension[extensions.length + 1]; 		if (extensions.length &gt; 0) { 			System.arraycopy(extensions, 0, newExtensions, 0, extensions.length); 		} 		newExtensions[newExtensions.length - 1] = extension; 		this.extensions = newExtensions;  		extension.setBuilder(this); 	}  	/** 	 * Returns the builder extensions/ 	 * 	 * @return		the builder extensions 	 */ 	public BuilderExtension[] getExtensions() { 		return extensions; 	}  	/** 	 * Returns the logger associated with this builder. 	 * 	 * @return		the logger 	 */ 	public Logger getLogger() { 		return logger; 	}  	/** 	 * Sets this builder's logger. 	 * 	 * @param 		logger		the new logger 	 */ 	public void setLogger(Logger logger) { 		this.logger = logger; 	}  	/** 	 * Sets whether the build is incremental or not. 	 * 	 * @param 		isIncremental	true if the build is incremental, false otherwise 	 */ 	public void setIncremental(boolean isIncremental) { 		this.isIncremental = isIncremental; 	}  	/** 	 * Returns wheter or not this builder will only do an incremental build. 	 * 	 * @return		true if the build is incremental, false otherwise 	 */ 	public boolean isIncremental() { 		return this.isIncremental; 	}  	/** 	 * Sets whether or not preprocessor metadata will be generated. 	 * 	 * @param 		enabledMetadata		true if metadata is to be generated, 	 * 									false otherwise 	 */ 	public void setMetadata(boolean enabledMetadata) { 		this.enabledMetadata = enabledMetadata; 	}  	/** 	 * Returns whether or not preprocessor metadata is enabled. 	 * 	 * @return		true if metadata will be written, false otherwise 	 */ 	public boolean isMetadataEnabled() { 		return this.enabledMetadata; 	}  	/** 	 * Sets whether or not the preprocessor should include files that do not 	 * have a INCLUDE-IF tag. 	 * 	 * @param 		include		true if files with no INCLUDE-IF should 	 * 							be included, false otherwise 	 */ 	public void setIncludeIfUnsure(boolean include) { 		this.includeIfUnsure = include; 	}  	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 	/** 	 * Sets whether or not the preprocessor is running to generate Tests Boot Path project 	 * 	 * @param 	isTestsBoot		true if preprocessor is running to generate Tests Boot Path project, 	 * 							false otherwise 	 */ 	public void setIsTestsBoot(boolean isTestsBoot) { 		this.isTestsBootPath = isTestsBoot; 	}  	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 	/** 	 * Sets whether or not the preprocessor should give warningsor errors about the files that do not 	 * have a INCLUDE-IF tag. 	 * 	 * @param 		warning		true if files with no INCLUDE-IF should 	 * 							be marked with warning or error, false otherwise 	 */ 	public void setNoWarnIncludeIf(boolean warning) { 		this.noWarnIncludeIf = warning; 	}  	/** 	 * Sets the configuration to preprocess. 	 * 	 * @param 		config		the configuration to preprocess 	 */ 	public void setConfiguration(ConfigObject config) { 		if (config.isSet()) { 			System.err.println(&quot;Warning: Builder is using &quot; + config + &quot;, a set, not a configuration.&quot;); 		} 		this.configObject = config; 		this.registry = config.getRegistry(); 		this.outputDir = config.getOutputDir(); 	}  	/** 	 * Returns this builder's output directory. 	 * 	 * @return		the output directory 	 */ 	public File getOutputDir() { 		return this.outputDir; 	}  	/** 	 * Sets this builder's output directory. 	 * 	 * @param 		outputDir	the new output directory 	 */ 	public void setOutputDir(File outputDir) { 		if (outputDir == null) { 			throw new NullPointerException(); 		} 		this.outputDir = outputDir; 	}  	/** 	 * Returns this builder's configuration source directories. 	 * 	 * @return		the config's source dirs 	 */ 	public File getSourceDir() { 		return this.sourceDir; 	}  	/** 	 * Sets the proprocess job's source directory. 	 * 	 * @param 		sourceDir	the source directory to preprocess 	 */ 	public void setSourceDir(File sourceDir) { 		if (sourceDir == null) { 			throw new NullPointerException(); 		} else { 			this.sourceDir = sourceDir; 		} 	}  	/** 	 * Set builder aware of other sources (to be used by the ExternalMessagesExtension). 	 * 	 * @param 		multipleSources		true if there are other sources, false otherwise 	 */ 	public void setMultipleSources(boolean multipleSources) { 		this.multipleSources = multipleSources; 	}  	/** 	 * Returns whether or not the configuration that setup this builder has multiple sources. 	 * 	 * @return		true if there are other sources, false otherwise 	 */ 	public boolean hasMultipleSources() { 		return multipleSources; 	}  	/** 	 * Performs the build. 	 */ 	public boolean build() { 		//create output dir even if no file is gonna be included in preprocess 		getOutputDir().mkdirs(); 		if (validateOptions()) { 			computeBuildFiles(); 			notifyBuildBegin();  			PreprocessorFactory factory = newPreprocessorFactory(); 			boolean force = isForced(this.options);  			//Ignore folders that do not exist (warning thrown in computeBuildFiles() 			if (sourceDir != null) { 				File metadataDir = new File(outputDir.getParentFile(), &quot;jppmd&quot;); 				String[] buildFiles = buildFilesBySourceDir.get(sourceDir); 				getLogger().log(&quot;\nPreprocessing &quot; + sourceDir.getAbsolutePath(), 1); 				builtFileCount = 0;  				for (String buildFile : buildFiles) { 					File sourceFile = new File(sourceDir, buildFile); 					File outputFile = new File(outputDir, buildFile); 					File metadataFile = new File(metadataDir, buildFile + &quot;.jppmd&quot;);  					notifyBuildFileBegin(sourceFile, outputFile, buildFile);  					try (OutputStream metadataOutput = new PhantomOutputStream(metadataFile); 						 OutputStream output = new PhantomOutputStream(outputFile, force)) {  						// configure the preprocessor and let extensions do the same 						JavaPreprocessor jpp;  						if (enabledMetadata) { 							jpp = factory.newPreprocessor(metadataOutput, sourceFile, output, outputFile); 						} else { 							jpp = factory.newPreprocessor(sourceFile, output); 						}  						Calendar cal = new GregorianCalendar(); 						if (!updateAllCopyrights) { 							cal.setTime(new Date(sourceFile.lastModified())); 						} 						jpp.setCopyrightYear(cal.get(Calendar.YEAR)); 						jpp.addValidFlags(registry.getValidFlags()); 						/*[PR 120411] Use a javadoc tag instead of TestBootpath preprocessor tag*/ 						jpp.setTestBootPath(isTestsBootPath); 						notifyConfigurePreprocessor(jpp);  						// preprocess 						boolean included = false; 						try { 							included = jpp.preprocess(); 							if (included) { 								builtFileCount++; 							} 							handlePreprocessorWarnings(jpp, sourceFile); 						} catch (Throwable t) { 							handlePreprocessorException(t, sourceFile); 						}  						if (!included &amp;&amp; outputFile.exists()) { 							outputFile.delete(); 						}  						if (!included &amp;&amp; metadataFile.exists()) { 							metadataFile.delete(); 						} 					} catch (Throwable t) { 						getLogger().log(&quot;Exception occured in file &quot; + sourceFile.getAbsolutePath() + &quot;, preprocess failed.&quot;, 3, t); 						handleBuildException(t); 					} finally { 						notifyBuildFileEnd(sourceFile, outputFile, buildFile); 					} 				}  				logger.log(builtFileCount + &quot; of &quot; + buildFileCount + &quot; file(s) included in preprocess&quot;, 1);  				/*[PR 118220] Incremental builder is not called when file is deleted in base library*/ 				List deleteFiles = deleteFilesBySourceDir.get(sourceDir); 				if (deleteFiles != null &amp;&amp; deleteFiles.size() != 0) { 					int deletedFilesCount = 0; 					for (String file : deleteFiles) { 						File deleteFile = new File(outputDir, file); 						if (deleteFile.exists()) { 							deletedFilesCount++; 							deleteFile.delete(); 						} 					} 					getLogger().log(deletedFilesCount + &quot; of &quot; + deleteFileCount 							+ &quot; file(s) deleted in preprocess from &quot; + outputDir.getAbsolutePath(), 1); 				} 			} 			/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 			List buildResources = buildResourcesBySourceDir.get(sourceDir); 			if (buildResources != null &amp;&amp; buildResources.size() != 0) { 				int copiedResourcesCount = 0; 				int deletedResorucesCount = 0; 				String outputpath; 				if (isTestsBootPath) { 					outputpath = configObject.getBootTestsOutputPath(); 				} else { 					outputpath = configObject.getTestsOutputPath(); 				} 				for (String file : buildResources) { 					File resource_out = new File(outputpath, file); 					File resource_src = new File(sourceDir, file); 					if (resource_src.exists()) { 						copyResource(resource_src, resource_out); 						copiedResourcesCount++; 					} else { 						resource_out.delete(); 						deletedResorucesCount++; 					} 				}  				getLogger().log(&quot;Total Build Resource Count : &quot; + buildResourcesCount, 1); 				getLogger().log(&quot;  - &quot; + copiedResourcesCount + &quot; resource&quot; + (copiedResourcesCount &gt; 1 ? &quot;s are &quot; : &quot; is &quot;) + &quot;copied to &quot; + outputpath, 1); 				getLogger().log(&quot;  - &quot; + deletedResorucesCount + &quot; resource&quot; + (deletedResorucesCount &gt; 1 ? &quot;s are &quot; : &quot; is &quot;) + &quot;deleted from &quot; + outputpath, 1); 			}  			notifyBuildEnd(); 		}  		if (logger.getErrorCount() == 0) { 			if (verdict) { 				getLogger().log(&quot;PREPROCESS WAS SUCCESSFUL&quot;, 1); 			} 			return true; 		} else { 			if (verdict) { 				getLogger().log(&quot;PREPROCESS WAS NOT SUCCESSFUL&quot;, 1); 			} 			return false; 		} 	}  	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 	public static void copyResource(File source, File destination) { 		destination.delete();  		try { 			SimpleCopy.copyFile(source, destination); 		} catch (IOException e) { 			System.err.println(&quot;ERROR - Could not copy the file to destination&quot;); 			System.err.println(&quot;   Source: &quot; + source.toString()); 			System.err.println(&quot;   Destination: &quot; + destination.toString()); 			e.printStackTrace(); 		} 	}  	/** 	 * Validates the build options. 	 */ 	private boolean validateOptions() { 		boolean isValid = true;  		if (configObject == null) { 			configObject = registry.getConfiguration(options.getProperty(&quot;config&quot;)); 		} 		this.options.putAll(configObject.getOptions());  		// check for the verdict option 		if (options.containsKey(&quot;verdict&quot;)) { 			this.verdict = true; 		}  		if (options.containsKey(&quot;includeifunsure&quot;)) { 			setIncludeIfUnsure(true); 		} 		if (options.containsKey(&quot;nowarnincludeif&quot;)) { 			setNoWarnIncludeIf(true); 		}  		if (options.containsKey(&quot;nowarninvalidflags&quot;)) { 			this.noWarnInvalidFlags = true; 		}  		if (options.containsKey(&quot;updateallcopyrights&quot;)) { 			this.updateAllCopyrights = true; 		}  		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				extension.validateOptions(this.options); 			} 		} catch (BuilderConfigurationException e) { 			logger.log(&quot;A configuration exception occured&quot;, Logger.SEVERITY_FATAL, e); 			isValid = false; 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking validateOptions() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 		return isValid; 	}  	/** 	 * Notifies the extensions that the build is beginning. 	 */ 	private void notifyBuildBegin() { 		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyBuildBegin(); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyBuildBegin() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Notifies the extensions that the build is ending. 	 */ 	private void notifyBuildEnd() { 		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyBuildEnd(); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyBuildEnd() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Notifies the extensions that the build is beginning on the specified 	 * file. 	 */ 	private void notifyBuildFileBegin(File sourceFile, File outputFile, String relativePath) { 		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyBuildFileBegin(sourceFile, outputFile, relativePath); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyBuildFileBegin() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Notifies the extensions that the build is ending on the specified file. 	 */ 	private void notifyBuildFileEnd(File sourceFile, File outputFile, String relativePath) { 		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyBuildFileEnd(sourceFile, outputFile, relativePath); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyBuildFileEnd() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Notifies the extensions that they should configure the preprocessor. 	 */ 	private void notifyConfigurePreprocessor(JavaPreprocessor preprocessor) { 		preprocessor.setIncludeIfUnsure(this.includeIfUnsure); 		preprocessor.setNoWarnIncludeIf(this.noWarnIncludeIf);  		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyConfigurePreprocessor(preprocessor); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyConfigurePreprocessor() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Handles exceptions thrown while building. 	 */ 	private void handleBuildException(Throwable t) { 		if (t instanceof Error) { 			logger.log(&quot;An error occured while building&quot;, Logger.SEVERITY_FATAL, t); 			throw (Error) t; 		} else { 			logger.log(&quot;An exception occured while building&quot;, Logger.SEVERITY_ERROR, t); 		} 	}  	/** 	 * Handles exceptions thrown by the preprocessor. 	 */ 	private void handlePreprocessorException(Throwable t, File sourceFile) { 		if (t instanceof Error) { 			logger.log(&quot;An error occured while invoking the preprocessor&quot;, &quot;preprocessor&quot;, Logger.SEVERITY_FATAL, sourceFile, t); 			throw (Error) t; 		} else { 			logger.log(&quot;An exception occured while invoking the preprocessor&quot;, &quot;preprocessor&quot;, Logger.SEVERITY_ERROR, sourceFile, t); 		} 	}  	/** 	 * Handles warnings generated by the preprocessor. 	 */ 	private void handlePreprocessorWarnings(JavaPreprocessor jpp, File sourceFile) { 		if (jpp.hasWarnings()) { 			for (PreprocessorWarning warning : jpp.getWarnings()) { 				int severity = warning.shouldFail() ? Logger.SEVERITY_ERROR : Logger.SEVERITY_WARNING; 				/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 				if (warning.getMessage().startsWith(&quot;No INCLUDE-IF&quot;) &amp;&amp; sourceFile.getAbsolutePath().endsWith(&quot;.java&quot;) &amp;&amp; !includeIfUnsure &amp;&amp; !isTestsBootPath) { 					severity = Logger.SEVERITY_ERROR; 				}  				if (warning.getMessage().startsWith(&quot;Ignoring copyright&quot;)) { 					severity = Logger.SEVERITY_INFO; 				}  				logger.log(warning.getMessage(), &quot;preprocessor&quot;, severity, sourceFile, warning.getLine(), warning.getCharstart(), warning.getCharend()); 			} 		}  		if (!noWarnInvalidFlags) { 			for (PreprocessorWarning warning : jpp.getInvalidFlags()) { 				logger.log(warning.getMessage(), &quot;preprocessor&quot;, Logger.SEVERITY_ERROR, sourceFile, warning.getLine(), warning.getCharstart(), warning.getCharend()); 			} 		} 	}  	/** 	 * Determines whether the specified source file should be built. 	 */ 	private boolean shouldBuild(File sourceFile, File outputFile, String relativePath) { 		// call the method for all the extensions 		for (BuilderExtension extension : extensions) { 			logger.setMessageSource(extension.getName()); 			boolean shouldBuild = extension.shouldBuild(sourceFile, outputFile, relativePath); 			logger.setMessageSource(null); 			if (!shouldBuild) { 				return false; 			} 		}  		return true; 	}  	/*[PR 118220] Incremental builder is not called when file is deleted in base library*/ 	/** 	 * Returns the deleted Files 	 */ 	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 	private List getDeletedFiles(File sourceDir) { 		// call the method for all the extensions 		for (BuilderExtension extension : extensions) { 			logger.setMessageSource(extension.getName()); 			List elements = extension.getDeleteFiles(sourceDir); 			logger.setMessageSource(null); 			if (elements != null) { 				return elements; 			} 		}  		return null; 	}  	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 	private List getBuildResources(File sourceDir) { 		// call the method for all the extensions 		for (BuilderExtension extension : extensions) { 			logger.setMessageSource(extension.getName()); 			List elements = extension.getBuildResources(sourceDir); 			logger.setMessageSource(null); 			if (elements != null) { 				return elements; 			} 		} 		return null; 	}  	/** 	 * Creates a new PreprocessorFactory object. 	 */ 	private PreprocessorFactory newPreprocessorFactory() { 		PreprocessorFactory factory = new PreprocessorFactory(); 		/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 		factory.setFlags(this.configObject.getFlagsAsArray()); 		factory.setRequiredIncludeFlags(this.configObject.getRequiredIncludeFlagSet()); 		return factory; 	}  	/** 	 * Recursively searches the given root directory to find all files. The file 	 * paths are returned, relative to the root directory. 	 */ 	private List getFiles(File rootDirectory) { 		List fileList = new ArrayList&lt;&gt;(); 		File[] files = rootDirectory.listFiles();  		if (files == null) { 			StringBuffer msg = new StringBuffer(&quot;Error reading the source directory \&quot;&quot;); 			msg.append(rootDirectory.getAbsolutePath()); 			msg.append(&quot;\&quot; - No Files copied&quot;); 			getLogger().log(msg.toString(), 2); 			verdict = false; 		} else { 			getFiles(files, &quot;&quot;, fileList); 		}  		return fileList; 	}  	/** 	 * This is a helper function to getFiles(File); 	 */ 	private static void getFiles(File[] files, String relativePath, List fileList) { 		for (File file : files) { 			if (file.isFile()) { 				fileList.add(relativePath + file.getName()); 			} else { 				String childRelativePath = relativePath + file.getName() + File.separator; 				getFiles(file.listFiles(), childRelativePath, fileList); 			} 		} 	}  	private void computeBuildFiles() { 		if (sourceDir.exists()) { 			List allFiles = getFiles(sourceDir); 			List buildFiles = new ArrayList&lt;&gt;(allFiles.size()); 			for (int j = 0; j &lt; allFiles.size(); j++) { 				String currentFile = allFiles.get(j).toString(); 				if (shouldBuild(sourceDir, outputDir, currentFile)) { 					buildFiles.add(currentFile); 				} 			}  			String[] buildFilesArray = buildFiles.toArray(new String[buildFiles.size()]); 			buildFilesBySourceDir.put(sourceDir, buildFilesArray); 			buildFileCount += buildFilesArray.length; 			/*[PR 118220] Incremental builder is not called when file is deleted in base library*/ 			/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 			List deleteFiles = getDeletedFiles(sourceDir); 			if (deleteFiles != null &amp;&amp; deleteFiles.size() != 0) { 				deleteFileCount = deleteFiles.size(); 				deleteFilesBySourceDir.put(sourceDir, deleteFiles); 			}  			List buildResources = getBuildResources(sourceDir); 			if (buildResources != null &amp;&amp; buildResources.size() != 0) { 				buildResourcesCount = buildResources.size(); 				buildResourcesBySourceDir.put(sourceDir, buildResources); 			} 		} else { 			logger.log(&quot;Error: Source directory does not exist: &quot; + sourceDir.getAbsolutePath(), Logger.SEVERITY_ERROR, new NullPointerException()); 			sourceDir = null; 		} 	}  	/** 	 * Returns the number of files preprocessed. 	 * 	 * @return		the number of files preprocessed 	 */ 	public int getBuildFileCount() { 		return buildFileCount; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8311</td>
    <td align="left">https://github.com/eclipse/openj9/blob/4911084853eb75b20e037c434ad4521b7317ebfb/sourcetools/com.ibm.jpp.preprocessor/com/ibm/jpp/om/Builder.java/#L41-L806</td>
    <td align="right">1</td>
    <td align="right">925</td>
    <td align="right">8311</td>
  </tr>
  <tr valign="top">
    <td align="right">1371</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;2. Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    class Whitespace implements Text {         private String text;         public Whitespace(String text) {             this.text = text;         }         @Override         public String getText() {             return text;         }     }</td>
    <td align="left">data class</td>
    <td align="left">2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10800</td>
    <td align="left">https://github.com/eclipse/ceylon/blob/d3994d6cd120c4df85952cd9432123b413cfd65a/common/src/org/eclipse/ceylon/common/config/ConfigWriter.java/#L395-L404</td>
    <td align="right">1</td>
    <td align="right">1371</td>
    <td align="right">10800</td>
  </tr>
  <tr valign="top">
    <td align="right">454</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface ExpressionNode {      String evaluateAsString(Context context);      Object evaluateAsObject(Context context);      long evaluateAsLong(Context context);      double evaluateAsDouble(Context context);      boolean evaluateAsBoolean(Context context);  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4439</td>
    <td align="left">https://github.com/apache/cayenne/blob/5be5235ed1c02589b6300e9729cf3c308c0173e8/cayenne-server/src/main/java/org/apache/cayenne/template/parser/ExpressionNode.java/#L27-L39</td>
    <td align="right">1</td>
    <td align="right">454</td>
    <td align="right">4439</td>
  </tr>
  <tr valign="top">
    <td align="right">5180</td>
    <td align="left">&nbsp;&nbsp;YES I found bad smells The bad smells are: 1. Long method 2. Feature envy 3. Data class 4. Primitive obsession 5. Divergent change 6. Temporary field 7. Lazy class </td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class AddEditNameUrlDialog extends Dialog { 	AbstractNameUrlPreferenceModel model;  	Text nameText;  	Text urlText;  	String name;  	String urlString;  	private final String explanatoryText;  	protected Label errorTextLabel;  	protected Composite composite;  	private String title;  	public AddEditNameUrlDialog(Shell parent, AbstractNameUrlPreferenceModel aModel, NameUrlPair nameUrl, 			String headerText) { 		super(parent); 		explanatoryText = headerText; 		model = aModel; 		if (nameUrl != null) { 			name = nameUrl.getName(); 			urlString = nameUrl.getUrlString(); 		} 		else { 			name = null; 			urlString = null; 		} 	}  	@Override 	protected Control createDialogArea(Composite parent) { 		composite = new Composite(parent, SWT.NONE);  		GridLayoutFactory.fillDefaults().numColumns(2).extendedMargins(5, 13, 10, 0).applyTo(composite); 		GridDataFactory.fillDefaults().grab(true, true).applyTo(composite);  		Label explanatoryTextLabel = new Label(composite, SWT.WRAP); 		explanatoryTextLabel.setText(explanatoryText); 		GridDataFactory.fillDefaults().grab(true, false).span(2, 1).applyTo(explanatoryTextLabel);  		Label nameLabel = new Label(composite, SWT.NONE); 		nameLabel.setText(NLS.bind(&quot;Name:&quot;, null)); 		nameLabel.setLayoutData(new GridData(SWT.LEFT, SWT.TOP, false, false, 1, 1));  		nameText = new Text(composite, SWT.BORDER + SWT.FILL); 		GridDataFactory.fillDefaults().grab(true, false).hint(300, SWT.DEFAULT).applyTo(nameText); 		nameText.setEditable(true); 		if (name != null &amp;&amp; name.length() &gt; 0) { 			nameText.setText(name); 		}  		Label urlLabel = new Label(composite, SWT.NONE); 		urlLabel.setText(NLS.bind(&quot;URL:&quot;, null)); 		urlLabel.setLayoutData(new GridData(SWT.LEFT, SWT.TOP, false, false, 1, 1)); 		urlText = new Text(composite, SWT.BORDER); 		GridDataFactory.fillDefaults().grab(true, false).hint(300, SWT.DEFAULT).applyTo(urlText); 		urlText.setEditable(true); 		if (urlString != null &amp;&amp; urlString.length() &gt; 0) { 			urlText.setText(urlString); 		}  		urlText.addKeyListener(getUrlValidationListener());  		String errorText = &quot;&quot;; 		errorTextLabel = new Label(composite, SWT.WRAP); 		errorTextLabel.setText(errorText); 		GridDataFactory.fillDefaults().grab(true, false).span(2, 1).applyTo(errorTextLabel);  		// getButton(IDialogConstants.OK_ID).setEnabled(validateUrl(urlString));  		return composite; 	}  	@Override 	public void create() { 		super.create(); 		if (title != null) { 			getShell().setText(title); 		} 		getButton(IDialogConstants.OK_ID).setEnabled(validateUrl(urlString)); 	}  	protected KeyListener getUrlValidationListener() { 		return new KeyListener() {  			public void keyReleased(KeyEvent e) {  				String urlString = ((Text) e.getSource()).getText().trim(); 				if (!validateUrl(urlString)) { 					getButton(IDialogConstants.OK_ID).setEnabled(false); 				} 				else { 					errorTextLabel.setText(&quot;&quot;); 					composite.update(); 					getButton(IDialogConstants.OK_ID).setEnabled(true); 				} 			}  			public void keyPressed(KeyEvent e) { 				// do nothing 			} 		}; 	}  	@Override 	protected void okPressed() { 		name = nameText.getText(); 		urlString = urlText.getText(); 		if (urlString.length() &gt; 0) { 			if (name.length() &lt;= 0) { 				name = urlString; 			} 		}  		super.okPressed(); 	}  	public String getUrlString() { 		return urlString; 	}  	public String getName() { 		return name; 	}  	protected boolean validateUrl(String urlString) { 		if (urlString != null &amp;&amp; urlString.contains(&quot; &quot;)) { 			urlString = urlString.replace(&quot; &quot;, &quot;%20&quot;); 			int caret = urlText.getCaretPosition(); 			urlText.setText(urlString); 			urlText.setSelection(caret + &quot;%20&quot;.length() - 1); 		} 		if (urlString == null || urlString.length() &lt;= 0) { 			return false; 		}  		try { 			new URI(urlString); 		} 		catch (URISyntaxException e) { 			return showError(); 		}  		try { 			URL url = new URL(urlString); 			if (url.getHost().isEmpty()) { 				return showError(); 			} 		} 		catch (MalformedURLException e) { 			return showError(); 		}  		return true; 	}  	private boolean showError() { 		errorTextLabel.setText(AddEditNameUrlDialogMessages.malformedUrl); 		composite.update(); 		return false; 	}  	protected void setTitle(String title) { 		this.title = title; 	} }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method2 Feature envy3 Data class4 Primitive obsession5 Divergent change6 Temporary field7 Lazy class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14486</td>
    <td align="left">https://github.com/spring-projects/spring-ide/blob/915fe9bffd50db45ee0b8fb993416e45dee68179/plugins/org.springframework.ide.eclipse.wizard/src/org/springframework/ide/eclipse/wizard/template/util/AddEditNameUrlDialog.java/#L38-L208</td>
    <td align="right">2</td>
    <td align="right">5180</td>
    <td align="right">14486</td>
  </tr>
  <tr valign="top">
    <td align="right">2246</td>
    <td align="left">YES I found bad smells The bad smells are: 1. Long method, 2. Feature envy, 3. Magic numbers, 4. Large Class, 5. Shotgub surgery, 6. Data class, 7. Commented out code, 8. Manual getter/setter methods, 9. Code duplication.</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public final class MessageTransfer extends Method {      public static final int TYPE = 1025;     private int _bodySize;      @Override     public final int getStructType() {         return TYPE;     }      @Override     public final int getSizeWidth() {         return 0;     }      @Override     public final int getPackWidth() {         return 2;     }      @Override     public final boolean hasPayload() {         return true;     }      @Override     public final byte getEncodedTrack() {         return Frame.L4;     }      @Override     public final boolean isConnectionControl()     {         return false;     }      private short packing_flags = 0;     private String destination;     private MessageAcceptMode acceptMode;     private MessageAcquireMode acquireMode;     private Header header;     private QpidByteBuffer _body;       public MessageTransfer() {}      public MessageTransfer(String destination, MessageAcceptMode acceptMode, MessageAcquireMode acquireMode, Header header, java.nio.ByteBuffer body, Option ... options)     {         this(destination,              acceptMode,              acquireMode,              header,              QpidByteBuffer.wrap(body),              options);     }      public MessageTransfer(String destination, MessageAcceptMode acceptMode, MessageAcquireMode acquireMode, Header header, QpidByteBuffer body, Option ... _options) {         if(destination != null) {             setDestination(destination);         }         if(acceptMode != null) {             setAcceptMode(acceptMode);         }         if(acquireMode != null) {             setAcquireMode(acquireMode);         }         setHeader(header);         setBody(body);          for (int i=0; i &lt; _options.length; i++) {             switch (_options[i]) {             case SYNC: this.setSync(true); break;             case BATCH: this.setBatch(true); break;             case UNRELIABLE: this.setUnreliable(true); break;             case NONE: break;             default: throw new IllegalArgumentException(&quot;invalid option: &quot; + _options[i]);             }         }      }      @Override     public  void dispatch(C context, MethodDelegate delegate) {         delegate.messageTransfer(context, this);     }       public final boolean hasDestination() {         return (packing_flags &amp; 256) != 0;     }      public final MessageTransfer clearDestination() {         packing_flags &amp;= ~256;         this.destination = null;         setDirty(true);         return this;     }      public final String getDestination() {         return destination;     }      public final MessageTransfer setDestination(String value) {         this.destination = value;         packing_flags |= 256;         setDirty(true);         return this;     }      public final MessageTransfer destination(String value) {         return setDestination(value);     }      public final boolean hasAcceptMode() {         return (packing_flags &amp; 512) != 0;     }      public final MessageTransfer clearAcceptMode() {         packing_flags &amp;= ~512;         this.acceptMode = null;         setDirty(true);         return this;     }      public final MessageAcceptMode getAcceptMode() {         return acceptMode;     }      public final MessageTransfer setAcceptMode(MessageAcceptMode value) {         this.acceptMode = value;         packing_flags |= 512;         setDirty(true);         return this;     }      public final MessageTransfer acceptMode(MessageAcceptMode value) {         return setAcceptMode(value);     }      public final boolean hasAcquireMode() {         return (packing_flags &amp; 1024) != 0;     }      public final MessageTransfer clearAcquireMode() {         packing_flags &amp;= ~1024;         this.acquireMode = null;         setDirty(true);         return this;     }      public final MessageAcquireMode getAcquireMode() {         return acquireMode;     }      public final MessageTransfer setAcquireMode(MessageAcquireMode value) {         this.acquireMode = value;         packing_flags |= 1024;         setDirty(true);         return this;     }      public final MessageTransfer acquireMode(MessageAcquireMode value) {         return setAcquireMode(value);     }       @Override     public final Header getHeader() {         return this.header;     }      @Override     public final void setHeader(Header header) {         this.header = header;     }      public final MessageTransfer header(Header header)     {         setHeader(header);         return this;     }      @Override     public final QpidByteBuffer getBody()     {         return _body;     }      @Override     public final void setBody(QpidByteBuffer body)     {         if (body == null)         {             _bodySize = 0;             if (_body != null)             {                 _body.dispose();             }             _body = null;         }         else         {             _body = body.duplicate();             _bodySize = _body.remaining();         }     }      @Override     public int getBodySize()     {         return _bodySize;     }      @Override     public void write(Encoder enc)     {         enc.writeUint16(packing_flags);         if ((packing_flags &amp; 256) != 0)         {             enc.writeStr8(this.destination);         }         if ((packing_flags &amp; 512) != 0)         {             enc.writeUint8(this.acceptMode.getValue());         }         if ((packing_flags &amp; 1024) != 0)         {             enc.writeUint8(this.acquireMode.getValue());         }      }      @Override     public void read(Decoder dec)     {         packing_flags = (short) dec.readUint16();         if ((packing_flags &amp; 256) != 0)         {             this.destination = dec.readStr8();         }         if ((packing_flags &amp; 512) != 0)         {             this.acceptMode = MessageAcceptMode.get(dec.readUint8());         }         if ((packing_flags &amp; 1024) != 0)         {             this.acquireMode = MessageAcquireMode.get(dec.readUint8());         }      }      @Override     public Map getFields()     {         Map result = new LinkedHashMap();          if ((packing_flags &amp; 256) != 0)         {             result.put(&quot;destination&quot;, getDestination());         }         if ((packing_flags &amp; 512) != 0)         {             result.put(&quot;acceptMode&quot;, getAcceptMode());         }         if ((packing_flags &amp; 1024) != 0)         {             result.put(&quot;acquireMode&quot;, getAcquireMode());         }           return result;     }      public void dispose()     {         if (_body != null)         {             _body.dispose();             _body = null;         }     } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method, 2 Feature envy, 3 Magic numbers, 4 Large Class, 5 Shotgub surgery, 6 Data class, 7 Commented out code, 8 Manual getter/setter methods, 9 Code duplication</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">. Long method,  2. Feature envy,  3. Magic numbers,  4. Large Class,  5. Shotgub surgery,  7. Commented out code,  8. Manual getter/setter methods,  9. Code duplication.</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13649</td>
    <td align="left">https://github.com/apache/qpid-broker-j/blob/4c4400b98a5a8493cfb9e5dbb21c97175f433a62/broker-plugins/amqp-0-10-protocol/src/main/java/org/apache/qpid/server/protocol/v0_10/transport/MessageTransfer.java/#L31-L312</td>
    <td align="right">2</td>
    <td align="right">2246</td>
    <td align="right">13649</td>
  </tr>
  <tr valign="top">
    <td align="right">2476</td>
    <td align="left">{&quot;response&quot;:&quot;YES I found bad smells&quot;,&quot;bad smells&quot;:[&quot;Long Method&quot;,&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class AbstractGroupingProperty {     protected Set columnSet;      public AbstractGroupingProperty(Set columnSet) {         this.columnSet = columnSet;     }      public Set getColumnSet() {         return columnSet;     }      // Returns normalized and concise columns from an input column set, by considering     // equivalence classes and functional dependencies.     protected Set normalizeAndReduceGroupingColumns(Set columns,             Map equivalenceClasses, List fds) {         Set normalizedColumnSet =                 getNormalizedColumnsAccordingToEqClasses(columns, equivalenceClasses);         reduceGroupingColumns(normalizedColumnSet, fds);         return normalizedColumnSet;     }      // Gets normalized columns, where each column variable is a representative variable of its equivalence class,     // therefore, the matching of properties will can consider equivalence classes.     private Set getNormalizedColumnsAccordingToEqClasses(Set columns,             Map equivalenceClasses) {         Set normalizedColumns = new ListSet&lt;&gt;();         if (equivalenceClasses == null || equivalenceClasses.isEmpty()) {             normalizedColumns.addAll(columns);             return normalizedColumns;         }         for (LogicalVariable v : columns) {             EquivalenceClass ec = equivalenceClasses.get(v);             if (ec == null) {                 normalizedColumns.add(v);             } else {                 if (ec.representativeIsConst()) {                     // trivially satisfied, so the var. can be removed                 } else {                     normalizedColumns.add(ec.getVariableRepresentative());                 }             }         }         return normalizedColumns;     }      // Using functional dependencies to eliminate unnecessary columns.     private void reduceGroupingColumns(Set columnSet, List fds) {         // the set of vars. is unordered         // so we try all FDs on all variables (incomplete algo?)         if (fds == null || fds.isEmpty()) {             return;         }         Set norm = new ListSet&lt;&gt;();         for (LogicalVariable v : columnSet) {             boolean isImpliedByAnFD = false;             for (FunctionalDependency fdep : fds) {                 if (columnSet.containsAll(fdep.getHead()) &amp;&amp; fdep.getTail().contains(v)) {                     isImpliedByAnFD = true;                     norm.addAll(fdep.getHead());                     break;                 }              }             if (!isImpliedByAnFD) {                 norm.add(v);             }         }         columnSet.retainAll(norm);     }  }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14587</td>
    <td align="left">https://github.com/apache/asterixdb/blob/223d13a06c4a4a58408aeac19674ac1f36f5ff35/hyracks-fullstack/algebricks/algebricks-core/src/main/java/org/apache/hyracks/algebricks/core/algebra/properties/AbstractGroupingProperty.java/#L29-L99</td>
    <td align="right">1</td>
    <td align="right">2476</td>
    <td align="right">14587</td>
  </tr>
  <tr valign="top">
    <td align="right">2074</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{       &quot;message&quot;: &quot;YES I found bad smells&quot;,       &quot;bad smells are&quot;: &quot;1. Long Method, 2. Data Class&quot;    }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SageRuntimeException extends RuntimeException implements SageExceptable {   protected final int kind;     public SageRuntimeException()   {     kind = UNKNOWN;   }    public SageRuntimeException(String message, int kind)   {     super(message);      this.kind = kind;   }    public SageRuntimeException(Throwable cause, int kind)   {     super(cause);      this.kind = kind;   }    public SageRuntimeException(String message, Throwable cause, int kind)   {     super(message, cause);      this.kind = kind;   }    public int getKind()   {     return (kind);   }    public boolean isKind(int kind)   {     return ((this.kind &amp; kind) != 0);   }    public String getMessage()   {     return (&quot;kind=&quot; + kind + &quot;; &quot; + super.getMessage());   } }</td>
    <td align="left">data class</td>
    <td align="left">1. long method, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13036</td>
    <td align="left">https://github.com/google/sagetv/blob/a35e3a450b4c0134cb097b9e7de76dca08eb6654/java/tv/sage/SageRuntimeException.java/#L23-L68</td>
    <td align="right">1</td>
    <td align="right">2074</td>
    <td align="right">13036</td>
  </tr>
  <tr valign="top">
    <td align="right">2512</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad_smells&quot;: [       &quot;1. Long Method&quot;,       &quot;2. Blob&quot;,       &quot;3. Data Class&quot;     ]   } </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SuppressWarnings(&quot;serial&quot;) public abstract class MqttMessageDeliveryEvent extends MqttIntegrationEvent {  	private final int messageId;  	private final String clientId;  	private final int clientInstance;  	public MqttMessageDeliveryEvent(Object source, int messageId, String clientId, int clientInstance) { 		super(source); 		this.messageId = messageId; 		this.clientId = clientId; 		this.clientInstance = clientInstance; 	}  	public int getMessageId() { 		return this.messageId; 	}  	public String getClientId() { 		return this.clientId; 	}  	public int getClientInstance() { 		return this.clientInstance; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">1. long method, 2. blob, 3. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. long method,  2. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14689</td>
    <td align="left">https://github.com/spring-projects/spring-integration/blob/872302de6e98c1fd34e3192d8e4de244008ca857/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/event/MqttMessageDeliveryEvent.java/#L28-L56</td>
    <td align="right">1</td>
    <td align="right">2512</td>
    <td align="right">14689</td>
  </tr>
  <tr valign="top">
    <td align="right">209</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ProjectList extends DataType implements Cloneable {     protected ArrayList list = new ArrayList();            /**      * add a project      * @param pro      */     public void addProjectInfo(ProjectInfo pro)     {         list.add(pro);     }          /**      * get project by index      * @param index      * @return      */     public ProjectInfo getProject(int index)     {         assert(index&gt;=0 &amp;&amp; index&lt;list.size());         return (ProjectInfo)list.get(index);     }               /**      * get count      * @return      */     public int getCount()     {         return list.size();     }            }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2311</td>
    <td align="left">https://github.com/eclipse/birt/blob/f89264810347de98702db45386a822aabc0fadbf/build/org.eclipse.birt.build/src/org/eclipse/birt/build/ProjectList.java/#L24-L61</td>
    <td align="right">1</td>
    <td align="right">209</td>
    <td align="right">2311</td>
  </tr>
  <tr valign="top">
    <td align="right">2301</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Blob&quot;,       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class Builder {          private File path;          private String interval;          private boolean incremental;          private File out;          private String filter;          private boolean ignoreMissingSegments;          private Builder() {             // Prevent external instantiation.         }          /**          * The path to an existing segment store. This parameter is required.          *          * @param path the path to an existing segment store.          * @return this builder.          */         public Builder withPath(File path) {             this.path = checkNotNull(path);             return this;         }          /**          * The two node records to diff specified as a record ID interval. This          * parameter is required.          *           * The interval is specified as two record IDs separated by two full          * stops ({@code ..}). In example, {@code 333dc24d-438f-4cca-8b21-3ebf67c05856:12345..46116fda-7a72-4dbc-af88-a09322a7753a:67890}.          * Instead of using a full record ID, it is possible to use the special          * placeholder {@code head}. This placeholder is translated to the          * record ID of the most recent head state.          *          * @param interval an interval between two node record IDs.          * @return this builder.          */         public Builder withInterval(String interval) {             this.interval = checkNotNull(interval);             return this;         }          /**          * Set whether or not to perform an incremental diff of the specified          * interval. An incremental diff shows every change between the two          * records at every revision available to the segment store. This          * parameter is not mandatory and defaults to {@code false}.          *          * @param incremental {@code true} to perform an incremental diff,          *                    {@code false} otherwise.          * @return this builder.          */         public Builder withIncremental(boolean incremental) {             this.incremental = incremental;             return this;         }          /**          * The file where the output of this command is stored. this parameter          * is mandatory.          *          * @param file the output file.          * @return this builder.          */         public Builder withOutput(File file) {             this.out = checkNotNull(file);             return this;         }          /**          * The path to a subtree. If specified, this parameter allows to          * restrict the diff to the specified subtree. This parameter is not          * mandatory and defaults to the entire tree.          *          * @param filter a path used as as filter for the resulting diff.          * @return this builder.          */         public Builder withFilter(String filter) {             this.filter = checkNotNull(filter);             return this;         }          /**          * Whether to ignore exceptions caused by missing segments in the          * segment store. This parameter is not mandatory and defaults to {@code          * false}.          *          * @param ignoreMissingSegments {@code true} to ignore exceptions caused          *                              by missing segments, {@code false}          *                              otherwise.          * @return this builder.          */         public Builder withIgnoreMissingSegments(boolean ignoreMissingSegments) {             this.ignoreMissingSegments = ignoreMissingSegments;             return this;         }          /**          * Create an executable version of the {@link Diff} command.          *          * @return an instance of {@link Runnable}.          */         public Diff build() {             checkNotNull(path);             checkNotNull(interval);             checkNotNull(out);             checkNotNull(filter);             return new Diff(this);         }      }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14036</td>
    <td align="left">https://github.com/apache/jackrabbit-oak/blob/fa85f54a065e01c0a1cb8c03af74194fdf521ddd/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/tool/Diff.java/#L56-L171</td>
    <td align="right">1</td>
    <td align="right">2301</td>
    <td align="right">14036</td>
  </tr>
  <tr valign="top">
    <td align="right">2102</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;response&quot;: &quot;YES, I found bad smells&quot;,         &quot;detected_smells&quot;: [             &quot;Data Class&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class Value {         int        count = 0;         BigInteger txid;     }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13161</td>
    <td align="left">https://github.com/alibaba/jstorm/blob/5d6cde22dbca7df3d6e6830bf94f98a6639ab559/example/sequence-split-merge/src/main/java/com/alipay/dw/jstorm/transcation/TransactionalGlobalCount.java/#L93-L96</td>
    <td align="right">1</td>
    <td align="right">2102</td>
    <td align="right">13161</td>
  </tr>
  <tr valign="top">
    <td align="right">1369</td>
    <td align="left">{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;Long Method&quot;,     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Job20LineHistoryEventEmitter extends HistoryEventEmitter {    static List nonFinals =       new LinkedList();   static List finals = new LinkedList();    Long originalSubmitTime = null;    static {     nonFinals.add(new JobSubmittedEventEmitter());     nonFinals.add(new JobPriorityChangeEventEmitter());     nonFinals.add(new JobStatusChangedEventEmitter());     nonFinals.add(new JobInitedEventEmitter());     nonFinals.add(new JobInfoChangeEventEmitter());      finals.add(new JobUnsuccessfulCompletionEventEmitter());     finals.add(new JobFinishedEventEmitter());   }    Job20LineHistoryEventEmitter() {     super();   }    static private class JobSubmittedEventEmitter extends SingleEventEmitter {     HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName,         HistoryEventEmitter thatg) {       JobID jobID = JobID.forName(jobIDName);        if (jobIDName == null) {         return null;       }        String submitTime = line.get(&quot;SUBMIT_TIME&quot;);       String jobConf = line.get(&quot;JOBCONF&quot;);       String user = line.get(&quot;USER&quot;);       if (user == null) {         user = &quot;nulluser&quot;;       }       String jobName = line.get(&quot;JOBNAME&quot;);       String jobQueueName = line.get(&quot;JOB_QUEUE&quot;);// could be null       String workflowId = line.get(&quot;WORKFLOW_ID&quot;);       if (workflowId == null) {         workflowId = &quot;&quot;;       }       String workflowName = line.get(&quot;WORKFLOW_NAME&quot;);       if (workflowName == null) {         workflowName = &quot;&quot;;       }       String workflowNodeName = line.get(&quot;WORKFLOW_NODE_NAME&quot;);       if (workflowNodeName == null) {         workflowNodeName = &quot;&quot;;       }       String workflowAdjacencies = line.get(&quot;WORKFLOW_ADJACENCIES&quot;);       if (workflowAdjacencies == null) {         workflowAdjacencies = &quot;&quot;;       }       String workflowTags = line.get(&quot;WORKFLOW_TAGS&quot;);       if (workflowTags == null) {         workflowTags = &quot;&quot;;       }               if (submitTime != null) {         Job20LineHistoryEventEmitter that =             (Job20LineHistoryEventEmitter) thatg;          that.originalSubmitTime = Long.parseLong(submitTime);          Map jobACLs =           new HashMap();         return new JobSubmittedEvent(jobID, jobName, user,             that.originalSubmitTime, jobConf, jobACLs, jobQueueName,             workflowId, workflowName, workflowNodeName, workflowAdjacencies,             workflowTags);       }        return null;     }   }    static private class JobPriorityChangeEventEmitter extends SingleEventEmitter {     HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName,         HistoryEventEmitter thatg) {       JobID jobID = JobID.forName(jobIDName);        if (jobIDName == null) {         return null;       }        String priority = line.get(&quot;JOB_PRIORITY&quot;);        if (priority != null) {         return new JobPriorityChangeEvent(jobID, JobPriority.valueOf(priority));       }        return null;     }   }    static private class JobInitedEventEmitter extends SingleEventEmitter {     HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName,         HistoryEventEmitter thatg) {       if (jobIDName == null) {         return null;       }        JobID jobID = JobID.forName(jobIDName);        String launchTime = line.get(&quot;LAUNCH_TIME&quot;);       String status = line.get(&quot;JOB_STATUS&quot;);       String totalMaps = line.get(&quot;TOTAL_MAPS&quot;);       String totalReduces = line.get(&quot;TOTAL_REDUCES&quot;);       String uberized = line.get(&quot;UBERIZED&quot;);        if (launchTime != null &amp;&amp; totalMaps != null &amp;&amp; totalReduces != null) {         return new JobInitedEvent(jobID, Long.parseLong(launchTime), Integer             .parseInt(totalMaps), Integer.parseInt(totalReduces), status,             Boolean.parseBoolean(uberized));       }        return null;     }   }    static private class JobStatusChangedEventEmitter extends SingleEventEmitter {     HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName,         HistoryEventEmitter thatg) {       if (jobIDName == null) {         return null;       }        JobID jobID = JobID.forName(jobIDName);        String status = line.get(&quot;JOB_STATUS&quot;);        if (status != null) {         return new JobStatusChangedEvent(jobID, status);       }        return null;     }   }    static private class JobInfoChangeEventEmitter extends SingleEventEmitter {     HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName,         HistoryEventEmitter thatg) {       if (jobIDName == null) {         return null;       }        JobID jobID = JobID.forName(jobIDName);        String launchTime = line.get(&quot;LAUNCH_TIME&quot;);        if (launchTime != null) {         Job20LineHistoryEventEmitter that =             (Job20LineHistoryEventEmitter) thatg;         return new JobInfoChangeEvent(jobID, that.originalSubmitTime, Long             .parseLong(launchTime));       }        return null;     }   }    static private class JobUnsuccessfulCompletionEventEmitter extends       SingleEventEmitter {     HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName,         HistoryEventEmitter thatg) {       if (jobIDName == null) {         return null;       }        JobID jobID = JobID.forName(jobIDName);        String finishTime = line.get(&quot;FINISH_TIME&quot;);        String status = line.get(&quot;JOB_STATUS&quot;);        String finishedMaps = line.get(&quot;FINISHED_MAPS&quot;);       String finishedReduces = line.get(&quot;FINISHED_REDUCES&quot;);        if (status != null &amp;&amp; !status.equalsIgnoreCase(&quot;success&quot;)           &amp;&amp; finishTime != null &amp;&amp; finishedMaps != null           &amp;&amp; finishedReduces != null) {         return new JobUnsuccessfulCompletionEvent(jobID, Long             .parseLong(finishTime), Integer.parseInt(finishedMaps), Integer             .parseInt(finishedReduces), -1, -1, -1, -1, status);       }        return null;     }   }    static private class JobFinishedEventEmitter extends SingleEventEmitter {     HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName,         HistoryEventEmitter thatg) {       if (jobIDName == null) {         return null;       }        JobID jobID = JobID.forName(jobIDName);        String finishTime = line.get(&quot;FINISH_TIME&quot;);        String status = line.get(&quot;JOB_STATUS&quot;);        String finishedMaps = line.get(&quot;FINISHED_MAPS&quot;);       String finishedReduces = line.get(&quot;FINISHED_REDUCES&quot;);        String failedMaps = line.get(&quot;FAILED_MAPS&quot;);       String failedReduces = line.get(&quot;FAILED_REDUCES&quot;);        String counters = line.get(&quot;COUNTERS&quot;);        if (status != null &amp;&amp; status.equalsIgnoreCase(&quot;success&quot;)           &amp;&amp; finishTime != null &amp;&amp; finishedMaps != null           &amp;&amp; finishedReduces != null) {         return new JobFinishedEvent(jobID, Long.parseLong(finishTime), Integer             .parseInt(finishedMaps), Integer.parseInt(finishedReduces), Integer             .parseInt(failedMaps), Integer.parseInt(failedReduces), -1, -1,             null, null, maybeParseCounters(counters));       }        return null;     }   }    @Override   List finalSEEs() {     return finals;   }    @Override   List nonFinalSEEs() {     return nonFinals;   }  }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10791</td>
    <td align="left">https://github.com/apache/hadoop/blob/128dd91e10080bdcbcd7d555fa3c4105e55a6b51/hadoop-tools/hadoop-rumen/src/main/java/org/apache/hadoop/tools/rumen/Job20LineHistoryEventEmitter.java/#L39-L277</td>
    <td align="right">1</td>
    <td align="right">1369</td>
    <td align="right">10791</td>
  </tr>
  <tr valign="top">
    <td align="right">2590</td>
    <td align="left">&nbsp;{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Data Class&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
class FloatFilterFunction extends AbstractFloatValue {   private final FloatValue baseExpr;   private final BooleanValue filterExpr;   public static final String name = FilterFunction.name;   private final String exprStr;   private final ExpressionType funcType;      public FloatFilterFunction(FloatValue baseExpr, BooleanValue filterExpr) throws SolrException {     this.baseExpr = baseExpr;     this.filterExpr = filterExpr;     this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);     this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);   }      boolean exists = false;    @Override   public float getFloat() {     float value = baseExpr.getFloat();     exists = baseExpr.exists() &amp;&amp; filterExpr.getBoolean() &amp;&amp; filterExpr.exists();     return value;   }   @Override   public boolean exists() {     return exists;   }      @Override   public String getName() {     return name;   }   @Override   public String getExpressionStr() {     return exprStr;   }   @Override   public ExpressionType getExpressionType() {     return funcType;   } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14997</td>
    <td align="left">https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/FilterFunction.java/#L462-L501</td>
    <td align="right">1</td>
    <td align="right">2590</td>
    <td align="right">14997</td>
  </tr>
  <tr valign="top">
    <td align="right">73</td>
    <td align="left">{&quot;answer&quot;:&quot;YES I found bad smells&quot;,&quot;detectedBadSmells&quot;:[&quot;Long Method&quot;,&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class AbstractAzureMojo extends AbstractMojo implements TelemetryConfiguration, AuthConfiguration {     public static final String PLUGIN_NAME_KEY = &quot;pluginName&quot;;     public static final String PLUGIN_VERSION_KEY = &quot;pluginVersion&quot;;     public static final String INSTALLATION_ID_KEY = &quot;installationId&quot;;     public static final String SESSION_ID_KEY = &quot;sessionId&quot;;     public static final String SUBSCRIPTION_ID_KEY = &quot;subscriptionId&quot;;     public static final String AUTH_TYPE = &quot;authType&quot;;     public static final String TELEMETRY_NOT_ALLOWED = &quot;TelemetryNotAllowed&quot;;     public static final String INIT_FAILURE = &quot;InitFailure&quot;;     public static final String AZURE_INIT_FAIL = &quot;Failed to authenticate with Azure. Please check your configuration.&quot;;     public static final String FAILURE_REASON = &quot;failureReason&quot;;     private static final String CONFIGURATION_PATH = Paths.get(System.getProperty(&quot;user.home&quot;),         &quot;.azure&quot;, &quot;mavenplugins.properties&quot;).toString();     private static final String FIRST_RUN_KEY = &quot;first.run&quot;;     private static final String PRIVACY_STATEMENT = &quot;\nData/Telemetry\n&quot; +         &quot;---------\n&quot; +         &quot;This project collects usage data and sends it to Microsoft to help improve our products and services.\n&quot; +         &quot;Read Microsoft's privacy statement to learn more: https://privacy.microsoft.com/en-us/privacystatement.&quot; +         &quot;\n\nYou can change your telemetry configuration through 'allowTelemetry' property.\n&quot; +         &quot;For more information, please go to https://aka.ms/azure-maven-config.\n&quot;;      //region Properties      @Parameter(defaultValue = &quot;${project}&quot;, readonly = true, required = true)     protected MavenProject project;      @Parameter(defaultValue = &quot;${session}&quot;, readonly = true, required = true)     protected MavenSession session;      @Parameter(defaultValue = &quot;${project.build.directory}&quot;, readonly = true, required = true)     protected File buildDirectory;      @Parameter(defaultValue = &quot;${plugin}&quot;, readonly = true, required = true)     protected PluginDescriptor plugin;      /**      * The system settings for Maven. This is the instance resulting from      * merging global and user-level settings files.      */     @Parameter(defaultValue = &quot;${settings}&quot;, readonly = true, required = true)     protected Settings settings;      @Component(role = MavenResourcesFiltering.class, hint = &quot;default&quot;)     protected MavenResourcesFiltering mavenResourcesFiltering;      /**      * Authentication setting for Azure Management API.      * Below are the supported sub-elements within {@code }. You can use one of them to authenticate      * with azure      * {@code } specifies the credentials of your Azure service principal, by referencing a server definition      * in Maven's settings.xml      * {@code } specifies the absolute path of your authentication file for Azure.      *      * @since 0.1.0      */     @Parameter     protected AuthenticationSetting authentication;      /**      * Azure subscription Id. You only need to specify it when:      *       * you are using authentication file      * there are more than one subscription in the authentication file      *       *      * @since 0.1.0      */     @Parameter     protected String subscriptionId = &quot;&quot;;      /**      * Boolean flag to turn on/off telemetry within current Maven plugin.      *      * @since 0.1.0      */     @Parameter(property = &quot;allowTelemetry&quot;, defaultValue = &quot;true&quot;)     protected boolean allowTelemetry;      /**      * Boolean flag to control whether throwing exception from current Maven plugin when meeting any error.      * If set to true, the exception from current Maven plugin will fail the current Maven run.      *      * @since 0.1.0      */     @Parameter(property = &quot;failsOnError&quot;, defaultValue = &quot;true&quot;)     protected boolean failsOnError;      /**      * Use a HTTP proxy host for the Azure Auth Client      */     @Parameter(property = &quot;httpProxyHost&quot;, readonly = false, required = false)     protected String httpProxyHost;      /**      * Use a HTTP proxy port for the Azure Auth Client      */     @Parameter(property = &quot;httpProxyPort&quot;, defaultValue = &quot;80&quot;)     protected int httpProxyPort;      private AzureAuthHelper azureAuthHelper = new AzureAuthHelper(this);      private Azure azure;      private TelemetryProxy telemetryProxy;      private String sessionId = UUID.randomUUID().toString();      private String installationId = GetHashMac.getHashMac();      //endregion      //region Getter      public MavenProject getProject() {         return project;     }      public MavenSession getSession() {         return session;     }      public String getBuildDirectoryAbsolutePath() {         return buildDirectory.getAbsolutePath();     }      public MavenResourcesFiltering getMavenResourcesFiltering() {         return mavenResourcesFiltering;     }      public Settings getSettings() {         return settings;     }      public AuthenticationSetting getAuthenticationSetting() {         return authentication;     }      public String getSubscriptionId() {         return subscriptionId;     }      public boolean isTelemetryAllowed() {         return allowTelemetry;     }      public boolean isFailingOnError() {         return failsOnError;     }      public String getSessionId() {         return sessionId;     }      public String getInstallationId() {         return installationId == null ? &quot;&quot; : installationId;     }      public String getPluginName() {         return plugin.getArtifactId();     }      public String getPluginVersion() {         return plugin.getVersion();     }      public String getUserAgent() {         return isTelemetryAllowed() ? String.format(&quot;%s/%s %s:%s %s:%s&quot;, getPluginName(), getPluginVersion(),                         INSTALLATION_ID_KEY, getInstallationId(), SESSION_ID_KEY, getSessionId())                 : String.format(&quot;%s/%s&quot;, getPluginName(), getPluginVersion());     }      public String getHttpProxyHost() {         return httpProxyHost;     }            public int getHttpProxyPort() {         return httpProxyPort;     }       public Azure getAzureClient() throws AzureAuthFailureException {         if (azure == null) {             azure = azureAuthHelper.getAzureClient();             if (azure == null) {                 getTelemetryProxy().trackEvent(INIT_FAILURE);                 throw new AzureAuthFailureException(AZURE_INIT_FAIL);             } else {                 // Repopulate subscriptionId in case it is not configured.                 getTelemetryProxy().addDefaultProperty(SUBSCRIPTION_ID_KEY, azure.subscriptionId());             }         }         return azure;     }      public TelemetryProxy getTelemetryProxy() {         if (telemetryProxy == null) {             initTelemetry();         }         return telemetryProxy;     }      protected void initTelemetry() {         telemetryProxy = new AppInsightsProxy(this);         if (!isTelemetryAllowed()) {             telemetryProxy.trackEvent(TELEMETRY_NOT_ALLOWED);             telemetryProxy.disable();         }     }      //endregion      //region Telemetry Configuration Interface      public Map getTelemetryProperties() {         final Map map = new HashMap&lt;&gt;();         map.put(INSTALLATION_ID_KEY, getInstallationId());         map.put(PLUGIN_NAME_KEY, getPluginName());         map.put(PLUGIN_VERSION_KEY, getPluginVersion());         map.put(SUBSCRIPTION_ID_KEY, getSubscriptionId());         map.put(SESSION_ID_KEY, getSessionId());         map.put(AUTH_TYPE, getAuthType());         return map;     }      // TODO:     // Add AuthType ENUM and move to AzureAuthHelper.     public String getAuthType() {         final AuthenticationSetting authSetting = getAuthenticationSetting();         if (authSetting == null) {             return &quot;AzureCLI&quot;;         }         if (StringUtils.isNotEmpty(authSetting.getServerId())) {             return &quot;ServerId&quot;;         }         if (authSetting.getFile() != null) {             return &quot;AuthFile&quot;;         }         return &quot;Unknown&quot;;     }      //endregion      //region Entry Point      @Override     public void execute() throws MojoExecutionException {         try {             // Work around for Application Insights Java SDK:             // Sometimes, NoClassDefFoundError will be thrown even after Maven build is completed successfully.             // An issue has been filed at https://github.com/Microsoft/ApplicationInsights-Java/issues/416             // Before this issue is fixed, set default uncaught exception handler for all threads as work around.             Thread.setDefaultUncaughtExceptionHandler(new DefaultUncaughtExceptionHandler());              final Properties prop = new Properties();             if (isFirstRun(prop)) {                 infoWithMultipleLines(PRIVACY_STATEMENT);                 updateConfigurationFile(prop);             }              if (isSkipMojo()) {                 info(&quot;Skip execution.&quot;);                 trackMojoSkip();             } else {                 trackMojoStart();                  doExecute();                  trackMojoSuccess();             }         } catch (Exception e) {             handleException(e);         } finally {             // When maven goal executes too quick, The HTTPClient of AI SDK may not fully initialized and will step             // into endless loop when close, we need to call it in main thread.             // Refer here for detail codes: https://github.com/Microsoft/ApplicationInsights-Java/blob/master/core/src             // /main/java/com/microsoft/applicationinsights/internal/channel/common/ApacheSender43.java#L103             ApacheSenderFactory.INSTANCE.create().close();         }     }      /**      * Sub-class can override this method to decide whether skip execution.      *      * @return Boolean to indicate whether skip execution.      */     protected boolean isSkipMojo() {         return false;     }      /**      * Entry point of sub-class. Sub-class should implement this method to do real work.      *      * @throws Exception      */     protected abstract void doExecute() throws Exception;      //endregion      //region Telemetry      protected void trackMojoSkip() {         getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + &quot;.skip&quot;);     }      protected void trackMojoStart() {         getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + &quot;.start&quot;);     }      protected void trackMojoSuccess() {         getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + &quot;.success&quot;);     }      protected void trackMojoFailure(final String message) {         final HashMap failureReason = new HashMap&lt;&gt;();         failureReason.put(FAILURE_REASON, message);         getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + &quot;.failure&quot;, failureReason);     }      //endregion      //region Helper methods      protected void handleException(final Exception exception) throws MojoExecutionException {         String message = exception.getMessage();         if (StringUtils.isEmpty(message)) {             message = exception.toString();         }         trackMojoFailure(message);          if (isFailingOnError()) {             throw new MojoExecutionException(message, exception);         } else {             error(message);         }     }      private boolean isFirstRun(Properties prop) {         try {             final File configurationFile = new File(CONFIGURATION_PATH);             if (configurationFile.exists()) {                 try (InputStream input = new FileInputStream(CONFIGURATION_PATH)) {                     prop.load(input);                     final String firstRunValue = prop.getProperty(FIRST_RUN_KEY);                     if (firstRunValue != null &amp;&amp; !firstRunValue.isEmpty() &amp;&amp; firstRunValue.equalsIgnoreCase(&quot;false&quot;)) {                         return false;                     }                 }             } else {                 configurationFile.getParentFile().mkdirs();                 configurationFile.createNewFile();             }         } catch (Exception e) {             // catch exceptions here to avoid blocking mojo execution.             debug(e.getMessage());         }         return true;     }      private void updateConfigurationFile(Properties prop) {         try (OutputStream output = new FileOutputStream(CONFIGURATION_PATH)) {             prop.setProperty(FIRST_RUN_KEY, &quot;false&quot;);             prop.store(output, &quot;Azure Maven Plugin configurations&quot;);         } catch (Exception e) {             // catch exceptions here to avoid blocking mojo execution.             debug(e.getMessage());         }     }      protected class DefaultUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {         @Override         public void uncaughtException(Thread t, Throwable e) {             debug(&quot;uncaughtException: &quot; + e);         }     }      //endregion      //region Logging      public void debug(final String message) {         getLog().debug(message);     }      public void info(final String message) {         getLog().info(message);     }      public void infoWithMultipleLines(final String messages) {         final String[] messageArray = messages.split(&quot;\\n&quot;);         for (final String line : messageArray) {             getLog().info(line);         }     }      public void warning(final String message) {         getLog().warn(message);     }      public void error(final String message) {         getLog().error(message);     }      //endregion }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1109</td>
    <td align="left">https://github.com/Microsoft/azure-maven-plugins/blob/d3e0b6fa0e00f38c04b622589a939fb3bae2227e/azure-maven-plugin-lib/src/main/java/com/microsoft/azure/maven/AbstractAzureMojo.java/#L45-L447</td>
    <td align="right">1</td>
    <td align="right">73</td>
    <td align="right">1109</td>
  </tr>
  <tr valign="top">
    <td align="right">1406</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SparkVersion {   private static final Logger logger = LoggerFactory.getLogger(SparkVersion.class);    public static final SparkVersion SPARK_1_6_0 = SparkVersion.fromVersionString(&quot;1.6.0&quot;);    public static final SparkVersion SPARK_2_0_0 = SparkVersion.fromVersionString(&quot;2.0.0&quot;);   public static final SparkVersion SPARK_2_3_0 = SparkVersion.fromVersionString(&quot;2.3.0&quot;);   public static final SparkVersion SPARK_2_3_1 = SparkVersion.fromVersionString(&quot;2.3.1&quot;);   public static final SparkVersion SPARK_2_4_0 = SparkVersion.fromVersionString(&quot;2.4.0&quot;);   public static final SparkVersion SPARK_3_0_0 = SparkVersion.fromVersionString(&quot;3.0.0&quot;);    public static final SparkVersion MIN_SUPPORTED_VERSION =  SPARK_1_6_0;   public static final SparkVersion UNSUPPORTED_FUTURE_VERSION = SPARK_3_0_0;    private int version;   private int majorVersion;   private int minorVersion;   private int patchVersion;   private String versionString;    SparkVersion(String versionString) {     this.versionString = versionString;      try {       int pos = versionString.indexOf('-');        String numberPart = versionString;       if (pos &gt; 0) {         numberPart = versionString.substring(0, pos);       }        String versions[] = numberPart.split(&quot;\\.&quot;);       this.majorVersion = Integer.parseInt(versions[0]);       this.minorVersion = Integer.parseInt(versions[1]);       this.patchVersion = Integer.parseInt(versions[2]);       // version is always 5 digits. (e.g. 2.0.0 -&gt; 20000, 1.6.2 -&gt; 10602)       version = Integer.parseInt(String.format(&quot;%d%02d%02d&quot;, majorVersion, minorVersion, patchVersion));     } catch (Exception e) {       logger.error(&quot;Can not recognize Spark version &quot; + versionString +           &quot;. Assume it's a future release&quot;, e);        // assume it is future release       version = 99999;     }   }    public int toNumber() {     return version;   }    public String toString() {     return versionString;   }    public boolean isUnsupportedVersion() {     return olderThan(MIN_SUPPORTED_VERSION) || newerThanEquals(UNSUPPORTED_FUTURE_VERSION);   }    public static SparkVersion fromVersionString(String versionString) {     return new SparkVersion(versionString);   }    public boolean isSpark2() {     return this.newerThanEquals(SPARK_2_0_0);   }    public boolean isSecretSocketSupported() {     return this.newerThanEquals(SparkVersion.SPARK_2_4_0) ||             this.newerThanEqualsPatchVersion(SPARK_2_3_1) ||             this.newerThanEqualsPatchVersion(SparkVersion.fromVersionString(&quot;2.2.2&quot;)) ||             this.newerThanEqualsPatchVersion(SparkVersion.fromVersionString(&quot;2.1.3&quot;));   }    public boolean equals(Object versionToCompare) {     return version == ((SparkVersion) versionToCompare).version;   }    public boolean newerThan(SparkVersion versionToCompare) {     return version &gt; versionToCompare.version;   }    public boolean newerThanEquals(SparkVersion versionToCompare) {     return version &gt;= versionToCompare.version;   }    public boolean newerThanEqualsPatchVersion(SparkVersion versionToCompare) {     return majorVersion == versionToCompare.majorVersion &amp;&amp;             minorVersion == versionToCompare.minorVersion &amp;&amp;             patchVersion &gt;= versionToCompare.patchVersion;   }    public boolean olderThan(SparkVersion versionToCompare) {     return version &lt; versionToCompare.version;   }    public boolean olderThanEquals(SparkVersion versionToCompare) {     return version &lt;= versionToCompare.version;   } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10877</td>
    <td align="left">https://github.com/apache/zeppelin/blob/4219d552349f8f7f3e6de34505b8a8ae9835f98b/spark/interpreter/src/main/java/org/apache/zeppelin/spark/SparkVersion.java/#L25-L123</td>
    <td align="right">1</td>
    <td align="right">1406</td>
    <td align="right">10877</td>
  </tr>
  <tr valign="top">
    <td align="right">1489</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public static final class VertexGroupItem extends Tuple4, Long&gt; {  		private final Either.Right nullValue = new Either.Right&lt;&gt;(NullValue.getInstance());  		public VertexGroupItem() { 			reset(); 		}  		public K getVertexId() { 			return f0; 		}  		public void setVertexId(K vertexId) { 			f0 = vertexId; 		}  		public K getGroupRepresentativeId() { 			return f1; 		}  		public void setGroupRepresentativeId(K groupRepresentativeId) { 			f1 = groupRepresentativeId; 		}  		public VGV getVertexGroupValue() { 			return f2.isLeft() ? f2.left() : null; 		}  		public void setVertexGroupValue(VGV vertexGroupValue) { 			if (vertexGroupValue == null) { 				f2 = nullValue; 			} else { 				f2 = new Either.Left&lt;&gt;(vertexGroupValue); 			} 		}  		public Long getVertexGroupCount() { 			return f3; 		}  		public void setVertexGroupCount(Long vertexGroupCount) { 			f3 = vertexGroupCount; 		}  		/** 		 * Resets the fields to initial values. This is necessary if the tuples are reused and not all fields were modified. 		 */ 		public void reset() { 			f0 = null; 			f1 = null; 			f2 = nullValue; 			f3 = 0L; 		} 	} </td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11106</td>
    <td align="left">https://github.com/apache/flink/blob/8068c8775ad067d75828e6360e7e0994348da9b9/flink-libraries/flink-gelly/src/main/java/org/apache/flink/graph/library/Summarization.java/#L214-L268</td>
    <td align="right">1</td>
    <td align="right">1489</td>
    <td align="right">11106</td>
  </tr>
  <tr valign="top">
    <td align="right">1866</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;output&quot;: &quot;YES I found bad smells&quot;,         &quot;the bad smells are&quot;: [             &quot;Data Class&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class FileSinkOptionsMetadata implements ProfileNamesProvider {  	private static final String USE_SPEL_PROFILE = &quot;use-expression&quot;;  	private static final String USE_LITERAL_STRING_PROFILE = &quot;use-string&quot;;  	private boolean binary = false;  	private String charset = &quot;UTF-8&quot;;  	private String dir = &quot;/tmp/xd/output/&quot;;  	private String name = XD_STREAM_NAME;  	private String suffix = &quot;out&quot;;  	private Mode mode = APPEND;  	private String nameExpression;  	private String dirExpression;  	@NotNull 	public Mode getMode() { 		return mode; 	}  	@ModuleOption(&quot;what to do if the file already exists&quot;) 	public void setMode(Mode mode) { 		this.mode = mode; 	}  	/** 	 * Return dot + suffix if suffix is set, or the empty string otherwise. 	 */ 	public String getExtensionWithDot() { 		return StringUtils.hasText(suffix) ? &quot;.&quot; + suffix.trim() : &quot;&quot;; 	}   	@ModuleOption(&quot;filename extension to use&quot;) 	public void setSuffix(String suffix) { 		this.suffix = suffix; 	}  	public String getName() { 		return name; 	}  	@ModuleOption(&quot;filename pattern to use&quot;) 	public void setName(String name) { 		this.name = name; 	}  	@NotBlank 	public String getDir() { 		return dir; 	}  	@ModuleOption(&quot;the directory in which files will be created&quot;) 	public void setDir(String dir) { 		this.dir = dir; 	}  	public boolean isBinary() { 		return binary; 	}  	@ModuleOption(&quot;if false, will append a newline character at the end of each line&quot;) 	public void setBinary(boolean binary) { 		this.binary = binary; 	}  	@ModuleOption(&quot;the charset to use when writing a String payload&quot;) 	public void setCharset(String charset) { 		this.charset = charset; 	}  	@NotBlank 	public String getCharset() { 		return charset; 	}   	public String getNameExpression() { 		return nameExpression; 	}  	@ModuleOption(&quot;spring expression used to define filename&quot;) 	public void setNameExpression(String nameExpression) { 		this.nameExpression = nameExpression; 	}  	public String getDirExpression() { 		return dirExpression; 	}  	@ModuleOption(&quot;spring expression used to define directory name&quot;) 	public void setDirExpression(String dirExpression) { 		this.dirExpression = dirExpression; 	}  	public static enum Mode { 		APPEND, REPLACE, FAIL, IGNORE; 	}  	@Override 	public String[] profilesToActivate() { 		return (nameExpression != null || dirExpression != null) ? new String[] { USE_SPEL_PROFILE } 				: new String[] { USE_LITERAL_STRING_PROFILE }; 	} }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12238</td>
    <td align="left">https://github.com/spring-projects/spring-xd/blob/ec106725c51d245109b2e5055d9f65e43228ecc1/spring-xd-dirt/src/main/java/org/springframework/xd/dirt/modules/metadata/FileSinkOptionsMetadata.java/#L37-L148</td>
    <td align="right">1</td>
    <td align="right">1866</td>
    <td align="right">12238</td>
  </tr>
  <tr valign="top">
    <td align="right">355</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  protected static final class PersistenceWithIntOffset extends PersistenceWithIntOffsetNoLL {     /**      * Used by DiskRegion for compaction      *      * @since GemFire prPersistSprint1      */     private DiskEntry prev;     /**      * Used by DiskRegion for compaction      *      * @since GemFire prPersistSprint1      */     private DiskEntry next;      @Override     public DiskEntry getPrev() {       return this.prev;     }      @Override     public DiskEntry getNext() {       return this.next;     }      @Override     public void setPrev(DiskEntry v) {       this.prev = v;     }      @Override     public void setNext(DiskEntry v) {       this.next = v;     }   }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3668</td>
    <td align="left">https://github.com/apache/geode/blob/8fd839e8b73e40bd2dfd14f331b587431bd35a66/geode-core/src/main/java/org/apache/geode/internal/cache/DiskId.java/#L531-L564</td>
    <td align="right">1</td>
    <td align="right">355</td>
    <td align="right">3668</td>
  </tr>
  <tr valign="top">
    <td align="right">2196</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ChartReportItemHelper { 	private static ChartReportItemHelper instance = new ChartReportItemHelper( );  	protected ChartReportItemHelper( ) 	{  	}  	public static void initInstance( ChartReportItemHelper newInstance ) 	{ 		instance = newInstance; 	}  	public static ChartReportItemHelper instance( ) 	{ 		return instance; 	} 	 	public CubeHandle getBindingCubeHandle( ReportItemHandle itemHandle ) 	{ 		return ChartCubeUtil.getBindingCube( itemHandle ); 	} 	 	public DataSetHandle getBindingDataSetHandle(ReportItemHandle itemHandle ) 	{ 		return ChartCubeUtil.getBindingDataSet( itemHandle ); 	} 	 	public boolean checkCubeBindings( ExtendedItemHandle handle, Iterator columnBindings ) 	{ 		return ChartCubeUtil.checkColumnbindingForCube( columnBindings ); 	} 	 	public ChartExpressionUtil.ExpressionCodec createExpressionCodec( 			ExtendedItemHandle handle ) 	{ 		return ChartModelHelper.instance( ).createExpressionCodec( ); 	} 	 	public boolean loadExpression( ExpressionCodec exprCodec, 			ComputedColumnHandle cch ) 	{ 		return ChartItemUtil.loadExpression( exprCodec, cch ); 	} 	 	public ComputedColumnHandle findDimensionBinding( 			ExpressionCodec exprCodec, String dimName, String levelName, 			Collection bindings, ReportItemHandle itemHandle ) 	{ 		for ( ComputedColumnHandle cch : bindings ) 		{ 			ChartReportItemHelper.instance( ).loadExpression( exprCodec, cch ); 			String[] levelNames = exprCodec.getLevelNames( ); 			if ( levelNames != null 					&amp;&amp; levelNames[0].equals( dimName ) 					&amp;&amp; levelNames[1].equals( levelName ) ) 			{ 				return cch; 			} 		} 		return null; 	} 	 	/** 	 * Returns all bindings used by chart. 	 *  	 * @param cm 	 * @param handle 	 * @param validExtensionNames 	 * @return all bindings used by chart. 	 */ 	public Iterator getAllUsedBindings( Chart cm, ReportItemHandle handle, List validExtensionNames ) 	{ 		return handle.columnBindingsIterator( ); 	} 	 	/** 	 * Returns all bindings used by chart. 	 *  	 * @param cm 	 * @param handle 	 * @return all bindings used by chart. 	 */ 	public Iterator getAllUsedBindings( Chart cm, ReportItemHandle handle ) 	{ 		return handle.columnBindingsIterator( ); 	}  	public String getMeasureExprIndicator( CubeHandle cubeHandle ) 	{ 		return ExpressionUtil.MEASURE_INDICATOR; 	} 	 	public List getLevelBindingNamesOfCrosstab( 			CrosstabViewHandle viewHandle, ReportItemHandle chartHandle ) 	{ 		ArrayList names = new ArrayList( ); 		for ( int i = 0; i &lt; viewHandle.getDimensionCount( ); i++ ) 		{ 			DimensionViewHandle dimensionHandle = viewHandle.getDimension( i ); 			dimensionHandle.availableBindings( ); 			for ( int k = 0; k &lt; dimensionHandle.getLevelCount( ); k++ ) 			{ 				names.add( dimensionHandle.getLevel( k ) 						.getCubeLevel( ) 						.getName( ) ); 			} 		}  		return names; 	} }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13481</td>
    <td align="left">https://github.com/eclipse/birt/blob/f89264810347de98702db45386a822aabc0fadbf/chart/org.eclipse.birt.chart.reportitem/src/org/eclipse/birt/chart/reportitem/api/ChartReportItemHelper.java/#L36-L148</td>
    <td align="right">1</td>
    <td align="right">2196</td>
    <td align="right">13481</td>
  </tr>
  <tr valign="top">
    <td align="right">1699</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
final class PolyglotExceptionImpl extends AbstractExceptionImpl implements com.oracle.truffle.polyglot.PolyglotImpl.VMObject {      private static final String CAUSE_CAPTION = &quot;Caused by host exception: &quot;;      private static final boolean TRACE_STACK_TRACE_WALKING = false;      private PolyglotException api;      final PolyglotContextImpl context;     private final PolyglotEngineImpl engine;     final Throwable exception;     private final List guestFrames;      private StackTraceElement[] javaStackTrace;     private List materializedFrames;      private final SourceSection sourceLocation;     private final boolean internal;     private final boolean cancelled;     private final boolean exit;     private final boolean incompleteSource;     private final boolean syntaxError;     private final int exitStatus;     private final Value guestObject;     private final String message;     private Object fileSystemContext;      // Exception coming from a language     PolyglotExceptionImpl(PolyglotLanguageContext languageContext, Throwable original) {         this(languageContext.getImpl(), languageContext.getEngine(), languageContext, original);     }      // Exception coming from an instrument     PolyglotExceptionImpl(PolyglotEngineImpl engine, Throwable original) {         this(engine.impl, engine, null, original);     }      private PolyglotExceptionImpl(AbstractPolyglotImpl impl, PolyglotEngineImpl engine, PolyglotLanguageContext languageContext, Throwable original) {         super(impl);         Objects.requireNonNull(engine);         this.engine = engine;         this.context = (languageContext != null) ? languageContext.context : null;         this.exception = original;         this.guestFrames = TruffleStackTrace.getStackTrace(original);          if (exception instanceof TruffleException) {             TruffleException truffleException = (TruffleException) exception;             this.internal = truffleException.isInternalError();             this.cancelled = truffleException.isCancelled();             this.syntaxError = truffleException.isSyntaxError();             this.incompleteSource = truffleException.isIncompleteSource();             this.exit = truffleException.isExit();             this.exitStatus = this.exit ? truffleException.getExitStatus() : 0;              com.oracle.truffle.api.source.SourceSection section = truffleException.getSourceLocation();             if (section != null) {                 Objects.requireNonNull(languageContext, &quot;Source location can not be accepted without language context.&quot;);                 com.oracle.truffle.api.source.Source truffleSource = section.getSource();                 String language = truffleSource.getLanguage();                 if (language == null) {                     PolyglotLanguage foundLanguage = languageContext.getEngine().findLanguage(language, truffleSource.getMimeType(), false);                     if (foundLanguage != null) {                         language = foundLanguage.getId();                     }                 }                 Source source = getAPIAccess().newSource(language, truffleSource);                 this.sourceLocation = getAPIAccess().newSourceSection(source, section);             } else {                 this.sourceLocation = null;             }             Object exceptionObject;             if (languageContext != null &amp;&amp; !(exception instanceof HostException) &amp;&amp; (exceptionObject = ((TruffleException) exception).getExceptionObject()) != null) {                 /*                  * Allow proxies in guest language objects. This is for legacy support. Ideally we                  * should get rid of this if it is no longer relied upon.                  */                 Object receiver = exceptionObject;                 if (receiver instanceof Proxy) {                     receiver = languageContext.toGuestValue(receiver);                 }                 this.guestObject = languageContext.asValue(receiver);             } else {                 this.guestObject = null;             }         } else {             this.cancelled = false;             this.internal = true;             this.syntaxError = false;             this.incompleteSource = false;             this.exit = false;             this.exitStatus = 0;             this.sourceLocation = null;             this.guestObject = null;         }         if (isHostException()) {             this.message = asHostException().getMessage();         } else {             if (internal) {                 this.message = exception.toString();             } else {                 this.message = exception.getMessage();             }         }          // late materialization of host frames. only needed if polyglot exceptions cross the         // host boundary.         VMAccessor.LANGUAGE.materializeHostFrames(original);     }      @Override     public boolean equals(Object obj) {         if (obj instanceof PolyglotExceptionImpl) {             return exception == ((PolyglotExceptionImpl) obj).exception;         }         return false;     }      @Override     public int hashCode() {         return exception.hashCode();     }      @Override     public org.graalvm.polyglot.SourceSection getSourceLocation() {         return sourceLocation;     }      @Override     public void onCreate(PolyglotException instance) {         this.api = instance;     }      @Override     public boolean isHostException() {         return exception instanceof HostException;     }      @Override     public Throwable asHostException() {         if (!(exception instanceof HostException)) {             throw new PolyglotUnsupportedException(                             String.format(&quot;Unsupported operation %s.%s. You can ensure that the operation is supported using %s.%s.&quot;,                                             PolyglotException.class.getSimpleName(), &quot;asHostException()&quot;,                                             PolyglotException.class.getSimpleName(), &quot;isHostException()&quot;));         }         return ((HostException) exception).getOriginal();     }      @Override     public void printStackTrace(PrintWriter s) {         printStackTrace(new WrappedPrintWriter(s));     }      @Override     public void printStackTrace(PrintStream s) {         printStackTrace(new WrappedPrintStream(s));     }      private void printStackTrace(PrintStreamOrWriter s) {         // Guard against malicious overrides of Throwable.equals by         // using a Set with identity equality semantics.         synchronized (s.lock()) {             // Print our stack trace             if (isInternalError() || getMessage() == null || getMessage().isEmpty()) {                 s.println(api);             } else {                 s.println(getMessage());             }              materialize();             int languageIdLength = 0; // java             for (StackFrame traceElement : getPolyglotStackTrace()) {                 if (!traceElement.isHostFrame()) {                     languageIdLength = Math.max(languageIdLength, getAPIAccess().getImpl(traceElement).getLanguage().getId().length());                 }             }              for (StackFrame traceElement : getPolyglotStackTrace()) {                 s.println(&quot;\tat &quot; + getAPIAccess().getImpl(traceElement).toStringImpl(languageIdLength));             }              // Print cause, if any             if (isHostException()) {                 s.println(CAUSE_CAPTION + asHostException());             }             if (isInternalError()) {                 s.println(&quot;Original Internal Error: &quot;);                 s.printStackTrace(exception);             }         }     }      @Override     public String getMessage() {         return message;     }      public StackTraceElement[] getJavaStackTrace() {         if (javaStackTrace == null) {             materialize();             javaStackTrace = new StackTraceElement[materializedFrames.size()];             for (int i = 0; i &lt; javaStackTrace.length; i++) {                 javaStackTrace[i] = materializedFrames.get(i).toHostFrame();             }         }         return javaStackTrace;     }      private void materialize() {         if (this.materializedFrames == null) {             List frames = new ArrayList&lt;&gt;();             for (StackFrame frame : getPolyglotStackTrace()) {                 frames.add(frame);             }             this.materializedFrames = Collections.unmodifiableList(frames);         }     }      @Override     public StackTraceElement[] getStackTrace() {         return getJavaStackTrace().clone();     }      @Override     public PolyglotEngineImpl getEngine() {         return engine;     }      @Override     public boolean isInternalError() {         return internal;     }      @Override     public Iterable getPolyglotStackTrace() {         if (materializedFrames != null) {             return materializedFrames;         } else {             return new Iterable() {                 public Iterator iterator() {                     return new StackFrameIterator(PolyglotExceptionImpl.this);                 }             };         }     }      @Override     public boolean isCancelled() {         return cancelled;     }      @Override     public boolean isExit() {         return exit;     }      @Override     public boolean isIncompleteSource() {         return incompleteSource;     }      @Override     public int getExitStatus() {         return exitStatus;     }      @Override     public boolean isSyntaxError() {         return syntaxError;     }      @Override     public Value getGuestObject() {         return guestObject;     }      Object getFileSystemContext() {         if (fileSystemContext != null) {             return fileSystemContext;         }         if (context == null) {             return null;         }         return VMAccessor.LANGUAGE.createFileSystemContext(context.config.fileSystem, context.engine.getFileTypeDetectorsSupplier());     }      /**      * Wrapper class for PrintStream and PrintWriter to enable a single implementation of      * printStackTrace.      */     private abstract static class PrintStreamOrWriter {         /** Returns the object to be locked when using this StreamOrWriter. */         abstract Object lock();          /** Prints the specified string as a line on this StreamOrWriter. */         abstract void println(Object o);          abstract void printStackTrace(Throwable t);     }      private static class WrappedPrintStream extends PrintStreamOrWriter {         private final PrintStream printStream;          WrappedPrintStream(PrintStream printStream) {             this.printStream = printStream;         }          @Override         Object lock() {             return printStream;         }          @Override         void println(Object o) {             printStream.println(o);         }          @Override         void printStackTrace(Throwable t) {             t.printStackTrace(printStream);         }     }      private static class WrappedPrintWriter extends PrintStreamOrWriter {         private final PrintWriter printWriter;          WrappedPrintWriter(PrintWriter printWriter) {             this.printWriter = printWriter;         }          @Override         Object lock() {             return printWriter;         }          @Override         void println(Object o) {             printWriter.println(o);         }          @Override         void printStackTrace(Throwable t) {             t.printStackTrace(printWriter);         }     }      private static class StackFrameIterator implements Iterator {          private static final String POLYGLOT_PACKAGE = Engine.class.getName().substring(0, Engine.class.getName().lastIndexOf('.') + 1);         private static final String HOST_INTEROP_PACKAGE = &quot;com.oracle.truffle.polyglot.&quot;;         private static final String[] JAVA_INTEROP_HOST_TO_GUEST = {                         HOST_INTEROP_PACKAGE + &quot;PolyglotMap&quot;,                         HOST_INTEROP_PACKAGE + &quot;PolyglotList&quot;,                         HOST_INTEROP_PACKAGE + &quot;PolyglotFunction&quot;,                         HOST_INTEROP_PACKAGE + &quot;FunctionProxyHandler&quot;,                         HOST_INTEROP_PACKAGE + &quot;ObjectProxyHandler&quot;         };          final PolyglotExceptionImpl impl;         final Iterator guestFrames;         final StackTraceElement[] hostStack;         final ListIterator hostFrames;         /*          * Initial host frames are skipped if the error is a regular non-internal guest language          * error.          */         final APIAccess apiAccess;          boolean inHostLanguage;         boolean firstGuestFrame = true;         PolyglotExceptionFrame fetchedNext;          StackFrameIterator(PolyglotExceptionImpl impl) {             this.impl = impl;             this.apiAccess = impl.getAPIAccess();              Throwable cause = impl.exception;             while (cause.getCause() != null &amp;&amp; cause.getStackTrace().length == 0) {                 if (cause instanceof HostException) {                     cause = ((HostException) cause).getOriginal();                 } else {                     cause = cause.getCause();                 }             }             if (VMAccessor.LANGUAGE.isTruffleStackTrace(cause)) {                 this.hostStack = VMAccessor.LANGUAGE.getInternalStackTraceElements(cause);             } else if (cause.getStackTrace() == null || cause.getStackTrace().length == 0) {                 this.hostStack = impl.exception.getStackTrace();             } else {                 this.hostStack = cause.getStackTrace();             }             this.guestFrames = impl.guestFrames == null ? Collections. emptyList().iterator() : impl.guestFrames.iterator();             this.hostFrames = Arrays.asList(hostStack).listIterator();             // we always start in some host stack frame             this.inHostLanguage = impl.isHostException() || impl.isInternalError();              if (TRACE_STACK_TRACE_WALKING) {                 // To mark the beginning of the stack trace and separate from the previous one                 PrintStream out = System.out;                 out.println();             }         }          public boolean hasNext() {             return fetchNext() != null;         }          public StackFrame next() {             PolyglotExceptionFrame next = fetchNext();             if (next == null) {                 throw new NoSuchElementException();             }             fetchedNext = null;             return apiAccess.newPolyglotStackTraceElement(impl.api, next);         }          PolyglotExceptionFrame fetchNext() {             if (fetchedNext != null) {                 return fetchedNext;             }              while (hostFrames.hasNext()) {                 StackTraceElement element = hostFrames.next();                 traceStackTraceElement(element);                 // we need to flip inHostLanguage state in opposite order as the stack is top to                 // bottom.                 if (inHostLanguage) {                     int guestToHost = isGuestToHost(element, hostStack, hostFrames.nextIndex());                     if (guestToHost &gt;= 0) {                         assert !isHostToGuest(element);                         inHostLanguage = false;                          for (int i = 0; i &lt; guestToHost; i++) {                             assert isGuestToHostReflectiveCall(element);                             element = hostFrames.next();                             traceStackTraceElement(element);                         }                          assert isGuestToHostCallFromHostInterop(element);                     }                 } else {                     if (isHostToGuest(element)) {                         inHostLanguage = true;                          // skip extra host-to-guest frames                         while (hostFrames.hasNext()) {                             StackTraceElement next = hostFrames.next();                             traceStackTraceElement(next);                             if (isHostToGuest(next)) {                                 element = next;                             } else {                                 hostFrames.previous();                                 break;                             }                         }                     }                 }                  if (isGuestCall(element)) {                     inHostLanguage = false;                     // construct guest frame                     TruffleStackTraceElement guestFrame = null;                     if (guestFrames.hasNext()) {                         guestFrame = guestFrames.next();                     }                     PolyglotExceptionFrame frame = PolyglotExceptionFrame.createGuest(impl, guestFrame, firstGuestFrame);                     firstGuestFrame = false;                     if (frame != null) {                         fetchedNext = frame;                         return fetchedNext;                     }                 } else if (inHostLanguage) {                     // construct host frame                     fetchedNext = (PolyglotExceptionFrame.createHost(impl, element));                     return fetchedNext;                 } else {                     // skip stack frame that is part of guest language stack                 }             }              // consume guest frames             if (guestFrames.hasNext()) {                 TruffleStackTraceElement guestFrame = guestFrames.next();                 PolyglotExceptionFrame frame = PolyglotExceptionFrame.createGuest(impl, guestFrame, firstGuestFrame);                 firstGuestFrame = false;                 if (frame != null) {                     fetchedNext = frame;                     return fetchedNext;                 }             }              return null;         }          static boolean isLazyStackTraceElement(StackTraceElement element) {             return element == null;         }          static boolean isGuestCall(StackTraceElement element) {             return isLazyStackTraceElement(element) || VMAccessor.SPI.isGuestCallStackElement(element);         }          static boolean isHostToGuest(StackTraceElement element) {             if (isLazyStackTraceElement(element)) {                 return false;             }             if (element.getClassName().startsWith(POLYGLOT_PACKAGE) &amp;&amp; element.getClassName().indexOf('.', POLYGLOT_PACKAGE.length()) &lt; 0) {                 return true;             } else if (element.getClassName().startsWith(HOST_INTEROP_PACKAGE)) {                 for (String hostToGuestClassName : JAVA_INTEROP_HOST_TO_GUEST) {                     if (element.getClassName().equals(hostToGuestClassName)) {                         return true;                     }                 }             }             return false;         }          // Return the number of frames with reflective calls to skip         static int isGuestToHost(StackTraceElement firstElement, StackTraceElement[] hostStack, int nextElementIndex) {             if (isLazyStackTraceElement(firstElement)) {                 return -1;             }              StackTraceElement element = firstElement;             int index = nextElementIndex;             while (isGuestToHostReflectiveCall(element) &amp;&amp; nextElementIndex &lt; hostStack.length) {                 element = hostStack[index++];             }             if (isGuestToHostCallFromHostInterop(element)) {                 return index - nextElementIndex;             } else {                 return -1;             }         }          private static boolean isGuestToHostCallFromHostInterop(StackTraceElement element) {             switch (element.getClassName()) {                 case &quot;com.oracle.truffle.polyglot.HostMethodDesc$SingleMethod$MHBase&quot;:                     return element.getMethodName().equals(&quot;invokeHandle&quot;);                 case &quot;com.oracle.truffle.polyglot.HostMethodDesc$SingleMethod$MethodReflectImpl&quot;:                     return element.getMethodName().equals(&quot;reflectInvoke&quot;);                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$ExecuteNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$InstantiateNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$AsPointerNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$ArrayGetNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$ArraySetNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$ArrayRemoveNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$ArraySizeNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$GetMemberKeysNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$PutMemberNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$RemoveMemberNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$HasMemberNode&quot;:                     return element.getMethodName().equals(&quot;executeImpl&quot;);                 default:                     return false;             }         }          private static boolean isGuestToHostReflectiveCall(StackTraceElement element) {             switch (element.getClassName()) {                 case &quot;sun.reflect.NativeMethodAccessorImpl&quot;:                 case &quot;sun.reflect.DelegatingMethodAccessorImpl&quot;:                 case &quot;jdk.internal.reflect.NativeMethodAccessorImpl&quot;:                 case &quot;jdk.internal.reflect.DelegatingMethodAccessorImpl&quot;:                 case &quot;java.lang.reflect.Method&quot;:                     return element.getMethodName().startsWith(&quot;invoke&quot;);                 default:                     return false;             }         }          private void traceStackTraceElement(StackTraceElement element) {             if (TRACE_STACK_TRACE_WALKING) {                 PrintStream out = System.out;                 out.printf(&quot;host: %5s, guestToHost: %2s, hostToGuest: %5s, guestCall: %5s, -- %s %n&quot;, inHostLanguage,                                 isGuestToHost(element, hostStack, hostFrames.nextIndex()), isHostToGuest(element),                                 isGuestCall(element), element);             }         }     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11734</td>
    <td align="left">https://github.com/oracle/graal/blob/4deb681aaaa79c248115037fc8e399c9876619fd/truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotExceptionImpl.java/#L69-L651</td>
    <td align="right">1</td>
    <td align="right">1699</td>
    <td align="right">11734</td>
  </tr>
  <tr valign="top">
    <td align="right">137</td>
    <td align="left">&nbsp;{   &quot;message&quot;: &quot;YES, I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;1. Blob&quot;,     &quot;2. Data Class&quot;,     &quot;3. Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LoopedModelImpl extends MinimalEObjectImpl.Container implements LoopedModel {   /**    * The cached value of the '{@link #getVisibility() Visibility}' attribute list.    *     *     * @see #getVisibility()    * @generated    * @ordered    */   protected EList visibility;    /**    * The cached value of the '{@link #getStatic() Static}' attribute list.    *     *     * @see #getStatic()    * @generated    * @ordered    */   protected EList static_;    /**    * The cached value of the '{@link #getSynchronized() Synchronized}' attribute list.    *     *     * @see #getSynchronized()    * @generated    * @ordered    */   protected EList synchronized_;    /**    * The cached value of the '{@link #getAbstract() Abstract}' attribute list.    *     *     * @see #getAbstract()    * @generated    * @ordered    */   protected EList abstract_;    /**    * The cached value of the '{@link #getFinal() Final}' attribute list.    *     *     * @see #getFinal()    * @generated    * @ordered    */   protected EList final_;    /**    * The default value of the '{@link #getName() Name}' attribute.    *     *     * @see #getName()    * @generated    * @ordered    */   protected static final String NAME_EDEFAULT = null;    /**    * The cached value of the '{@link #getName() Name}' attribute.    *     *     * @see #getName()    * @generated    * @ordered    */   protected String name = NAME_EDEFAULT;    /**    *     *     * @generated    */   protected LoopedModelImpl()   {     super();   }    /**    *     *     * @generated    */   @Override   protected EClass eStaticClass()   {     return UnorderedGroupsTestPackage.Literals.LOOPED_MODEL;   }    /**    *     *     * @generated    */   public EList getVisibility()   {     if (visibility == null)     {       visibility = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY);     }     return visibility;   }    /**    *     *     * @generated    */   public EList getStatic()   {     if (static_ == null)     {       static_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC);     }     return static_;   }    /**    *     *     * @generated    */   public EList getSynchronized()   {     if (synchronized_ == null)     {       synchronized_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED);     }     return synchronized_;   }    /**    *     *     * @generated    */   public EList getAbstract()   {     if (abstract_ == null)     {       abstract_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT);     }     return abstract_;   }    /**    *     *     * @generated    */   public EList getFinal()   {     if (final_ == null)     {       final_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL);     }     return final_;   }    /**    *     *     * @generated    */   public String getName()   {     return name;   }    /**    *     *     * @generated    */   public void setName(String newName)   {     String oldName = name;     name = newName;     if (eNotificationRequired())       eNotify(new ENotificationImpl(this, Notification.SET, UnorderedGroupsTestPackage.LOOPED_MODEL__NAME, oldName, name));   }    /**    *     *     * @generated    */   @Override   public Object eGet(int featureID, boolean resolve, boolean coreType)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         return getVisibility();       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         return getStatic();       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         return getSynchronized();       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         return getAbstract();       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         return getFinal();       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         return getName();     }     return super.eGet(featureID, resolve, coreType);   }    /**    *     *     * @generated    */   @SuppressWarnings(&quot;unchecked&quot;)   @Override   public void eSet(int featureID, Object newValue)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         getVisibility().clear();         getVisibility().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         getStatic().clear();         getStatic().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         getSynchronized().clear();         getSynchronized().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         getAbstract().clear();         getAbstract().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         getFinal().clear();         getFinal().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         setName((String)newValue);         return;     }     super.eSet(featureID, newValue);   }    /**    *     *     * @generated    */   @Override   public void eUnset(int featureID)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         getVisibility().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         getStatic().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         getSynchronized().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         getAbstract().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         getFinal().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         setName(NAME_EDEFAULT);         return;     }     super.eUnset(featureID);   }    /**    *     *     * @generated    */   @Override   public boolean eIsSet(int featureID)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         return visibility != null &amp;&amp; !visibility.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         return static_ != null &amp;&amp; !static_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         return synchronized_ != null &amp;&amp; !synchronized_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         return abstract_ != null &amp;&amp; !abstract_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         return final_ != null &amp;&amp; !final_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         return NAME_EDEFAULT == null ? name != null : !NAME_EDEFAULT.equals(name);     }     return super.eIsSet(featureID);   }    /**    *     *     * @generated    */   @Override   public String toString()   {     if (eIsProxy()) return super.toString();      StringBuffer result = new StringBuffer(super.toString());     result.append(&quot; (visibility: &quot;);     result.append(visibility);     result.append(&quot;, static: &quot;);     result.append(static_);     result.append(&quot;, synchronized: &quot;);     result.append(synchronized_);     result.append(&quot;, abstract: &quot;);     result.append(abstract_);     result.append(&quot;, final: &quot;);     result.append(final_);     result.append(&quot;, name: &quot;);     result.append(name);     result.append(')');     return result.toString();   }  } //LoopedModelImpl</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. data class, 3. long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. blob,  3. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1730</td>
    <td align="left">https://github.com/eclipse/xtext-eclipse/blob/0c7546b6aaf3644a77fc68eef9f3da368cbbeabd/org.eclipse.xtext.ui.tests/src-gen/org/eclipse/xtext/ui/tests/editor/contentassist/unorderedGroupsTest/impl/LoopedModelImpl.java/#L40-L375</td>
    <td align="right">1</td>
    <td align="right">137</td>
    <td align="right">1730</td>
  </tr>
  <tr valign="top">
    <td align="right">249</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     } </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class CreditBureauData {  	private final long creditBureauId;  	private final String creditBureauName;  	private final String country;  	private final String productName;  	private final String creditBureauSummary;  	private final long implementationKey;  	private CreditBureauData(final long creditBureauId, final String creditBureauName, final String country, 			final String productName, final String creditBureauSummary, final long implementationKey) { 		this.creditBureauId = creditBureauId; 		this.creditBureauName = creditBureauName; 		this.country = country; 		this.productName = productName; 		this.creditBureauSummary = creditBureauSummary; 		this.implementationKey = implementationKey;  	}  	public static CreditBureauData instance(final long creditBureauId, final String creditBureauName, 			final String country, final String productName, final String creditBureauSummary, final long implementationKey) {  		return new CreditBureauData(creditBureauId, creditBureauName, country, productName, creditBureauSummary, 				implementationKey); 	}  	public String getCreditBureauSummary() { 		return this.creditBureauSummary; 	}  	public long getCreditBureauId() { 		return this.creditBureauId; 	}  	public String getCreditBureauName() { 		return this.creditBureauName; 	}  	public String getCountry() { 		return this.country; 	}  	public String getProductName() { 		return this.productName; 	}  	public long getImplementationKey() { 		return this.implementationKey; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2663</td>
    <td align="left">https://github.com/apache/fineract/blob/210e380df3ca5c74c8c2fa09e7fe1cffdb87e20a/fineract-provider/src/main/java/org/apache/fineract/infrastructure/creditbureau/data/CreditBureauData.java/#L21-L77</td>
    <td align="right">1</td>
    <td align="right">249</td>
    <td align="right">2663</td>
  </tr>
  <tr valign="top">
    <td align="right">2585</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@UriParams public class Mina2Configuration implements Cloneable {      @UriPath @Metadata(required = true)     private String protocol;     @UriPath @Metadata(required = true)     private String host;     @UriPath @Metadata(required = true)     private int port;     @UriParam(defaultValue = &quot;true&quot;)     private boolean sync = true;     @UriParam(label = &quot;codec&quot;)     private boolean textline;     @UriParam(label = &quot;codec&quot;)     private Mina2TextLineDelimiter textlineDelimiter;     @UriParam(label = &quot;codec&quot;)     private ProtocolCodecFactory codec;     @UriParam(label = &quot;codec&quot;)     private String encoding;     @UriParam(defaultValue = &quot;10000&quot;)     private long writeTimeout = 10000;     @UriParam(defaultValue = &quot;30000&quot;)     private long timeout = 30000;     @UriParam(label = &quot;producer,advanced&quot;, defaultValue = &quot;true&quot;)     private boolean lazySessionCreation = true;     @UriParam(label = &quot;advanced&quot;)     private boolean transferExchange;     @UriParam     private boolean minaLogger;     @UriParam(label = &quot;codec&quot;, defaultValue = &quot;-1&quot;)     private int encoderMaxLineLength = -1;     @UriParam(label = &quot;codec&quot;, defaultValue = &quot;1024&quot;)     private int decoderMaxLineLength = 1024;     @UriParam(label = &quot;codec&quot;)     private List filters;     @UriParam(label = &quot;codec&quot;, defaultValue = &quot;true&quot;)     private boolean allowDefaultCodec = true;     @UriParam     private boolean disconnect;     @UriParam(label = &quot;consumer,advanced&quot;, defaultValue = &quot;true&quot;)     private boolean disconnectOnNoReply = true;     @UriParam(label = &quot;consumer,advanced&quot;, defaultValue = &quot;WARN&quot;)     private LoggingLevel noReplyLogLevel = LoggingLevel.WARN;     @UriParam(label = &quot;security&quot;)     private SSLContextParameters sslContextParameters;     @UriParam(label = &quot;security&quot;, defaultValue = &quot;true&quot;)     private boolean autoStartTls = true;     @UriParam(label = &quot;advanced&quot;, defaultValue = &quot;16&quot;)     private int maximumPoolSize = 16; // 16 is the default mina setting     @UriParam(label = &quot;advanced&quot;, defaultValue = &quot;true&quot;)     private boolean orderedThreadPoolExecutor = true;     @UriParam(label = &quot;producer,advanced&quot;, defaultValue = &quot;true&quot;)     private boolean cachedAddress = true;     @UriParam(label = &quot;consumer&quot;)     private boolean clientMode;      /**      * Returns a copy of this configuration      */     public Mina2Configuration copy() {         try {             return (Mina2Configuration) clone();         } catch (CloneNotSupportedException e) {             throw new RuntimeCamelException(e);         }     }      public String getCharsetName() {         if (encoding == null) {             return null;         }         if (!Charset.isSupported(encoding)) {             throw new IllegalArgumentException(&quot;The encoding: &quot; + encoding + &quot; is not supported&quot;);         }          return Charset.forName(encoding).name();     }      public String getProtocol() {         return protocol;     }      /**      * Protocol to use      */     public void setProtocol(String protocol) {         this.protocol = protocol;     }      public String getHost() {         return host;     }      /**      * Hostname to use. Use localhost or 0.0.0.0 for local server as consumer. For producer use the hostname or ip address of the remote server.      */     public void setHost(String host) {         this.host = host;     }      public int getPort() {         return port;     }      /**      * Port number      */     public void setPort(int port) {         this.port = port;     }      public boolean isSync() {         return sync;     }      /**      * Setting to set endpoint as one-way or request-response.      */     public void setSync(boolean sync) {         this.sync = sync;     }      public boolean isTextline() {         return textline;     }      /**      * Only used for TCP. If no codec is specified, you can use this flag to indicate a text line based codec;      * if not specified or the value is false, then Object Serialization is assumed over TCP.      */     public void setTextline(boolean textline) {         this.textline = textline;     }      public Mina2TextLineDelimiter getTextlineDelimiter() {         return textlineDelimiter;     }      /**      * Only used for TCP and if textline=true. Sets the text line delimiter to use.      * If none provided, Camel will use DEFAULT.      * This delimiter is used to mark the end of text.      */     public void setTextlineDelimiter(Mina2TextLineDelimiter textlineDelimiter) {         this.textlineDelimiter = textlineDelimiter;     }      public ProtocolCodecFactory getCodec() {         return codec;     }      /**      * To use a custom minda codec implementation.      */     public void setCodec(ProtocolCodecFactory codec) {         this.codec = codec;     }      public String getEncoding() {         return encoding;     }      /**      * You can configure the encoding (a charset name) to use for the TCP textline codec and the UDP protocol.      * If not provided, Camel will use the JVM default Charset      */     public void setEncoding(String encoding) {         this.encoding = encoding;     }      public long getWriteTimeout() {         return writeTimeout;     }      /**      * Maximum amount of time it should take to send data to the MINA session. Default is 10000 milliseconds.      */     public void setWriteTimeout(long writeTimeout) {         this.writeTimeout = writeTimeout;     }      public long getTimeout() {         return timeout;     }      /**      * You can configure the timeout that specifies how long to wait for a response from a remote server.      * The timeout unit is in milliseconds, so 60000 is 60 seconds.      */     public void setTimeout(long timeout) {         this.timeout = timeout;     }      public boolean isLazySessionCreation() {         return lazySessionCreation;     }      /**      * Sessions can be lazily created to avoid exceptions, if the remote server is not up and running when the Camel producer is started.      */     public void setLazySessionCreation(boolean lazySessionCreation) {         this.lazySessionCreation = lazySessionCreation;     }      public boolean isTransferExchange() {         return transferExchange;     }      /**      * Only used for TCP. You can transfer the exchange over the wire instead of just the body.      * The following fields are transferred: In body, Out body, fault body, In headers, Out headers, fault headers, exchange properties, exchange exception.      * This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.      */     public void setTransferExchange(boolean transferExchange) {         this.transferExchange = transferExchange;     }      /**      * To set the textline protocol encoder max line length. By default the default value of Mina itself is used which are Integer.MAX_VALUE.      */     public void setEncoderMaxLineLength(int encoderMaxLineLength) {         this.encoderMaxLineLength = encoderMaxLineLength;     }      public int getEncoderMaxLineLength() {         return encoderMaxLineLength;     }      /**      * To set the textline protocol decoder max line length. By default the default value of Mina itself is used which are 1024.      */     public void setDecoderMaxLineLength(int decoderMaxLineLength) {         this.decoderMaxLineLength = decoderMaxLineLength;     }      public int getDecoderMaxLineLength() {         return decoderMaxLineLength;     }      public boolean isMinaLogger() {         return minaLogger;     }      /**      * You can enable the Apache MINA logging filter. Apache MINA uses slf4j logging at INFO level to log all input and output.      */     public void setMinaLogger(boolean minaLogger) {         this.minaLogger = minaLogger;     }      public List getFilters() {         return filters;     }      /**      * You can set a list of Mina IoFilters to use.      */     public void setFilters(List filters) {         this.filters = filters;     }      public boolean isDatagramProtocol() {         return protocol.equals(&quot;udp&quot;);     }      /**      * The mina component installs a default codec if both, codec is null and textline is false.      * Setting allowDefaultCodec to false prevents the mina component from installing a default codec as the first element in the filter chain.      * This is useful in scenarios where another filter must be the first in the filter chain, like the SSL filter.      */     public void setAllowDefaultCodec(boolean allowDefaultCodec) {         this.allowDefaultCodec = allowDefaultCodec;     }      public boolean isAllowDefaultCodec() {         return allowDefaultCodec;     }      public boolean isDisconnect() {         return disconnect;     }      /**      * Whether or not to disconnect(close) from Mina session right after use. Can be used for both consumer and producer.      */     public void setDisconnect(boolean disconnect) {         this.disconnect = disconnect;     }      public boolean isDisconnectOnNoReply() {         return disconnectOnNoReply;     }      /**      * If sync is enabled then this option dictates MinaConsumer if it should disconnect where there is no reply to send back.      */     public void setDisconnectOnNoReply(boolean disconnectOnNoReply) {         this.disconnectOnNoReply = disconnectOnNoReply;     }      public LoggingLevel getNoReplyLogLevel() {         return noReplyLogLevel;     }      /**      * If sync is enabled this option dictates MinaConsumer which logging level to use when logging a there is no reply to send back.      */     public void setNoReplyLogLevel(LoggingLevel noReplyLogLevel) {         this.noReplyLogLevel = noReplyLogLevel;     }      public SSLContextParameters getSslContextParameters() {         return sslContextParameters;     }      /**      * To configure SSL security.      */     public void setSslContextParameters(SSLContextParameters sslContextParameters) {         this.sslContextParameters = sslContextParameters;     }      public boolean isAutoStartTls() {         return autoStartTls;     }      /**      * Whether to auto start SSL handshake.      */     public void setAutoStartTls(boolean autoStartTls) {         this.autoStartTls = autoStartTls;     }      public int getMaximumPoolSize() {         return maximumPoolSize;     }      /**      * Number of worker threads in the worker pool for TCP and UDP      */     public void setMaximumPoolSize(int maximumPoolSize) {         this.maximumPoolSize = maximumPoolSize;     }      public boolean isOrderedThreadPoolExecutor() {         return orderedThreadPoolExecutor;     }      /**      * Whether to use ordered thread pool, to ensure events are processed orderly on the same channel.      */     public void setOrderedThreadPoolExecutor(boolean orderedThreadPoolExecutor) {         this.orderedThreadPoolExecutor = orderedThreadPoolExecutor;     }      /**      * Whether to create the InetAddress once and reuse. Setting this to false allows to pickup DNS changes in the network.      */     public void setCachedAddress(boolean shouldCacheAddress) {         this.cachedAddress = shouldCacheAddress;     }      public boolean isCachedAddress() {         return cachedAddress;     }      /**      * If the clientMode is true, mina consumer will connect the address as a TCP client.      */     public void setClientMode(boolean clientMode) {         this.clientMode = clientMode;     }          public boolean isClientMode() {         return clientMode;     }      // here we just shows the option setting of host, port, protocol      public String getUriString() {         return &quot;mina2:&quot; + getProtocol() + &quot;:&quot; + getHost() + &quot;:&quot; + getPort();     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14976</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-mina2/src/main/java/org/apache/camel/component/mina2/Mina2Configuration.java/#L35-L416</td>
    <td align="right">1</td>
    <td align="right">2585</td>
    <td align="right">14976</td>
  </tr>
  <tr valign="top">
    <td align="right">759</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells the bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ReportInstance extends AbstractDTOBase {      private String id;     private ReportStatusEnum status;     private String url;     private String ownerId;     private Boolean hasDetailRows;     private ZonedDateTime completionDate;     private ZonedDateTime requestDate;      public String getId() {         return id;     }      public void setId(String id) {         this.id = id;     }      public ReportStatusEnum getStatus() {         return status;     }      public void setStatus(ReportStatusEnum status) {         this.status = status;     }      public String getUrl() {         return url;     }      public void setUrl(String url) {         this.url = url;     }      public String getOwnerId() {         return ownerId;     }      public void setOwnerId(String ownerId) {         this.ownerId = ownerId;     }      public Boolean getHasDetailRows() {         return hasDetailRows;     }      public void setHasDetailRows(Boolean hasDetailRows) {         this.hasDetailRows = hasDetailRows;     }      public ZonedDateTime getCompletionDate() {         return completionDate;     }      public void setCompletionDate(ZonedDateTime completionDate) {         this.completionDate = completionDate;     }      public ZonedDateTime getRequestDate() {         return requestDate;     }      public void setRequestDate(ZonedDateTime requestDate) {         this.requestDate = requestDate;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7066</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/api/dto/analytics/reports/ReportInstance.java/#L26-L91</td>
    <td align="right">1</td>
    <td align="right">759</td>
    <td align="right">7066</td>
  </tr>
  <tr valign="top">
    <td align="right">2069</td>
    <td align="left">YES I found bad smells the bad smells are:  1. Long class 2. Duplicate code (in methods setTargetUri and getTargetUris) 3. Temporary fields (in methods getTargetUri and getTargetUris) 4. Data class (all getter and setter methods with no logic or manipulation of data) 5. Misplaced field (field flowRefreshed could potentially be better placed in RemoteProcessGroupContentsDTO class) 6. Long parameter list (constructor with multiple parameters) 7. Feature envy (methods in RemoteProcessGroupContentsDTO class that could potentially be moved to this class)</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
@XmlType(name = &quot;remoteProcessGroup&quot;) public class RemoteProcessGroupDTO extends ComponentDTO {      private String targetUri;     private String targetUris;     private Boolean targetSecure;      private String name;     private String comments;     private String communicationsTimeout;     private String yieldDuration;     private String transportProtocol;     private String localNetworkInterface;     private String proxyHost;     private Integer proxyPort;     private String proxyUser;     private String proxyPassword;      private Collection authorizationIssues;     private Collection validationErrors;     private Boolean transmitting;      private Integer inputPortCount;     private Integer outputPortCount;      private Integer activeRemoteInputPortCount;     private Integer inactiveRemoteInputPortCount;     private Integer activeRemoteOutputPortCount;     private Integer inactiveRemoteOutputPortCount;      private Date flowRefreshed;      private RemoteProcessGroupContentsDTO contents;      public RemoteProcessGroupDTO() {         super();     }      public RemoteProcessGroupDTO(final RemoteProcessGroupDTO toCopy) {         setId(toCopy.getId());         setPosition(toCopy.getPosition());         targetUri = toCopy.getTargetUri();         name = toCopy.getName();     }      public void setTargetUri(final String targetUri) {         this.targetUri = targetUri;     }      /**      * @return target uri of this remote process group.      * If target uri is not set, but uris are set, then returns the first url in the urls.      * If neither target uri nor uris are set, then returns null.      */     @ApiModelProperty(             value = &quot;The target URI of the remote process group.&quot; +                     &quot; If target uri is not set, but uris are set, then returns the first url in the urls.&quot; +                     &quot; If neither target uri nor uris are set, then returns null.&quot;     )     public String getTargetUri() {         if (targetUri == null || targetUri.length() == 0) {             synchronized (this) {                 if (targetUri == null || targetUri.length() == 0) {                     if (targetUris != null &amp;&amp; targetUris.length() &gt; 0) {                         if (targetUris.indexOf(',') &gt; -1) {                             targetUri = targetUris.substring(0, targetUris.indexOf(','));                         } else {                             targetUri = targetUris;                         }                     }                 }             }         }          return this.targetUri;     }      public void setTargetUris(String targetUris) {         this.targetUris = targetUris;     }      /**      * @return target uris of this remote process group      * If targetUris was not set but target uri was set, then returns a collection containing the single uri.      * If neither target uris nor uri were set, then returns null.      */     @ApiModelProperty(             value = &quot;The target URI of the remote process group.&quot; +                     &quot; If target uris is not set but target uri is set,&quot; +                     &quot; then returns a collection containing the single target uri.&quot; +                     &quot; If neither target uris nor uris are set, then returns null.&quot;     )     public String getTargetUris() {         if (targetUris == null || targetUris.length() == 0) {             synchronized (this) {                 if (targetUris == null || targetUris.length() == 0) {                     targetUris = targetUri;                 }             }         }          return this.targetUris;     }      /**      * @param name of this remote process group      */     @ApiModelProperty(             value = &quot;The name of the remote process group.&quot;     )     public void setName(final String name) {         this.name = name;     }      public String getName() {         return this.name;     }      /**      * @return Comments for this remote process group      */     @ApiModelProperty(             value = &quot;The comments for the remote process group.&quot;     )     public String getComments() {         return comments;     }      public void setComments(String comments) {         this.comments = comments;     }      /**      * @return any remote authorization issues for this remote process group      */     @ApiModelProperty(             value = &quot;Any remote authorization issues for the remote process group.&quot;     )     public Collection getAuthorizationIssues() {         return authorizationIssues;     }      public void setAuthorizationIssues(Collection authorizationIssues) {         this.authorizationIssues = authorizationIssues;     }      /**      * @return whether or not this remote process group is actively transmitting      */     @ApiModelProperty(             value = &quot;Whether the remote process group is actively transmitting.&quot;     )     public Boolean isTransmitting() {         return transmitting;     }      public void setTransmitting(Boolean transmitting) {         this.transmitting = transmitting;     }      /**      * @return whether or not the target is running securely      */     @ApiModelProperty(             value = &quot;Whether the target is running securely.&quot;     )     public Boolean isTargetSecure() {         return targetSecure;     }      public void setTargetSecure(Boolean targetSecure) {         this.targetSecure = targetSecure;     }      /**      * @return the time period used for the timeout when communicating with this RemoteProcessGroup      */     @ApiModelProperty(             value = &quot;The time period used for the timeout when communicating with the target.&quot;     )     public String getCommunicationsTimeout() {         return communicationsTimeout;     }      public void setCommunicationsTimeout(String communicationsTimeout) {         this.communicationsTimeout = communicationsTimeout;     }      /**      * @return when yielding, this amount of time must elapse before this remote process group is scheduled again      */     @ApiModelProperty(             value = &quot;When yielding, this amount of time must elapse before the remote process group is scheduled again.&quot;     )     public String getYieldDuration() {         return yieldDuration;     }      public void setYieldDuration(String yieldDuration) {         this.yieldDuration = yieldDuration;     }      /**      * @return number of active remote input ports      */     @ApiModelProperty(             value = &quot;The number of active remote input ports.&quot;     )     public Integer getActiveRemoteInputPortCount() {         return activeRemoteInputPortCount;     }      public void setActiveRemoteInputPortCount(Integer activeRemoteInputPortCount) {         this.activeRemoteInputPortCount = activeRemoteInputPortCount;     }      /**      * @return number of inactive remote input ports      */     @ApiModelProperty(             value = &quot;The number of inactive remote input ports.&quot;     )     public Integer getInactiveRemoteInputPortCount() {         return inactiveRemoteInputPortCount;     }      public void setInactiveRemoteInputPortCount(Integer inactiveRemoteInputPortCount) {         this.inactiveRemoteInputPortCount = inactiveRemoteInputPortCount;     }      /**      * @return number of active remote output ports      */     @ApiModelProperty(             value = &quot;The number of active remote output ports.&quot;     )     public Integer getActiveRemoteOutputPortCount() {         return activeRemoteOutputPortCount;     }      public void setActiveRemoteOutputPortCount(Integer activeRemoteOutputPortCount) {         this.activeRemoteOutputPortCount = activeRemoteOutputPortCount;     }      /**      * @return number of inactive remote output ports      */     @ApiModelProperty(             value = &quot;The number of inactive remote output ports.&quot;     )     public Integer getInactiveRemoteOutputPortCount() {         return inactiveRemoteOutputPortCount;     }      public void setInactiveRemoteOutputPortCount(Integer inactiveRemoteOutputPortCount) {         this.inactiveRemoteOutputPortCount = inactiveRemoteOutputPortCount;     }      /**      * @return number of Remote Input Ports currently available in the remote NiFi instance      */     @ApiModelProperty(             value = &quot;The number of remote input ports currently available on the target.&quot;     )     public Integer getInputPortCount() {         return inputPortCount;     }      public void setInputPortCount(Integer inputPortCount) {         this.inputPortCount = inputPortCount;     }      /**      * @return number of Remote Output Ports currently available in the remote NiFi instance      */     @ApiModelProperty(             value = &quot;The number of remote output ports currently available on the target.&quot;     )     public Integer getOutputPortCount() {         return outputPortCount;     }      public void setOutputPortCount(Integer outputPortCount) {         this.outputPortCount = outputPortCount;     }      /**      * @return contents of this remote process group. Will contain available input/output ports      */     @ApiModelProperty(             value = &quot;The contents of the remote process group. Will contain available input/output ports.&quot;     )     public RemoteProcessGroupContentsDTO getContents() {         return contents;     }      public void setContents(RemoteProcessGroupContentsDTO contents) {         this.contents = contents;     }      /**      * @return the flow for this remote group was last refreshed      */     @XmlJavaTypeAdapter(DateTimeAdapter.class)     @ApiModelProperty(             value = &quot;The timestamp when this remote process group was last refreshed.&quot;,             dataType = &quot;string&quot;     )     public Date getFlowRefreshed() {         return flowRefreshed;     }      public void setFlowRefreshed(Date flowRefreshed) {         this.flowRefreshed = flowRefreshed;     }      public String getTransportProtocol() {         return transportProtocol;     }      public void setTransportProtocol(String transportProtocol) {         this.transportProtocol = transportProtocol;     }      @ApiModelProperty(&quot;The local network interface to send/receive data. If not specified, any local address is used. If clustered, all nodes must have an interface with this identifier.&quot;)     public String getLocalNetworkInterface() {         return localNetworkInterface;     }      public void setLocalNetworkInterface(String localNetworkInterface) {         this.localNetworkInterface = localNetworkInterface;     }      @ApiModelProperty(             &quot;The validation errors for the remote process group. These validation errors represent the problems with the remote process group that must be resolved before it can transmit.&quot;     )     public Collection getValidationErrors() {         return validationErrors;     }      public void setValidationErrors(Collection validationErrors) {         this.validationErrors = validationErrors;     }      public String getProxyHost() {         return proxyHost;     }      public void setProxyHost(String proxyHost) {         this.proxyHost = proxyHost;     }      public Integer getProxyPort() {         return proxyPort;     }      public void setProxyPort(Integer proxyPort) {         this.proxyPort = proxyPort;     }      public String getProxyUser() {         return proxyUser;     }      public void setProxyUser(String proxyUser) {         this.proxyUser = proxyUser;     }      public String getProxyPassword() {         return proxyPassword;     }      public void setProxyPassword(String proxyPassword) {         this.proxyPassword = proxyPassword;     } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long class2 Duplicate code (in methods setTargetUri and getTargetUris)3 Temporary fields (in methods getTargetUri and getTargetUris)4 Data class (all getter and setter methods with no logic or manipulation of data)5 Misplaced field (field flowRefreshed could potentially be better placed in RemoteProcessGroupContentsDTO class)6 Long parameter list (constructor with multiple parameters)7 Feature envy (methods in RemoteProcessGroupContentsDTO class that could potentially be moved to this class)</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13004</td>
    <td align="left">https://github.com/apache/nifi/blob/c8eff590efa3babcda0b755009224dcac168708b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/RemoteProcessGroupDTO.java/#L30-L405</td>
    <td align="right">2</td>
    <td align="right">2069</td>
    <td align="right">13004</td>
  </tr>
  <tr valign="top">
    <td align="right">238</td>
    <td align="left">&nbsp;{ &quot;output&quot;: &quot;YES I found bad smells the bad smells are: 1. Data Class&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class MetaColumn implements Named {     public final String tableCat;     public final String tableSchem;     public final String tableName;     public final String columnName;     public final int dataType;     public final String typeName;     public final Integer columnSize;     public final Integer bufferLength = null;     public final Integer decimalDigits;     public final Integer numPrecRadix;     public final int nullable;     public final String remarks = null;     public final String columnDef = null;     public final Integer sqlDataType = null;     public final Integer sqlDatetimeSub = null;     public final Integer charOctetLength;     public final int ordinalPosition;     @NotNull     public final String isNullable;     public final String scopeCatalog = null;     public final String scopeSchema = null;     public final String scopeTable = null;     public final Short sourceDataType = null;     @NotNull     public final String isAutoincrement = &quot;&quot;;     @NotNull     public final String isGeneratedcolumn = &quot;&quot;;      public MetaColumn(         String tableCat,         String tableSchem,         String tableName,         String columnName,         int dataType,         String typeName,         Integer columnSize,         Integer decimalDigits,         Integer numPrecRadix,         int nullable,         Integer charOctetLength,         int ordinalPosition,         String isNullable) {       this.tableCat = tableCat;       this.tableSchem = tableSchem;       this.tableName = tableName;       this.columnName = columnName;       this.dataType = dataType;       this.typeName = typeName;       this.columnSize = columnSize;       this.decimalDigits = decimalDigits;       this.numPrecRadix = numPrecRadix;       this.nullable = nullable;       this.charOctetLength = charOctetLength;       this.ordinalPosition = ordinalPosition;       this.isNullable = isNullable;     }      @Override     public String getName() {       return columnName;     }   }</td>
    <td align="left">data class</td>
    <td align="left">1. data class </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2613</td>
    <td align="left">https://github.com/apache/drill/blob/5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3/exec/jdbc/src/main/java/org/apache/drill/jdbc/impl/DrillMetaImpl.java/#L160-L222</td>
    <td align="right">1</td>
    <td align="right">238</td>
    <td align="right">2613</td>
  </tr>
  <tr valign="top">
    <td align="right">1922</td>
    <td align="left">{&quot;response&quot;: &quot;YES, I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class ShareContent         implements ShareModel {     private final Uri contentUrl;     private final List peopleIds;     private final String placeId;     private final String pageId;     private final String ref;     private final ShareHashtag hashtag;      protected ShareContent(final Builder builder) {         super();         this.contentUrl = builder.contentUrl;         this.peopleIds = builder.peopleIds;         this.placeId = builder.placeId;         this.pageId = builder.pageId;         this.ref = builder.ref;         this.hashtag = builder.hashtag;     }      protected ShareContent(final Parcel in) {         this.contentUrl = in.readParcelable(Uri.class.getClassLoader());         this.peopleIds = readUnmodifiableStringList(in);         this.placeId = in.readString();         this.pageId = in.readString();         this.ref = in.readString();         this.hashtag = new ShareHashtag.Builder().readFrom(in).build();     }      /**      * URL for the content being shared.  This URL will be checked for app link meta tags for      * linking in platform specific ways.      *       * See documentation for App Links.      *      * @return {@link android.net.Uri} representation of the content link.      */     @Nullable     public Uri getContentUrl() {         return this.contentUrl;     }      /**      * List of Ids for taggable people to tag with this content.      *       * See documentation for      *       * Taggable Friends.      *      * @return {@link java.util.List} of Ids for people to tag.      */     @Nullable     public List getPeopleIds() {         return this.peopleIds;     }      /**      * The Id for a place to tag with this content.      *      * @return The Id for the place to tag.      */     @Nullable     public String getPlaceId() {         return this.placeId;     }      /**      * For shares into Messenger, this pageID will be used to map the app to page and attach      * attribution to the share.      *      * @return The ID of the Facebook page this share is associated with.      */     @Nullable     public String getPageId() {         return this.pageId;     }      /**      * A value to be added to the referrer URL when a person follows a link from this shared      * content on feed.      *      * @return The ref for the content.      */     @Nullable     public String getRef() {         return this.ref;     }      /**      * Gets the ShareHashtag, if one has been set, for this content.      *      * @return The hashtag      */     @Nullable     public ShareHashtag getShareHashtag() {         return this.hashtag;     }      public int describeContents() {         return 0;     }      public void writeToParcel(final Parcel out, final int flags) {         out.writeParcelable(this.contentUrl, 0);         out.writeStringList(this.peopleIds);         out.writeString(this.placeId);         out.writeString(this.pageId);         out.writeString(this.ref);         out.writeParcelable(this.hashtag, 0);     }      private List readUnmodifiableStringList(final Parcel in) {         final List list = new ArrayList();         in.readStringList(list);         return (list.size() == 0 ? null : Collections.unmodifiableList(list));     }      /**      * Abstract builder for {@link com.facebook.share.model.ShareContent}      */     public abstract static class Builder             implements ShareModelBuilder {         private Uri contentUrl;         private List peopleIds;         private String placeId;         private String pageId;         private String ref;         private ShareHashtag hashtag;          /**          * Set the URL for the content being shared.          *          * @param contentUrl {@link android.net.Uri} representation of the content link.          * @return The builder.          */         public E setContentUrl(@Nullable final Uri contentUrl) {             this.contentUrl = contentUrl;             return (E) this;         }          /**          * Set the list of Ids for taggable people to tag with this content.          *          * @param peopleIds {@link java.util.List} of Ids for people to tag.          * @return The builder.          */         public E setPeopleIds(@Nullable final List peopleIds) {             this.peopleIds = (peopleIds == null ? null : Collections.unmodifiableList(peopleIds));             return (E) this;         }          /**          * Set the Id for a place to tag with this content.          *          * @param placeId The Id for the place to tag.          * @return The builder.          */         public E setPlaceId(@Nullable final String placeId) {             this.placeId = placeId;             return (E) this;         }          /**          * Set the Id of the Facebook page this share is associated with.          *          * @param pageId The Id for the Page          * @return The builder          */         public E setPageId(@Nullable final String pageId) {             this.pageId = pageId;             return (E) this;         }          /**          * Set the value to be added to the referrer URL when a person follows a link from this          * shared content on feed.          *          * @param ref The ref for the content.          * @return The builder.          */         public E setRef(@Nullable final String ref) {             this.ref = ref;             return (E) this;         }          /**          * Set the ShareHashtag for this content          *          * @param shareHashtag The hashtag for this content          * @return The builder          */         public E setShareHashtag(@Nullable final ShareHashtag shareHashtag) {             this.hashtag = shareHashtag;             return (E) this;         }          @Override         public E readFrom(final P content) {             if (content == null) {                 return (E) this;             }             return (E) this                     .setContentUrl(content.getContentUrl())                     .setPeopleIds(content.getPeopleIds())                     .setPlaceId(content.getPlaceId())                     .setPageId(content.getPageId())                     .setRef(content.getRef());         }     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12425</td>
    <td align="left">https://github.com/facebook/facebook-android-sdk/blob/81ca34a2a0f7ee391f90c6051c5a22e5bc8663c2/facebook-common/src/main/java/com/facebook/share/model/ShareContent.java/#L35-L243</td>
    <td align="right">1</td>
    <td align="right">1922</td>
    <td align="right">12425</td>
  </tr>
  <tr valign="top">
    <td align="right">604</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MessageComponent extends UIOutput {       // ------------------------------------------------------------ Constructors       /**      * Create a new {@link MessageComponent} with default properties.      */     public MessageComponent() {          super();         setRendererType(&quot;org.apache.struts.faces.Message&quot;);      }       // ------------------------------------------------------ Instance Variables       /**      * MessageResources attribute key to use for message lookup.      */     private String bundle = null;       /**      * Flag indicating whether output should be filtered.      */     private boolean filter = true;     private boolean filterSet = false;       /**      * Message key to use for message lookup.      */     private String key = null;       /**      * CSS style(s) to be rendered for this component.      */     private String style = null;       /**      * CSS style class(es) to be rendered for this component.      */     private String styleClass = null;       // ---------------------------------------------------- Component Properties       /**      * Return the MessageResources key.      */     public String getBundle() {          ValueBinding vb = getValueBinding(&quot;bundle&quot;);         if (vb != null) {             return (String) vb.getValue(getFacesContext());         } else {             return bundle;         }      }       /**      * Set the MessageResources key.      *      * @param bundle The new key      */     public void setBundle(String bundle) {          this.bundle = bundle;      }       /**      * Return the component family to which this component belongs.      */     public String getFamily() {          return &quot;org.apache.struts.faces.Message&quot;;      }       /**      * Return a flag indicating whether filtering should take place.      */     public boolean isFilter() {          if (filterSet) {             return filter;         }         ValueBinding vb = getValueBinding(&quot;filter&quot;);         if (vb != null) {             Boolean value = (Boolean) vb.getValue(getFacesContext());             if (null == value) {                 return filter;             }             return value.booleanValue();         } else {             return filter;         }      }       /**      * Set the flag indicating that the output value should be filtered.      *      * @param filter The new filter flag      */     public void setFilter(boolean filter) {          this.filter = filter;         this.filterSet = true;      }       /**      * Return the message key.      */     public String getKey() {          ValueBinding vb = getValueBinding(&quot;key&quot;);         if (vb != null) {             return (String) vb.getValue(getFacesContext());         } else {             return key;         }      }       /**      * Set the message key.      *      * @param key The new key      */     public void setKey(String key) {          this.key = key;      }       /**      * Return the CSS style(s) to be rendered for this component.      */     public String getStyle() {          ValueBinding vb = getValueBinding(&quot;style&quot;);         if (vb != null) {             return (String) vb.getValue(getFacesContext());         } else {             return style;         }      }       /**      * Set the CSS style(s) to be rendered for this component.      *      * @param style The new CSS style(s)      */     public void setStyle(String style) {          this.style = style;      }       /**      * Return the CSS style class(es) to be rendered for this component.      */     public String getStyleClass() {          ValueBinding vb = getValueBinding(&quot;styleClass&quot;);         if (vb != null) {             return (String) vb.getValue(getFacesContext());         } else {             return styleClass;         }      }       /**      * Set the CSS style class(es) to be rendered for this component.      *      * @param styleClass The new CSS style class(es)      */     public void setStyleClass(String styleClass) {          this.styleClass = styleClass;      }       // ---------------------------------------------------- StateManager Methods       /**      * Restore the state of this component.      *      * @param context FacesContext for the current request      * @param state State object from which to restore our state      */     public void restoreState(FacesContext context, Object state) {          Object values[] = (Object[]) state;         super.restoreState(context, values[0]);         bundle = (String) values[1];         filter = ((Boolean) values[2]).booleanValue();         filterSet = ((Boolean) values[3]).booleanValue();         key = (String) values[4];         style = (String) values[5];         styleClass = (String) values[6];      }       /**      * Save the state of this component.      *      * @param context FacesContext for the current request      */     public Object saveState(FacesContext context) {          Object values[] = new Object[7];         values[0] = super.saveState(context);         values[1] = bundle;         values[2] = filter ? Boolean.TRUE : Boolean.FALSE;         values[3] = filterSet ? Boolean.TRUE : Boolean.FALSE;         values[4] = key;         values[5] = style;         values[6] = styleClass;         return values;      }   }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6027</td>
    <td align="left">https://github.com/apache/struts1/blob/02c9ff7485b1900515c6e0b32ed54ea46dd97d51/faces/src/main/java/org/apache/struts/faces/component/MessageComponent.java/#L35-L285</td>
    <td align="right">1</td>
    <td align="right">604</td>
    <td align="right">6027</td>
  </tr>
  <tr valign="top">
    <td align="right">4227</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
 		protected int height; 		protected int width;  		public ImageSource( int width, int height ) 		{ 			this.width = width; 			this.height = height; 		}  		public int getHeight( ) 		{ 			return height; 		}  		public int getWidth( ) 		{ 			return width; 		}  		public abstract int getRGB( int x, int y ); 	}  	public class ArrayImageSource extends ImageSource</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11130</td>
    <td align="left">https://github.com/eclipse/birt/blob/f89264810347de98702db45386a822aabc0fadbf/engine/org.eclipse.birt.report.engine.emitter.postscript/src/org/eclipse/birt/report/engine/emitter/postscript/PostscriptWriter.java/#L1340-L1363</td>
    <td align="right">1</td>
    <td align="right">4227</td>
    <td align="right">11130</td>
  </tr>
  <tr valign="top">
    <td align="right">2471</td>
    <td align="left">&nbsp;{ &quot;answer&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Data Class&quot;] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ExtendedCompletionList {   private boolean inComplete;   private List items;    public ExtendedCompletionList(boolean incomplete, List items) {     this.inComplete = incomplete;     this.items = items;   }    public ExtendedCompletionList() {}    public List getItems() {     return items;   }    public void setItems(List items) {     this.items = items;   }    public boolean isInComplete() {     return inComplete;   }    public void setInComplete(boolean inComplete) {     this.inComplete = inComplete;   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14578</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/wsagent/che-core-api-languageserver-shared/src/main/java/org/eclipse/che/api/languageserver/shared/model/ExtendedCompletionList.java/#L22-L48</td>
    <td align="right">1</td>
    <td align="right">2471</td>
    <td align="right">14578</td>
  </tr>
  <tr valign="top">
    <td align="right">2470</td>
    <td align="left">&nbsp;	{ 		&quot;message&quot;: &quot;YES I found bad smells&quot;, 		&quot;detected_bad_smells&quot;: [ 			&quot;the bad smells are:&quot;, 			&quot;1. Blob&quot;, 			&quot;2. Data Class&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ReportInstance extends AbstractDTOBase {      private String id;     private ReportStatusEnum status;     private String url;     private String ownerId;     private Boolean hasDetailRows;     private ZonedDateTime completionDate;     private ZonedDateTime requestDate;      public String getId() {         return id;     }      public void setId(String id) {         this.id = id;     }      public ReportStatusEnum getStatus() {         return status;     }      public void setStatus(ReportStatusEnum status) {         this.status = status;     }      public String getUrl() {         return url;     }      public void setUrl(String url) {         this.url = url;     }      public String getOwnerId() {         return ownerId;     }      public void setOwnerId(String ownerId) {         this.ownerId = ownerId;     }      public Boolean getHasDetailRows() {         return hasDetailRows;     }      public void setHasDetailRows(Boolean hasDetailRows) {         this.hasDetailRows = hasDetailRows;     }      public ZonedDateTime getCompletionDate() {         return completionDate;     }      public void setCompletionDate(ZonedDateTime completionDate) {         this.completionDate = completionDate;     }      public ZonedDateTime getRequestDate() {         return requestDate;     }      public void setRequestDate(ZonedDateTime requestDate) {         this.requestDate = requestDate;     } }</td>
    <td align="left">data class</td>
    <td align="left">the bad smells are:, 1. blob, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">the bad smells are:,  1. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14576</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/api/dto/analytics/reports/ReportInstance.java/#L26-L91</td>
    <td align="right">1</td>
    <td align="right">2470</td>
    <td align="right">14576</td>
  </tr>
  <tr valign="top">
    <td align="right">4031</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [       &quot;Blob&quot;,       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Customer388 {  	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id; 	private String firstName; 	private String lastName;  	protected Customer388() {}  	public Customer388(String firstName, String lastName) { 		this.firstName = firstName; 		this.lastName = lastName; 	}  	@Override 	public String toString() { 		return String.format(&quot;Customer388[id=%d, firstName='%s', lastName='%s']&quot;, id, firstName, lastName); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10668</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer388.java/#L8-L27</td>
    <td align="right">1</td>
    <td align="right">4031</td>
    <td align="right">10668</td>
  </tr>
  <tr valign="top">
    <td align="right">2643</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;ProviderCreditReversalDetails&quot;, propOrder = {     &quot;amazonProviderCreditReversalId&quot;,     &quot;sellerId&quot;,     &quot;providerSellerId&quot;,     &quot;creditReversalReferenceId&quot;,     &quot;creditReversalAmount&quot;,     &quot;creationTimestamp&quot;,     &quot;creditReversalStatus&quot;,     &quot;creditReversalNote&quot; }) public class ProviderCreditReversalDetails {      @XmlElement(name = &quot;AmazonProviderCreditReversalId&quot;, required = true)     protected String amazonProviderCreditReversalId;     @XmlElement(name = &quot;SellerId&quot;, required = true)     protected String sellerId;     @XmlElement(name = &quot;ProviderSellerId&quot;, required = true)     protected String providerSellerId;     @XmlElement(name = &quot;CreditReversalReferenceId&quot;, required = true)     protected String creditReversalReferenceId;     @XmlElement(name = &quot;CreditReversalAmount&quot;, required = true)     protected Price creditReversalAmount;     @XmlElement(name = &quot;CreationTimestamp&quot;, required = true)     @XmlSchemaType(name = &quot;dateTime&quot;)     protected XMLGregorianCalendar creationTimestamp;     @XmlElement(name = &quot;CreditReversalStatus&quot;, required = true)     protected Status creditReversalStatus;     @XmlElement(name = &quot;CreditReversalNote&quot;)     protected String creditReversalNote;      public ProviderCreditReversalDetails() {         super();     }      /**      * Returns the amazonProviderCreditReversalId from notification      *       * @return Returns the amazonProviderCreditReversalId from notification      */     public String getAmazonProviderCreditReversalId() {         return amazonProviderCreditReversalId;     }      /**      * Returns the sellerId from notification      *       * @return Returns the sellerId from notification      */     public String getSellerId() {         return sellerId;     }      /**      * Returns the providerSellerId from notification      *       * @return Returns the providerSellerId from notification      */     public String getProviderSellerId() {         return providerSellerId;     }      /**      * Returns the creditReversalReferenceId from notification      *       * @return Returns the creditReversalReferenceId from notification      */     public String getCreditReversalReferenceId() {         return creditReversalReferenceId;     }       /**      * Returns the creditReversalAmount from notification       *       * @return Returns the creditReversalAmount from notification       */     public Price getCreditReversalAmount() {         return creditReversalAmount;     }      /**      * Returns the creationTimestamp from notification      *       * @return Returns the creationTimestamp from notification      */     public XMLGregorianCalendar getCreationTimestamp() {         return creationTimestamp;     }      /**      * Returns the creditReversalStatus from notification      *       * @return Returns the creditReversalStatus from notification      */     public Status getCreditReversalStatus() {         return creditReversalStatus;     }      /**      * Returns the creditReversalNote from notification      *       * @return Returns the creditReversalNote from notification      */     public String getCreditReversalNote() {         return creditReversalNote;     }      /**      * String representation of providerCreditReversalNotification      */     @Override     public String toString() {         return &quot;ProviderCreditReversalDetails{&quot; + &quot;amazonProviderCreditReversalId=&quot; + amazonProviderCreditReversalId                  + &quot;, sellerId=&quot; + sellerId + &quot;, providerId=&quot; + providerSellerId + &quot;, creditReversalReferenceId=&quot;                  + creditReversalReferenceId + &quot;, creditReversalAmount=&quot; + creditReversalAmount + &quot;, creationTimestamp=&quot;                  + creationTimestamp + &quot;, creditReversalStatus=&quot; + creditReversalStatus + &quot;, creditReversalNote=&quot;                  + creditReversalNote + '}';     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15147</td>
    <td align="left">https://github.com/amzn/amazon-pay-sdk-java/blob/5a3547d00c796aab8f0c8ac12e0310f7a5c4678a/src/com/amazon/pay/response/ipn/model/ProviderCreditReversalDetails.java/#L25-L145</td>
    <td align="right">1</td>
    <td align="right">2643</td>
    <td align="right">15147</td>
  </tr>
  <tr valign="top">
    <td align="right">2170</td>
    <td align="left">&nbsp;{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Data Class&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class BacktrackingBug325745TestLanguagePackageImpl extends EPackageImpl implements BacktrackingBug325745TestLanguagePackage {   /**    *     *     * @generated    */   private EClass modelEClass = null;    /**    *     *     * @generated    */   private EClass elementEClass = null;    /**    *     *     * @generated    */   private EClass dataTypeEClass = null;    /**    *     *     * @generated    */   private EClass expressionEClass = null;    /**    *     *     * @generated    */   private EClass simpleTermEClass = null;    /**    * Creates an instance of the model Package, registered with    * {@link org.eclipse.emf.ecore.EPackage.Registry EPackage.Registry} by the package    * package URI value.    * Note: the correct way to create the package is via the static    * factory method {@link #init init()}, which also performs    * initialization of the package, or returns the registered package,    * if one already exists.    *     *     * @see org.eclipse.emf.ecore.EPackage.Registry    * @see org.eclipse.xtext.parser.unorderedGroups.backtrackingBug325745TestLanguage.BacktrackingBug325745TestLanguagePackage#eNS_URI    * @see #init()    * @generated    */   private BacktrackingBug325745TestLanguagePackageImpl()   {     super(eNS_URI, BacktrackingBug325745TestLanguageFactory.eINSTANCE);   }    /**    *     *     * @generated    */   private static boolean isInited = false;    /**    * Creates, registers, and initializes the Package for this model, and for any others upon which it depends.    *     * This method is used to initialize {@link BacktrackingBug325745TestLanguagePackage#eINSTANCE} when that field is accessed.    * Clients should not invoke it directly. Instead, they should simply access that field to obtain the package.    *     *     * @see #eNS_URI    * @see #createPackageContents()    * @see #initializePackageContents()    * @generated    */   public static BacktrackingBug325745TestLanguagePackage init()   {     if (isInited) return (BacktrackingBug325745TestLanguagePackage)EPackage.Registry.INSTANCE.getEPackage(BacktrackingBug325745TestLanguagePackage.eNS_URI);      // Obtain or create and register package     BacktrackingBug325745TestLanguagePackageImpl theBacktrackingBug325745TestLanguagePackage = (BacktrackingBug325745TestLanguagePackageImpl)(EPackage.Registry.INSTANCE.get(eNS_URI) instanceof BacktrackingBug325745TestLanguagePackageImpl ? EPackage.Registry.INSTANCE.get(eNS_URI) : new BacktrackingBug325745TestLanguagePackageImpl());      isInited = true;      // Initialize simple dependencies     EcorePackage.eINSTANCE.eClass();      // Create package meta-data objects     theBacktrackingBug325745TestLanguagePackage.createPackageContents();      // Initialize created meta-data     theBacktrackingBug325745TestLanguagePackage.initializePackageContents();      // Mark meta-data to indicate it can't be changed     theBacktrackingBug325745TestLanguagePackage.freeze();         // Update the registry and return the package     EPackage.Registry.INSTANCE.put(BacktrackingBug325745TestLanguagePackage.eNS_URI, theBacktrackingBug325745TestLanguagePackage);     return theBacktrackingBug325745TestLanguagePackage;   }    /**    *     *     * @generated    */   public EClass getModel()   {     return modelEClass;   }    /**    *     *     * @generated    */   public EReference getModel_Fields()   {     return (EReference)modelEClass.getEStructuralFeatures().get(0);   }    /**    *     *     * @generated    */   public EClass getElement()   {     return elementEClass;   }    /**    *     *     * @generated    */   public EAttribute getElement_Name()   {     return (EAttribute)elementEClass.getEStructuralFeatures().get(0);   }    /**    *     *     * @generated    */   public EReference getElement_DataType()   {     return (EReference)elementEClass.getEStructuralFeatures().get(1);   }    /**    *     *     * @generated    */   public EReference getElement_Expression()   {     return (EReference)elementEClass.getEStructuralFeatures().get(2);   }    /**    *     *     * @generated    */   public EClass getDataType()   {     return dataTypeEClass;   }    /**    *     *     * @generated    */   public EAttribute getDataType_BaseType()   {     return (EAttribute)dataTypeEClass.getEStructuralFeatures().get(0);   }    /**    *     *     * @generated    */   public EAttribute getDataType_DefaultValue()   {     return (EAttribute)dataTypeEClass.getEStructuralFeatures().get(1);   }    /**    *     *     * @generated    */   public EClass getExpression()   {     return expressionEClass;   }    /**    *     *     * @generated    */   public EAttribute getExpression_Prefix()   {     return (EAttribute)expressionEClass.getEStructuralFeatures().get(0);   }    /**    *     *     * @generated    */   public EReference getExpression_Terms()   {     return (EReference)expressionEClass.getEStructuralFeatures().get(1);   }    /**    *     *     * @generated    */   public EAttribute getExpression_Postfix()   {     return (EAttribute)expressionEClass.getEStructuralFeatures().get(2);   }    /**    *     *     * @generated    */   public EClass getSimpleTerm()   {     return simpleTermEClass;   }    /**    *     *     * @generated    */   public EAttribute getSimpleTerm_LineCount()   {     return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(0);   }    /**    *     *     * @generated    */   public EAttribute getSimpleTerm_CharCount()   {     return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(1);   }    /**    *     *     * @generated    */   public EAttribute getSimpleTerm_CharSet()   {     return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(2);   }    /**    *     *     * @generated    */   public EAttribute getSimpleTerm_RefChar()   {     return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(3);   }    /**    *     *     * @generated    */   public BacktrackingBug325745TestLanguageFactory getBacktrackingBug325745TestLanguageFactory()   {     return (BacktrackingBug325745TestLanguageFactory)getEFactoryInstance();   }    /**    *     *     * @generated    */   private boolean isCreated = false;    /**    * Creates the meta-model objects for the package.  This method is    * guarded to have no affect on any invocation but its first.    *     *     * @generated    */   public void createPackageContents()   {     if (isCreated) return;     isCreated = true;      // Create classes and their features     modelEClass = createEClass(MODEL);     createEReference(modelEClass, MODEL__FIELDS);      elementEClass = createEClass(ELEMENT);     createEAttribute(elementEClass, ELEMENT__NAME);     createEReference(elementEClass, ELEMENT__DATA_TYPE);     createEReference(elementEClass, ELEMENT__EXPRESSION);      dataTypeEClass = createEClass(DATA_TYPE);     createEAttribute(dataTypeEClass, DATA_TYPE__BASE_TYPE);     createEAttribute(dataTypeEClass, DATA_TYPE__DEFAULT_VALUE);      expressionEClass = createEClass(EXPRESSION);     createEAttribute(expressionEClass, EXPRESSION__PREFIX);     createEReference(expressionEClass, EXPRESSION__TERMS);     createEAttribute(expressionEClass, EXPRESSION__POSTFIX);      simpleTermEClass = createEClass(SIMPLE_TERM);     createEAttribute(simpleTermEClass, SIMPLE_TERM__LINE_COUNT);     createEAttribute(simpleTermEClass, SIMPLE_TERM__CHAR_COUNT);     createEAttribute(simpleTermEClass, SIMPLE_TERM__CHAR_SET);     createEAttribute(simpleTermEClass, SIMPLE_TERM__REF_CHAR);   }    /**    *     *     * @generated    */   private boolean isInitialized = false;    /**    * Complete the initialization of the package and its meta-model.  This    * method is guarded to have no affect on any invocation but its first.    *     *     * @generated    */   public void initializePackageContents()   {     if (isInitialized) return;     isInitialized = true;      // Initialize package     setName(eNAME);     setNsPrefix(eNS_PREFIX);     setNsURI(eNS_URI);      // Obtain other dependent packages     EcorePackage theEcorePackage = (EcorePackage)EPackage.Registry.INSTANCE.getEPackage(EcorePackage.eNS_URI);      // Create type parameters      // Set bounds for type parameters      // Add supertypes to classes      // Initialize classes and features; add operations and parameters     initEClass(modelEClass, Model.class, &quot;Model&quot;, !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);     initEReference(getModel_Fields(), this.getElement(), null, &quot;fields&quot;, null, 0, -1, Model.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);      initEClass(elementEClass, Element.class, &quot;Element&quot;, !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);     initEAttribute(getElement_Name(), theEcorePackage.getEString(), &quot;name&quot;, null, 0, 1, Element.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEReference(getElement_DataType(), this.getDataType(), null, &quot;dataType&quot;, null, 0, 1, Element.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEReference(getElement_Expression(), this.getExpression(), null, &quot;expression&quot;, null, 0, 1, Element.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);      initEClass(dataTypeEClass, DataType.class, &quot;DataType&quot;, !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);     initEAttribute(getDataType_BaseType(), theEcorePackage.getEString(), &quot;baseType&quot;, null, 0, 1, DataType.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEAttribute(getDataType_DefaultValue(), theEcorePackage.getEString(), &quot;defaultValue&quot;, null, 0, 1, DataType.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);      initEClass(expressionEClass, Expression.class, &quot;Expression&quot;, !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);     initEAttribute(getExpression_Prefix(), theEcorePackage.getEString(), &quot;prefix&quot;, null, 0, 1, Expression.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEReference(getExpression_Terms(), this.getSimpleTerm(), null, &quot;terms&quot;, null, 0, -1, Expression.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEAttribute(getExpression_Postfix(), theEcorePackage.getEString(), &quot;postfix&quot;, null, 0, 1, Expression.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);      initEClass(simpleTermEClass, SimpleTerm.class, &quot;SimpleTerm&quot;, !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);     initEAttribute(getSimpleTerm_LineCount(), theEcorePackage.getEInt(), &quot;lineCount&quot;, null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEAttribute(getSimpleTerm_CharCount(), theEcorePackage.getEInt(), &quot;charCount&quot;, null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEAttribute(getSimpleTerm_CharSet(), theEcorePackage.getEString(), &quot;charSet&quot;, null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEAttribute(getSimpleTerm_RefChar(), theEcorePackage.getEString(), &quot;refChar&quot;, null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);      // Create resource     createResource(eNS_URI);   }  } //BacktrackingBug325745TestLanguagePackageImpl</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13356</td>
    <td align="left">https://github.com/eclipse/xtext-core/blob/e04964e4c2a3e0338c0079bd8333688835e77c31/org.eclipse.xtext.tests/src-gen/org/eclipse/xtext/parser/unorderedGroups/backtrackingBug325745TestLanguage/impl/BacktrackingBug325745TestLanguagePackageImpl.java/#L28-L426</td>
    <td align="right">1</td>
    <td align="right">2170</td>
    <td align="right">13356</td>
  </tr>
  <tr valign="top">
    <td align="right">2139</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ActionNamesAction extends ActionSupport {      private static final long serialVersionUID = -5389385242431387840L;      private Set actionNames;     private String namespace = &quot;&quot;;     private Set namespaces;     private String extension;      protected ConfigurationHelper configHelper;      @Inject     public void setConfigurationHelper(ConfigurationHelper cfg) {         this.configHelper = cfg;     }      public Set getActionNames() {         return actionNames;     }      public String getNamespace() {         return StringEscapeUtils.escapeHtml4(namespace);     }      public void setNamespace(String namespace) {         this.namespace = namespace;     }      @Inject(StrutsConstants.STRUTS_ACTION_EXTENSION)     public void setExtension(String ext) {         this.extension = ext;     }      public ActionConfig getConfig(String actionName) {         return configHelper.getActionConfig(namespace, actionName);     }      public Set getNamespaces() {         return namespaces;     }      public String getExtension() {         if (extension == null) {             return &quot;action&quot;;         }         if (extension.contains(&quot;,&quot;)) {             return extension.substring(0, extension.indexOf(&quot;,&quot;));         }         return extension;     }      public String execute() throws Exception {         namespaces = configHelper.getNamespaces();         if (namespaces.size() == 0) {             addActionError(&quot;There are no namespaces in this configuration&quot;);             return ERROR;         }         if (namespace == null) {             namespace = &quot;&quot;;         }         actionNames = new TreeSet(configHelper.getActionNames(namespace));         return SUCCESS;     }      /**      * Index action to support cooperation with REST plugin      *      * @return action result      * @throws Exception      */     public String index() throws Exception {         return execute();     }      public String redirect() {         return SUCCESS;     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13262</td>
    <td align="left">https://github.com/apache/struts/blob/e82c5a207f62fdb1bb6e8da690325b5a109c924f/plugins/config-browser/src/main/java/org/apache/struts2/config_browser/ActionNamesAction.java/#L33-L111</td>
    <td align="right">1</td>
    <td align="right">2139</td>
    <td align="right">13262</td>
  </tr>
  <tr valign="top">
    <td align="right">2216</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Named @RequestScoped public class UserUpdateBean {     private String name;          private String surname;          private int age;          private String userName;          private String password;          private @Inject @Default UserController controller;          private @Inject @Default SessionTracker tracker;          public UserUpdateBean()     {              }      public String showInfo()     {         //Just show how can access session webbeans         User user = this.controller.getUser(tracker.getUser().getId());                  setName(user.getName());         setSurname(user.getSurname());         setAge(user.getAge());         setUserName(user.getUserName());         setPassword(user.getPassword());                          return &quot;toUpdatePage&quot;;     }      public String clear()     {         setName(&quot;&quot;);         setSurname(&quot;&quot;);         setAge(0);         setUserName(&quot;&quot;);         setPassword(&quot;&quot;);                  return null;     }          public String update()     {         this.controller.updateUserInfo(tracker.getUser().getId(), name, surname, age, userName, password);                  JSFUtility.addInfoMessage(&quot;Personal information is succesfully updated.&quot;, &quot;&quot;);                  return null;     }          /**      * @return the name      */     public String getName()     {         return name;     }      /**      * @param name the name to set      */     public void setName(String name)     {         this.name = name;     }      /**      * @return the surname      */     public String getSurname()     {         return surname;     }      /**      * @param surname the surname to set      */     public void setSurname(String surname)     {         this.surname = surname;     }      /**      * @return the age      */     public int getAge()     {         return age;     }      /**      * @param age the age to set      */     public void setAge(int age)     {         this.age = age;     }      /**      * @return the userName      */     public String getUserName()     {         return userName;     }      /**      * @param userName the userName to set      */     public void setUserName(String userName)     {         this.userName = userName;     }      /**      * @return the password      */     public String getPassword()     {         return password;     }      /**      * @param password the password to set      */     public void setPassword(String password)     {         this.password = password;     }           }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13536</td>
    <td align="left">https://github.com/apache/openwebbeans/blob/7831798861478a035c9e9dcca151b5a67e4a28a3/samples/reservation/src/main/java/org/apache/webbeans/reservation/beans/user/UserUpdateBean.java/#L31-L169</td>
    <td align="right">1</td>
    <td align="right">2216</td>
    <td align="right">13536</td>
  </tr>
  <tr valign="top">
    <td align="right">629</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;bad_smells&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TransportConnectionState extends org.apache.activemq.state.ConnectionState {      private ConnectionContext context;     private TransportConnection connection;     private AtomicInteger referenceCounter = new AtomicInteger();     private final Object connectionMutex = new Object();      public TransportConnectionState(ConnectionInfo info, TransportConnection transportConnection) {         super(info);         connection = transportConnection;     }      public ConnectionContext getContext() {         return context;     }      public TransportConnection getConnection() {         return connection;     }      public void setContext(ConnectionContext context) {         this.context = context;     }      public void setConnection(TransportConnection connection) {         this.connection = connection;     }      public int incrementReference() {         return referenceCounter.incrementAndGet();     }      public int decrementReference() {         return referenceCounter.decrementAndGet();     }  	public AtomicInteger getReferenceCounter() { 		return referenceCounter; 	}  	public void setReferenceCounter(AtomicInteger referenceCounter) { 		this.referenceCounter = referenceCounter; 	}  	public Object getConnectionMutex() { 		return connectionMutex; 	} }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6279</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-broker/src/main/java/org/apache/activemq/broker/TransportConnectionState.java/#L27-L74</td>
    <td align="right">1</td>
    <td align="right">629</td>
    <td align="right">6279</td>
  </tr>
  <tr valign="top">
    <td align="right">3236</td>
    <td align="left">&nbsp;{   &quot;result&quot;: &quot;YES I found bad smells&quot;,   &quot;the bad smells are&quot;: [     &quot;Long Method&quot;,     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Singleton public class StandardComponentInitializer {    public static final String NAVIGATE_TO_FILE = &quot;navigateToFile&quot;;   public static final String FULL_TEXT_SEARCH = &quot;fullTextSearch&quot;;   public static final String PREVIEW_IMAGE = &quot;previewImage&quot;;   public static final String FIND_ACTION = &quot;findAction&quot;;   public static final String FORMAT = &quot;format&quot;;   public static final String SAVE = &quot;save&quot;;   public static final String COPY = &quot;copy&quot;;   public static final String CUT = &quot;cut&quot;;   public static final String PASTE = &quot;paste&quot;;   public static final String UNDO = &quot;undo&quot;;   public static final String REDO = &quot;redo&quot;;   public static final String SWITCH_LEFT_TAB = &quot;switchLeftTab&quot;;   public static final String SWITCH_RIGHT_TAB = &quot;switchRightTab&quot;;   public static final String OPEN_RECENT_FILES = &quot;openRecentFiles&quot;;   public static final String DELETE_ITEM = &quot;deleteItem&quot;;   public static final String NEW_FILE = &quot;newFile&quot;;   public static final String CREATE_PROJECT = &quot;createProject&quot;;   public static final String IMPORT_PROJECT = &quot;importProject&quot;;   public static final String CLOSE_ACTIVE_EDITOR = &quot;closeActiveEditor&quot;;   public static final String SIGNATURE_HELP = &quot;signatureHelp&quot;;   public static final String SOFT_WRAP = &quot;softWrap&quot;;   public static final String RENAME = &quot;renameResource&quot;;   public static final String SHOW_REFERENCE = &quot;showReference&quot;;   public static final String SHOW_COMMANDS_PALETTE = &quot;showCommandsPalette&quot;;   public static final String NEW_TERMINAL = &quot;newTerminal&quot;;   public static final String OPEN_IN_TERMINAL = &quot;openInTerminal&quot;;   public static final String PROJECT_EXPLORER_DISPLAYING_MODE = &quot;projectExplorerDisplayingMode&quot;;   public static final String COMMAND_EXPLORER_DISPLAYING_MODE = &quot;commandExplorerDisplayingMode&quot;;   public static final String FIND_RESULT_DISPLAYING_MODE = &quot;findResultDisplayingMode&quot;;   public static final String EVENT_LOGS_DISPLAYING_MODE = &quot;eventLogsDisplayingMode&quot;;   public static final String EDITOR_DISPLAYING_MODE = &quot;editorDisplayingMode&quot;;   public static final String TERMINAL_DISPLAYING_MODE = &quot;terminalDisplayingMode&quot;;   public static final String REVEAL_RESOURCE = &quot;revealResourceInProjectTree&quot;;   public static final String COLLAPSE_ALL = &quot;collapseAll&quot;;    public interface ParserResource extends ClientBundle {     @Source(&quot;org/eclipse/che/ide/blank.svg&quot;)     SVGResource samplesCategoryBlank();   }    @Inject private EditorRegistry editorRegistry;    @Inject private FileTypeRegistry fileTypeRegistry;    @Inject private Resources resources;    @Inject private KeyBindingAgent keyBinding;    @Inject private ActionManager actionManager;    @Inject private SaveAction saveAction;    @Inject private SaveAllAction saveAllAction;    @Inject private ShowPreferencesAction showPreferencesAction;    @Inject private PreviewImageAction previewImageAction;    @Inject private FindActionAction findActionAction;    @Inject private NavigateToFileAction navigateToFileAction;    @Inject @MainToolbar private ToolbarPresenter toolbarPresenter;    @Inject private CutResourceAction cutResourceAction;    @Inject private CopyResourceAction copyResourceAction;    @Inject private PasteResourceAction pasteResourceAction;    @Inject private DeleteResourceAction deleteResourceAction;    @Inject private RenameItemAction renameItemAction;    @Inject private SplitVerticallyAction splitVerticallyAction;    @Inject private SplitHorizontallyAction splitHorizontallyAction;    @Inject private CloseAction closeAction;    @Inject private CloseAllAction closeAllAction;    @Inject private CloseOtherAction closeOtherAction;    @Inject private CloseAllExceptPinnedAction closeAllExceptPinnedAction;    @Inject private ReopenClosedFileAction reopenClosedFileAction;    @Inject private PinEditorTabAction pinEditorTabAction;    @Inject private GoIntoAction goIntoAction;    @Inject private EditFileAction editFileAction;    @Inject private OpenFileAction openFileAction;    @Inject private ShowHiddenFilesAction showHiddenFilesAction;    @Inject private FormatterAction formatterAction;    @Inject private UndoAction undoAction;    @Inject private RedoAction redoAction;    @Inject private UploadFileAction uploadFileAction;    @Inject private UploadFolderAction uploadFolderAction;    @Inject private DownloadProjectAction downloadProjectAction;    @Inject private DownloadWsAction downloadWsAction;    @Inject private DownloadResourceAction downloadResourceAction;    @Inject private ImportProjectAction importProjectAction;    @Inject private CreateProjectAction createProjectAction;    @Inject private ConvertFolderToProjectAction convertFolderToProjectAction;    @Inject private FullTextSearchAction fullTextSearchAction;    @Inject private NewFolderAction newFolderAction;    @Inject private NewFileAction newFileAction;    @Inject private NewXmlFileAction newXmlFileAction;    @Inject private ImageViewerProvider imageViewerProvider;    @Inject private ProjectConfigurationAction projectConfigurationAction;    @Inject private ExpandEditorAction expandEditorAction;    @Inject private CompleteAction completeAction;    @Inject private SwitchPreviousEditorAction switchPreviousEditorAction;    @Inject private SwitchNextEditorAction switchNextEditorAction;    @Inject private HotKeysListAction hotKeysListAction;    @Inject private OpenRecentFilesAction openRecentFilesAction;    @Inject private ClearRecentListAction clearRecentFilesAction;    @Inject private CloseActiveEditorAction closeActiveEditorAction;    @Inject private MessageLoaderResources messageLoaderResources;    @Inject private EditorResources editorResources;    @Inject private PopupResources popupResources;    @Inject private ShowReferenceAction showReferenceAction;    @Inject private RevealResourceAction revealResourceAction;    @Inject private RefreshPathAction refreshPathAction;    @Inject private LinkWithEditorAction linkWithEditorAction;    @Inject private ShowToolbarAction showToolbarAction;    @Inject private SignatureHelpAction signatureHelpAction;    @Inject private MaximizePartAction maximizePartAction;    @Inject private HidePartAction hidePartAction;    @Inject private RestorePartAction restorePartAction;    @Inject private ShowCommandsPaletteAction showCommandsPaletteAction;    @Inject private SoftWrapAction softWrapAction;    @Inject private StartWorkspaceAction startWorkspaceAction;    @Inject private StopWorkspaceAction stopWorkspaceAction;    @Inject private ShowWorkspaceStatusAction showWorkspaceStatusAction;    @Inject private ShowRuntimeInfoAction showRuntimeInfoAction;    @Inject private RunCommandAction runCommandAction;    @Inject private NewTerminalAction newTerminalAction;    @Inject private ReRunProcessAction reRunProcessAction;    @Inject private StopProcessAction stopProcessAction;    @Inject private CloseConsoleAction closeConsoleAction;    @Inject private DisplayMachineOutputAction displayMachineOutputAction;    @Inject private PreviewSSHAction previewSSHAction;    @Inject private ShowConsoleTreeAction showConsoleTreeAction;    @Inject private AddToFileWatcherExcludesAction addToFileWatcherExcludesAction;    @Inject private RemoveFromFileWatcherExcludesAction removeFromFileWatcherExcludesAction;    @Inject private DevModeSetUpAction devModeSetUpAction;    @Inject private DevModeOffAction devModeOffAction;    @Inject private CollapseAllAction collapseAllAction;    @Inject private PerspectiveManager perspectiveManager;    @Inject private CommandsExplorerDisplayingModeAction commandsExplorerDisplayingModeAction;    @Inject private ProjectExplorerDisplayingModeAction projectExplorerDisplayingModeAction;    @Inject private EventLogsDisplayingModeAction eventLogsDisplayingModeAction;    @Inject private FindResultDisplayingModeAction findResultDisplayingModeAction;    @Inject private EditorDisplayingModeAction editorDisplayingModeAction;    @Inject private TerminalDisplayingModeAction terminalDisplayingModeAction;    @Inject private RenameCommandAction renameCommandAction;    @Inject private MoveCommandAction moveCommandAction;    @Inject private OpenInTerminalAction openInTerminalAction;    @Inject private FreeDiskSpaceStatusBarAction freeDiskSpaceStatusBarAction;    @Inject   @Named(&quot;XMLFileType&quot;)   private FileType xmlFile;    @Inject   @Named(&quot;TXTFileType&quot;)   private FileType txtFile;    @Inject   @Named(&quot;JsonFileType&quot;)   private FileType jsonFile;    @Inject   @Named(&quot;MDFileType&quot;)   private FileType mdFile;    @Inject   @Named(&quot;PNGFileType&quot;)   private FileType pngFile;    @Inject   @Named(&quot;BMPFileType&quot;)   private FileType bmpFile;    @Inject   @Named(&quot;GIFFileType&quot;)   private FileType gifFile;    @Inject   @Named(&quot;ICOFileType&quot;)   private FileType iconFile;    @Inject   @Named(&quot;SVGFileType&quot;)   private FileType svgFile;    @Inject   @Named(&quot;JPEFileType&quot;)   private FileType jpeFile;    @Inject   @Named(&quot;JPEGFileType&quot;)   private FileType jpegFile;    @Inject   @Named(&quot;JPGFileType&quot;)   private FileType jpgFile;    @Inject private CommandEditorProvider commandEditorProvider;    @Inject   @Named(&quot;CommandFileType&quot;)   private FileType commandFileType;    @Inject private ProjectConfigSynchronized projectConfigSynchronized;    @Inject private TreeResourceRevealer treeResourceRevealer; // just to work with it    @Inject private TerminalInitializer terminalInitializer;    /** Instantiates {@link StandardComponentInitializer} an creates standard content. */   @Inject   public StandardComponentInitializer(       IconRegistry iconRegistry,       MachineResources machineResources,       StandardComponentInitializer.ParserResource parserResource) {     iconRegistry.registerIcon(         new Icon(BLANK_CATEGORY + &quot;.samples.category.icon&quot;, parserResource.samplesCategoryBlank()));     iconRegistry.registerIcon(new Icon(&quot;che.machine.icon&quot;, machineResources.devMachine()));     machineResources.getCss().ensureInjected();   }    public void initialize() {     messageLoaderResources.Css().ensureInjected();     editorResources.editorCss().ensureInjected();     popupResources.popupStyle().ensureInjected();      fileTypeRegistry.registerFileType(xmlFile);      fileTypeRegistry.registerFileType(txtFile);      fileTypeRegistry.registerFileType(jsonFile);      fileTypeRegistry.registerFileType(mdFile);      fileTypeRegistry.registerFileType(pngFile);     editorRegistry.registerDefaultEditor(pngFile, imageViewerProvider);      fileTypeRegistry.registerFileType(bmpFile);     editorRegistry.registerDefaultEditor(bmpFile, imageViewerProvider);      fileTypeRegistry.registerFileType(gifFile);     editorRegistry.registerDefaultEditor(gifFile, imageViewerProvider);      fileTypeRegistry.registerFileType(iconFile);     editorRegistry.registerDefaultEditor(iconFile, imageViewerProvider);      fileTypeRegistry.registerFileType(svgFile);     editorRegistry.registerDefaultEditor(svgFile, imageViewerProvider);      fileTypeRegistry.registerFileType(jpeFile);     editorRegistry.registerDefaultEditor(jpeFile, imageViewerProvider);      fileTypeRegistry.registerFileType(jpegFile);     editorRegistry.registerDefaultEditor(jpegFile, imageViewerProvider);      fileTypeRegistry.registerFileType(jpgFile);     editorRegistry.registerDefaultEditor(jpgFile, imageViewerProvider);      fileTypeRegistry.registerFileType(commandFileType);     editorRegistry.registerDefaultEditor(commandFileType, commandEditorProvider);      // Workspace (New Menu)     DefaultActionGroup workspaceGroup =         (DefaultActionGroup) actionManager.getAction(GROUP_WORKSPACE);      actionManager.registerAction(IMPORT_PROJECT, importProjectAction);     workspaceGroup.add(importProjectAction);      actionManager.registerAction(CREATE_PROJECT, createProjectAction);     workspaceGroup.add(createProjectAction);      actionManager.registerAction(&quot;downloadWsAsZipAction&quot;, downloadWsAction);     workspaceGroup.add(downloadWsAction);      workspaceGroup.addSeparator();     workspaceGroup.add(startWorkspaceAction);     workspaceGroup.add(stopWorkspaceAction);     workspaceGroup.add(showWorkspaceStatusAction);      // Project (New Menu)     DefaultActionGroup projectGroup = (DefaultActionGroup) actionManager.getAction(GROUP_PROJECT);      DefaultActionGroup newGroup = new DefaultActionGroup(&quot;New&quot;, true, actionManager);     newGroup.getTemplatePresentation().setDescription(&quot;Create...&quot;);     newGroup         .getTemplatePresentation()         .setImageElement(new SVGImage(resources.newResource()).getElement());     actionManager.registerAction(GROUP_FILE_NEW, newGroup);     projectGroup.add(newGroup);      newGroup.addSeparator();      actionManager.registerAction(NEW_FILE, newFileAction);     newGroup.addAction(newFileAction, Constraints.FIRST);      actionManager.registerAction(&quot;newFolder&quot;, newFolderAction);     newGroup.addAction(newFolderAction, new Constraints(AFTER, NEW_FILE));      newGroup.addSeparator();      actionManager.registerAction(&quot;newXmlFile&quot;, newXmlFileAction);     newXmlFileAction         .getTemplatePresentation()         .setImageElement(new SVGImage(xmlFile.getImage()).getElement());     newGroup.addAction(newXmlFileAction);      actionManager.registerAction(&quot;uploadFile&quot;, uploadFileAction);     projectGroup.add(uploadFileAction);      actionManager.registerAction(&quot;uploadFolder&quot;, uploadFolderAction);     projectGroup.add(uploadFolderAction);      actionManager.registerAction(&quot;convertFolderToProject&quot;, convertFolderToProjectAction);     projectGroup.add(convertFolderToProjectAction);      actionManager.registerAction(&quot;downloadAsZipAction&quot;, downloadProjectAction);     projectGroup.add(downloadProjectAction);      actionManager.registerAction(&quot;showHideHiddenFiles&quot;, showHiddenFilesAction);     projectGroup.add(showHiddenFilesAction);      projectGroup.addSeparator();      actionManager.registerAction(&quot;projectConfiguration&quot;, projectConfigurationAction);     projectGroup.add(projectConfigurationAction);      DefaultActionGroup saveGroup = new DefaultActionGroup(actionManager);     actionManager.registerAction(&quot;saveGroup&quot;, saveGroup);     actionManager.registerAction(SAVE, saveAction);     saveGroup.addSeparator();     saveGroup.add(saveAction);      // Edit (New Menu)     DefaultActionGroup editGroup = (DefaultActionGroup) actionManager.getAction(GROUP_EDIT);     DefaultActionGroup recentGroup = new DefaultActionGroup(RECENT_GROUP_ID, true, actionManager);     actionManager.registerAction(GROUP_RECENT_FILES, recentGroup);     actionManager.registerAction(&quot;clearRecentList&quot;, clearRecentFilesAction);     recentGroup.addSeparator();     recentGroup.add(clearRecentFilesAction, LAST);     editGroup.add(recentGroup);     actionManager.registerAction(OPEN_RECENT_FILES, openRecentFilesAction);     editGroup.add(openRecentFilesAction);      actionManager.registerAction(CLOSE_ACTIVE_EDITOR, closeActiveEditorAction);     editGroup.add(closeActiveEditorAction);      actionManager.registerAction(FORMAT, formatterAction);     editGroup.add(formatterAction);      editGroup.add(saveAction);      actionManager.registerAction(UNDO, undoAction);     editGroup.add(undoAction);      actionManager.registerAction(REDO, redoAction);     editGroup.add(redoAction);      actionManager.registerAction(SOFT_WRAP, softWrapAction);     editGroup.add(softWrapAction);      actionManager.registerAction(CUT, cutResourceAction);     editGroup.add(cutResourceAction);      actionManager.registerAction(COPY, copyResourceAction);     editGroup.add(copyResourceAction);      actionManager.registerAction(PASTE, pasteResourceAction);     editGroup.add(pasteResourceAction);      actionManager.registerAction(RENAME, renameItemAction);     editGroup.add(renameItemAction);      actionManager.registerAction(DELETE_ITEM, deleteResourceAction);     editGroup.add(deleteResourceAction);      actionManager.registerAction(FULL_TEXT_SEARCH, fullTextSearchAction);     editGroup.add(fullTextSearchAction);      editGroup.addSeparator();     editGroup.add(switchPreviousEditorAction);     editGroup.add(switchNextEditorAction);      // Assistant (New Menu)     DefaultActionGroup assistantGroup =         (DefaultActionGroup) actionManager.getAction(GROUP_ASSISTANT);      actionManager.registerAction(PREVIEW_IMAGE, previewImageAction);     assistantGroup.add(previewImageAction);      actionManager.registerAction(FIND_ACTION, findActionAction);     assistantGroup.add(findActionAction);      actionManager.registerAction(&quot;hotKeysList&quot;, hotKeysListAction);     assistantGroup.add(hotKeysListAction);      assistantGroup.addSeparator();      // Switching of parts     DefaultActionGroup toolWindowsGroup =         new DefaultActionGroup(&quot;Tool Windows&quot;, true, actionManager);     actionManager.registerAction(TOOL_WINDOWS_GROUP, toolWindowsGroup);      actionManager.registerAction(         PROJECT_EXPLORER_DISPLAYING_MODE, projectExplorerDisplayingModeAction);     actionManager.registerAction(FIND_RESULT_DISPLAYING_MODE, findResultDisplayingModeAction);     actionManager.registerAction(EVENT_LOGS_DISPLAYING_MODE, eventLogsDisplayingModeAction);     actionManager.registerAction(         COMMAND_EXPLORER_DISPLAYING_MODE, commandsExplorerDisplayingModeAction);     actionManager.registerAction(EDITOR_DISPLAYING_MODE, editorDisplayingModeAction);     actionManager.registerAction(TERMINAL_DISPLAYING_MODE, terminalDisplayingModeAction);     toolWindowsGroup.add(projectExplorerDisplayingModeAction, FIRST);     toolWindowsGroup.add(         eventLogsDisplayingModeAction, new Constraints(AFTER, PROJECT_EXPLORER_DISPLAYING_MODE));     toolWindowsGroup.add(         findResultDisplayingModeAction, new Constraints(AFTER, EVENT_LOGS_DISPLAYING_MODE));     toolWindowsGroup.add(         commandsExplorerDisplayingModeAction, new Constraints(AFTER, FIND_RESULT_DISPLAYING_MODE));     toolWindowsGroup.add(editorDisplayingModeAction);     toolWindowsGroup.add(terminalDisplayingModeAction);      assistantGroup.add(toolWindowsGroup);     assistantGroup.addSeparator();      actionManager.registerAction(&quot;callCompletion&quot;, completeAction);     assistantGroup.add(completeAction);      actionManager.registerAction(&quot;downloadItemAction&quot;, downloadResourceAction);     actionManager.registerAction(NAVIGATE_TO_FILE, navigateToFileAction);     assistantGroup.add(navigateToFileAction);      assistantGroup.addSeparator();     actionManager.registerAction(&quot;devModeSetUpAction&quot;, devModeSetUpAction);     actionManager.registerAction(&quot;devModeOffAction&quot;, devModeOffAction);     assistantGroup.add(devModeSetUpAction);     assistantGroup.add(devModeOffAction);      // Compose Profile menu     DefaultActionGroup profileGroup = (DefaultActionGroup) actionManager.getAction(GROUP_PROFILE);     actionManager.registerAction(&quot;showPreferences&quot;, showPreferencesAction);      profileGroup.add(showPreferencesAction);      // Compose Help menu     DefaultActionGroup helpGroup = (DefaultActionGroup) actionManager.getAction(GROUP_HELP);     helpGroup.addSeparator();      // Processes panel actions     actionManager.registerAction(&quot;startWorkspace&quot;, startWorkspaceAction);     actionManager.registerAction(&quot;stopWorkspace&quot;, stopWorkspaceAction);     actionManager.registerAction(&quot;showWorkspaceStatus&quot;, showWorkspaceStatusAction);     actionManager.registerAction(&quot;runCommand&quot;, runCommandAction);     actionManager.registerAction(&quot;newTerminal&quot;, newTerminalAction);      // Compose main context menu     DefaultActionGroup resourceOperation = new DefaultActionGroup(actionManager);     actionManager.registerAction(&quot;resourceOperation&quot;, resourceOperation);     actionManager.registerAction(&quot;refreshPathAction&quot;, refreshPathAction);     actionManager.registerAction(&quot;linkWithEditor&quot;, linkWithEditorAction);     actionManager.registerAction(&quot;showToolbar&quot;, showToolbarAction);      resourceOperation.addSeparator();     resourceOperation.add(previewImageAction);     resourceOperation.add(showReferenceAction);     resourceOperation.add(goIntoAction);     resourceOperation.add(editFileAction);      resourceOperation.add(saveAction);     resourceOperation.add(cutResourceAction);     resourceOperation.add(copyResourceAction);     resourceOperation.add(pasteResourceAction);     resourceOperation.add(renameItemAction);     resourceOperation.add(deleteResourceAction);     resourceOperation.addSeparator();     resourceOperation.add(downloadResourceAction);     resourceOperation.add(refreshPathAction);     resourceOperation.add(linkWithEditorAction);     resourceOperation.add(collapseAllAction);     resourceOperation.addSeparator();     resourceOperation.add(convertFolderToProjectAction);     resourceOperation.addSeparator();     resourceOperation.addSeparator();     resourceOperation.add(addToFileWatcherExcludesAction);     resourceOperation.add(removeFromFileWatcherExcludesAction);     resourceOperation.addSeparator();      DefaultActionGroup mainContextMenuGroup =         (DefaultActionGroup) actionManager.getAction(GROUP_MAIN_CONTEXT_MENU);     mainContextMenuGroup.add(newGroup, FIRST);     mainContextMenuGroup.addSeparator();     mainContextMenuGroup.add(resourceOperation);     mainContextMenuGroup.add(openInTerminalAction);     actionManager.registerAction(OPEN_IN_TERMINAL, openInTerminalAction);      DefaultActionGroup partMenuGroup =         (DefaultActionGroup) actionManager.getAction(GROUP_PART_MENU);     partMenuGroup.add(maximizePartAction);     partMenuGroup.add(hidePartAction);     partMenuGroup.add(restorePartAction);     partMenuGroup.add(showConsoleTreeAction);     partMenuGroup.add(revealResourceAction);     partMenuGroup.add(collapseAllAction);     partMenuGroup.add(refreshPathAction);     partMenuGroup.add(linkWithEditorAction);      DefaultActionGroup toolbarControllerGroup =         (DefaultActionGroup) actionManager.getAction(GROUP_TOOLBAR_CONTROLLER);     toolbarControllerGroup.add(showToolbarAction);      actionManager.registerAction(&quot;expandEditor&quot;, expandEditorAction);     DefaultActionGroup rightMenuGroup =         (DefaultActionGroup) actionManager.getAction(GROUP_RIGHT_MAIN_MENU);     rightMenuGroup.add(expandEditorAction, FIRST);      // Compose main toolbar     DefaultActionGroup changeResourceGroup = new DefaultActionGroup(actionManager);     actionManager.registerAction(&quot;changeResourceGroup&quot;, changeResourceGroup);     actionManager.registerAction(&quot;editFile&quot;, editFileAction);     actionManager.registerAction(&quot;goInto&quot;, goIntoAction);     actionManager.registerAction(SHOW_REFERENCE, showReferenceAction);      actionManager.registerAction(REVEAL_RESOURCE, revealResourceAction);     actionManager.registerAction(COLLAPSE_ALL, collapseAllAction);      actionManager.registerAction(&quot;openFile&quot;, openFileAction);     actionManager.registerAction(SWITCH_LEFT_TAB, switchPreviousEditorAction);     actionManager.registerAction(SWITCH_RIGHT_TAB, switchNextEditorAction);      changeResourceGroup.add(cutResourceAction);     changeResourceGroup.add(copyResourceAction);     changeResourceGroup.add(pasteResourceAction);     changeResourceGroup.add(deleteResourceAction);      DefaultActionGroup mainToolbarGroup =         (DefaultActionGroup) actionManager.getAction(GROUP_MAIN_TOOLBAR);     mainToolbarGroup.add(newGroup);     mainToolbarGroup.add(saveGroup);     mainToolbarGroup.add(changeResourceGroup);     toolbarPresenter.bindMainGroup(mainToolbarGroup);      DefaultActionGroup centerToolbarGroup =         (DefaultActionGroup) actionManager.getAction(GROUP_CENTER_TOOLBAR);     toolbarPresenter.bindCenterGroup(centerToolbarGroup);      DefaultActionGroup rightToolbarGroup =         (DefaultActionGroup) actionManager.getAction(GROUP_RIGHT_TOOLBAR);     toolbarPresenter.bindRightGroup(rightToolbarGroup);      actionManager.registerAction(&quot;showServers&quot;, showRuntimeInfoAction);      // Consoles tree context menu group     DefaultActionGroup consolesTreeContextMenu =         (DefaultActionGroup) actionManager.getAction(GROUP_CONSOLES_TREE_CONTEXT_MENU);     consolesTreeContextMenu.add(showRuntimeInfoAction);     consolesTreeContextMenu.add(newTerminalAction);     consolesTreeContextMenu.add(reRunProcessAction);     consolesTreeContextMenu.add(stopProcessAction);     consolesTreeContextMenu.add(closeConsoleAction);      actionManager.registerAction(&quot;displayMachineOutput&quot;, displayMachineOutputAction);     consolesTreeContextMenu.add(displayMachineOutputAction);      actionManager.registerAction(&quot;previewSSH&quot;, previewSSHAction);     consolesTreeContextMenu.add(previewSSHAction);      // Editor context menu group     DefaultActionGroup editorTabContextMenu =         (DefaultActionGroup) actionManager.getAction(GROUP_EDITOR_TAB_CONTEXT_MENU);     editorTabContextMenu.add(closeAction);     actionManager.registerAction(CLOSE, closeAction);     editorTabContextMenu.add(closeAllAction);     actionManager.registerAction(CLOSE_ALL, closeAllAction);     editorTabContextMenu.add(closeOtherAction);     actionManager.registerAction(CLOSE_OTHER, closeOtherAction);     editorTabContextMenu.add(closeAllExceptPinnedAction);     actionManager.registerAction(CLOSE_ALL_EXCEPT_PINNED, closeAllExceptPinnedAction);     editorTabContextMenu.addSeparator();     editorTabContextMenu.add(reopenClosedFileAction);     actionManager.registerAction(REOPEN_CLOSED, reopenClosedFileAction);     editorTabContextMenu.add(pinEditorTabAction);     actionManager.registerAction(PIN_TAB, pinEditorTabAction);     editorTabContextMenu.addSeparator();     actionManager.registerAction(SPLIT_HORIZONTALLY, splitHorizontallyAction);     editorTabContextMenu.add(splitHorizontallyAction);     actionManager.registerAction(SPLIT_VERTICALLY, splitVerticallyAction);     editorTabContextMenu.add(splitVerticallyAction);     actionManager.registerAction(SIGNATURE_HELP, signatureHelpAction);      actionManager.registerAction(SHOW_COMMANDS_PALETTE, showCommandsPaletteAction);     DefaultActionGroup runGroup =         (DefaultActionGroup) actionManager.getAction(IdeActions.GROUP_RUN);     runGroup.add(showCommandsPaletteAction);     runGroup.add(newTerminalAction, FIRST);     runGroup.addSeparator();      DefaultActionGroup editorContextMenuGroup = new DefaultActionGroup(actionManager);     actionManager.registerAction(GROUP_EDITOR_CONTEXT_MENU, editorContextMenuGroup);      editorContextMenuGroup.add(saveAction);     editorContextMenuGroup.add(undoAction);     editorContextMenuGroup.add(redoAction);     editorContextMenuGroup.addSeparator();     editorContextMenuGroup.add(formatterAction);     editorContextMenuGroup.add(softWrapAction);      editorContextMenuGroup.addSeparator();     editorContextMenuGroup.add(fullTextSearchAction);     editorContextMenuGroup.add(closeActiveEditorAction);      editorContextMenuGroup.addSeparator();     editorContextMenuGroup.add(revealResourceAction);      DefaultActionGroup commandExplorerMenuGroup = new DefaultActionGroup(actionManager);     actionManager.registerAction(GROUP_COMMAND_EXPLORER_CONTEXT_MENU, commandExplorerMenuGroup);      actionManager.registerAction(&quot;renameCommand&quot;, renameCommandAction);     commandExplorerMenuGroup.add(renameCommandAction);     actionManager.registerAction(&quot;moveCommand&quot;, moveCommandAction);     commandExplorerMenuGroup.add(moveCommandAction);      DefaultActionGroup rightStatusPanelGroup =         (DefaultActionGroup) actionManager.getAction(GROUP_RIGHT_STATUS_PANEL);     rightStatusPanelGroup.add(freeDiskSpaceStatusBarAction);      // Define hot-keys     keyBinding         .getGlobal()         .addKey(new KeyBuilder().action().alt().charCode('n').build(), NAVIGATE_TO_FILE);     keyBinding         .getGlobal()         .addKey(new KeyBuilder().action().charCode('F').build(), FULL_TEXT_SEARCH);     keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('A').build(), FIND_ACTION);     keyBinding.getGlobal().addKey(new KeyBuilder().alt().charCode('L').build(), FORMAT);     keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('c').build(), COPY);     keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('x').build(), CUT);     keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('v').build(), PASTE);     keyBinding.getGlobal().addKey(new KeyBuilder().shift().charCode(KeyCodeMap.F6).build(), RENAME);     keyBinding         .getGlobal()         .addKey(new KeyBuilder().shift().charCode(KeyCodeMap.F7).build(), SHOW_REFERENCE);     keyBinding         .getGlobal()         .addKey(new KeyBuilder().alt().charCode(KeyCodeMap.ARROW_LEFT).build(), SWITCH_LEFT_TAB);     keyBinding         .getGlobal()         .addKey(new KeyBuilder().alt().charCode(KeyCodeMap.ARROW_RIGHT).build(), SWITCH_RIGHT_TAB);     keyBinding         .getGlobal()         .addKey(new KeyBuilder().action().charCode('e').build(), OPEN_RECENT_FILES);     keyBinding         .getGlobal()         .addKey(new KeyBuilder().charCode(KeyCodeMap.DELETE).build(), DELETE_ITEM);     keyBinding.getGlobal().addKey(new KeyBuilder().action().alt().charCode('w').build(), SOFT_WRAP);     keyBinding         .getGlobal()         .addKey(new KeyBuilder().alt().charCode(KeyCodeMap.F12).build(), NEW_TERMINAL);     keyBinding         .getGlobal()         .addKey(new KeyBuilder().alt().shift().charCode(KeyCodeMap.F12).build(), OPEN_IN_TERMINAL);      keyBinding.getGlobal().addKey(new KeyBuilder().alt().charCode('N').build(), NEW_FILE);     keyBinding.getGlobal().addKey(new KeyBuilder().alt().charCode('x').build(), CREATE_PROJECT);     keyBinding.getGlobal().addKey(new KeyBuilder().alt().charCode('A').build(), IMPORT_PROJECT);      keyBinding         .getGlobal()         .addKey(new KeyBuilder().shift().charCode(KeyCodeMap.F10).build(), SHOW_COMMANDS_PALETTE);      keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('s').build(), SAVE);      keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('z').build(), UNDO);     keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('y').build(), REDO);      if (UserAgent.isMac()) {       keyBinding           .getGlobal()           .addKey(               new KeyBuilder().action().control().charCode('1').build(),               PROJECT_EXPLORER_DISPLAYING_MODE);        keyBinding           .getGlobal()           .addKey(               new KeyBuilder().action().control().charCode('2').build(),               EVENT_LOGS_DISPLAYING_MODE);        keyBinding           .getGlobal()           .addKey(               new KeyBuilder().action().control().charCode('3').build(),               FIND_RESULT_DISPLAYING_MODE);        keyBinding           .getGlobal()           .addKey(               new KeyBuilder().action().control().charCode('4').build(),               COMMAND_EXPLORER_DISPLAYING_MODE);        keyBinding           .getGlobal()           .addKey(new KeyBuilder().action().charCode('E').build(), EDITOR_DISPLAYING_MODE);        keyBinding           .getGlobal()           .addKey(new KeyBuilder().action().charCode('T').build(), TERMINAL_DISPLAYING_MODE);     } else {       keyBinding           .getGlobal()           .addKey(               new KeyBuilder().action().alt().charCode('1').build(),               PROJECT_EXPLORER_DISPLAYING_MODE);        keyBinding           .getGlobal()           .addKey(               new KeyBuilder().action().alt().charCode('2').build(), EVENT_LOGS_DISPLAYING_MODE);        keyBinding           .getGlobal()           .addKey(               new KeyBuilder().action().alt().charCode('3').build(), FIND_RESULT_DISPLAYING_MODE);        keyBinding           .getGlobal()           .addKey(               new KeyBuilder().action().alt().charCode('4').build(),               COMMAND_EXPLORER_DISPLAYING_MODE);        keyBinding           .getGlobal()           .addKey(new KeyBuilder().alt().charCode('E').build(), EDITOR_DISPLAYING_MODE);        keyBinding           .getGlobal()           .addKey(new KeyBuilder().alt().charCode('T').build(), TERMINAL_DISPLAYING_MODE);     }      keyBinding         .getGlobal()         .addKey(new KeyBuilder().action().charCode(ARROW_DOWN).build(), REVEAL_RESOURCE);     keyBinding         .getGlobal()         .addKey(new KeyBuilder().action().charCode(ARROW_UP).build(), COLLAPSE_ALL);      if (UserAgent.isMac()) {       keyBinding           .getGlobal()           .addKey(new KeyBuilder().control().charCode('w').build(), CLOSE_ACTIVE_EDITOR);       keyBinding           .getGlobal()           .addKey(new KeyBuilder().control().charCode('p').build(), SIGNATURE_HELP);     } else {       keyBinding           .getGlobal()           .addKey(new KeyBuilder().alt().charCode('w').build(), CLOSE_ACTIVE_EDITOR);       keyBinding           .getGlobal()           .addKey(new KeyBuilder().action().charCode('p').build(), SIGNATURE_HELP);     }      final Map perspectives = perspectiveManager.getPerspectives();     if (perspectives.size()         &gt; 1) { // if registered perspectives will be more then 2 Main Menu -&gt; Window       // will appears and contains all of them as sub-menu       final DefaultActionGroup windowMenu = new DefaultActionGroup(&quot;Window&quot;, true, actionManager);       actionManager.registerAction(&quot;Window&quot;, windowMenu);       final DefaultActionGroup mainMenu =           (DefaultActionGroup) actionManager.getAction(GROUP_MAIN_MENU);       mainMenu.add(windowMenu);       for (Perspective perspective : perspectives.values()) {         final BaseAction action =             new BaseAction(perspective.getPerspectiveName()) {               @Override               public void actionPerformed(ActionEvent e) {                 perspectiveManager.setPerspectiveId(perspective.getPerspectiveId());               }             };         actionManager.registerAction(perspective.getPerspectiveId(), action);         windowMenu.add(action);       }     }   } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5427</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/ide/che-core-ide-app/src/main/java/org/eclipse/che/ide/core/StandardComponentInitializer.java/#L179-L1046</td>
    <td align="right">1</td>
    <td align="right">3236</td>
    <td align="right">5427</td>
  </tr>
  <tr valign="top">
    <td align="right">2051</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Car2 {   @Id   private String numberPlate;      private String colour;      private int engineSize;      private int numberOfSeats;    public String getNumberPlate() {     return numberPlate;   }    public void setNumberPlate(String numberPlate) {     this.numberPlate = numberPlate;   }    public String getColour() {     return colour;   }    public void setColour(String colour) {     this.colour = colour;   }    public int getEngineSize() {     return engineSize;   }    public void setEngineSize(int engineSize) {     this.engineSize = engineSize;   }    public int getNumberOfSeats() {     return numberOfSeats;   }    public void setNumberOfSeats(int numberOfSeats) {     this.numberOfSeats = numberOfSeats;   }       }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12894</td>
    <td align="left">https://github.com/apache/aries-jpa/blob/f8a04dfabbf0853af07926e4d8f8028b0d829bc8/itests/jpa-container-testbundle-eclipselink/src/main/java/org/apache/aries/jpa/container/itest/eclipselink/entities/Car2.java/#L24-L68</td>
    <td align="right">1</td>
    <td align="right">2051</td>
    <td align="right">12894</td>
  </tr>
  <tr valign="top">
    <td align="right">3653</td>
    <td align="left">&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;bad_smells&quot;: [         &quot;Long Method&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
 		protected int height; 		protected int width;  		public ImageSource( int width, int height ) 		{ 			this.width = width; 			this.height = height; 		}  		public int getHeight( ) 		{ 			return height; 		}  		public int getWidth( ) 		{ 			return width; 		}  		public abstract int getRGB( int x, int y ); 	}  	public class ArrayImageSource extends ImageSource</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8313</td>
    <td align="left">https://github.com/eclipse/birt/blob/f89264810347de98702db45386a822aabc0fadbf/engine/org.eclipse.birt.report.engine.emitter.postscript/src/org/eclipse/birt/report/engine/emitter/postscript/PostscriptWriter.java/#L1340-L1363</td>
    <td align="right">1</td>
    <td align="right">3653</td>
    <td align="right">8313</td>
  </tr>
  <tr valign="top">
    <td align="right">2562</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;response&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class ValidEmail {         @Email         String newEmail;          public String getNewEmail() {             return newEmail;         }          public void setNewEmail(String email) {             this.newEmail = email;         }     }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14843</td>
    <td align="left">https://github.com/cloudfoundry/uaa/blob/f3b66dd2a250c1309a86cade560ac9a9cfeafec7/server/src/main/java/org/cloudfoundry/identity/uaa/account/ChangeEmailController.java/#L147-L158</td>
    <td align="right">1</td>
    <td align="right">2562</td>
    <td align="right">14843</td>
  </tr>
  <tr valign="top">
    <td align="right">1083</td>
    <td align="left">&nbsp;{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;Blob&quot;,     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;serialization-registration-type&quot;,     namespace = &quot;http://geode.apache.org/schema/cache&quot;,     propOrder = {&quot;serializers&quot;, &quot;instantiators&quot;}) @Experimental public class SerializationRegistrationType {    @XmlElement(name = &quot;serializer&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)   protected List serializers;   @XmlElement(name = &quot;instantiator&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)   protected List instantiators;    /**    * Gets the value of the serializer property.    *    *     * This accessor method returns a reference to the live list,    * not a snapshot. Therefore any modification you make to the    * returned list will be present inside the JAXB object.    * This is why there is not a set method for the serializer property.    *    *     * For example, to add a new item, do as follows:    *    *     * getSerializer().add(newItem);    *     *    *    *     * Objects of the following type(s) are allowed in the list    * {@link SerializationRegistrationType.Serializer }    *    *    */   public List getSerializers() {     if (serializers == null) {       serializers = new ArrayList();     }     return this.serializers;   }    /**    * Gets the value of the instantiator property.    *    *     * This accessor method returns a reference to the live list,    * not a snapshot. Therefore any modification you make to the    * returned list will be present inside the JAXB object.    * This is why there is not a set method for the instantiator property.    *    *     * For example, to add a new item, do as follows:    *    *     * getInstantiator().add(newItem);    *     *    *    *     * Objects of the following type(s) are allowed in the list    * {@link SerializationRegistrationType.Instantiator }    *    *    */   public List getInstantiators() {     if (instantiators == null) {       instantiators = new ArrayList();     }     return this.instantiators;   }     /**    *     * Java class for anonymous complex type.    *    *     * The following schema fragment specifies the expected content contained within this class.    *    *     * &lt;complexType&gt;    *   &lt;complexContent&gt;    *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;    *       &lt;sequence&gt;    *         &lt;element name=&quot;class-name&quot; type=&quot;{http://geode.apache.org/schema/cache}class-name-type&quot;/&gt;    *       &lt;/sequence&gt;    *       &lt;attribute name=&quot;id&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;    *     &lt;/restriction&gt;    *   &lt;/complexContent&gt;    * &lt;/complexType&gt;    *     *    *    */   @XmlAccessorType(XmlAccessType.FIELD)   @XmlType(name = &quot;&quot;, propOrder = {&quot;className&quot;})   public static class Instantiator {      @XmlElement(name = &quot;class-name&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;,         required = true)     protected String className;     @XmlAttribute(name = &quot;id&quot;, required = true)     protected String id;      /**      * Gets the value of the className property.      *      * possible object is      * {@link String }      *      */     public String getClassName() {       return className;     }      /**      * Sets the value of the className property.      *      * allowed object is      * {@link String }      *      */     public void setClassName(String value) {       this.className = value;     }      /**      * Gets the value of the id property.      *      * possible object is      * {@link String }      *      */     public String getId() {       return id;     }      /**      * Sets the value of the id property.      *      * allowed object is      * {@link String }      *      */     public void setId(String value) {       this.id = value;     }    }     /**    *     * Java class for anonymous complex type.    *    *     * The following schema fragment specifies the expected content contained within this class.    *    *     * &lt;complexType&gt;    *   &lt;complexContent&gt;    *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;    *       &lt;sequence&gt;    *         &lt;element name=&quot;class-name&quot; type=&quot;{http://geode.apache.org/schema/cache}class-name-type&quot;/&gt;    *       &lt;/sequence&gt;    *     &lt;/restriction&gt;    *   &lt;/complexContent&gt;    * &lt;/complexType&gt;    *     *    *    */   @XmlAccessorType(XmlAccessType.FIELD)   @XmlType(name = &quot;&quot;, propOrder = {&quot;className&quot;})   public static class Serializer {      @XmlElement(name = &quot;class-name&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;,         required = true)     protected String className;      /**      * Gets the value of the className property.      *      * possible object is      * {@link String }      *      */     public String getClassName() {       return className;     }      /**      * Sets the value of the className property.      *      * allowed object is      * {@link String }      *      */     public void setClassName(String value) {       this.className = value;     }    }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9689</td>
    <td align="left">https://github.com/apache/geode/blob/8fd839e8b73e40bd2dfd14f331b587431bd35a66/geode-management/src/main/java/org/apache/geode/cache/configuration/SerializationRegistrationType.java/#L81-L286</td>
    <td align="right">1</td>
    <td align="right">1083</td>
    <td align="right">9689</td>
  </tr>
  <tr valign="top">
    <td align="right">2324</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{       &quot;message&quot;: &quot;YES I found bad smells&quot;,       &quot;bad smells are&quot;: [          &quot;Data Class&quot;,          &quot;Long Method&quot;       ]    }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LimitedSizeDataCollection implements SWCollection {      private final HashMap&gt; data;     private final int limitedSize;     private volatile boolean writing;     private volatile boolean reading;      LimitedSizeDataCollection(int limitedSize) {         this.data = new HashMap&lt;&gt;();         this.writing = false;         this.reading = false;         this.limitedSize = limitedSize;     }      public void finishWriting() {         writing = false;     }      @Override public void writing() {         writing = true;     }      @Override public boolean isWriting() {         return writing;     }      @Override public void finishReading() {         reading = false;     }      @Override public void reading() {         reading = true;     }      @Override public boolean isReading() {         return reading;     }      @Override public int size() {         return data.size();     }      @Override public void clear() {         data.clear();     }      @Override public boolean containsKey(STORAGE_DATA key) {         throw new UnsupportedOperationException(&quot;Limited size data collection doesn't support containsKey operation.&quot;);     }      @Override public STORAGE_DATA get(STORAGE_DATA key) {         throw new UnsupportedOperationException(&quot;Limited size data collection doesn't support get operation.&quot;);     }      @Override public void put(STORAGE_DATA value) {         LinkedList storageDataList = this.data.get(value);         if (storageDataList == null) {             storageDataList = new LinkedList&lt;&gt;();             data.put(value, storageDataList);         }          if (storageDataList.size() &lt; limitedSize) {             storageDataList.add(value);             return;         }          for (int i = 0; i &lt; storageDataList.size(); i++) {             STORAGE_DATA storageData = storageDataList.get(i);             if (value.compareTo(storageData) &lt;= 0) {                 if (i == 0) {                     // input value is less than the smallest in top N list, ignore                 } else {                     // Remove the smallest in top N list                     // add the current value into the right position                     storageDataList.add(i, value);                     storageDataList.removeFirst();                 }                 return;             }         }          // Add the value as biggest in top N list         storageDataList.addLast(value);         storageDataList.removeFirst();     }      @Override public Collection collection() {         List collection = new ArrayList&lt;&gt;();         data.values().forEach(e -&gt; e.forEach(collection::add));         return collection;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14136</td>
    <td align="left">https://github.com/apache/incubator-skywalking/blob/32c4bced8a7e055003d6e4bea0fd8f8361bec8e5/oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/data/LimitedSizeDataCollection.java/#L24-L115</td>
    <td align="right">1</td>
    <td align="right">2324</td>
    <td align="right">14136</td>
  </tr>
  <tr valign="top">
    <td align="right">3854</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class ResolutionOptions {     public static class EncodingStrategy extends TypesafeEnum {         private EncodingStrategy(final int value) {             super(value);         }          /**          * When this strategy is chosen, the file's existing encoding is used.          */         public final static EncodingStrategy DEFAULT = new EncodingStrategy(0);         /**          * When this strategy is chosen, the all files involved in the merge          * will have their encodings treated like the given encoding. No file          * conversion is done.          */         public final static EncodingStrategy OVERRIDE_EXPLICIT = new EncodingStrategy(1);         /**          * When this strategy is chosen, the all files involved in the merge          * will be converted into the explicitly named encoding.          */         public final static EncodingStrategy CONVERT_EXPLICIT = new EncodingStrategy(2);     }      /**      * How to go about resolving encoding conflicts.      */     private EncodingStrategy encodingStrategy = EncodingStrategy.DEFAULT;      /**      * Only used when _encodingStrategy is not default.      */     private FileEncoding explicitEncoding = FileEncoding.AUTOMATICALLY_DETECT;      private boolean useInternalEngine = true;      private FileEncoding acceptMergeEncoding = null;      private String newPath = null;      private boolean acceptMergeWithConflicts = false;      private PropertyValue[] acceptMergeProperties;      /**      * Creates a {@link ResolutionOptions} with the default options set.      */     public ResolutionOptions() {         super();     }      /**      * Sets the strategy for resolving encoding conflicts. If the strategy is      * EncodingStrategy.DEFAULT, explicitEncoding must be null. If the strategy      * is some other value, explicitEncoding must be non-null, and represents      * the overriding encoding, or conversion encoding, or whatever that      * strategy's comment says it represents.      *      * @param strategy      *        the strategy to take for resolving encoding conflicts.      * @param explicitEncoding      *        the encoding to use for resolving conflicts (null if the strategy      *        is EncodingStrategy.DEFAULT).      */     public void setEncodingStrategy(final EncodingStrategy strategy, final FileEncoding explicitEncoding) {         Check.isTrue(             (strategy == EncodingStrategy.DEFAULT &amp;&amp; explicitEncoding == null || explicitEncoding != null),             &quot;explicitEncoding must be null if strategy is EncodingStrategy.DEFAULT&quot;); //$NON-NLS-1$          encodingStrategy = strategy;         this.explicitEncoding = explicitEncoding;     }      /**      * Gets the encoding resolution strategy. If the returned strategy is not      * EncodingStrategy.DEFAULT, call getExplicitEncoding() to get the encoding      * to be used for the strategy.      *      * @return the encoding resolution strategy.      */     public EncodingStrategy getEncodingStrategy() {         return encodingStrategy;     }      /**      * Gets the explicit encoding set previously as part of setting an encoding      * strategy.      *      * @return the encoding to use as part of the encoding resolution strategy,      *         null if not set or if the strategy was EncodingStrategy.DEFAULT.      */     public FileEncoding getExplicitEncoding() {         return explicitEncoding;     }      public void setUseInternalEngine(final boolean useInternalEngine) {         this.useInternalEngine = useInternalEngine;     }      public boolean useInternalEngine() {         return useInternalEngine;     }      /**      * When a conflict is to be resolved with the AcceptMerge resolution and      * there is a conflicting pending encoding change, the given encoding will      * be used (no file conversion is done). If the given encoding is null, the      * conflict will not be resolved.      *      * @param encoding      *        the encoding to use when an automatic merge is desired and there      *        is a conflicting pending change.      */     public void setAcceptMergeEncoding(final FileEncoding encoding) {         acceptMergeEncoding = encoding;     }      /**      * Gets the encoding to use when an AcceptMerge resolution is desired but      * there is a conflicting pending encoding change. If null is returned, the      * encoding should be unchanged.      *      * @return the encoding to use to resolve the case where AcceptMerge must      *         operate on a file with a conflicting pending encoding change,      *         null if the encoding should be unchanged.      */     public FileEncoding getAcceptMergeEncoding() {         return acceptMergeEncoding;     }      /**      * When a conflict is to be resolved with the AcceptMerge resolution and      * there is a conflicting pending property change, this property contains      * the desired properties. If this property is left as null, the conflict      * will not be resolved.      */     public PropertyValue[] getAcceptMergeProperties() {         return acceptMergeProperties;     }      public void setAcceptMergeProperties(final PropertyValue[] acceptMergeProperties) {         this.acceptMergeProperties = acceptMergeProperties;     }      /**      * Sets the new path for a conflicted item or the item in its way when it      * needs needs to move to a new location. This may happen in cases like      * these:      *      * Merge conflict with AcceptMerge chosen, and there's a conflicting pending      * rename: set the desired name. If null, the conflict will not be resolved.      *      * Namespace conflict with AcceptTheirs: set the path that would describe      * their item.      *      * Namespace conflict with AcceptYours: set to the path of the local item      * that was in the way of the server item.      *      * @param newPath      *        the path to use for this conflict resolution, null to defer the      *        resolution in the cases documented above.      */     public void setNewPath(final String newPath) {         this.newPath = newPath;     }      /**      * Gets the new path to use for this resolution. See setNewPath() comments      * for details.      *      * @return the new path, null if not set.      */     public String getNewPath() {         return newPath;     }      /**      * @return true if a merge should be resolved when conflicts remain in the      *         file, false if the merge should not be resolved when conflicts      *         remain      */     public boolean isAcceptMergeWithConflicts() {         return acceptMergeWithConflicts;     }      /**      * Sets the option to accept (resolve a conflict) when the merge resulted in      * conflicts.      *      * @param mergeWithConflicts      *        true if a merge should be resolved when conflicts remain in the      *        file, false if the merge should not be resolved when conflicts      *        remain      */     public void setAcceptMergeWithConflicts(final boolean mergeWithConflicts) {         acceptMergeWithConflicts = mergeWithConflicts;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10010</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core/src/com/microsoft/tfs/core/clients/versioncontrol/ResolutionOptions.java/#L17-L213</td>
    <td align="right">1</td>
    <td align="right">3854</td>
    <td align="right">10010</td>
  </tr>
  <tr valign="top">
    <td align="right">139</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public class GroupMultiplicitiesElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.xtext.validation.ConcreteSyntaxValidationTestLanguage.GroupMultiplicities&quot;); 		private final Group cGroup = (Group)rule.eContents().get(1); 		private final Keyword cNumberSignDigitFourKeyword_0 = (Keyword)cGroup.eContents().get(0); 		private final Assignment cVal1Assignment_1 = (Assignment)cGroup.eContents().get(1); 		private final RuleCall cVal1IDTerminalRuleCall_1_0 = (RuleCall)cVal1Assignment_1.eContents().get(0); 		private final Keyword cKw1Keyword_2 = (Keyword)cGroup.eContents().get(2); 		private final Group cGroup_3 = (Group)cGroup.eContents().get(3); 		private final Assignment cVal2Assignment_3_0 = (Assignment)cGroup_3.eContents().get(0); 		private final RuleCall cVal2IDTerminalRuleCall_3_0_0 = (RuleCall)cVal2Assignment_3_0.eContents().get(0); 		private final Assignment cVal3Assignment_3_1 = (Assignment)cGroup_3.eContents().get(1); 		private final RuleCall cVal3IDTerminalRuleCall_3_1_0 = (RuleCall)cVal3Assignment_3_1.eContents().get(0); 		private final Keyword cKw2Keyword_4 = (Keyword)cGroup.eContents().get(4); 		private final Group cGroup_5 = (Group)cGroup.eContents().get(5); 		private final Assignment cVal4Assignment_5_0 = (Assignment)cGroup_5.eContents().get(0); 		private final RuleCall cVal4IDTerminalRuleCall_5_0_0 = (RuleCall)cVal4Assignment_5_0.eContents().get(0); 		private final Assignment cVal5Assignment_5_1 = (Assignment)cGroup_5.eContents().get(1); 		private final RuleCall cVal5IDTerminalRuleCall_5_1_0 = (RuleCall)cVal5Assignment_5_1.eContents().get(0); 		private final Keyword cKw3Keyword_6 = (Keyword)cGroup.eContents().get(6); 		private final Group cGroup_7 = (Group)cGroup.eContents().get(7); 		private final Assignment cVal6Assignment_7_0 = (Assignment)cGroup_7.eContents().get(0); 		private final RuleCall cVal6IDTerminalRuleCall_7_0_0 = (RuleCall)cVal6Assignment_7_0.eContents().get(0); 		private final Assignment cVal7Assignment_7_1 = (Assignment)cGroup_7.eContents().get(1); 		private final RuleCall cVal7IDTerminalRuleCall_7_1_0 = (RuleCall)cVal7Assignment_7_1.eContents().get(0); 		 		//GroupMultiplicities: 		//	&quot;#4&quot; val1=ID &quot;kw1&quot; (val2=ID val3=ID)? &quot;kw2&quot; (val4+=ID val5+=ID)+ &quot;kw3&quot; (val6+=ID val7+=ID)*; 		@Override public ParserRule getRule() { return rule; } 		 		//&quot;#4&quot; val1=ID &quot;kw1&quot; (val2=ID val3=ID)? &quot;kw2&quot; (val4+=ID val5+=ID)+ &quot;kw3&quot; (val6+=ID val7+=ID)* 		public Group getGroup() { return cGroup; } 		 		//&quot;#4&quot; 		public Keyword getNumberSignDigitFourKeyword_0() { return cNumberSignDigitFourKeyword_0; } 		 		//val1=ID 		public Assignment getVal1Assignment_1() { return cVal1Assignment_1; } 		 		//ID 		public RuleCall getVal1IDTerminalRuleCall_1_0() { return cVal1IDTerminalRuleCall_1_0; } 		 		//&quot;kw1&quot; 		public Keyword getKw1Keyword_2() { return cKw1Keyword_2; } 		 		//(val2=ID val3=ID)? 		public Group getGroup_3() { return cGroup_3; } 		 		//val2=ID 		public Assignment getVal2Assignment_3_0() { return cVal2Assignment_3_0; } 		 		//ID 		public RuleCall getVal2IDTerminalRuleCall_3_0_0() { return cVal2IDTerminalRuleCall_3_0_0; } 		 		//val3=ID 		public Assignment getVal3Assignment_3_1() { return cVal3Assignment_3_1; } 		 		//ID 		public RuleCall getVal3IDTerminalRuleCall_3_1_0() { return cVal3IDTerminalRuleCall_3_1_0; } 		 		//&quot;kw2&quot; 		public Keyword getKw2Keyword_4() { return cKw2Keyword_4; } 		 		//(val4+=ID val5+=ID)+ 		public Group getGroup_5() { return cGroup_5; } 		 		//val4+=ID 		public Assignment getVal4Assignment_5_0() { return cVal4Assignment_5_0; } 		 		//ID 		public RuleCall getVal4IDTerminalRuleCall_5_0_0() { return cVal4IDTerminalRuleCall_5_0_0; } 		 		//val5+=ID 		public Assignment getVal5Assignment_5_1() { return cVal5Assignment_5_1; } 		 		//ID 		public RuleCall getVal5IDTerminalRuleCall_5_1_0() { return cVal5IDTerminalRuleCall_5_1_0; } 		 		//&quot;kw3&quot; 		public Keyword getKw3Keyword_6() { return cKw3Keyword_6; } 		 		//(val6+=ID val7+=ID)* 		public Group getGroup_7() { return cGroup_7; } 		 		//val6+=ID 		public Assignment getVal6Assignment_7_0() { return cVal6Assignment_7_0; } 		 		//ID 		public RuleCall getVal6IDTerminalRuleCall_7_0_0() { return cVal6IDTerminalRuleCall_7_0_0; } 		 		//val7+=ID 		public Assignment getVal7Assignment_7_1() { return cVal7Assignment_7_1; } 		 		//ID 		public RuleCall getVal7IDTerminalRuleCall_7_1_0() { return cVal7IDTerminalRuleCall_7_1_0; } 	}</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1751</td>
    <td align="left">https://github.com/eclipse/xtext-core/blob/e04964e4c2a3e0338c0079bd8333688835e77c31/org.eclipse.xtext.tests/src-gen/org/eclipse/xtext/validation/services/ConcreteSyntaxValidationTestLanguageGrammarAccess.java/#L414-L508</td>
    <td align="right">1</td>
    <td align="right">139</td>
    <td align="right">1751</td>
  </tr>
  <tr valign="top">
    <td align="right">2294</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TagTag extends DefineTagSupport {      private String name;      public TagTag() {     }      // Tag interface     //-------------------------------------------------------------------------     public void doTag(XMLOutput output) throws JellyTagException {         getTagLibrary().registerDynamicTag( getName(), getBody() );     }      // Properties     //-------------------------------------------------------------------------      /** @return the name of the tag to create */     public String getName() {         return name;     }      /** Sets the name of the tag to create */     public void setName(String name) {         this.name = name;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13978</td>
    <td align="left">https://github.com/apache/commons-jelly/blob/48c008cc2328402e0976295625b32c5197ba2324/jelly-tags/define/src/main/java/org/apache/commons/jelly/tags/define/TagTag.java/#L32-L57</td>
    <td align="right">1</td>
    <td align="right">2294</td>
    <td align="right">13978</td>
  </tr>
  <tr valign="top">
    <td align="right">2230</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static final class Builder extends         com.google.protobuf.GeneratedMessage.Builder implements         // @@protoc_insertion_point(builder_implements:com.alibaba.otter.canal.protocol.RowChange)         RowChangeOrBuilder {       public static final com.google.protobuf.Descriptors.Descriptor           getDescriptor() {         return CanalEntry.internal_static_com_alibaba_otter_canal_protocol_RowChange_descriptor;       }        protected FieldAccessorTable           internalGetFieldAccessorTable() {         return CanalEntry.internal_static_com_alibaba_otter_canal_protocol_RowChange_fieldAccessorTable             .ensureFieldAccessorsInitialized(                 RowChange.class, Builder.class);       }        // Construct using com.alibaba.otter.canal.protocol.CanalEntry.RowChange.newBuilder()       private Builder() {         maybeForceBuilderInitialization();       }        private Builder(           BuilderParent parent) {         super(parent);         maybeForceBuilderInitialization();       }       private void maybeForceBuilderInitialization() {         if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {           getRowDatasFieldBuilder();           getPropsFieldBuilder();         }       }       private static Builder create() {         return new Builder();       }        public Builder clear() {         super.clear();         tableId_ = 0L;         bitField0_ = (bitField0_ &amp; ~0x00000001);         eventType_ = EventType.UPDATE;         bitField0_ = (bitField0_ &amp; ~0x00000002);         isDdl_ = false;         bitField0_ = (bitField0_ &amp; ~0x00000004);         sql_ = &quot;&quot;;         bitField0_ = (bitField0_ &amp; ~0x00000008);         if (rowDatasBuilder_ == null) {           rowDatas_ = java.util.Collections.emptyList();           bitField0_ = (bitField0_ &amp; ~0x00000010);         } else {           rowDatasBuilder_.clear();         }         if (propsBuilder_ == null) {           props_ = java.util.Collections.emptyList();           bitField0_ = (bitField0_ &amp; ~0x00000020);         } else {           propsBuilder_.clear();         }         ddlSchemaName_ = &quot;&quot;;         bitField0_ = (bitField0_ &amp; ~0x00000040);         return this;       }        public Builder clone() {         return create().mergeFrom(buildPartial());       }        public com.google.protobuf.Descriptors.Descriptor           getDescriptorForType() {         return CanalEntry.internal_static_com_alibaba_otter_canal_protocol_RowChange_descriptor;       }        public RowChange getDefaultInstanceForType() {         return RowChange.getDefaultInstance();       }        public RowChange build() {         RowChange result = buildPartial();         if (!result.isInitialized()) {           throw newUninitializedMessageException(result);         }         return result;       }        public RowChange buildPartial() {         RowChange result = new RowChange(this);         int from_bitField0_ = bitField0_;         int to_bitField0_ = 0;         if (((from_bitField0_ &amp; 0x00000001) == 0x00000001)) {           to_bitField0_ |= 0x00000001;         }         result.tableId_ = tableId_;         if (((from_bitField0_ &amp; 0x00000002) == 0x00000002)) {           to_bitField0_ |= 0x00000002;         }         result.eventType_ = eventType_;         if (((from_bitField0_ &amp; 0x00000004) == 0x00000004)) {           to_bitField0_ |= 0x00000004;         }         result.isDdl_ = isDdl_;         if (((from_bitField0_ &amp; 0x00000008) == 0x00000008)) {           to_bitField0_ |= 0x00000008;         }         result.sql_ = sql_;         if (rowDatasBuilder_ == null) {           if (((bitField0_ &amp; 0x00000010) == 0x00000010)) {             rowDatas_ = java.util.Collections.unmodifiableList(rowDatas_);             bitField0_ = (bitField0_ &amp; ~0x00000010);           }           result.rowDatas_ = rowDatas_;         } else {           result.rowDatas_ = rowDatasBuilder_.build();         }         if (propsBuilder_ == null) {           if (((bitField0_ &amp; 0x00000020) == 0x00000020)) {             props_ = java.util.Collections.unmodifiableList(props_);             bitField0_ = (bitField0_ &amp; ~0x00000020);           }           result.props_ = props_;         } else {           result.props_ = propsBuilder_.build();         }         if (((from_bitField0_ &amp; 0x00000040) == 0x00000040)) {           to_bitField0_ |= 0x00000010;         }         result.ddlSchemaName_ = ddlSchemaName_;         result.bitField0_ = to_bitField0_;         onBuilt();         return result;       }        public Builder mergeFrom(com.google.protobuf.Message other) {         if (other instanceof RowChange) {           return mergeFrom((RowChange)other);         } else {           super.mergeFrom(other);           return this;         }       }        public Builder mergeFrom(RowChange other) {         if (other == RowChange.getDefaultInstance()) return this;         if (other.hasTableId()) {           setTableId(other.getTableId());         }         if (other.hasEventType()) {           setEventType(other.getEventType());         }         if (other.hasIsDdl()) {           setIsDdl(other.getIsDdl());         }         if (other.hasSql()) {           bitField0_ |= 0x00000008;           sql_ = other.sql_;           onChanged();         }         if (rowDatasBuilder_ == null) {           if (!other.rowDatas_.isEmpty()) {             if (rowDatas_.isEmpty()) {               rowDatas_ = other.rowDatas_;               bitField0_ = (bitField0_ &amp; ~0x00000010);             } else {               ensureRowDatasIsMutable();               rowDatas_.addAll(other.rowDatas_);             }             onChanged();           }         } else {           if (!other.rowDatas_.isEmpty()) {             if (rowDatasBuilder_.isEmpty()) {               rowDatasBuilder_.dispose();               rowDatasBuilder_ = null;               rowDatas_ = other.rowDatas_;               bitField0_ = (bitField0_ &amp; ~0x00000010);               rowDatasBuilder_ =                 com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?                    getRowDatasFieldBuilder() : null;             } else {               rowDatasBuilder_.addAllMessages(other.rowDatas_);             }           }         }         if (propsBuilder_ == null) {           if (!other.props_.isEmpty()) {             if (props_.isEmpty()) {               props_ = other.props_;               bitField0_ = (bitField0_ &amp; ~0x00000020);             } else {               ensurePropsIsMutable();               props_.addAll(other.props_);             }             onChanged();           }         } else {           if (!other.props_.isEmpty()) {             if (propsBuilder_.isEmpty()) {               propsBuilder_.dispose();               propsBuilder_ = null;               props_ = other.props_;               bitField0_ = (bitField0_ &amp; ~0x00000020);               propsBuilder_ =                 com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?                    getPropsFieldBuilder() : null;             } else {               propsBuilder_.addAllMessages(other.props_);             }           }         }         if (other.hasDdlSchemaName()) {           bitField0_ |= 0x00000040;           ddlSchemaName_ = other.ddlSchemaName_;           onChanged();         }         this.mergeUnknownFields(other.getUnknownFields());         return this;       }        public final boolean isInitialized() {         return true;       }        public Builder mergeFrom(           com.google.protobuf.CodedInputStream input,           com.google.protobuf.ExtensionRegistryLite extensionRegistry)           throws java.io.IOException {         RowChange parsedMessage = null;         try {           parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);         } catch (com.google.protobuf.InvalidProtocolBufferException e) {           parsedMessage = (RowChange) e.getUnfinishedMessage();           throw e;         } finally {           if (parsedMessage != null) {             mergeFrom(parsedMessage);           }         }         return this;       }       private int bitField0_;        private long tableId_ ;       /**        * optional int64 tableId = 1;        *        *         **tableId,由数据库产生*        *         */       public boolean hasTableId() {         return ((bitField0_ &amp; 0x00000001) == 0x00000001);       }       /**        * optional int64 tableId = 1;        *        *         **tableId,由数据库产生*        *         */       public long getTableId() {         return tableId_;       }       /**        * optional int64 tableId = 1;        *        *         **tableId,由数据库产生*        *         */       public Builder setTableId(long value) {         bitField0_ |= 0x00000001;         tableId_ = value;         onChanged();         return this;       }       /**        * optional int64 tableId = 1;        *        *         **tableId,由数据库产生*        *         */       public Builder clearTableId() {         bitField0_ = (bitField0_ &amp; ~0x00000001);         tableId_ = 0L;         onChanged();         return this;       }        private EventType eventType_ = EventType.UPDATE;       /**        * optional .com.alibaba.otter.canal.protocol.EventType eventType = 2 [default = UPDATE];        *        *         **数据变更类型*        *         */       public boolean hasEventType() {         return ((bitField0_ &amp; 0x00000002) == 0x00000002);       }       /**        * optional .com.alibaba.otter.canal.protocol.EventType eventType = 2 [default = UPDATE];        *        *         **数据变更类型*        *         */       public EventType getEventType() {         return eventType_;       }       /**        * optional .com.alibaba.otter.canal.protocol.EventType eventType = 2 [default = UPDATE];        *        *         **数据变更类型*        *         */       public Builder setEventType(EventType value) {         if (value == null) {           throw new NullPointerException();         }         bitField0_ |= 0x00000002;         eventType_ = value;         onChanged();         return this;       }       /**        * optional .com.alibaba.otter.canal.protocol.EventType eventType = 2 [default = UPDATE];        *        *         **数据变更类型*        *         */       public Builder clearEventType() {         bitField0_ = (bitField0_ &amp; ~0x00000002);         eventType_ = EventType.UPDATE;         onChanged();         return this;       }        private boolean isDdl_ ;       /**        * optional bool isDdl = 10 [default = false];        *        *         ** 标识是否是ddl语句  *        *         */       public boolean hasIsDdl() {         return ((bitField0_ &amp; 0x00000004) == 0x00000004);       }       /**        * optional bool isDdl = 10 [default = false];        *        *         ** 标识是否是ddl语句  *        *         */       public boolean getIsDdl() {         return isDdl_;       }       /**        * optional bool isDdl = 10 [default = false];        *        *         ** 标识是否是ddl语句  *        *         */       public Builder setIsDdl(boolean value) {         bitField0_ |= 0x00000004;         isDdl_ = value;         onChanged();         return this;       }       /**        * optional bool isDdl = 10 [default = false];        *        *         ** 标识是否是ddl语句  *        *         */       public Builder clearIsDdl() {         bitField0_ = (bitField0_ &amp; ~0x00000004);         isDdl_ = false;         onChanged();         return this;       }        private Object sql_ = &quot;&quot;;       /**        * optional string sql = 11;        *        *         ** ddl/query的sql语句  *        *         */       public boolean hasSql() {         return ((bitField0_ &amp; 0x00000008) == 0x00000008);       }       /**        * optional string sql = 11;        *        *         ** ddl/query的sql语句  *        *         */       public String getSql() {         Object ref = sql_;         if (!(ref instanceof String)) {           com.google.protobuf.ByteString bs =               (com.google.protobuf.ByteString) ref;           String s = bs.toStringUtf8();           if (bs.isValidUtf8()) {             sql_ = s;           }           return s;         } else {           return (String) ref;         }       }       /**        * optional string sql = 11;        *        *         ** ddl/query的sql语句  *        *         */       public com.google.protobuf.ByteString           getSqlBytes() {         Object ref = sql_;         if (ref instanceof String) {           com.google.protobuf.ByteString b =               com.google.protobuf.ByteString.copyFromUtf8(                   (String) ref);           sql_ = b;           return b;         } else {           return (com.google.protobuf.ByteString) ref;         }       }       /**        * optional string sql = 11;        *        *         ** ddl/query的sql语句  *        *         */       public Builder setSql(           String value) {         if (value == null) {     throw new NullPointerException();   }   bitField0_ |= 0x00000008;         sql_ = value;         onChanged();         return this;       }       /**        * optional string sql = 11;        *        *         ** ddl/query的sql语句  *        *         */       public Builder clearSql() {         bitField0_ = (bitField0_ &amp; ~0x00000008);         sql_ = getDefaultInstance().getSql();         onChanged();         return this;       }       /**        * optional string sql = 11;        *        *         ** ddl/query的sql语句  *        *         */       public Builder setSqlBytes(           com.google.protobuf.ByteString value) {         if (value == null) {     throw new NullPointerException();   }   bitField0_ |= 0x00000008;         sql_ = value;         onChanged();         return this;       }        private java.util.List rowDatas_ =         java.util.Collections.emptyList();       private void ensureRowDatasIsMutable() {         if (!((bitField0_ &amp; 0x00000010) == 0x00000010)) {           rowDatas_ = new java.util.ArrayList(rowDatas_);           bitField0_ |= 0x00000010;          }       }        private com.google.protobuf.RepeatedFieldBuilder&lt;           RowData, RowData.Builder, RowDataOrBuilder&gt; rowDatasBuilder_;        /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public java.util.List getRowDatasList() {         if (rowDatasBuilder_ == null) {           return java.util.Collections.unmodifiableList(rowDatas_);         } else {           return rowDatasBuilder_.getMessageList();         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public int getRowDatasCount() {         if (rowDatasBuilder_ == null) {           return rowDatas_.size();         } else {           return rowDatasBuilder_.getCount();         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public RowData getRowDatas(int index) {         if (rowDatasBuilder_ == null) {           return rowDatas_.get(index);         } else {           return rowDatasBuilder_.getMessage(index);         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder setRowDatas(           int index, RowData value) {         if (rowDatasBuilder_ == null) {           if (value == null) {             throw new NullPointerException();           }           ensureRowDatasIsMutable();           rowDatas_.set(index, value);           onChanged();         } else {           rowDatasBuilder_.setMessage(index, value);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder setRowDatas(           int index, RowData.Builder builderForValue) {         if (rowDatasBuilder_ == null) {           ensureRowDatasIsMutable();           rowDatas_.set(index, builderForValue.build());           onChanged();         } else {           rowDatasBuilder_.setMessage(index, builderForValue.build());         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder addRowDatas(RowData value) {         if (rowDatasBuilder_ == null) {           if (value == null) {             throw new NullPointerException();           }           ensureRowDatasIsMutable();           rowDatas_.add(value);           onChanged();         } else {           rowDatasBuilder_.addMessage(value);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder addRowDatas(           int index, RowData value) {         if (rowDatasBuilder_ == null) {           if (value == null) {             throw new NullPointerException();           }           ensureRowDatasIsMutable();           rowDatas_.add(index, value);           onChanged();         } else {           rowDatasBuilder_.addMessage(index, value);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder addRowDatas(           RowData.Builder builderForValue) {         if (rowDatasBuilder_ == null) {           ensureRowDatasIsMutable();           rowDatas_.add(builderForValue.build());           onChanged();         } else {           rowDatasBuilder_.addMessage(builderForValue.build());         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder addRowDatas(           int index, RowData.Builder builderForValue) {         if (rowDatasBuilder_ == null) {           ensureRowDatasIsMutable();           rowDatas_.add(index, builderForValue.build());           onChanged();         } else {           rowDatasBuilder_.addMessage(index, builderForValue.build());         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder addAllRowDatas(           Iterable values) {         if (rowDatasBuilder_ == null) {           ensureRowDatasIsMutable();           com.google.protobuf.AbstractMessageLite.Builder.addAll(               values, rowDatas_);           onChanged();         } else {           rowDatasBuilder_.addAllMessages(values);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder clearRowDatas() {         if (rowDatasBuilder_ == null) {           rowDatas_ = java.util.Collections.emptyList();           bitField0_ = (bitField0_ &amp; ~0x00000010);           onChanged();         } else {           rowDatasBuilder_.clear();         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder removeRowDatas(int index) {         if (rowDatasBuilder_ == null) {           ensureRowDatasIsMutable();           rowDatas_.remove(index);           onChanged();         } else {           rowDatasBuilder_.remove(index);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public RowData.Builder getRowDatasBuilder(           int index) {         return getRowDatasFieldBuilder().getBuilder(index);       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public RowDataOrBuilder getRowDatasOrBuilder(           int index) {         if (rowDatasBuilder_ == null) {           return rowDatas_.get(index);  } else {           return rowDatasBuilder_.getMessageOrBuilder(index);         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public java.util.List            getRowDatasOrBuilderList() {         if (rowDatasBuilder_ != null) {           return rowDatasBuilder_.getMessageOrBuilderList();         } else {           return java.util.Collections.unmodifiableList(rowDatas_);         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public RowData.Builder addRowDatasBuilder() {         return getRowDatasFieldBuilder().addBuilder(             RowData.getDefaultInstance());       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public RowData.Builder addRowDatasBuilder(           int index) {         return getRowDatasFieldBuilder().addBuilder(             index, RowData.getDefaultInstance());       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public java.util.List            getRowDatasBuilderList() {         return getRowDatasFieldBuilder().getBuilderList();       }       private com.google.protobuf.RepeatedFieldBuilder&lt;           RowData, RowData.Builder, RowDataOrBuilder&gt;           getRowDatasFieldBuilder() {         if (rowDatasBuilder_ == null) {           rowDatasBuilder_ = new com.google.protobuf.RepeatedFieldBuilder&lt;               RowData, RowData.Builder, RowDataOrBuilder&gt;(                   rowDatas_,                   ((bitField0_ &amp; 0x00000010) == 0x00000010),                   getParentForChildren(),                   isClean());           rowDatas_ = null;         }         return rowDatasBuilder_;       }        private java.util.List props_ =         java.util.Collections.emptyList();       private void ensurePropsIsMutable() {         if (!((bitField0_ &amp; 0x00000020) == 0x00000020)) {           props_ = new java.util.ArrayList(props_);           bitField0_ |= 0x00000020;          }       }        private com.google.protobuf.RepeatedFieldBuilder&lt;           Pair, Pair.Builder, PairOrBuilder&gt; propsBuilder_;        /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public java.util.List getPropsList() {         if (propsBuilder_ == null) {           return java.util.Collections.unmodifiableList(props_);         } else {           return propsBuilder_.getMessageList();         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public int getPropsCount() {         if (propsBuilder_ == null) {           return props_.size();         } else {           return propsBuilder_.getCount();         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Pair getProps(int index) {         if (propsBuilder_ == null) {           return props_.get(index);         } else {           return propsBuilder_.getMessage(index);         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder setProps(           int index, Pair value) {         if (propsBuilder_ == null) {           if (value == null) {             throw new NullPointerException();           }           ensurePropsIsMutable();           props_.set(index, value);           onChanged();         } else {           propsBuilder_.setMessage(index, value);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder setProps(           int index, Pair.Builder builderForValue) {         if (propsBuilder_ == null) {           ensurePropsIsMutable();           props_.set(index, builderForValue.build());           onChanged();         } else {           propsBuilder_.setMessage(index, builderForValue.build());         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder addProps(Pair value) {         if (propsBuilder_ == null) {           if (value == null) {             throw new NullPointerException();           }           ensurePropsIsMutable();           props_.add(value);           onChanged();         } else {           propsBuilder_.addMessage(value);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder addProps(           int index, Pair value) {         if (propsBuilder_ == null) {           if (value == null) {             throw new NullPointerException();           }           ensurePropsIsMutable();           props_.add(index, value);           onChanged();         } else {           propsBuilder_.addMessage(index, value);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder addProps(           Pair.Builder builderForValue) {         if (propsBuilder_ == null) {           ensurePropsIsMutable();           props_.add(builderForValue.build());           onChanged();         } else {           propsBuilder_.addMessage(builderForValue.build());         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder addProps(           int index, Pair.Builder builderForValue) {         if (propsBuilder_ == null) {           ensurePropsIsMutable();           props_.add(index, builderForValue.build());           onChanged();         } else {           propsBuilder_.addMessage(index, builderForValue.build());         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder addAllProps(           Iterable values) {         if (propsBuilder_ == null) {           ensurePropsIsMutable();           com.google.protobuf.AbstractMessageLite.Builder.addAll(               values, props_);           onChanged();         } else {           propsBuilder_.addAllMessages(values);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder clearProps() {         if (propsBuilder_ == null) {           props_ = java.util.Collections.emptyList();           bitField0_ = (bitField0_ &amp; ~0x00000020);           onChanged();         } else {           propsBuilder_.clear();         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder removeProps(int index) {         if (propsBuilder_ == null) {           ensurePropsIsMutable();           props_.remove(index);           onChanged();         } else {           propsBuilder_.remove(index);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Pair.Builder getPropsBuilder(           int index) {         return getPropsFieldBuilder().getBuilder(index);       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public PairOrBuilder getPropsOrBuilder(           int index) {         if (propsBuilder_ == null) {           return props_.get(index);  } else {           return propsBuilder_.getMessageOrBuilder(index);         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public java.util.List            getPropsOrBuilderList() {         if (propsBuilder_ != null) {           return propsBuilder_.getMessageOrBuilderList();         } else {           return java.util.Collections.unmodifiableList(props_);         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Pair.Builder addPropsBuilder() {         return getPropsFieldBuilder().addBuilder(             Pair.getDefaultInstance());       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Pair.Builder addPropsBuilder(           int index) {         return getPropsFieldBuilder().addBuilder(             index, Pair.getDefaultInstance());       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public java.util.List            getPropsBuilderList() {         return getPropsFieldBuilder().getBuilderList();       }       private com.google.protobuf.RepeatedFieldBuilder&lt;           Pair, Pair.Builder, PairOrBuilder&gt;           getPropsFieldBuilder() {         if (propsBuilder_ == null) {           propsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder&lt;               Pair, Pair.Builder, PairOrBuilder&gt;(                   props_,                   ((bitField0_ &amp; 0x00000020) == 0x00000020),                   getParentForChildren(),                   isClean());           props_ = null;         }         return propsBuilder_;       }        private Object ddlSchemaName_ = &quot;&quot;;       /**        * optional string ddlSchemaName = 14;        *        *         ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *        *         */       public boolean hasDdlSchemaName() {         return ((bitField0_ &amp; 0x00000040) == 0x00000040);       }       /**        * optional string ddlSchemaName = 14;        *        *         ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *        *         */       public String getDdlSchemaName() {         Object ref = ddlSchemaName_;         if (!(ref instanceof String)) {           com.google.protobuf.ByteString bs =               (com.google.protobuf.ByteString) ref;           String s = bs.toStringUtf8();           if (bs.isValidUtf8()) {             ddlSchemaName_ = s;           }           return s;         } else {           return (String) ref;         }       }       /**        * optional string ddlSchemaName = 14;        *        *         ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *        *         */       public com.google.protobuf.ByteString           getDdlSchemaNameBytes() {         Object ref = ddlSchemaName_;         if (ref instanceof String) {           com.google.protobuf.ByteString b =               com.google.protobuf.ByteString.copyFromUtf8(                   (String) ref);           ddlSchemaName_ = b;           return b;         } else {           return (com.google.protobuf.ByteString) ref;         }       }       /**        * optional string ddlSchemaName = 14;        *        *         ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *        *         */       public Builder setDdlSchemaName(           String value) {         if (value == null) {     throw new NullPointerException();   }   bitField0_ |= 0x00000040;         ddlSchemaName_ = value;         onChanged();         return this;       }       /**        * optional string ddlSchemaName = 14;        *        *         ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *        *         */       public Builder clearDdlSchemaName() {         bitField0_ = (bitField0_ &amp; ~0x00000040);         ddlSchemaName_ = getDefaultInstance().getDdlSchemaName();         onChanged();         return this;       }       /**        * optional string ddlSchemaName = 14;        *        *         ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *        *         */       public Builder setDdlSchemaNameBytes(           com.google.protobuf.ByteString value) {         if (value == null) {     throw new NullPointerException();   }   bitField0_ |= 0x00000040;         ddlSchemaName_ = value;         onChanged();         return this;       }        // @@protoc_insertion_point(builder_scope:com.alibaba.otter.canal.protocol.RowChange)     }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13584</td>
    <td align="left">https://github.com/alibaba/canal/blob/08167c95c767fd3c9879584c0230820a8476a7a7/protocol/src/main/java/com/alibaba/otter/canal/protocol/CanalEntry.java/#L8477-L9689</td>
    <td align="right">1</td>
    <td align="right">2230</td>
    <td align="right">13584</td>
  </tr>
  <tr valign="top">
    <td align="right">1257</td>
    <td align="left">&nbsp;&nbsp;YES I found bad smells the bad smells are: 1. Long class, 2. Data class, 3. Feature envy </td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;faces-config-propertyType&quot;, propOrder = {     &quot;descriptions&quot;,     &quot;displayNames&quot;,     &quot;icon&quot;,     &quot;propertyName&quot;,     &quot;propertyClass&quot;,     &quot;defaultValue&quot;,     &quot;suggestedValue&quot;,     &quot;propertyExtension&quot; }) public class FacesProperty {      @XmlTransient     protected TextMap description = new TextMap();     @XmlTransient     protected TextMap displayName = new TextMap();     @XmlElement(name = &quot;icon&quot;, required = true)     protected LocalCollection icon = new LocalCollection();     @XmlElement(name = &quot;property-name&quot;, required = true)     protected java.lang.String propertyName;     @XmlElement(name = &quot;property-class&quot;, required = true)     protected java.lang.String propertyClass;     @XmlElement(name = &quot;default-value&quot;)     protected java.lang.String defaultValue;     @XmlElement(name = &quot;suggested-value&quot;)     protected java.lang.String suggestedValue;     @XmlElement(name = &quot;property-extension&quot;)     protected List propertyExtension;     @XmlAttribute     @XmlJavaTypeAdapter(CollapsedStringAdapter.class)     @XmlID     @XmlSchemaType(name = &quot;ID&quot;)     protected java.lang.String id;      @XmlElement(name = &quot;description&quot;, required = true)     public Text[] getDescriptions() {         return description.toArray();     }      public void setDescriptions(Text[] text) {         description.set(text);     }      public String getDescription() {         return description.get();     }      @XmlElement(name = &quot;display-name&quot;, required = true)     public Text[] getDisplayNames() {         return displayName.toArray();     }      public void setDisplayNames(Text[] text) {         displayName.set(text);     }      public String getDisplayName() {         return displayName.get();     }      public Collection getIcons() {         if (icon == null) {             icon = new LocalCollection();         }         return icon;     }      public Map getIconMap() {         if (icon == null) {             icon = new LocalCollection();         }         return icon.toMap();     }      public Icon getIcon() {         return icon.getLocal();     }      /**      * Gets the value of the propertyName property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getPropertyName() {         return propertyName;     }      /**      * Sets the value of the propertyName property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setPropertyName(java.lang.String value) {         this.propertyName = value;     }      /**      * Gets the value of the propertyClass property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getPropertyClass() {         return propertyClass;     }      /**      * Sets the value of the propertyClass property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setPropertyClass(java.lang.String value) {         this.propertyClass = value;     }      /**      * Gets the value of the defaultValue property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getDefaultValue() {         return defaultValue;     }      /**      * Sets the value of the defaultValue property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setDefaultValue(java.lang.String value) {         this.defaultValue = value;     }      /**      * Gets the value of the suggestedValue property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getSuggestedValue() {         return suggestedValue;     }      /**      * Sets the value of the suggestedValue property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setSuggestedValue(java.lang.String value) {         this.suggestedValue = value;     }      /**      * Gets the value of the propertyExtension property.      *       *       * This accessor method returns a reference to the live list,      * not a snapshot. Therefore any modification you make to the      * returned list will be present inside the JAXB object.      * This is why there is not a set method for the propertyExtension property.      *       *       * For example, to add a new item, do as follows:      *       *    getPropertyExtension().add(newItem);      *       *       *       *       * Objects of the following type(s) are allowed in the list      * {@link FacesPropertyExtension }      *       *       */     public List getPropertyExtension() {         if (propertyExtension == null) {             propertyExtension = new ArrayList();         }         return this.propertyExtension;     }      /**      * Gets the value of the id property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getId() {         return id;     }      /**      * Sets the value of the id property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setId(java.lang.String value) {         this.id = value;     }  }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long class, 2 Data class, 3 Feature envy </td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">. Long class,  3. Feature envy </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10498</td>
    <td align="left">https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/container/openejb-jee/src/main/java/org/apache/openejb/jee/FacesProperty.java/#L70-L298</td>
    <td align="right">2</td>
    <td align="right">1257</td>
    <td align="right">10498</td>
  </tr>
  <tr valign="top">
    <td align="right">2201</td>
    <td align="left">&nbsp;{     &quot;answer&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: {         &quot;the bad smells are&quot;: [             &quot;Data Class&quot;         ]     } }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
 		protected int height; 		protected int width;  		public ImageSource( int width, int height ) 		{ 			this.width = width; 			this.height = height; 		}  		public int getHeight( ) 		{ 			return height; 		}  		public int getWidth( ) 		{ 			return width; 		}  		public abstract int getRGB( int x, int y ); 	}  	public class ArrayImageSource extends ImageSource</td>
    <td align="left">data class</td>
    <td align="left">the bad smells are: data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13502</td>
    <td align="left">https://github.com/eclipse/birt/blob/f89264810347de98702db45386a822aabc0fadbf/engine/org.eclipse.birt.report.engine.emitter.postscript/src/org/eclipse/birt/report/engine/emitter/postscript/PostscriptWriter.java/#L1340-L1363</td>
    <td align="right">1</td>
    <td align="right">2201</td>
    <td align="right">13502</td>
  </tr>
  <tr valign="top">
    <td align="right">834</td>
    <td align="left">&nbsp;LFOAbstractType  YES I found bad smells the bad smells are: 1. Long method 2. Data class 3. Low cohesion 4. Repeating code  5. Primitive obsession  6.Freeloader class  7.Feature envy  8. Inappropriate visibility modifier  9. Inconsistent naming convention  10. Magic numbers</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
@Internal public abstract class LFOAbstractType {      protected int field_1_lsid;     protected int field_2_unused1;     protected int field_3_unused2;     protected byte field_4_clfolvl;     protected byte field_5_ibstFltAutoNum;     protected Grfhic field_6_grfhic;     protected byte field_7_unused3;      protected LFOAbstractType()     {         this.field_6_grfhic = new Grfhic();     }      protected void fillFields( byte[] data, int offset )     {         field_1_lsid                   = LittleEndian.getInt( data, 0x0 + offset );         field_2_unused1                = LittleEndian.getInt( data, 0x4 + offset );         field_3_unused2                = LittleEndian.getInt( data, 0x8 + offset );         field_4_clfolvl                = data[ 0xc + offset ];         field_5_ibstFltAutoNum         = data[ 0xd + offset ];         field_6_grfhic                 = new Grfhic( data, 0xe + offset );         field_7_unused3                = data[ 0xf + offset ];     }      public void serialize( byte[] data, int offset )     {         LittleEndian.putInt( data, 0x0 + offset, field_1_lsid );         LittleEndian.putInt( data, 0x4 + offset, field_2_unused1 );         LittleEndian.putInt( data, 0x8 + offset, field_3_unused2 );         data[ 0xc + offset ] = field_4_clfolvl;         data[ 0xd + offset ] = field_5_ibstFltAutoNum;         field_6_grfhic.serialize( data, 0xe + offset );         data[ 0xf + offset ] = field_7_unused3;     }      public byte[] serialize()     {         final byte[] result = new byte[ getSize() ];         serialize( result, 0 );         return result;     }      /**      * Size of record      */     public static int getSize()     {         return 0 + 4 + 4 + 4 + 1 + 1 + 1 + 1;     }      @Override     public boolean equals( Object obj )     {         if ( this == obj )             return true;         if ( obj == null )             return false;         if ( getClass() != obj.getClass() )             return false;         LFOAbstractType other = (LFOAbstractType) obj;         if ( field_1_lsid != other.field_1_lsid )             return false;         if ( field_2_unused1 != other.field_2_unused1 )             return false;         if ( field_3_unused2 != other.field_3_unused2 )             return false;         if ( field_4_clfolvl != other.field_4_clfolvl )             return false;         if ( field_5_ibstFltAutoNum != other.field_5_ibstFltAutoNum )             return false;         if ( field_6_grfhic == null )         {             if ( other.field_6_grfhic != null )                 return false;         }         else if ( !field_6_grfhic.equals( other.field_6_grfhic ) )             return false;         if ( field_7_unused3 != other.field_7_unused3 )             return false;         return true;     }      @Override     public int hashCode()     {         final int prime = 31;         int result = 1;         result = prime * result + field_1_lsid;         result = prime * result + field_2_unused1;         result = prime * result + field_3_unused2;         result = prime * result + field_4_clfolvl;         result = prime * result + field_5_ibstFltAutoNum;         result = prime * result                 + ((field_6_grfhic == null) ? 0 : field_6_grfhic.hashCode());         result = prime * result + field_7_unused3;         return result;     }      public String toString()     {         StringBuilder builder = new StringBuilder();          builder.append(&quot;[LFO]\n&quot;);         builder.append( &quot;    .lsid                 = &quot; );         builder.append(&quot; ( &quot;).append( field_1_lsid ).append( &quot; )\n&quot; );         builder.append( &quot;    .unused1              = &quot; );         builder.append(&quot; ( &quot;).append( field_2_unused1 ).append( &quot; )\n&quot; );         builder.append( &quot;    .unused2              = &quot; );         builder.append(&quot; ( &quot;).append( field_3_unused2 ).append( &quot; )\n&quot; );         builder.append( &quot;    .clfolvl              = &quot; );         builder.append(&quot; ( &quot;).append( field_4_clfolvl ).append( &quot; )\n&quot; );         builder.append( &quot;    .ibstFltAutoNum       = &quot; );         builder.append(&quot; ( &quot;).append( field_5_ibstFltAutoNum ).append( &quot; )\n&quot; );         builder.append( &quot;    .grfhic               = &quot; );         builder.append(&quot; ( &quot;).append( field_6_grfhic == null ? &quot;null&quot; : field_6_grfhic.toString().replaceAll( &quot;\n&quot;, &quot;\n    &quot; ) ).append( &quot; )\n&quot; );         builder.append( &quot;    .unused3              = &quot; );         builder.append(&quot; ( &quot;).append( field_7_unused3 ).append( &quot; )\n&quot; );          builder.append(&quot;[/LFO]&quot;);         return builder.toString();     }      /**      * A signed integer that specifies the list identifier of an LSTF. This LFO corresponds to the LSTF in PlfLst.rgLstf that has an lsid whose value is equal to this value..      */     @Internal     public int getLsid()     {         return field_1_lsid;     }      /**      * A signed integer that specifies the list identifier of an LSTF. This LFO corresponds to the LSTF in PlfLst.rgLstf that has an lsid whose value is equal to this value..      */     @Internal     public void setLsid( int field_1_lsid )     {         this.field_1_lsid = field_1_lsid;     }      /**      * This field MUST be ignored.      */     @Internal     public int getUnused1()     {         return field_2_unused1;     }      /**      * This field MUST be ignored.      */     @Internal     public void setUnused1( int field_2_unused1 )     {         this.field_2_unused1 = field_2_unused1;     }      /**      * This field MUST be ignored.      */     @Internal     public int getUnused2()     {         return field_3_unused2;     }      /**      * This field MUST be ignored.      */     @Internal     public void setUnused2( int field_3_unused2 )     {         this.field_3_unused2 = field_3_unused2;     }      /**      * An unsigned integer that specifies the field that this LFO represents..      */     @Internal     public byte getClfolvl()     {         return field_4_clfolvl;     }      /**      * An unsigned integer that specifies the field that this LFO represents..      */     @Internal     public void setClfolvl( byte field_4_clfolvl )     {         this.field_4_clfolvl = field_4_clfolvl;     }      /**      * Used for AUTONUM field emulation.      */     @Internal     public byte getIbstFltAutoNum()     {         return field_5_ibstFltAutoNum;     }      /**      * Used for AUTONUM field emulation.      */     @Internal     public void setIbstFltAutoNum( byte field_5_ibstFltAutoNum )     {         this.field_5_ibstFltAutoNum = field_5_ibstFltAutoNum;     }      /**      * HTML compatibility flags.      */     @Internal     public Grfhic getGrfhic()     {         return field_6_grfhic;     }      /**      * HTML compatibility flags.      */     @Internal     public void setGrfhic( Grfhic field_6_grfhic )     {         this.field_6_grfhic = field_6_grfhic;     }      /**      * This field MUST be ignored.      */     @Internal     public byte getUnused3()     {         return field_7_unused3;     }      /**      * This field MUST be ignored.      */     @Internal     public void setUnused3( byte field_7_unused3 )     {         this.field_7_unused3 = field_7_unused3;     }  }  // END OF CLASS</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method2 Data class3 Low cohesion4 Repeating code 5 Primitive obsession 6Freeloader class 7Feature envy 8 Inappropriate visibility modifier 9 Inconsistent naming convention </td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7749</td>
    <td align="left">https://github.com/apache/poi/blob/351623a86924dab9c565e08e8cecfe151522c448/src/scratchpad/src/org/apache/poi/hwpf/model/types/LFOAbstractType.java/#L38-L290</td>
    <td align="right">2</td>
    <td align="right">834</td>
    <td align="right">7749</td>
  </tr>
  <tr valign="top">
    <td align="right">326</td>
    <td align="left">{      &quot;output&quot;: &quot;YES I found bad smells. The bad smells are: 1. Data Class&quot;  }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class BuildProperties extends AbstractProperties {      public BuildProperties(PropertiesAccessor accessor) {         super(accessor);     }      public Map getAllProps() {         return accessor.getBuildProperties();     }  }</td>
    <td align="left">data class</td>
    <td align="left">1. data class  </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3376</td>
    <td align="left">https://github.com/apache/asterixdb/blob/223d13a06c4a4a58408aeac19674ac1f36f5ff35/asterixdb/asterix-common/src/main/java/org/apache/asterix/common/config/BuildProperties.java/#L24-L34</td>
    <td align="right">1</td>
    <td align="right">326</td>
    <td align="right">3376</td>
  </tr>
  <tr valign="top">
    <td align="right">1811</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Deprecated public class TransactionRecord {     // Commit Log Offset     private long offset;     private String producerGroup;      public long getOffset() {         return offset;     }      public void setOffset(long offset) {         this.offset = offset;     }      public String getProducerGroup() {         return producerGroup;     }      public void setProducerGroup(String producerGroup) {         this.producerGroup = producerGroup;     } }</td>
    <td align="left">data class</td>
    <td align="left">Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12061</td>
    <td align="left">https://github.com/apache/rocketmq/blob/971fa8ed8b209b39bdfe41c57cd64576d244e6bd/broker/src/main/java/org/apache/rocketmq/broker/transaction/TransactionRecord.java/#L22-L43</td>
    <td align="right">1</td>
    <td align="right">1811</td>
    <td align="right">12061</td>
  </tr>
  <tr valign="top">
    <td align="right">706</td>
    <td align="left">&nbsp;&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells the bad smells are: 1. Data Class&quot; }  </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class MessageTransfer extends Method {      public static final int TYPE = 1025;     private int _bodySize;      @Override     public final int getStructType() {         return TYPE;     }      @Override     public final int getSizeWidth() {         return 0;     }      @Override     public final int getPackWidth() {         return 2;     }      @Override     public final boolean hasPayload() {         return true;     }      @Override     public final byte getEncodedTrack() {         return Frame.L4;     }      @Override     public final boolean isConnectionControl()     {         return false;     }      private short packing_flags = 0;     private String destination;     private MessageAcceptMode acceptMode;     private MessageAcquireMode acquireMode;     private Header header;     private QpidByteBuffer _body;       public MessageTransfer() {}      public MessageTransfer(String destination, MessageAcceptMode acceptMode, MessageAcquireMode acquireMode, Header header, java.nio.ByteBuffer body, Option ... options)     {         this(destination,              acceptMode,              acquireMode,              header,              QpidByteBuffer.wrap(body),              options);     }      public MessageTransfer(String destination, MessageAcceptMode acceptMode, MessageAcquireMode acquireMode, Header header, QpidByteBuffer body, Option ... _options) {         if(destination != null) {             setDestination(destination);         }         if(acceptMode != null) {             setAcceptMode(acceptMode);         }         if(acquireMode != null) {             setAcquireMode(acquireMode);         }         setHeader(header);         setBody(body);          for (int i=0; i &lt; _options.length; i++) {             switch (_options[i]) {             case SYNC: this.setSync(true); break;             case BATCH: this.setBatch(true); break;             case UNRELIABLE: this.setUnreliable(true); break;             case NONE: break;             default: throw new IllegalArgumentException(&quot;invalid option: &quot; + _options[i]);             }         }      }      @Override     public  void dispatch(C context, MethodDelegate delegate) {         delegate.messageTransfer(context, this);     }       public final boolean hasDestination() {         return (packing_flags &amp; 256) != 0;     }      public final MessageTransfer clearDestination() {         packing_flags &amp;= ~256;         this.destination = null;         setDirty(true);         return this;     }      public final String getDestination() {         return destination;     }      public final MessageTransfer setDestination(String value) {         this.destination = value;         packing_flags |= 256;         setDirty(true);         return this;     }      public final MessageTransfer destination(String value) {         return setDestination(value);     }      public final boolean hasAcceptMode() {         return (packing_flags &amp; 512) != 0;     }      public final MessageTransfer clearAcceptMode() {         packing_flags &amp;= ~512;         this.acceptMode = null;         setDirty(true);         return this;     }      public final MessageAcceptMode getAcceptMode() {         return acceptMode;     }      public final MessageTransfer setAcceptMode(MessageAcceptMode value) {         this.acceptMode = value;         packing_flags |= 512;         setDirty(true);         return this;     }      public final MessageTransfer acceptMode(MessageAcceptMode value) {         return setAcceptMode(value);     }      public final boolean hasAcquireMode() {         return (packing_flags &amp; 1024) != 0;     }      public final MessageTransfer clearAcquireMode() {         packing_flags &amp;= ~1024;         this.acquireMode = null;         setDirty(true);         return this;     }      public final MessageAcquireMode getAcquireMode() {         return acquireMode;     }      public final MessageTransfer setAcquireMode(MessageAcquireMode value) {         this.acquireMode = value;         packing_flags |= 1024;         setDirty(true);         return this;     }      public final MessageTransfer acquireMode(MessageAcquireMode value) {         return setAcquireMode(value);     }       @Override     public final Header getHeader() {         return this.header;     }      @Override     public final void setHeader(Header header) {         this.header = header;     }      public final MessageTransfer header(Header header)     {         setHeader(header);         return this;     }      @Override     public final QpidByteBuffer getBody()     {         return _body;     }      @Override     public final void setBody(QpidByteBuffer body)     {         if (body == null)         {             _bodySize = 0;             if (_body != null)             {                 _body.dispose();             }             _body = null;         }         else         {             _body = body.duplicate();             _bodySize = _body.remaining();         }     }      @Override     public int getBodySize()     {         return _bodySize;     }      @Override     public void write(Encoder enc)     {         enc.writeUint16(packing_flags);         if ((packing_flags &amp; 256) != 0)         {             enc.writeStr8(this.destination);         }         if ((packing_flags &amp; 512) != 0)         {             enc.writeUint8(this.acceptMode.getValue());         }         if ((packing_flags &amp; 1024) != 0)         {             enc.writeUint8(this.acquireMode.getValue());         }      }      @Override     public void read(Decoder dec)     {         packing_flags = (short) dec.readUint16();         if ((packing_flags &amp; 256) != 0)         {             this.destination = dec.readStr8();         }         if ((packing_flags &amp; 512) != 0)         {             this.acceptMode = MessageAcceptMode.get(dec.readUint8());         }         if ((packing_flags &amp; 1024) != 0)         {             this.acquireMode = MessageAcquireMode.get(dec.readUint8());         }      }      @Override     public Map getFields()     {         Map result = new LinkedHashMap();          if ((packing_flags &amp; 256) != 0)         {             result.put(&quot;destination&quot;, getDestination());         }         if ((packing_flags &amp; 512) != 0)         {             result.put(&quot;acceptMode&quot;, getAcceptMode());         }         if ((packing_flags &amp; 1024) != 0)         {             result.put(&quot;acquireMode&quot;, getAcquireMode());         }           return result;     }      public void dispose()     {         if (_body != null)         {             _body.dispose();             _body = null;         }     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class   </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6735</td>
    <td align="left">https://github.com/apache/qpid-broker-j/blob/4c4400b98a5a8493cfb9e5dbb21c97175f433a62/broker-plugins/amqp-0-10-protocol/src/main/java/org/apache/qpid/server/protocol/v0_10/transport/MessageTransfer.java/#L31-L312</td>
    <td align="right">1</td>
    <td align="right">706</td>
    <td align="right">6735</td>
  </tr>
  <tr valign="top">
    <td align="right">1706</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;the bad smells are&quot;: [             &quot;Data Class&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Targeting extends APINode {   @SerializedName(&quot;adgroup_id&quot;)   private String mAdgroupId = null;   @SerializedName(&quot;age_max&quot;)   private Long mAgeMax = null;   @SerializedName(&quot;age_min&quot;)   private Long mAgeMin = null;   @SerializedName(&quot;alternate_auto_targeting_option&quot;)   private String mAlternateAutoTargetingOption = null;   @SerializedName(&quot;app_install_state&quot;)   private String mAppInstallState = null;   @SerializedName(&quot;audience_network_positions&quot;)   private List mAudienceNetworkPositions = null;   @SerializedName(&quot;behaviors&quot;)   private List mBehaviors = null;   @SerializedName(&quot;brand_safety_content_filter_levels&quot;)   private List mBrandSafetyContentFilterLevels = null;   @SerializedName(&quot;brand_safety_content_severity_levels&quot;)   private List mBrandSafetyContentSeverityLevels = null;   @SerializedName(&quot;catalog_based_targeting&quot;)   private CatalogBasedTargeting mCatalogBasedTargeting = null;   @SerializedName(&quot;cities&quot;)   private List mCities = null;   @SerializedName(&quot;college_years&quot;)   private List mCollegeYears = null;   @SerializedName(&quot;connections&quot;)   private List mConnections = null;   @SerializedName(&quot;contextual_targeting_categories&quot;)   private List mContextualTargetingCategories = null;   @SerializedName(&quot;countries&quot;)   private List mCountries = null;   @SerializedName(&quot;country&quot;)   private List mCountry = null;   @SerializedName(&quot;country_groups&quot;)   private List mCountryGroups = null;   @SerializedName(&quot;custom_audiences&quot;)   private List mCustomAudiences = null;   @SerializedName(&quot;device_platforms&quot;)   private List mDevicePlatforms = null;   @SerializedName(&quot;direct_install_devices&quot;)   private Boolean mDirectInstallDevices = null;   @SerializedName(&quot;dynamic_audience_ids&quot;)   private List mDynamicAudienceIds = null;   @SerializedName(&quot;education_majors&quot;)   private List mEducationMajors = null;   @SerializedName(&quot;education_schools&quot;)   private List mEducationSchools = null;   @SerializedName(&quot;education_statuses&quot;)   private List mEducationStatuses = null;   @SerializedName(&quot;effective_audience_network_positions&quot;)   private List mEffectiveAudienceNetworkPositions = null;   @SerializedName(&quot;effective_device_platforms&quot;)   private List mEffectiveDevicePlatforms = null;   @SerializedName(&quot;effective_facebook_positions&quot;)   private List mEffectiveFacebookPositions = null;   @SerializedName(&quot;effective_instagram_positions&quot;)   private List mEffectiveInstagramPositions = null;   @SerializedName(&quot;effective_messenger_positions&quot;)   private List mEffectiveMessengerPositions = null;   @SerializedName(&quot;effective_publisher_platforms&quot;)   private List mEffectivePublisherPlatforms = null;   @SerializedName(&quot;engagement_specs&quot;)   private List mEngagementSpecs = null;   @SerializedName(&quot;ethnic_affinity&quot;)   private List mEthnicAffinity = null;   @SerializedName(&quot;exclude_reached_since&quot;)   private List mExcludeReachedSince = null;   @SerializedName(&quot;excluded_connections&quot;)   private List mExcludedConnections = null;   @SerializedName(&quot;excluded_custom_audiences&quot;)   private List mExcludedCustomAudiences = null;   @SerializedName(&quot;excluded_dynamic_audience_ids&quot;)   private List mExcludedDynamicAudienceIds = null;   @SerializedName(&quot;excluded_engagement_specs&quot;)   private List mExcludedEngagementSpecs = null;   @SerializedName(&quot;excluded_geo_locations&quot;)   private TargetingGeoLocation mExcludedGeoLocations = null;   @SerializedName(&quot;excluded_mobile_device_model&quot;)   private List mExcludedMobileDeviceModel = null;   @SerializedName(&quot;excluded_product_audience_specs&quot;)   private List mExcludedProductAudienceSpecs = null;   @SerializedName(&quot;excluded_publisher_categories&quot;)   private List mExcludedPublisherCategories = null;   @SerializedName(&quot;excluded_publisher_list_ids&quot;)   private List mExcludedPublisherListIds = null;   @SerializedName(&quot;excluded_user_device&quot;)   private List mExcludedUserDevice = null;   @SerializedName(&quot;exclusions&quot;)   private FlexibleTargeting mExclusions = null;   @SerializedName(&quot;facebook_positions&quot;)   private List mFacebookPositions = null;   @SerializedName(&quot;family_statuses&quot;)   private List mFamilyStatuses = null;   @SerializedName(&quot;fb_deal_id&quot;)   private String mFbDealId = null;   @SerializedName(&quot;flexible_spec&quot;)   private List mFlexibleSpec = null;   @SerializedName(&quot;friends_of_connections&quot;)   private List mFriendsOfConnections = null;   @SerializedName(&quot;genders&quot;)   private List mGenders = null;   @SerializedName(&quot;generation&quot;)   private List mGeneration = null;   @SerializedName(&quot;geo_locations&quot;)   private TargetingGeoLocation mGeoLocations = null;   @SerializedName(&quot;home_ownership&quot;)   private List mHomeOwnership = null;   @SerializedName(&quot;home_type&quot;)   private List mHomeType = null;   @SerializedName(&quot;home_value&quot;)   private List mHomeValue = null;   @SerializedName(&quot;household_composition&quot;)   private List mHouseholdComposition = null;   @SerializedName(&quot;income&quot;)   private List mIncome = null;   @SerializedName(&quot;industries&quot;)   private List mIndustries = null;   @SerializedName(&quot;instagram_positions&quot;)   private List mInstagramPositions = null;   @SerializedName(&quot;instream_video_sponsorship_placements&quot;)   private List mInstreamVideoSponsorshipPlacements = null;   @SerializedName(&quot;interested_in&quot;)   private List mInterestedIn = null;   @SerializedName(&quot;interests&quot;)   private List mInterests = null;   @SerializedName(&quot;is_whatsapp_destination_ad&quot;)   private Boolean mIsWhatsappDestinationAd = null;   @SerializedName(&quot;keywords&quot;)   private List mKeywords = null;   @SerializedName(&quot;life_events&quot;)   private List mLifeEvents = null;   @SerializedName(&quot;locales&quot;)   private List mLocales = null;   @SerializedName(&quot;messenger_positions&quot;)   private List mMessengerPositions = null;   @SerializedName(&quot;moms&quot;)   private List mMoms = null;   @SerializedName(&quot;net_worth&quot;)   private List mNetWorth = null;   @SerializedName(&quot;office_type&quot;)   private List mOfficeType = null;   @SerializedName(&quot;place_page_set_ids&quot;)   private List mPlacePageSetIds = null;   @SerializedName(&quot;political_views&quot;)   private List mPoliticalViews = null;   @SerializedName(&quot;politics&quot;)   private List mPolitics = null;   @SerializedName(&quot;product_audience_specs&quot;)   private List mProductAudienceSpecs = null;   @SerializedName(&quot;prospecting_audience&quot;)   private TargetingProspectingAudience mProspectingAudience = null;   @SerializedName(&quot;publisher_platforms&quot;)   private List mPublisherPlatforms = null;   @SerializedName(&quot;publisher_visibility_categories&quot;)   private List mPublisherVisibilityCategories = null;   @SerializedName(&quot;radius&quot;)   private String mRadius = null;   @SerializedName(&quot;regions&quot;)   private List mRegions = null;   @SerializedName(&quot;relationship_statuses&quot;)   private List mRelationshipStatuses = null;   @SerializedName(&quot;site_category&quot;)   private List mSiteCategory = null;   @SerializedName(&quot;targeting_optimization&quot;)   private String mTargetingOptimization = null;   @SerializedName(&quot;user_adclusters&quot;)   private List mUserAdclusters = null;   @SerializedName(&quot;user_device&quot;)   private List mUserDevice = null;   @SerializedName(&quot;user_event&quot;)   private List mUserEvent = null;   @SerializedName(&quot;user_os&quot;)   private List mUserOs = null;   @SerializedName(&quot;wireless_carrier&quot;)   private List mWirelessCarrier = null;   @SerializedName(&quot;work_employers&quot;)   private List mWorkEmployers = null;   @SerializedName(&quot;work_positions&quot;)   private List mWorkPositions = null;   @SerializedName(&quot;zips&quot;)   private List mZips = null;   protected static Gson gson = null;    public Targeting() {   }    public String getId() {     return null;   }   public static Targeting loadJSON(String json, APIContext context, String header) {     Targeting targeting = getGson().fromJson(json, Targeting.class);     if (context.isDebug()) {       JsonParser parser = new JsonParser();       JsonElement o1 = parser.parse(json);       JsonElement o2 = parser.parse(targeting.toString());       if (o1.getAsJsonObject().get(&quot;__fb_trace_id__&quot;) != null) {         o2.getAsJsonObject().add(&quot;__fb_trace_id__&quot;, o1.getAsJsonObject().get(&quot;__fb_trace_id__&quot;));       }       if (!o1.equals(o2)) {         context.log(&quot;[Warning] When parsing response, object is not consistent with JSON:&quot;);         context.log(&quot;[JSON]&quot; + o1);         context.log(&quot;[Object]&quot; + o2);       };     }     targeting.context = context;     targeting.rawValue = json;     targeting.header = header;     return targeting;   }    public static APINodeList parseResponse(String json, APIContext context, APIRequest request, String header) throws MalformedResponseException {     APINodeList targetings = new APINodeList(request, json, header);     JsonArray arr;     JsonObject obj;     JsonParser parser = new JsonParser();     Exception exception = null;     try{       JsonElement result = parser.parse(json);       if (result.isJsonArray()) {         // First, check if it's a pure JSON Array         arr = result.getAsJsonArray();         for (int i = 0; i &lt; arr.size(); i++) {           targetings.add(loadJSON(arr.get(i).getAsJsonObject().toString(), context, header));         };         return targetings;       } else if (result.isJsonObject()) {         obj = result.getAsJsonObject();         if (obj.has(&quot;data&quot;)) {           if (obj.has(&quot;paging&quot;)) {             JsonObject paging = obj.get(&quot;paging&quot;).getAsJsonObject();             if (paging.has(&quot;cursors&quot;)) {                 JsonObject cursors = paging.get(&quot;cursors&quot;).getAsJsonObject();                 String before = cursors.has(&quot;before&quot;) ? cursors.get(&quot;before&quot;).getAsString() : null;                 String after = cursors.has(&quot;after&quot;) ? cursors.get(&quot;after&quot;).getAsString() : null;                 targetings.setCursors(before, after);             }             String previous = paging.has(&quot;previous&quot;) ? paging.get(&quot;previous&quot;).getAsString() : null;             String next = paging.has(&quot;next&quot;) ? paging.get(&quot;next&quot;).getAsString() : null;             targetings.setPaging(previous, next);             if (context.hasAppSecret()) {               targetings.setAppSecret(context.getAppSecretProof());             }           }           if (obj.get(&quot;data&quot;).isJsonArray()) {             // Second, check if it's a JSON array with &quot;data&quot;             arr = obj.get(&quot;data&quot;).getAsJsonArray();             for (int i = 0; i &lt; arr.size(); i++) {               targetings.add(loadJSON(arr.get(i).getAsJsonObject().toString(), context, header));             };           } else if (obj.get(&quot;data&quot;).isJsonObject()) {             // Third, check if it's a JSON object with &quot;data&quot;             obj = obj.get(&quot;data&quot;).getAsJsonObject();             boolean isRedownload = false;             for (String s : new String[]{&quot;campaigns&quot;, &quot;adsets&quot;, &quot;ads&quot;}) {               if (obj.has(s)) {                 isRedownload = true;                 obj = obj.getAsJsonObject(s);                 for (Map.Entry entry : obj.entrySet()) {                   targetings.add(loadJSON(entry.getValue().toString(), context, header));                 }                 break;               }             }             if (!isRedownload) {               targetings.add(loadJSON(obj.toString(), context, header));             }           }           return targetings;         } else if (obj.has(&quot;images&quot;)) {           // Fourth, check if it's a map of image objects           obj = obj.get(&quot;images&quot;).getAsJsonObject();           for (Map.Entry entry : obj.entrySet()) {               targetings.add(loadJSON(entry.getValue().toString(), context, header));           }           return targetings;         } else {           // Fifth, check if it's an array of objects indexed by id           boolean isIdIndexedArray = true;           for (Map.Entry entry : obj.entrySet()) {             String key = (String) entry.getKey();             if (key.equals(&quot;__fb_trace_id__&quot;)) {               continue;             }             JsonElement value = (JsonElement) entry.getValue();             if (               value != null &amp;&amp;               value.isJsonObject() &amp;&amp;               value.getAsJsonObject().has(&quot;id&quot;) &amp;&amp;               value.getAsJsonObject().get(&quot;id&quot;) != null &amp;&amp;               value.getAsJsonObject().get(&quot;id&quot;).getAsString().equals(key)             ) {               targetings.add(loadJSON(value.toString(), context, header));             } else {               isIdIndexedArray = false;               break;             }           }           if (isIdIndexedArray) {             return targetings;           }            // Sixth, check if it's pure JsonObject           targetings.clear();           targetings.add(loadJSON(json, context, header));           return targetings;         }       }     } catch (Exception e) {       exception = e;     }     throw new MalformedResponseException(       &quot;Invalid response string: &quot; + json,       exception     );   }    @Override   public APIContext getContext() {     return context;   }    @Override   public void setContext(APIContext context) {     this.context = context;   }    @Override   public String toString() {     return getGson().toJson(this);   }     public String getFieldAdgroupId() {     return mAdgroupId;   }    public Targeting setFieldAdgroupId(String value) {     this.mAdgroupId = value;     return this;   }    public Long getFieldAgeMax() {     return mAgeMax;   }    public Targeting setFieldAgeMax(Long value) {     this.mAgeMax = value;     return this;   }    public Long getFieldAgeMin() {     return mAgeMin;   }    public Targeting setFieldAgeMin(Long value) {     this.mAgeMin = value;     return this;   }    public String getFieldAlternateAutoTargetingOption() {     return mAlternateAutoTargetingOption;   }    public Targeting setFieldAlternateAutoTargetingOption(String value) {     this.mAlternateAutoTargetingOption = value;     return this;   }    public String getFieldAppInstallState() {     return mAppInstallState;   }    public Targeting setFieldAppInstallState(String value) {     this.mAppInstallState = value;     return this;   }    public List getFieldAudienceNetworkPositions() {     return mAudienceNetworkPositions;   }    public Targeting setFieldAudienceNetworkPositions(List value) {     this.mAudienceNetworkPositions = value;     return this;   }    public List getFieldBehaviors() {     return mBehaviors;   }    public Targeting setFieldBehaviors(List value) {     this.mBehaviors = value;     return this;   }    public Targeting setFieldBehaviors(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mBehaviors = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldBrandSafetyContentFilterLevels() {     return mBrandSafetyContentFilterLevels;   }    public Targeting setFieldBrandSafetyContentFilterLevels(List value) {     this.mBrandSafetyContentFilterLevels = value;     return this;   }    public List getFieldBrandSafetyContentSeverityLevels() {     return mBrandSafetyContentSeverityLevels;   }    public Targeting setFieldBrandSafetyContentSeverityLevels(List value) {     this.mBrandSafetyContentSeverityLevels = value;     return this;   }    public CatalogBasedTargeting getFieldCatalogBasedTargeting() {     return mCatalogBasedTargeting;   }    public Targeting setFieldCatalogBasedTargeting(CatalogBasedTargeting value) {     this.mCatalogBasedTargeting = value;     return this;   }    public Targeting setFieldCatalogBasedTargeting(String value) {     Type type = new TypeToken(){}.getType();     this.mCatalogBasedTargeting = CatalogBasedTargeting.getGson().fromJson(value, type);     return this;   }   public List getFieldCities() {     return mCities;   }    public Targeting setFieldCities(List value) {     this.mCities = value;     return this;   }    public Targeting setFieldCities(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mCities = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldCollegeYears() {     return mCollegeYears;   }    public Targeting setFieldCollegeYears(List value) {     this.mCollegeYears = value;     return this;   }    public List getFieldConnections() {     return mConnections;   }    public Targeting setFieldConnections(List value) {     this.mConnections = value;     return this;   }    public Targeting setFieldConnections(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mConnections = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldContextualTargetingCategories() {     return mContextualTargetingCategories;   }    public Targeting setFieldContextualTargetingCategories(List value) {     this.mContextualTargetingCategories = value;     return this;   }    public Targeting setFieldContextualTargetingCategories(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mContextualTargetingCategories = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldCountries() {     return mCountries;   }    public Targeting setFieldCountries(List value) {     this.mCountries = value;     return this;   }    public List getFieldCountry() {     return mCountry;   }    public Targeting setFieldCountry(List value) {     this.mCountry = value;     return this;   }    public List getFieldCountryGroups() {     return mCountryGroups;   }    public Targeting setFieldCountryGroups(List value) {     this.mCountryGroups = value;     return this;   }    public List getFieldCustomAudiences() {     return mCustomAudiences;   }    public Targeting setFieldCustomAudiences(List value) {     this.mCustomAudiences = value;     return this;   }    public Targeting setFieldCustomAudiences(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mCustomAudiences = RawCustomAudience.getGson().fromJson(value, type);     return this;   }   public List getFieldDevicePlatforms() {     return mDevicePlatforms;   }    public Targeting setFieldDevicePlatforms(List value) {     this.mDevicePlatforms = value;     return this;   }    public Boolean getFieldDirectInstallDevices() {     return mDirectInstallDevices;   }    public Targeting setFieldDirectInstallDevices(Boolean value) {     this.mDirectInstallDevices = value;     return this;   }    public List getFieldDynamicAudienceIds() {     return mDynamicAudienceIds;   }    public Targeting setFieldDynamicAudienceIds(List value) {     this.mDynamicAudienceIds = value;     return this;   }    public List getFieldEducationMajors() {     return mEducationMajors;   }    public Targeting setFieldEducationMajors(List value) {     this.mEducationMajors = value;     return this;   }    public Targeting setFieldEducationMajors(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mEducationMajors = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldEducationSchools() {     return mEducationSchools;   }    public Targeting setFieldEducationSchools(List value) {     this.mEducationSchools = value;     return this;   }    public Targeting setFieldEducationSchools(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mEducationSchools = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldEducationStatuses() {     return mEducationStatuses;   }    public Targeting setFieldEducationStatuses(List value) {     this.mEducationStatuses = value;     return this;   }    public List getFieldEffectiveAudienceNetworkPositions() {     return mEffectiveAudienceNetworkPositions;   }    public Targeting setFieldEffectiveAudienceNetworkPositions(List value) {     this.mEffectiveAudienceNetworkPositions = value;     return this;   }    public List getFieldEffectiveDevicePlatforms() {     return mEffectiveDevicePlatforms;   }    public Targeting setFieldEffectiveDevicePlatforms(List value) {     this.mEffectiveDevicePlatforms = value;     return this;   }    public List getFieldEffectiveFacebookPositions() {     return mEffectiveFacebookPositions;   }    public Targeting setFieldEffectiveFacebookPositions(List value) {     this.mEffectiveFacebookPositions = value;     return this;   }    public List getFieldEffectiveInstagramPositions() {     return mEffectiveInstagramPositions;   }    public Targeting setFieldEffectiveInstagramPositions(List value) {     this.mEffectiveInstagramPositions = value;     return this;   }    public List getFieldEffectiveMessengerPositions() {     return mEffectiveMessengerPositions;   }    public Targeting setFieldEffectiveMessengerPositions(List value) {     this.mEffectiveMessengerPositions = value;     return this;   }    public List getFieldEffectivePublisherPlatforms() {     return mEffectivePublisherPlatforms;   }    public Targeting setFieldEffectivePublisherPlatforms(List value) {     this.mEffectivePublisherPlatforms = value;     return this;   }    public List getFieldEngagementSpecs() {     return mEngagementSpecs;   }    public Targeting setFieldEngagementSpecs(List value) {     this.mEngagementSpecs = value;     return this;   }    public Targeting setFieldEngagementSpecs(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mEngagementSpecs = TargetingDynamicRule.getGson().fromJson(value, type);     return this;   }   public List getFieldEthnicAffinity() {     return mEthnicAffinity;   }    public Targeting setFieldEthnicAffinity(List value) {     this.mEthnicAffinity = value;     return this;   }    public Targeting setFieldEthnicAffinity(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mEthnicAffinity = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldExcludeReachedSince() {     return mExcludeReachedSince;   }    public Targeting setFieldExcludeReachedSince(List value) {     this.mExcludeReachedSince = value;     return this;   }    public List getFieldExcludedConnections() {     return mExcludedConnections;   }    public Targeting setFieldExcludedConnections(List value) {     this.mExcludedConnections = value;     return this;   }    public Targeting setFieldExcludedConnections(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mExcludedConnections = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldExcludedCustomAudiences() {     return mExcludedCustomAudiences;   }    public Targeting setFieldExcludedCustomAudiences(List value) {     this.mExcludedCustomAudiences = value;     return this;   }    public Targeting setFieldExcludedCustomAudiences(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mExcludedCustomAudiences = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldExcludedDynamicAudienceIds() {     return mExcludedDynamicAudienceIds;   }    public Targeting setFieldExcludedDynamicAudienceIds(List value) {     this.mExcludedDynamicAudienceIds = value;     return this;   }    public List getFieldExcludedEngagementSpecs() {     return mExcludedEngagementSpecs;   }    public Targeting setFieldExcludedEngagementSpecs(List value) {     this.mExcludedEngagementSpecs = value;     return this;   }    public Targeting setFieldExcludedEngagementSpecs(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mExcludedEngagementSpecs = TargetingDynamicRule.getGson().fromJson(value, type);     return this;   }   public TargetingGeoLocation getFieldExcludedGeoLocations() {     return mExcludedGeoLocations;   }    public Targeting setFieldExcludedGeoLocations(TargetingGeoLocation value) {     this.mExcludedGeoLocations = value;     return this;   }    public Targeting setFieldExcludedGeoLocations(String value) {     Type type = new TypeToken(){}.getType();     this.mExcludedGeoLocations = TargetingGeoLocation.getGson().fromJson(value, type);     return this;   }   public List getFieldExcludedMobileDeviceModel() {     return mExcludedMobileDeviceModel;   }    public Targeting setFieldExcludedMobileDeviceModel(List value) {     this.mExcludedMobileDeviceModel = value;     return this;   }    public List getFieldExcludedProductAudienceSpecs() {     return mExcludedProductAudienceSpecs;   }    public Targeting setFieldExcludedProductAudienceSpecs(List value) {     this.mExcludedProductAudienceSpecs = value;     return this;   }    public Targeting setFieldExcludedProductAudienceSpecs(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mExcludedProductAudienceSpecs = TargetingProductAudienceSpec.getGson().fromJson(value, type);     return this;   }   public List getFieldExcludedPublisherCategories() {     return mExcludedPublisherCategories;   }    public Targeting setFieldExcludedPublisherCategories(List value) {     this.mExcludedPublisherCategories = value;     return this;   }    public List getFieldExcludedPublisherListIds() {     return mExcludedPublisherListIds;   }    public Targeting setFieldExcludedPublisherListIds(List value) {     this.mExcludedPublisherListIds = value;     return this;   }    public List getFieldExcludedUserDevice() {     return mExcludedUserDevice;   }    public Targeting setFieldExcludedUserDevice(List value) {     this.mExcludedUserDevice = value;     return this;   }    public FlexibleTargeting getFieldExclusions() {     return mExclusions;   }    public Targeting setFieldExclusions(FlexibleTargeting value) {     this.mExclusions = value;     return this;   }    public Targeting setFieldExclusions(String value) {     Type type = new TypeToken(){}.getType();     this.mExclusions = FlexibleTargeting.getGson().fromJson(value, type);     return this;   }   public List getFieldFacebookPositions() {     return mFacebookPositions;   }    public Targeting setFieldFacebookPositions(List value) {     this.mFacebookPositions = value;     return this;   }    public List getFieldFamilyStatuses() {     return mFamilyStatuses;   }    public Targeting setFieldFamilyStatuses(List value) {     this.mFamilyStatuses = value;     return this;   }    public Targeting setFieldFamilyStatuses(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mFamilyStatuses = IDName.getGson().fromJson(value, type);     return this;   }   public String getFieldFbDealId() {     return mFbDealId;   }    public Targeting setFieldFbDealId(String value) {     this.mFbDealId = value;     return this;   }    public List getFieldFlexibleSpec() {     return mFlexibleSpec;   }    public Targeting setFieldFlexibleSpec(List value) {     this.mFlexibleSpec = value;     return this;   }    public Targeting setFieldFlexibleSpec(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mFlexibleSpec = FlexibleTargeting.getGson().fromJson(value, type);     return this;   }   public List getFieldFriendsOfConnections() {     return mFriendsOfConnections;   }    public Targeting setFieldFriendsOfConnections(List value) {     this.mFriendsOfConnections = value;     return this;   }    public Targeting setFieldFriendsOfConnections(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mFriendsOfConnections = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldGenders() {     return mGenders;   }    public Targeting setFieldGenders(List value) {     this.mGenders = value;     return this;   }    public List getFieldGeneration() {     return mGeneration;   }    public Targeting setFieldGeneration(List value) {     this.mGeneration = value;     return this;   }    public Targeting setFieldGeneration(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mGeneration = IDName.getGson().fromJson(value, type);     return this;   }   public TargetingGeoLocation getFieldGeoLocations() {     return mGeoLocations;   }    public Targeting setFieldGeoLocations(TargetingGeoLocation value) {     this.mGeoLocations = value;     return this;   }    public Targeting setFieldGeoLocations(String value) {     Type type = new TypeToken(){}.getType();     this.mGeoLocations = TargetingGeoLocation.getGson().fromJson(value, type);     return this;   }   public List getFieldHomeOwnership() {     return mHomeOwnership;   }    public Targeting setFieldHomeOwnership(List value) {     this.mHomeOwnership = value;     return this;   }    public Targeting setFieldHomeOwnership(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mHomeOwnership = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldHomeType() {     return mHomeType;   }    public Targeting setFieldHomeType(List value) {     this.mHomeType = value;     return this;   }    public Targeting setFieldHomeType(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mHomeType = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldHomeValue() {     return mHomeValue;   }    public Targeting setFieldHomeValue(List value) {     this.mHomeValue = value;     return this;   }    public Targeting setFieldHomeValue(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mHomeValue = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldHouseholdComposition() {     return mHouseholdComposition;   }    public Targeting setFieldHouseholdComposition(List value) {     this.mHouseholdComposition = value;     return this;   }    public Targeting setFieldHouseholdComposition(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mHouseholdComposition = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldIncome() {     return mIncome;   }    public Targeting setFieldIncome(List value) {     this.mIncome = value;     return this;   }    public Targeting setFieldIncome(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mIncome = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldIndustries() {     return mIndustries;   }    public Targeting setFieldIndustries(List value) {     this.mIndustries = value;     return this;   }    public Targeting setFieldIndustries(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mIndustries = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldInstagramPositions() {     return mInstagramPositions;   }    public Targeting setFieldInstagramPositions(List value) {     this.mInstagramPositions = value;     return this;   }    public List getFieldInstreamVideoSponsorshipPlacements() {     return mInstreamVideoSponsorshipPlacements;   }    public Targeting setFieldInstreamVideoSponsorshipPlacements(List value) {     this.mInstreamVideoSponsorshipPlacements = value;     return this;   }    public List getFieldInterestedIn() {     return mInterestedIn;   }    public Targeting setFieldInterestedIn(List value) {     this.mInterestedIn = value;     return this;   }    public List getFieldInterests() {     return mInterests;   }    public Targeting setFieldInterests(List value) {     this.mInterests = value;     return this;   }    public Targeting setFieldInterests(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mInterests = IDName.getGson().fromJson(value, type);     return this;   }   public Boolean getFieldIsWhatsappDestinationAd() {     return mIsWhatsappDestinationAd;   }    public Targeting setFieldIsWhatsappDestinationAd(Boolean value) {     this.mIsWhatsappDestinationAd = value;     return this;   }    public List getFieldKeywords() {     return mKeywords;   }    public Targeting setFieldKeywords(List value) {     this.mKeywords = value;     return this;   }    public List getFieldLifeEvents() {     return mLifeEvents;   }    public Targeting setFieldLifeEvents(List value) {     this.mLifeEvents = value;     return this;   }    public Targeting setFieldLifeEvents(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mLifeEvents = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldLocales() {     return mLocales;   }    public Targeting setFieldLocales(List value) {     this.mLocales = value;     return this;   }    public List getFieldMessengerPositions() {     return mMessengerPositions;   }    public Targeting setFieldMessengerPositions(List value) {     this.mMessengerPositions = value;     return this;   }    public List getFieldMoms() {     return mMoms;   }    public Targeting setFieldMoms(List value) {     this.mMoms = value;     return this;   }    public Targeting setFieldMoms(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mMoms = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldNetWorth() {     return mNetWorth;   }    public Targeting setFieldNetWorth(List value) {     this.mNetWorth = value;     return this;   }    public Targeting setFieldNetWorth(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mNetWorth = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldOfficeType() {     return mOfficeType;   }    public Targeting setFieldOfficeType(List value) {     this.mOfficeType = value;     return this;   }    public Targeting setFieldOfficeType(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mOfficeType = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldPlacePageSetIds() {     return mPlacePageSetIds;   }    public Targeting setFieldPlacePageSetIds(List value) {     this.mPlacePageSetIds = value;     return this;   }    public List getFieldPoliticalViews() {     return mPoliticalViews;   }    public Targeting setFieldPoliticalViews(List value) {     this.mPoliticalViews = value;     return this;   }    public List getFieldPolitics() {     return mPolitics;   }    public Targeting setFieldPolitics(List value) {     this.mPolitics = value;     return this;   }    public Targeting setFieldPolitics(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mPolitics = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldProductAudienceSpecs() {     return mProductAudienceSpecs;   }    public Targeting setFieldProductAudienceSpecs(List value) {     this.mProductAudienceSpecs = value;     return this;   }    public Targeting setFieldProductAudienceSpecs(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mProductAudienceSpecs = TargetingProductAudienceSpec.getGson().fromJson(value, type);     return this;   }   public TargetingProspectingAudience getFieldProspectingAudience() {     return mProspectingAudience;   }    public Targeting setFieldProspectingAudience(TargetingProspectingAudience value) {     this.mProspectingAudience = value;     return this;   }    public Targeting setFieldProspectingAudience(String value) {     Type type = new TypeToken(){}.getType();     this.mProspectingAudience = TargetingProspectingAudience.getGson().fromJson(value, type);     return this;   }   public List getFieldPublisherPlatforms() {     return mPublisherPlatforms;   }    public Targeting setFieldPublisherPlatforms(List value) {     this.mPublisherPlatforms = value;     return this;   }    public List getFieldPublisherVisibilityCategories() {     return mPublisherVisibilityCategories;   }    public Targeting setFieldPublisherVisibilityCategories(List value) {     this.mPublisherVisibilityCategories = value;     return this;   }    public String getFieldRadius() {     return mRadius;   }    public Targeting setFieldRadius(String value) {     this.mRadius = value;     return this;   }    public List getFieldRegions() {     return mRegions;   }    public Targeting setFieldRegions(List value) {     this.mRegions = value;     return this;   }    public Targeting setFieldRegions(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mRegions = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldRelationshipStatuses() {     return mRelationshipStatuses;   }    public Targeting setFieldRelationshipStatuses(List value) {     this.mRelationshipStatuses = value;     return this;   }    public List getFieldSiteCategory() {     return mSiteCategory;   }    public Targeting setFieldSiteCategory(List value) {     this.mSiteCategory = value;     return this;   }    public String getFieldTargetingOptimization() {     return mTargetingOptimization;   }    public Targeting setFieldTargetingOptimization(String value) {     this.mTargetingOptimization = value;     return this;   }    public List getFieldUserAdclusters() {     return mUserAdclusters;   }    public Targeting setFieldUserAdclusters(List value) {     this.mUserAdclusters = value;     return this;   }    public Targeting setFieldUserAdclusters(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mUserAdclusters = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldUserDevice() {     return mUserDevice;   }    public Targeting setFieldUserDevice(List value) {     this.mUserDevice = value;     return this;   }    public List getFieldUserEvent() {     return mUserEvent;   }    public Targeting setFieldUserEvent(List value) {     this.mUserEvent = value;     return this;   }    public List getFieldUserOs() {     return mUserOs;   }    public Targeting setFieldUserOs(List value) {     this.mUserOs = value;     return this;   }    public List getFieldWirelessCarrier() {     return mWirelessCarrier;   }    public Targeting setFieldWirelessCarrier(List value) {     this.mWirelessCarrier = value;     return this;   }    public List getFieldWorkEmployers() {     return mWorkEmployers;   }    public Targeting setFieldWorkEmployers(List value) {     this.mWorkEmployers = value;     return this;   }    public Targeting setFieldWorkEmployers(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mWorkEmployers = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldWorkPositions() {     return mWorkPositions;   }    public Targeting setFieldWorkPositions(List value) {     this.mWorkPositions = value;     return this;   }    public Targeting setFieldWorkPositions(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mWorkPositions = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldZips() {     return mZips;   }    public Targeting setFieldZips(List value) {     this.mZips = value;     return this;   }      public static enum EnumDevicePlatforms {       @SerializedName(&quot;connected_tv&quot;)       VALUE_CONNECTED_TV(&quot;connected_tv&quot;),       @SerializedName(&quot;desktop&quot;)       VALUE_DESKTOP(&quot;desktop&quot;),       @SerializedName(&quot;mobile&quot;)       VALUE_MOBILE(&quot;mobile&quot;),       NULL(null);        private String value;        private EnumDevicePlatforms(String value) {         this.value = value;       }        @Override       public String toString() {         return value;       }   }    public static enum EnumEffectiveDevicePlatforms {       @SerializedName(&quot;connected_tv&quot;)       VALUE_CONNECTED_TV(&quot;connected_tv&quot;),       @SerializedName(&quot;desktop&quot;)       VALUE_DESKTOP(&quot;desktop&quot;),       @SerializedName(&quot;mobile&quot;)       VALUE_MOBILE(&quot;mobile&quot;),       NULL(null);        private String value;        private EnumEffectiveDevicePlatforms(String value) {         this.value = value;       }        @Override       public String toString() {         return value;       }   }     synchronized /*package*/ static Gson getGson() {     if (gson != null) {       return gson;     } else {       gson = new GsonBuilder()         .excludeFieldsWithModifiers(Modifier.STATIC)         .excludeFieldsWithModifiers(Modifier.PROTECTED)         .disableHtmlEscaping()         .create();     }     return gson;   }    public Targeting copyFrom(Targeting instance) {     this.mAdgroupId = instance.mAdgroupId;     this.mAgeMax = instance.mAgeMax;     this.mAgeMin = instance.mAgeMin;     this.mAlternateAutoTargetingOption = instance.mAlternateAutoTargetingOption;     this.mAppInstallState = instance.mAppInstallState;     this.mAudienceNetworkPositions = instance.mAudienceNetworkPositions;     this.mBehaviors = instance.mBehaviors;     this.mBrandSafetyContentFilterLevels = instance.mBrandSafetyContentFilterLevels;     this.mBrandSafetyContentSeverityLevels = instance.mBrandSafetyContentSeverityLevels;     this.mCatalogBasedTargeting = instance.mCatalogBasedTargeting;     this.mCities = instance.mCities;     this.mCollegeYears = instance.mCollegeYears;     this.mConnections = instance.mConnections;     this.mContextualTargetingCategories = instance.mContextualTargetingCategories;     this.mCountries = instance.mCountries;     this.mCountry = instance.mCountry;     this.mCountryGroups = instance.mCountryGroups;     this.mCustomAudiences = instance.mCustomAudiences;     this.mDevicePlatforms = instance.mDevicePlatforms;     this.mDirectInstallDevices = instance.mDirectInstallDevices;     this.mDynamicAudienceIds = instance.mDynamicAudienceIds;     this.mEducationMajors = instance.mEducationMajors;     this.mEducationSchools = instance.mEducationSchools;     this.mEducationStatuses = instance.mEducationStatuses;     this.mEffectiveAudienceNetworkPositions = instance.mEffectiveAudienceNetworkPositions;     this.mEffectiveDevicePlatforms = instance.mEffectiveDevicePlatforms;     this.mEffectiveFacebookPositions = instance.mEffectiveFacebookPositions;     this.mEffectiveInstagramPositions = instance.mEffectiveInstagramPositions;     this.mEffectiveMessengerPositions = instance.mEffectiveMessengerPositions;     this.mEffectivePublisherPlatforms = instance.mEffectivePublisherPlatforms;     this.mEngagementSpecs = instance.mEngagementSpecs;     this.mEthnicAffinity = instance.mEthnicAffinity;     this.mExcludeReachedSince = instance.mExcludeReachedSince;     this.mExcludedConnections = instance.mExcludedConnections;     this.mExcludedCustomAudiences = instance.mExcludedCustomAudiences;     this.mExcludedDynamicAudienceIds = instance.mExcludedDynamicAudienceIds;     this.mExcludedEngagementSpecs = instance.mExcludedEngagementSpecs;     this.mExcludedGeoLocations = instance.mExcludedGeoLocations;     this.mExcludedMobileDeviceModel = instance.mExcludedMobileDeviceModel;     this.mExcludedProductAudienceSpecs = instance.mExcludedProductAudienceSpecs;     this.mExcludedPublisherCategories = instance.mExcludedPublisherCategories;     this.mExcludedPublisherListIds = instance.mExcludedPublisherListIds;     this.mExcludedUserDevice = instance.mExcludedUserDevice;     this.mExclusions = instance.mExclusions;     this.mFacebookPositions = instance.mFacebookPositions;     this.mFamilyStatuses = instance.mFamilyStatuses;     this.mFbDealId = instance.mFbDealId;     this.mFlexibleSpec = instance.mFlexibleSpec;     this.mFriendsOfConnections = instance.mFriendsOfConnections;     this.mGenders = instance.mGenders;     this.mGeneration = instance.mGeneration;     this.mGeoLocations = instance.mGeoLocations;     this.mHomeOwnership = instance.mHomeOwnership;     this.mHomeType = instance.mHomeType;     this.mHomeValue = instance.mHomeValue;     this.mHouseholdComposition = instance.mHouseholdComposition;     this.mIncome = instance.mIncome;     this.mIndustries = instance.mIndustries;     this.mInstagramPositions = instance.mInstagramPositions;     this.mInstreamVideoSponsorshipPlacements = instance.mInstreamVideoSponsorshipPlacements;     this.mInterestedIn = instance.mInterestedIn;     this.mInterests = instance.mInterests;     this.mIsWhatsappDestinationAd = instance.mIsWhatsappDestinationAd;     this.mKeywords = instance.mKeywords;     this.mLifeEvents = instance.mLifeEvents;     this.mLocales = instance.mLocales;     this.mMessengerPositions = instance.mMessengerPositions;     this.mMoms = instance.mMoms;     this.mNetWorth = instance.mNetWorth;     this.mOfficeType = instance.mOfficeType;     this.mPlacePageSetIds = instance.mPlacePageSetIds;     this.mPoliticalViews = instance.mPoliticalViews;     this.mPolitics = instance.mPolitics;     this.mProductAudienceSpecs = instance.mProductAudienceSpecs;     this.mProspectingAudience = instance.mProspectingAudience;     this.mPublisherPlatforms = instance.mPublisherPlatforms;     this.mPublisherVisibilityCategories = instance.mPublisherVisibilityCategories;     this.mRadius = instance.mRadius;     this.mRegions = instance.mRegions;     this.mRelationshipStatuses = instance.mRelationshipStatuses;     this.mSiteCategory = instance.mSiteCategory;     this.mTargetingOptimization = instance.mTargetingOptimization;     this.mUserAdclusters = instance.mUserAdclusters;     this.mUserDevice = instance.mUserDevice;     this.mUserEvent = instance.mUserEvent;     this.mUserOs = instance.mUserOs;     this.mWirelessCarrier = instance.mWirelessCarrier;     this.mWorkEmployers = instance.mWorkEmployers;     this.mWorkPositions = instance.mWorkPositions;     this.mZips = instance.mZips;     this.context = instance.context;     this.rawValue = instance.rawValue;     return this;   }    public static APIRequest.ResponseParser getParser() {     return new APIRequest.ResponseParser() {       public APINodeList parseResponse(String response, APIContext context, APIRequest request, String header) throws MalformedResponseException {         return Targeting.parseResponse(response, context, request, header);       }     };   } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11754</td>
    <td align="left">https://github.com/facebook/facebook-java-business-sdk/blob/561f1a75e1220b55a160a1b92b0187f72be9cd08/src/main/java/com/facebook/ads/sdk/Targeting.java/#L57-L1555</td>
    <td align="right">1</td>
    <td align="right">1706</td>
    <td align="right">11754</td>
  </tr>
  <tr valign="top">
    <td align="right">1995</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;bad_smells&quot;: [         &quot;1. Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Status {  	private StatusCode code; 	private String message; 	private String detail;  	public StatusCode getCode() { 		return code; 	}  	public Status setCode(StatusCode code) { 		this.code = code; 		return this; 	}  	public String getMessage() { 		return message; 	}  	public Status setMessage(String message) { 		this.message = message; 		return this; 	}  	public String getDetail() { 		return detail; 	}  	public Status setDetail(String detail) { 		this.detail = detail; 		return this; 	} }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">&nbsp; </td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">12696</td>
    <td align="left">https://github.com/spring-projects/spring-security-saml/blob/fa46190c8c37c2eb24b0fd424263c219ffe27e25/core/src/main/java/org/springframework/security/saml/saml2/authentication/Status.java/#L25-L57</td>
    <td align="right">1</td>
    <td align="right">1995</td>
    <td align="right">12696</td>
  </tr>
  <tr valign="top">
    <td align="right">987</td>
    <td align="left">&nbsp;{      &quot;output&quot;: &quot;YES I found bad smells&quot;,    &quot;bad smells are&quot;: [         &quot;Data Class&quot;    ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TeamContext {      /**     * The team project Id or name.  Ignored if ProjectId is set.     */     private String project;     /**     * The Team Project ID.  Required if Project is not set.     */     private UUID projectId;     /**     * The Team Id or name.  Ignored if TeamId is set.     */     private String team;     /**     * The Team Id     */     private UUID teamId;      /**     * The team project Id or name.  Ignored if ProjectId is set.     */     public String getProject() {         return project;     }      /**     * The team project Id or name.  Ignored if ProjectId is set.     */     public void setProject(final String project) {         this.project = project;     }      /**     * The Team Project ID.  Required if Project is not set.     */     public UUID getProjectId() {         return projectId;     }      /**     * The Team Project ID.  Required if Project is not set.     */     public void setProjectId(final UUID projectId) {         this.projectId = projectId;     }      /**     * The Team Id or name.  Ignored if TeamId is set.     */     public String getTeam() {         return team;     }      /**     * The Team Id or name.  Ignored if TeamId is set.     */     public void setTeam(final String team) {         this.team = team;     }      /**     * The Team Id     */     public UUID getTeamId() {         return teamId;     }      /**     * The Team Id     */     public void setTeamId(final UUID teamId) {         this.teamId = teamId;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8965</td>
    <td align="left">https://github.com/Microsoft/vso-httpclient-java/blob/7b6329238498d7ad1934243150f955bea594df37/Rest/alm-tfs-client/src/main/generated/com/microsoft/alm/teamfoundation/core/webapi/types/TeamContext.java/#L24-L98</td>
    <td align="right">1</td>
    <td align="right">987</td>
    <td align="right">8965</td>
  </tr>
  <tr valign="top">
    <td align="right">1447</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             &quot;Data Class&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class _ParameterFieldReference     extends _ParameterValueOrFieldReference     implements ElementSerializable, ElementDeserializable {     // No attributes          // Elements     protected String parameterName;     protected String fieldAlias;      public _ParameterFieldReference()     {         super();     }      public _ParameterFieldReference(         final String parameterName,         final String fieldAlias)     {         // TODO : Call super() instead of setting all fields directly?         setParameterName(parameterName);         setFieldAlias(fieldAlias);     }      public String getParameterName()     {         return this.parameterName;     }      public void setParameterName(String value)     {         this.parameterName = value;     }      public String getFieldAlias()     {         return this.fieldAlias;     }      public void setFieldAlias(String value)     {         this.fieldAlias = value;     }      public void writeAsElement(         final XMLStreamWriter writer,         final String name)         throws XMLStreamException     {         writer.writeStartElement(name);          // Declare our type         writer.writeAttribute(             &quot;xsi&quot;,             &quot;http://www.w3.org/2001/XMLSchema-instance&quot;,             &quot;type&quot;,             &quot;ParameterFieldReference&quot;);          // Elements         XMLStreamWriterHelper.writeElement(             writer,             &quot;ParameterName&quot;,             this.parameterName);         XMLStreamWriterHelper.writeElement(             writer,             &quot;FieldAlias&quot;,             this.fieldAlias);          writer.writeEndElement();     }      public void readFromElement(final XMLStreamReader reader)         throws XMLStreamException     {         String localName;          // This object uses no attributes          // Elements         int event;          do         {             event = reader.next();              if (event == XMLStreamConstants.START_ELEMENT)             {                 localName = reader.getLocalName();                  if (localName.equalsIgnoreCase(&quot;ParameterName&quot;))                 {                     this.parameterName = reader.getElementText();                 }                 else if (localName.equalsIgnoreCase(&quot;FieldAlias&quot;))                 {                     this.fieldAlias = reader.getElementText();                 }                 else                 {                     // Read the unknown child element until its end                     XMLStreamReaderHelper.readUntilElementEnd(reader);                 }             }         }         while (event != XMLStreamConstants.END_ELEMENT);     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10988</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core.ws/generated-src/ms/sql/reporting/reportingservices/_ParameterFieldReference.java/#L31-L137</td>
    <td align="right">1</td>
    <td align="right">1447</td>
    <td align="right">10988</td>
  </tr>
  <tr valign="top">
    <td align="right">2477</td>
    <td align="left">&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Long Method&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity @Table(name=&quot;xa_access_audit&quot;) public class AuthzAuditEventDbObj implements Serializable {  	private static final Log LOG = LogFactory.getLog(AuthzAuditEventDbObj.class);  	private static final long serialVersionUID = 1L;  	static int MaxValueLengthAccessType = 255; 	static int MaxValueLengthAclEnforcer = 255; 	static int MaxValueLengthAgentId = 255; 	static int MaxValueLengthClientIp = 255; 	static int MaxValueLengthClientType = 255; 	static int MaxValueLengthRepoName = 255; 	static int MaxValueLengthResultReason = 255; 	static int MaxValueLengthSessionId = 255; 	static int MaxValueLengthRequestUser = 255; 	static int MaxValueLengthAction = 2000; 	static int MaxValueLengthRequestData = 4000; 	static int MaxValueLengthResourcePath = 4000; 	static int MaxValueLengthResourceType = 255;  	private long   auditId; 	private int    repositoryType; 	private String repositoryName; 	private String user; 	private Date   timeStamp; 	private String accessType; 	private String resourcePath; 	private String resourceType; 	private String action; 	private int    accessResult; 	private String agentId; 	private long   policyId; 	private String resultReason; 	private String aclEnforcer; 	private String sessionId; 	private String clientType; 	private String clientIP; 	private String requestData; 	private long seqNum; 	private long eventCount; 	private long eventDurationMS; 	private String tags;  	public static void init(Properties props) 	{ 		LOG.info(&quot;AuthzAuditEventDbObj.init()&quot;);  		final String AUDIT_DB_MAX_COLUMN_VALUE = &quot;xasecure.audit.destination.db.max.column.length&quot;; 		MaxValueLengthAccessType = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;access_type&quot;, MaxValueLengthAccessType); 		logMaxColumnValue(&quot;access_type&quot;, MaxValueLengthAccessType);  		MaxValueLengthAclEnforcer = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;acl_enforcer&quot;, MaxValueLengthAclEnforcer); 		logMaxColumnValue(&quot;acl_enforcer&quot;, MaxValueLengthAclEnforcer);  		MaxValueLengthAction = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;action&quot;, MaxValueLengthAction); 		logMaxColumnValue(&quot;action&quot;, MaxValueLengthAction);  		MaxValueLengthAgentId = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;agent_id&quot;, MaxValueLengthAgentId); 		logMaxColumnValue(&quot;agent_id&quot;, MaxValueLengthAgentId);  		MaxValueLengthClientIp = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;client_id&quot;, MaxValueLengthClientIp); 		logMaxColumnValue(&quot;client_id&quot;, MaxValueLengthClientIp);  		MaxValueLengthClientType = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;client_type&quot;, MaxValueLengthClientType); 		logMaxColumnValue(&quot;client_type&quot;, MaxValueLengthClientType);  		MaxValueLengthRepoName = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;repo_name&quot;, MaxValueLengthRepoName); 		logMaxColumnValue(&quot;repo_name&quot;, MaxValueLengthRepoName);  		MaxValueLengthResultReason = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;result_reason&quot;, MaxValueLengthResultReason); 		logMaxColumnValue(&quot;result_reason&quot;, MaxValueLengthResultReason);  		MaxValueLengthSessionId = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;session_id&quot;, MaxValueLengthSessionId); 		logMaxColumnValue(&quot;session_id&quot;, MaxValueLengthSessionId);  		MaxValueLengthRequestUser = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;request_user&quot;, MaxValueLengthRequestUser); 		logMaxColumnValue(&quot;request_user&quot;, MaxValueLengthRequestUser);  		MaxValueLengthRequestData = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;request_data&quot;, MaxValueLengthRequestData); 		logMaxColumnValue(&quot;request_data&quot;, MaxValueLengthRequestData);  		MaxValueLengthResourcePath = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;resource_path&quot;, MaxValueLengthResourcePath); 		logMaxColumnValue(&quot;resource_path&quot;, MaxValueLengthResourcePath);  		MaxValueLengthResourceType = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;resource_type&quot;, MaxValueLengthResourceType); 		logMaxColumnValue(&quot;resource_type&quot;, MaxValueLengthResourceType); 	}  	public static void logMaxColumnValue(String columnName, int configuredMaxValueLength) { 		LOG.info(&quot;Setting max column value for column[&quot; + columnName + &quot;] to [&quot; + configuredMaxValueLength + &quot;].&quot;); 		if (configuredMaxValueLength == 0) { 			LOG.info(&quot;Max length of column[&quot; + columnName + &quot;] was 0! Column will NOT be emitted in the audit.&quot;); 		} else if (configuredMaxValueLength &lt; 0) { 			LOG.info(&quot;Max length of column[&quot; + columnName + &quot;] was less than 0! Column value will never be truncated.&quot;); 		} 	}   	public AuthzAuditEventDbObj() { 		super(); 	}  	public AuthzAuditEventDbObj(AuthzAuditEvent event) { 		super(); 		Date utcDate=null; 		if(event.getEventTime()!=null){ 			utcDate=MiscUtil.getUTCDateForLocalDate(event.getEventTime()); 		}else{ 			utcDate=MiscUtil.getUTCDate(); 		} 		this.repositoryType = event.getRepositoryType(); 		this.repositoryName = event.getRepositoryName(); 		this.user           = event.getUser(); 		this.timeStamp      = utcDate; 		this.accessType     = event.getAccessType(); 		this.resourcePath   = event.getResourcePath(); 		this.resourceType   = event.getResourceType(); 		this.action         = event.getAction(); 		this.accessResult   = event.getAccessResult(); 		this.agentId        = event.getAgentId(); 		this.policyId       = event.getPolicyId(); 		this.resultReason   = event.getResultReason(); 		this.aclEnforcer    = event.getAclEnforcer(); 		this.sessionId      = event.getSessionId(); 		this.clientType     = event.getClientType(); 		this.clientIP       = event.getClientIP(); 		this.requestData    = event.getRequestData(); 		this.seqNum         = event.getSeqNum(); 		this.eventCount     = event.getEventCount(); 		this.eventDurationMS= event.getEventDurationMS(); 		this.tags           = StringUtils.join(event.getTags(), &quot;, &quot;); 	}  	@Id 	@SequenceGenerator(name=&quot;XA_ACCESS_AUDIT_SEQ&quot;,sequenceName=&quot;XA_ACCESS_AUDIT_SEQ&quot;,allocationSize=1) 	@GeneratedValue(strategy=GenerationType.AUTO,generator=&quot;XA_ACCESS_AUDIT_SEQ&quot;) 	@Column(name = &quot;id&quot;, unique = true, nullable = false) 	public long getAuditId() { 		return this.auditId; 	}  	public void setAuditId(long auditId) { 		this.auditId = auditId; 	}  	@Column(name = &quot;repo_type&quot;) 	public int getRepositoryType() { 		return this.repositoryType; 	}  	public void setRepositoryType(int repositoryType) { 		this.repositoryType = repositoryType; 	}  	@Column(name = &quot;repo_name&quot;) 	public String getRepositoryName() { 		return truncate(this.repositoryName, MaxValueLengthRepoName, &quot;repo_name&quot;); 	}  	public void setRepositoryName(String repositoryName) { 		this.repositoryName = repositoryName; 	}  	@Column(name = &quot;request_user&quot;) 	public String getUser() { 		return truncate(this.user, MaxValueLengthRequestUser, &quot;request_user&quot;); 	}  	public void setUser(String user) { 		this.user = user; 	}  	@Temporal(TemporalType.TIMESTAMP) 	@Column(name = &quot;event_time&quot;) 	public Date getTimeStamp() { 		return this.timeStamp; 	}  	public void setTimeStamp(Date timeStamp) { 		this.timeStamp = timeStamp; 	}  	@Column(name = &quot;access_type&quot;) 	public String getAccessType() { 		return truncate(this.accessType, MaxValueLengthAccessType, &quot;access_type&quot;); 	}  	public void setAccessType(String accessType) { 		this.accessType = accessType; 	}  	@Column(name = &quot;resource_path&quot;) 	public String getResourcePath() { 		return truncate(this.resourcePath, MaxValueLengthResourcePath, &quot;resource_path&quot;); 	}  	public void setResourcePath(String resourcePath) { 		this.resourcePath = resourcePath; 	}  	@Column(name = &quot;resource_type&quot;) 	public String getResourceType() { 		return truncate(this.resourceType, MaxValueLengthResourceType, &quot;resource_type&quot;); 	}  	public void setResourceType(String resourceType) { 		this.resourceType = resourceType; 	}  	@Column(name = &quot;action&quot;) 	public String getAction() { 		return truncate(this.action, MaxValueLengthAction, &quot;action&quot;); 	}  	public void setAction(String action) { 		this.action = action; 	}  	@Column(name = &quot;access_result&quot;) 	public int getAccessResult() { 		return this.accessResult; 	}  	public void setAccessResult(int accessResult) { 		this.accessResult = accessResult; 	}  	@Column(name = &quot;agent_id&quot;) 	public String getAgentId() { 		return truncate(this.agentId, MaxValueLengthAgentId, &quot;agent_id&quot;); 	}  	public void setAgentId(String agentId) { 		this.agentId = agentId; 	}  	@Column(name = &quot;policy_id&quot;) 	public long getPolicyId() { 		return this.policyId; 	}  	public void setPolicyId(long policyId) { 		this.policyId = policyId; 	}  	@Column(name = &quot;result_reason&quot;) 	public String getResultReason() { 		return truncate(this.resultReason, MaxValueLengthResultReason, &quot;result_reason&quot;); 	}  	public void setResultReason(String resultReason) { 		this.resultReason = resultReason; 	}  	@Column(name = &quot;acl_enforcer&quot;) 	public String getAclEnforcer() { 		return truncate(this.aclEnforcer, MaxValueLengthAclEnforcer, &quot;acl_enforcer&quot;); 	}  	public void setAclEnforcer(String aclEnforcer) { 		this.aclEnforcer = aclEnforcer; 	}  	@Column(name = &quot;session_id&quot;) 	public String getSessionId() { 		return truncate(this.sessionId, MaxValueLengthSessionId, &quot;session_id&quot;); 	}  	public void setSessionId(String sessionId) { 		this.sessionId = sessionId; 	}  	@Column(name = &quot;client_type&quot;) 	public String getClientType() { 		return truncate(this.clientType, MaxValueLengthClientType, &quot;client_type&quot;); 	}  	public void setClientType(String clientType) { 		this.clientType = clientType; 	}  	@Column(name = &quot;client_ip&quot;) 	public String getClientIP() { 		return truncate(this.clientIP, MaxValueLengthClientIp, &quot;client_ip&quot;); 	}  	public void setClientIP(String clientIP) { 		this.clientIP = clientIP; 	}  	@Column(name = &quot;request_data&quot;) 	public String getRequestData() { 		return truncate(this.requestData, MaxValueLengthRequestData, &quot;request_data&quot;); 	}  	public void setRequestData(String requestData) { 		this.requestData = requestData; 	}  	@Column(name = &quot;seq_num&quot;) 	public long getSeqNum() { return this.seqNum; }  	public void setSeqNum(long seqNum) { this.seqNum = seqNum; }  	@Column(name = &quot;event_count&quot;) 	public long getEventCount() { return this.eventCount; }  	public void setEventCount(long eventCount) { this.eventCount = eventCount; }  	@Column(name = &quot;event_dur_ms&quot;) 	public long getEventDurationMS() { return this.eventDurationMS; }  	public void setEventDurationMS(long eventDurationMS) { this.eventDurationMS = eventDurationMS; }  	@Column(name = &quot;tags&quot;) 	public String getTags() { 		return this.tags; 	}  	public void setTags(String tags) { 		this.tags = tags; 	}  	static final String TruncationMarker = &quot;...&quot;; 	static final int TruncationMarkerLength = TruncationMarker.length();  	protected String truncate(String value, int limit, String columnName) { 		if (LOG.isDebugEnabled()) { 			LOG.debug(String.format(&quot;==&gt; getTrunctedValue(%s, %d, %s)&quot;, value, limit, columnName)); 		}  		String result = value; 		if (value != null) { 			if (limit &lt; 0) { 				if (LOG.isDebugEnabled()) { 					LOG.debug(String.format(&quot;Truncation is suppressed for column[%s]: old value [%s], new value[%s]&quot;, columnName, value, result)); 				} 			} else if (limit == 0) { 				if (LOG.isDebugEnabled()) { 					LOG.debug(String.format(&quot;Column[%s] is to be excluded from audit: old value [%s], new value[%s]&quot;, columnName, value, result)); 				} 				result = null; 			} else { 				if (value.length() &gt; limit) { 					if (limit &lt;= TruncationMarkerLength) { 						// NOTE: If value is to be truncated to a size that is less than of equal to the Truncation Marker then we won't put the marker in!! 						result = value.substring(0, limit); 					} else { 						StringBuilder sb = new StringBuilder(value.substring(0, limit - TruncationMarkerLength)); 						sb.append(TruncationMarker); 						result = sb.toString(); 					} 					if (LOG.isDebugEnabled()) { 						LOG.debug(String.format(&quot;Truncating value for column[%s] to [%d] characters: old value [%s], new value[%s]&quot;, columnName, limit, value, result)); 					} 				} 			} 		}  		if (LOG.isDebugEnabled()) { 			LOG.debug(String.format(&quot;&lt;== getTrunctedValue(%s, %d, %s): %s&quot;, value, limit, columnName, result)); 		} 		return result; 	} }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14589</td>
    <td align="left">https://github.com/apache/ranger/blob/7c52a79a5d0b41bfc94caca9d531e0fefba2bfe7/agents-audit/src/main/java/org/apache/ranger/audit/entity/AuthzAuditEventDbObj.java/#L46-L412</td>
    <td align="right">1</td>
    <td align="right">2477</td>
    <td align="right">14589</td>
  </tr>
  <tr valign="top">
    <td align="right">558</td>
    <td align="left">&nbsp;SequenceFileReader YES I found bad smells the bad smells are: 1. Long method 2. Feature envy 3. Duplicate code 4. Large class 5. Data class 6. Inconsistent levels of abstraction 7. Inappropriate intimacy</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
    private long prevRecordEndOffset;      public Offset(long lastSyncPoint, long recordsSinceLastSync, long currentRecord) {       this(lastSyncPoint, recordsSinceLastSync, currentRecord, 0, 0 );     }      public Offset(long lastSyncPoint, long recordsSinceLastSync, long currentRecord                   , long currRecordEndOffset, long prevRecordEndOffset) {       this.lastSyncPoint = lastSyncPoint;       this.recordsSinceLastSync = recordsSinceLastSync;       this.currentRecord = currentRecord;       this.prevRecordEndOffset = prevRecordEndOffset;       this.currRecordEndOffset = currRecordEndOffset;     }      public Offset(String offset) {       try {         if(offset==null) {           throw new IllegalArgumentException(&quot;offset cannot be null&quot;);         }         if(offset.equalsIgnoreCase(&quot;0&quot;)) {           this.lastSyncPoint = 0;           this.recordsSinceLastSync = 0;           this.currentRecord = 0;           this.prevRecordEndOffset = 0;           this.currRecordEndOffset = 0;         } else {           String[] parts = offset.split(&quot;:&quot;);           this.lastSyncPoint = Long.parseLong(parts[0].split(&quot;=&quot;)[1]);           this.recordsSinceLastSync = Long.parseLong(parts[1].split(&quot;=&quot;)[1]);           this.currentRecord = Long.parseLong(parts[2].split(&quot;=&quot;)[1]);           this.prevRecordEndOffset = 0;           this.currRecordEndOffset = 0;         }       } catch (Exception e) {         throw new IllegalArgumentException(&quot;'&quot; + offset +                 &quot;' cannot be interpreted. It is not in expected format for SequenceFileReader.&quot; +                 &quot; Format e.g. {sync=123:afterSync=345:record=67}&quot;);       }     }      @Override     public String toString() {       return '{' +               &quot;sync=&quot; + lastSyncPoint +               &quot;:afterSync=&quot; + recordsSinceLastSync +               &quot;:record=&quot; + currentRecord +               &quot;:}&quot;;     }      @Override     public boolean isNextOffset(FileOffset rhs) {       if(rhs instanceof Offset) {         Offset other = ((Offset) rhs);         return  other.currentRecord &gt; currentRecord+1;       }       return false;     }      @Override     public int compareTo(FileOffset o) {       Offset rhs = ((Offset) o);       if(currentRecord&gt;&gt; 32));     }          void increment(boolean syncSeen, long newBytePosition) {       if(!syncSeen) {         ++recordsSinceLastSync;       }  else {         recordsSinceLastSync = 1;         lastSyncPoint = prevRecordEndOffset;       }       ++currentRecord;       prevRecordEndOffset = currRecordEndOffset;       currentRecord = newBytePosition;     }      @Override     public Offset clone() {       return new Offset(lastSyncPoint, recordsSinceLastSync, currentRecord, currRecordEndOffset, prevRecordEndOffset);     }    } //class Offset } //class</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method2 Feature envy3 Duplicate code4 Large class5 Data class6 Inconsistent levels of abstraction7 Inappropriate intimacy</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5621</td>
    <td align="left">https://github.com/alibaba/jstorm/blob/5d6cde22dbca7df3d6e6830bf94f98a6639ab559/jstorm-hdfs/src/main/java/com/alibaba/jstorm/hdfs/spout/SequenceFileReader.java/#L104-L212</td>
    <td align="right">2</td>
    <td align="right">558</td>
    <td align="right">5621</td>
  </tr>
  <tr valign="top">
    <td align="right">2567</td>
    <td align="left">&nbsp;{    &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TfsGitTreeEntriesJson {     private final String objectId;     private final List treeEntries;     private final int size;      @JsonCreator     public TfsGitTreeEntriesJson(         @JsonProperty(&quot;objectId&quot;) final String objectId,         @JsonProperty(&quot;treeEntries&quot;) final List treeEntries,         @JsonProperty(&quot;size&quot;) final int size) throws JsonProcessingException {         this.objectId = objectId;         this.treeEntries = treeEntries;         this.size = size;     }      public String getObjectId() {         return objectId;     }      public List getTreeEntries() {         return treeEntries;     }      public int getSize() {         return size;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14871</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.client.common/src/com/microsoft/tfs/client/common/git/json/TfsGitTreeEntriesJson.java/#L12-L38</td>
    <td align="right">1</td>
    <td align="right">2567</td>
    <td align="right">14871</td>
  </tr>
  <tr valign="top">
    <td align="right">1223</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             {                 &quot;1&quot;: &quot;Data class&quot;             }         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class BasicBundleInfo {      private String pkgName;      /**      * The main dex depends on + the md5 that is currently dependent      */     private String unique_tag;      private String applicationName;      private String version;       public Boolean getIsMBundle() {         return isMBundle;     }      public void setIsMBundle(boolean mainBundle) {         isMBundle = mainBundle;     }      private Boolean isMBundle = false;      private List dependency = Lists.newArrayList();      private List activities = Lists.newArrayList();      private List services = Lists.newArrayList();      private List receivers = Lists.newArrayList();      private List contentProviders = Lists.newArrayList();      private HashMap remoteFragments= new HashMap();      private HashMap remoteViews = new HashMap();      private HashMap remoteTransactors = new HashMap();      private Boolean isInternal = true;      public HashMap getRemoteViews() {         return remoteViews;     }      public void setRemoteViews(HashMap remoteViews) {         this.remoteViews = remoteViews;     }      public HashMap getRemoteTransactors() {         return remoteTransactors;     }      public void setRemoteTransactors(HashMap remoteTransactors) {         this.remoteTransactors = remoteTransactors;     }      public HashMap getRemoteFragments() {         return remoteFragments;     }      public void setRemoteFragments(HashMap remoteFragments) {         this.remoteFragments = remoteFragments;     }      public String getPkgName() {         return pkgName;     }      public void setPkgName(String pkgName) {         this.pkgName = pkgName;     }      public String getApplicationName() {         return applicationName;     }      public void setApplicationName(String applicationName) {         this.applicationName = applicationName;     }      public String getVersion() {         return version;     }      public void setVersion(String version) {         this.version = version;     }      public List getDependency() {         return dependency;     }      public void setDependency(List dependency) {         this.dependency = dependency;     }      public List getActivities() {         return activities;     }      public void setActivities(List activities) {         this.activities = activities;     }      public List getServices() {         return services;     }      public void setServices(List services) {         this.services = services;     }      public List getReceivers() {         return receivers;     }      public void setReceivers(List receivers) {         this.receivers = receivers;     }      public List getContentProviders() {         return contentProviders;     }      public void setContentProviders(List contentProviders) {         this.contentProviders = contentProviders;     }      public boolean getIsInternal() {         return isInternal;     }      public void setIsInternal(boolean internal) {         isInternal = internal;     }      public String getUnique_tag() {         return unique_tag;     }      public void setUnique_tag(String unique_tag) {         this.unique_tag = unique_tag;     } }</td>
    <td align="left">data class</td>
    <td align="left">1: data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10340</td>
    <td align="left">https://github.com/alibaba/atlas/blob/e8c7b3f1ff14b2a1df64321c6992b796cae7d732/atlas-gradle-plugin/atlas-plugin/src/main/java/com/taobao/android/builder/tools/bundleinfo/model/BasicBundleInfo.java/#L220-L365</td>
    <td align="right">1</td>
    <td align="right">1223</td>
    <td align="right">10340</td>
  </tr>
  <tr valign="top">
    <td align="right">811</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @Immutable     private static final class NumberLiteralNode extends PrimitiveLiteralNode {         private static final long serialVersionUID = 1L;          private final Type type = numberGetType(value);          private NumberLiteralNode(final long token, final int finish, final Number value) {             super(Token.recast(token, TokenType.DECIMAL), finish, value);         }          private NumberLiteralNode(final NumberLiteralNode literalNode) {             super(literalNode);         }          private static Type numberGetType(final Number number) {             if (number instanceof Integer) {                 return Type.INT;             } else if (number instanceof Double) {                 return Type.NUMBER;             } else {                 assert false;             }              return null;         }          @Override         public Type getType() {             return type;         }          @Override         public Type getWidestOperationType() {             return getType();         }      }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7650</td>
    <td align="left">https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/ir/LiteralNode.java/#L373-L409</td>
    <td align="right">1</td>
    <td align="right">811</td>
    <td align="right">7650</td>
  </tr>
  <tr valign="top">
    <td align="right">1221</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class IntermediateModel {     private final Metadata metadata;      private final Map operations;      private final Map shapes;      private final CustomizationConfig customizationConfig;      private final ServiceExamples examples;      private final Map customAuthorizers;      @JsonIgnore     private final Optional endpointOperation;      @JsonIgnore     private final Map paginators;      @JsonIgnore     private final NamingStrategy namingStrategy;      @JsonCreator     public IntermediateModel(         @JsonProperty(&quot;metadata&quot;) Metadata metadata,         @JsonProperty(&quot;operations&quot;) Map operations,         @JsonProperty(&quot;shapes&quot;) Map shapes,         @JsonProperty(&quot;customizationConfig&quot;) CustomizationConfig customizationConfig,         @JsonProperty(&quot;serviceExamples&quot;) ServiceExamples examples) {          this(metadata, operations, shapes, customizationConfig, examples, null,              Collections.emptyMap(), Collections.emptyMap(), null);     }      public IntermediateModel(         Metadata metadata,         Map operations,         Map shapes,         CustomizationConfig customizationConfig,         ServiceExamples examples,         OperationModel endpointOperation,         Map customAuthorizers,         Map paginators,         NamingStrategy namingStrategy) {         this.metadata = metadata;         this.operations = operations;         this.shapes = shapes;         this.customizationConfig = customizationConfig;         this.examples = examples;         this.endpointOperation = Optional.ofNullable(endpointOperation);         this.customAuthorizers = customAuthorizers;         this.paginators = paginators;         this.namingStrategy = namingStrategy;     }      public Metadata getMetadata() {         return metadata;     }      public Map getOperations() {         return operations;     }      public OperationModel getOperation(String operationName) {         return getOperations().get(operationName);     }      public Map getShapes() {         return shapes;     }      public ShapeModel getShapeByC2jName(String c2jName) {         return Utils.findShapeModelByC2jName(this, c2jName);     }      public CustomizationConfig getCustomizationConfig() {         return customizationConfig;     }      public ServiceExamples getExamples() {         return examples;     }      public Map getPaginators() {         return paginators;     }      public NamingStrategy getNamingStrategy() {         return namingStrategy;     }      public String getCustomRetryPolicy() {         return customizationConfig.getCustomRetryPolicy();     }      public String getSdkModeledExceptionBaseFqcn() {         return String.format(&quot;%s.%s&quot;,                              metadata.getFullModelPackageName(),                              getSdkModeledExceptionBaseClassName());     }      public String getSdkModeledExceptionBaseClassName() {         if (customizationConfig.getSdkModeledExceptionBaseClassName() != null) {             return customizationConfig.getSdkModeledExceptionBaseClassName();         } else {             return metadata.getBaseExceptionName();         }     }      public String getSdkRequestBaseClassName() {         if (customizationConfig.getSdkRequestBaseClassName() != null) {             return customizationConfig.getSdkRequestBaseClassName();         } else {             return metadata.getBaseRequestName();         }     }      public String getSdkResponseBaseClassName() {         if (customizationConfig.getSdkResponseBaseClassName() != null) {             return customizationConfig.getSdkResponseBaseClassName();         } else {             return metadata.getBaseResponseName();         }     }      public String getFileHeader() throws IOException {         return loadDefaultFileHeader();     }      private String loadDefaultFileHeader() throws IOException {         try (InputStream inputStream = getClass()             .getResourceAsStream(&quot;/software/amazon/awssdk/codegen/DefaultFileHeader.txt&quot;)) {             return IoUtils.toUtf8String(inputStream)                           .replaceFirst(&quot;%COPYRIGHT_DATE_RANGE%&quot;, getCopyrightDateRange());         }     }      private String getCopyrightDateRange() {         int currentYear = ZonedDateTime.now().getYear();         int copyrightStartYear = currentYear - 5;         return String.format(&quot;%d-%d&quot;, copyrightStartYear, currentYear);     }      public String getSdkBaseResponseFqcn() {         if (metadata.getProtocol() == Protocol.API_GATEWAY) {             return &quot;software.amazon.awssdk.opensdk.BaseResult&quot;;         } else {             return String.format(&quot;%s&lt;%s&gt;&quot;,                                  AwsResponse.class.getName(),                                  getResponseMetadataClassName());         }     }      private String getResponseMetadataClassName() {         return AwsResponseMetadata.class.getName();     }      @JsonIgnore     public List simpleMethodsRequiringTesting() {         return getOperations().values().stream()                               .filter(v -&gt; v.getInputShape().isSimpleMethod())                               .collect(Collectors.toList());     }      public Map getCustomAuthorizers() {         return customAuthorizers;     }      public Optional getEndpointOperation() {         return endpointOperation;     }      public boolean hasPaginators() {         return paginators.size() &gt; 0;     }      public boolean containsRequestSigners() {         return getShapes().values().stream()                           .filter(ShapeModel::isRequestSignerAware)                           .findAny()                           .isPresent();     }      public boolean containsRequestEventStreams() {         return getOperations().values().stream()                               .filter(opModel -&gt; opModel.hasEventStreamInput())                               .findAny()                               .isPresent();     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10334</td>
    <td align="left">https://github.com/aws/aws-sdk-java-v2/blob/1d5d11e8087c93ab1a3a2d35193052e526fd123c/codegen/src/main/java/software/amazon/awssdk/codegen/model/intermediate/IntermediateModel.java/#L37-L226</td>
    <td align="right">1</td>
    <td align="right">1221</td>
    <td align="right">10334</td>
  </tr>
  <tr valign="top">
    <td align="right">2179</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DeploymentPlannersResponse extends BaseResponse {     @SerializedName(ApiConstants.NAME)     @Param(description = &quot;Deployment Planner name&quot;)     private String name;      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13412</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/api/src/main/java/org/apache/cloudstack/api/response/DeploymentPlannersResponse.java/#L26-L38</td>
    <td align="right">1</td>
    <td align="right">2179</td>
    <td align="right">13412</td>
  </tr>
  <tr valign="top">
    <td align="right">2141</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class APIRequestGet extends APIRequest {      AdCampaignActivity lastResponse = null;     @Override     public AdCampaignActivity getLastResponse() {       return lastResponse;     }     public static final String[] PARAMS = {     };      public static final String[] FIELDS = {       &quot;auto_create_lookalike_new&quot;,       &quot;auto_create_lookalike_old&quot;,       &quot;bid_adjustments_spec_new&quot;,       &quot;bid_adjustments_spec_old&quot;,       &quot;bid_amount_new&quot;,       &quot;bid_amount_old&quot;,       &quot;bid_constraints_new&quot;,       &quot;bid_constraints_old&quot;,       &quot;bid_info_new&quot;,       &quot;bid_info_old&quot;,       &quot;bid_strategy_new&quot;,       &quot;bid_strategy_old&quot;,       &quot;bid_type_new&quot;,       &quot;bid_type_old&quot;,       &quot;billing_event_new&quot;,       &quot;billing_event_old&quot;,       &quot;brande_audience_id_new&quot;,       &quot;brande_audience_id_old&quot;,       &quot;budget_limit_new&quot;,       &quot;budget_limit_old&quot;,       &quot;created_time&quot;,       &quot;daily_impressions_new&quot;,       &quot;daily_impressions_old&quot;,       &quot;dco_mode_new&quot;,       &quot;dco_mode_old&quot;,       &quot;delivery_behavior_new&quot;,       &quot;delivery_behavior_old&quot;,       &quot;destination_type_new&quot;,       &quot;destination_type_old&quot;,       &quot;event_time&quot;,       &quot;event_type&quot;,       &quot;id&quot;,       &quot;invoicing_limit_new&quot;,       &quot;invoicing_limit_old&quot;,       &quot;min_spend_target_new&quot;,       &quot;min_spend_target_old&quot;,       &quot;name_new&quot;,       &quot;name_old&quot;,       &quot;optimization_goal_new&quot;,       &quot;optimization_goal_old&quot;,       &quot;pacing_type_new&quot;,       &quot;pacing_type_old&quot;,       &quot;run_status_new&quot;,       &quot;run_status_old&quot;,       &quot;schedule_new&quot;,       &quot;schedule_old&quot;,       &quot;spend_cap_new&quot;,       &quot;spend_cap_old&quot;,       &quot;start_time_new&quot;,       &quot;start_time_old&quot;,       &quot;stop_time_new&quot;,       &quot;stop_time_old&quot;,       &quot;targeting_expansion_new&quot;,       &quot;targeting_expansion_old&quot;,       &quot;updated_time_new&quot;,       &quot;updated_time_old&quot;,     };      @Override     public AdCampaignActivity parseResponse(String response, String header) throws APIException {       return AdCampaignActivity.parseResponse(response, getContext(), this, header).head();     }      @Override     public AdCampaignActivity execute() throws APIException {       return execute(new HashMap());     }      @Override     public AdCampaignActivity execute(Map extraParams) throws APIException {       ResponseWrapper rw = executeInternal(extraParams);       lastResponse = parseResponse(rw.getBody(), rw.getHeader());       return lastResponse;     }      public ListenableFuture executeAsync() throws APIException {       return executeAsync(new HashMap());     };      public ListenableFuture executeAsync(Map extraParams) throws APIException {       return Futures.transform(         executeAsyncInternal(extraParams),         new Function() {            public AdCampaignActivity apply(ResponseWrapper result) {              try {                return APIRequestGet.this.parseResponse(result.getBody(), result.getHeader());              } catch (Exception e) {                throw new RuntimeException(e);              }            }          }       );     };      public APIRequestGet(String nodeId, APIContext context) {       super(context, nodeId, &quot;/&quot;, &quot;GET&quot;, Arrays.asList(PARAMS));     }      @Override     public APIRequestGet setParam(String param, Object value) {       setParamInternal(param, value);       return this;     }      @Override     public APIRequestGet setParams(Map params) {       setParamsInternal(params);       return this;     }       public APIRequestGet requestAllFields () {       return this.requestAllFields(true);     }      public APIRequestGet requestAllFields (boolean value) {       for (String field : FIELDS) {         this.requestField(field, value);       }       return this;     }      @Override     public APIRequestGet requestFields (List fields) {       return this.requestFields(fields, true);     }      @Override     public APIRequestGet requestFields (List fields, boolean value) {       for (String field : fields) {         this.requestField(field, value);       }       return this;     }      @Override     public APIRequestGet requestField (String field) {       this.requestField(field, true);       return this;     }      @Override     public APIRequestGet requestField (String field, boolean value) {       this.requestFieldInternal(field, value);       return this;     }      public APIRequestGet requestAutoCreateLookalikeNewField () {       return this.requestAutoCreateLookalikeNewField(true);     }     public APIRequestGet requestAutoCreateLookalikeNewField (boolean value) {       this.requestField(&quot;auto_create_lookalike_new&quot;, value);       return this;     }     public APIRequestGet requestAutoCreateLookalikeOldField () {       return this.requestAutoCreateLookalikeOldField(true);     }     public APIRequestGet requestAutoCreateLookalikeOldField (boolean value) {       this.requestField(&quot;auto_create_lookalike_old&quot;, value);       return this;     }     public APIRequestGet requestBidAdjustmentsSpecNewField () {       return this.requestBidAdjustmentsSpecNewField(true);     }     public APIRequestGet requestBidAdjustmentsSpecNewField (boolean value) {       this.requestField(&quot;bid_adjustments_spec_new&quot;, value);       return this;     }     public APIRequestGet requestBidAdjustmentsSpecOldField () {       return this.requestBidAdjustmentsSpecOldField(true);     }     public APIRequestGet requestBidAdjustmentsSpecOldField (boolean value) {       this.requestField(&quot;bid_adjustments_spec_old&quot;, value);       return this;     }     public APIRequestGet requestBidAmountNewField () {       return this.requestBidAmountNewField(true);     }     public APIRequestGet requestBidAmountNewField (boolean value) {       this.requestField(&quot;bid_amount_new&quot;, value);       return this;     }     public APIRequestGet requestBidAmountOldField () {       return this.requestBidAmountOldField(true);     }     public APIRequestGet requestBidAmountOldField (boolean value) {       this.requestField(&quot;bid_amount_old&quot;, value);       return this;     }     public APIRequestGet requestBidConstraintsNewField () {       return this.requestBidConstraintsNewField(true);     }     public APIRequestGet requestBidConstraintsNewField (boolean value) {       this.requestField(&quot;bid_constraints_new&quot;, value);       return this;     }     public APIRequestGet requestBidConstraintsOldField () {       return this.requestBidConstraintsOldField(true);     }     public APIRequestGet requestBidConstraintsOldField (boolean value) {       this.requestField(&quot;bid_constraints_old&quot;, value);       return this;     }     public APIRequestGet requestBidInfoNewField () {       return this.requestBidInfoNewField(true);     }     public APIRequestGet requestBidInfoNewField (boolean value) {       this.requestField(&quot;bid_info_new&quot;, value);       return this;     }     public APIRequestGet requestBidInfoOldField () {       return this.requestBidInfoOldField(true);     }     public APIRequestGet requestBidInfoOldField (boolean value) {       this.requestField(&quot;bid_info_old&quot;, value);       return this;     }     public APIRequestGet requestBidStrategyNewField () {       return this.requestBidStrategyNewField(true);     }     public APIRequestGet requestBidStrategyNewField (boolean value) {       this.requestField(&quot;bid_strategy_new&quot;, value);       return this;     }     public APIRequestGet requestBidStrategyOldField () {       return this.requestBidStrategyOldField(true);     }     public APIRequestGet requestBidStrategyOldField (boolean value) {       this.requestField(&quot;bid_strategy_old&quot;, value);       return this;     }     public APIRequestGet requestBidTypeNewField () {       return this.requestBidTypeNewField(true);     }     public APIRequestGet requestBidTypeNewField (boolean value) {       this.requestField(&quot;bid_type_new&quot;, value);       return this;     }     public APIRequestGet requestBidTypeOldField () {       return this.requestBidTypeOldField(true);     }     public APIRequestGet requestBidTypeOldField (boolean value) {       this.requestField(&quot;bid_type_old&quot;, value);       return this;     }     public APIRequestGet requestBillingEventNewField () {       return this.requestBillingEventNewField(true);     }     public APIRequestGet requestBillingEventNewField (boolean value) {       this.requestField(&quot;billing_event_new&quot;, value);       return this;     }     public APIRequestGet requestBillingEventOldField () {       return this.requestBillingEventOldField(true);     }     public APIRequestGet requestBillingEventOldField (boolean value) {       this.requestField(&quot;billing_event_old&quot;, value);       return this;     }     public APIRequestGet requestBrandeAudienceIdNewField () {       return this.requestBrandeAudienceIdNewField(true);     }     public APIRequestGet requestBrandeAudienceIdNewField (boolean value) {       this.requestField(&quot;brande_audience_id_new&quot;, value);       return this;     }     public APIRequestGet requestBrandeAudienceIdOldField () {       return this.requestBrandeAudienceIdOldField(true);     }     public APIRequestGet requestBrandeAudienceIdOldField (boolean value) {       this.requestField(&quot;brande_audience_id_old&quot;, value);       return this;     }     public APIRequestGet requestBudgetLimitNewField () {       return this.requestBudgetLimitNewField(true);     }     public APIRequestGet requestBudgetLimitNewField (boolean value) {       this.requestField(&quot;budget_limit_new&quot;, value);       return this;     }     public APIRequestGet requestBudgetLimitOldField () {       return this.requestBudgetLimitOldField(true);     }     public APIRequestGet requestBudgetLimitOldField (boolean value) {       this.requestField(&quot;budget_limit_old&quot;, value);       return this;     }     public APIRequestGet requestCreatedTimeField () {       return this.requestCreatedTimeField(true);     }     public APIRequestGet requestCreatedTimeField (boolean value) {       this.requestField(&quot;created_time&quot;, value);       return this;     }     public APIRequestGet requestDailyImpressionsNewField () {       return this.requestDailyImpressionsNewField(true);     }     public APIRequestGet requestDailyImpressionsNewField (boolean value) {       this.requestField(&quot;daily_impressions_new&quot;, value);       return this;     }     public APIRequestGet requestDailyImpressionsOldField () {       return this.requestDailyImpressionsOldField(true);     }     public APIRequestGet requestDailyImpressionsOldField (boolean value) {       this.requestField(&quot;daily_impressions_old&quot;, value);       return this;     }     public APIRequestGet requestDcoModeNewField () {       return this.requestDcoModeNewField(true);     }     public APIRequestGet requestDcoModeNewField (boolean value) {       this.requestField(&quot;dco_mode_new&quot;, value);       return this;     }     public APIRequestGet requestDcoModeOldField () {       return this.requestDcoModeOldField(true);     }     public APIRequestGet requestDcoModeOldField (boolean value) {       this.requestField(&quot;dco_mode_old&quot;, value);       return this;     }     public APIRequestGet requestDeliveryBehaviorNewField () {       return this.requestDeliveryBehaviorNewField(true);     }     public APIRequestGet requestDeliveryBehaviorNewField (boolean value) {       this.requestField(&quot;delivery_behavior_new&quot;, value);       return this;     }     public APIRequestGet requestDeliveryBehaviorOldField () {       return this.requestDeliveryBehaviorOldField(true);     }     public APIRequestGet requestDeliveryBehaviorOldField (boolean value) {       this.requestField(&quot;delivery_behavior_old&quot;, value);       return this;     }     public APIRequestGet requestDestinationTypeNewField () {       return this.requestDestinationTypeNewField(true);     }     public APIRequestGet requestDestinationTypeNewField (boolean value) {       this.requestField(&quot;destination_type_new&quot;, value);       return this;     }     public APIRequestGet requestDestinationTypeOldField () {       return this.requestDestinationTypeOldField(true);     }     public APIRequestGet requestDestinationTypeOldField (boolean value) {       this.requestField(&quot;destination_type_old&quot;, value);       return this;     }     public APIRequestGet requestEventTimeField () {       return this.requestEventTimeField(true);     }     public APIRequestGet requestEventTimeField (boolean value) {       this.requestField(&quot;event_time&quot;, value);       return this;     }     public APIRequestGet requestEventTypeField () {       return this.requestEventTypeField(true);     }     public APIRequestGet requestEventTypeField (boolean value) {       this.requestField(&quot;event_type&quot;, value);       return this;     }     public APIRequestGet requestIdField () {       return this.requestIdField(true);     }     public APIRequestGet requestIdField (boolean value) {       this.requestField(&quot;id&quot;, value);       return this;     }     public APIRequestGet requestInvoicingLimitNewField () {       return this.requestInvoicingLimitNewField(true);     }     public APIRequestGet requestInvoicingLimitNewField (boolean value) {       this.requestField(&quot;invoicing_limit_new&quot;, value);       return this;     }     public APIRequestGet requestInvoicingLimitOldField () {       return this.requestInvoicingLimitOldField(true);     }     public APIRequestGet requestInvoicingLimitOldField (boolean value) {       this.requestField(&quot;invoicing_limit_old&quot;, value);       return this;     }     public APIRequestGet requestMinSpendTargetNewField () {       return this.requestMinSpendTargetNewField(true);     }     public APIRequestGet requestMinSpendTargetNewField (boolean value) {       this.requestField(&quot;min_spend_target_new&quot;, value);       return this;     }     public APIRequestGet requestMinSpendTargetOldField () {       return this.requestMinSpendTargetOldField(true);     }     public APIRequestGet requestMinSpendTargetOldField (boolean value) {       this.requestField(&quot;min_spend_target_old&quot;, value);       return this;     }     public APIRequestGet requestNameNewField () {       return this.requestNameNewField(true);     }     public APIRequestGet requestNameNewField (boolean value) {       this.requestField(&quot;name_new&quot;, value);       return this;     }     public APIRequestGet requestNameOldField () {       return this.requestNameOldField(true);     }     public APIRequestGet requestNameOldField (boolean value) {       this.requestField(&quot;name_old&quot;, value);       return this;     }     public APIRequestGet requestOptimizationGoalNewField () {       return this.requestOptimizationGoalNewField(true);     }     public APIRequestGet requestOptimizationGoalNewField (boolean value) {       this.requestField(&quot;optimization_goal_new&quot;, value);       return this;     }     public APIRequestGet requestOptimizationGoalOldField () {       return this.requestOptimizationGoalOldField(true);     }     public APIRequestGet requestOptimizationGoalOldField (boolean value) {       this.requestField(&quot;optimization_goal_old&quot;, value);       return this;     }     public APIRequestGet requestPacingTypeNewField () {       return this.requestPacingTypeNewField(true);     }     public APIRequestGet requestPacingTypeNewField (boolean value) {       this.requestField(&quot;pacing_type_new&quot;, value);       return this;     }     public APIRequestGet requestPacingTypeOldField () {       return this.requestPacingTypeOldField(true);     }     public APIRequestGet requestPacingTypeOldField (boolean value) {       this.requestField(&quot;pacing_type_old&quot;, value);       return this;     }     public APIRequestGet requestRunStatusNewField () {       return this.requestRunStatusNewField(true);     }     public APIRequestGet requestRunStatusNewField (boolean value) {       this.requestField(&quot;run_status_new&quot;, value);       return this;     }     public APIRequestGet requestRunStatusOldField () {       return this.requestRunStatusOldField(true);     }     public APIRequestGet requestRunStatusOldField (boolean value) {       this.requestField(&quot;run_status_old&quot;, value);       return this;     }     public APIRequestGet requestScheduleNewField () {       return this.requestScheduleNewField(true);     }     public APIRequestGet requestScheduleNewField (boolean value) {       this.requestField(&quot;schedule_new&quot;, value);       return this;     }     public APIRequestGet requestScheduleOldField () {       return this.requestScheduleOldField(true);     }     public APIRequestGet requestScheduleOldField (boolean value) {       this.requestField(&quot;schedule_old&quot;, value);       return this;     }     public APIRequestGet requestSpendCapNewField () {       return this.requestSpendCapNewField(true);     }     public APIRequestGet requestSpendCapNewField (boolean value) {       this.requestField(&quot;spend_cap_new&quot;, value);       return this;     }     public APIRequestGet requestSpendCapOldField () {       return this.requestSpendCapOldField(true);     }     public APIRequestGet requestSpendCapOldField (boolean value) {       this.requestField(&quot;spend_cap_old&quot;, value);       return this;     }     public APIRequestGet requestStartTimeNewField () {       return this.requestStartTimeNewField(true);     }     public APIRequestGet requestStartTimeNewField (boolean value) {       this.requestField(&quot;start_time_new&quot;, value);       return this;     }     public APIRequestGet requestStartTimeOldField () {       return this.requestStartTimeOldField(true);     }     public APIRequestGet requestStartTimeOldField (boolean value) {       this.requestField(&quot;start_time_old&quot;, value);       return this;     }     public APIRequestGet requestStopTimeNewField () {       return this.requestStopTimeNewField(true);     }     public APIRequestGet requestStopTimeNewField (boolean value) {       this.requestField(&quot;stop_time_new&quot;, value);       return this;     }     public APIRequestGet requestStopTimeOldField () {       return this.requestStopTimeOldField(true);     }     public APIRequestGet requestStopTimeOldField (boolean value) {       this.requestField(&quot;stop_time_old&quot;, value);       return this;     }     public APIRequestGet requestTargetingExpansionNewField () {       return this.requestTargetingExpansionNewField(true);     }     public APIRequestGet requestTargetingExpansionNewField (boolean value) {       this.requestField(&quot;targeting_expansion_new&quot;, value);       return this;     }     public APIRequestGet requestTargetingExpansionOldField () {       return this.requestTargetingExpansionOldField(true);     }     public APIRequestGet requestTargetingExpansionOldField (boolean value) {       this.requestField(&quot;targeting_expansion_old&quot;, value);       return this;     }     public APIRequestGet requestUpdatedTimeNewField () {       return this.requestUpdatedTimeNewField(true);     }     public APIRequestGet requestUpdatedTimeNewField (boolean value) {       this.requestField(&quot;updated_time_new&quot;, value);       return this;     }     public APIRequestGet requestUpdatedTimeOldField () {       return this.requestUpdatedTimeOldField(true);     }     public APIRequestGet requestUpdatedTimeOldField (boolean value) {       this.requestField(&quot;updated_time_old&quot;, value);       return this;     }   }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13266</td>
    <td align="left">https://github.com/facebook/facebook-java-business-sdk/blob/561f1a75e1220b55a160a1b92b0187f72be9cd08/src/main/java/com/facebook/ads/sdk/AdCampaignActivity.java/#L610-L1160</td>
    <td align="right">1</td>
    <td align="right">2141</td>
    <td align="right">13266</td>
  </tr>
  <tr valign="top">
    <td align="right">2279</td>
    <td align="left">{         &quot;output&quot;: &quot;YES, I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Blob&quot;,         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class ConfigBoolean extends ConfigVariable {     public ConfigBoolean(OptionSpec spec)     {         super(spec);          this.enabled = false;         this.isSet = false;     }      public ConfigBoolean(OptionSpec spec, boolean enabled)     {         super(spec);         this.set(enabled);     }          private boolean enabled;     private boolean isSet;       public void set(boolean value)     {         this.enabled = value;         this.isSet = true;     }      public void set(String value)     {         this.enabled = parseValue(value);         this.isSet = true;     }      public boolean isSet()     {     	return isSet;     	}      public void addToCommandline(Commandline cmdline)     {         if (isSet)             cmdline.createArgument(true).setValue(&quot;-&quot; + spec.getFullName() + &quot;=&quot; + enabled);     }      private boolean parseValue(String value)     {         return value.toLowerCase().matches(&quot;\\s*(true|yes|on)\\s*&quot;);     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13785</td>
    <td align="left">https://github.com/apache/royale-compiler/blob/fbd9bc3b9e48c80dbd8c1d32a6f83221e314efdd/royale-ant-tasks/src/main/java/org/apache/royale/compiler/ant/config/ConfigBoolean.java/#L28-L75</td>
    <td align="right">1</td>
    <td align="right">2279</td>
    <td align="right">13785</td>
  </tr>
  <tr valign="top">
    <td align="right">867</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES, I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Long Method&quot;,       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class Builder {     private String omServiceId;     private String omNodeId;     private InetSocketAddress rpcAddress;     private int rpcPort;     private int ratisPort;      public Builder setRpcAddress(InetSocketAddress rpcAddr) {       this.rpcAddress = rpcAddr;       this.rpcPort = rpcAddress.getPort();       return this;     }      public Builder setRatisPort(int port) {       this.ratisPort = port;       return this;     }      public Builder setOMServiceId(String serviceId) {       this.omServiceId = serviceId;       return this;     }      public Builder setOMNodeId(String nodeId) {       this.omNodeId = nodeId;       return this;     }      public OMNodeDetails build() {       return new OMNodeDetails(omServiceId, omNodeId, rpcAddress, rpcPort,           ratisPort);     }   }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7941</td>
    <td align="left">https://github.com/apache/hadoop/blob/128dd91e10080bdcbcd7d555fa3c4105e55a6b51/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/OMNodeDetails.java/#L50-L82</td>
    <td align="right">1</td>
    <td align="right">867</td>
    <td align="right">7941</td>
  </tr>
  <tr valign="top">
    <td align="right">5180</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Data Class&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class AddEditNameUrlDialog extends Dialog { 	AbstractNameUrlPreferenceModel model;  	Text nameText;  	Text urlText;  	String name;  	String urlString;  	private final String explanatoryText;  	protected Label errorTextLabel;  	protected Composite composite;  	private String title;  	public AddEditNameUrlDialog(Shell parent, AbstractNameUrlPreferenceModel aModel, NameUrlPair nameUrl, 			String headerText) { 		super(parent); 		explanatoryText = headerText; 		model = aModel; 		if (nameUrl != null) { 			name = nameUrl.getName(); 			urlString = nameUrl.getUrlString(); 		} 		else { 			name = null; 			urlString = null; 		} 	}  	@Override 	protected Control createDialogArea(Composite parent) { 		composite = new Composite(parent, SWT.NONE);  		GridLayoutFactory.fillDefaults().numColumns(2).extendedMargins(5, 13, 10, 0).applyTo(composite); 		GridDataFactory.fillDefaults().grab(true, true).applyTo(composite);  		Label explanatoryTextLabel = new Label(composite, SWT.WRAP); 		explanatoryTextLabel.setText(explanatoryText); 		GridDataFactory.fillDefaults().grab(true, false).span(2, 1).applyTo(explanatoryTextLabel);  		Label nameLabel = new Label(composite, SWT.NONE); 		nameLabel.setText(NLS.bind(&quot;Name:&quot;, null)); 		nameLabel.setLayoutData(new GridData(SWT.LEFT, SWT.TOP, false, false, 1, 1));  		nameText = new Text(composite, SWT.BORDER + SWT.FILL); 		GridDataFactory.fillDefaults().grab(true, false).hint(300, SWT.DEFAULT).applyTo(nameText); 		nameText.setEditable(true); 		if (name != null &amp;&amp; name.length() &gt; 0) { 			nameText.setText(name); 		}  		Label urlLabel = new Label(composite, SWT.NONE); 		urlLabel.setText(NLS.bind(&quot;URL:&quot;, null)); 		urlLabel.setLayoutData(new GridData(SWT.LEFT, SWT.TOP, false, false, 1, 1)); 		urlText = new Text(composite, SWT.BORDER); 		GridDataFactory.fillDefaults().grab(true, false).hint(300, SWT.DEFAULT).applyTo(urlText); 		urlText.setEditable(true); 		if (urlString != null &amp;&amp; urlString.length() &gt; 0) { 			urlText.setText(urlString); 		}  		urlText.addKeyListener(getUrlValidationListener());  		String errorText = &quot;&quot;; 		errorTextLabel = new Label(composite, SWT.WRAP); 		errorTextLabel.setText(errorText); 		GridDataFactory.fillDefaults().grab(true, false).span(2, 1).applyTo(errorTextLabel);  		// getButton(IDialogConstants.OK_ID).setEnabled(validateUrl(urlString));  		return composite; 	}  	@Override 	public void create() { 		super.create(); 		if (title != null) { 			getShell().setText(title); 		} 		getButton(IDialogConstants.OK_ID).setEnabled(validateUrl(urlString)); 	}  	protected KeyListener getUrlValidationListener() { 		return new KeyListener() {  			public void keyReleased(KeyEvent e) {  				String urlString = ((Text) e.getSource()).getText().trim(); 				if (!validateUrl(urlString)) { 					getButton(IDialogConstants.OK_ID).setEnabled(false); 				} 				else { 					errorTextLabel.setText(&quot;&quot;); 					composite.update(); 					getButton(IDialogConstants.OK_ID).setEnabled(true); 				} 			}  			public void keyPressed(KeyEvent e) { 				// do nothing 			} 		}; 	}  	@Override 	protected void okPressed() { 		name = nameText.getText(); 		urlString = urlText.getText(); 		if (urlString.length() &gt; 0) { 			if (name.length() &lt;= 0) { 				name = urlString; 			} 		}  		super.okPressed(); 	}  	public String getUrlString() { 		return urlString; 	}  	public String getName() { 		return name; 	}  	protected boolean validateUrl(String urlString) { 		if (urlString != null &amp;&amp; urlString.contains(&quot; &quot;)) { 			urlString = urlString.replace(&quot; &quot;, &quot;%20&quot;); 			int caret = urlText.getCaretPosition(); 			urlText.setText(urlString); 			urlText.setSelection(caret + &quot;%20&quot;.length() - 1); 		} 		if (urlString == null || urlString.length() &lt;= 0) { 			return false; 		}  		try { 			new URI(urlString); 		} 		catch (URISyntaxException e) { 			return showError(); 		}  		try { 			URL url = new URL(urlString); 			if (url.getHost().isEmpty()) { 				return showError(); 			} 		} 		catch (MalformedURLException e) { 			return showError(); 		}  		return true; 	}  	private boolean showError() { 		errorTextLabel.setText(AddEditNameUrlDialogMessages.malformedUrl); 		composite.update(); 		return false; 	}  	protected void setTitle(String title) { 		this.title = title; 	} }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14486</td>
    <td align="left">https://github.com/spring-projects/spring-ide/blob/915fe9bffd50db45ee0b8fb993416e45dee68179/plugins/org.springframework.ide.eclipse.wizard/src/org/springframework/ide/eclipse/wizard/template/util/AddEditNameUrlDialog.java/#L38-L208</td>
    <td align="right">1</td>
    <td align="right">5180</td>
    <td align="right">14486</td>
  </tr>
  <tr valign="top">
    <td align="right">2084</td>
    <td align="left">&nbsp;{&quot;answer&quot;: &quot;YES I found bad smells&quot;,  &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  private static class FieldMetaData {     public final FieldInfo fieldInfo;     public final long numTerms;     public final long sumTotalTermFreq;     public final long sumDocFreq;     public final int docCount;     public final int longsSize;     public final FST dict;      public FieldMetaData(FieldInfo fieldInfo, long numTerms, long sumTotalTermFreq, long sumDocFreq, int docCount, int longsSize, FST fst) {       this.fieldInfo = fieldInfo;       this.numTerms = numTerms;       this.sumTotalTermFreq = sumTotalTermFreq;       this.sumDocFreq = sumDocFreq;       this.docCount = docCount;       this.longsSize = longsSize;       this.dict = fst;     }   }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13082</td>
    <td align="left">https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/lucene/codecs/src/java/org/apache/lucene/codecs/memory/FSTTermsWriter.java/#L229-L247</td>
    <td align="right">1</td>
    <td align="right">2084</td>
    <td align="right">13082</td>
  </tr>
  <tr valign="top">
    <td align="right">444</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@ConfigurationProperties(prefix = &quot;camel.opentracing&quot;) public class OpenTracingConfigurationProperties {      /**      * Sets exclude pattern(s) that will disable tracing for Camel messages that      * matches the pattern.      */     private Set excludePatterns;     /**      * Activate or deactivate dash encoding in headers (required by JMS) for      * messaging      */     private Boolean encoding;      public Set getExcludePatterns() {         return excludePatterns;     }      public void setExcludePatterns(Set excludePatterns) {         this.excludePatterns = excludePatterns;     }      public Boolean getEncoding() {         return encoding;     }      public void setEncoding(Boolean encoding) {         this.encoding = encoding;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4319</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/platforms/spring-boot/components-starter/camel-opentracing-starter/src/main/java/org/apache/camel/opentracing/starter/OpenTracingConfigurationProperties.java/#L23-L52</td>
    <td align="right">1</td>
    <td align="right">444</td>
    <td align="right">4319</td>
  </tr>
  <tr valign="top">
    <td align="right">2280</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class NodeValueString extends NodeValue {     // A plain string, with no language tag, or an xsd:string.          private String string ;           public NodeValueString(String str)         { string = str ; }      public NodeValueString(String str, Node n) { super(n) ; string = str ; }          @Override     public boolean isString() { return true ; }          @Override     public String getString() { return string ; }      @Override     public String asString() { return string ; }          @Override     public String toString()     {          if ( getNode() != null )         {             // Can be a plain string or an xsd:string.             return FmtUtils.stringForNode(getNode()) ;         }         return '&quot;'+string+'&quot;'  ;     }          @Override     protected Node makeNode()     { return NodeFactory.createLiteral(string) ; }          @Override     public void visit(NodeValueVisitor visitor) { visitor.visit(this) ; } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13797</td>
    <td align="left">https://github.com/apache/jena/blob/1cca775bbf0bb0fd3ee8ac55e31f0f30cdde3b77/jena-arq/src/main/java/org/apache/jena/sparql/expr/nodevalue/NodeValueString.java/#L27-L62</td>
    <td align="right">1</td>
    <td align="right">2280</td>
    <td align="right">13797</td>
  </tr>
  <tr valign="top">
    <td align="right">2346</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells the bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
   public class Header {        public String key;       public String val;        public Header(String key, String val) {          this.key = key;          this.val = val;       }        public String getEncodedKey() {          return encode(key);       }        public String getEncodedValue() {          return encode(val);       }    }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14193</td>
    <td align="left">https://github.com/apache/activemq-artemis/blob/5bd5c610195d6f4a3dd1ac28170727003f8a5a54/artemis-protocols/artemis-stomp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/stomp/StompFrame.java/#L158-L175</td>
    <td align="right">1</td>
    <td align="right">2346</td>
    <td align="right">14193</td>
  </tr>
  <tr valign="top">
    <td align="right">2502</td>
    <td align="left">&nbsp;{   &quot;message&quot;: &quot;YES, I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class NotificationsAggregatorState {         public long recentEventLogsCount;         public long activeRequestsCount;     }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14662</td>
    <td align="left">https://github.com/vmware/admiral/blob/e02d0e77f65d0ee3541a378110ecd4233bdb6664/request/src/main/java/com/vmware/admiral/request/notification/NotificationsService.java/#L52-L55</td>
    <td align="right">1</td>
    <td align="right">2502</td>
    <td align="right">14662</td>
  </tr>
  <tr valign="top">
    <td align="right">4113</td>
    <td align="left">{&quot;answer&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;1. Long Method&quot;, &quot;2. Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class CovarianceMatricesAggregator implements Serializable {     /** Serial version uid. */     private static final long serialVersionUID = 4163253784526780812L;      /** Mean vector. */     private final Vector mean;      /** Weighted by P(c|xi) sum of (xi - mean) * (xi - mean)^T values. */     private Matrix weightedSum;      /** Count of rows. */     private int rowCount;      /**      * Creates an instance of CovarianceMatricesAggregator.      *      * @param mean Mean vector.      */     CovarianceMatricesAggregator(Vector mean) {         this.mean = mean;     }      /**      * Creates an instance of CovarianceMatricesAggregator.      *      * @param mean Mean vector.      * @param weightedSum Weighted sums for covariace computation.      * @param rowCount Count of rows.      */     CovarianceMatricesAggregator(Vector mean, Matrix weightedSum, int rowCount) {         this.mean = mean;         this.weightedSum = weightedSum;         this.rowCount = rowCount;     }      /**      * Computes covatiation matrices for feature vector for each GMM component.      *      * @param dataset Dataset.      * @param clusterProbs Probabilities of each GMM component.      * @param means Means for each GMM component.      */     static List computeCovariances(Dataset dataset,         Vector clusterProbs, Vector[] means) {          List aggregators = dataset.compute(             data -&gt; map(data, means),             CovarianceMatricesAggregator::reduce         );          if (aggregators == null)             return Collections.emptyList();          List res = new ArrayList&lt;&gt;();         for (int i = 0; i &lt; aggregators.size(); i++)             res.add(aggregators.get(i).covariance(clusterProbs.get(i)));          return res;     }      /**      * @param x Feature vector (xi).      * @param pcxi P(c|xi) for GMM component &quot;c&quot; and vector xi.      */     void add(Vector x, double pcxi) {         Matrix deltaCol = x.minus(mean).toMatrix(false);         Matrix weightedCovComponent = deltaCol.times(deltaCol.transpose()).times(pcxi);         if (weightedSum == null)             weightedSum = weightedCovComponent;         else             weightedSum = weightedSum.plus(weightedCovComponent);         rowCount += 1;     }      /**      * @param other Other.      * @return sum of aggregators.      */     CovarianceMatricesAggregator plus(CovarianceMatricesAggregator other) {         A.ensure(this.mean.equals(other.mean), &quot;this.mean == other.mean&quot;);          return new CovarianceMatricesAggregator(             mean,             this.weightedSum.plus(other.weightedSum),             this.rowCount + other.rowCount         );     }      /**      * Map stage for covariance computation over dataset.      *      * @param data Data partition.      * @param means Means vector.      * @return Covariance aggregators.      */     static List map(GmmPartitionData data, Vector[] means) {         int countOfComponents = means.length;          List aggregators = new ArrayList&lt;&gt;();         for (int i = 0; i &lt; countOfComponents; i++)             aggregators.add(new CovarianceMatricesAggregator(means[i]));          for (int i = 0; i &lt; data.size(); i++) {             for (int c = 0; c &lt; countOfComponents; c++)                 aggregators.get(c).add(data.getX(i), data.pcxi(c, i));         }          return aggregators;     }      /**      * @param clusterProb GMM component probability.      * @return computed covariance matrix.      */     private Matrix covariance(double clusterProb) {         return weightedSum.divide(rowCount * clusterProb);     }      /**      * Reduce stage for covariance computation over dataset.      *      * @param l first partition.      * @param r second partition.      */     static List reduce(List l,         List r) {          A.ensure(l != null || r != null, &quot;Both partitions cannot equal to null&quot;);          if (l == null || l.isEmpty())             return r;         if (r == null || r.isEmpty())             return l;          A.ensure(l.size() == r.size(), &quot;l.size() == r.size()&quot;);         List res = new ArrayList&lt;&gt;();         for (int i = 0; i &lt; l.size(); i++)             res.add(l.get(i).plus(r.get(i)));          return res;     }      /**      * @return mean vector.      */     Vector mean() {         return mean.copy();     }      /**      * @return weighted sum.      */     Matrix weightedSum() {         return weightedSum.copy();     }      /**      * @return rows count.      */     public int rowCount() {         return rowCount;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. long method, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10831</td>
    <td align="left">https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/ml/src/main/java/org/apache/ignite/ml/clustering/gmm/CovarianceMatricesAggregator.java/#L34-L196</td>
    <td align="right">1</td>
    <td align="right">4113</td>
    <td align="right">10831</td>
  </tr>
  <tr valign="top">
    <td align="right">457</td>
    <td align="left">YES I found bad smells the bad smells are: 1.Long method, 2.Data class, 3.Feature envy, 4.Magic number, 5.Duplicate code, 6.Inappropriate constant, 7.Message chains</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class SSLConfigClient extends SSLConfig {    private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(SSLConfigClient.class);    private final Properties properties;   private final boolean userSslEnabled;   private final String trustStoreType;   private final String trustStorePath;   private final String trustStorePassword;   private final boolean disableHostVerification;   private final boolean disableCertificateVerification;   private final boolean useSystemTrustStore;   private final String protocol;   private final int handshakeTimeout;   private final String provider;    private final String emptyString = new String();    public SSLConfigClient(Properties properties) throws DrillException {     this.properties = properties;     userSslEnabled = getBooleanProperty(DrillProperties.ENABLE_TLS);     trustStoreType = getStringProperty(DrillProperties.TRUSTSTORE_TYPE, &quot;JKS&quot;);     trustStorePath = getStringProperty(DrillProperties.TRUSTSTORE_PATH, &quot;&quot;);     trustStorePassword = getStringProperty(DrillProperties.TRUSTSTORE_PASSWORD, &quot;&quot;);     disableHostVerification = getBooleanProperty(DrillProperties.DISABLE_HOST_VERIFICATION);     disableCertificateVerification = getBooleanProperty(DrillProperties.DISABLE_CERT_VERIFICATION);     useSystemTrustStore = getBooleanProperty(DrillProperties.USE_SYSTEM_TRUSTSTORE);     protocol = getStringProperty(DrillProperties.TLS_PROTOCOL, DEFAULT_SSL_PROTOCOL);     int hsTimeout = getIntProperty(DrillProperties.TLS_HANDSHAKE_TIMEOUT, DEFAULT_SSL_HANDSHAKE_TIMEOUT_MS);     if (hsTimeout &lt;= 0) {       hsTimeout = DEFAULT_SSL_HANDSHAKE_TIMEOUT_MS;     }     handshakeTimeout = hsTimeout;     // If provider is OPENSSL then to debug or run this code in an IDE, you will need to enable     // the dependency on netty-tcnative with the correct classifier for the platform you use.     // This can be done by enabling the openssl profile.     // If the IDE is Eclipse, it requires you to install an additional Eclipse plugin available here:     // http://repo1.maven.org/maven2/kr/motd/maven/os-maven-plugin/1.6.1/os-maven-plugin-1.6.1.jar     // or from your local maven repository:     // ~/.m2/repository/kr/motd/maven/os-maven-plugin/1.6.1/os-maven-plugin-1.6.1.jar     // Note that installing this plugin may require you to start with a new workspace     provider = getStringProperty(DrillProperties.TLS_PROVIDER, DEFAULT_SSL_PROVIDER);   }    private boolean getBooleanProperty(String propName) {     return (properties != null) &amp;&amp; (properties.containsKey(propName))         &amp;&amp; (properties.getProperty(propName).compareToIgnoreCase(&quot;true&quot;) == 0);   }    private String getStringProperty(String name, String defaultValue) {     String value = &quot;&quot;;     if ( (properties != null) &amp;&amp; (properties.containsKey(name))) {       value = properties.getProperty(name);     }     if (value.isEmpty()) {       value = defaultValue;     }     value = value.trim();     return value;   }    private int getIntProperty(String name, int defaultValue) {     int value = defaultValue;     if (properties != null) {       String property = properties.getProperty(name);       if (property != null &amp;&amp; property.length() &gt; 0) {         value = Integer.decode(property);       }     }     return value;   }    public void validateKeyStore() throws DrillException {    }    @Override   public SslContext initNettySslContext() throws DrillException {     final SslContext sslCtx;      if (!userSslEnabled) {       return null;     }      TrustManagerFactory tmf;     try {       tmf = initializeTrustManagerFactory();       sslCtx = SslContextBuilder.forClient()           .sslProvider(getProvider())           .trustManager(tmf)           .protocols(protocol)           .build();     } catch (Exception e) {       // Catch any SSL initialization Exceptions here and abort.       throw new DrillException(new StringBuilder()           .append(&quot;SSL is enabled but cannot be initialized due to the following exception: &quot;)           .append(&quot;[ &quot;)           .append(e.getMessage())           .append(&quot;]. &quot;)           .toString());     }     this.nettySslContext = sslCtx;     return sslCtx;   }    @Override   public SSLContext initJDKSSLContext() throws DrillException {     final SSLContext sslCtx;      if (!userSslEnabled) {       return null;     }      TrustManagerFactory tmf;     try {       tmf = initializeTrustManagerFactory();       sslCtx = SSLContext.getInstance(protocol);       sslCtx.init(null, tmf.getTrustManagers(), null);     } catch (Exception e) {       // Catch any SSL initialization Exceptions here and abort.       throw new DrillException(new StringBuilder()           .append(&quot;SSL is enabled but cannot be initialized due to the following exception: &quot;)           .append(&quot;[ &quot;)           .append(e.getMessage())           .append(&quot;]. &quot;)           .toString());     }     this.jdkSSlContext = sslCtx;     return sslCtx;   }    @Override   public SSLEngine createSSLEngine(BufferAllocator allocator, String peerHost, int peerPort) {     SSLEngine engine = super.createSSLEngine(allocator, peerHost, peerPort);      if (!this.disableHostVerification()) {       SSLParameters sslParameters = engine.getSSLParameters();       // only available since Java 7       sslParameters.setEndpointIdentificationAlgorithm(&quot;HTTPS&quot;);       engine.setSSLParameters(sslParameters);     }      engine.setUseClientMode(true);      try {       engine.setEnableSessionCreation(true);     } catch (Exception e) {       // Openssl implementation may throw this.       logger.debug(&quot;Session creation not enabled. Exception: {}&quot;, e.getMessage());     }      return engine;   }    @Override   public boolean isUserSslEnabled() {     return userSslEnabled;   }    @Override   public boolean isHttpsEnabled() {     return false;   }    @Override   public String getKeyStoreType() {     return emptyString;   }    @Override   public String getKeyStorePath() {     return emptyString;   }    @Override   public String getKeyStorePassword() {     return emptyString;   }    @Override   public String getKeyPassword() {     return emptyString;   }    @Override   public String getTrustStoreType() {     return trustStoreType;   }    @Override   public boolean hasTrustStorePath() {     return !trustStorePath.isEmpty();   }    @Override   public String getTrustStorePath() {     return trustStorePath;   }    @Override   public boolean hasTrustStorePassword() {     return !trustStorePassword.isEmpty();   }    @Override   public String getTrustStorePassword() {     return trustStorePassword;   }    @Override   public String getProtocol() {     return protocol;   }    @Override   public SslProvider getProvider() {     return provider.equalsIgnoreCase(&quot;JDK&quot;) ? SslProvider.JDK : SslProvider.OPENSSL;   }    @Override   public int getHandshakeTimeout() {     return handshakeTimeout;   }    @Override   public Mode getMode() {     return Mode.CLIENT;   }    @Override   public boolean disableHostVerification() {     return disableHostVerification;   }    @Override   public boolean disableCertificateVerification() {     return disableCertificateVerification;   }    @Override   public boolean useSystemTrustStore() {     return useSystemTrustStore;   }    public boolean isSslValid() {     return true;   }  }</td>
    <td align="left">data class</td>
    <td align="left">Long method, 2Data class, 3Feature envy, 4Magic number, 5Duplicate code, 6Inappropriate constant, 7Message chains</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">.Long method,  3.Feature envy,  4.Magic number,  5.Duplicate code,  6.Inappropriate constant,  7.Message chains</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4454</td>
    <td align="left">https://github.com/apache/drill/blob/5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3/exec/java-exec/src/main/java/org/apache/drill/exec/ssl/SSLConfigClient.java/#L33-L281</td>
    <td align="right">2</td>
    <td align="right">457</td>
    <td align="right">4454</td>
  </tr>
  <tr valign="top">
    <td align="right">678</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private class PutFileAction implements SshAction {         // TODO support backup as a property?                  private SFTPClient sftp;         private final String path;         private final int permissionsMask;         private final long lastModificationDate;         private final long lastAccessDate;         private final int uid;         private final Supplier contentsSupplier;         private final Integer length;                  PutFileAction(Map props, String path, Supplier contentsSupplier, long length) {             String permissions = getOptionalVal(props, PROP_PERMISSIONS);             long lastModificationDateVal = getOptionalVal(props, PROP_LAST_MODIFICATION_DATE);             long lastAccessDateVal = getOptionalVal(props, PROP_LAST_ACCESS_DATE);             if (lastAccessDateVal &lt;= 0 ^ lastModificationDateVal &lt;= 0) {                 lastAccessDateVal = Math.max(lastAccessDateVal, lastModificationDateVal);                 lastModificationDateVal = Math.max(lastAccessDateVal, lastModificationDateVal);             }             this.permissionsMask = Integer.parseInt(permissions, 8);             this.lastAccessDate = lastAccessDateVal;             this.lastModificationDate = lastModificationDateVal;             this.uid = getOptionalVal(props, PROP_OWNER_UID);             this.path = checkNotNull(path, &quot;path&quot;);             this.contentsSupplier = checkNotNull(contentsSupplier, &quot;contents&quot;);             this.length = Ints.checkedCast(checkNotNull((long)length, &quot;size&quot;));         }          @Override         public void clear() {             closeWhispering(sftp, this);             sftp = null;         }          @Override         public Void create() throws Exception {             final AtomicReference inputStreamRef = new AtomicReference();             sftp = acquire(sftpConnection);             try {                 sftp.put(new InMemorySourceFile() {                     @Override public String getName() {                         return path;                     }                     @Override public long getLength() {                         return length;                     }                     @Override public InputStream getInputStream() throws IOException {                         InputStream contents = contentsSupplier.get();                         inputStreamRef.set(contents);                         return contents;                     }                 }, path);                 sftp.chmod(path, permissionsMask);                 if (uid != -1) {                     sftp.chown(path, uid);                 }                 if (lastAccessDate &gt; 0) {                     sftp.setattr(path, new FileAttributes.Builder()                             .withAtimeMtime(lastAccessDate, lastModificationDate)                             .build());                 }             } finally {                 closeWhispering(inputStreamRef.get(), this);             }             return null;         }          @Override         public String toString() {             return &quot;Put(path=[&quot; + path + &quot; &quot;+length+&quot;])&quot;;         }     }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6584</td>
    <td align="left">https://github.com/apache/incubator-brooklyn/blob/337a5d22d5e9c98cc96ea1085383cbed1ee0b741/brooklyn-server/core/src/main/java/org/apache/brooklyn/util/core/internal/ssh/sshj/SshjTool.java/#L730-L802</td>
    <td align="right">1</td>
    <td align="right">678</td>
    <td align="right">6584</td>
  </tr>
  <tr valign="top">
    <td align="right">901</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class Builder {          private File path;          private String interval;          private boolean incremental;          private File out;          private String filter;          private boolean ignoreMissingSegments;          private Builder() {             // Prevent external instantiation.         }          /**          * The path to an existing segment store. This parameter is required.          *          * @param path the path to an existing segment store.          * @return this builder.          */         public Builder withPath(File path) {             this.path = checkNotNull(path);             return this;         }          /**          * The two node records to diff specified as a record ID interval. This          * parameter is required.          *           * The interval is specified as two record IDs separated by two full          * stops ({@code ..}). In example, {@code 333dc24d-438f-4cca-8b21-3ebf67c05856:12345..46116fda-7a72-4dbc-af88-a09322a7753a:67890}.          * Instead of using a full record ID, it is possible to use the special          * placeholder {@code head}. This placeholder is translated to the          * record ID of the most recent head state.          *          * @param interval an interval between two node record IDs.          * @return this builder.          */         public Builder withInterval(String interval) {             this.interval = checkNotNull(interval);             return this;         }          /**          * Set whether or not to perform an incremental diff of the specified          * interval. An incremental diff shows every change between the two          * records at every revision available to the segment store. This          * parameter is not mandatory and defaults to {@code false}.          *          * @param incremental {@code true} to perform an incremental diff,          *                    {@code false} otherwise.          * @return this builder.          */         public Builder withIncremental(boolean incremental) {             this.incremental = incremental;             return this;         }          /**          * The file where the output of this command is stored. this parameter          * is mandatory.          *          * @param file the output file.          * @return this builder.          */         public Builder withOutput(File file) {             this.out = checkNotNull(file);             return this;         }          /**          * The path to a subtree. If specified, this parameter allows to          * restrict the diff to the specified subtree. This parameter is not          * mandatory and defaults to the entire tree.          *          * @param filter a path used as as filter for the resulting diff.          * @return this builder.          */         public Builder withFilter(String filter) {             this.filter = checkNotNull(filter);             return this;         }          /**          * Whether to ignore exceptions caused by missing segments in the          * segment store. This parameter is not mandatory and defaults to {@code          * false}.          *          * @param ignoreMissingSegments {@code true} to ignore exceptions caused          *                              by missing segments, {@code false}          *                              otherwise.          * @return this builder.          */         public Builder withIgnoreMissingSegments(boolean ignoreMissingSegments) {             this.ignoreMissingSegments = ignoreMissingSegments;             return this;         }          /**          * Create an executable version of the {@link Diff} command.          *          * @return an instance of {@link Runnable}.          */         public Diff build() {             checkNotNull(path);             checkNotNull(interval);             checkNotNull(out);             checkNotNull(filter);             return new Diff(this);         }      }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8158</td>
    <td align="left">https://github.com/apache/jackrabbit-oak/blob/fa85f54a065e01c0a1cb8c03af74194fdf521ddd/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/tool/Diff.java/#L56-L171</td>
    <td align="right">1</td>
    <td align="right">901</td>
    <td align="right">8158</td>
  </tr>
  <tr valign="top">
    <td align="right">1112</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{       &quot;output&quot;: &quot;YES I found bad smells&quot;,       &quot;detected_bad_smells&quot;: [          &quot;Data Class&quot;       ]    }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Customer1392 {  	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id; 	private String firstName; 	private String lastName;  	protected Customer1392() {}  	public Customer1392(String firstName, String lastName) { 		this.firstName = firstName; 		this.lastName = lastName; 	}  	@Override 	public String toString() { 		return String.format(&quot;Customer1392[id=%d, firstName='%s', lastName='%s']&quot;, id, firstName, lastName); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9894</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer1392.java/#L8-L27</td>
    <td align="right">1</td>
    <td align="right">1112</td>
    <td align="right">9894</td>
  </tr>
  <tr valign="top">
    <td align="right">621</td>
    <td align="left">&nbsp;	{ 		&quot;response&quot;: &quot;YES I found bad smells&quot;, 		&quot;bad_smells&quot;: [ 			&quot;1. Data Class&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class UpdateEntityResponse extends UpdateResponse {   private final V _entity;    public UpdateEntityResponse(final HttpStatus status, final V entity)   {     super(status);     _entity = entity;   }    public boolean hasEntity()   {     return _entity != null;   }    public V getEntity()   {     return _entity;   } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6238</td>
    <td align="left">https://github.com/linkedin/rest.li/blob/ad74aa98da8a55ad9c339d0769a3e8fb495765af/restli-server/src/main/java/com/linkedin/restli/server/UpdateEntityResponse.java/#L31-L50</td>
    <td align="right">1</td>
    <td align="right">621</td>
    <td align="right">6238</td>
  </tr>
  <tr valign="top">
    <td align="right">5090</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class GetOperationCompletedEvent extends OperationCompletedEvent {     private final GetRequest[] requests;     private final GetStatus status;      public GetOperationCompletedEvent(         final EventSource source,         final Workspace workspace,         final GetRequest[] requests,         final GetStatus status) {         super(source, workspace, ProcessType.GET);          Check.notNull(requests, &quot;requests&quot;); //$NON-NLS-1$          this.requests = requests;         this.status = status;     }      /**      * @return the status object produced by the get operation that caused this      *         event. null means the get operation did not fully complete.      */     public GetStatus getStatus() {         return status;     }      /**      * @return the request objects that initiated this get operation.      */     public GetRequest[] getRequests() {         return requests;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14228</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core/src/com/microsoft/tfs/core/clients/versioncontrol/events/GetOperationCompletedEvent.java/#L17-L48</td>
    <td align="right">1</td>
    <td align="right">5090</td>
    <td align="right">14228</td>
  </tr>
  <tr valign="top">
    <td align="right">2453</td>
    <td align="left">&nbsp;{ &quot;output&quot;: &quot;YES I found bad smells. the bad smells are: 1. Data Class&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class NetworkBridgeStatistics extends StatsImpl {      protected CountStatisticImpl enqueues;     protected CountStatisticImpl dequeues;     protected CountStatisticImpl receivedCount;      public NetworkBridgeStatistics() {         enqueues = new CountStatisticImpl(&quot;enqueues&quot;, &quot;The current number of enqueues this bridge has, which is the number of potential messages to be forwarded.&quot;);         dequeues = new CountStatisticImpl(&quot;dequeues&quot;, &quot;The current number of dequeues this bridge has, which is the number of messages received by the remote broker.&quot;);         receivedCount = new CountStatisticImpl(&quot;receivedCount&quot;, &quot;The number of messages that have been received by the NetworkBridge from the remote broker.  Only applies for Duplex bridges.&quot;);          addStatistic(&quot;enqueues&quot;, enqueues);         addStatistic(&quot;dequeues&quot;, dequeues);         addStatistic(&quot;receivedCount&quot;, receivedCount);     }      /**      * The current number of enqueues this bridge has, which is the number of potential messages to be forwarded      * Messages may not be forwarded if there is no subscription      *      * @return      */     public CountStatisticImpl getEnqueues() {         return enqueues;     }      /**      * The current number of dequeues this bridge has, which is the number of      * messages actually sent to and received by the remote broker.      *      * @return      */     public CountStatisticImpl getDequeues() {         return dequeues;     }      /**      * The number of messages that have been received by the NetworkBridge from the remote broker.      * Only applies for Duplex bridges.      *      * @return      */     public CountStatisticImpl getReceivedCount() {         return receivedCount;     }      @Override     public void reset() {         if (this.isDoReset()) {             super.reset();             enqueues.reset();             dequeues.reset();             receivedCount.reset();         }     }      @Override     public void setEnabled(boolean enabled) {         super.setEnabled(enabled);         enqueues.setEnabled(enabled);         dequeues.setEnabled(enabled);         receivedCount.setEnabled(enabled);     }      public void setParent(NetworkBridgeStatistics parent) {         if (parent != null) {             enqueues.setParent(parent.enqueues);             dequeues.setParent(parent.dequeues);             receivedCount.setParent(parent.receivedCount);         } else {             enqueues.setParent(null);             dequeues.setParent(null);             receivedCount.setParent(null);         }     }  }</td>
    <td align="left">data class</td>
    <td align="left">1. data class </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14518</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-broker/src/main/java/org/apache/activemq/network/NetworkBridgeStatistics.java/#L26-L102</td>
    <td align="right">1</td>
    <td align="right">2453</td>
    <td align="right">14518</td>
  </tr>
  <tr valign="top">
    <td align="right">1315</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         {             &quot;1&quot;: &quot;Data Class&quot;         }     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LockMode extends TypesafeEnum {     private LockMode(final int value) {         super(value);     }      /**      * Do not perform any locking. Items are opened for read or write without      * regard to concurrent access by other processes.      */     public static final LockMode NONE = new LockMode(0);      /**      * Wait forever to acquire the lock (or until the thread is interrupted).      */     public static final LockMode WAIT_FOREVER = new LockMode(1);      /**      * Attempt to acquire the lock but return immediately if it could not be      * acquired.      */     public static final LockMode NO_WAIT = new LockMode(2); }</td>
    <td align="left">data class</td>
    <td align="left">1: data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10688</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core/src/com/microsoft/tfs/core/persistence/LockMode.java/#L15-L36</td>
    <td align="right">1</td>
    <td align="right">1315</td>
    <td align="right">10688</td>
  </tr>
  <tr valign="top">
    <td align="right">2534</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ConstantPartitioner implements DocumentPartitioner {    /** The list with a single content type, the default one. */   private final List legalContentTypes;    /** The single content type. */   private final String contentType;    /** The full document length. */   private int documentLength = 0;    /** Handle on the document. */   private DocumentHandle documentHandle;    /**    * Constructor for a {@link ConstantPartitioner} that has a single partition of type ContentType.    *    * @param contentType the single content type    */   public ConstantPartitioner(final String contentType) {     this.contentType = contentType;     this.legalContentTypes = Collections.singletonList(this.contentType);   }    /**    * Constructor for a {@link ConstantPartitioner} that has a single partition of type {@link    * DefaultPartitioner#DEFAULT_CONTENT_TYPE}.    */   public ConstantPartitioner() {     this(DEFAULT_CONTENT_TYPE);   }    @Override   public void onDocumentChanged(final DocumentChangedEvent event) {     final int removed = event.getLength();     int added = 0;     if (event.getText() != null) {       added = event.getText().length();     }     final int sizeDelta = added - removed;     this.documentLength += sizeDelta;   }    @Override   public void initialize() {     this.documentLength = getDocumentHandle().getDocument().getContentsCharCount();   }    @Override   public List getLegalContentTypes() {     return legalContentTypes;   }    @Override   public String getContentType(final int offset) {     return this.contentType;   }    @Override   public List computePartitioning(final int offset, final int length) {     final TypedRegion region = getPartition(offset);     return Collections.singletonList(region);   }    @Override   public TypedRegion getPartition(final int offset) {     return new TypedRegionImpl(offset, this.documentLength, this.contentType);   }    @Override   public DocumentHandle getDocumentHandle() {     return documentHandle;   }    @Override   public void setDocumentHandle(DocumentHandle handle) {     this.documentHandle = handle;   }    @Override   public void release() {} }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14749</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/ide/che-core-ide-api/src/main/java/org/eclipse/che/ide/api/editor/partition/ConstantPartitioner.java/#L22-L103</td>
    <td align="right">1</td>
    <td align="right">2534</td>
    <td align="right">14749</td>
  </tr>
  <tr valign="top">
    <td align="right">1245</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Ipam {   private String driver;   private List config;   private Map options;    public String getDriver() {     return driver;   }    public void setDriver(String driver) {     this.driver = driver;   }    public Ipam withDriver(String driver) {     this.driver = driver;     return this;   }    public List getConfig() {     return config;   }    public void setConfig(List config) {     this.config = config;   }    public Ipam withConfig(List config) {     this.config = config;     return this;   }    public Map getOptions() {     return options;   }    public void setOptions(Map options) {     this.options = options;   }    public Ipam withOptions(Map options) {     this.options = options;     return this;   }    @Override   public boolean equals(Object obj) {     if (this == obj) {       return true;     }     if (!(obj instanceof Ipam)) {       return false;     }     final Ipam that = (Ipam) obj;     return Objects.equals(driver, that.driver)         &amp;&amp; getConfig().equals(that.getConfig())         &amp;&amp; getOptions().equals(that.getOptions());   }    @Override   public int hashCode() {     int hash = 7;     hash = 31 * hash + Objects.hashCode(driver);     hash = 31 * hash + getConfig().hashCode();     hash = 31 * hash + getOptions().hashCode();     return hash;   }    @Override   public String toString() {     return &quot;Ipam{&quot;         + &quot;driver='&quot;         + driver         + '\''         + &quot;, config=&quot;         + config         + &quot;, options=&quot;         + options         + '}';   } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10419</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/infrastructures/docker/docker-client/src/main/java/org/eclipse/che/infrastructure/docker/client/json/network/Ipam.java/#L19-L98</td>
    <td align="right">1</td>
    <td align="right">1245</td>
    <td align="right">10419</td>
  </tr>
  <tr valign="top">
    <td align="right">1199</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells the bad smells are: Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class HandleConfigDriveIsoCommand extends Command {      @LogLevel(LogLevel.Log4jLevel.Off)     private String isoData;      private String isoFile;     private boolean create = false;     private DataStoreTO destStore;      public HandleConfigDriveIsoCommand(String isoFile, String isoData, DataStoreTO destStore, boolean create) {         this.isoFile = isoFile;         this.isoData = isoData;         this.destStore = destStore;         this.create = create;     }      @Override     public boolean executeInSequence() {         return false;     }      public String getIsoData() {         return isoData;     }      public boolean isCreate() {         return create;     }      public DataStoreTO getDestStore() {         return destStore;     }      public String getIsoFile() {         return isoFile;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10278</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/core/src/main/java/com/cloud/agent/api/HandleConfigDriveIsoCommand.java/#L24-L60</td>
    <td align="right">1</td>
    <td align="right">1199</td>
    <td align="right">10278</td>
  </tr>
  <tr valign="top">
    <td align="right">2660</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;answer&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SlaveSynchronize {     private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);     private final BrokerController brokerController;     private volatile String masterAddr = null;      public SlaveSynchronize(BrokerController brokerController) {         this.brokerController = brokerController;     }      public String getMasterAddr() {         return masterAddr;     }      public void setMasterAddr(String masterAddr) {         this.masterAddr = masterAddr;     }      public void syncAll() {         this.syncTopicConfig();         this.syncConsumerOffset();         this.syncDelayOffset();         this.syncSubscriptionGroupConfig();     }      private void syncTopicConfig() {         String masterAddrBak = this.masterAddr;         if (masterAddrBak != null &amp;&amp; !masterAddrBak.equals(brokerController.getBrokerAddr())) {             try {                 TopicConfigSerializeWrapper topicWrapper =                     this.brokerController.getBrokerOuterAPI().getAllTopicConfig(masterAddrBak);                 if (!this.brokerController.getTopicConfigManager().getDataVersion()                     .equals(topicWrapper.getDataVersion())) {                      this.brokerController.getTopicConfigManager().getDataVersion()                         .assignNewOne(topicWrapper.getDataVersion());                     this.brokerController.getTopicConfigManager().getTopicConfigTable().clear();                     this.brokerController.getTopicConfigManager().getTopicConfigTable()                         .putAll(topicWrapper.getTopicConfigTable());                     this.brokerController.getTopicConfigManager().persist();                      log.info(&quot;Update slave topic config from master, {}&quot;, masterAddrBak);                 }             } catch (Exception e) {                 log.error(&quot;SyncTopicConfig Exception, {}&quot;, masterAddrBak, e);             }         }     }      private void syncConsumerOffset() {         String masterAddrBak = this.masterAddr;         if (masterAddrBak != null &amp;&amp; !masterAddrBak.equals(brokerController.getBrokerAddr())) {             try {                 ConsumerOffsetSerializeWrapper offsetWrapper =                     this.brokerController.getBrokerOuterAPI().getAllConsumerOffset(masterAddrBak);                 this.brokerController.getConsumerOffsetManager().getOffsetTable()                     .putAll(offsetWrapper.getOffsetTable());                 this.brokerController.getConsumerOffsetManager().persist();                 log.info(&quot;Update slave consumer offset from master, {}&quot;, masterAddrBak);             } catch (Exception e) {                 log.error(&quot;SyncConsumerOffset Exception, {}&quot;, masterAddrBak, e);             }         }     }      private void syncDelayOffset() {         String masterAddrBak = this.masterAddr;         if (masterAddrBak != null &amp;&amp; !masterAddrBak.equals(brokerController.getBrokerAddr())) {             try {                 String delayOffset =                     this.brokerController.getBrokerOuterAPI().getAllDelayOffset(masterAddrBak);                 if (delayOffset != null) {                      String fileName =                         StorePathConfigHelper.getDelayOffsetStorePath(this.brokerController                             .getMessageStoreConfig().getStorePathRootDir());                     try {                         MixAll.string2File(delayOffset, fileName);                     } catch (IOException e) {                         log.error(&quot;Persist file Exception, {}&quot;, fileName, e);                     }                 }                 log.info(&quot;Update slave delay offset from master, {}&quot;, masterAddrBak);             } catch (Exception e) {                 log.error(&quot;SyncDelayOffset Exception, {}&quot;, masterAddrBak, e);             }         }     }      private void syncSubscriptionGroupConfig() {         String masterAddrBak = this.masterAddr;         if (masterAddrBak != null  &amp;&amp; !masterAddrBak.equals(brokerController.getBrokerAddr())) {             try {                 SubscriptionGroupWrapper subscriptionWrapper =                     this.brokerController.getBrokerOuterAPI()                         .getAllSubscriptionGroupConfig(masterAddrBak);                  if (!this.brokerController.getSubscriptionGroupManager().getDataVersion()                     .equals(subscriptionWrapper.getDataVersion())) {                     SubscriptionGroupManager subscriptionGroupManager =                         this.brokerController.getSubscriptionGroupManager();                     subscriptionGroupManager.getDataVersion().assignNewOne(                         subscriptionWrapper.getDataVersion());                     subscriptionGroupManager.getSubscriptionGroupTable().clear();                     subscriptionGroupManager.getSubscriptionGroupTable().putAll(                         subscriptionWrapper.getSubscriptionGroupTable());                     subscriptionGroupManager.persist();                     log.info(&quot;Update slave Subscription Group from master, {}&quot;, masterAddrBak);                 }             } catch (Exception e) {                 log.error(&quot;SyncSubscriptionGroup Exception, {}&quot;, masterAddrBak, e);             }         }     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15192</td>
    <td align="left">https://github.com/apache/rocketmq/blob/971fa8ed8b209b39bdfe41c57cd64576d244e6bd/broker/src/main/java/org/apache/rocketmq/broker/slave/SlaveSynchronize.java/#L31-L144</td>
    <td align="right">1</td>
    <td align="right">2660</td>
    <td align="right">15192</td>
  </tr>
  <tr valign="top">
    <td align="right">2133</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells the bad smells are:&quot;, &quot;bad_smells&quot;: [&quot;1. Long Method&quot;, &quot;2. Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private long prevRecordEndOffset;      public Offset(long lastSyncPoint, long recordsSinceLastSync, long currentRecord) {       this(lastSyncPoint, recordsSinceLastSync, currentRecord, 0, 0 );     }      public Offset(long lastSyncPoint, long recordsSinceLastSync, long currentRecord                   , long currRecordEndOffset, long prevRecordEndOffset) {       this.lastSyncPoint = lastSyncPoint;       this.recordsSinceLastSync = recordsSinceLastSync;       this.currentRecord = currentRecord;       this.prevRecordEndOffset = prevRecordEndOffset;       this.currRecordEndOffset = currRecordEndOffset;     }      public Offset(String offset) {       try {         if(offset==null) {           throw new IllegalArgumentException(&quot;offset cannot be null&quot;);         }         if(offset.equalsIgnoreCase(&quot;0&quot;)) {           this.lastSyncPoint = 0;           this.recordsSinceLastSync = 0;           this.currentRecord = 0;           this.prevRecordEndOffset = 0;           this.currRecordEndOffset = 0;         } else {           String[] parts = offset.split(&quot;:&quot;);           this.lastSyncPoint = Long.parseLong(parts[0].split(&quot;=&quot;)[1]);           this.recordsSinceLastSync = Long.parseLong(parts[1].split(&quot;=&quot;)[1]);           this.currentRecord = Long.parseLong(parts[2].split(&quot;=&quot;)[1]);           this.prevRecordEndOffset = 0;           this.currRecordEndOffset = 0;         }       } catch (Exception e) {         throw new IllegalArgumentException(&quot;'&quot; + offset +                 &quot;' cannot be interpreted. It is not in expected format for SequenceFileReader.&quot; +                 &quot; Format e.g. {sync=123:afterSync=345:record=67}&quot;);       }     }      @Override     public String toString() {       return '{' +               &quot;sync=&quot; + lastSyncPoint +               &quot;:afterSync=&quot; + recordsSinceLastSync +               &quot;:record=&quot; + currentRecord +               &quot;:}&quot;;     }      @Override     public boolean isNextOffset(FileOffset rhs) {       if(rhs instanceof Offset) {         Offset other = ((Offset) rhs);         return  other.currentRecord &gt; currentRecord+1;       }       return false;     }      @Override     public int compareTo(FileOffset o) {       Offset rhs = ((Offset) o);       if(currentRecord&gt;&gt; 32));     }          void increment(boolean syncSeen, long newBytePosition) {       if(!syncSeen) {         ++recordsSinceLastSync;       }  else {         recordsSinceLastSync = 1;         lastSyncPoint = prevRecordEndOffset;       }       ++currentRecord;       prevRecordEndOffset = currRecordEndOffset;       currentRecord = newBytePosition;     }      @Override     public Offset clone() {       return new Offset(lastSyncPoint, recordsSinceLastSync, currentRecord, currRecordEndOffset, prevRecordEndOffset);     }    } //class Offset } //class</td>
    <td align="left">data class</td>
    <td align="left">1. long method, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13238</td>
    <td align="left">https://github.com/alibaba/jstorm/blob/5d6cde22dbca7df3d6e6830bf94f98a6639ab559/jstorm-hdfs/src/main/java/com/alibaba/jstorm/hdfs/spout/SequenceFileReader.java/#L104-L212</td>
    <td align="right">1</td>
    <td align="right">2133</td>
    <td align="right">13238</td>
  </tr>
  <tr valign="top">
    <td align="right">1201</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;answer&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             &quot;Long Method&quot;,             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ProcessorUtils {     public static final String AVAILABLE_PROCESSORS = &quot;JETTY_AVAILABLE_PROCESSORS&quot;;     private static int __availableProcessors = init();      static int init()     {         String processors = System.getProperty(AVAILABLE_PROCESSORS, System.getenv(AVAILABLE_PROCESSORS));         if (processors != null)         {             try             {                 return Integer.parseInt( processors );             }             catch (NumberFormatException ignored)             {             }         }         return Runtime.getRuntime().availableProcessors();     }      /**      * Returns the number of available processors, from System Property &quot;JETTY_AVAILABLE_PROCESSORS&quot;,      * or if not set then from environment variable &quot;JETTY_AVAILABLE_PROCESSORS&quot; or if not set then      * from {@link Runtime#availableProcessors()}.      *      * @return the number of processors      */     public static int availableProcessors()     {         return __availableProcessors;     }      public static void setAvailableProcessors(int processors)     {         if (processors &lt; 1)             throw new IllegalArgumentException(&quot;Invalid number of processors: &quot; + processors);         __availableProcessors = processors;     } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10284</td>
    <td align="left">https://github.com/eclipse/jetty.project/blob/65528f76c5ef6ddca11385f9721c8f0bc5f2eed7/jetty-util/src/main/java/org/eclipse/jetty/util/ProcessorUtils.java/#L27-L66</td>
    <td align="right">1</td>
    <td align="right">1201</td>
    <td align="right">10284</td>
  </tr>
  <tr valign="top">
    <td align="right">2181</td>
    <td align="left">&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Long Method&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TagTag extends DefineTagSupport {      private String name;      public TagTag() {     }      // Tag interface     //-------------------------------------------------------------------------     public void doTag(XMLOutput output) throws JellyTagException {         getTagLibrary().registerDynamicTag( getName(), getBody() );     }      // Properties     //-------------------------------------------------------------------------      /** @return the name of the tag to create */     public String getName() {         return name;     }      /** Sets the name of the tag to create */     public void setName(String name) {         this.name = name;     } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13416</td>
    <td align="left">https://github.com/apache/commons-jelly/blob/48c008cc2328402e0976295625b32c5197ba2324/jelly-tags/define/src/main/java/org/apache/commons/jelly/tags/define/TagTag.java/#L32-L57</td>
    <td align="right">1</td>
    <td align="right">2181</td>
    <td align="right">13416</td>
  </tr>
  <tr valign="top">
    <td align="right">372</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells the bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class Value {         int        count = 0;         BigInteger txid;     }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">&nbsp; </td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">3859</td>
    <td align="left">https://github.com/alibaba/jstorm/blob/5d6cde22dbca7df3d6e6830bf94f98a6639ab559/example/sequence-split-merge/src/main/java/com/alipay/dw/jstorm/transcation/TransactionalGlobalCount.java/#L93-L96</td>
    <td align="right">1</td>
    <td align="right">372</td>
    <td align="right">3859</td>
  </tr>
  <tr valign="top">
    <td align="right">4093</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;the bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  @XmlAccessorType(XmlAccessType.FIELD)   @XmlType(name = &quot;&quot;, propOrder = {&quot;gateways&quot;})   public static class GatewayHub {      @XmlElement(name = &quot;gateway&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)     protected List gateways;     @XmlAttribute(name = &quot;id&quot;, required = true)     protected String id;     @XmlAttribute(name = &quot;bind-address&quot;)     protected String bindAddress;     @XmlAttribute(name = &quot;maximum-time-between-pings&quot;)     protected String maximumTimeBetweenPings;     @XmlAttribute(name = &quot;port&quot;)     protected String port;     @XmlAttribute(name = &quot;socket-buffer-size&quot;)     protected String socketBufferSize;     @XmlAttribute(name = &quot;startup-policy&quot;)     protected String startupPolicy;     @XmlAttribute(name = &quot;manual-start&quot;)     protected Boolean manualStart;     @XmlAttribute(name = &quot;max-connections&quot;)     protected BigInteger maxConnections;      /**      * Gets the value of the gateway property.      *      *       * This accessor method returns a reference to the live list,      * not a snapshot. Therefore any modification you make to the      * returned list will be present inside the JAXB object.      * This is why there is not a set method for the gateway property.      *      *       * For example, to add a new item, do as follows:      *      *       * getGateway().add(newItem);      *       *      *      *       * Objects of the following type(s) are allowed in the list      * {@link CacheConfig.GatewayHub.Gateway }      *      *      */     public List getGateway() {       if (gateways == null) {         gateways = new ArrayList();       }       return this.gateways;     }      /**      * Gets the value of the id property.      *      * possible object is      * {@link String }      *      */     public String getId() {       return id;     }      /**      * Sets the value of the id property.      *      * allowed object is      * {@link String }      *      */     public void setId(String value) {       this.id = value;     }      /**      * Gets the value of the bindAddress property.      *      * possible object is      * {@link String }      *      */     public String getBindAddress() {       return bindAddress;     }      /**      * Sets the value of the bindAddress property.      *      * allowed object is      * {@link String }      *      */     public void setBindAddress(String value) {       this.bindAddress = value;     }      /**      * Gets the value of the maximumTimeBetweenPings property.      *      * possible object is      * {@link String }      *      */     public String getMaximumTimeBetweenPings() {       return maximumTimeBetweenPings;     }      /**      * Sets the value of the maximumTimeBetweenPings property.      *      * allowed object is      * {@link String }      *      */     public void setMaximumTimeBetweenPings(String value) {       this.maximumTimeBetweenPings = value;     }      /**      * Gets the value of the port property.      *      * possible object is      * {@link String }      *      */     public String getPort() {       return port;     }      /**      * Sets the value of the port property.      *      * allowed object is      * {@link String }      *      */     public void setPort(String value) {       this.port = value;     }      /**      * Gets the value of the socketBufferSize property.      *      * possible object is      * {@link String }      *      */     public String getSocketBufferSize() {       return socketBufferSize;     }      /**      * Sets the value of the socketBufferSize property.      *      * allowed object is      * {@link String }      *      */     public void setSocketBufferSize(String value) {       this.socketBufferSize = value;     }      /**      * Gets the value of the startupPolicy property.      *      * possible object is      * {@link String }      *      */     public String getStartupPolicy() {       return startupPolicy;     }      /**      * Sets the value of the startupPolicy property.      *      * allowed object is      * {@link String }      *      */     public void setStartupPolicy(String value) {       this.startupPolicy = value;     }      /**      * Gets the value of the manualStart property.      *      * possible object is      * {@link Boolean }      *      */     public Boolean isManualStart() {       return manualStart;     }      /**      * Sets the value of the manualStart property.      *      * allowed object is      * {@link Boolean }      *      */     public void setManualStart(Boolean value) {       this.manualStart = value;     }      /**      * Gets the value of the maxConnections property.      *      * possible object is      * {@link BigInteger }      *      */     public BigInteger getMaxConnections() {       return maxConnections;     }      /**      * Sets the value of the maxConnections property.      *      * allowed object is      * {@link BigInteger }      *      */     public void setMaxConnections(BigInteger value) {       this.maxConnections = value;     }       /**      *       * Java class for anonymous complex type.      *      *       * The following schema fragment specifies the expected content contained within this class.      *      *       * &lt;complexType&gt;      *   &lt;complexContent&gt;      *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;      *       &lt;sequence&gt;      *         &lt;choice&gt;      *           &lt;element name=&quot;gateway-endpoint&quot; maxOccurs=&quot;unbounded&quot;&gt;      *             &lt;complexType&gt;      *               &lt;complexContent&gt;      *                 &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;      *                   &lt;attribute name=&quot;host&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                   &lt;attribute name=&quot;id&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                   &lt;attribute name=&quot;port&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;/restriction&gt;      *               &lt;/complexContent&gt;      *             &lt;/complexType&gt;      *           &lt;/element&gt;      *           &lt;element name=&quot;gateway-listener&quot; maxOccurs=&quot;unbounded&quot;&gt;      *             &lt;complexType&gt;      *               &lt;complexContent&gt;      *                 &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;      *                   &lt;sequence&gt;      *                     &lt;element name=&quot;class-name&quot; type=&quot;{http://geode.apache.org/schema/cache}class-name-type&quot;/&gt;      *                     &lt;element name=&quot;parameter&quot; type=&quot;{http://geode.apache.org/schema/cache}parameter-type&quot; maxOccurs=&quot;unbounded&quot; minOccurs=&quot;0&quot;/&gt;      *                   &lt;/sequence&gt;      *                 &lt;/restriction&gt;      *               &lt;/complexContent&gt;      *             &lt;/complexType&gt;      *           &lt;/element&gt;      *         &lt;/choice&gt;      *         &lt;element name=&quot;gateway-queue&quot; minOccurs=&quot;0&quot;&gt;      *           &lt;complexType&gt;      *             &lt;complexContent&gt;      *               &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;      *                 &lt;attribute name=&quot;alert-threshold&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;batch-conflation&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;      *                 &lt;attribute name=&quot;batch-size&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;batch-time-interval&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;enable-persistence&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;      *                 &lt;attribute name=&quot;disk-store-name&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;roll-oplogs&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;      *                 &lt;attribute name=&quot;maximum-queue-memory&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;overflow-directory&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *               &lt;/restriction&gt;      *             &lt;/complexContent&gt;      *           &lt;/complexType&gt;      *         &lt;/element&gt;      *       &lt;/sequence&gt;      *       &lt;attribute name=&quot;early-ack&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;      *       &lt;attribute name=&quot;id&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *       &lt;attribute name=&quot;socket-buffer-size&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *       &lt;attribute name=&quot;socket-read-timeout&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *       &lt;attribute name=&quot;concurrency-level&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *       &lt;attribute name=&quot;order-policy&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *     &lt;/restriction&gt;      *   &lt;/complexContent&gt;      * &lt;/complexType&gt;      *       *      *      */     @XmlAccessorType(XmlAccessType.FIELD)     @XmlType(name = &quot;&quot;, propOrder = {&quot;gatewayEndpoints&quot;, &quot;gatewayListeners&quot;, &quot;gatewayQueue&quot;})     public static class Gateway {        @XmlElement(name = &quot;gateway-endpoint&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)       protected List gatewayEndpoints;       @XmlElement(name = &quot;gateway-listener&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)       protected List gatewayListeners;       @XmlElement(name = &quot;gateway-queue&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)       protected CacheConfig.GatewayHub.Gateway.GatewayQueue gatewayQueue;       @XmlAttribute(name = &quot;early-ack&quot;)       protected Boolean earlyAck;       @XmlAttribute(name = &quot;id&quot;, required = true)       protected String id;       @XmlAttribute(name = &quot;socket-buffer-size&quot;)       protected String socketBufferSize;       @XmlAttribute(name = &quot;socket-read-timeout&quot;)       protected String socketReadTimeout;       @XmlAttribute(name = &quot;concurrency-level&quot;)       protected String concurrencyLevel;       @XmlAttribute(name = &quot;order-policy&quot;)       protected String orderPolicy;        /**        * Gets the value of the gatewayEndpoints property.        *        *         * This accessor method returns a reference to the live list,        * not a snapshot. Therefore any modification you make to the        * returned list will be present inside the JAXB object.        * This is why there is not a set method for the gatewayEndpoints property.        *        *         * For example, to add a new item, do as follows:        *        *         * getGatewayEndpoints().add(newItem);        *         *        *        *         * Objects of the following type(s) are allowed in the list        * {@link CacheConfig.GatewayHub.Gateway.GatewayEndpoint }        *        *        */       public List getGatewayEndpoints() {         if (gatewayEndpoints == null) {           gatewayEndpoints = new ArrayList();         }         return this.gatewayEndpoints;       }        /**        * Gets the value of the gatewayListeners property.        *        *         * This accessor method returns a reference to the live list,        * not a snapshot. Therefore any modification you make to the        * returned list will be present inside the JAXB object.        * This is why there is not a set method for the gatewayListeners property.        *        *         * For example, to add a new item, do as follows:        *        *         * getGatewayListeners().add(newItem);        *         *        *        *         * Objects of the following type(s) are allowed in the list        * {@link DeclarableType }        *        *        */       public List getGatewayListeners() {         if (gatewayListeners == null) {           gatewayListeners = new ArrayList();         }         return this.gatewayListeners;       }        /**        * Gets the value of the gatewayQueue property.        *        * possible object is        * {@link CacheConfig.GatewayHub.Gateway.GatewayQueue }        *        */       public CacheConfig.GatewayHub.Gateway.GatewayQueue getGatewayQueue() {         return gatewayQueue;       }        /**        * Sets the value of the gatewayQueue property.        *        * allowed object is        * {@link CacheConfig.GatewayHub.Gateway.GatewayQueue }        *        */       public void setGatewayQueue(CacheConfig.GatewayHub.Gateway.GatewayQueue value) {         this.gatewayQueue = value;       }        /**        * Gets the value of the earlyAck property.        *        * possible object is        * {@link Boolean }        *        */       public Boolean isEarlyAck() {         return earlyAck;       }        /**        * Sets the value of the earlyAck property.        *        * allowed object is        * {@link Boolean }        *        */       public void setEarlyAck(Boolean value) {         this.earlyAck = value;       }        /**        * Gets the value of the id property.        *        * possible object is        * {@link String }        *        */       public String getId() {         return id;       }        /**        * Sets the value of the id property.        *        * allowed object is        * {@link String }        *        */       public void setId(String value) {         this.id = value;       }        /**        * Gets the value of the socketBufferSize property.        *        * possible object is        * {@link String }        *        */       public String getSocketBufferSize() {         return socketBufferSize;       }        /**        * Sets the value of the socketBufferSize property.        *        * allowed object is        * {@link String }        *        */       public void setSocketBufferSize(String value) {         this.socketBufferSize = value;       }        /**        * Gets the value of the socketReadTimeout property.        *        * possible object is        * {@link String }        *        */       public String getSocketReadTimeout() {         return socketReadTimeout;       }        /**        * Sets the value of the socketReadTimeout property.        *        * allowed object is        * {@link String }        *        */       public void setSocketReadTimeout(String value) {         this.socketReadTimeout = value;       }        /**        * Gets the value of the concurrencyLevel property.        *        * possible object is        * {@link String }        *        */       public String getConcurrencyLevel() {         return concurrencyLevel;       }        /**        * Sets the value of the concurrencyLevel property.        *        * allowed object is        * {@link String }        *        */       public void setConcurrencyLevel(String value) {         this.concurrencyLevel = value;       }        /**        * Gets the value of the orderPolicy property.        *        * possible object is        * {@link String }        *        */       public String getOrderPolicy() {         return orderPolicy;       }        /**        * Sets the value of the orderPolicy property.        *        * allowed object is        * {@link String }        *        */       public void setOrderPolicy(String value) {         this.orderPolicy = value;       }         /**        *         * Java class for anonymous complex type.        *        *         * The following schema fragment specifies the expected content contained within this class.        *        *         * &lt;complexType&gt;        *   &lt;complexContent&gt;        *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;        *       &lt;attribute name=&quot;host&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;id&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;port&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *     &lt;/restriction&gt;        *   &lt;/complexContent&gt;        * &lt;/complexType&gt;        *         *        *        */       @XmlAccessorType(XmlAccessType.FIELD)       @XmlType(name = &quot;&quot;)       public static class GatewayEndpoint {          @XmlAttribute(name = &quot;host&quot;, required = true)         protected String host;         @XmlAttribute(name = &quot;id&quot;, required = true)         protected String id;         @XmlAttribute(name = &quot;port&quot;, required = true)         protected String port;          /**          * Gets the value of the host property.          *          * possible object is          * {@link String }          *          */         public String getHost() {           return host;         }          /**          * Sets the value of the host property.          *          * allowed object is          * {@link String }          *          */         public void setHost(String value) {           this.host = value;         }          /**          * Gets the value of the id property.          *          * possible object is          * {@link String }          *          */         public String getId() {           return id;         }          /**          * Sets the value of the id property.          *          * allowed object is          * {@link String }          *          */         public void setId(String value) {           this.id = value;         }          /**          * Gets the value of the port property.          *          * possible object is          * {@link String }          *          */         public String getPort() {           return port;         }          /**          * Sets the value of the port property.          *          * allowed object is          * {@link String }          *          */         public void setPort(String value) {           this.port = value;         }        }        /**        *         * Java class for anonymous complex type.        *        *         * The following schema fragment specifies the expected content contained within this class.        *        *         * &lt;complexType&gt;        *   &lt;complexContent&gt;        *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;        *       &lt;attribute name=&quot;alert-threshold&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;batch-conflation&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;        *       &lt;attribute name=&quot;batch-size&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;batch-time-interval&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;enable-persistence&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;        *       &lt;attribute name=&quot;disk-store-name&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;roll-oplogs&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;        *       &lt;attribute name=&quot;maximum-queue-memory&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;overflow-directory&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *     &lt;/restriction&gt;        *   &lt;/complexContent&gt;        * &lt;/complexType&gt;        *         *        *        */       @XmlAccessorType(XmlAccessType.FIELD)       @XmlType(name = &quot;&quot;)       public static class GatewayQueue {          @XmlAttribute(name = &quot;alert-threshold&quot;)         protected String alertThreshold;         @XmlAttribute(name = &quot;batch-conflation&quot;)         protected Boolean batchConflation;         @XmlAttribute(name = &quot;batch-size&quot;)         protected String batchSize;         @XmlAttribute(name = &quot;batch-time-interval&quot;)         protected String batchTimeInterval;         @XmlAttribute(name = &quot;enable-persistence&quot;)         protected Boolean enablePersistence;         @XmlAttribute(name = &quot;disk-store-name&quot;)         protected String diskStoreName;         @XmlAttribute(name = &quot;roll-oplogs&quot;)         protected Boolean rollOplogs;         @XmlAttribute(name = &quot;maximum-queue-memory&quot;)         protected String maximumQueueMemory;         @XmlAttribute(name = &quot;overflow-directory&quot;)         protected String overflowDirectory;          /**          * Gets the value of the alertThreshold property.          *          * possible object is          * {@link String }          *          */         public String getAlertThreshold() {           return alertThreshold;         }          /**          * Sets the value of the alertThreshold property.          *          * allowed object is          * {@link String }          *          */         public void setAlertThreshold(String value) {           this.alertThreshold = value;         }          /**          * Gets the value of the batchConflation property.          *          * possible object is          * {@link Boolean }          *          */         public Boolean isBatchConflation() {           return batchConflation;         }          /**          * Sets the value of the batchConflation property.          *          * allowed object is          * {@link Boolean }          *          */         public void setBatchConflation(Boolean value) {           this.batchConflation = value;         }          /**          * Gets the value of the batchSize property.          *          * possible object is          * {@link String }          *          */         public String getBatchSize() {           return batchSize;         }          /**          * Sets the value of the batchSize property.          *          * allowed object is          * {@link String }          *          */         public void setBatchSize(String value) {           this.batchSize = value;         }          /**          * Gets the value of the batchTimeInterval property.          *          * possible object is          * {@link String }          *          */         public String getBatchTimeInterval() {           return batchTimeInterval;         }          /**          * Sets the value of the batchTimeInterval property.          *          * allowed object is          * {@link String }          *          */         public void setBatchTimeInterval(String value) {           this.batchTimeInterval = value;         }          /**          * Gets the value of the enablePersistence property.          *          * possible object is          * {@link Boolean }          *          */         public Boolean isEnablePersistence() {           return enablePersistence;         }          /**          * Sets the value of the enablePersistence property.          *          * allowed object is          * {@link Boolean }          *          */         public void setEnablePersistence(Boolean value) {           this.enablePersistence = value;         }          /**          * Gets the value of the diskStoreName property.          *          * possible object is          * {@link String }          *          */         public String getDiskStoreName() {           return diskStoreName;         }          /**          * Sets the value of the diskStoreName property.          *          * allowed object is          * {@link String }          *          */         public void setDiskStoreName(String value) {           this.diskStoreName = value;         }          /**          * Gets the value of the rollOplogs property.          *          * possible object is          * {@link Boolean }          *          */         public Boolean isRollOplogs() {           return rollOplogs;         }          /**          * Sets the value of the rollOplogs property.          *          * allowed object is          * {@link Boolean }          *          */         public void setRollOplogs(Boolean value) {           this.rollOplogs = value;         }          /**          * Gets the value of the maximumQueueMemory property.          *          * possible object is          * {@link String }          *          */         public String getMaximumQueueMemory() {           return maximumQueueMemory;         }          /**          * Sets the value of the maximumQueueMemory property.          *          * allowed object is          * {@link String }          *          */         public void setMaximumQueueMemory(String value) {           this.maximumQueueMemory = value;         }          /**          * Gets the value of the overflowDirectory property.          *          * possible object is          * {@link String }          *          */         public String getOverflowDirectory() {           return overflowDirectory;         }          /**          * Sets the value of the overflowDirectory property.          *          * allowed object is          * {@link String }          *          */         public void setOverflowDirectory(String value) {           this.overflowDirectory = value;         }        }      }    }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10786</td>
    <td align="left">https://github.com/apache/geode/blob/8fd839e8b73e40bd2dfd14f331b587431bd35a66/geode-management/src/main/java/org/apache/geode/cache/configuration/CacheConfig.java/#L1636-L2524</td>
    <td align="right">1</td>
    <td align="right">4093</td>
    <td align="right">10786</td>
  </tr>
  <tr valign="top">
    <td align="right">2286</td>
    <td align="left">&nbsp;&nbsp;YES I found bad smells The bad smells are: 1. Long parameter list, 2. Long method, 3. Feature envy (getFullContentOctets), 4. Inappropriate intimacy (The class has access to the internals of SharedInputStream rather than using encapsulation), 5. Inconsistent naming conventions (size and textualLineCount variables start with lowercase but subType and mediaType start with uppercase), 6. Data class (only contains data and no behavior), 7. Inconsistent importing (some classes are imported with the full package name, others are not), 8. Lack of documentation or comments, 9. Duplication of code (the second constructor calls the first one), 10. Primitive obsession (use of primitive data types rather than creating custom objects), 11. Unnecessary constructor (the second constructor is not needed since it just calls the first one with an additional parameter), 12. Lack of cohesion (the class handles both message properties and attachments), 13. Unnecessary public access modifiers (the methods could be made private since they are only used within the class), 14. Lack of abstraction (the class directly accesses the SharedInputStream rather than using a more abstract layer).</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class SimpleMessage implements Message {      private final MessageId messageId;     private final String subType;     private final String mediaType;     private final SharedInputStream content;     private final int bodyStartOctet;     private final Date internalDate;     private final long size;     private final Long textualLineCount;     private final List properties;     private final List attachments;      public SimpleMessage(MessageId messageId, SharedInputStream content, long size, Date internalDate, String subType, String mediaType, int bodyStartOctet, Long textualLineCount, List properties, List attachments) {         this.messageId = messageId;         this.subType = subType;         this.mediaType = mediaType;         this.content = content;         this.bodyStartOctet = bodyStartOctet;         this.internalDate = internalDate;         this.size = size;         this.textualLineCount = textualLineCount;         this.properties = properties;         this.attachments = attachments;     }      public SimpleMessage(MessageId messageId, SharedInputStream content, long size, Date internalDate, String subType, String mediaType, int bodyStartOctet, Long textualLineCount, List properties) {         this(messageId, content, size, internalDate, subType, mediaType, bodyStartOctet, textualLineCount, properties, ImmutableList.of());     }      @Override     public MessageId getMessageId() {         return messageId;     }      @Override     public Date getInternalDate() {         return internalDate;     }      @Override     public InputStream getBodyContent() throws IOException {         return content.newStream(bodyStartOctet, -1);     }      @Override     public String getMediaType() {         return mediaType;     }      @Override     public String getSubType() {         return subType;     }      @Override     public long getBodyOctets() {         return getFullContentOctets() - bodyStartOctet;     }      @Override     public long getHeaderOctets() {         return bodyStartOctet;     }      @Override     public long getFullContentOctets() {         return size;     }      @Override     public Long getTextualLineCount() {         return textualLineCount;     }      @Override     public InputStream getHeaderContent() throws IOException {         long headerEnd = bodyStartOctet;         if (headerEnd &lt; 0) {             headerEnd = 0;         }         return content.newStream(0, headerEnd);     }      @Override     public InputStream getFullContent() throws IOException {         return content.newStream(0, -1);     }      @Override     public List getProperties() {         return properties;     }      @Override     public List getAttachments() {         return attachments;     } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long parameter list, 2 Long method, 3 Feature envy (getFullContentOctets), 4 Inappropriate intimacy (The class has access to the internals of SharedInputStream rather than using encapsulation), 5 Inconsistent naming conventions (size and textualLineCount variables start with lowercase but subType and mediaType start with uppercase), 6 Data class (only contains data and no behavior), 7 Inconsistent importing (some classes are imported with the full package name, others are not), 8 Lack of documentation or comments, 9 Duplication of code (the second constructor calls the first one), </td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">. Long parameter list,  2. Long method,  3. Feature envy (getFullContentOctets),  4. Inappropriate intimacy (The class has access to the internals of SharedInputStream rather than using encapsulation),  5. Inconsistent naming conventions (size and textualLineCount variables start with lowercase but subType and mediaType start with uppercase),  7. Inconsistent importing (some classes are imported with the full package name,  others are not),  8. Lack of documentation or comments,  9. Duplication of code (the second constructor calls the first one),  </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13880</td>
    <td align="left">https://github.com/apache/james-project/blob/fa24a096a5853459c3769a34ccc68feb91626bfa/mailbox/store/src/main/java/org/apache/james/mailbox/store/mail/model/impl/SimpleMessage.java/#L35-L133</td>
    <td align="right">2</td>
    <td align="right">2286</td>
    <td align="right">13880</td>
  </tr>
  <tr valign="top">
    <td align="right">2</td>
    <td align="left">{&quot;message&quot;:&quot;YES I found bad smells&quot;,&quot;the bad smells are&quot;:[&quot;Long Method&quot;,&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class UnorderedPartitionedKVWriter extends BaseUnorderedPartitionedKVWriter {    private static final Logger LOG = LoggerFactory.getLogger(UnorderedPartitionedKVWriter.class);    private static final int INT_SIZE = 4;   private static final int NUM_META = 3; // Number of meta fields.   private static final int INDEX_KEYLEN = 0; // KeyLength index   private static final int INDEX_VALLEN = 1; // ValLength index   private static final int INDEX_NEXT = 2; // Next Record Index.   private static final int META_SIZE = NUM_META * INT_SIZE; // Size of total meta-data    private final static int APPROX_HEADER_LENGTH = 150;    // Maybe setup a separate statistics class which can be shared between the   // buffer and the main path instead of having multiple arrays.    private final String destNameTrimmed;   private final long availableMemory;   @VisibleForTesting   final WrappedBuffer[] buffers;   @VisibleForTesting   final BlockingQueue availableBuffers;   private final ByteArrayOutputStream baos;   private final NonSyncDataOutputStream dos;   @VisibleForTesting   WrappedBuffer currentBuffer;   private final FileSystem rfs;    @VisibleForTesting   final List spillInfoList = Collections.synchronizedList(new ArrayList());    private final ListeningExecutorService spillExecutor;    private final int[] numRecordsPerPartition;   private long localOutputRecordBytesCounter;   private long localOutputBytesWithOverheadCounter;   private long localOutputRecordsCounter;   // notify after x records   private static final int NOTIFY_THRESHOLD = 1000;   // uncompressed size for each partition   private final long[] sizePerPartition;   private volatile long spilledSize = 0;    static final ThreadLocal deflater = new ThreadLocal() {      @Override     public Deflater initialValue() {       return TezCommonUtils.newBestCompressionDeflater();     }      @Override     public Deflater get() {       Deflater deflater = super.get();       deflater.reset();       return deflater;     }   };    private final Semaphore availableSlots;    /**    * Represents final number of records written (spills are not counted)    */   protected final TezCounter outputLargeRecordsCounter;    @VisibleForTesting   int numBuffers;   @VisibleForTesting   int sizePerBuffer;   @VisibleForTesting   int lastBufferSize;   @VisibleForTesting   int numInitializedBuffers;   @VisibleForTesting   int spillLimit;    private Throwable spillException;   private AtomicBoolean isShutdown = new AtomicBoolean(false);   @VisibleForTesting   final AtomicInteger numSpills = new AtomicInteger(0);   private final AtomicInteger pendingSpillCount = new AtomicInteger(0);    @VisibleForTesting   Path finalIndexPath;   @VisibleForTesting   Path finalOutPath;    //for single partition cases (e.g UnorderedKVOutput)   private final IFile.Writer writer;   @VisibleForTesting   final boolean skipBuffers;    private final ReentrantLock spillLock = new ReentrantLock();   private final Condition spillInProgress = spillLock.newCondition();    private final boolean pipelinedShuffle;   private final boolean isFinalMergeEnabled;   // To store events when final merge is disabled   private final List finalEvents;   // How partition stats should be reported.   final ReportPartitionStats reportPartitionStats;    private final long indexFileSizeEstimate;    private List filledBuffers = new ArrayList&lt;&gt;();    public UnorderedPartitionedKVWriter(OutputContext outputContext, Configuration conf,       int numOutputs, long availableMemoryBytes) throws IOException {     super(outputContext, conf, numOutputs);      Preconditions.checkArgument(availableMemoryBytes &gt;= 0, &quot;availableMemory should be &gt;= 0 bytes&quot;);      this.destNameTrimmed = TezUtilsInternal.cleanVertexName(outputContext.getDestinationVertexName());     //Not checking for TEZ_RUNTIME_ENABLE_FINAL_MERGE_IN_OUTPUT as it might not add much value in     // this case.  Add it later if needed.     boolean pipelinedShuffleConf = this.conf.getBoolean(TezRuntimeConfiguration         .TEZ_RUNTIME_PIPELINED_SHUFFLE_ENABLED, TezRuntimeConfiguration         .TEZ_RUNTIME_PIPELINED_SHUFFLE_ENABLED_DEFAULT);     this.isFinalMergeEnabled = conf.getBoolean(         TezRuntimeConfiguration.TEZ_RUNTIME_ENABLE_FINAL_MERGE_IN_OUTPUT,         TezRuntimeConfiguration.TEZ_RUNTIME_ENABLE_FINAL_MERGE_IN_OUTPUT_DEFAULT);     this.pipelinedShuffle = pipelinedShuffleConf &amp;&amp; !isFinalMergeEnabled;     this.finalEvents = Lists.newLinkedList();      if (availableMemoryBytes == 0) {       Preconditions.checkArgument(((numPartitions == 1) &amp;&amp; !pipelinedShuffle), &quot;availableMemory &quot;           + &quot;can be set to 0 only when numPartitions=1 and &quot; + TezRuntimeConfiguration           .TEZ_RUNTIME_PIPELINED_SHUFFLE_ENABLED + &quot; is disabled. current numPartitions=&quot; +           numPartitions + &quot;, &quot; + TezRuntimeConfiguration.TEZ_RUNTIME_PIPELINED_SHUFFLE_ENABLED + &quot;=&quot;           + pipelinedShuffle);     }      // Ideally, should be significantly larger.     availableMemory = availableMemoryBytes;      // Allow unit tests to control the buffer sizes.     int maxSingleBufferSizeBytes = conf.getInt(         TezRuntimeConfiguration.TEZ_RUNTIME_UNORDERED_OUTPUT_MAX_PER_BUFFER_SIZE_BYTES,         Integer.MAX_VALUE);     computeNumBuffersAndSize(maxSingleBufferSizeBytes);      availableBuffers = new LinkedBlockingQueue();     buffers = new WrappedBuffer[numBuffers];     // Set up only the first buffer to start with.     buffers[0] = new WrappedBuffer(numOutputs, sizePerBuffer);     numInitializedBuffers = 1;     if (LOG.isDebugEnabled()) {       LOG.debug(destNameTrimmed + &quot;: &quot; + &quot;Initializing Buffer #&quot; +           numInitializedBuffers + &quot; with size=&quot; + sizePerBuffer);     }     currentBuffer = buffers[0];     baos = new ByteArrayOutputStream();     dos = new NonSyncDataOutputStream(baos);     keySerializer.open(dos);     valSerializer.open(dos);     rfs = ((LocalFileSystem) FileSystem.getLocal(this.conf)).getRaw();      int maxThreads = Math.max(2, numBuffers/2);     //TODO: Make use of TezSharedExecutor later     ExecutorService executor = new ThreadPoolExecutor(1, maxThreads,         60L, TimeUnit.SECONDS,         new SynchronousQueue(),         new ThreadFactoryBuilder()             .setDaemon(true)             .setNameFormat(                 &quot;UnorderedOutSpiller {&quot; + TezUtilsInternal.cleanVertexName(                     outputContext.getDestinationVertexName()) + &quot;} #%d&quot;)             .build()     );     // to restrict submission of more tasks than threads (e.g numBuffers &gt; numThreads)     // This is maxThreads - 1, to avoid race between callback thread releasing semaphore and the     // thread calling tryAcquire.     availableSlots = new Semaphore(maxThreads - 1, true);     spillExecutor = MoreExecutors.listeningDecorator(executor);     numRecordsPerPartition = new int[numPartitions];     reportPartitionStats = ReportPartitionStats.fromString(         conf.get(TezRuntimeConfiguration.TEZ_RUNTIME_REPORT_PARTITION_STATS,         TezRuntimeConfiguration.TEZ_RUNTIME_REPORT_PARTITION_STATS_DEFAULT));     sizePerPartition = (reportPartitionStats.isEnabled()) ?         new long[numPartitions] : null;      outputLargeRecordsCounter = outputContext.getCounters().findCounter(         TaskCounter.OUTPUT_LARGE_RECORDS);        indexFileSizeEstimate = numPartitions * Constants.MAP_OUTPUT_INDEX_RECORD_LENGTH;      if (numPartitions == 1 &amp;&amp; !pipelinedShuffle) {       //special case, where in only one partition is available.       finalOutPath = outputFileHandler.getOutputFileForWrite();       finalIndexPath = outputFileHandler.getOutputIndexFileForWrite(indexFileSizeEstimate);       skipBuffers = true;       writer = new IFile.Writer(conf, rfs, finalOutPath, keyClass, valClass,           codec, outputRecordsCounter, outputRecordBytesCounter);     } else {       skipBuffers = false;       writer = null;     }     LOG.info(destNameTrimmed + &quot;: &quot;         + &quot;numBuffers=&quot; + numBuffers         + &quot;, sizePerBuffer=&quot; + sizePerBuffer         + &quot;, skipBuffers=&quot; + skipBuffers         + &quot;, numPartitions=&quot; + numPartitions         + &quot;, availableMemory=&quot; + availableMemory         + &quot;, maxSingleBufferSizeBytes=&quot; + maxSingleBufferSizeBytes         + &quot;, pipelinedShuffle=&quot; + pipelinedShuffle         + &quot;, isFinalMergeEnabled=&quot; + isFinalMergeEnabled         + &quot;, numPartitions=&quot; + numPartitions         + &quot;, reportPartitionStats=&quot; + reportPartitionStats);   }    private static final int ALLOC_OVERHEAD = 64;   private void computeNumBuffersAndSize(int bufferLimit) {     numBuffers = (int)(availableMemory / bufferLimit);      if (numBuffers &gt;= 2) {       sizePerBuffer = bufferLimit - ALLOC_OVERHEAD;       lastBufferSize = (int)(availableMemory % bufferLimit);       // Use leftover memory last buffer only if the leftover memory &gt; 50% of bufferLimit       if (lastBufferSize &gt; bufferLimit / 2) {         numBuffers += 1;       } else {         if (lastBufferSize &gt; 0) {           LOG.warn(&quot;Underallocating memory. Unused memory size: {}.&quot;,  lastBufferSize);         }         lastBufferSize = sizePerBuffer;       }     } else {       // We should have minimum of 2 buffers.       numBuffers = 2;       if (availableMemory / numBuffers &gt; Integer.MAX_VALUE) {         sizePerBuffer = Integer.MAX_VALUE;       } else {         sizePerBuffer = (int)(availableMemory / numBuffers);       }       // 2 equal sized buffers.       lastBufferSize = sizePerBuffer;     }     // Ensure allocation size is multiple of INT_SIZE, truncate down.     sizePerBuffer = sizePerBuffer - (sizePerBuffer % INT_SIZE);     lastBufferSize = lastBufferSize - (lastBufferSize % INT_SIZE);      int mergePercent = conf.getInt(         TezRuntimeConfiguration.TEZ_RUNTIME_UNORDERED_PARTITIONED_KVWRITER_BUFFER_MERGE_PERCENT,         TezRuntimeConfiguration.TEZ_RUNTIME_UNORDERED_PARTITIONED_KVWRITER_BUFFER_MERGE_PERCENT_DEFAULT);     spillLimit = numBuffers * mergePercent / 100;     // Keep within limits.     if (spillLimit &lt; 1) {       spillLimit = 1;     }     if (spillLimit &gt; numBuffers) {       spillLimit = numBuffers;     }   }    @Override   public void write(Object key, Object value) throws IOException {     // Skipping checks for key-value types. IFile takes care of these, but should be removed from     // there as well.      // How expensive are checks like these ?     if (isShutdown.get()) {       throw new RuntimeException(&quot;Writer already closed&quot;);     }     if (spillException != null) {       // Already reported as a fatalError - report to the user code       throw new IOException(&quot;Exception during spill&quot;, new IOException(spillException));     }     if (skipBuffers) {       //special case, where we have only one partition and pipelining is disabled.       // The reason outputRecordsCounter isn't updated here:       // For skipBuffers case, IFile writer has the reference to       // outputRecordsCounter and during its close method call,       // it will update the outputRecordsCounter.       writer.append(key, value);       outputContext.notifyProgress();     } else {       int partition = partitioner.getPartition(key, value, numPartitions);       write(key, value, partition);     }   }    @SuppressWarnings(&quot;unchecked&quot;)   private void write(Object key, Object value, int partition) throws IOException {     // Wrap to 4 byte (Int) boundary for metaData     int mod = currentBuffer.nextPosition % INT_SIZE;     int metaSkip = mod == 0 ? 0 : (INT_SIZE - mod);     if ((currentBuffer.availableSize &lt; (META_SIZE + metaSkip)) || (currentBuffer.full)) {       // Move over to the next buffer.       metaSkip = 0;       setupNextBuffer();     }     currentBuffer.nextPosition += metaSkip;     int metaStart = currentBuffer.nextPosition;     currentBuffer.availableSize -= (META_SIZE + metaSkip);     currentBuffer.nextPosition += META_SIZE;      keySerializer.serialize(key);      if (currentBuffer.full) {       if (metaStart == 0) { // Started writing at the start of the buffer. Write Key to disk.         // Key too large for any buffer. Write entire record to disk.         currentBuffer.reset();         writeLargeRecord(key, value, partition);         return;       } else { // Exceeded length on current buffer.         // Try resetting the buffer to the next one, if this was not the start of a buffer,         // and begin spilling the current buffer to disk if it has any records.         setupNextBuffer();         write(key, value, partition);         return;       }     }      int valStart = currentBuffer.nextPosition;     valSerializer.serialize(value);      if (currentBuffer.full) {       // Value too large for current buffer, or K-V too large for entire buffer.       if (metaStart == 0) {         // Key + Value too large for a single buffer.         currentBuffer.reset();         writeLargeRecord(key, value, partition);         return;       } else { // Exceeded length on current buffer.         // Try writing key+value to a new buffer - will fall back to disk if that fails.         setupNextBuffer();         write(key, value, partition);         return;       }     }      // Meta-data updates     int metaIndex = metaStart / INT_SIZE;     int indexNext = currentBuffer.partitionPositions[partition];      currentBuffer.metaBuffer.put(metaIndex + INDEX_KEYLEN, (valStart - (metaStart + META_SIZE)));     currentBuffer.metaBuffer.put(metaIndex + INDEX_VALLEN, (currentBuffer.nextPosition - valStart));     currentBuffer.metaBuffer.put(metaIndex + INDEX_NEXT, indexNext);     currentBuffer.skipSize += metaSkip; // For size estimation     // Update stats on number of records     localOutputRecordBytesCounter += (currentBuffer.nextPosition - (metaStart + META_SIZE));     localOutputBytesWithOverheadCounter += ((currentBuffer.nextPosition - metaStart) + metaSkip);     localOutputRecordsCounter++;     if (localOutputRecordBytesCounter % NOTIFY_THRESHOLD == 0) {       updateTezCountersAndNotify();     }     currentBuffer.partitionPositions[partition] = metaStart;     currentBuffer.recordsPerPartition[partition]++;     currentBuffer.sizePerPartition[partition] +=         currentBuffer.nextPosition - (metaStart + META_SIZE);     currentBuffer.numRecords++;    }    private void updateTezCountersAndNotify() {     outputRecordBytesCounter.increment(localOutputRecordBytesCounter);     outputBytesWithOverheadCounter.increment(localOutputBytesWithOverheadCounter);     outputRecordsCounter.increment(localOutputRecordsCounter);     outputContext.notifyProgress();     localOutputRecordBytesCounter = 0;     localOutputBytesWithOverheadCounter = 0;     localOutputRecordsCounter = 0;   }    private void setupNextBuffer() throws IOException {      if (currentBuffer.numRecords == 0) {       currentBuffer.reset();     } else {       // Update overall stats       final int filledBufferCount = filledBuffers.size();       if (LOG.isDebugEnabled() || (filledBufferCount % 10) == 0) {         LOG.info(destNameTrimmed + &quot;: &quot; + &quot;Moving to next buffer. Total filled buffers: &quot; + filledBufferCount);       }       updateGlobalStats(currentBuffer);        filledBuffers.add(currentBuffer);       mayBeSpill(false);        currentBuffer = getNextAvailableBuffer();        // in case spill threads are free, check if spilling is needed       mayBeSpill(false);     }   }    private void mayBeSpill(boolean shouldBlock) throws IOException {     if (filledBuffers.size() &gt;= spillLimit) {       // Do not block; possible that there are more buffers       scheduleSpill(shouldBlock);     }   }    private boolean scheduleSpill(boolean block) throws IOException {     if (filledBuffers.isEmpty()) {       return false;     }      try {       if (block) {         availableSlots.acquire();       } else {         if (!availableSlots.tryAcquire()) {           // Data in filledBuffers would be spilled in subsequent iteration.           return false;         }       }        final int filledBufferCount = filledBuffers.size();       if (LOG.isDebugEnabled() || (filledBufferCount % 10) == 0) {         LOG.info(destNameTrimmed + &quot;: triggering spill. filledBuffers.size=&quot; + filledBufferCount);       }       pendingSpillCount.incrementAndGet();       int spillNumber = numSpills.getAndIncrement();        ListenableFuture future = spillExecutor.submit(new SpillCallable(           new ArrayList(filledBuffers), codec, spilledRecordsCounter,           spillNumber));       filledBuffers.clear();       Futures.addCallback(future, new SpillCallback(spillNumber));       // Update once per buffer (instead of every record)       updateTezCountersAndNotify();       return true;     } catch(InterruptedException ie) {       Thread.currentThread().interrupt(); // reset interrupt status     }     return false;   }    private boolean reportPartitionStats() {     return (sizePerPartition != null);   }    private void updateGlobalStats(WrappedBuffer buffer) {     for (int i = 0; i &lt; numPartitions; i++) {       numRecordsPerPartition[i] += buffer.recordsPerPartition[i];       if (reportPartitionStats()) {         sizePerPartition[i] += buffer.sizePerPartition[i];       }     }   }    private WrappedBuffer getNextAvailableBuffer() throws IOException {     if (availableBuffers.peek() == null) {       if (numInitializedBuffers &lt; numBuffers) {         buffers[numInitializedBuffers] = new WrappedBuffer(numPartitions,             numInitializedBuffers == numBuffers - 1 ? lastBufferSize : sizePerBuffer);         numInitializedBuffers++;         return buffers[numInitializedBuffers - 1];       } else {         // All buffers initialized, and none available right now. Wait         try {           // Ensure that spills are triggered so that buffers can be released.           mayBeSpill(true);           return availableBuffers.take();         } catch (InterruptedException e) {           Thread.currentThread().interrupt();           throw new IOInterruptedException(&quot;Interrupted while waiting for next buffer&quot;, e);         }       }     } else {       return availableBuffers.poll();     }   }    // All spills using compression for now.   private class SpillCallable extends CallableWithNdc {      private final List filledBuffers;     private final CompressionCodec codec;     private final TezCounter numRecordsCounter;     private int spillIndex;     private SpillPathDetails spillPathDetails;     private int spillNumber;      public SpillCallable(List filledBuffers, CompressionCodec codec,         TezCounter numRecordsCounter, SpillPathDetails spillPathDetails) {       this(filledBuffers, codec, numRecordsCounter, spillPathDetails.spillIndex);       Preconditions.checkArgument(spillPathDetails.outputFilePath != null, &quot;Spill output file &quot;           + &quot;path can not be null&quot;);       this.spillPathDetails = spillPathDetails;     }      public SpillCallable(List filledBuffers, CompressionCodec codec,         TezCounter numRecordsCounter, int spillNumber) {       this.filledBuffers = filledBuffers;       this.codec = codec;       this.numRecordsCounter = numRecordsCounter;       this.spillNumber = spillNumber;     }      @Override     protected SpillResult callInternal() throws IOException {       // This should not be called with an empty buffer. Check before invoking.        // Number of parallel spills determined by number of threads.       // Last spill synchronization handled separately.       SpillResult spillResult = null;       if (spillPathDetails == null) {         this.spillPathDetails = getSpillPathDetails(false, -1, spillNumber);         this.spillIndex = spillPathDetails.spillIndex;       }       LOG.info(&quot;Writing spill &quot; + spillNumber + &quot; to &quot; + spillPathDetails.outputFilePath.toString());       FSDataOutputStream out = rfs.create(spillPathDetails.outputFilePath);       if (!SPILL_FILE_PERMS.equals(SPILL_FILE_PERMS.applyUMask(FsPermission.getUMask(conf)))) {         rfs.setPermission(spillPathDetails.outputFilePath, SPILL_FILE_PERMS);       }       TezSpillRecord spillRecord = new TezSpillRecord(numPartitions);       DataInputBuffer key = new DataInputBuffer();       DataInputBuffer val = new DataInputBuffer();       long compressedLength = 0;       for (int i = 0; i &lt; numPartitions; i++) {         IFile.Writer writer = null;         try {           long segmentStart = out.getPos();           long numRecords = 0;           for (WrappedBuffer buffer : filledBuffers) {             outputContext.notifyProgress();             if (buffer.partitionPositions[i] == WrappedBuffer.PARTITION_ABSENT_POSITION) {               // Skip empty partition.               continue;             }             if (writer == null) {               writer = new Writer(conf, out, keyClass, valClass, codec, null, null);             }             numRecords += writePartition(buffer.partitionPositions[i], buffer, writer, key, val);           }           if (writer != null) {             if (numRecordsCounter != null) {               // TezCounter is not threadsafe; Since numRecordsCounter would be updated from               // multiple threads, it is good to synchronize it when incrementing it for correctness.               synchronized (numRecordsCounter) {                 numRecordsCounter.increment(numRecords);               }             }             writer.close();             compressedLength += writer.getCompressedLength();             TezIndexRecord indexRecord = new TezIndexRecord(segmentStart, writer.getRawLength(),                 writer.getCompressedLength());             spillRecord.putIndex(indexRecord, i);             writer = null;           }         } finally {           if (writer != null) {             writer.close();           }         }       }       key.close();       val.close();        spillResult = new SpillResult(compressedLength, this.filledBuffers);        handleSpillIndex(spillPathDetails, spillRecord);       LOG.info(destNameTrimmed + &quot;: &quot; + &quot;Finished spill &quot; + spillIndex);        if (LOG.isDebugEnabled()) {         LOG.debug(destNameTrimmed + &quot;: &quot; + &quot;Spill=&quot; + spillIndex + &quot;, indexPath=&quot;             + spillPathDetails.indexFilePath + &quot;, outputPath=&quot; + spillPathDetails.outputFilePath);       }       return spillResult;     }   }    private long writePartition(int pos, WrappedBuffer wrappedBuffer, Writer writer,       DataInputBuffer keyBuffer, DataInputBuffer valBuffer) throws IOException {     long numRecords = 0;     while (pos != WrappedBuffer.PARTITION_ABSENT_POSITION) {       int metaIndex = pos / INT_SIZE;       int keyLength = wrappedBuffer.metaBuffer.get(metaIndex + INDEX_KEYLEN);       int valLength = wrappedBuffer.metaBuffer.get(metaIndex + INDEX_VALLEN);       keyBuffer.reset(wrappedBuffer.buffer, pos + META_SIZE, keyLength);       valBuffer.reset(wrappedBuffer.buffer, pos + META_SIZE + keyLength, valLength);        writer.append(keyBuffer, valBuffer);       numRecords++;       pos = wrappedBuffer.metaBuffer.get(metaIndex + INDEX_NEXT);     }     return numRecords;   }    public static long getInitialMemoryRequirement(Configuration conf, long maxAvailableTaskMemory) {     long initialMemRequestMb = conf.getInt(         TezRuntimeConfiguration.TEZ_RUNTIME_UNORDERED_OUTPUT_BUFFER_SIZE_MB,         TezRuntimeConfiguration.TEZ_RUNTIME_UNORDERED_OUTPUT_BUFFER_SIZE_MB_DEFAULT);     Preconditions.checkArgument(initialMemRequestMb != 0,         TezRuntimeConfiguration.TEZ_RUNTIME_UNORDERED_OUTPUT_BUFFER_SIZE_MB + &quot; should be larger than 0&quot;);     long reqBytes = initialMemRequestMb &lt;&lt; 20;     LOG.info(&quot;Requested BufferSize (&quot; + TezRuntimeConfiguration.TEZ_RUNTIME_UNORDERED_OUTPUT_BUFFER_SIZE_MB         + &quot;) : &quot; + initialMemRequestMb);     return reqBytes;   }    @Override   public List close() throws IOException, InterruptedException {     // In case there are buffers to be spilled, schedule spilling     scheduleSpill(true);     List eventList = Lists.newLinkedList();     isShutdown.set(true);     spillLock.lock();     try {       LOG.info(destNameTrimmed + &quot;: &quot; + &quot;Waiting for all spills to complete : Pending : &quot; + pendingSpillCount.get());       while (pendingSpillCount.get() != 0 &amp;&amp; spillException == null) {         spillInProgress.await();       }     } finally {       spillLock.unlock();     }     if (spillException != null) {       LOG.error(destNameTrimmed + &quot;: &quot; + &quot;Error during spill, throwing&quot;);       // Assuming close will be called on the same thread as the write       cleanup();       currentBuffer.cleanup();       currentBuffer = null;       if (spillException instanceof IOException) {         throw (IOException) spillException;       } else {         throw new IOException(spillException);       }     } else {       LOG.info(destNameTrimmed + &quot;: &quot; + &quot;All spills complete&quot;);       // Assuming close will be called on the same thread as the write       cleanup();        List events = Lists.newLinkedList();       if (!pipelinedShuffle) {         if (skipBuffers) {           writer.close();           long rawLen = writer.getRawLength();           long compLen = writer.getCompressedLength();           TezIndexRecord rec = new TezIndexRecord(0, rawLen, compLen);           TezSpillRecord sr = new TezSpillRecord(1);           sr.putIndex(rec, 0);           sr.writeToFile(finalIndexPath, conf);            BitSet emptyPartitions = new BitSet();           if (outputRecordsCounter.getValue() == 0) {             emptyPartitions.set(0);           }           if (reportPartitionStats()) {             if (outputRecordsCounter.getValue() &gt; 0) {               sizePerPartition[0] = rawLen;             }           }           cleanupCurrentBuffer();            if (outputRecordsCounter.getValue() &gt; 0) {             outputBytesWithOverheadCounter.increment(rawLen);             fileOutputBytesCounter.increment(compLen + indexFileSizeEstimate);           }           eventList.add(generateVMEvent());           eventList.add(generateDMEvent(false, -1, false, outputContext               .getUniqueIdentifier(), emptyPartitions));           return eventList;         }          /*           1. Final merge enabled              - When lots of spills are there, mergeAll, generate events and return              - If there are no existing spills, check for final spill and generate events           2. Final merge disabled              - If finalSpill generated data, generate events and return              - If finalSpill did not generate data, it would automatically populate events          */         if (isFinalMergeEnabled) {           if (numSpills.get() &gt; 0) {             mergeAll();           } else {             finalSpill();           }           updateTezCountersAndNotify();           eventList.add(generateVMEvent());           eventList.add(generateDMEvent());         } else {           // if no data is generated, finalSpill would create VMEvent &amp; add to finalEvents           SpillResult result = finalSpill();           if (result != null) {             updateTezCountersAndNotify();             // Generate vm event             finalEvents.add(generateVMEvent());              // compute empty partitions based on spill result and generate DME             int spillNum = numSpills.get() - 1;             SpillCallback callback = new SpillCallback(spillNum);             callback.computePartitionStats(result);             BitSet emptyPartitions = getEmptyPartitions(callback.getRecordsPerPartition());             String pathComponent = generatePathComponent(outputContext.getUniqueIdentifier(), spillNum);             Event finalEvent = generateDMEvent(true, spillNum,                 true, pathComponent, emptyPartitions);             finalEvents.add(finalEvent);           }           //all events to be sent out are in finalEvents.           eventList.addAll(finalEvents);         }         cleanupCurrentBuffer();         return eventList;       }        //For pipelined case, send out an event in case finalspill generated a spill file.       if (finalSpill() != null) {         // VertexManagerEvent is only sent at the end and thus sizePerPartition is used         // for the sum of all spills.         mayBeSendEventsForSpill(currentBuffer.recordsPerPartition,             sizePerPartition, numSpills.get() - 1, true);       }       updateTezCountersAndNotify();       cleanupCurrentBuffer();       return events;     }   }    private BitSet getEmptyPartitions(int[] recordsPerPartition) {     Preconditions.checkArgument(recordsPerPartition != null, &quot;records per partition can not be null&quot;);     BitSet emptyPartitions = new BitSet();     for (int i = 0; i &lt; numPartitions; i++) {       if (recordsPerPartition[i] == 0 ) {         emptyPartitions.set(i);       }     }     return emptyPartitions;   }    public boolean reportDetailedPartitionStats() {     return reportPartitionStats.isPrecise();   }    private Event generateVMEvent() throws IOException {     return ShuffleUtils.generateVMEvent(outputContext, this.sizePerPartition,         this.reportDetailedPartitionStats(), deflater.get());   }    private Event generateDMEvent() throws IOException {     BitSet emptyPartitions = getEmptyPartitions(numRecordsPerPartition);     return generateDMEvent(false, -1, false, outputContext.getUniqueIdentifier(), emptyPartitions);   }    private Event generateDMEvent(boolean addSpillDetails, int spillId,       boolean isLastSpill, String pathComponent, BitSet emptyPartitions)       throws IOException {      outputContext.notifyProgress();     DataMovementEventPayloadProto.Builder payloadBuilder = DataMovementEventPayloadProto         .newBuilder();      String host = getHost();     if (emptyPartitions.cardinality() != 0) {       // Empty partitions exist       ByteString emptyPartitionsByteString =           TezCommonUtils.compressByteArrayToByteString(TezUtilsInternal.toByteArray               (emptyPartitions), deflater.get());       payloadBuilder.setEmptyPartitions(emptyPartitionsByteString);     }      if (emptyPartitions.cardinality() != numPartitions) {       // Populate payload only if at least 1 partition has data       payloadBuilder.setHost(host);       payloadBuilder.setPort(getShufflePort());       payloadBuilder.setPathComponent(pathComponent);     }      if (addSpillDetails) {       payloadBuilder.setSpillId(spillId);       payloadBuilder.setLastEvent(isLastSpill);     }      ByteBuffer payload = payloadBuilder.build().toByteString().asReadOnlyByteBuffer();     return CompositeDataMovementEvent.create(0, numPartitions, payload);   }    private void cleanupCurrentBuffer() {     currentBuffer.cleanup();     currentBuffer = null;   }    private void cleanup() {     if (spillExecutor != null) {       spillExecutor.shutdownNow();     }     for (int i = 0; i &lt; buffers.length; i++) {       if (buffers[i] != null &amp;&amp; buffers[i] != currentBuffer) {         buffers[i].cleanup();         buffers[i] = null;       }     }     availableBuffers.clear();   }    private SpillResult finalSpill() throws IOException {     if (currentBuffer.nextPosition == 0) {       if (pipelinedShuffle || !isFinalMergeEnabled) {         List eventList = Lists.newLinkedList();         eventList.add(ShuffleUtils.generateVMEvent(outputContext,             reportPartitionStats() ? new long[numPartitions] : null,             reportDetailedPartitionStats(), deflater.get()));         if (localOutputRecordsCounter == 0 &amp;&amp; outputLargeRecordsCounter.getValue() == 0) {           // Should send this event (all empty partitions) only when no records are written out.           BitSet emptyPartitions = new BitSet(numPartitions);           emptyPartitions.flip(0, numPartitions);           eventList.add(generateDMEvent(true, numSpills.get(), true,               null, emptyPartitions));         }         if (pipelinedShuffle) {           outputContext.sendEvents(eventList);         } else if (!isFinalMergeEnabled) {           finalEvents.addAll(0, eventList);         }       }       return null;     } else {       updateGlobalStats(currentBuffer);       filledBuffers.add(currentBuffer);        //setup output file and index file       SpillPathDetails spillPathDetails = getSpillPathDetails(true, -1);       SpillCallable spillCallable = new SpillCallable(filledBuffers,           codec, null, spillPathDetails);       try {         SpillResult spillResult = spillCallable.call();          fileOutputBytesCounter.increment(spillResult.spillSize);         fileOutputBytesCounter.increment(indexFileSizeEstimate);         return spillResult;       } catch (Exception ex) {         throw (ex instanceof IOException) ? (IOException)ex : new IOException(ex);       }     }    }    /**    * Set up spill output file, index file details.    *    * @param isFinalSpill    * @param expectedSpillSize    * @return SpillPathDetails    * @throws IOException    */   private SpillPathDetails getSpillPathDetails(boolean isFinalSpill, long expectedSpillSize)       throws IOException {     int spillNumber = numSpills.getAndIncrement();     return getSpillPathDetails(isFinalSpill, expectedSpillSize, spillNumber);   }    /**    * Set up spill output file, index file details.    *    * @param isFinalSpill    * @param expectedSpillSize    * @param spillNumber    * @return SpillPathDetails    * @throws IOException    */   private SpillPathDetails getSpillPathDetails(boolean isFinalSpill, long expectedSpillSize,       int spillNumber) throws IOException {     long spillSize = (expectedSpillSize &lt; 0) ?         (currentBuffer.nextPosition + numPartitions * APPROX_HEADER_LENGTH) : expectedSpillSize;      Path outputFilePath = null;     Path indexFilePath = null;      if (!pipelinedShuffle &amp;&amp; isFinalMergeEnabled) {       if (isFinalSpill) {         outputFilePath = outputFileHandler.getOutputFileForWrite(spillSize);         indexFilePath = outputFileHandler.getOutputIndexFileForWrite(indexFileSizeEstimate);          //Setting this for tests         finalOutPath = outputFilePath;         finalIndexPath = indexFilePath;       } else {         outputFilePath = outputFileHandler.getSpillFileForWrite(spillNumber, spillSize);       }     } else {       outputFilePath = outputFileHandler.getSpillFileForWrite(spillNumber, spillSize);       indexFilePath  = outputFileHandler.getSpillIndexFileForWrite(spillNumber, indexFileSizeEstimate);     }      return new SpillPathDetails(outputFilePath, indexFilePath, spillNumber);   }    private void mergeAll() throws IOException {     long expectedSize = spilledSize;     if (currentBuffer.nextPosition != 0) {       expectedSize += currentBuffer.nextPosition - (currentBuffer.numRecords * META_SIZE)           - currentBuffer.skipSize + numPartitions * APPROX_HEADER_LENGTH;       // Update final statistics.       updateGlobalStats(currentBuffer);     }      SpillPathDetails spillPathDetails = getSpillPathDetails(true, expectedSize);     finalIndexPath = spillPathDetails.indexFilePath;     finalOutPath = spillPathDetails.outputFilePath;      TezSpillRecord finalSpillRecord = new TezSpillRecord(numPartitions);      DataInputBuffer keyBuffer = new DataInputBuffer();     DataInputBuffer valBuffer = new DataInputBuffer();      DataInputBuffer keyBufferIFile = new DataInputBuffer();     DataInputBuffer valBufferIFile = new DataInputBuffer();      FSDataOutputStream out = null;     try {       out = rfs.create(finalOutPath);       if (!SPILL_FILE_PERMS.equals(SPILL_FILE_PERMS.applyUMask(FsPermission.getUMask(conf)))) {         rfs.setPermission(finalOutPath, SPILL_FILE_PERMS);       }       Writer writer = null;        for (int i = 0; i &lt; numPartitions; i++) {         long segmentStart = out.getPos();         if (numRecordsPerPartition[i] == 0) {           LOG.info(destNameTrimmed + &quot;: &quot; + &quot;Skipping partition: &quot; + i + &quot; in final merge since it has no records&quot;);           continue;         }         writer = new Writer(conf, out, keyClass, valClass, codec, null, null);         try {           if (currentBuffer.nextPosition != 0               &amp;&amp; currentBuffer.partitionPositions[i] != WrappedBuffer.PARTITION_ABSENT_POSITION) {             // Write current buffer.             writePartition(currentBuffer.partitionPositions[i], currentBuffer, writer, keyBuffer,                 valBuffer);           }           synchronized (spillInfoList) {             for (SpillInfo spillInfo : spillInfoList) {               TezIndexRecord indexRecord = spillInfo.spillRecord.getIndex(i);               if (indexRecord.getPartLength() == 0) {                 // Skip empty partitions within a spill                 continue;               }               FSDataInputStream in = rfs.open(spillInfo.outPath);               in.seek(indexRecord.getStartOffset());               IFile.Reader reader = new IFile.Reader(in, indexRecord.getPartLength(), codec, null,                   additionalSpillBytesReadCounter, ifileReadAhead, ifileReadAheadLength,                   ifileBufferSize);               while (reader.nextRawKey(keyBufferIFile)) {                 // TODO Inefficient. If spills are not compressed, a direct copy should be possible                 // given the current IFile format. Also exteremely inefficient for large records,                 // since the entire record will be read into memory.                 reader.nextRawValue(valBufferIFile);                 writer.append(keyBufferIFile, valBufferIFile);               }               reader.close();             }           }           writer.close();           fileOutputBytesCounter.increment(writer.getCompressedLength());           TezIndexRecord indexRecord = new TezIndexRecord(segmentStart, writer.getRawLength(),               writer.getCompressedLength());           writer = null;           finalSpillRecord.putIndex(indexRecord, i);           outputContext.notifyProgress();         } finally {           if (writer != null) {             writer.close();           }         }       }     } finally {       if (out != null) {         out.close();       }       deleteIntermediateSpills();     }     finalSpillRecord.writeToFile(finalIndexPath, conf);     fileOutputBytesCounter.increment(indexFileSizeEstimate);     LOG.info(destNameTrimmed + &quot;: &quot; + &quot;Finished final spill after merging : &quot; + numSpills.get() + &quot; spills&quot;);   }    private void deleteIntermediateSpills() {     // Delete the intermediate spill files     synchronized (spillInfoList) {       for (SpillInfo spill : spillInfoList) {         try {           rfs.delete(spill.outPath, false);         } catch (IOException e) {           LOG.warn(&quot;Unable to delete intermediate spill &quot; + spill.outPath, e);         }       }     }   }    private void writeLargeRecord(final Object key, final Object value, final int partition)       throws IOException {     numAdditionalSpillsCounter.increment(1);     long size = sizePerBuffer - (currentBuffer.numRecords * META_SIZE) - currentBuffer.skipSize         + numPartitions * APPROX_HEADER_LENGTH;     SpillPathDetails spillPathDetails = getSpillPathDetails(false, size);     int spillIndex = spillPathDetails.spillIndex;     FSDataOutputStream out = null;     long outSize = 0;     try {       final TezSpillRecord spillRecord = new TezSpillRecord(numPartitions);       final Path outPath = spillPathDetails.outputFilePath;       out = rfs.create(outPath);       if (!SPILL_FILE_PERMS.equals(SPILL_FILE_PERMS.applyUMask(FsPermission.getUMask(conf)))) {         rfs.setPermission(outPath, SPILL_FILE_PERMS);       }       BitSet emptyPartitions = null;       if (pipelinedShuffle || !isFinalMergeEnabled) {         emptyPartitions = new BitSet(numPartitions);       }       for (int i = 0; i &lt; numPartitions; i++) {         final long recordStart = out.getPos();         if (i == partition) {           spilledRecordsCounter.increment(1);           Writer writer = null;           try {             writer = new IFile.Writer(conf, out, keyClass, valClass, codec, null, null);             writer.append(key, value);             outputLargeRecordsCounter.increment(1);             numRecordsPerPartition[i]++;             if (reportPartitionStats()) {               sizePerPartition[i] += writer.getRawLength();             }             writer.close();             synchronized (additionalSpillBytesWritternCounter) {               additionalSpillBytesWritternCounter.increment(writer.getCompressedLength());             }             TezIndexRecord indexRecord = new TezIndexRecord(recordStart, writer.getRawLength(),                 writer.getCompressedLength());             spillRecord.putIndex(indexRecord, i);             outSize = writer.getCompressedLength();             writer = null;           } finally {             if (writer != null) {               writer.close();             }           }         } else {           if (emptyPartitions != null) {             emptyPartitions.set(i);           }         }       }       handleSpillIndex(spillPathDetails, spillRecord);        mayBeSendEventsForSpill(emptyPartitions, sizePerPartition,           spillIndex, false);        LOG.info(destNameTrimmed + &quot;: &quot; + &quot;Finished writing large record of size &quot; + outSize + &quot; to spill file &quot; + spillIndex);       if (LOG.isDebugEnabled()) {         LOG.debug(destNameTrimmed + &quot;: &quot; + &quot;LargeRecord Spill=&quot; + spillIndex + &quot;, indexPath=&quot;             + spillPathDetails.indexFilePath + &quot;, outputPath=&quot;             + spillPathDetails.outputFilePath);       }     } finally {       if (out != null) {         out.close();       }     }   }    private void handleSpillIndex(SpillPathDetails spillPathDetails, TezSpillRecord spillRecord)       throws IOException {     if (spillPathDetails.indexFilePath != null) {       //write the index record       spillRecord.writeToFile(spillPathDetails.indexFilePath, conf);     } else {       //add to cache       SpillInfo spillInfo = new SpillInfo(spillRecord, spillPathDetails.outputFilePath);       spillInfoList.add(spillInfo);       numAdditionalSpillsCounter.increment(1);     }   }    private class ByteArrayOutputStream extends OutputStream {      private final byte[] scratch = new byte[1];      @Override     public void write(int v) throws IOException {       scratch[0] = (byte) v;       write(scratch, 0, 1);     }      public void write(byte[] b, int off, int len) throws IOException {       if (currentBuffer.full) {           /* no longer do anything until reset */       } else if (len &gt; currentBuffer.availableSize) {         currentBuffer.full = true; /* stop working &amp; signal we hit the end */       } else {         System.arraycopy(b, off, currentBuffer.buffer, currentBuffer.nextPosition, len);         currentBuffer.nextPosition += len;         currentBuffer.availableSize -= len;       }     }   }    private static class WrappedBuffer {      private static final int PARTITION_ABSENT_POSITION = -1;      private final int[] partitionPositions;     private final int[] recordsPerPartition;     // uncompressed size for each partition     private final long[] sizePerPartition;     private final int numPartitions;     private final int size;      private byte[] buffer;     private IntBuffer metaBuffer;      private int numRecords = 0;     private int skipSize = 0;      private int nextPosition = 0;     private int availableSize;     private boolean full = false;      WrappedBuffer(int numPartitions, int size) {       this.partitionPositions = new int[numPartitions];       this.recordsPerPartition = new int[numPartitions];       this.sizePerPartition = new long[numPartitions];       this.numPartitions = numPartitions;       for (int i = 0; i &lt; numPartitions; i++) {         this.partitionPositions[i] = PARTITION_ABSENT_POSITION;         this.recordsPerPartition[i] = 0;         this.sizePerPartition[i] = 0;       }       size = size - (size % INT_SIZE);       this.size = size;       this.buffer = new byte[size];       this.metaBuffer = ByteBuffer.wrap(buffer).order(ByteOrder.nativeOrder()).asIntBuffer();       availableSize = size;     }      void reset() {       for (int i = 0; i &lt; numPartitions; i++) {         this.partitionPositions[i] = PARTITION_ABSENT_POSITION;         this.recordsPerPartition[i] = 0;         this.sizePerPartition[i] = 0;       }       numRecords = 0;       nextPosition = 0;       skipSize = 0;       availableSize = size;       full = false;     }      void cleanup() {       buffer = null;       metaBuffer = null;     }   }    private String generatePathComponent(String uniqueId, int spillNumber) {     return (uniqueId + &quot;_&quot; + spillNumber);   }    private List generateEventForSpill(BitSet emptyPartitions, long[] sizePerPartition,       int spillNumber,       boolean isFinalUpdate) throws IOException {     List eventList = Lists.newLinkedList();     //Send out an event for consuming.     String pathComponent = generatePathComponent(outputContext.getUniqueIdentifier(), spillNumber);     if (isFinalUpdate) {       eventList.add(ShuffleUtils.generateVMEvent(outputContext,           sizePerPartition, reportDetailedPartitionStats(), deflater.get()));     }     Event compEvent = generateDMEvent(true, spillNumber, isFinalUpdate,         pathComponent, emptyPartitions);     eventList.add(compEvent);     return eventList;   }    private void mayBeSendEventsForSpill(       BitSet emptyPartitions, long[] sizePerPartition,       int spillNumber, boolean isFinalUpdate) {     if (!pipelinedShuffle) {       if (isFinalMergeEnabled) {         return;       }     }     List events = null;     try {       events = generateEventForSpill(emptyPartitions, sizePerPartition, spillNumber,           isFinalUpdate);       LOG.info(destNameTrimmed + &quot;: &quot; + &quot;Adding spill event for spill&quot;           + &quot; (final update=&quot; + isFinalUpdate + &quot;), spillId=&quot; + spillNumber);       if (pipelinedShuffle) {         //Send out an event for consuming.         outputContext.sendEvents(events);       } else if (!isFinalMergeEnabled) {         this.finalEvents.addAll(events);       }     } catch (IOException e) {       LOG.error(destNameTrimmed + &quot;: &quot; + &quot;Error in sending pipelined events&quot;, e);       outputContext.reportFailure(TaskFailureType.NON_FATAL, e,           &quot;Error in sending events.&quot;);     }   }    private void mayBeSendEventsForSpill(int[] recordsPerPartition,       long[] sizePerPartition, int spillNumber, boolean isFinalUpdate) {     BitSet emptyPartitions = getEmptyPartitions(recordsPerPartition);     mayBeSendEventsForSpill(emptyPartitions, sizePerPartition, spillNumber,         isFinalUpdate);   }    private class SpillCallback implements FutureCallback {      private final int spillNumber;     private int recordsPerPartition[];     private long sizePerPartition[];      SpillCallback(int spillNumber) {       this.spillNumber = spillNumber;     }      void computePartitionStats(SpillResult result) {       if (result.filledBuffers.size() == 1) {         recordsPerPartition = result.filledBuffers.get(0).recordsPerPartition;         sizePerPartition = result.filledBuffers.get(0).sizePerPartition;       } else {         recordsPerPartition = new int[numPartitions];         sizePerPartition = new long[numPartitions];         for (WrappedBuffer buffer : result.filledBuffers) {           for (int i = 0; i &lt; numPartitions; ++i) {             recordsPerPartition[i] += buffer.recordsPerPartition[i];             sizePerPartition[i] += buffer.sizePerPartition[i];           }         }       }     }      int[] getRecordsPerPartition() {       return recordsPerPartition;     }      @Override     public void onSuccess(SpillResult result) {       synchronized (UnorderedPartitionedKVWriter.this) {         spilledSize += result.spillSize;       }        computePartitionStats(result);        mayBeSendEventsForSpill(recordsPerPartition, sizePerPartition, spillNumber, false);        try {         for (WrappedBuffer buffer : result.filledBuffers) {           buffer.reset();           availableBuffers.add(buffer);         }       } catch (Throwable e) {         LOG.error(destNameTrimmed + &quot;: Failure while attempting to reset buffer after spill&quot;, e);         outputContext.reportFailure(TaskFailureType.NON_FATAL, e, &quot;Failure while attempting to reset buffer after spill&quot;);       }        if (!pipelinedShuffle &amp;&amp; isFinalMergeEnabled) {         synchronized(additionalSpillBytesWritternCounter) {           additionalSpillBytesWritternCounter.increment(result.spillSize);         }       } else {         synchronized(fileOutputBytesCounter) {           fileOutputBytesCounter.increment(indexFileSizeEstimate);           fileOutputBytesCounter.increment(result.spillSize);         }       }        spillLock.lock();       try {         if (pendingSpillCount.decrementAndGet() == 0) {           spillInProgress.signal();         }       } finally {         spillLock.unlock();         availableSlots.release();       }     }      @Override     public void onFailure(Throwable t) {       // spillException setup to throw an exception back to the user. Requires synchronization.       // Consider removing it in favor of having Tez kill the task       LOG.error(destNameTrimmed + &quot;: &quot; + &quot;Failure while spilling to disk&quot;, t);       spillException = t;       outputContext.reportFailure(TaskFailureType.NON_FATAL, t, &quot;Failure while spilling to disk&quot;);       spillLock.lock();       try {         spillInProgress.signal();       } finally {         spillLock.unlock();         availableSlots.release();       }     }   }    private static class SpillResult {     final long spillSize;     final List filledBuffers;      SpillResult(long size, List filledBuffers) {       this.spillSize = size;       this.filledBuffers = filledBuffers;     }   }    @VisibleForTesting   static class SpillInfo {     final TezSpillRecord spillRecord;     final Path outPath;      SpillInfo(TezSpillRecord spillRecord, Path outPath) {       this.spillRecord = spillRecord;       this.outPath = outPath;     }   }    @VisibleForTesting   String getHost() {     return outputContext.getExecutionContext().getHostName();   }    @VisibleForTesting   int getShufflePort() throws IOException {     String auxiliaryService = conf.get(TezConfiguration.TEZ_AM_SHUFFLE_AUXILIARY_SERVICE_ID,         TezConfiguration.TEZ_AM_SHUFFLE_AUXILIARY_SERVICE_ID_DEFAULT);     ByteBuffer shuffleMetadata = outputContext         .getServiceProviderMetaData(auxiliaryService);     int shufflePort = ShuffleUtils.deserializeShuffleProviderMetaData(shuffleMetadata);     return shufflePort;   }    @InterfaceAudience.Private   static class SpillPathDetails {     final Path indexFilePath;     final Path outputFilePath;     final int spillIndex;      SpillPathDetails(Path outputFilePath, Path indexFilePath, int spillIndex) {       this.outputFilePath = outputFilePath;       this.indexFilePath = indexFilePath;       this.spillIndex = spillIndex;     }   } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">529</td>
    <td align="left">https://github.com/apache/tez/blob/d5675c332497c1ac1dedefdf91e87476b5c0d7a9/tez-runtime-library/src/main/java/org/apache/tez/runtime/library/common/writers/UnorderedPartitionedKVWriter.java/#L89-L1427</td>
    <td align="right">1</td>
    <td align="right">2</td>
    <td align="right">529</td>
  </tr>
  <tr valign="top">
    <td align="right">5084</td>
    <td align="left">{&quot;message&quot;:&quot;YES I found bad smells&quot;,&quot;detected_bad_smells&quot;:[&quot;Blob&quot;,&quot;Data Class&quot;,&quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;ProviderCreditReversalDetails&quot;, propOrder = {     &quot;amazonProviderCreditReversalId&quot;,     &quot;sellerId&quot;,     &quot;providerSellerId&quot;,     &quot;creditReversalReferenceId&quot;,     &quot;creditReversalAmount&quot;,     &quot;creationTimestamp&quot;,     &quot;creditReversalStatus&quot;,     &quot;creditReversalNote&quot; }) public class ProviderCreditReversalDetails {      @XmlElement(name = &quot;AmazonProviderCreditReversalId&quot;, required = true)     protected String amazonProviderCreditReversalId;     @XmlElement(name = &quot;SellerId&quot;, required = true)     protected String sellerId;     @XmlElement(name = &quot;ProviderSellerId&quot;, required = true)     protected String providerSellerId;     @XmlElement(name = &quot;CreditReversalReferenceId&quot;, required = true)     protected String creditReversalReferenceId;     @XmlElement(name = &quot;CreditReversalAmount&quot;, required = true)     protected Price creditReversalAmount;     @XmlElement(name = &quot;CreationTimestamp&quot;, required = true)     @XmlSchemaType(name = &quot;dateTime&quot;)     protected XMLGregorianCalendar creationTimestamp;     @XmlElement(name = &quot;CreditReversalStatus&quot;, required = true)     protected Status creditReversalStatus;     @XmlElement(name = &quot;CreditReversalNote&quot;)     protected String creditReversalNote;      public ProviderCreditReversalDetails() {         super();     }      /**      * Returns the amazonProviderCreditReversalId from notification      *       * @return Returns the amazonProviderCreditReversalId from notification      */     public String getAmazonProviderCreditReversalId() {         return amazonProviderCreditReversalId;     }      /**      * Returns the sellerId from notification      *       * @return Returns the sellerId from notification      */     public String getSellerId() {         return sellerId;     }      /**      * Returns the providerSellerId from notification      *       * @return Returns the providerSellerId from notification      */     public String getProviderSellerId() {         return providerSellerId;     }      /**      * Returns the creditReversalReferenceId from notification      *       * @return Returns the creditReversalReferenceId from notification      */     public String getCreditReversalReferenceId() {         return creditReversalReferenceId;     }       /**      * Returns the creditReversalAmount from notification       *       * @return Returns the creditReversalAmount from notification       */     public Price getCreditReversalAmount() {         return creditReversalAmount;     }      /**      * Returns the creationTimestamp from notification      *       * @return Returns the creationTimestamp from notification      */     public XMLGregorianCalendar getCreationTimestamp() {         return creationTimestamp;     }      /**      * Returns the creditReversalStatus from notification      *       * @return Returns the creditReversalStatus from notification      */     public Status getCreditReversalStatus() {         return creditReversalStatus;     }      /**      * Returns the creditReversalNote from notification      *       * @return Returns the creditReversalNote from notification      */     public String getCreditReversalNote() {         return creditReversalNote;     }      /**      * String representation of providerCreditReversalNotification      */     @Override     public String toString() {         return &quot;ProviderCreditReversalDetails{&quot; + &quot;amazonProviderCreditReversalId=&quot; + amazonProviderCreditReversalId                  + &quot;, sellerId=&quot; + sellerId + &quot;, providerId=&quot; + providerSellerId + &quot;, creditReversalReferenceId=&quot;                  + creditReversalReferenceId + &quot;, creditReversalAmount=&quot; + creditReversalAmount + &quot;, creationTimestamp=&quot;                  + creationTimestamp + &quot;, creditReversalStatus=&quot; + creditReversalStatus + &quot;, creditReversalNote=&quot;                  + creditReversalNote + '}';     }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14204</td>
    <td align="left">https://github.com/amzn/amazon-pay-sdk-java/blob/5a3547d00c796aab8f0c8ac12e0310f7a5c4678a/src/com/amazon/pay/response/ipn/model/ProviderCreditReversalDetails.java/#L25-L145</td>
    <td align="right">1</td>
    <td align="right">5084</td>
    <td align="right">14204</td>
  </tr>
  <tr valign="top">
    <td align="right">1659</td>
    <td align="left">{&quot;response&quot;: &quot;YES, I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;1. Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SysInfo implements Serializable {      static final long serialVersionUID = -3096346807579L;      public int numCores;     public long maxMemory;      public SysInfo(int nc, long mm) {         numCores = nc;         maxMemory = mm;     } }</td>
    <td align="left">data class</td>
    <td align="left">1 Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11607</td>
    <td align="left">https://github.com/google/error-prone-javac/blob/a53d069bbdb2c60232ed3811c19b65e41c3e60e0/src/jdk.compiler/share/classes/com/sun/tools/sjavac/server/SysInfo.java/#L45-L56</td>
    <td align="right">1</td>
    <td align="right">1659</td>
    <td align="right">11607</td>
  </tr>
  <tr valign="top">
    <td align="right">2344</td>
    <td align="left">&nbsp;{       &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [           &quot;Long Method&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@InterfaceAudience.Public @InterfaceStability.Evolving public class MetricsTag implements MetricsInfo {   private final MetricsInfo info;   private final String value;    /**    * Construct the tag with name, description and value    * @param info  of the tag    * @param value of the tag    */   public MetricsTag(MetricsInfo info, String value) {     this.info = checkNotNull(info, &quot;tag info&quot;);     this.value = value;   }    @Override public String name() {     return info.name();   }    @Override public String description() {     return info.description();   }    /**    * @return the info object of the tag    */   public MetricsInfo info() {     return info;   }    /**    * Get the value of the tag    * @return  the value    */   public String value() {     return value;   }    @Override public boolean equals(Object obj) {     if (obj instanceof MetricsTag) {       final MetricsTag other = (MetricsTag) obj;       return Objects.equal(info, other.info()) &amp;&amp;              Objects.equal(value, other.value());     }     return false;   }    @Override public int hashCode() {     return Objects.hashCode(info, value);   }    @Override public String toString() {     return Objects.toStringHelper(this)         .add(&quot;info&quot;, info)         .add(&quot;value&quot;, value())         .toString();   } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14186</td>
    <td align="left">https://github.com/apache/hadoop-common/blob/42a61a4fbc88303913c4681f0d40ffcc737e70b5/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/metrics2/MetricsTag.java/#L30-L88</td>
    <td align="right">1</td>
    <td align="right">2344</td>
    <td align="right">14186</td>
  </tr>
  <tr valign="top">
    <td align="right">143</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   } </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class BinaryExpression implements Expression {     protected Expression left;     protected Expression right;      public BinaryExpression(Expression left, Expression right) {         this.left = left;         this.right = right;     }      public Expression getLeft() {         return left;     }      public Expression getRight() {         return right;     }       /**      * @see java.lang.Object#toString()      */     public String toString() {         return &quot;(&quot; + left.toString() + &quot; &quot; + getExpressionSymbol() + &quot; &quot; + right.toString() + &quot;)&quot;;     }      /**      * TODO: more efficient hashCode()      *      * @see java.lang.Object#hashCode()      */     public int hashCode() {         return toString().hashCode();     }      /**      * TODO: more efficient hashCode()      *      * @see java.lang.Object#equals(java.lang.Object)      */     public boolean equals(Object o) {          if (o == null || !this.getClass().equals(o.getClass())) {             return false;         }         return toString().equals(o.toString());      }      /**      * Returns the symbol that represents this binary expression.  For example, addition is      * represented by &quot;+&quot;      *      * @return      */     public abstract String getExpressionSymbol();      /**      * @param expression      */     public void setRight(Expression expression) {         right = expression;     }      /**      * @param expression      */     public void setLeft(Expression expression) {         left = expression;     }      }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1786</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-client/src/main/java/org/apache/activemq/filter/BinaryExpression.java/#L26-L96</td>
    <td align="right">1</td>
    <td align="right">143</td>
    <td align="right">1786</td>
  </tr>
  <tr valign="top">
    <td align="right">250</td>
    <td align="left">&nbsp;		{ 			&quot;message&quot;: &quot;YES I found bad smells&quot;, 			&quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Data Class&quot;] 		}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public static final class VertexGroupItem extends Tuple4, Long&gt; {  		private final Either.Right nullValue = new Either.Right&lt;&gt;(NullValue.getInstance());  		public VertexGroupItem() { 			reset(); 		}  		public K getVertexId() { 			return f0; 		}  		public void setVertexId(K vertexId) { 			f0 = vertexId; 		}  		public K getGroupRepresentativeId() { 			return f1; 		}  		public void setGroupRepresentativeId(K groupRepresentativeId) { 			f1 = groupRepresentativeId; 		}  		public VGV getVertexGroupValue() { 			return f2.isLeft() ? f2.left() : null; 		}  		public void setVertexGroupValue(VGV vertexGroupValue) { 			if (vertexGroupValue == null) { 				f2 = nullValue; 			} else { 				f2 = new Either.Left&lt;&gt;(vertexGroupValue); 			} 		}  		public Long getVertexGroupCount() { 			return f3; 		}  		public void setVertexGroupCount(Long vertexGroupCount) { 			f3 = vertexGroupCount; 		}  		/** 		 * Resets the fields to initial values. This is necessary if the tuples are reused and not all fields were modified. 		 */ 		public void reset() { 			f0 = null; 			f1 = null; 			f2 = nullValue; 			f3 = 0L; 		} 	} </td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2685</td>
    <td align="left">https://github.com/apache/flink/blob/8068c8775ad067d75828e6360e7e0994348da9b9/flink-libraries/flink-gelly/src/main/java/org/apache/flink/graph/library/Summarization.java/#L214-L268</td>
    <td align="right">1</td>
    <td align="right">250</td>
    <td align="right">2685</td>
  </tr>
  <tr valign="top">
    <td align="right">702</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlType(name = &quot;remoteProcessGroup&quot;) public class RemoteProcessGroupDTO extends ComponentDTO {      private String targetUri;     private String targetUris;     private Boolean targetSecure;      private String name;     private String comments;     private String communicationsTimeout;     private String yieldDuration;     private String transportProtocol;     private String localNetworkInterface;     private String proxyHost;     private Integer proxyPort;     private String proxyUser;     private String proxyPassword;      private Collection authorizationIssues;     private Collection validationErrors;     private Boolean transmitting;      private Integer inputPortCount;     private Integer outputPortCount;      private Integer activeRemoteInputPortCount;     private Integer inactiveRemoteInputPortCount;     private Integer activeRemoteOutputPortCount;     private Integer inactiveRemoteOutputPortCount;      private Date flowRefreshed;      private RemoteProcessGroupContentsDTO contents;      public RemoteProcessGroupDTO() {         super();     }      public RemoteProcessGroupDTO(final RemoteProcessGroupDTO toCopy) {         setId(toCopy.getId());         setPosition(toCopy.getPosition());         targetUri = toCopy.getTargetUri();         name = toCopy.getName();     }      public void setTargetUri(final String targetUri) {         this.targetUri = targetUri;     }      /**      * @return target uri of this remote process group.      * If target uri is not set, but uris are set, then returns the first url in the urls.      * If neither target uri nor uris are set, then returns null.      */     @ApiModelProperty(             value = &quot;The target URI of the remote process group.&quot; +                     &quot; If target uri is not set, but uris are set, then returns the first url in the urls.&quot; +                     &quot; If neither target uri nor uris are set, then returns null.&quot;     )     public String getTargetUri() {         if (targetUri == null || targetUri.length() == 0) {             synchronized (this) {                 if (targetUri == null || targetUri.length() == 0) {                     if (targetUris != null &amp;&amp; targetUris.length() &gt; 0) {                         if (targetUris.indexOf(',') &gt; -1) {                             targetUri = targetUris.substring(0, targetUris.indexOf(','));                         } else {                             targetUri = targetUris;                         }                     }                 }             }         }          return this.targetUri;     }      public void setTargetUris(String targetUris) {         this.targetUris = targetUris;     }      /**      * @return target uris of this remote process group      * If targetUris was not set but target uri was set, then returns a collection containing the single uri.      * If neither target uris nor uri were set, then returns null.      */     @ApiModelProperty(             value = &quot;The target URI of the remote process group.&quot; +                     &quot; If target uris is not set but target uri is set,&quot; +                     &quot; then returns a collection containing the single target uri.&quot; +                     &quot; If neither target uris nor uris are set, then returns null.&quot;     )     public String getTargetUris() {         if (targetUris == null || targetUris.length() == 0) {             synchronized (this) {                 if (targetUris == null || targetUris.length() == 0) {                     targetUris = targetUri;                 }             }         }          return this.targetUris;     }      /**      * @param name of this remote process group      */     @ApiModelProperty(             value = &quot;The name of the remote process group.&quot;     )     public void setName(final String name) {         this.name = name;     }      public String getName() {         return this.name;     }      /**      * @return Comments for this remote process group      */     @ApiModelProperty(             value = &quot;The comments for the remote process group.&quot;     )     public String getComments() {         return comments;     }      public void setComments(String comments) {         this.comments = comments;     }      /**      * @return any remote authorization issues for this remote process group      */     @ApiModelProperty(             value = &quot;Any remote authorization issues for the remote process group.&quot;     )     public Collection getAuthorizationIssues() {         return authorizationIssues;     }      public void setAuthorizationIssues(Collection authorizationIssues) {         this.authorizationIssues = authorizationIssues;     }      /**      * @return whether or not this remote process group is actively transmitting      */     @ApiModelProperty(             value = &quot;Whether the remote process group is actively transmitting.&quot;     )     public Boolean isTransmitting() {         return transmitting;     }      public void setTransmitting(Boolean transmitting) {         this.transmitting = transmitting;     }      /**      * @return whether or not the target is running securely      */     @ApiModelProperty(             value = &quot;Whether the target is running securely.&quot;     )     public Boolean isTargetSecure() {         return targetSecure;     }      public void setTargetSecure(Boolean targetSecure) {         this.targetSecure = targetSecure;     }      /**      * @return the time period used for the timeout when communicating with this RemoteProcessGroup      */     @ApiModelProperty(             value = &quot;The time period used for the timeout when communicating with the target.&quot;     )     public String getCommunicationsTimeout() {         return communicationsTimeout;     }      public void setCommunicationsTimeout(String communicationsTimeout) {         this.communicationsTimeout = communicationsTimeout;     }      /**      * @return when yielding, this amount of time must elapse before this remote process group is scheduled again      */     @ApiModelProperty(             value = &quot;When yielding, this amount of time must elapse before the remote process group is scheduled again.&quot;     )     public String getYieldDuration() {         return yieldDuration;     }      public void setYieldDuration(String yieldDuration) {         this.yieldDuration = yieldDuration;     }      /**      * @return number of active remote input ports      */     @ApiModelProperty(             value = &quot;The number of active remote input ports.&quot;     )     public Integer getActiveRemoteInputPortCount() {         return activeRemoteInputPortCount;     }      public void setActiveRemoteInputPortCount(Integer activeRemoteInputPortCount) {         this.activeRemoteInputPortCount = activeRemoteInputPortCount;     }      /**      * @return number of inactive remote input ports      */     @ApiModelProperty(             value = &quot;The number of inactive remote input ports.&quot;     )     public Integer getInactiveRemoteInputPortCount() {         return inactiveRemoteInputPortCount;     }      public void setInactiveRemoteInputPortCount(Integer inactiveRemoteInputPortCount) {         this.inactiveRemoteInputPortCount = inactiveRemoteInputPortCount;     }      /**      * @return number of active remote output ports      */     @ApiModelProperty(             value = &quot;The number of active remote output ports.&quot;     )     public Integer getActiveRemoteOutputPortCount() {         return activeRemoteOutputPortCount;     }      public void setActiveRemoteOutputPortCount(Integer activeRemoteOutputPortCount) {         this.activeRemoteOutputPortCount = activeRemoteOutputPortCount;     }      /**      * @return number of inactive remote output ports      */     @ApiModelProperty(             value = &quot;The number of inactive remote output ports.&quot;     )     public Integer getInactiveRemoteOutputPortCount() {         return inactiveRemoteOutputPortCount;     }      public void setInactiveRemoteOutputPortCount(Integer inactiveRemoteOutputPortCount) {         this.inactiveRemoteOutputPortCount = inactiveRemoteOutputPortCount;     }      /**      * @return number of Remote Input Ports currently available in the remote NiFi instance      */     @ApiModelProperty(             value = &quot;The number of remote input ports currently available on the target.&quot;     )     public Integer getInputPortCount() {         return inputPortCount;     }      public void setInputPortCount(Integer inputPortCount) {         this.inputPortCount = inputPortCount;     }      /**      * @return number of Remote Output Ports currently available in the remote NiFi instance      */     @ApiModelProperty(             value = &quot;The number of remote output ports currently available on the target.&quot;     )     public Integer getOutputPortCount() {         return outputPortCount;     }      public void setOutputPortCount(Integer outputPortCount) {         this.outputPortCount = outputPortCount;     }      /**      * @return contents of this remote process group. Will contain available input/output ports      */     @ApiModelProperty(             value = &quot;The contents of the remote process group. Will contain available input/output ports.&quot;     )     public RemoteProcessGroupContentsDTO getContents() {         return contents;     }      public void setContents(RemoteProcessGroupContentsDTO contents) {         this.contents = contents;     }      /**      * @return the flow for this remote group was last refreshed      */     @XmlJavaTypeAdapter(DateTimeAdapter.class)     @ApiModelProperty(             value = &quot;The timestamp when this remote process group was last refreshed.&quot;,             dataType = &quot;string&quot;     )     public Date getFlowRefreshed() {         return flowRefreshed;     }      public void setFlowRefreshed(Date flowRefreshed) {         this.flowRefreshed = flowRefreshed;     }      public String getTransportProtocol() {         return transportProtocol;     }      public void setTransportProtocol(String transportProtocol) {         this.transportProtocol = transportProtocol;     }      @ApiModelProperty(&quot;The local network interface to send/receive data. If not specified, any local address is used. If clustered, all nodes must have an interface with this identifier.&quot;)     public String getLocalNetworkInterface() {         return localNetworkInterface;     }      public void setLocalNetworkInterface(String localNetworkInterface) {         this.localNetworkInterface = localNetworkInterface;     }      @ApiModelProperty(             &quot;The validation errors for the remote process group. These validation errors represent the problems with the remote process group that must be resolved before it can transmit.&quot;     )     public Collection getValidationErrors() {         return validationErrors;     }      public void setValidationErrors(Collection validationErrors) {         this.validationErrors = validationErrors;     }      public String getProxyHost() {         return proxyHost;     }      public void setProxyHost(String proxyHost) {         this.proxyHost = proxyHost;     }      public Integer getProxyPort() {         return proxyPort;     }      public void setProxyPort(Integer proxyPort) {         this.proxyPort = proxyPort;     }      public String getProxyUser() {         return proxyUser;     }      public void setProxyUser(String proxyUser) {         this.proxyUser = proxyUser;     }      public String getProxyPassword() {         return proxyPassword;     }      public void setProxyPassword(String proxyPassword) {         this.proxyPassword = proxyPassword;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6697</td>
    <td align="left">https://github.com/apache/nifi/blob/c8eff590efa3babcda0b755009224dcac168708b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/RemoteProcessGroupDTO.java/#L30-L405</td>
    <td align="right">1</td>
    <td align="right">702</td>
    <td align="right">6697</td>
  </tr>
  <tr valign="top">
    <td align="right">382</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Long Method&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@InterfaceAudience.Public @InterfaceStability.Evolving public class Cluster {      @InterfaceStability.Evolving   public static enum JobTrackerStatus {INITIALIZING, RUNNING};      private ClientProtocolProvider clientProtocolProvider;   private ClientProtocol client;   private UserGroupInformation ugi;   private Configuration conf;   private FileSystem fs = null;   private Path sysDir = null;   private Path stagingAreaDir = null;   private Path jobHistoryDir = null;   private static final Log LOG = LogFactory.getLog(Cluster.class);    private static ServiceLoader frameworkLoader =       ServiceLoader.load(ClientProtocolProvider.class);      static {     ConfigUtil.loadResources();   }      public Cluster(Configuration conf) throws IOException {     this(null, conf);   }    public Cluster(InetSocketAddress jobTrackAddr, Configuration conf)        throws IOException {     this.conf = conf;     this.ugi = UserGroupInformation.getCurrentUser();     initialize(jobTrackAddr, conf);   }      private void initialize(InetSocketAddress jobTrackAddr, Configuration conf)       throws IOException {      synchronized (frameworkLoader) {       for (ClientProtocolProvider provider : frameworkLoader) {         LOG.debug(&quot;Trying ClientProtocolProvider : &quot;             + provider.getClass().getName());         ClientProtocol clientProtocol = null;          try {           if (jobTrackAddr == null) {             clientProtocol = provider.create(conf);           } else {             clientProtocol = provider.create(jobTrackAddr, conf);           }            if (clientProtocol != null) {             clientProtocolProvider = provider;             client = clientProtocol;             LOG.debug(&quot;Picked &quot; + provider.getClass().getName()                 + &quot; as the ClientProtocolProvider&quot;);             break;           }           else {             LOG.debug(&quot;Cannot pick &quot; + provider.getClass().getName()                 + &quot; as the ClientProtocolProvider - returned null protocol&quot;);           }         }          catch (Exception e) {           LOG.info(&quot;Failed to use &quot; + provider.getClass().getName()               + &quot; due to error: &quot; + e.getMessage());         }       }     }      if (null == clientProtocolProvider || null == client) {       throw new IOException(           &quot;Cannot initialize Cluster. Please check your configuration for &quot;               + MRConfig.FRAMEWORK_NAME               + &quot; and the correspond server addresses.&quot;);     }   }    ClientProtocol getClient() {     return client;   }      Configuration getConf() {     return conf;   }      /**    * Close the Cluster.    */   public synchronized void close() throws IOException {     clientProtocolProvider.close(client);   }    private Job[] getJobs(JobStatus[] stats) throws IOException {     List jobs = new ArrayList();     for (JobStatus stat : stats) {       jobs.add(Job.getInstance(this, stat, new JobConf(stat.getJobFile())));     }     return jobs.toArray(new Job[0]);   }    /**    * Get the file system where job-specific files are stored    *     * @return object of FileSystem    * @throws IOException    * @throws InterruptedException    */   public synchronized FileSystem getFileSystem()        throws IOException, InterruptedException {     if (this.fs == null) {       try {         this.fs = ugi.doAs(new PrivilegedExceptionAction() {           public FileSystem run() throws IOException, InterruptedException {             final Path sysDir = new Path(client.getSystemDir());             return sysDir.getFileSystem(getConf());           }         });       } catch (InterruptedException e) {         throw new RuntimeException(e);       }     }     return fs;   }    /**    * Get job corresponding to jobid.    *     * @param jobId    * @return object of {@link Job}    * @throws IOException    * @throws InterruptedException    */   public Job getJob(JobID jobId) throws IOException, InterruptedException {     JobStatus status = client.getJobStatus(jobId);     if (status != null) {       JobConf conf;       try {         conf = new JobConf(status.getJobFile());       } catch (RuntimeException ex) {         // If job file doesn't exist it means we can't find the job         if (ex.getCause() instanceof FileNotFoundException) {           return null;         } else {           throw ex;         }       }       return Job.getInstance(this, status, conf);     }     return null;   }      /**    * Get all the queues in cluster.    *     * @return array of {@link QueueInfo}    * @throws IOException    * @throws InterruptedException    */   public QueueInfo[] getQueues() throws IOException, InterruptedException {     return client.getQueues();   }      /**    * Get queue information for the specified name.    *     * @param name queuename    * @return object of {@link QueueInfo}    * @throws IOException    * @throws InterruptedException    */   public QueueInfo getQueue(String name)        throws IOException, InterruptedException {     return client.getQueue(name);   }    /**    * Get log parameters for the specified jobID or taskAttemptID    * @param jobID the job id.    * @param taskAttemptID the task attempt id. Optional.    * @return the LogParams    * @throws IOException    * @throws InterruptedException    */   public LogParams getLogParams(JobID jobID, TaskAttemptID taskAttemptID)       throws IOException, InterruptedException {     return client.getLogFileParams(jobID, taskAttemptID);   }    /**    * Get current cluster status.    *     * @return object of {@link ClusterMetrics}    * @throws IOException    * @throws InterruptedException    */   public ClusterMetrics getClusterStatus() throws IOException, InterruptedException {     return client.getClusterMetrics();   }      /**    * Get all active trackers in the cluster.    *     * @return array of {@link TaskTrackerInfo}    * @throws IOException    * @throws InterruptedException    */   public TaskTrackerInfo[] getActiveTaskTrackers()        throws IOException, InterruptedException  {     return client.getActiveTrackers();   }      /**    * Get blacklisted trackers.    *     * @return array of {@link TaskTrackerInfo}    * @throws IOException    * @throws InterruptedException    */   public TaskTrackerInfo[] getBlackListedTaskTrackers()        throws IOException, InterruptedException  {     return client.getBlacklistedTrackers();   }      /**    * Get all the jobs in cluster.    *     * @return array of {@link Job}    * @throws IOException    * @throws InterruptedException    * @deprecated Use {@link #getAllJobStatuses()} instead.    */   @Deprecated   public Job[] getAllJobs() throws IOException, InterruptedException {     return getJobs(client.getAllJobs());   }    /**    * Get job status for all jobs in the cluster.    * @return job status for all jobs in cluster    * @throws IOException    * @throws InterruptedException    */   public JobStatus[] getAllJobStatuses() throws IOException, InterruptedException {     return client.getAllJobs();   }    /**    * Grab the jobtracker system directory path where     * job-specific files will  be placed.    *     * @return the system directory where job-specific files are to be placed.    */   public Path getSystemDir() throws IOException, InterruptedException {     if (sysDir == null) {       sysDir = new Path(client.getSystemDir());     }     return sysDir;   }      /**    * Grab the jobtracker's view of the staging directory path where     * job-specific files will  be placed.    *     * @return the staging directory where job-specific files are to be placed.    */   public Path getStagingAreaDir() throws IOException, InterruptedException {     if (stagingAreaDir == null) {       stagingAreaDir = new Path(client.getStagingAreaDir());     }     return stagingAreaDir;   }    /**    * Get the job history file path for a given job id. The job history file at     * this path may or may not be existing depending on the job completion state.    * The file is present only for the completed jobs.    * @param jobId the JobID of the job submitted by the current user.    * @return the file path of the job history file    * @throws IOException    * @throws InterruptedException    */   public String getJobHistoryUrl(JobID jobId) throws IOException,      InterruptedException {     if (jobHistoryDir == null) {       jobHistoryDir = new Path(client.getJobHistoryDir());     }     return new Path(jobHistoryDir, jobId.toString() + &quot;_&quot;                     + ugi.getShortUserName()).toString();   }    /**    * Gets the Queue ACLs for current user    * @return array of QueueAclsInfo object for current user.    * @throws IOException    */   public QueueAclsInfo[] getQueueAclsForCurrentUser()        throws IOException, InterruptedException  {     return client.getQueueAclsForCurrentUser();   }    /**    * Gets the root level queues.    * @return array of JobQueueInfo object.    * @throws IOException    */   public QueueInfo[] getRootQueues() throws IOException, InterruptedException {     return client.getRootQueues();   }      /**    * Returns immediate children of queueName.    * @param queueName    * @return array of JobQueueInfo which are children of queueName    * @throws IOException    */   public QueueInfo[] getChildQueues(String queueName)        throws IOException, InterruptedException {     return client.getChildQueues(queueName);   }      /**    * Get the JobTracker's status.    *     * @return {@link JobTrackerStatus} of the JobTracker    * @throws IOException    * @throws InterruptedException    */   public JobTrackerStatus getJobTrackerStatus() throws IOException,       InterruptedException {     return client.getJobTrackerStatus();   }      /**    * Get the tasktracker expiry interval for the cluster    * @return the expiry interval in msec    */   public long getTaskTrackerExpiryInterval() throws IOException,       InterruptedException {     return client.getTaskTrackerExpiryInterval();   }    /**    * Get a delegation token for the user from the JobTracker.    * @param renewer the user who can renew the token    * @return the new token    * @throws IOException    */   public Token        getDelegationToken(Text renewer) throws IOException, InterruptedException{     // client has already set the service     return client.getDelegationToken(renewer);   }    /**    * Renew a delegation token    * @param token the token to renew    * @return the new expiration time    * @throws InvalidToken    * @throws IOException    * @deprecated Use {@link Token#renew} instead    */   public long renewDelegationToken(Token token                                    ) throws InvalidToken, IOException,                                             InterruptedException {     return token.renew(getConf());   }    /**    * Cancel a delegation token from the JobTracker    * @param token the token to cancel    * @throws IOException    * @deprecated Use {@link Token#cancel} instead    */   public void cancelDelegationToken(Token token                                     ) throws IOException,                                              InterruptedException {     token.cancel(getConf());   }  }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">3913</td>
    <td align="left">https://github.com/apache/hadoop-common/blob/42a61a4fbc88303913c4681f0d40ffcc737e70b5/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/Cluster.java/#L50-L429</td>
    <td align="right">1</td>
    <td align="right">382</td>
    <td align="right">3913</td>
  </tr>
  <tr valign="top">
    <td align="right">447</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells, the bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class ValidEmail {         @Email         String newEmail;          public String getNewEmail() {             return newEmail;         }          public void setNewEmail(String email) {             this.newEmail = email;         }     }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">&nbsp; </td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">4364</td>
    <td align="left">https://github.com/cloudfoundry/uaa/blob/f3b66dd2a250c1309a86cade560ac9a9cfeafec7/server/src/main/java/org/cloudfoundry/identity/uaa/account/ChangeEmailController.java/#L147-L158</td>
    <td align="right">1</td>
    <td align="right">447</td>
    <td align="right">4364</td>
  </tr>
  <tr valign="top">
    <td align="right">2067</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Long Method&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DefaultArtifact extends AbstractArtifact {      public static Artifact newIvyArtifact(ModuleRevisionId mrid, Date pubDate) {         return new DefaultArtifact(mrid, pubDate, &quot;ivy&quot;, &quot;ivy&quot;, &quot;xml&quot;, true);     }      public static Artifact newPomArtifact(ModuleRevisionId mrid, Date pubDate) {         return new DefaultArtifact(mrid, pubDate, mrid.getName(), &quot;pom&quot;, &quot;pom&quot;, true);     }      public static Artifact cloneWithAnotherExt(Artifact artifact, String newExt) {         return cloneWithAnotherTypeAndExt(artifact, artifact.getType(), newExt);     }      public static Artifact cloneWithAnotherType(Artifact artifact, String newType) {         return cloneWithAnotherTypeAndExt(artifact, newType, artifact.getExt());     }      public static Artifact cloneWithAnotherTypeAndExt(Artifact artifact, String newType,             String newExt) {         return new DefaultArtifact(ArtifactRevisionId.newInstance(artifact.getModuleRevisionId(),             artifact.getName(), newType, newExt, artifact.getQualifiedExtraAttributes()),                 artifact.getPublicationDate(), artifact.getUrl(), artifact.isMetadata());     }      public static Artifact cloneWithAnotherName(Artifact artifact, String name) {         return new DefaultArtifact(ArtifactRevisionId.newInstance(artifact.getModuleRevisionId(),             name, artifact.getType(), artifact.getExt(), artifact.getQualifiedExtraAttributes()),                 artifact.getPublicationDate(), artifact.getUrl(), artifact.isMetadata());     }      public static Artifact cloneWithAnotherMrid(Artifact artifact, ModuleRevisionId mrid) {         return new DefaultArtifact(ArtifactRevisionId.newInstance(mrid, artifact.getName(),             artifact.getType(), artifact.getExt(), artifact.getQualifiedExtraAttributes()),                 artifact.getPublicationDate(), artifact.getUrl(), artifact.isMetadata());     }      private Date publicationDate;      private ArtifactRevisionId arid;      private URL url;      private boolean isMetadata = false;      public DefaultArtifact(ModuleRevisionId mrid, Date publicationDate, String name, String type,             String ext) {         this(mrid, publicationDate, name, type, ext, null, null);     }      public DefaultArtifact(ModuleRevisionId mrid, Date publicationDate, String name, String type,             String ext, boolean isMetadata) {         this(mrid, publicationDate, name, type, ext, null, null);         this.isMetadata = isMetadata;     }      public DefaultArtifact(ModuleRevisionId mrid, Date publicationDate, String name, String type,             String ext, Map extraAttributes) {         this(mrid, publicationDate, name, type, ext, null, extraAttributes);     }      public DefaultArtifact(ModuleRevisionId mrid, Date publicationDate, String name, String type,             String ext, URL url, Map extraAttributes) {         this(ArtifactRevisionId.newInstance(mrid, name, type, ext, extraAttributes),                 publicationDate, url, false);     }      public DefaultArtifact(ArtifactRevisionId arid, Date publicationDate, URL url,             boolean isMetadata) {         if (arid == null) {             throw new NullPointerException(&quot;null arid not allowed&quot;);         }         if (publicationDate == null) {             publicationDate = new Date();         }         this.publicationDate = publicationDate;         this.arid = arid;         this.url = url;         this.isMetadata = isMetadata;     }      public ModuleRevisionId getModuleRevisionId() {         return arid.getModuleRevisionId();     }      public String getName() {         return arid.getName();     }      public Date getPublicationDate() {         return publicationDate;     }      public String getType() {         return arid.getType();     }      public String getExt() {         return arid.getExt();     }      public ArtifactRevisionId getId() {         return arid;     }      public String[] getConfigurations() {         return new String[0];     }      public URL getUrl() {         return url;     }      public boolean isMetadata() {         return isMetadata;     } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">12996</td>
    <td align="left">https://github.com/apache/ant-ivy/blob/4ffcf8f06f238b17e78e8033c3e8278833e452eb/src/java/org/apache/ivy/core/module/descriptor/DefaultArtifact.java/#L30-L146</td>
    <td align="right">1</td>
    <td align="right">2067</td>
    <td align="right">12996</td>
  </tr>
  <tr valign="top">
    <td align="right">2097</td>
    <td align="left">&nbsp;YES, I found bad smells. the bad smells are: 1. Long class 2. Long method 3. Feature envy 4. Inconsistent naming conventions 5. Unnecessary comments 6. Data class 7. Frequent use of conditional statements and null checks 8. Complex and convoluted code logic 9. Violation of Liskov substitution principle (subclass Map4 does not strictly adhere to the behavior of its superclass Map3) 10. Use of raw types (set of raw type AbstractSet is used without specifying its generic type) 11. Violation of single responsibility principle (Map4 class handles both map data structure and internal iterator logic)</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
    private static class Map4 extends Map3 {         /** */         private static final long serialVersionUID = 0L;          /** */         protected K k4;          /** */         protected V v4;          /**          * Constructs map.          */         Map4() {             // No-op.         }          /**          * Constructs map.          *          * @param k1 Key1.          * @param v1 Value1.          * @param k2 Key2.          * @param v2 Value2.          * @param k3 Key3.          * @param v3 Value3.          * @param k4 Key4.          * @param v4 Value4.          */         Map4(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {             super(k1, v1, k2, v2, k3, v3);              this.k4 = k4;             this.v4 = v4;         }          /** {@inheritDoc} */         @Override public boolean isFull() {             return size() == 4;         }          /** {@inheritDoc} */         @Nullable @Override public V remove(Object key) {             if (F.eq(key, k4)) {                 V res = v4;                  v4 = null;                 k4 = null;                  return res;             }              return super.remove(key);         }          /** {@inheritDoc} */         @Override public int size() {             return super.size() + (k4 != null ? 1 : 0);         }          /** {@inheritDoc} */         @Override public boolean containsKey(Object k) {             return super.containsKey(k) || (k4 != null &amp;&amp; F.eq(k, k4));         }          /** {@inheritDoc} */         @Override public boolean containsValue(Object v) {             return super.containsValue(v) || (k4 != null &amp;&amp; F.eq(v, v4));         }          /** {@inheritDoc} */         @Nullable @Override public V get(Object k) {             V v = super.get(k);              return v != null ? v : (k4 != null &amp;&amp; F.eq(k, k4)) ? v4 : null;         }          /**          * Puts key-value pair into map only if given key is already contained in the map          * or there are free slots.          * Note that this implementation of {@link Map#put(Object, Object)} does not match          * general contract of {@link Map} interface and serves only for internal purposes.          *          * @param key Key.          * @param val Value.          * @return Previous value associated with given key.          */         @Nullable @Override public V put(K key, V val) throws NullPointerException {             V oldVal = get(key);              if (k1 == null || F.eq(k1, key)) {                 k1 = key;                 v1 = val;             }             else if (k2 == null || F.eq(k2, key)) {                 k2 = key;                 v2 = val;             }             else if (k3 == null || F.eq(k3, key)) {                 k3 = key;                 v3 = val;             }             else if (k4 == null || F.eq(k4, key)) {                 k4 = key;                 v4 = val;             }              return oldVal;         }          /** {@inheritDoc} */         @Override public Set&gt; entrySet() {             return new AbstractSet&gt;() {                 @Override public Iterator&gt; iterator() {                     return new Iterator&gt;() {                         private int idx;                          private Entry next;                          {                             if (k1 != null) {                                 idx = 1;                                 next = e(k1, v1);                             }                             else if (k2 != null) {                                 idx = 2;                                 next = e(k2, v2);                             }                             else if (k3 != null) {                                 idx = 3;                                 next = e(k3, v3);                             }                             else if (k4 != null) {                                 idx = 4;                                 next = e(k4, v4);                             }                         }                          @Override public boolean hasNext() {                             return next != null;                         }                          @SuppressWarnings(&quot;fallthrough&quot;)                         @Override public Entry next() {                             if (!hasNext())                                 throw new NoSuchElementException();                              Entry old = next;                              next = null;                              switch (idx) {                                 case 1:                                     if (k2 != null) {                                         idx = 2;                                         next = e(k2, v2);                                          break;                                     }                                  case 2:                                     if (k3 != null) {                                         idx = 3;                                         next = e(k3, v3);                                          break;                                     }                                  case 3:                                     if (k4 != null) {                                         idx = 4;                                         next = e(k4, v4);                                          break;                                     }                             }                              return old;                         }                          @Override public void remove() {                             throw new UnsupportedOperationException();                         }                     };                 }                  @Override public int size() {                     return Map4.this.size();                 }             };         }     }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long class2 Long method3 Feature envy4 Inconsistent naming conventions5 Unnecessary comments6 Data class7 Frequent use of conditional statements and null checks8 Complex and convoluted code logic9 Violation of Liskov substitution principle (subclass Map4 does not strictly adhere to the behavior of its superclass Map3)</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13149</td>
    <td align="left">https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/core/src/main/java/org/apache/ignite/internal/util/GridLeanMap.java/#L836-L1027</td>
    <td align="right">2</td>
    <td align="right">2097</td>
    <td align="right">13149</td>
  </tr>
  <tr valign="top">
    <td align="right">2182</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class AccessRoleCreatorImpl extends AbstractKapuaEntityCreator implements AccessRoleCreator {      private static final long serialVersionUID = 972154225756734130L;      private KapuaId accessInfo;     private KapuaId roleId;      /**      * Constructor      *       * @param scopeId      */     public AccessRoleCreatorImpl(KapuaId scopeId) {         super(scopeId);     }      @Override     public KapuaId getAccessInfoId() {         return accessInfo;     }      @Override     public void setAccessInfoId(KapuaId accessInfo) {         this.accessInfo = accessInfo;     }      @Override     public KapuaId getRoleId() {         return roleId;     }      @Override     public void setRoleId(KapuaId roleId) {         this.roleId = roleId;     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13420</td>
    <td align="left">https://github.com/eclipse/kapua/blob/11e610c657f7e473b52882833e33a2261bd3d67d/service/security/shiro/src/main/java/org/eclipse/kapua/service/authorization/access/shiro/AccessRoleCreatorImpl.java/#L25-L61</td>
    <td align="right">1</td>
    <td align="right">2182</td>
    <td align="right">13420</td>
  </tr>
  <tr valign="top">
    <td align="right">2220</td>
    <td align="left">&nbsp;{ &quot;message&quot;: &quot;YES I found bad smells, the bad smells are: 1. Data Class&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SysInfo implements Serializable {      static final long serialVersionUID = -3096346807579L;      public int numCores;     public long maxMemory;      public SysInfo(int nc, long mm) {         numCores = nc;         maxMemory = mm;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13551</td>
    <td align="left">https://github.com/google/error-prone-javac/blob/a53d069bbdb2c60232ed3811c19b65e41c3e60e0/src/jdk.compiler/share/classes/com/sun/tools/sjavac/server/SysInfo.java/#L45-L56</td>
    <td align="right">1</td>
    <td align="right">2220</td>
    <td align="right">13551</td>
  </tr>
  <tr valign="top">
    <td align="right">120</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Status {  	private StatusCode code; 	private String message; 	private String detail;  	public StatusCode getCode() { 		return code; 	}  	public Status setCode(StatusCode code) { 		this.code = code; 		return this; 	}  	public String getMessage() { 		return message; 	}  	public Status setMessage(String message) { 		this.message = message; 		return this; 	}  	public String getDetail() { 		return detail; 	}  	public Status setDetail(String detail) { 		this.detail = detail; 		return this; 	} }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1519</td>
    <td align="left">https://github.com/spring-projects/spring-security-saml/blob/fa46190c8c37c2eb24b0fd424263c219ffe27e25/core/src/main/java/org/springframework/security/saml/saml2/authentication/Status.java/#L25-L57</td>
    <td align="right">1</td>
    <td align="right">120</td>
    <td align="right">1519</td>
  </tr>
  <tr valign="top">
    <td align="right">398</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SuppressWarnings(&quot;serial&quot;) public class GitHubUser implements Serializable {  	private final long id;  	private final String url;  	private final String login;  	private final String avatarUrl;  	private final String gravatarId;  	private String name;  	private String email;      public GitHubUser(long id, String url, String login, String avatarUrl, String gravatarId) {         this.id = id;         this.url = url;         this.login = login;         this.avatarUrl = avatarUrl;         this.gravatarId = gravatarId;     }      public Long getId() { return id; } 	 	public String getUrl() { return url; }  	public String getLogin() { return login; }  	public String getAvatarUrl() { return avatarUrl; }  	public String getGravatarId() { return gravatarId; } 	 	public String getName() { return name; } 	 	public void setName(String name) { this.name = name; } 	 	public String getEmail() { return email; } 	 	public void setEmail(String email) { this.email = email; } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4066</td>
    <td align="left">https://github.com/spring-projects/spring-social-github/blob/7939988245be49486d27c42c30bfb0a567c6ec1b/spring-social-github/src/main/java/org/springframework/social/github/api/GitHubUser.java/#L30-L72</td>
    <td align="right">1</td>
    <td align="right">398</td>
    <td align="right">4066</td>
  </tr>
  <tr valign="top">
    <td align="right">181</td>
    <td align="left"><br />
  {<br />
    &quot;message&quot;: &quot;YES I found bad smells&quot;,<br />
    &quot;bad smells are&quot;: [<br />
      &quot;Long method&quot;,<br />
      &quot;Data class&quot;<br />
    ]<br />
  }</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells).<br />
 Could you please identify which smells occur in the following code? However, do not describe the smells,<br />
 just list them. <br />
Please start your answer with &quot;YES I found bad smells&quot; when you find any bad smell. <br />
Otherwise, start your answer with &quot;NO, I did not find any bad smell&quot;. <br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells<br />
are:&quot; amongst the text your answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
  protected static class OnheapDecodedCell implements ExtendedCell {     private static final long FIXED_OVERHEAD = ClassSize.align(ClassSize.OBJECT         + (3 * ClassSize.REFERENCE) + (2 * Bytes.SIZEOF_LONG) + (7 * Bytes.SIZEOF_INT)         + (Bytes.SIZEOF_SHORT) + (2 * Bytes.SIZEOF_BYTE) + (3 * ClassSize.ARRAY));     private byte[] keyOnlyBuffer;     private short rowLength;     private int familyOffset;     private byte familyLength;     private int qualifierOffset;     private int qualifierLength;     private long timestamp;     private byte typeByte;     private byte[] valueBuffer;     private int valueOffset;     private int valueLength;     private byte[] tagsBuffer;     private int tagsOffset;     private int tagsLength;     private long seqId;      protected OnheapDecodedCell(byte[] keyBuffer, short rowLength, int familyOffset,         byte familyLength, int qualOffset, int qualLength, long timeStamp, byte typeByte,         byte[] valueBuffer, int valueOffset, int valueLen, long seqId, byte[] tagsBuffer,         int tagsOffset, int tagsLength) {       this.keyOnlyBuffer = keyBuffer;       this.rowLength = rowLength;       this.familyOffset = familyOffset;       this.familyLength = familyLength;       this.qualifierOffset = qualOffset;       this.qualifierLength = qualLength;       this.timestamp = timeStamp;       this.typeByte = typeByte;       this.valueBuffer = valueBuffer;       this.valueOffset = valueOffset;       this.valueLength = valueLen;       this.tagsBuffer = tagsBuffer;       this.tagsOffset = tagsOffset;       this.tagsLength = tagsLength;       setSequenceId(seqId);     }      @Override     public byte[] getRowArray() {       return keyOnlyBuffer;     }      @Override     public byte[] getFamilyArray() {       return keyOnlyBuffer;     }      @Override     public byte[] getQualifierArray() {       return keyOnlyBuffer;     }      @Override     public int getRowOffset() {       return Bytes.SIZEOF_SHORT;     }      @Override     public short getRowLength() {       return rowLength;     }      @Override     public int getFamilyOffset() {       return familyOffset;     }      @Override     public byte getFamilyLength() {       return familyLength;     }      @Override     public int getQualifierOffset() {       return qualifierOffset;     }      @Override     public int getQualifierLength() {       return qualifierLength;     }      @Override     public long getTimestamp() {       return timestamp;     }      @Override     public byte getTypeByte() {       return typeByte;     }      @Override     public long getSequenceId() {       return seqId;     }      @Override     public byte[] getValueArray() {       return this.valueBuffer;     }      @Override     public int getValueOffset() {       return valueOffset;     }      @Override     public int getValueLength() {       return valueLength;     }      @Override     public byte[] getTagsArray() {       return this.tagsBuffer;     }      @Override     public int getTagsOffset() {       return this.tagsOffset;     }      @Override     public int getTagsLength() {       return tagsLength;     }      @Override     public String toString() {       return KeyValue.keyToString(this.keyOnlyBuffer, 0, KeyValueUtil.keyLength(this)) + &quot;/vlen=&quot;           + getValueLength() + &quot;/seqid=&quot; + seqId;     }      @Override     public void setSequenceId(long seqId) {       this.seqId = seqId;     }      @Override     public long heapSize() {       return FIXED_OVERHEAD + rowLength + familyLength + qualifierLength + valueLength + tagsLength;     }      @Override     public int write(OutputStream out, boolean withTags) throws IOException {       int lenToWrite = getSerializedSize(withTags);       ByteBufferUtils.putInt(out, keyOnlyBuffer.length);       ByteBufferUtils.putInt(out, valueLength);       // Write key       out.write(keyOnlyBuffer);       // Write value       out.write(this.valueBuffer, this.valueOffset, this.valueLength);       if (withTags &amp;&amp; this.tagsLength &gt; 0) {         // 2 bytes tags length followed by tags bytes         // tags length is serialized with 2 bytes only(short way) even if the type is int.         // As this is non -ve numbers, we save the sign bit. See HBASE-11437         out.write((byte) (0xff &amp; (this.tagsLength &gt;&gt; 8)));         out.write((byte) (0xff &amp; this.tagsLength));         out.write(this.tagsBuffer, this.tagsOffset, this.tagsLength);       }       return lenToWrite;     }      @Override     public int getSerializedSize(boolean withTags) {       return KeyValueUtil.length(rowLength, familyLength, qualifierLength, valueLength, tagsLength,           withTags);     }      @Override     public void write(ByteBuffer buf, int offset) {       // This is not used in actual flow. Throwing UnsupportedOperationException       throw new UnsupportedOperationException();     }      @Override     public void setTimestamp(long ts) throws IOException {       // This is not used in actual flow. Throwing UnsupportedOperationException       throw new UnsupportedOperationException();     }      @Override     public void setTimestamp(byte[] ts) throws IOException {       // This is not used in actual flow. Throwing UnsupportedOperationException       throw new UnsupportedOperationException();     }      @Override     public ExtendedCell deepClone() {       // This is not used in actual flow. Throwing UnsupportedOperationException       throw new UnsupportedOperationException();     }   }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2064</td>
    <td align="left">https://github.com/apache/hbase/blob/44f8abd5c65c59e9d09f6ad14b3c825f145d8e4f/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/BufferedDataBlockEncoder.java/#L282-L478</td>
    <td align="right">2</td>
    <td align="right">181</td>
    <td align="right">2064</td>
  </tr>
  <tr valign="top">
    <td align="right">1893</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
		public Action getBinaryBitwiseExpressionLhsAction_1_0_0_0() { return cBinaryBitwiseExpressionLhsAction_1_0_0_0; } 		 		//op=BitwiseOROperator 		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; } 		 		//BitwiseOROperator 		public RuleCall getOpBitwiseOROperatorParserRuleCall_1_0_0_1_0() { return cOpBitwiseOROperatorParserRuleCall_1_0_0_1_0; } 		 		//rhs=BitwiseXORExpression 		public Assignment getRhsAssignment_1_1() { return cRhsAssignment_1_1; } 		 		//BitwiseXORExpression 		public RuleCall getRhsBitwiseXORExpressionParserRuleCall_1_1_0() { return cRhsBitwiseXORExpressionParserRuleCall_1_1_0; } 	} 	public class BitwiseOROperatorElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.n4js.N4JS.BitwiseOROperator&quot;); 		private final Keyword cVerticalLineKeyword = (Keyword)rule.eContents().get(1); 		 		//BitwiseOROperator BinaryBitwiseOperator: 		//	'|'; 		@Override public ParserRule getRule() { return rule; } 		 		//'|' 		public Keyword getVerticalLineKeyword() { return cVerticalLineKeyword; } 	} 	public class LogicalANDExpressionElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.n4js.N4JS.LogicalANDExpression&quot;); 		private final Group cGroup = (Group)rule.eContents().get(1); 		private final RuleCall cBitwiseORExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0); 		private final Group cGroup_1 = (Group)cGroup.eContents().get(1); 		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0); 		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0); 		private final Action cBinaryLogicalExpressionLhsAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0); 		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1); 		private final RuleCall cOpLogicalANDOperatorParserRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0); 		private final Assignment cRhsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1); 		private final RuleCall cRhsBitwiseORExpressionParserRuleCall_1_1_0 = (RuleCall)cRhsAssignment_1_1.eContents().get(0); 		 		//// $ (=&gt; ({BinaryLogicalExpression.lhs=current} op=LogicalANDOperator) 		//	rhs=BitwiseORExpression)*; 		@Override public ParserRule getRule() { return rule; } 		 		//BitwiseORExpression (=&gt; ({BinaryLogicalExpression.lhs=current} op=LogicalANDOperator) 		//rhs=BitwiseORExpression)* 		public Group getGroup() { return cGroup; } 		 		//BitwiseORExpression 		public RuleCall getBitwiseORExpressionParserRuleCall_0() { return cBitwiseORExpressionParserRuleCall_0; } 		</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12320</td>
    <td align="left">https://github.com/eclipse/n4js/blob/f715912fce0352ab574ff878086f77d17a78c908/plugins/org.eclipse.n4js/src-gen/org/eclipse/n4js/services/N4JSGrammarAccess.java/#L6096-L6144</td>
    <td align="right">1</td>
    <td align="right">1893</td>
    <td align="right">12320</td>
  </tr>
  <tr valign="top">
    <td align="right">2432</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells the bad smells are: 1. Blob, 2. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement(name = &quot;Product&quot;) public class Product {     private long id;     private String description;      public long getId() {         return id;     }      public void setId(long id) {         this.id = id;     }      public String getDescription() {         return description;     }      public void setDescription(String d) {         this.description = d;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14460</td>
    <td align="left">https://github.com/apache/cxf/blob/6bf89e9c8804c8845ec4d38583dd33eea8256439/distribution/src/main/release/samples/jax_rs/spring_security/src/main/java/demo/jaxrs/service/Product.java/#L23-L43</td>
    <td align="right">1</td>
    <td align="right">2432</td>
    <td align="right">14460</td>
  </tr>
  <tr valign="top">
    <td align="right">3818</td>
    <td align="left">&nbsp;&nbsp;YES, I found bad smells. The bad smells are: 1. Long method 2. Data class 3. Data clumps 4. Feature envy 5. Primitive obsession 6. Message chains </td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class NodeAnnounceMessage extends PacketImpl {     protected String nodeID;     protected String backupGroupName;     protected boolean backup;     protected long currentEventID;     protected TransportConfiguration connector;     protected TransportConfiguration backupConnector;     private String scaleDownGroupName;     // Static --------------------------------------------------------     // Constructors --------------------------------------------------     public NodeAnnounceMessage(final long currentEventID,                               final String nodeID,                               final String backupGroupName,                               final String scaleDownGroupName,                               final boolean backup,                               final TransportConfiguration tc,                               final TransportConfiguration backupConnector) {       super(NODE_ANNOUNCE);        this.currentEventID = currentEventID;        this.nodeID = nodeID;        this.backupGroupName = backupGroupName;        this.backup = backup;        this.connector = tc;        this.backupConnector = backupConnector;        this.scaleDownGroupName = scaleDownGroupName;    }     public NodeAnnounceMessage() {       super(NODE_ANNOUNCE);    }     public NodeAnnounceMessage(byte nodeAnnounceMessage_V2) {       super(nodeAnnounceMessage_V2);    }     // Public --------------------------------------------------------     public String getNodeID() {       return nodeID;    }     public String getBackupGroupName() {       return backupGroupName;    }     public boolean isBackup() {       return backup;    }     public TransportConfiguration getConnector() {       return connector;    }     public TransportConfiguration getBackupConnector() {       return backupConnector;    }     public String getScaleDownGroupName() {       return scaleDownGroupName;    }     /**     * @return the currentEventID     */    public long getCurrentEventID() {       return currentEventID;    }     @Override    public void encodeRest(final ActiveMQBuffer buffer) {       buffer.writeString(nodeID);       buffer.writeNullableString(backupGroupName);       buffer.writeBoolean(backup);       buffer.writeLong(currentEventID);       if (connector != null) {          buffer.writeBoolean(true);          connector.encode(buffer);       } else {          buffer.writeBoolean(false);       }       if (backupConnector != null) {          buffer.writeBoolean(true);          backupConnector.encode(buffer);       } else {          buffer.writeBoolean(false);       }       buffer.writeNullableString(scaleDownGroupName);    }     @Override    public void decodeRest(final ActiveMQBuffer buffer) {       this.nodeID = buffer.readString();       this.backupGroupName = buffer.readNullableString();       this.backup = buffer.readBoolean();       this.currentEventID = buffer.readLong();       if (buffer.readBoolean()) {          connector = new TransportConfiguration();          connector.decode(buffer);       }       if (buffer.readBoolean()) {          backupConnector = new TransportConfiguration();          backupConnector.decode(buffer);       }       scaleDownGroupName = buffer.readNullableString();    }     @Override    public String toString() {       return &quot;NodeAnnounceMessage [backup=&quot; + backup +          &quot;, connector=&quot; +          connector +          &quot;, nodeID=&quot; +          nodeID +          &quot;, toString()=&quot; +          super.toString() +          &quot;]&quot;;    }     @Override    public int hashCode() {       final int prime = 31;       int result = super.hashCode();       result = prime * result + (backup ? 1231 : 1237);       result = prime * result + ((backupConnector == null) ? 0 : backupConnector.hashCode());       result = prime * result + ((connector == null) ? 0 : connector.hashCode());       result = prime * result + (int) (currentEventID ^ (currentEventID &gt;&gt;&gt; 32));       result = prime * result + ((nodeID == null) ? 0 : nodeID.hashCode());       result = prime * result + ((scaleDownGroupName == null) ? 0 : scaleDownGroupName.hashCode());       return result;    }     @Override    public boolean equals(Object obj) {       if (this == obj) {          return true;       }       if (!super.equals(obj)) {          return false;       }       if (!(obj instanceof NodeAnnounceMessage)) {          return false;       }       NodeAnnounceMessage other = (NodeAnnounceMessage) obj;       if (backup != other.backup) {          return false;       }       if (backupConnector == null) {          if (other.backupConnector != null) {             return false;          }       } else if (!backupConnector.equals(other.backupConnector)) {          return false;       }       if (connector == null) {          if (other.connector != null) {             return false;          }       } else if (!connector.equals(other.connector)) {          return false;       }       if (currentEventID != other.currentEventID) {          return false;       }       if (nodeID == null) {          if (other.nodeID != null) {             return false;          }       } else if (!nodeID.equals(other.nodeID)) {          return false;       } else if (!scaleDownGroupName.equals(other.scaleDownGroupName)) {          return false;       }       return true;    } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method2 Data class3 Data clumps4 Feature envy5 Primitive obsession6 Message chains </td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9732</td>
    <td align="left">https://github.com/apache/activemq-artemis/blob/5bd5c610195d6f4a3dd1ac28170727003f8a5a54/artemis-server/src/main/java/org/apache/activemq/artemis/core/protocol/core/impl/wireformat/NodeAnnounceMessage.java/#L23-L214</td>
    <td align="right">2</td>
    <td align="right">3818</td>
    <td align="right">9732</td>
  </tr>
  <tr valign="top">
    <td align="right">765</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class HeaderSection extends UniformItemSection {     /** {@code non-null;} the list of the one item in the section */     private final List list;      /**      * Constructs an instance. The file offset is initially unknown.      *      * @param file {@code non-null;} file that this instance is part of      */     public HeaderSection(DexFile file) {         super(null, file, 4);          HeaderItem item = new HeaderItem();         item.setIndex(0);          this.list = Collections.singletonList(item);     }      /** {@inheritDoc} */     @Override     public IndexedItem get(Constant cst) {         return null;     }      /** {@inheritDoc} */     @Override     public Collection items() {         return list;     }      /** {@inheritDoc} */     @Override     protected void orderItems() {         // Nothing to do here.     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7136</td>
    <td align="left">https://github.com/facebook/buck/blob/1bc8d383ea5cb153ca9bf4f2807e6be498648523/third-party/java/dx/src/com/android/dx/dex/file/HeaderSection.java/#L27-L62</td>
    <td align="right">1</td>
    <td align="right">765</td>
    <td align="right">7136</td>
  </tr>
  <tr valign="top">
    <td align="right">1257</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Blob&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;faces-config-propertyType&quot;, propOrder = {     &quot;descriptions&quot;,     &quot;displayNames&quot;,     &quot;icon&quot;,     &quot;propertyName&quot;,     &quot;propertyClass&quot;,     &quot;defaultValue&quot;,     &quot;suggestedValue&quot;,     &quot;propertyExtension&quot; }) public class FacesProperty {      @XmlTransient     protected TextMap description = new TextMap();     @XmlTransient     protected TextMap displayName = new TextMap();     @XmlElement(name = &quot;icon&quot;, required = true)     protected LocalCollection icon = new LocalCollection();     @XmlElement(name = &quot;property-name&quot;, required = true)     protected java.lang.String propertyName;     @XmlElement(name = &quot;property-class&quot;, required = true)     protected java.lang.String propertyClass;     @XmlElement(name = &quot;default-value&quot;)     protected java.lang.String defaultValue;     @XmlElement(name = &quot;suggested-value&quot;)     protected java.lang.String suggestedValue;     @XmlElement(name = &quot;property-extension&quot;)     protected List propertyExtension;     @XmlAttribute     @XmlJavaTypeAdapter(CollapsedStringAdapter.class)     @XmlID     @XmlSchemaType(name = &quot;ID&quot;)     protected java.lang.String id;      @XmlElement(name = &quot;description&quot;, required = true)     public Text[] getDescriptions() {         return description.toArray();     }      public void setDescriptions(Text[] text) {         description.set(text);     }      public String getDescription() {         return description.get();     }      @XmlElement(name = &quot;display-name&quot;, required = true)     public Text[] getDisplayNames() {         return displayName.toArray();     }      public void setDisplayNames(Text[] text) {         displayName.set(text);     }      public String getDisplayName() {         return displayName.get();     }      public Collection getIcons() {         if (icon == null) {             icon = new LocalCollection();         }         return icon;     }      public Map getIconMap() {         if (icon == null) {             icon = new LocalCollection();         }         return icon.toMap();     }      public Icon getIcon() {         return icon.getLocal();     }      /**      * Gets the value of the propertyName property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getPropertyName() {         return propertyName;     }      /**      * Sets the value of the propertyName property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setPropertyName(java.lang.String value) {         this.propertyName = value;     }      /**      * Gets the value of the propertyClass property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getPropertyClass() {         return propertyClass;     }      /**      * Sets the value of the propertyClass property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setPropertyClass(java.lang.String value) {         this.propertyClass = value;     }      /**      * Gets the value of the defaultValue property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getDefaultValue() {         return defaultValue;     }      /**      * Sets the value of the defaultValue property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setDefaultValue(java.lang.String value) {         this.defaultValue = value;     }      /**      * Gets the value of the suggestedValue property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getSuggestedValue() {         return suggestedValue;     }      /**      * Sets the value of the suggestedValue property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setSuggestedValue(java.lang.String value) {         this.suggestedValue = value;     }      /**      * Gets the value of the propertyExtension property.      *       *       * This accessor method returns a reference to the live list,      * not a snapshot. Therefore any modification you make to the      * returned list will be present inside the JAXB object.      * This is why there is not a set method for the propertyExtension property.      *       *       * For example, to add a new item, do as follows:      *       *    getPropertyExtension().add(newItem);      *       *       *       *       * Objects of the following type(s) are allowed in the list      * {@link FacesPropertyExtension }      *       *       */     public List getPropertyExtension() {         if (propertyExtension == null) {             propertyExtension = new ArrayList();         }         return this.propertyExtension;     }      /**      * Gets the value of the id property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getId() {         return id;     }      /**      * Sets the value of the id property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setId(java.lang.String value) {         this.id = value;     }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10498</td>
    <td align="left">https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/container/openejb-jee/src/main/java/org/apache/openejb/jee/FacesProperty.java/#L70-L298</td>
    <td align="right">1</td>
    <td align="right">1257</td>
    <td align="right">10498</td>
  </tr>
  <tr valign="top">
    <td align="right">1965</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SignatureSupportingConfigProperties {      private String sharedSecret;     private String keyPath;     private long tokenExpirationSeconds = 600L;     private String certificatePath;      /**      * Gets the secret used for creating and validating HmacSHA256 based signatures.      *       * @return The secret or {@code null} if not set.      */     public final String getSharedSecret() {         return sharedSecret;     }      /**      * Sets the secret to use for creating and validating HmacSHA256 based signatures.      *       * @param secret The shared secret.      * @throws NullPointerException if secret is {@code null}.      * @throws IllegalArgumentException if the secret is &lt; 32 bytes.      */     public final void setSharedSecret(final String secret) {         if (Objects.requireNonNull(secret).getBytes(StandardCharsets.UTF_8).length &lt; 32) {             throw new IllegalArgumentException(&quot;shared secret must be at least 32 bytes&quot;);         }         this.sharedSecret = secret;     }      /**      * Sets the path to the file containing the private key to be used      * for creating SHA256withRSA based signatures.      *       * The file must be in PKCS8 PEM format.      *       * @param keyPath The path to the PEM file.      * @throws NullPointerException if the path is {@code null}.      */     public final void setKeyPath(final String keyPath) {         this.keyPath = Objects.requireNonNull(keyPath);     }      /**      * Gets the path to the file containing the private key to be used      * for validating RSA based signatures.      *       * @return The path to the file or {@code null} if not set.      */     public final String getKeyPath() {         return keyPath;     }      /**      * Gets the period of time after which tokens created using this configuration should expire.      *       * @return The number of seconds after which tokens expire.      */     public final long getTokenExpiration() {         return tokenExpirationSeconds;     }      /**      * Sets the period of time after which tokens created using this configuration should expire.      *       * The default value is 600 seconds (10 minutes).      *       * @param seconds The number of seconds after which tokens expire.      * @throws IllegalArgumentException if seconds is &lt;= 0.      */     public final void setTokenExpiration(final long seconds) {         if (seconds &lt;= 0) {             throw new IllegalArgumentException(&quot;token expiration must be &gt; 0&quot;);         }         this.tokenExpirationSeconds = seconds;     }      /**      * Sets the path to the X.509 certificate containing the public key to be used      * for validating SHA256withRSA based signatures.      *       * The file must be in PKCS8 PEM format.      *       * @param certPath The path to the PEM file.      * @throws NullPointerException if the path is {@code null}.      */     public final void setCertPath(final String certPath) {         this.certificatePath = Objects.requireNonNull(certPath);     }      /**      * Gets the path to the X.509 certificate containing the public key to be used      * for validating RSA based signatures.      *       * @return The path to the file or {@code null} if not set.      */     public final String getCertPath() {         return certificatePath;     }      /**      * Checks if this configuration contains enough information for creating assertions.      *       * @return {@code true} if any of sharedSecret or keyPath is not {@code null}.      */     public final boolean isAppropriateForCreating() {         return sharedSecret != null || keyPath != null;     }      /**      * Checks if this configuration contains enough information for validating assertions.      *       * @return {@code true} if any of sharedSecret or certificatePath is not {@code null}.      */     public final boolean isAppropriateForValidating() {         return sharedSecret != null || certificatePath != null;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12591</td>
    <td align="left">https://github.com/eclipse/hono/blob/ec84947227564c6459801f708bdeabd7687a8bf0/core/src/main/java/org/eclipse/hono/config/SignatureSupportingConfigProperties.java/#L22-L139</td>
    <td align="right">1</td>
    <td align="right">1965</td>
    <td align="right">12591</td>
  </tr>
  <tr valign="top">
    <td align="right">947</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class _Repository4Soap_QueryPendingSetsWithLocalWorkspaces     implements ElementSerializable {     // No attributes          // Elements     protected String localWorkspaceName;     protected String localWorkspaceOwner;     protected String queryWorkspaceName;     protected String ownerName;     protected _ItemSpec[] itemSpecs;     protected boolean generateDownloadUrls;     protected String[] itemPropertyFilters;      public _Repository4Soap_QueryPendingSetsWithLocalWorkspaces()     {         super();     }      public _Repository4Soap_QueryPendingSetsWithLocalWorkspaces(         final String localWorkspaceName,         final String localWorkspaceOwner,         final String queryWorkspaceName,         final String ownerName,         final _ItemSpec[] itemSpecs,         final boolean generateDownloadUrls,         final String[] itemPropertyFilters)     {         // TODO : Call super() instead of setting all fields directly?         setLocalWorkspaceName(localWorkspaceName);         setLocalWorkspaceOwner(localWorkspaceOwner);         setQueryWorkspaceName(queryWorkspaceName);         setOwnerName(ownerName);         setItemSpecs(itemSpecs);         setGenerateDownloadUrls(generateDownloadUrls);         setItemPropertyFilters(itemPropertyFilters);     }      public String getLocalWorkspaceName()     {         return this.localWorkspaceName;     }      public void setLocalWorkspaceName(String value)     {         this.localWorkspaceName = value;     }      public String getLocalWorkspaceOwner()     {         return this.localWorkspaceOwner;     }      public void setLocalWorkspaceOwner(String value)     {         this.localWorkspaceOwner = value;     }      public String getQueryWorkspaceName()     {         return this.queryWorkspaceName;     }      public void setQueryWorkspaceName(String value)     {         this.queryWorkspaceName = value;     }      public String getOwnerName()     {         return this.ownerName;     }      public void setOwnerName(String value)     {         this.ownerName = value;     }      public _ItemSpec[] getItemSpecs()     {         return this.itemSpecs;     }      public void setItemSpecs(_ItemSpec[] value)     {         this.itemSpecs = value;     }      public boolean isGenerateDownloadUrls()     {         return this.generateDownloadUrls;     }      public void setGenerateDownloadUrls(boolean value)     {         this.generateDownloadUrls = value;     }      public String[] getItemPropertyFilters()     {         return this.itemPropertyFilters;     }      public void setItemPropertyFilters(String[] value)     {         this.itemPropertyFilters = value;     }      public void writeAsElement(         final XMLStreamWriter writer,         final String name)         throws XMLStreamException     {         writer.writeStartElement(name);          // Elements         XMLStreamWriterHelper.writeElement(             writer,             &quot;localWorkspaceName&quot;,             this.localWorkspaceName);         XMLStreamWriterHelper.writeElement(             writer,             &quot;localWorkspaceOwner&quot;,             this.localWorkspaceOwner);         XMLStreamWriterHelper.writeElement(             writer,             &quot;queryWorkspaceName&quot;,             this.queryWorkspaceName);         XMLStreamWriterHelper.writeElement(             writer,             &quot;ownerName&quot;,             this.ownerName);          if (this.itemSpecs != null)         {             /*              * The element type is an array.              */             writer.writeStartElement(&quot;itemSpecs&quot;);              for (int iterator0 = 0; iterator0 &lt; this.itemSpecs.length; iterator0++)             {                 this.itemSpecs[iterator0].writeAsElement(                     writer,                     &quot;ItemSpec&quot;);             }              writer.writeEndElement();         }          XMLStreamWriterHelper.writeElement(             writer,             &quot;generateDownloadUrls&quot;,             this.generateDownloadUrls);          if (this.itemPropertyFilters != null)         {             /*              * The element type is an array.              */             writer.writeStartElement(&quot;itemPropertyFilters&quot;);              for (int iterator0 = 0; iterator0 &lt; this.itemPropertyFilters.length; iterator0++)             {                 XMLStreamWriterHelper.writeElement(                     writer,                     &quot;string&quot;,                     this.itemPropertyFilters[iterator0]);             }              writer.writeEndElement();         }          writer.writeEndElement();     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8507</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core.ws/generated-src/ms/tfs/versioncontrol/clientservices/_03/_Repository4Soap_QueryPendingSetsWithLocalWorkspaces.java/#L33-L208</td>
    <td align="right">1</td>
    <td align="right">947</td>
    <td align="right">8507</td>
  </tr>
  <tr valign="top">
    <td align="right">535</td>
    <td align="left">{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;the bad smells are&quot;: [     &quot;1. Long Method&quot;,     &quot;2. Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class OperatorWrapper {   @SuppressWarnings(&quot;unused&quot;)   private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(OperatorWrapper.class);    private static final DecimalFormat DECIMAL_FORMATTER = new DecimalFormat(&quot;#.##&quot;);   private static final String UNKNOWN_OPERATOR = &quot;UNKNOWN_OPERATOR&quot;;   //Negative valued constant used for denoting invalid index to indicate absence of metric   private static final int NO_SPILL_METRIC_INDEX = Integer.MIN_VALUE;   private final int major;   private final List, String&gt;&gt; opsAndHosts; // [(operatorProfile --&gt; minorFragment number,host), ...]   private final OperatorProfile firstProfile;   private final CoreOperatorType operatorType;   private final String operatorName;   private final int size;   private final int timeSkewMin;   private final double timeSkewRatio;   private final int scanWaitMin;   private final double waitSkewRatio;    public OperatorWrapper(int major, List, String&gt;&gt; opsAndHostsList, Map phyOperMap, DrillConfig config) {     //Threshold to track if the slowest operator ran relatively slow     timeSkewMin = config.getInt(ExecConstants.PROFILE_WARNING_TIME_SKEW_MIN);     timeSkewRatio = config.getDouble(ExecConstants.PROFILE_WARNING_TIME_SKEW_RATIO_PROCESS);     //Threshold to track if the slowest SCAN operator spent more time in wait than processing     scanWaitMin = config.getInt(ExecConstants.PROFILE_WARNING_SCAN_WAIT_MIN);     waitSkewRatio = config.getDouble(ExecConstants.PROFILE_WARNING_TIME_SKEW_RATIO_WAIT);      Preconditions.checkArgument(opsAndHostsList.size() &gt; 0);     this.major = major;     firstProfile = opsAndHostsList.get(0).getLeft().getLeft();     operatorType = CoreOperatorType.valueOf(firstProfile.getOperatorType());     //Update Name from Physical Map     String path = new OperatorPathBuilder().setMajor(major).setOperator(firstProfile).build();     //Use Plan Extracted Operator Names if available     String extractedOpName = phyOperMap.get(path);     String inferredOpName = operatorType == null ? UNKNOWN_OPERATOR : operatorType.toString();     //Revert to inferred names for exceptional cases     // 1. Extracted 'FLATTEN' operator is NULL     // 2. Extracted 'SCAN' could be a PARQUET_ROW_GROUP_SCAN, or KAFKA_SUB_SCAN, or etc.     // 3. Extracted 'UNION_EXCHANGE' could be a SINGLE_SENDER or UNORDERED_RECEIVER     if (extractedOpName == null || inferredOpName.contains(extractedOpName) || extractedOpName.endsWith(&quot;_EXCHANGE&quot;)) {       operatorName =  inferredOpName;     } else {       operatorName =  extractedOpName;     }     this.opsAndHosts = opsAndHostsList;     size = opsAndHostsList.size();   }    public String getDisplayName() {     final String path = new OperatorPathBuilder().setMajor(major).setOperator(firstProfile).build();     return String.format(&quot;%s - %s&quot;, path, operatorName);   }    public String getId() {     return String.format(&quot;operator-%d-%d&quot;, major, opsAndHosts.get(0).getLeft().getLeft().getOperatorId());   }    public static final String [] OPERATOR_COLUMNS = {       OperatorTblTxt.MINOR_FRAGMENT, OperatorTblTxt.HOSTNAME, OperatorTblTxt.SETUP_TIME, OperatorTblTxt.PROCESS_TIME, OperatorTblTxt.WAIT_TIME,       OperatorTblTxt.MAX_BATCHES, OperatorTblTxt.MAX_RECORDS, OperatorTblTxt.PEAK_MEMORY   };    public static final String [] OPERATOR_COLUMNS_TOOLTIP = {       OperatorTblTooltip.MINOR_FRAGMENT, OperatorTblTooltip.HOSTNAME, OperatorTblTooltip.SETUP_TIME, OperatorTblTooltip.PROCESS_TIME, OperatorTblTooltip.WAIT_TIME,       OperatorTblTooltip.MAX_BATCHES, OperatorTblTooltip.MAX_RECORDS, OperatorTblTooltip.PEAK_MEMORY   };    public String getContent() {     TableBuilder builder = new TableBuilder(OPERATOR_COLUMNS, OPERATOR_COLUMNS_TOOLTIP, true);      Map attributeMap = new HashMap&lt;&gt;(); //Reusing for different fragments     for (ImmutablePair, String&gt; ip : opsAndHosts) {       int minor = ip.getLeft().getRight();       OperatorProfile op = ip.getLeft().getLeft();        attributeMap.put(HtmlAttribute.DATA_ORDER, String.valueOf(minor)); //Overwrite values from previous fragments       String path = new OperatorPathBuilder().setMajor(major).setMinor(minor).setOperator(op).build();       builder.appendCell(path, attributeMap);       builder.appendCell(ip.getRight());       builder.appendNanos(op.getSetupNanos());       builder.appendNanos(op.getProcessNanos());       builder.appendNanos(op.getWaitNanos());        long maxBatches = Long.MIN_VALUE;       long maxRecords = Long.MIN_VALUE;       for (StreamProfile sp : op.getInputProfileList()) {         maxBatches = Math.max(sp.getBatches(), maxBatches);         maxRecords = Math.max(sp.getRecords(), maxRecords);       }        builder.appendFormattedInteger(maxBatches);       builder.appendFormattedInteger(maxRecords);       builder.appendBytes(op.getPeakLocalMemoryAllocated());     }     return builder.build();   }    public static final String[] OPERATORS_OVERVIEW_COLUMNS = {       OverviewTblTxt.OPERATOR_ID, OverviewTblTxt.TYPE_OF_OPERATOR,       OverviewTblTxt.AVG_SETUP_TIME, OverviewTblTxt.MAX_SETUP_TIME,       OverviewTblTxt.AVG_PROCESS_TIME, OverviewTblTxt.MAX_PROCESS_TIME,       OverviewTblTxt.MIN_WAIT_TIME, OverviewTblTxt.AVG_WAIT_TIME, OverviewTblTxt.MAX_WAIT_TIME,       OverviewTblTxt.PERCENT_FRAGMENT_TIME, OverviewTblTxt.PERCENT_QUERY_TIME, OverviewTblTxt.ROWS,       OverviewTblTxt.AVG_PEAK_MEMORY, OverviewTblTxt.MAX_PEAK_MEMORY   };    public static final String[] OPERATORS_OVERVIEW_COLUMNS_TOOLTIP = {       OverviewTblTooltip.OPERATOR_ID, OverviewTblTooltip.TYPE_OF_OPERATOR,       OverviewTblTooltip.AVG_SETUP_TIME, OverviewTblTooltip.MAX_SETUP_TIME,       OverviewTblTooltip.AVG_PROCESS_TIME, OverviewTblTooltip.MAX_PROCESS_TIME,       OverviewTblTooltip.MIN_WAIT_TIME, OverviewTblTooltip.AVG_WAIT_TIME, OverviewTblTooltip.MAX_WAIT_TIME,       OverviewTblTooltip.PERCENT_FRAGMENT_TIME, OverviewTblTooltip.PERCENT_QUERY_TIME, OverviewTblTooltip.ROWS,       OverviewTblTooltip.AVG_PEAK_MEMORY, OverviewTblTooltip.MAX_PEAK_MEMORY   };    //Palette to help shade operators sharing a common major fragment   private static final String[] OPERATOR_OVERVIEW_BGCOLOR_PALETTE = {&quot;#ffffff&quot;,&quot;#f2f2f2&quot;};    public void addSummary(TableBuilder tb, Map majorFragmentBusyTally, long majorFragmentBusyTallyTotal) {     //Select background color from palette     String opTblBgColor = OPERATOR_OVERVIEW_BGCOLOR_PALETTE[major%OPERATOR_OVERVIEW_BGCOLOR_PALETTE.length];     String path = new OperatorPathBuilder().setMajor(major).setOperator(firstProfile).build();     tb.appendCell(path, opTblBgColor, null);     tb.appendCell(operatorName);      //Check if spill information is available     int spillCycleMetricIndex = getSpillCycleMetricIndex(operatorType);     boolean isSpillableOp = (spillCycleMetricIndex != NO_SPILL_METRIC_INDEX);     boolean hasSpilledToDisk = false;     boolean isScanOp = operatorName.endsWith(&quot;SCAN&quot;);      //Get MajorFragment Busy+Wait Time Tally     long majorBusyNanos = majorFragmentBusyTally.get(new OperatorPathBuilder().setMajor(major).build());      double setupSum = 0.0;     double processSum = 0.0;     double waitSum = 0.0;     double memSum = 0.0;     double spillCycleSum = 0.0;     long spillCycleMax = 0L;     long recordSum = 0L;      //Construct list for sorting purposes (using legacy Comparators)     final List&gt; opList = new ArrayList&lt;&gt;();      for (ImmutablePair,String&gt; ip : opsAndHosts) {       OperatorProfile profile = ip.getLeft().getLeft();       setupSum += profile.getSetupNanos();       processSum += profile.getProcessNanos();       waitSum += profile.getWaitNanos();       memSum += profile.getPeakLocalMemoryAllocated();       for (final StreamProfile sp : profile.getInputProfileList()) {         recordSum += sp.getRecords();       }       opList.add(ip.getLeft());        //Capture Spill Info       //Check to ensure index &lt; #metrics (old profiles have less metrics); else reset isSpillableOp       if (isSpillableOp) {         //NOTE: We get non-zero value for non-existent metrics, so we can't use getMetric(index)         //profile.getMetric(spillCycleMetricIndex).getLongValue();         //Forced to iterate list         for (MetricValue metricVal : profile.getMetricList()) {           if (metricVal.getMetricId() == spillCycleMetricIndex) {             long spillCycles = metricVal.getLongValue();             spillCycleMax = Math.max(spillCycles, spillCycleMax);             spillCycleSum += spillCycles;             hasSpilledToDisk = (spillCycleSum &gt; 0.0);           }         }       }     }      final ImmutablePair longSetup = Collections.max(opList, Comparators.setupTime);     tb.appendNanos(Math.round(setupSum / size));     tb.appendNanos(longSetup.getLeft().getSetupNanos());      Map timeSkewMap = null;     final ImmutablePair longProcess = Collections.max(opList, Comparators.processTime);     //Calculating average processing time     long avgProcTime = Math.round(processSum / size);     tb.appendNanos(avgProcTime);     long maxProcTime = longProcess.getLeft().getProcessNanos();     //Calculating skew of longest processing fragment w.r.t. average     double maxSkew = (avgProcTime &gt; 0) ? maxProcTime/Double.valueOf(avgProcTime) : 0.0d;     //Marking skew if both thresholds are crossed     if (avgProcTime &gt; TimeUnit.SECONDS.toNanos(timeSkewMin) &amp;&amp; maxSkew &gt; timeSkewRatio ) {       timeSkewMap = new HashMap&lt;&gt;();       timeSkewMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_TIME_SKEW_TAG);       timeSkewMap.put(HtmlAttribute.TITLE,  &quot;One fragment took &quot; + DECIMAL_FORMATTER.format(maxSkew) + &quot; longer than average&quot;);       timeSkewMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);     }     tb.appendNanos(maxProcTime, timeSkewMap);      final ImmutablePair shortWait = Collections.min(opList, Comparators.waitTime);     final ImmutablePair longWait = Collections.max(opList, Comparators.waitTime);     tb.appendNanos(shortWait.getLeft().getWaitNanos());     //Calculating average wait time for fragment     long avgWaitTime = Math.round(waitSum / size);      //Slow Scan Warning     Map slowScanMap = null;     //Marking slow scan if threshold is crossed and wait was longer than processing     if (isScanOp &amp;&amp; (avgWaitTime &gt; TimeUnit.SECONDS.toNanos(scanWaitMin)) &amp;&amp; (avgWaitTime &gt; avgProcTime)) {       slowScanMap = new HashMap&lt;&gt;();       slowScanMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_SCAN_WAIT_TAG);       slowScanMap.put(HtmlAttribute.TITLE, &quot;Avg Wait Time &gt; Avg Processing Time&quot;);       slowScanMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);     }     tb.appendNanos(avgWaitTime, slowScanMap);      long maxWaitTime = longWait.getLeft().getWaitNanos();     //Skewed Wait Warning     timeSkewMap = null; //Resetting     //Calculating skew of longest waiting fragment w.r.t. average     maxSkew = (avgWaitTime &gt; 0) ? maxWaitTime/Double.valueOf(avgWaitTime) : 0.0d;     //Marking skew if both thresholds are crossed     if (avgWaitTime &gt; TimeUnit.SECONDS.toNanos(timeSkewMin) &amp;&amp; maxSkew &gt; waitSkewRatio) {       timeSkewMap = new HashMap&lt;&gt;();       timeSkewMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_TIME_SKEW_TAG);       timeSkewMap.put(HtmlAttribute.TITLE, &quot;One fragment waited &quot; + DECIMAL_FORMATTER.format(maxSkew) + &quot; longer than average&quot;);       timeSkewMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);     }     tb.appendNanos(maxWaitTime, timeSkewMap);      tb.appendPercent(processSum / majorBusyNanos);     tb.appendPercent(processSum / majorFragmentBusyTallyTotal);      tb.appendFormattedInteger(recordSum);      final ImmutablePair peakMem = Collections.max(opList, Comparators.operatorPeakMemory);      //Inject spill-to-disk attributes     Map avgSpillMap = null;     Map maxSpillMap = null;     if (hasSpilledToDisk) {       avgSpillMap = new HashMap&lt;&gt;();       //Average SpillCycle       double avgSpillCycle = spillCycleSum/size;       avgSpillMap.put(HtmlAttribute.TITLE, DECIMAL_FORMATTER.format(avgSpillCycle) + &quot; spills on average&quot;);       avgSpillMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);       avgSpillMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_SPILL_TAG); //JScript will inject Icon       avgSpillMap.put(HtmlAttribute.SPILLS, DECIMAL_FORMATTER.format(avgSpillCycle)); //JScript will inject Count       maxSpillMap = new HashMap&lt;&gt;();       maxSpillMap.put(HtmlAttribute.TITLE, &quot;Most # spills: &quot; + spillCycleMax);       maxSpillMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);       maxSpillMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_SPILL_TAG); //JScript will inject Icon       maxSpillMap.put(HtmlAttribute.SPILLS, String.valueOf(spillCycleMax)); //JScript will inject Count     }      tb.appendBytes(Math.round(memSum / size), avgSpillMap);     tb.appendBytes(peakMem.getLeft().getPeakLocalMemoryAllocated(), maxSpillMap);   }    /**    * Returns index of Spill Count/Cycle metric    * @param operatorType    * @return index of spill metric    */   private int getSpillCycleMetricIndex(CoreOperatorType operatorType) {     // TODO: DRILL-6642, replace null values for ProtocolMessageEnum with UNRECOGNIZED NullValue to avoid null checks     if (operatorType == null) {       return NO_SPILL_METRIC_INDEX;     }     String metricName;      switch (operatorType) {     case EXTERNAL_SORT:       metricName = &quot;SPILL_COUNT&quot;;       break;     case HASH_AGGREGATE:     case HASH_JOIN:       metricName = &quot;SPILL_CYCLE&quot;;       break;     default:       return NO_SPILL_METRIC_INDEX;     }      int metricIndex = 0; //Default     String[] metricNames = OperatorMetricRegistry.getMetricNames(operatorType.getNumber());     for (String name : metricNames) {       if (name.equalsIgnoreCase(metricName)) {         return metricIndex;       }       metricIndex++;     }     //Backward compatibility with rendering older profiles. Ideally we should never touch this if an expected metric is not there     return NO_SPILL_METRIC_INDEX;   }    public String getMetricsTable() {     if (operatorType == null) {       return &quot;&quot;;     }     final String[] metricNames = OperatorMetricRegistry.getMetricNames(operatorType.getNumber());     if (metricNames == null) {       return &quot;&quot;;     }      final String[] metricsTableColumnNames = new String[metricNames.length + 1];     metricsTableColumnNames[0] = &quot;Minor Fragment&quot;;     int i = 1;     for (final String metricName : metricNames) {       metricsTableColumnNames[i++] = metricName;     }     final TableBuilder builder = new TableBuilder(metricsTableColumnNames, null);      for (final ImmutablePair,String&gt; ip : opsAndHosts) {       final OperatorProfile op = ip.getLeft().getLeft();        builder.appendCell(           new OperatorPathBuilder()           .setMajor(major)           .setMinor(ip.getLeft().getRight())           .setOperator(op)           .build());        final Number[] values = new Number[metricNames.length];       //Track new/Unknown Metrics       final Set unknownMetrics = new TreeSet&lt;&gt;();       for (final MetricValue metric : op.getMetricList()) {         if (metric.getMetricId() &lt; metricNames.length) {           if (metric.hasLongValue()) {             values[metric.getMetricId()] = metric.getLongValue();           } else if (metric.hasDoubleValue()) {             values[metric.getMetricId()] = metric.getDoubleValue();           }         } else {           //Tracking unknown metric IDs           unknownMetrics.add(metric.getMetricId());         }       }       for (final Number value : values) {         if (value != null) {           builder.appendFormattedNumber(value);         } else {           builder.appendCell(&quot;&quot;);         }       }     }     return builder.build();   }    private class OperatorTblTxt {     static final String MINOR_FRAGMENT = &quot;Minor Fragment&quot;;     static final String HOSTNAME = &quot;Hostname&quot;;     static final String SETUP_TIME = &quot;Setup Time&quot;;     static final String PROCESS_TIME = &quot;Process Time&quot;;     static final String WAIT_TIME = &quot;Wait Time&quot;;     static final String MAX_BATCHES = &quot;Max Batches&quot;;     static final String MAX_RECORDS = &quot;Max Records&quot;;     static final String PEAK_MEMORY = &quot;Peak Memory&quot;;   }    private class OperatorTblTooltip {     static final String MINOR_FRAGMENT = &quot;Operator's Minor Fragment&quot;;     static final String HOSTNAME = &quot;Host on which the minor fragment ran&quot;;     static final String SETUP_TIME = &quot;Setup Time for the minor fragment's operator&quot;;     static final String PROCESS_TIME = &quot;Process Time for the minor fragment's operator&quot;;     static final String WAIT_TIME = &quot;Wait Time for the minor fragment's operator&quot;;     static final String MAX_BATCHES = &quot;Max Batches processed by the minor fragment's operator&quot;;     static final String MAX_RECORDS = &quot;Max Records processed by the minor fragment's operator&quot;;     static final String PEAK_MEMORY = &quot;Peak Memory usage by the minor fragment's operator&quot;;   }    private class OverviewTblTxt {     static final String OPERATOR_ID = &quot;Operator ID&quot;;     static final String TYPE_OF_OPERATOR = &quot;Type&quot;;     static final String AVG_SETUP_TIME = &quot;Avg Setup Time&quot;;     static final String MAX_SETUP_TIME = &quot;Max Setup Time&quot;;     static final String AVG_PROCESS_TIME = &quot;Avg Process Time&quot;;     static final String MAX_PROCESS_TIME = &quot;Max Process Time&quot;;     static final String MIN_WAIT_TIME = &quot;Min Wait Time&quot;;     static final String AVG_WAIT_TIME = &quot;Avg Wait Time&quot;;     static final String MAX_WAIT_TIME = &quot;Max Wait Time&quot;;     static final String PERCENT_FRAGMENT_TIME = &quot;% Fragment Time&quot;;     static final String PERCENT_QUERY_TIME = &quot;% Query Time&quot;;     static final String ROWS = &quot;Rows&quot;;     static final String AVG_PEAK_MEMORY = &quot;Avg Peak Memory&quot;;     static final String MAX_PEAK_MEMORY = &quot;Max Peak Memory&quot;;   }    private class OverviewTblTooltip {     static final String OPERATOR_ID = &quot;Operator ID&quot;;     static final String TYPE_OF_OPERATOR = &quot;Operator Type&quot;;     static final String AVG_SETUP_TIME = &quot;Average time in setting up fragments&quot;;     static final String MAX_SETUP_TIME = &quot;Longest time a fragment took in setup&quot;;     static final String AVG_PROCESS_TIME = &quot;Average process time for a fragment&quot;;     static final String MAX_PROCESS_TIME = &quot;Longest process time of any fragment&quot;;     static final String MIN_WAIT_TIME = &quot;Shortest time a fragment spent in waiting&quot;;     static final String AVG_WAIT_TIME = &quot;Average wait time for a fragment&quot;;     static final String MAX_WAIT_TIME = &quot;Longest time a fragment spent in waiting&quot;;     static final String PERCENT_FRAGMENT_TIME = &quot;Percentage of the total fragment time that was spent on the operator&quot;;     static final String PERCENT_QUERY_TIME = &quot;Percentage of the total query time that was spent on the operator&quot;;     static final String ROWS = &quot;Rows emitted by scans, or consumed by other operators&quot;;     static final String AVG_PEAK_MEMORY  =  &quot;Average memory consumption by a fragment&quot;;     static final String MAX_PEAK_MEMORY  =  &quot;Highest memory consumption by a fragment&quot;;   } }</td>
    <td align="left">data class</td>
    <td align="left">1. long method, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5486</td>
    <td align="left">https://github.com/apache/drill/blob/5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3/exec/java-exec/src/main/java/org/apache/drill/exec/server/rest/profile/OperatorWrapper.java/#L43-L442</td>
    <td align="right">1</td>
    <td align="right">535</td>
    <td align="right">5486</td>
  </tr>
  <tr valign="top">
    <td align="right">1674</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@UriParams public class Mina2Configuration implements Cloneable {      @UriPath @Metadata(required = true)     private String protocol;     @UriPath @Metadata(required = true)     private String host;     @UriPath @Metadata(required = true)     private int port;     @UriParam(defaultValue = &quot;true&quot;)     private boolean sync = true;     @UriParam(label = &quot;codec&quot;)     private boolean textline;     @UriParam(label = &quot;codec&quot;)     private Mina2TextLineDelimiter textlineDelimiter;     @UriParam(label = &quot;codec&quot;)     private ProtocolCodecFactory codec;     @UriParam(label = &quot;codec&quot;)     private String encoding;     @UriParam(defaultValue = &quot;10000&quot;)     private long writeTimeout = 10000;     @UriParam(defaultValue = &quot;30000&quot;)     private long timeout = 30000;     @UriParam(label = &quot;producer,advanced&quot;, defaultValue = &quot;true&quot;)     private boolean lazySessionCreation = true;     @UriParam(label = &quot;advanced&quot;)     private boolean transferExchange;     @UriParam     private boolean minaLogger;     @UriParam(label = &quot;codec&quot;, defaultValue = &quot;-1&quot;)     private int encoderMaxLineLength = -1;     @UriParam(label = &quot;codec&quot;, defaultValue = &quot;1024&quot;)     private int decoderMaxLineLength = 1024;     @UriParam(label = &quot;codec&quot;)     private List filters;     @UriParam(label = &quot;codec&quot;, defaultValue = &quot;true&quot;)     private boolean allowDefaultCodec = true;     @UriParam     private boolean disconnect;     @UriParam(label = &quot;consumer,advanced&quot;, defaultValue = &quot;true&quot;)     private boolean disconnectOnNoReply = true;     @UriParam(label = &quot;consumer,advanced&quot;, defaultValue = &quot;WARN&quot;)     private LoggingLevel noReplyLogLevel = LoggingLevel.WARN;     @UriParam(label = &quot;security&quot;)     private SSLContextParameters sslContextParameters;     @UriParam(label = &quot;security&quot;, defaultValue = &quot;true&quot;)     private boolean autoStartTls = true;     @UriParam(label = &quot;advanced&quot;, defaultValue = &quot;16&quot;)     private int maximumPoolSize = 16; // 16 is the default mina setting     @UriParam(label = &quot;advanced&quot;, defaultValue = &quot;true&quot;)     private boolean orderedThreadPoolExecutor = true;     @UriParam(label = &quot;producer,advanced&quot;, defaultValue = &quot;true&quot;)     private boolean cachedAddress = true;     @UriParam(label = &quot;consumer&quot;)     private boolean clientMode;      /**      * Returns a copy of this configuration      */     public Mina2Configuration copy() {         try {             return (Mina2Configuration) clone();         } catch (CloneNotSupportedException e) {             throw new RuntimeCamelException(e);         }     }      public String getCharsetName() {         if (encoding == null) {             return null;         }         if (!Charset.isSupported(encoding)) {             throw new IllegalArgumentException(&quot;The encoding: &quot; + encoding + &quot; is not supported&quot;);         }          return Charset.forName(encoding).name();     }      public String getProtocol() {         return protocol;     }      /**      * Protocol to use      */     public void setProtocol(String protocol) {         this.protocol = protocol;     }      public String getHost() {         return host;     }      /**      * Hostname to use. Use localhost or 0.0.0.0 for local server as consumer. For producer use the hostname or ip address of the remote server.      */     public void setHost(String host) {         this.host = host;     }      public int getPort() {         return port;     }      /**      * Port number      */     public void setPort(int port) {         this.port = port;     }      public boolean isSync() {         return sync;     }      /**      * Setting to set endpoint as one-way or request-response.      */     public void setSync(boolean sync) {         this.sync = sync;     }      public boolean isTextline() {         return textline;     }      /**      * Only used for TCP. If no codec is specified, you can use this flag to indicate a text line based codec;      * if not specified or the value is false, then Object Serialization is assumed over TCP.      */     public void setTextline(boolean textline) {         this.textline = textline;     }      public Mina2TextLineDelimiter getTextlineDelimiter() {         return textlineDelimiter;     }      /**      * Only used for TCP and if textline=true. Sets the text line delimiter to use.      * If none provided, Camel will use DEFAULT.      * This delimiter is used to mark the end of text.      */     public void setTextlineDelimiter(Mina2TextLineDelimiter textlineDelimiter) {         this.textlineDelimiter = textlineDelimiter;     }      public ProtocolCodecFactory getCodec() {         return codec;     }      /**      * To use a custom minda codec implementation.      */     public void setCodec(ProtocolCodecFactory codec) {         this.codec = codec;     }      public String getEncoding() {         return encoding;     }      /**      * You can configure the encoding (a charset name) to use for the TCP textline codec and the UDP protocol.      * If not provided, Camel will use the JVM default Charset      */     public void setEncoding(String encoding) {         this.encoding = encoding;     }      public long getWriteTimeout() {         return writeTimeout;     }      /**      * Maximum amount of time it should take to send data to the MINA session. Default is 10000 milliseconds.      */     public void setWriteTimeout(long writeTimeout) {         this.writeTimeout = writeTimeout;     }      public long getTimeout() {         return timeout;     }      /**      * You can configure the timeout that specifies how long to wait for a response from a remote server.      * The timeout unit is in milliseconds, so 60000 is 60 seconds.      */     public void setTimeout(long timeout) {         this.timeout = timeout;     }      public boolean isLazySessionCreation() {         return lazySessionCreation;     }      /**      * Sessions can be lazily created to avoid exceptions, if the remote server is not up and running when the Camel producer is started.      */     public void setLazySessionCreation(boolean lazySessionCreation) {         this.lazySessionCreation = lazySessionCreation;     }      public boolean isTransferExchange() {         return transferExchange;     }      /**      * Only used for TCP. You can transfer the exchange over the wire instead of just the body.      * The following fields are transferred: In body, Out body, fault body, In headers, Out headers, fault headers, exchange properties, exchange exception.      * This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.      */     public void setTransferExchange(boolean transferExchange) {         this.transferExchange = transferExchange;     }      /**      * To set the textline protocol encoder max line length. By default the default value of Mina itself is used which are Integer.MAX_VALUE.      */     public void setEncoderMaxLineLength(int encoderMaxLineLength) {         this.encoderMaxLineLength = encoderMaxLineLength;     }      public int getEncoderMaxLineLength() {         return encoderMaxLineLength;     }      /**      * To set the textline protocol decoder max line length. By default the default value of Mina itself is used which are 1024.      */     public void setDecoderMaxLineLength(int decoderMaxLineLength) {         this.decoderMaxLineLength = decoderMaxLineLength;     }      public int getDecoderMaxLineLength() {         return decoderMaxLineLength;     }      public boolean isMinaLogger() {         return minaLogger;     }      /**      * You can enable the Apache MINA logging filter. Apache MINA uses slf4j logging at INFO level to log all input and output.      */     public void setMinaLogger(boolean minaLogger) {         this.minaLogger = minaLogger;     }      public List getFilters() {         return filters;     }      /**      * You can set a list of Mina IoFilters to use.      */     public void setFilters(List filters) {         this.filters = filters;     }      public boolean isDatagramProtocol() {         return protocol.equals(&quot;udp&quot;);     }      /**      * The mina component installs a default codec if both, codec is null and textline is false.      * Setting allowDefaultCodec to false prevents the mina component from installing a default codec as the first element in the filter chain.      * This is useful in scenarios where another filter must be the first in the filter chain, like the SSL filter.      */     public void setAllowDefaultCodec(boolean allowDefaultCodec) {         this.allowDefaultCodec = allowDefaultCodec;     }      public boolean isAllowDefaultCodec() {         return allowDefaultCodec;     }      public boolean isDisconnect() {         return disconnect;     }      /**      * Whether or not to disconnect(close) from Mina session right after use. Can be used for both consumer and producer.      */     public void setDisconnect(boolean disconnect) {         this.disconnect = disconnect;     }      public boolean isDisconnectOnNoReply() {         return disconnectOnNoReply;     }      /**      * If sync is enabled then this option dictates MinaConsumer if it should disconnect where there is no reply to send back.      */     public void setDisconnectOnNoReply(boolean disconnectOnNoReply) {         this.disconnectOnNoReply = disconnectOnNoReply;     }      public LoggingLevel getNoReplyLogLevel() {         return noReplyLogLevel;     }      /**      * If sync is enabled this option dictates MinaConsumer which logging level to use when logging a there is no reply to send back.      */     public void setNoReplyLogLevel(LoggingLevel noReplyLogLevel) {         this.noReplyLogLevel = noReplyLogLevel;     }      public SSLContextParameters getSslContextParameters() {         return sslContextParameters;     }      /**      * To configure SSL security.      */     public void setSslContextParameters(SSLContextParameters sslContextParameters) {         this.sslContextParameters = sslContextParameters;     }      public boolean isAutoStartTls() {         return autoStartTls;     }      /**      * Whether to auto start SSL handshake.      */     public void setAutoStartTls(boolean autoStartTls) {         this.autoStartTls = autoStartTls;     }      public int getMaximumPoolSize() {         return maximumPoolSize;     }      /**      * Number of worker threads in the worker pool for TCP and UDP      */     public void setMaximumPoolSize(int maximumPoolSize) {         this.maximumPoolSize = maximumPoolSize;     }      public boolean isOrderedThreadPoolExecutor() {         return orderedThreadPoolExecutor;     }      /**      * Whether to use ordered thread pool, to ensure events are processed orderly on the same channel.      */     public void setOrderedThreadPoolExecutor(boolean orderedThreadPoolExecutor) {         this.orderedThreadPoolExecutor = orderedThreadPoolExecutor;     }      /**      * Whether to create the InetAddress once and reuse. Setting this to false allows to pickup DNS changes in the network.      */     public void setCachedAddress(boolean shouldCacheAddress) {         this.cachedAddress = shouldCacheAddress;     }      public boolean isCachedAddress() {         return cachedAddress;     }      /**      * If the clientMode is true, mina consumer will connect the address as a TCP client.      */     public void setClientMode(boolean clientMode) {         this.clientMode = clientMode;     }          public boolean isClientMode() {         return clientMode;     }      // here we just shows the option setting of host, port, protocol      public String getUriString() {         return &quot;mina2:&quot; + getProtocol() + &quot;:&quot; + getHost() + &quot;:&quot; + getPort();     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11643</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-mina2/src/main/java/org/apache/camel/component/mina2/Mina2Configuration.java/#L35-L416</td>
    <td align="right">1</td>
    <td align="right">1674</td>
    <td align="right">11643</td>
  </tr>
  <tr valign="top">
    <td align="right">1064</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;1. Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
   public class Header {        public String key;       public String val;        public Header(String key, String val) {          this.key = key;          this.val = val;       }        public String getEncodedKey() {          return encode(key);       }        public String getEncodedValue() {          return encode(val);       }    }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9556</td>
    <td align="left">https://github.com/apache/activemq-artemis/blob/5bd5c610195d6f4a3dd1ac28170727003f8a5a54/artemis-protocols/artemis-stomp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/stomp/StompFrame.java/#L158-L175</td>
    <td align="right">1</td>
    <td align="right">1064</td>
    <td align="right">9556</td>
  </tr>
  <tr valign="top">
    <td align="right">94</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;,  &quot;bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface ServletConstants {     String PAGE_HEADER           = &quot;\n&quot; +             &quot;\n&quot; +             &quot;\n&quot; +             &quot;    \n&quot; +             &quot;    Weblogic Monitoring Exporter\n&quot; +             &quot;\n&quot; +             &quot;&quot;;      // The locations of the servlets relative to the web app     String MAIN_PAGE = &quot;&quot;;     String METRICS_PAGE = &quot;metrics&quot;;     String CONFIGURATION_PAGE = &quot;configure&quot;;      /** The header used by a web client to send its authentication credentials. **/     String AUTHENTICATION_HEADER = &quot;Authorization&quot;;      /** The header used by a web client to send cookies as part of a request. */     String COOKIE_HEADER = &quot;Cookie&quot;;      // The field which defines the configuration update action     String EFFECT_OPTION = &quot;effect&quot;;      // The possible values for the effect     String DEFAULT_ACTION = ServletConstants.REPLACE_ACTION;     String REPLACE_ACTION = &quot;replace&quot;;     String APPEND_ACTION = &quot;append&quot;; }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1261</td>
    <td align="left">https://github.com/oracle/weblogic-monitoring-exporter/blob/05f1d3c4cc797577801df0ceceb9d92fc31718e8/src/main/java/io/prometheus/wls/rest/ServletConstants.java/#L13-L41</td>
    <td align="right">1</td>
    <td align="right">94</td>
    <td align="right">1261</td>
  </tr>
  <tr valign="top">
    <td align="right">1943</td>
    <td align="left">{&quot;response&quot;: &quot;YES, I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Device {  	private String id;  	private String deviceType;  	private String name;  	private Authentication authentication;  	public String getId() { 		return id; 	}  	public void setId(String id) { 		this.id = id; 	}  	public String getDeviceType() { 		return deviceType; 	}  	public void setDeviceType(String deviceType) { 		this.deviceType = deviceType; 	}  	public String getName() { 		return name; 	}  	public void setName(String name) { 		this.name = name; 	}  	public Authentication getAuthentication() { 		return authentication; 	}  	public void setAuthentication(Authentication authentication) { 		this.authentication = authentication; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12503</td>
    <td align="left">https://github.com/SAP/iot-starterkit/blob/f0d9ce06a1a98569a5a4eed76a2ec0aa87c1a1df/neo/apps/java/authentication/com.sap.iot.starterkit.cert/src/main/java/com/sap/iot/starterkit/cert/type/Device.java/#L3-L45</td>
    <td align="right">1</td>
    <td align="right">1943</td>
    <td align="right">12503</td>
  </tr>
  <tr valign="top">
    <td align="right">2480</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity @Table(name = JPADynRealmMembership.TABLE) public class JPADynRealmMembership extends AbstractGeneratedKeyEntity implements DynRealmMembership {      private static final long serialVersionUID = 8157856850557493134L;      public static final String TABLE = &quot;DynRealmMembership&quot;;      @OneToOne     private JPADynRealm dynRealm;      @ManyToOne     private JPAAnyType anyType;      @NotNull     private String fiql;      @Override     public DynRealm getDynRealm() {         return dynRealm;     }      @Override     public void setDynRealm(final DynRealm dynRealm) {         checkType(dynRealm, JPADynRealm.class);         this.dynRealm = (JPADynRealm) dynRealm;     }      @Override     public AnyType getAnyType() {         return anyType;     }      @Override     public void setAnyType(final AnyType anyType) {         checkType(anyType, JPAAnyType.class);         this.anyType = (JPAAnyType) anyType;     }      @Override     public String getFIQLCond() {         return fiql;     }      @Override     public void setFIQLCond(final String fiql) {         this.fiql = fiql;     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14595</td>
    <td align="left">https://github.com/apache/syncope/blob/114c412afbfba24ffb4fbc804e5308a823a16a78/core/persistence-jpa/src/main/java/org/apache/syncope/core/persistence/jpa/entity/JPADynRealmMembership.java/#L30-L79</td>
    <td align="right">1</td>
    <td align="right">2480</td>
    <td align="right">14595</td>
  </tr>
  <tr valign="top">
    <td align="right">1626</td>
    <td align="left">{&quot;output&quot;: &quot;YES I found bad smells the bad smells are: 1. Long Method, 2. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Mojo( name = &quot;check&quot;, defaultPhase = LifecyclePhase.VERIFY, requiresDependencyResolution = ResolutionScope.TEST,        threadSafe = true ) public class CheckstyleViolationCheckMojo     extends AbstractMojo {      private static final String JAVA_FILES = &quot;**\\/*.java&quot;;     private static final String DEFAULT_CONFIG_LOCATION = &quot;sun_checks.xml&quot;;      /**      * Specifies the path and filename to save the Checkstyle output. The format      * of the output file is determined by the outputFileFormat      * parameter.      */     @Parameter( property = &quot;checkstyle.output.file&quot;, defaultValue = &quot;${project.build.directory}/checkstyle-result.xml&quot; )     private File outputFile;      /**      * Specifies the format of the output to be used when writing to the output      * file. Valid values are &quot;plain&quot; and &quot;xml&quot;.      */     @Parameter( property = &quot;checkstyle.output.format&quot;, defaultValue = &quot;xml&quot; )     private String outputFileFormat;      /**      * Fail the build on a violation. The goal checks for the violations      * after logging them (if {@link #logViolationsToConsole} is {@code true}).      * Compare this to {@link #failsOnError} which fails the build immediately      * before examining the output log.      */     @Parameter( property = &quot;checkstyle.failOnViolation&quot;, defaultValue = &quot;true&quot; )     private boolean failOnViolation;      /**      * The maximum number of allowed violations. The execution fails only if the      * number of violations is above this limit.      *      * @since 2.3      */     @Parameter( property = &quot;checkstyle.maxAllowedViolations&quot;, defaultValue = &quot;0&quot; )     private int maxAllowedViolations;      /**      * The lowest severity level that is considered a violation.      * Valid values are &quot;error&quot;, &quot;warning&quot; and &quot;info&quot;.      *      * @since 2.2      */     @Parameter( property = &quot;checkstyle.violationSeverity&quot;, defaultValue = &quot;error&quot; )     private String violationSeverity = &quot;error&quot;;      /**      * Violations to ignore. This is a comma-separated list, each value being either      * a rule name, a rule category or a java package name of rule class.      *      * @since 2.13      */     @Parameter( property = &quot;checkstyle.violation.ignore&quot; )     private String violationIgnore;      /**      * Skip entire check.      *      * @since 2.2      */     @Parameter( property = &quot;checkstyle.skip&quot;, defaultValue = &quot;false&quot; )     private boolean skip;      /**      * Skip Checkstyle execution will only scan the outputFile.      *      * @since 2.5      */     @Parameter( property = &quot;checkstyle.skipExec&quot;, defaultValue = &quot;false&quot; )     private boolean skipExec;      /**      * Output the detected violations to the console.      *      * @since 2.3      */     @Parameter( property = &quot;checkstyle.console&quot;, defaultValue = &quot;true&quot; )     private boolean logViolationsToConsole;      /**      * Specifies the location of the resources to be used for Checkstyle.      *      * @since 2.11      */     @Parameter( defaultValue = &quot;${project.resources}&quot;, readonly = true )     protected List resources;          /**      * Specifies the location of the test resources to be used for Checkstyle.      *      * @since 2.16      */     @Parameter( defaultValue = &quot;${project.testResources}&quot;, readonly = true )     protected List testResources;      /**      *       * Specifies the location of the XML configuration to use.      *       * Potential values are a filesystem path, a URL, or a classpath resource.      * This parameter expects that the contents of the location conform to the      * xml format (Checkstyle Checker      * module) configuration of rulesets.      *       * This parameter is resolved as resource, URL, then file. If successfully      * resolved, the contents of the configuration is copied into the      * ${project.build.directory}/checkstyle-configuration.xml      * file before being passed to Checkstyle as a configuration.      *       * There are 2 predefined rulesets.      *       * sun_checks.xml: Sun Checks.      * google_checks.xml: Google Checks.      *       *      * @since 2.5      */     @Parameter( property = &quot;checkstyle.config.location&quot;, defaultValue = DEFAULT_CONFIG_LOCATION )     private String configLocation;      /**      *       * Specifies the location of the properties file.      *       * This parameter is resolved as URL, File then resource. If successfully      * resolved, the contents of the properties location is copied into the      * ${project.build.directory}/checkstyle-checker.properties      * file before being passed to Checkstyle for loading.      *       * The contents of the propertiesLocation will be made      * available to Checkstyle for specifying values for parameters within the      * xml configuration (specified in the configLocation      * parameter).      *      * @since 2.5      */     @Parameter( property = &quot;checkstyle.properties.location&quot; )     private String propertiesLocation;      /**      * Allows for specifying raw property expansion information.      */     @Parameter     private String propertyExpansion;      /**      *       * Specifies the location of the License file (a.k.a. the header file) that      * can be used by Checkstyle to verify that source code has the correct      * license header.      *       * You need to use ${checkstyle.header.file} in your Checkstyle xml      * configuration to reference the name of this header file.      *       * For instance:      *       * &lt;module name=&quot;RegexpHeader&quot;&gt;      *   &lt;property name=&quot;headerFile&quot; value=&quot;${checkstyle.header.file}&quot;/&gt;      * &lt;/module&gt;      *       *      * @since 2.0-beta-2      */     @Parameter( property = &quot;checkstyle.header.file&quot;, defaultValue = &quot;LICENSE.txt&quot; )     private String headerLocation;      /**      * Specifies the cache file used to speed up Checkstyle on successive runs.      */     @Parameter( defaultValue = &quot;${project.build.directory}/checkstyle-cachefile&quot; )     private String cacheFile;      /**      * The key to be used in the properties for the suppressions file.      *      * @since 2.1      */     @Parameter( property = &quot;checkstyle.suppression.expression&quot;, defaultValue = &quot;checkstyle.suppressions.file&quot; )     private String suppressionsFileExpression;      /**      *       * Specifies the location of the suppressions XML file to use.      *       * This parameter is resolved as resource, URL, then file. If successfully      * resolved, the contents of the suppressions XML is copied into the      * ${project.build.directory}/checkstyle-suppressions.xml file      * before being passed to Checkstyle for loading.      *       * See suppressionsFileExpression for the property that will      * be made available to your Checkstyle configuration.      *      * @since 2.0-beta-2      */     @Parameter( property = &quot;checkstyle.suppressions.location&quot; )     private String suppressionsLocation;      /**      * The file encoding to use when reading the source files. If the property project.build.sourceEncoding      * is not set, the platform default encoding is used. Note: This parameter always overrides the      * property charset from Checkstyle's TreeWalker module.      *      * @since 2.2      */     @Parameter( property = &quot;encoding&quot;, defaultValue = &quot;${project.build.sourceEncoding}&quot; )     private String encoding;      /**      * @since 2.5      */     @Component( role = CheckstyleExecutor.class, hint = &quot;default&quot; )     protected CheckstyleExecutor checkstyleExecutor;      /**      * Output errors to console.      */     @Parameter( property = &quot;checkstyle.consoleOutput&quot;, defaultValue = &quot;false&quot; )     private boolean consoleOutput;      /**      * The Maven Project Object.      */     @Parameter ( defaultValue = &quot;${project}&quot;, readonly = true, required = true )     protected MavenProject project;          /**      * The Plugin Descriptor      */     @Parameter( defaultValue = &quot;${plugin}&quot;, readonly = true, required = true )     private PluginDescriptor plugin;      /**      * If null, the Checkstyle plugin will display violations on stdout.      * Otherwise, a text file will be created with the violations.      */     @Parameter     private File useFile;      /**      * Specifies the names filter of the source files to be excluded for      * Checkstyle.      */     @Parameter( property = &quot;checkstyle.excludes&quot; )     private String excludes;      /**      * Specifies the names filter of the source files to be used for Checkstyle.      */     @Parameter( property = &quot;checkstyle.includes&quot;, defaultValue = JAVA_FILES, required = true )     private String includes;      /**      * Specifies the names filter of the files to be excluded for      * Checkstyle when checking resources.      * @since 2.11      */     @Parameter( property = &quot;checkstyle.resourceExcludes&quot; )     private String resourceExcludes;      /**      * Specifies the names filter of the files to be used for Checkstyle when checking resources.      * @since 2.11      */     @Parameter( property = &quot;checkstyle.resourceIncludes&quot;, defaultValue = &quot;**/*.properties&quot;, required = true )     private String resourceIncludes;      /**      * If this is true, and Checkstyle reported any violations or errors,      * the build fails immediately after running Checkstyle, before checking the log      * for {@link #logViolationsToConsole}. If you want to use {@link #logViolationsToConsole},      * use {@link #failOnViolation} instead of this.      */     @Parameter( defaultValue = &quot;false&quot; )     private boolean failsOnError;      /**      * Specifies the location of the test source directory to be used for Checkstyle.      *      * @since 2.2      * @deprecated instead use {@link #testSourceDirectories}. For version 3.0.0, this parameter is only defined to      *             break the build if you use it!      */     @Deprecated     @Parameter     private File testSourceDirectory;      /**      * Specifies the location of the test source directories to be used for Checkstyle.      * Default value is ${project.testCompileSourceRoots}.      * @since 2.13      */     // Compatibility with all Maven 3: default of 'project.testCompileSourceRoots' is done manually because of MNG-5440     @Parameter     private List testSourceDirectories;      /**      * Include or not the test source directory to be used for Checkstyle.      *      * @since 2.2      */     @Parameter( defaultValue = &quot;false&quot; )     private boolean includeTestSourceDirectory;      /**      * Specifies the location of the source directory to be used for Checkstyle.      *       * @deprecated instead use {@link #sourceDirectories}. For version 3.0.0, this parameter is only defined to break      *             the build if you use it!      */     @Deprecated     @Parameter     private File sourceDirectory;      /**      * Specifies the location of the source directories to be used for Checkstyle.      * Default value is ${project.compileSourceRoots}.      * @since 2.13      */     // Compatibility with all Maven 3: default of 'project.compileSourceRoots' is done manually because of MNG-5440     @Parameter     private List sourceDirectories;      /**      * Whether to apply Checkstyle to resource directories.      * @since 2.11      */     @Parameter( property = &quot;checkstyle.includeResources&quot;, defaultValue = &quot;true&quot;, required = true )     private boolean includeResources = true;      /**      * Whether to apply Checkstyle to test resource directories.      * @since 2.11      */     @Parameter( property = &quot;checkstyle.includeTestResources&quot;, defaultValue = &quot;true&quot;, required = true )     private boolean includeTestResources = true;      /**      * By using this property, you can specify the whole Checkstyle rules      * inline directly inside this pom.      *      *       * &lt;plugin&gt;      *   ...      *   &lt;configuration&gt;      *     &lt;checkstyleRules&gt;      *       &lt;module name=&quot;Checker&quot;&gt;      *         &lt;module name=&quot;FileTabCharacter&quot;&gt;      *           &lt;property name=&quot;eachLine&quot; value=&quot;true&quot; /&gt;      *         &lt;/module&gt;      *         &lt;module name=&quot;TreeWalker&quot;&gt;      *           &lt;module name=&quot;EmptyBlock&quot;/&gt;      *         &lt;/module&gt;      *       &lt;/module&gt;      *     &lt;/checkstyleRules&gt;      *   &lt;/configuration&gt;      *   ...      *       *      * @since 2.12      */     @Parameter     private PlexusConfiguration checkstyleRules;      /**      * Dump file for inlined Checkstyle rules.       */     @Parameter( property = &quot;checkstyle.output.rules.file&quot;,                     defaultValue = &quot;${project.build.directory}/checkstyle-rules.xml&quot; )     private File rulesFiles;      /**      * The header to use for the inline configuration.      * Only used when you specify {@code checkstyleRules}.      */     @Parameter( defaultValue = &quot;\n&quot;             + &quot;\n&quot; )     private String checkstyleRulesHeader;      /**      * Specifies whether modules with a configured severity of ignore should be omitted during Checkstyle      * invocation.      *       * @since 3.0.0      */     @Parameter( defaultValue = &quot;false&quot; )     private boolean omitIgnoredModules;      private ByteArrayOutputStream stringOutputStream;      private File outputXmlFile;      /** {@inheritDoc} */     public void execute()         throws MojoExecutionException, MojoFailureException     {         checkDeprecatedParameterUsage( sourceDirectory, &quot;sourceDirectory&quot;, &quot;sourceDirectories&quot; );         checkDeprecatedParameterUsage( testSourceDirectory, &quot;testSourceDirectory&quot;, &quot;testSourceDirectories&quot; );         if ( skip )         {             return;         }          outputXmlFile = outputFile;          if ( !skipExec )         {             if ( checkstyleRules != null )             {                 if ( !DEFAULT_CONFIG_LOCATION.equals( configLocation ) )                 {                     throw new MojoExecutionException( &quot;If you use inline configuration for rules, don't specify &quot;                         + &quot;a configLocation&quot; );                 }                 if ( checkstyleRules.getChildCount() &gt; 1 )                 {                     throw new MojoExecutionException( &quot;Currently only one root module is supported&quot; );                 }                  PlexusConfiguration checkerModule = checkstyleRules.getChild( 0 );                  try                 {                     FileUtils.forceMkdir( rulesFiles.getParentFile() );                     FileUtils.fileWrite( rulesFiles, checkstyleRulesHeader + checkerModule.toString() );                 }                 catch ( final IOException e )                 {                     throw new MojoExecutionException( e.getMessage(), e );                 }                 configLocation = rulesFiles.getAbsolutePath();             }              ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();              try             {                 CheckstyleExecutorRequest request = new CheckstyleExecutorRequest();                 request.setConsoleListener( getConsoleListener() ).setConsoleOutput( consoleOutput )                     .setExcludes( excludes ).setFailsOnError( failsOnError ).setIncludes( includes )                     .setResourceIncludes( resourceIncludes )                     .setResourceExcludes( resourceExcludes )                     .setIncludeResources( includeResources )                     .setIncludeTestResources( includeTestResources )                     .setIncludeTestSourceDirectory( includeTestSourceDirectory ).setListener( getListener() )                     .setProject( project ).setSourceDirectories( getSourceDirectories() )                     .setResources( resources ).setTestResources( testResources )                     .setStringOutputStream( stringOutputStream ).setSuppressionsLocation( suppressionsLocation )                     .setTestSourceDirectories( getTestSourceDirectories() ).setConfigLocation( configLocation )                     .setConfigurationArtifacts( collectArtifacts( &quot;config&quot; ) )                     .setPropertyExpansion( propertyExpansion )                     .setHeaderLocation( headerLocation ).setLicenseArtifacts( collectArtifacts( &quot;license&quot; ) )                     .setCacheFile( cacheFile ).setSuppressionsFileExpression( suppressionsFileExpression )                     .setEncoding( encoding ).setPropertiesLocation( propertiesLocation )                     .setOmitIgnoredModules( omitIgnoredModules );                 checkstyleExecutor.executeCheckstyle( request );              }             catch ( CheckstyleException e )             {                 throw new MojoExecutionException( &quot;Failed during checkstyle configuration&quot;, e );             }             catch ( CheckstyleExecutorException e )             {                 throw new MojoExecutionException( &quot;Failed during checkstyle execution&quot;, e );             }             finally             {                 //be sure to restore original context classloader                 Thread.currentThread().setContextClassLoader( currentClassLoader );             }         }          if ( !&quot;xml&quot;.equals( outputFileFormat ) &amp;&amp; skipExec )         {             throw new MojoExecutionException( &quot;Output format is '&quot; + outputFileFormat                 + &quot;', checkstyle:check requires format to be 'xml' when using skipExec.&quot; );         }          if ( !outputXmlFile.exists() )         {             getLog().info( &quot;Unable to perform checkstyle:check, unable to find checkstyle:checkstyle outputFile.&quot; );             return;         }          try ( Reader reader = new BufferedReader( ReaderFactory.newXmlReader( outputXmlFile ) ) )         {             XmlPullParser xpp = new MXParser();             xpp.setInput( reader );              int violations = countViolations( xpp );              if ( violations &gt; maxAllowedViolations )             {                 if ( failOnViolation )                 {                     String msg =                         &quot;You have &quot; + violations + &quot; Checkstyle violation&quot; + ( ( violations &gt; 1 ) ? &quot;s&quot; : &quot;&quot; ) + &quot;.&quot;;                     if ( maxAllowedViolations &gt; 0 )                     {                         msg += &quot; The maximum number of allowed violations is &quot; + maxAllowedViolations + &quot;.&quot;;                     }                     throw new MojoFailureException( msg );                 }                  getLog().warn( &quot;checkstyle:check violations detected but failOnViolation set to false&quot; );             }         }         catch ( IOException | XmlPullParserException e )         {             throw new MojoExecutionException( &quot;Unable to read Checkstyle results xml: &quot;                 + outputXmlFile.getAbsolutePath(), e );         }     }      private void checkDeprecatedParameterUsage( Object parameter, String name, String replacement )         throws MojoFailureException     {         if ( parameter != null )         {             throw new MojoFailureException( &quot;You are using '&quot; + name + &quot;' which has been removed&quot;                 + &quot; from the maven-checkstyle-plugin. &quot; + &quot;Please use '&quot; + replacement                 + &quot;' and refer to the &gt;&gt;Major Version Upgrade to version 3.0.0&lt;&lt; &quot; + &quot;on the plugin site.&quot; );         }     }      private int countViolations( XmlPullParser xpp )         throws XmlPullParserException, IOException     {         int count = 0;         int ignoreCount = 0;         List ignores = violationIgnore == null ? Collections.emptyList()                         : RuleUtil.parseMatchers( violationIgnore.split( &quot;,&quot; ) );          String basedir = project.getBasedir().getAbsolutePath();         String file = &quot;&quot;;         for ( int eventType = xpp.getEventType(); eventType != XmlPullParser.END_DOCUMENT; eventType = xpp.next() )         {             if ( eventType != XmlPullParser.START_TAG )             {                 continue;             }             else if ( &quot;file&quot;.equals( xpp.getName() ) )             {                 file = PathTool.getRelativeFilePath( basedir, xpp.getAttributeValue( &quot;&quot;, &quot;name&quot; ) );                 //file = file.substring( file.lastIndexOf( File.separatorChar ) + 1 );             }             else if ( &quot;error&quot;.equals( xpp.getName() ) )             {                 String severity = xpp.getAttributeValue( &quot;&quot;, &quot;severity&quot; );                  if ( !isViolation( severity ) )                 {                     continue;                 }                  String source = xpp.getAttributeValue( &quot;&quot;, &quot;source&quot; );                  if ( ignore( ignores, source ) )                 {                     ignoreCount++;                 }                 else                 {                     count++;                      if ( logViolationsToConsole )                     {                         String line = xpp.getAttributeValue( &quot;&quot;, &quot;line&quot; );                         String column = xpp.getAttributeValue( &quot;&quot;, &quot;column&quot; );                         String message = xpp.getAttributeValue( &quot;&quot;, &quot;message&quot; );                         String rule = RuleUtil.getName( source );                         String category = RuleUtil.getCategory( source );                          log( severity, file + &quot;:[&quot; + line + ( ( column == null ) ? &quot;&quot; : ( ',' + column ) ) + &quot;] (&quot;                             + category + &quot;) &quot; + rule + &quot;: &quot; + message );                     }                 }             }         }          if ( ignoreCount &gt; 0 )         {             getLog().info( &quot;Ignored &quot; + ignoreCount + &quot; error&quot; + ( ( ignoreCount &gt; 1 ) ? &quot;s&quot; : &quot;&quot; ) + &quot;, &quot; + count                                + &quot; violation&quot; + ( ( count &gt; 1 ) ? &quot;s&quot; : &quot;&quot; ) + &quot; remaining.&quot; );         }          return count;     }      private void log( String severity, String message )     {         if ( &quot;info&quot;.equals( severity ) )         {             getLog().info( message );         }         else if ( &quot;warning&quot;.equals( severity ) )         {             getLog().warn( message );         }         else         {             getLog().error( message );         }     }      /**      * Checks if the given severity is considered a violation.      *      * @param severity The severity to check      * @return true if the given severity is a violation, otherwise false      */     private boolean isViolation( String severity )     {         if ( &quot;error&quot;.equals( severity ) )         {             return &quot;error&quot;.equals( violationSeverity ) || &quot;warning&quot;.equals( violationSeverity )                 || &quot;info&quot;.equals( violationSeverity );         }         else if ( &quot;warning&quot;.equals( severity ) )         {             return &quot;warning&quot;.equals( violationSeverity ) || &quot;info&quot;.equals( violationSeverity );         }         else if ( &quot;info&quot;.equals( severity ) )         {             return &quot;info&quot;.equals( violationSeverity );         }         else         {             return false;         }     }      private boolean ignore( List ignores, String source )     {         for ( RuleUtil.Matcher ignore : ignores )         {             if ( ignore.match( source ) )             {                 return true;             }         }         return false;     }      private DefaultLogger getConsoleListener()         throws MojoExecutionException     {         DefaultLogger consoleListener;          if ( useFile == null )         {             stringOutputStream = new ByteArrayOutputStream();             consoleListener = new DefaultLogger( stringOutputStream, false );         }         else         {             OutputStream out = getOutputStream( useFile );              consoleListener = new DefaultLogger( out, true );         }          return consoleListener;     }      private OutputStream getOutputStream( File file )         throws MojoExecutionException     {         File parentFile = file.getAbsoluteFile().getParentFile();          if ( !parentFile.exists() )         {             parentFile.mkdirs();         }          FileOutputStream fileOutputStream;         try         {             fileOutputStream = new FileOutputStream( file );         }         catch ( FileNotFoundException e )         {             throw new MojoExecutionException( &quot;Unable to create output stream: &quot; + file, e );         }         return fileOutputStream;     }      private AuditListener getListener()         throws MojoFailureException, MojoExecutionException     {         AuditListener listener = null;          if ( StringUtils.isNotEmpty( outputFileFormat ) )         {             File resultFile = outputFile;              OutputStream out = getOutputStream( resultFile );              if ( &quot;xml&quot;.equals( outputFileFormat ) )             {                 listener = new XMLLogger( out, true );             }             else if ( &quot;plain&quot;.equals( outputFileFormat ) )             {                 try                 {                     // Write a plain output file to the standard output file,                     // and write an XML output file to the temp directory that can be used to count violations                     outputXmlFile = File.createTempFile( &quot;checkstyle-result&quot;, &quot;.xml&quot; );                     outputXmlFile.deleteOnExit();                     OutputStream xmlOut = getOutputStream( outputXmlFile );                     CompositeAuditListener compoundListener = new CompositeAuditListener();                     compoundListener.addListener( new XMLLogger( xmlOut, true ) );                     compoundListener.addListener( new DefaultLogger( out, true ) );                     listener = compoundListener;                 }                 catch ( IOException e )                 {                     throw new MojoExecutionException( &quot;Unable to create temporary file&quot;, e );                 }             }             else             {                 throw new MojoFailureException( &quot;Invalid output file format: (&quot; + outputFileFormat                     + &quot;). Must be 'plain' or 'xml'.&quot; );             }         }          return listener;     }          private List collectArtifacts( String hint )     {         List artifacts = new ArrayList&lt;&gt;();          PluginManagement pluginManagement = project.getBuild().getPluginManagement();         if ( pluginManagement != null )         {             artifacts.addAll( getCheckstylePluginDependenciesAsArtifacts( pluginManagement.getPluginsAsMap(), hint ) );         }          artifacts.addAll( getCheckstylePluginDependenciesAsArtifacts( project.getBuild().getPluginsAsMap(), hint ) );          return artifacts;     }      private List getCheckstylePluginDependenciesAsArtifacts( Map plugins, String hint )     {         List artifacts = new ArrayList&lt;&gt;();                  Plugin checkstylePlugin = plugins.get( plugin.getGroupId() + &quot;:&quot; + plugin.getArtifactId() );         if ( checkstylePlugin != null )         {             for ( Dependency dep : checkstylePlugin.getDependencies() )             {              // @todo if we can filter on hints, it should be done here...                 String depKey = dep.getGroupId() + &quot;:&quot; + dep.getArtifactId();                 artifacts.add( (Artifact) plugin.getArtifactMap().get( depKey ) );             }         }         return artifacts;     }          private List getSourceDirectories()     {         if ( sourceDirectories == null )         {             sourceDirectories = project.getCompileSourceRoots();         }         List sourceDirs = new ArrayList&lt;&gt;( sourceDirectories.size() );         for ( String sourceDir : sourceDirectories )         {             sourceDirs.add( FileUtils.resolveFile( project.getBasedir(), sourceDir ) );         }         return sourceDirs;     }          private List getTestSourceDirectories()     {         if ( testSourceDirectories == null )         {             testSourceDirectories = project.getTestCompileSourceRoots();         }         List testSourceDirs = new ArrayList&lt;&gt;( testSourceDirectories.size() );         for ( String testSourceDir : testSourceDirectories )         {             testSourceDirs.add( FileUtils.resolveFile( project.getBasedir(), testSourceDir ) );         }         return testSourceDirs;     }      }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long Method, 2 Data Class&quot;}</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">. Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11500</td>
    <td align="left">https://github.com/apache/maven-checkstyle-plugin/blob/eee0ba18a70e6d6bd51797c70a83cf844f882286/src/main/java/org/apache/maven/plugins/checkstyle/CheckstyleViolationCheckMojo.java/#L75-L872</td>
    <td align="right">1</td>
    <td align="right">1626</td>
    <td align="right">11500</td>
  </tr>
  <tr valign="top">
    <td align="right">628</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class NewNodePresentation {    private String nodeText;   private StyleConfigurator nodeTextStyle;   private String nodeInfoText;   private StyleConfigurator nodeInfoTextStyle;   private SVGResource icon;   private Element userElement;    private NewNodePresentation(Builder builder) {     this.nodeText = builder.nodeText;     this.nodeTextStyle = builder.nodeTextStyle;     this.nodeInfoText = builder.nodeInfoText;     this.nodeInfoTextStyle = builder.nodeInfoTextStyle;     this.icon = builder.icon;     this.userElement = builder.userElement;   }    public String getNodeText() {     return nodeText;   }    public StyleConfigurator getNodeTextStyle() {     return nodeTextStyle;   }    public String getNodeInfoText() {     return nodeInfoText;   }    public StyleConfigurator getNodeInfoTextStyle() {     return nodeInfoTextStyle;   }    public SVGResource getIcon() {     return icon;   }    public Element getUserElement() {     return userElement;   }    public static class Builder {     private String nodeText;     private StyleConfigurator nodeTextStyle;     private String nodeInfoText;     private StyleConfigurator nodeInfoTextStyle;     private SVGResource icon;     private Element userElement;      public Builder() {}      public Builder withNodeText(String nodeText) {       this.nodeText = nodeText;       return this;     }      public Builder withNodeTextStyle(StyleConfigurator nodeTextStyle) {       this.nodeTextStyle = nodeTextStyle;       return this;     }      public Builder withNodeInfoText(String nodeInfoText) {       this.nodeInfoText = nodeInfoText;       return this;     }      public Builder withNodeIntoTextStyle(StyleConfigurator nodeInfoTextStyle) {       this.nodeInfoTextStyle = nodeInfoTextStyle;       return this;     }      public Builder withIcon(SVGResource icon) {       this.icon = icon;       return this;     }      public Builder withUserElement(Element userElement) {       this.userElement = userElement;       return this;     }      public NewNodePresentation build() {       return new NewNodePresentation(this);     }   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6271</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/ide/che-core-ide-ui/src/main/java/org/eclipse/che/ide/ui/smartTree/presentation/NewNodePresentation.java/#L25-L111</td>
    <td align="right">1</td>
    <td align="right">628</td>
    <td align="right">6271</td>
  </tr>
  <tr valign="top">
    <td align="right">2079</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;1. Long method&quot;, &quot;2. Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
class FloatFilterFunction extends AbstractFloatValue {   private final FloatValue baseExpr;   private final BooleanValue filterExpr;   public static final String name = FilterFunction.name;   private final String exprStr;   private final ExpressionType funcType;      public FloatFilterFunction(FloatValue baseExpr, BooleanValue filterExpr) throws SolrException {     this.baseExpr = baseExpr;     this.filterExpr = filterExpr;     this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);     this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);   }      boolean exists = false;    @Override   public float getFloat() {     float value = baseExpr.getFloat();     exists = baseExpr.exists() &amp;&amp; filterExpr.getBoolean() &amp;&amp; filterExpr.exists();     return value;   }   @Override   public boolean exists() {     return exists;   }      @Override   public String getName() {     return name;   }   @Override   public String getExpressionStr() {     return exprStr;   }   @Override   public ExpressionType getExpressionType() {     return funcType;   } }</td>
    <td align="left">data class</td>
    <td align="left">1. long method, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">13060</td>
    <td align="left">https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/FilterFunction.java/#L462-L501</td>
    <td align="right">1</td>
    <td align="right">2079</td>
    <td align="right">13060</td>
  </tr>
  <tr valign="top">
    <td align="right">238</td>
    <td align="left"><br />
  {&quot;response&quot;: &quot;YES I found bad smells&quot;,<br />
  &quot;the bad smells are&quot;: [<br />
    &quot;Long method&quot;,<br />
    &quot;Data class&quot;,<br />
    &quot;Data clumps&quot;<br />
  ]<br />
}</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells).<br />
 Could you please identify which smells occur in the following code? However, do not describe the smells,<br />
 just list them. <br />
Please start your answer with &quot;YES I found bad smells&quot; when you find any bad smell. <br />
Otherwise, start your answer with &quot;NO, I did not find any bad smell&quot;. <br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells<br />
are:&quot; amongst the text your answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
  public static class MetaColumn implements Named {     public final String tableCat;     public final String tableSchem;     public final String tableName;     public final String columnName;     public final int dataType;     public final String typeName;     public final Integer columnSize;     public final Integer bufferLength = null;     public final Integer decimalDigits;     public final Integer numPrecRadix;     public final int nullable;     public final String remarks = null;     public final String columnDef = null;     public final Integer sqlDataType = null;     public final Integer sqlDatetimeSub = null;     public final Integer charOctetLength;     public final int ordinalPosition;     @NotNull     public final String isNullable;     public final String scopeCatalog = null;     public final String scopeSchema = null;     public final String scopeTable = null;     public final Short sourceDataType = null;     @NotNull     public final String isAutoincrement = &quot;&quot;;     @NotNull     public final String isGeneratedcolumn = &quot;&quot;;      public MetaColumn(         String tableCat,         String tableSchem,         String tableName,         String columnName,         int dataType,         String typeName,         Integer columnSize,         Integer decimalDigits,         Integer numPrecRadix,         int nullable,         Integer charOctetLength,         int ordinalPosition,         String isNullable) {       this.tableCat = tableCat;       this.tableSchem = tableSchem;       this.tableName = tableName;       this.columnName = columnName;       this.dataType = dataType;       this.typeName = typeName;       this.columnSize = columnSize;       this.decimalDigits = decimalDigits;       this.numPrecRadix = numPrecRadix;       this.nullable = nullable;       this.charOctetLength = charOctetLength;       this.ordinalPosition = ordinalPosition;       this.isNullable = isNullable;     }      @Override     public String getName() {       return columnName;     }   }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class, data clumps</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method,  data clumps</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2613</td>
    <td align="left">https://github.com/apache/drill/blob/5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3/exec/jdbc/src/main/java/org/apache/drill/jdbc/impl/DrillMetaImpl.java/#L160-L222</td>
    <td align="right">2</td>
    <td align="right">238</td>
    <td align="right">2613</td>
  </tr>
  <tr valign="top">
    <td align="right">2617</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TransformIterator implements Iterator {      /** The iterator being used */     private Iterator iterator;     /** The transformer being used */     private Transformer transformer;      //-----------------------------------------------------------------------     /**      * Constructs a new TransformIterator that will not function      * until the {@link #setIterator(Iterator) setIterator} and      * {@link #setTransformer(Transformer)} methods are invoked.      */     public TransformIterator() {         super();     }      /**      * Constructs a new TransformIterator that won't transform      * elements from the given iterator.      *      * @param iterator  the iterator to use      */     public TransformIterator(final Iterator iterator) {         super();         this.iterator = iterator;     }      /**      * Constructs a new TransformIterator that will use the      * given iterator and transformer.  If the given transformer is null,      * then objects will not be transformed.      *      * @param iterator  the iterator to use      * @param transformer  the transformer to use      */     public TransformIterator(final Iterator iterator,                              final Transformer transformer) {         super();         this.iterator = iterator;         this.transformer = transformer;     }      //-----------------------------------------------------------------------     @Override     public boolean hasNext() {         return iterator.hasNext();     }      /**      * Gets the next object from the iteration, transforming it using the      * current transformer. If the transformer is null, no transformation      * occurs and the object from the iterator is returned directly.      *      * @return the next object      * @throws java.util.NoSuchElementException if there are no more elements      */     @Override     public O next() {         return transform(iterator.next());     }      @Override     public void remove() {         iterator.remove();     }      //-----------------------------------------------------------------------     /**      * Gets the iterator this iterator is using.      *      * @return the iterator.      */     public Iterator getIterator() {         return iterator;     }      /**      * Sets the iterator for this iterator to use.      * If iteration has started, this effectively resets the iterator.      *      * @param iterator  the iterator to use      */     public void setIterator(final Iterator iterator) {         this.iterator = iterator;     }      //-----------------------------------------------------------------------     /**      * Gets the transformer this iterator is using.      *      * @return the transformer.      */     public Transformer getTransformer() {         return transformer;     }      /**      * Sets the transformer this the iterator to use.      * A null transformer is a no-op transformer.      *      * @param transformer  the transformer to use      */     public void setTransformer(final Transformer transformer) {         this.transformer = transformer;     }      //-----------------------------------------------------------------------     /**      * Transforms the given object using the transformer.      * If the transformer is null, the original object is returned as-is.      *      * @param source  the object to transform      * @return the transformed object      */     protected O transform(final I source) {         return transformer.transform(source);     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15049</td>
    <td align="left">https://github.com/apache/commons-collections/blob/bb0781551c7f1d7ddd28733acff95e1f130e766c/src/main/java/org/apache/commons/collections4/iterators/TransformIterator.java/#L28-L146</td>
    <td align="right">1</td>
    <td align="right">2617</td>
    <td align="right">15049</td>
  </tr>
  <tr valign="top">
    <td align="right">1832</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Long Method&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class JobSchedulerService extends AbstractScheduledService {     protected static final long DEFAULT_DELAY = 1000;      private static final Logger logger = LoggerFactory.getLogger( JobSchedulerService.class );      private long interval = DEFAULT_DELAY;     private int workerSize = 1;     private int maxFailCount = 10;      private JobAccessor jobAccessor;     private JobFactory jobFactory;      private Semaphore capacitySemaphore;      private ListeningScheduledExecutorService service;     private JobListener jobListener;      private Timer jobTimer;     private Counter runCounter;     private Counter successCounter;     private Counter failCounter;      private Injector injector;      //TODO Add meters for throughput of start and stop       public JobSchedulerService() { }       @Override     protected void runOneIteration() throws Exception {          MetricsFactory metricsFactory = injector.getInstance( MetricsFactory.class );          jobTimer = metricsFactory.getTimer( JobSchedulerService.class, &quot;scheduler.job_execution_timer&quot; );         runCounter = metricsFactory.getCounter( JobSchedulerService.class, &quot;scheduler.running_workers&quot; );         successCounter = metricsFactory.getCounter( JobSchedulerService.class, &quot;scheduler.successful_jobs&quot; );         failCounter = metricsFactory.getCounter( JobSchedulerService.class, &quot;scheduler.failed_jobs&quot; );          try {             if ( logger.isDebugEnabled() ) {                 logger.debug( &quot;Running one check iteration ...&quot; );             }             List activeJobs;              // run until there are no more active jobs             while ( true ) {                  // get the semaphore if we can. This means we have space for at least 1                 // job                 if ( logger.isDebugEnabled() ) {                     logger.debug( &quot;About to acquire semaphore.  Capacity is {}&quot;, capacitySemaphore.availablePermits() );                 }                  capacitySemaphore.acquire();                 // release the sempaphore we only need to acquire as a way to stop the                 // loop if there's no capacity                 capacitySemaphore.release();                  int capacity = capacitySemaphore.availablePermits();                  if (logger.isDebugEnabled()) {                     logger.debug(&quot;Capacity is {}&quot;, capacity);                 }                  activeJobs = jobAccessor.getJobs( capacity );                  // nothing to do, we don't have any jobs to run                 if ( activeJobs.size() == 0 ) {                     if (logger.isDebugEnabled()) {                         logger.debug(&quot;No jobs returned. Exiting run loop&quot;);                     }                     return;                 }                  for ( JobDescriptor jd : activeJobs ) {                     logger.debug( &quot;Submitting work for {}&quot;, jd );                     submitWork( jd );                     logger.debug( &quot;Work submitted for {}&quot;, jd );                 }             }         }         catch ( Throwable t ) {             if (logger.isDebugEnabled()) {                 logger.debug(&quot;Scheduler run failed, error is&quot;, t);             }         }     }       /*      * (non-Javadoc)      *      * @see com.google.common.util.concurrent.AbstractScheduledService#scheduler()      */     @Override     protected Scheduler scheduler() {         return Scheduler.newFixedDelaySchedule( 0, interval, TimeUnit.MILLISECONDS );     }       /**      * Use the provided BulkJobFactory to build and submit BulkJob items as ListenableFuture objects      */     private void submitWork( final JobDescriptor jobDescriptor ) {         final Job job;          try {             job = jobFactory.jobsFrom( jobDescriptor );         }         catch ( JobNotFoundException e ) {             logger.error( &quot;Could not create jobs&quot;, e );             return;         }           // job execution needs to be external to both the callback and the task.         // This way regardless of any error we can         // mark a job as failed if required         final JobExecution execution = new JobExecutionImpl( jobDescriptor );          // We don't care if this is atomic (not worth using a lock object)         // we just need to prevent NPEs from ever occurring         final JobListener currentListener = this.jobListener;          /**          * Acquire the semaphore before we schedule.  This way we wont' take things from the Q that end up          * stuck in the queue for the scheduler and then time out their distributed heartbeat          */         try {             capacitySemaphore.acquire();         }         catch ( InterruptedException e ) {             logger.error( &quot;Unable to acquire semaphore capacity before submitting job&quot;, e );             //just return, they'll get picked up again later             return;         }           final Timer.Context timer = jobTimer.time();           ListenableFuture future = service.submit( new Callable() {             @Override             public Void call() throws Exception {                  if (logger.isDebugEnabled()) {                     logger.debug(&quot;Starting the job with job id {}&quot;, execution.getJobId());                 }                 runCounter.inc();                  execution.start( maxFailCount );                   //this job is dead, treat it as such                 if ( execution.getStatus() == Status.DEAD ) {                      try {                         job.dead( execution );                         jobAccessor.save( execution );                     }                     catch ( Exception t ) {                         //we purposefully swallow all exceptions here, we don't want it to effect the outcome                         //of finally popping this job from the queue                         logger.error( &quot;Unable to invoke dead event on job&quot;, t );                     }                      return null;                 }                  jobAccessor.save( execution );                  // TODO wrap and throw specifically typed exception for onFailure,                 // needs jobId                  logger.debug( &quot;Starting job {} with execution data {}&quot;, job, execution );                  job.execute( execution );                  if ( currentListener != null ) {                     currentListener.onSubmit( execution );                 }                  return null;             }         } );          Futures.addCallback( future, new FutureCallback() {             @Override             public void onSuccess( Void param ) {                  /**                  * Release semaphore first in case there are other problems with communicating with Cassandra                  */                  if (logger.isDebugEnabled()) {                     logger.debug(&quot;Job succeeded with the job id {}&quot;, execution.getJobId());                 }                 capacitySemaphore.release();                 timer.stop();                 runCounter.dec();                 successCounter.inc();                   //TODO, refactor into the execution itself for checking if done                 if ( execution.getStatus() == Status.IN_PROGRESS ) {                     logger.debug( &quot;Successful completion of bulkJob {}&quot;, execution );                     execution.completed();                 }                  jobAccessor.save( execution );                   if ( currentListener != null ) {                     currentListener.onSuccess( execution );                 }             }               @Override             public void onFailure( Throwable throwable ) {                  /**                  * Release semaphore first in case there are other problems with communicating with Cassandra                  */                 logger.error( &quot;Job failed with the job id {}&quot;, execution.getJobId() );                 capacitySemaphore.release();                 timer.stop();                 runCounter.dec();                 failCounter.inc();                   logger.error( &quot;Failed execution for bulkJob&quot;, throwable );                 // mark it as failed                 if ( execution.getStatus() == Status.IN_PROGRESS ) {                     execution.failed();                 }                  jobAccessor.save( execution );                   if ( currentListener != null ) {                     currentListener.onFailure( execution );                 }             }         } );     }       /**      * @param milliseconds the milliseconds to set to wait if we didn't receive a job to run      */     public void setInterval( long milliseconds ) {         this.interval = milliseconds;     }       public long getInterval() {         return interval;     }       /**      * @param listeners the listeners to set      */     public void setWorkerSize( int listeners ) {         this.workerSize = listeners;     }       public int getWorkerSize() {         return workerSize;     }       /**      * @param jobAccessor the jobAccessor to set      */     public void setJobAccessor( JobAccessor jobAccessor ) {         this.jobAccessor = jobAccessor;     }       /**      * @param jobFactory the jobFactory to set      */     public void setJobFactory( JobFactory jobFactory ) {         this.jobFactory = jobFactory;     }       /**      * @param maxFailCount the maxFailCount to set      */     public void setMaxFailCount( int maxFailCount ) {         this.maxFailCount = maxFailCount;     }       /**      * Set the metrics factory      */ //    public void setMetricsFactory( MetricsFactory metricsFactory ) { // //        jobTimer = metricsFactory.getTimer( JobSchedulerService.class, &quot;job_execution_timer&quot; ); //        runCounter = metricsFactory.getCounter( JobSchedulerService.class, &quot;running_workers&quot; ); //        successCounter = metricsFactory.getCounter( JobSchedulerService.class, &quot;successful_jobs&quot; ); //        failCounter = metricsFactory.getCounter( JobSchedulerService.class, &quot;failed_jobs&quot; ); //    }       /*      * (non-Javadoc)      *      * @see com.google.common.util.concurrent.AbstractScheduledService#startUp()      */     @Override     protected void startUp() throws Exception {         service = MoreExecutors                 .listeningDecorator( Executors.newScheduledThreadPool( workerSize, JobThreadFactory.INSTANCE ) );         capacitySemaphore = new Semaphore( workerSize );          logger.info( &quot;Starting executor pool.  Capacity is {}&quot;, workerSize );          super.startUp();          logger.info( &quot;Job Scheduler started&quot; );     }       /*      * (non-Javadoc)      *      * @see com.google.common.util.concurrent.AbstractScheduledService#shutDown()      */     @Override     protected void shutDown() throws Exception {         logger.info( &quot;Shutting down job scheduler&quot; );          service.shutdown();          logger.info( &quot;Job scheduler shut down&quot; );         super.shutDown();     }       /**      * Sets the JobListener notified of Job events on this SchedulerService.      *      * @param jobListener the listener to receive Job events      *      * @return the previous listener if set, or null if none was set      */     public JobListener setJobListener( JobListener jobListener ) {         JobListener old = this.jobListener;         this.jobListener = jobListener;         return old;     }       /**      * Gets the current JobListener to be notified of Job events on this SchedulerService.      *      * @return the current JobListener or null if none was set      */     public JobListener getJobListener() {         return jobListener;     }      public void setInjector(Injector injector) {         this.injector = injector;     }       /**      * Simple factory for labeling job worker threads for easier debugging      */     private static final class JobThreadFactory implements ThreadFactory {          public static final JobThreadFactory INSTANCE = new JobThreadFactory();          private static final String NAME = &quot;JobWorker-&quot;;         private final AtomicLong counter = new AtomicLong();           @Override         public Thread newThread( final Runnable r ) {              Thread newThread = new Thread( r, NAME + counter.incrementAndGet() );             newThread.setDaemon( true );              return newThread;         }     } }</td>
    <td align="left">data class</td>
    <td align="left">Long Method, Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12128</td>
    <td align="left">https://github.com/apache/usergrid/blob/ac1e6e4035f9307b871478ed47246cf92cfd5f7f/stack/core/src/main/java/org/apache/usergrid/batch/service/JobSchedulerService.java/#L55-L450</td>
    <td align="right">1</td>
    <td align="right">1832</td>
    <td align="right">12128</td>
  </tr>
  <tr valign="top">
    <td align="right">110</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	class PushCommand extends KeyCommand {  		private List values; 		private boolean upsert; 		private Direction direction;  		private PushCommand(@Nullable ByteBuffer key, List values, Direction direction, boolean upsert) {  			super(key);  			this.values = values; 			this.upsert = upsert; 			this.direction = direction; 		}  		/** 		 * Creates a new {@link PushCommand} for right push ({@literal RPUSH}). 		 * 		 * @return a new {@link PushCommand} for right push ({@literal RPUSH}). 		 */ 		public static PushCommand right() { 			return new PushCommand(null, Collections.emptyList(), Direction.RIGHT, true); 		}  		/** 		 * Creates a new {@link PushCommand} for left push ({@literal LPUSH}). 		 * 		 * @return a new {@link PushCommand} for left push ({@literal LPUSH}). 		 */ 		public static PushCommand left() { 			return new PushCommand(null, Collections.emptyList(), Direction.LEFT, true); 		}  		/** 		 * Applies the {@literal value}. Constructs a new command instance with all previously configured properties. 		 * 		 * @param value must not be {@literal null}. 		 * @return a new {@link PushCommand} with {@literal value} applied. 		 */ 		public PushCommand value(ByteBuffer value) {  			Assert.notNull(value, &quot;Value must not be null!&quot;);  			return new PushCommand(null, Collections.singletonList(value), direction, upsert); 		}  		/** 		 * Applies a {@link List} of {@literal values}. 		 * 		 * @param values must not be {@literal null}. 		 * @return a new {@link PushCommand} with {@literal values} applied. 		 */ 		public PushCommand values(List values) {  			Assert.notNull(values, &quot;Values must not be null!&quot;);  			return new PushCommand(null, new ArrayList&lt;&gt;(values), direction, upsert); 		}  		/** 		 * Applies the {@literal key}. Constructs a new command instance with all previously configured properties. 		 * 		 * @param key must not be {@literal null}. 		 * @return a new {@link PushCommand} with {@literal key} applied. 		 */ 		public PushCommand to(ByteBuffer key) {  			Assert.notNull(key, &quot;Key must not be null!&quot;);  			return new PushCommand(key, values, direction, upsert); 		}  		/** 		 * Disable upsert. Constructs a new command instance with all previously configured properties. 		 * 		 * @return a new {@link PushCommand} with upsert disabled. 		 */ 		public PushCommand ifExists() { 			return new PushCommand(getKey(), values, direction, false); 		}  		/** 		 * @return never {@literal null}. 		 */ 		public List getValues() { 			return values; 		}  		/** 		 * @return 		 */ 		public boolean getUpsert() { 			return upsert; 		}  		/** 		 * @return never {@literal null}. 		 */ 		public Direction getDirection() { 			return direction; 		} 	}</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1459</td>
    <td align="left">https://github.com/spring-projects/spring-data-redis/blob/2eb7067e8c7e859168a281145cc46ccddb42049f/src/main/java/org/springframework/data/redis/connection/ReactiveListCommands.java/#L63-L164</td>
    <td align="right">1</td>
    <td align="right">110</td>
    <td align="right">1459</td>
  </tr>
  <tr valign="top">
    <td align="right">2484</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class _ReportingService2005Soap_ValidateExtensionSettings     implements ElementSerializable {     // No attributes          // Elements     protected String extension;     protected _ParameterValueOrFieldReference[] parameterValues;      public _ReportingService2005Soap_ValidateExtensionSettings()     {         super();     }      public _ReportingService2005Soap_ValidateExtensionSettings(         final String extension,         final _ParameterValueOrFieldReference[] parameterValues)     {         // TODO : Call super() instead of setting all fields directly?         setExtension(extension);         setParameterValues(parameterValues);     }      public String getExtension()     {         return this.extension;     }      public void setExtension(String value)     {         this.extension = value;     }      public _ParameterValueOrFieldReference[] getParameterValues()     {         return this.parameterValues;     }      public void setParameterValues(_ParameterValueOrFieldReference[] value)     {         this.parameterValues = value;     }      public void writeAsElement(         final XMLStreamWriter writer,         final String name)         throws XMLStreamException     {         writer.writeStartElement(name);          // Elements         XMLStreamWriterHelper.writeElement(             writer,             &quot;Extension&quot;,             this.extension);          if (this.parameterValues != null)         {             /*              * The element type is an array.              */             writer.writeStartElement(&quot;ParameterValues&quot;);              for (int iterator0 = 0; iterator0 &lt; this.parameterValues.length; iterator0++)             {                 this.parameterValues[iterator0].writeAsElement(                     writer,                     &quot;ParameterValueOrFieldReference&quot;);             }              writer.writeEndElement();         }          writer.writeEndElement();     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14604</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core.ws/generated-src/ms/sql/reporting/reportingservices/_ReportingService2005Soap_ValidateExtensionSettings.java/#L32-L107</td>
    <td align="right">1</td>
    <td align="right">2484</td>
    <td align="right">14604</td>
  </tr>
  <tr valign="top">
    <td align="right">2402</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES, I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class NewNodePresentation {    private String nodeText;   private StyleConfigurator nodeTextStyle;   private String nodeInfoText;   private StyleConfigurator nodeInfoTextStyle;   private SVGResource icon;   private Element userElement;    private NewNodePresentation(Builder builder) {     this.nodeText = builder.nodeText;     this.nodeTextStyle = builder.nodeTextStyle;     this.nodeInfoText = builder.nodeInfoText;     this.nodeInfoTextStyle = builder.nodeInfoTextStyle;     this.icon = builder.icon;     this.userElement = builder.userElement;   }    public String getNodeText() {     return nodeText;   }    public StyleConfigurator getNodeTextStyle() {     return nodeTextStyle;   }    public String getNodeInfoText() {     return nodeInfoText;   }    public StyleConfigurator getNodeInfoTextStyle() {     return nodeInfoTextStyle;   }    public SVGResource getIcon() {     return icon;   }    public Element getUserElement() {     return userElement;   }    public static class Builder {     private String nodeText;     private StyleConfigurator nodeTextStyle;     private String nodeInfoText;     private StyleConfigurator nodeInfoTextStyle;     private SVGResource icon;     private Element userElement;      public Builder() {}      public Builder withNodeText(String nodeText) {       this.nodeText = nodeText;       return this;     }      public Builder withNodeTextStyle(StyleConfigurator nodeTextStyle) {       this.nodeTextStyle = nodeTextStyle;       return this;     }      public Builder withNodeInfoText(String nodeInfoText) {       this.nodeInfoText = nodeInfoText;       return this;     }      public Builder withNodeIntoTextStyle(StyleConfigurator nodeInfoTextStyle) {       this.nodeInfoTextStyle = nodeInfoTextStyle;       return this;     }      public Builder withIcon(SVGResource icon) {       this.icon = icon;       return this;     }      public Builder withUserElement(Element userElement) {       this.userElement = userElement;       return this;     }      public NewNodePresentation build() {       return new NewNodePresentation(this);     }   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14382</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/ide/che-core-ide-ui/src/main/java/org/eclipse/che/ide/ui/smartTree/presentation/NewNodePresentation.java/#L25-L111</td>
    <td align="right">1</td>
    <td align="right">2402</td>
    <td align="right">14382</td>
  </tr>
  <tr valign="top">
    <td align="right">32</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class Build {          /**          * Project version.          */         private String version = &quot;&quot;;          public String getVersion() {             return version;         }          public void setVersion(final String version) {             this.version = version;         }      }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">730</td>
    <td align="left">https://github.com/eclipse/hawkbit/blob/51be28147f6f575b6c1ab4a5ef84ffd9174f1209/hawkbit-core/src/main/java/org/eclipse/hawkbit/HawkbitServerProperties.java/#L75-L90</td>
    <td align="right">1</td>
    <td align="right">32</td>
    <td align="right">730</td>
  </tr>
  <tr valign="top">
    <td align="right">3999</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells the bad smells are: Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class HandleConfigDriveIsoCommand extends Command {      @LogLevel(LogLevel.Log4jLevel.Off)     private String isoData;      private String isoFile;     private boolean create = false;     private DataStoreTO destStore;      public HandleConfigDriveIsoCommand(String isoFile, String isoData, DataStoreTO destStore, boolean create) {         this.isoFile = isoFile;         this.isoData = isoData;         this.destStore = destStore;         this.create = create;     }      @Override     public boolean executeInSequence() {         return false;     }      public String getIsoData() {         return isoData;     }      public boolean isCreate() {         return create;     }      public DataStoreTO getDestStore() {         return destStore;     }      public String getIsoFile() {         return isoFile;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10569</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/core/src/main/java/com/cloud/agent/api/HandleConfigDriveIsoCommand.java/#L24-L60</td>
    <td align="right">1</td>
    <td align="right">3999</td>
    <td align="right">10569</td>
  </tr>
  <tr valign="top">
    <td align="right">2251</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SuppressWarnings(&quot;all&quot;) public class Case_1 {   @Accessors   private int id;      public int testFunction1() {     return 42;   }      public int testFunction2() {     return 42;   }      public Integer testFunction3() {     return Integer.valueOf(42);   }      @Pure   public int getId() {     return this.id;   }      public void setId(final int id) {     this.id = id;   } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13674</td>
    <td align="left">https://github.com/eclipse/xtext-xtend/blob/20500a324127e3ee73cb793a13430ee140246fa7/org.eclipse.xtend.core.tests/longrunning/xtend-gen/org/eclipse/xtend/core/tests/smoke/Case_1.java/#L6-L31</td>
    <td align="right">1</td>
    <td align="right">2251</td>
    <td align="right">13674</td>
  </tr>
  <tr valign="top">
    <td align="right">1905</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad_smells&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class JarModule {     private ModuleRevisionId mrid;      private File jar;      public JarModule(ModuleRevisionId mrid, File jar) {         this.mrid = mrid;         this.jar = jar;     }      public File getJar() {         return jar;     }      public ModuleRevisionId getMrid() {         return mrid;     }      public String toString() {         return jar + &quot; &quot; + mrid;     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12371</td>
    <td align="left">https://github.com/apache/ant-ivy/blob/4ffcf8f06f238b17e78e8033c3e8278833e452eb/src/java/org/apache/ivy/tools/analyser/JarModule.java/#L24-L46</td>
    <td align="right">1</td>
    <td align="right">1905</td>
    <td align="right">12371</td>
  </tr>
  <tr valign="top">
    <td align="right">1387</td>
    <td align="left">&nbsp;{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;bad_smells&quot;: [     &quot;1. Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Ipam {   private String driver;   private List config;   private Map options;    public String getDriver() {     return driver;   }    public void setDriver(String driver) {     this.driver = driver;   }    public Ipam withDriver(String driver) {     this.driver = driver;     return this;   }    public List getConfig() {     return config;   }    public void setConfig(List config) {     this.config = config;   }    public Ipam withConfig(List config) {     this.config = config;     return this;   }    public Map getOptions() {     return options;   }    public void setOptions(Map options) {     this.options = options;   }    public Ipam withOptions(Map options) {     this.options = options;     return this;   }    @Override   public boolean equals(Object obj) {     if (this == obj) {       return true;     }     if (!(obj instanceof Ipam)) {       return false;     }     final Ipam that = (Ipam) obj;     return Objects.equals(driver, that.driver)         &amp;&amp; getConfig().equals(that.getConfig())         &amp;&amp; getOptions().equals(that.getOptions());   }    @Override   public int hashCode() {     int hash = 7;     hash = 31 * hash + Objects.hashCode(driver);     hash = 31 * hash + getConfig().hashCode();     hash = 31 * hash + getOptions().hashCode();     return hash;   }    @Override   public String toString() {     return &quot;Ipam{&quot;         + &quot;driver='&quot;         + driver         + '\''         + &quot;, config=&quot;         + config         + &quot;, options=&quot;         + options         + '}';   } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10837</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/infrastructures/docker/docker-client/src/main/java/org/eclipse/che/infrastructure/docker/client/json/network/Ipam.java/#L19-L98</td>
    <td align="right">1</td>
    <td align="right">1387</td>
    <td align="right">10837</td>
  </tr>
  <tr valign="top">
    <td align="right">549</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Tower extends Item {      private Fit fit;     private String tubing;      public static enum Fit {         Custom,         Exact,         Universal     }      public Fit getFit() {         return fit;     }      public void setFit(Fit fit) {         this.fit = fit;     }      public String getTubing() {         return tubing;     }      public void setTubing(String tubing) {         this.tubing = tubing;     }      ; }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5558</td>
    <td align="left">https://github.com/apache/tomee/blob/d21933b313aff812fe5188b57bf572a9ad649148/examples/webservice-inheritance/src/main/java/org/superbiz/inheritance/Tower.java/#L21-L50</td>
    <td align="right">1</td>
    <td align="right">549</td>
    <td align="right">5558</td>
  </tr>
  <tr valign="top">
    <td align="right">20</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{   &quot;response&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MachineStoppedEvent extends GwtEvent {    public static final Type TYPE = new Type&lt;&gt;();    private final MachineImpl machine;    public MachineStoppedEvent(MachineImpl machine) {     this.machine = machine;   }    /** Returns the stopped machine. */   public MachineImpl getMachine() {     return machine;   }    @Override   public Type getAssociatedType() {     return TYPE;   }    @Override   protected void dispatch(Handler handler) {     handler.onMachineStopped(this);   }    public interface Handler extends EventHandler {     void onMachineStopped(MachineStoppedEvent event);   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">681</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/ide/che-core-ide-api/src/main/java/org/eclipse/che/ide/api/workspace/event/MachineStoppedEvent.java/#L19-L47</td>
    <td align="right">1</td>
    <td align="right">20</td>
    <td align="right">681</td>
  </tr>
  <tr valign="top">
    <td align="right">2651</td>
    <td align="left">&nbsp;&nbsp;YES I found bad smells the bad smells are:   1. Long method  2. Data class 3. Feature envy 4. Large class 5. Shotgun surgery</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class Shape {      private String type;      private Map members = Collections.emptyMap();      private String documentation;      private List required;      private List enumValues;      private String payload;      private boolean flattened;      private boolean exception;      private boolean streaming;      private boolean wrapper;      private Member listMember;      private Member mapKeyType;      private Member mapValueType;      @JsonProperty(value = &quot;error&quot;)     private ErrorTrait errorTrait;      private long min;      private long max;      private String pattern;      private boolean fault;      private boolean deprecated;      @JsonProperty(value = &quot;eventstream&quot;)     private boolean isEventStream;      @JsonProperty(value = &quot;event&quot;)     private boolean isEvent;      private String timestampFormat;      private boolean sensitive;      public boolean isFault() {         return fault;     }      public void setFault(boolean fault) {         this.fault = fault;     }      public String getPattern() {         return pattern;     }      public void setPattern(String pattern) {         this.pattern = pattern;     }      public String getType() {         return type;     }      public void setType(String type) {         this.type = type;     }      public Map getMembers() {         return members;     }      public void setMembers(Map members) {         this.members = members;     }      public String getDocumentation() {         return documentation;     }      public void setDocumentation(String documentation) {         this.documentation = documentation;     }      public List getRequired() {         return required;     }      public void setRequired(List required) {         this.required = required;     }      public List getEnumValues() {         return enumValues;     }      @JsonProperty(value = &quot;enum&quot;)     public void setEnumValues(List enumValues) {         this.enumValues = enumValues;     }      public String getPayload() {         return payload;     }      public void setPayload(String payload) {         this.payload = payload;     }      public boolean isFlattened() {         return flattened;     }      public void setFlattened(boolean flattened) {         this.flattened = flattened;     }      public boolean isException() {         return exception;     }      public void setException(boolean exception) {         this.exception = exception;     }      public Member getMapKeyType() {         return mapKeyType;     }      @JsonProperty(value = &quot;key&quot;)     public void setMapKeyType(Member mapKeyType) {         this.mapKeyType = mapKeyType;     }      public Member getMapValueType() {         return mapValueType;     }      @JsonProperty(value = &quot;value&quot;)     public void setMapValueType(Member mapValueType) {         this.mapValueType = mapValueType;     }      public Member getListMember() {         return listMember;     }      @JsonProperty(value = &quot;member&quot;)     public void setListMember(Member listMember) {         this.listMember = listMember;     }      public long getMin() {         return min;     }      public void setMin(long min) {         this.min = min;     }      public long getMax() {         return max;     }      public void setMax(long max) {         this.max = max;     }      public boolean isStreaming() {         return streaming;     }      public void setStreaming(boolean streaming) {         this.streaming = streaming;     }      public boolean isWrapper() {         return wrapper;     }      public void setWrapper(boolean wrapper) {         this.wrapper = wrapper;     }      public ErrorTrait getErrorTrait() {         return errorTrait;     }      public void setErrorTrait(ErrorTrait errorTrait) {         this.errorTrait = errorTrait;     }      public boolean isDeprecated() {         return deprecated;     }      public void setDeprecated(boolean deprecated) {         this.deprecated = deprecated;     }      public boolean isEventStream() {         return isEventStream;     }      public void setIsEventStream(boolean eventStream) {         isEventStream = eventStream;     }      public boolean isEvent() {         return isEvent;     }      public void setIsEvent(boolean event) {         isEvent = event;     }      public String getTimestampFormat() {         return timestampFormat;     }      public void setTimestampFormat(String timestampFormat) {         this.timestampFormat = timestampFormat;     }      public boolean isSensitive() {         return sensitive;     }      public void setSensitive(boolean sensitive) {         this.sensitive = sensitive;     } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method 2 Data class3 Feature envy4 Large class5 Shotgun surgery</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15170</td>
    <td align="left">https://github.com/aws/aws-sdk-java-v2/blob/1d5d11e8087c93ab1a3a2d35193052e526fd123c/codegen/src/main/java/software/amazon/awssdk/codegen/model/service/Shape.java/#L23-L261</td>
    <td align="right">2</td>
    <td align="right">2651</td>
    <td align="right">15170</td>
  </tr>
  <tr valign="top">
    <td align="right">1099</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells, the bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;&quot;, propOrder = {         &quot;setOrderAttributesResult&quot;,         &quot;responseMetadata&quot; }) @XmlRootElement(name = &quot;SetOrderAttributesResponse&quot;) public class SetOrderAttributesResponse {        @XmlElement(name = &quot;SetOrderAttributesResult&quot;, required = true)      protected SetOrderAttributesResult setOrderAttributesResult;     @XmlElement(name = &quot;ResponseMetadata&quot;, required = true)     protected ResponseMetadata responseMetadata;      public SetOrderAttributesResponse() {         super();     }      public SetOrderAttributesResult getSetOrderAttributesResult() {         return setOrderAttributesResult;     }     public ResponseMetadata getResponseMetadata() {         return responseMetadata;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9827</td>
    <td align="left">https://github.com/amzn/amazon-pay-sdk-java/blob/5a3547d00c796aab8f0c8ac12e0310f7a5c4678a/src/com/amazon/pay/response/model/SetOrderAttributesResponse.java/#L39-L65</td>
    <td align="right">1</td>
    <td align="right">1099</td>
    <td align="right">9827</td>
  </tr>
  <tr valign="top">
    <td align="right">1831</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class DAOAttachment {         private final AttachmentId attachmentId;         private final BlobId blobId;         private final String type;         private final long size;          private DAOAttachment(AttachmentId attachmentId, BlobId blobId, String type, long size) {             this.attachmentId = attachmentId;             this.blobId = blobId;             this.type = type;             this.size = size;         }          public AttachmentId getAttachmentId() {             return attachmentId;         }          public BlobId getBlobId() {             return blobId;         }          public String getType() {             return type;         }          public long getSize() {             return size;         }          public Attachment toAttachment(byte[] data) {             return Attachment.builder()                 .attachmentId(attachmentId)                 .type(type)                 .bytes(data)                 .build();         }          @Override         public final boolean equals(Object o) {             if (o instanceof DAOAttachment) {                 DAOAttachment that = (DAOAttachment) o;                  return Objects.equals(this.size, that.size)                     &amp;&amp; Objects.equals(this.attachmentId, that.attachmentId)                     &amp;&amp; Objects.equals(this.blobId, that.blobId)                     &amp;&amp; Objects.equals(this.type, that.type);             }             return false;         }          @Override         public final int hashCode() {             return Objects.hash(attachmentId, blobId, type, size);         }     }</td>
    <td align="left">data class</td>
    <td align="left">Blob, Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">Blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12126</td>
    <td align="left">https://github.com/apache/james-project/blob/fa24a096a5853459c3769a34ccc68feb91626bfa/mailbox/cassandra/src/main/java/org/apache/james/mailbox/cassandra/mail/CassandraAttachmentDAOV2.java/#L50-L104</td>
    <td align="right">1</td>
    <td align="right">1831</td>
    <td align="right">12126</td>
  </tr>
  <tr valign="top">
    <td align="right">1332</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells. the bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement(name = &quot;Product&quot;) public class Product {     private long id;     private String description;      public long getId() {         return id;     }      public void setId(long id) {         this.id = id;     }      public String getDescription() {         return description;     }      public void setDescription(String d) {         this.description = d;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10716</td>
    <td align="left">https://github.com/apache/cxf/blob/6bf89e9c8804c8845ec4d38583dd33eea8256439/distribution/src/main/release/samples/jax_rs/spring_security/src/main/java/demo/jaxrs/service/Product.java/#L23-L43</td>
    <td align="right">1</td>
    <td align="right">1332</td>
    <td align="right">10716</td>
  </tr>
  <tr valign="top">
    <td align="right">492</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;bad_smells&quot;: [         &quot;1. Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class WizardUIInfoPage { 	 	private int order; 	 	private String description; 	 	public int getOrder() { 		return order; 	} 	 	public String getDescription() { 		return description; 	} 	 	public static WizardUIInfoPage getDefaultPage(int order) { 		WizardUIInfoPage page = new WizardUIInfoPage(); 		page.order = order; 		page.description = &quot;&quot;; 		return page; 	} 	 }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">&nbsp; </td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">4936</td>
    <td align="left">https://github.com/spring-projects/spring-ide/blob/915fe9bffd50db45ee0b8fb993416e45dee68179/plugins/org.springframework.ide.eclipse.wizard/src/org/springframework/ide/eclipse/wizard/template/infrastructure/ui/WizardUIInfoPage.java/#L18-L39</td>
    <td align="right">1</td>
    <td align="right">492</td>
    <td align="right">4936</td>
  </tr>
  <tr valign="top">
    <td align="right">88</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells_found&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  static class DynamicPackageEntry {      // public:     //     // DynamicPackageEntry() =default;      DynamicPackageEntry(String package_name, int package_id) {       this.package_name = package_name;       this.package_id = package_id;     }      String package_name;     int package_id = 0;   }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1229</td>
    <td align="left">https://github.com/robolectric/robolectric/blob/525bfcfc0e0ed1653ad57341b564c6857e11dc50/resources/src/main/java/org/robolectric/res/android/LoadedArsc.java/#L62-L75</td>
    <td align="right">1</td>
    <td align="right">88</td>
    <td align="right">1229</td>
  </tr>
  <tr valign="top">
    <td align="right">329</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SageRuntimeException extends RuntimeException implements SageExceptable {   protected final int kind;     public SageRuntimeException()   {     kind = UNKNOWN;   }    public SageRuntimeException(String message, int kind)   {     super(message);      this.kind = kind;   }    public SageRuntimeException(Throwable cause, int kind)   {     super(cause);      this.kind = kind;   }    public SageRuntimeException(String message, Throwable cause, int kind)   {     super(message, cause);      this.kind = kind;   }    public int getKind()   {     return (kind);   }    public boolean isKind(int kind)   {     return ((this.kind &amp; kind) != 0);   }    public String getMessage()   {     return (&quot;kind=&quot; + kind + &quot;; &quot; + super.getMessage());   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3387</td>
    <td align="left">https://github.com/google/sagetv/blob/a35e3a450b4c0134cb097b9e7de76dca08eb6654/java/tv/sage/SageRuntimeException.java/#L23-L68</td>
    <td align="right">1</td>
    <td align="right">329</td>
    <td align="right">3387</td>
  </tr>
  <tr valign="top">
    <td align="right">1059</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;output&quot;: &quot;YES I found bad smells&quot;,         &quot;bad_smells&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Param {  	@Nullable 	private String name;  	@Nullable 	private String value;   	/** 	 * Set the raw name of the parameter. 	 */ 	public void setName(@Nullable String name) { 		this.name = name; 	}  	/** 	 * Return the raw parameter name. 	 */ 	@Nullable 	public String getName() { 		return this.name; 	}  	/** 	 * Set the raw value of the parameter. 	 */ 	public void setValue(@Nullable String value) { 		this.value = value; 	}  	/** 	 * Return the raw parameter value. 	 */ 	@Nullable 	public String getValue() { 		return this.value; 	}   	@Override 	public String toString() { 		return &quot;JSP Tag Param: name '&quot; + this.name + &quot;', value '&quot; + this.value + &quot;'&quot;; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9530</td>
    <td align="left">https://github.com/spring-projects/spring-framework/blob/3a0f309e2c9fdbbf7fb2d348be861528177f8555/spring-webmvc/src/main/java/org/springframework/web/servlet/tags/Param.java/#L32-L77</td>
    <td align="right">1</td>
    <td align="right">1059</td>
    <td align="right">9530</td>
  </tr>
  <tr valign="top">
    <td align="right">546</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Long Method&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MethodSecurityInterceptor extends AbstractSecurityInterceptor implements 		MethodInterceptor { 	// ~ Instance fields 	// ================================================================================================  	private MethodSecurityMetadataSource securityMetadataSource;  	// ~ Methods 	// ========================================================================================================  	public Class getSecureObjectClass() { 		return MethodInvocation.class; 	}  	/** 	 * This method should be used to enforce security on a MethodInvocation. 	 * 	 * @param mi The method being invoked which requires a security decision 	 * 	 * @return The returned value from the method invocation (possibly modified by the 	 * {@code AfterInvocationManager}). 	 * 	 * @throws Throwable if any error occurs 	 */ 	public Object invoke(MethodInvocation mi) throws Throwable { 		InterceptorStatusToken token = super.beforeInvocation(mi);  		Object result; 		try { 			result = mi.proceed(); 		} 		finally { 			super.finallyInvocation(token); 		} 		return super.afterInvocation(token, result); 	}  	public MethodSecurityMetadataSource getSecurityMetadataSource() { 		return this.securityMetadataSource; 	}  	public SecurityMetadataSource obtainSecurityMetadataSource() { 		return this.securityMetadataSource; 	}  	public void setSecurityMetadataSource(MethodSecurityMetadataSource newSource) { 		this.securityMetadataSource = newSource; 	} }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">5550</td>
    <td align="left">https://github.com/spring-projects/spring-security/blob/8dd2864dea3de5ea98637a1629debc89c29e76c0/core/src/main/java/org/springframework/security/access/intercept/aopalliance/MethodSecurityInterceptor.java/#L40-L88</td>
    <td align="right">1</td>
    <td align="right">546</td>
    <td align="right">5550</td>
  </tr>
  <tr valign="top">
    <td align="right">500</td>
    <td align="left">&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Callout implements Comparable {   /** The callout number. */   private int callout = 0;   /** The area Element item that generated this callout. */   private Element area = null;   /** The line on which this callout occurs. */   private int line = 0;   /** The column in which this callout appears. */   private int col = 0;   /** The type of callout. */   private int type = 0;   /** The other type of callout. */   private String otherType = null;    public static final int CALS_PAIR = 1;   public static final int LINE_COLUMN = 2;   public static final int LINE_COLUMN_PAIR = 3;   public static final int LINE_RANGE = 4;   public static final int OTHER = 5;    /** The constructor; initialize the private data structures. */   public Callout(int callout, Element area, int line, int col, int type) {     this.callout = callout;     this.area = area;     this.line = line;     this.col = col;     this.type = type;     this.otherType = null;   }    /** The constructor; initialize the private data structures. */   public Callout(int callout, Element area, int line, int col, String otherType) {     this.callout = callout;     this.area = area;     this.line = line;     this.col = col;     this.type = Callout.OTHER;     this.otherType = otherType;   }    /**    * The compareTo method compares this Callout with another.    *    * Given two Callouts, A and B, A &lt; B if:    *    *     * A.line &lt; B.line, or    * A.line = B.line &amp;&amp; A.col &lt; B.col, or    * A.line = B.line &amp;&amp; A.col = B.col &amp;&amp; A.callout &lt; B.callout    * Otherwise, they're equal.    *     */   public int compareTo (Object o) {     Callout c = (Callout) o;      if (line == c.getLine()) {       if (col &gt; c.getColumn()) { 	return 1;       } else if (col &lt; c.getColumn()) { 	return -1;       } else { 	if (callout &lt; c.getCallout()) { 	  return -1; 	} else if (callout &gt; c.getCallout()) { 	  return 1; 	} else { 	  return 0; 	}       }     } else {       if (line &gt; c.getLine()) { 	return 1;       } else { 	return -1;       }     }   }    /** Access the Callout's area. */   public Element getArea() {     return area;   }    /** Access the Callout's line. */   public int getLine() {     return line;   }    /** Access the Callout's column. */   public int getColumn() {     return col;   }    /** Access the Callout's callout number. */   public int getCallout() {     return callout;   }    /** Access the Callout's type. */   public int getType() {     return type;   }    /** Access the Callout's otherType. */   public String getOtherType() {     return otherType;   }   }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5070</td>
    <td align="left">https://github.com/eclipse/org.aspectj/blob/370f291c359cd159c5f3f0abd6e9e53e81234a07/lib/docbook/docbook-xsl/extensions/xalan2/com/nwalsh/xalan/Callout.java/#L33-L142</td>
    <td align="right">1</td>
    <td align="right">500</td>
    <td align="right">5070</td>
  </tr>
  <tr valign="top">
    <td align="right">1774</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;output&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SpringComponent @VaadinSessionScope public class ManageSoftwareModuleFilters implements Serializable {      private static final long serialVersionUID = -1631725636290496525L;      private SoftwareModuleType softwareModuleType;      private String searchText;      /**      * @return the softwareModuleType      */     public Optional getSoftwareModuleType() {         return Optional.ofNullable(softwareModuleType);     }      /**      * @param softwareModuleType      *            the softwareModuleType to set      */     public void setSoftwareModuleType(final SoftwareModuleType softwareModuleType) {         this.softwareModuleType = softwareModuleType;     }      /**      * @return the searchText      */     public Optional getSearchText() {         return Optional.ofNullable(searchText);     }      /**      * @param searchText      *            the searchText to set      */     public void setSearchText(final String searchText) {         this.searchText = searchText;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11932</td>
    <td align="left">https://github.com/eclipse/hawkbit/blob/51be28147f6f575b6c1ab4a5ef84ffd9174f1209/hawkbit-ui/src/main/java/org/eclipse/hawkbit/ui/distributions/state/ManageSoftwareModuleFilters.java/#L23-L62</td>
    <td align="right">1</td>
    <td align="right">1774</td>
    <td align="right">11932</td>
  </tr>
  <tr valign="top">
    <td align="right">1150</td>
    <td align="left">{&quot;output&quot;: &quot;YES I found bad smells\nthe bad smells are:\n1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface MetricsIndexerSource extends BaseSource {   // Metrics2 and JMX constants   String METRICS_NAME = &quot;PhoenixIndexer&quot;;   String METRICS_CONTEXT = &quot;phoenix&quot;;   String METRICS_DESCRIPTION = &quot;Metrics about the Phoenix Indexer&quot;;   String METRICS_JMX_CONTEXT = &quot;RegionServer,sub=&quot; + METRICS_NAME;    String INDEX_PREPARE_TIME = &quot;indexPrepareTime&quot;;   String INDEX_PREPARE_TIME_DESC = &quot;Histogram for the time in milliseconds for preparing an index write&quot;;   String SLOW_INDEX_PREPARE = &quot;slowIndexPrepareCalls&quot;;   String SLOW_INDEX_PREPARE_DESC = &quot;The number of index preparations slower than the configured threshold&quot;;    String INDEX_WRITE_TIME = &quot;indexWriteTime&quot;;   String INDEX_WRITE_TIME_DESC = &quot;Histogram for the time in milliseconds for writing an index update&quot;;   String SLOW_INDEX_WRITE = &quot;slowIndexWriteCalls&quot;;   String SLOW_INDEX_WRITE_DESC = &quot;The number of index writes slower than the configured threshold&quot;;    String DUPLICATE_KEY_TIME = &quot;duplicateKeyCheckTime&quot;;   String DUPLICATE_KEY_TIME_DESC = &quot;Histogram for the time in milliseconds to handle ON DUPLICATE keywords&quot;;   String SLOW_DUPLICATE_KEY = &quot;slowDuplicateKeyCheckCalls&quot;;   String SLOW_DUPLICATE_KEY_DESC = &quot;The number of on duplicate key checks slower than the configured threshold&quot;;    String PRE_WAL_RESTORE_TIME = &quot;preWALRestoreTime&quot;;   String PRE_WAL_RESTORE_TIME_DESC = &quot;Histogram for the time in milliseconds for Indexer's preWALRestore&quot;;   String SLOW_PRE_WAL_RESTORE = &quot;slowPreWALRestoreCalls&quot;;   String SLOW_PRE_WAL_RESTORE_DESC = &quot;The number of preWALRestore calls slower than the configured threshold&quot;;    String POST_PUT_TIME = &quot;postPutTime&quot;;   String POST_PUT_TIME_DESC = &quot;Histogram for the time in milliseconds for Indexer's postPut&quot;;   String SLOW_POST_PUT = &quot;slowPostPutCalls&quot;;   String SLOW_POST_PUT_DESC = &quot;The number of postPut calls slower than the configured threshold&quot;;    String POST_DELETE_TIME = &quot;postDeleteTime&quot;;   String POST_DELETE_TIME_DESC = &quot;Histogram for the time in milliseconds for Indexer's postDelete&quot;;   String SLOW_POST_DELETE = &quot;slowPostDeleteCalls&quot;;   String SLOW_POST_DELETE_DESC = &quot;The number of postDelete calls slower than the configured threshold&quot;;    String POST_OPEN_TIME = &quot;postOpenTime&quot;;   String POST_OPEN_TIME_DESC = &quot;Histogram for the time in milliseconds for Indexer's postOpen&quot;;   String SLOW_POST_OPEN = &quot;slowPostOpenCalls&quot;;   String SLOW_POST_OPEN_DESC = &quot;The number of postOpen calls slower than the configured threshold&quot;;    /**    * Updates the index preparation time histogram (preBatchMutate).    *    * @param t time taken in milliseconds    */   void updateIndexPrepareTime(long t);    /**    * Increments the number of slow calls prepare an index write.    */   void incrementNumSlowIndexPrepareCalls();    /**    * Updates the index write time histogram (postBatchMutate).    *    * @param t time taken in milliseconds    */   void updateIndexWriteTime(long t);    /**    * Increments the number of slow calls to write to the index.    */   void incrementNumSlowIndexWriteCalls();    /**    * Updates the preWALRestore time histogram.    *    * @param t time taken in milliseconds    */   void updatePreWALRestoreTime(long t);    /**    * Increments the number of slow preWALRestore calls.    */   void incrementNumSlowPreWALRestoreCalls();    /**    * Updates the postPut time histogram.    *    * @param t time taken in milliseconds    */   void updatePostPutTime(long t);    /**    * Increments the number of slow postPut calls.    */   void incrementNumSlowPostPutCalls();    /**    * Updates the postDelete time histogram.    *    * @param t time taken in milliseconds    */   void updatePostDeleteTime(long t);    /**    * Increments the number of slow postDelete calls.    */   void incrementNumSlowPostDeleteCalls();    /**    * Updates the postOpen time histogram.    *    * @param t time taken in milliseconds    */   void updatePostOpenTime(long t);    /**    * Increments the number of slow postOpen calls.    */   void incrementNumSlowPostOpenCalls();    /**    * Updates the preIncrementAfterRowLock time histogram.    *    * @param t time taken in milliseconds    */   void updateDuplicateKeyCheckTime(long t);    /**    * Increments the number of slow preIncrementAfteRowLock calls.    */   void incrementSlowDuplicateKeyCheckCalls(); }</td>
    <td align="left">data class</td>
    <td align="left">\n1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10131</td>
    <td align="left">https://github.com/apache/phoenix/blob/69e5bb0b304a53967cef40b2a4cfc66e69ecaa51/phoenix-core/src/main/java/org/apache/phoenix/hbase/index/metrics/MetricsIndexerSource.java/#L25-L150</td>
    <td align="right">1</td>
    <td align="right">1150</td>
    <td align="right">10131</td>
  </tr>
  <tr valign="top">
    <td align="right">125</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class NotificationsAggregatorState {         public long recentEventLogsCount;         public long activeRequestsCount;     }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1573</td>
    <td align="left">https://github.com/vmware/admiral/blob/e02d0e77f65d0ee3541a378110ecd4233bdb6664/request/src/main/java/com/vmware/admiral/request/notification/NotificationsService.java/#L52-L55</td>
    <td align="right">1</td>
    <td align="right">125</td>
    <td align="right">1573</td>
  </tr>
  <tr valign="top">
    <td align="right">1698</td>
    <td align="left">{ &quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [ &quot;1. Data Class&quot; ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@InterfaceAudience.Private @InterfaceStability.Evolving public class BlockMissingException extends IOException {    private static final long serialVersionUID = 1L;    private String filename;   private long   offset;    /**    * An exception that indicates that file was corrupted.    * @param filename name of corrupted file    * @param description a description of the corruption details    */   public BlockMissingException(String filename, String description, long offset) {     super(description);     this.filename = filename;     this.offset = offset;   }    /**    * Returns the name of the corrupted file.    * @return name of corrupted file    */   public String getFile() {     return filename;   }    /**    * Returns the offset at which this file is corrupted    * @return offset of corrupted file    */   public long getOffset() {     return offset;   } }</td>
    <td align="left">data class</td>
    <td align="left">1 Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11733</td>
    <td align="left">https://github.com/apache/hadoop-hdfs/blob/b2d2a3262c587638db04c2991d48656b3d06275c/src/java/org/apache/hadoop/hdfs/BlockMissingException.java/#L30-L65</td>
    <td align="right">1</td>
    <td align="right">1698</td>
    <td align="right">11733</td>
  </tr>
  <tr valign="top">
    <td align="right">367</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class RequireCapability     {         private final String namespace;          private final String filter;          private final String effective;          public RequireCapability ( final String namespace, final String filter, final String effective )         {             this.namespace = namespace;             this.filter = filter;             this.effective = effective;         }          public String getNamespace ()         {             return this.namespace;         }          public String getFilter ()         {             return this.filter;         }          public String getEffective ()         {             return this.effective;         }     }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3757</td>
    <td align="left">https://github.com/eclipse/packagedrone/blob/3869c1643cdc6f7cb8b26097a7b6994683b13d7e/bundles/org.eclipse.packagedrone.repo.utils.osgi/src/org/eclipse/packagedrone/repo/utils/osgi/bundle/BundleInformation.java/#L377-L406</td>
    <td align="right">1</td>
    <td align="right">367</td>
    <td align="right">3757</td>
  </tr>
  <tr valign="top">
    <td align="right">205</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;badsmells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class StableValue {      private final T value;     private final Assumption assumption;      public StableValue(T value, String name) {         this.value = value;         this.assumption = Truffle.getRuntime().createAssumption(name);     }      public T getValue() {         return value;     }      public Assumption getAssumption() {         return assumption;     }      @Override     public String toString() {         return &quot;[&quot; + value + &quot;, &quot; + assumption + &quot;]&quot;;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2299</td>
    <td align="left">https://github.com/oracle/fastr/blob/a1ee49060317621c0c9eceea8ec60040aca59b2d/com.oracle.truffle.r.runtime/src/com/oracle/truffle/r/runtime/StableValue.java/#L28-L50</td>
    <td align="right">1</td>
    <td align="right">205</td>
    <td align="right">2299</td>
  </tr>
  <tr valign="top">
    <td align="right">809</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface IContentEmitter {  	String getOutputFormat( );  	void initialize( IEmitterServices service ) throws BirtException;  	void start( IReportContent report ) throws BirtException;  	void end( IReportContent report ) throws BirtException;  	/** 	 * start a page 	 *  	 * @param page 	 */ 	void startPage( IPageContent page ) throws BirtException; 	 	/** 	 * page end 	 *  	 * @param page 	 */ 	void endPage( IPageContent page ) throws BirtException;  	/** 	 * table started 	 *  	 * @param table 	 */ 	void startTable( ITableContent table ) throws BirtException;  	/** 	 * table end 	 */ 	void endTable( ITableContent table ) throws BirtException;  	void startTableBand( ITableBandContent band ) throws BirtException;  	void endTableBand( ITableBandContent band ) throws BirtException;  	void startRow( IRowContent row ) throws BirtException;  	void endRow( IRowContent row ) throws BirtException;  	void startCell( ICellContent cell ) throws BirtException;  	void endCell( ICellContent cell ) throws BirtException; 	 	void startList( IListContent list ) throws BirtException;  	void endList( IListContent list ) throws BirtException;  	void startListBand( IListBandContent listBand ) throws BirtException;  	void endListBand( IListBandContent listBand ) throws BirtException;  	void startContainer( IContainerContent container ) throws BirtException;  	void endContainer( IContainerContent container ) throws BirtException;  	void startText( ITextContent text ) throws BirtException;  	void startData( IDataContent data ) throws BirtException;  	void startLabel( ILabelContent label ) throws BirtException; 	 	void startAutoText ( IAutoTextContent autoText ) throws BirtException;  	void startForeign( IForeignContent foreign ) throws BirtException;  	void startImage( IImageContent image ) throws BirtException;  	void startContent( IContent content ) throws BirtException; 	void endContent( IContent content) throws BirtException; 	 	void startGroup( IGroupContent group ) throws BirtException;  	void endGroup( IGroupContent group ) throws BirtException;  	void startTableGroup( ITableGroupContent group ) throws BirtException;  	void endTableGroup( ITableGroupContent group ) throws BirtException;  	void startListGroup( IListGroupContent group ) throws BirtException;  	void endListGroup( IListGroupContent group ) throws BirtException; }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7647</td>
    <td align="left">https://github.com/eclipse/birt/blob/f89264810347de98702db45386a822aabc0fadbf/engine/org.eclipse.birt.report.engine/src/org/eclipse/birt/report/engine/emitter/IContentEmitter.java/#L39-L126</td>
    <td align="right">1</td>
    <td align="right">809</td>
    <td align="right">7647</td>
  </tr>
  <tr valign="top">
    <td align="right">2076</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class FakeErrorBoxWidget implements IErrorBox { 	/**  	 * Boolean to signify if a listener was registered. 	 */ 	private boolean observed; 	/**  	 * Boolean to store the display state. 	 */ 	private boolean displayed;  	/**  	 * The error message. 	 */ 	private String errorMsg = null;  	/**  	 * This operation returns true if the display operation is called for the FakeErrorBoxWidget. 	 * @return True if the widget was displayed, false if not. 	 */ 	public boolean widgetDisplayed() { 		return this.displayed; 	}  	/**  	 * This operation implements display() from UIWidget with a simple pass through that makes whether or not the method was called. Nothing is drawn on the screen. 	 */ 	@Override 	public void display() {  		this.displayed = true;  		return;  	}  	/**  	 * (non-Javadoc) 	 * @see IErrorBox#setErrorString(String error) 	 */ 	@Override 	public void setErrorString(String error) {  		// Set the error message 		errorMsg = error;  		return;  	}  	/**  	 * (non-Javadoc) 	 * @see IErrorBox#getErrorString() 	 */ 	@Override 	public String getErrorString() {  		// Return the error message 		return errorMsg;  	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13050</td>
    <td align="left">https://github.com/eclipse/ice/blob/3f6e0265f5b476ff90a660397ce83992944142c4/org.eclipse.ice.tests.client/src/org/eclipse/ice/tests/client/FakeErrorBoxWidget.java/#L21-L82</td>
    <td align="right">1</td>
    <td align="right">2076</td>
    <td align="right">13050</td>
  </tr>
  <tr valign="top">
    <td align="right">1672</td>
    <td align="left">&nbsp;&nbsp;&nbsp;YES I found bad smells 1. Long method 2. Data class 3. Shotgun surgery 4. Inappropriate intimacy 5. Feature envy</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
    private class ClientSelectDeleteMutationPlan implements MutationPlan {         private final StatementContext context;         private final TableRef targetTableRef;         private final QueryPlan dataPlan;         private final QueryPlan bestPlan;         private final boolean hasPreOrPostProcessing;         private final DeletingParallelIteratorFactory parallelIteratorFactory;         private final List otherTableRefs;         private final TableRef projectedTableRef;         private final int maxSize;         private final int maxSizeBytes;         private final PhoenixConnection connection;          public ClientSelectDeleteMutationPlan(TableRef targetTableRef, QueryPlan dataPlan, QueryPlan bestPlan,                                               boolean hasPreOrPostProcessing,                                               DeletingParallelIteratorFactory parallelIteratorFactory,                                               List otherTableRefs, TableRef projectedTableRef, int maxSize,                                               int maxSizeBytes, PhoenixConnection connection) {             this.context = bestPlan.getContext();             this.targetTableRef = targetTableRef;             this.dataPlan = dataPlan;             this.bestPlan = bestPlan;             this.hasPreOrPostProcessing = hasPreOrPostProcessing;             this.parallelIteratorFactory = parallelIteratorFactory;             this.otherTableRefs = otherTableRefs;             this.projectedTableRef = projectedTableRef;             this.maxSize = maxSize;             this.maxSizeBytes = maxSizeBytes;             this.connection = connection;         }          @Override         public ParameterMetaData getParameterMetaData() {             return context.getBindManager().getParameterMetaData();         }          @Override         public StatementContext getContext() {             return context;         }          @Override         public TableRef getTargetRef() {             return targetTableRef;         }          @Override         public Set getSourceRefs() {             return dataPlan.getSourceRefs();         }          @Override         public Operation getOperation() {           return operation;         }          @Override         public MutationState execute() throws SQLException {             ResultIterator iterator = bestPlan.iterator();             try {                 // If we're not doing any pre or post processing, we can produce the delete mutations directly                 // in the parallel threads executed for the scan                 if (!hasPreOrPostProcessing) {                     Tuple tuple;                     long totalRowCount = 0;                     if (parallelIteratorFactory != null) {                         parallelIteratorFactory.setQueryPlan(bestPlan);                         parallelIteratorFactory.setOtherTableRefs(otherTableRefs);                         parallelIteratorFactory.setProjectedTableRef(projectedTableRef);                     }                     while ((tuple=iterator.next()) != null) {// Runs query                         Cell kv = tuple.getValue(0);                         totalRowCount += PLong.INSTANCE.getCodec().decodeLong(kv.getValueArray(), kv.getValueOffset(), SortOrder.getDefault());                     }                     // Return total number of rows that have been deleted from the table. In the case of auto commit being off                     // the mutations will all be in the mutation state of the current connection. We need to divide by the                     // total number of tables we updated as otherwise the client will get an inflated result.                     int totalTablesUpdateClientSide = 1; // data table is always updated                     PTable bestTable = bestPlan.getTableRef().getTable();                     // global immutable tables are also updated client side (but don't double count the data table)                     if (bestPlan != dataPlan &amp;&amp; isMaintainedOnClient(bestTable)) {                         totalTablesUpdateClientSide++;                     }                     for (TableRef otherTableRef : otherTableRefs) {                         PTable otherTable = otherTableRef.getTable();                         // Don't double count the data table here (which morphs when it becomes a projected table, hence this check)                         if (projectedTableRef != otherTableRef &amp;&amp; isMaintainedOnClient(otherTable)) {                             totalTablesUpdateClientSide++;                         }                     }                     MutationState state = new MutationState(maxSize, maxSizeBytes, connection, totalRowCount/totalTablesUpdateClientSide);                      // set the read metrics accumulated in the parent context so that it can be published when the mutations are committed.                     state.setReadMetricQueue(context.getReadMetricsQueue());                      return state;                 } else {                     // Otherwise, we have to execute the query and produce the delete mutations in the single thread                     // producing the query results.                     return deleteRows(context, iterator, bestPlan, projectedTableRef, otherTableRefs);                 }             } finally {                 iterator.close();             }         }          @Override         public ExplainPlan getExplainPlan() throws SQLException {             List queryPlanSteps =  bestPlan.getExplainPlan().getPlanSteps();             List planSteps = Lists.newArrayListWithExpectedSize(queryPlanSteps.size()+1);             planSteps.add(&quot;DELETE ROWS&quot;);             planSteps.addAll(queryPlanSteps);             return new ExplainPlan(planSteps);         }          @Override         public Long getEstimatedRowsToScan() throws SQLException {             return bestPlan.getEstimatedRowsToScan();         }          @Override         public Long getEstimatedBytesToScan() throws SQLException {             return bestPlan.getEstimatedBytesToScan();         }          @Override         public Long getEstimateInfoTimestamp() throws SQLException {             return bestPlan.getEstimateInfoTimestamp();         }          @Override         public QueryPlan getQueryPlan() {             return bestPlan;         }     }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method2 Data class3 Shotgun surgery4 Inappropriate intimacy5 Feature envy</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11637</td>
    <td align="left">https://github.com/apache/phoenix/blob/69e5bb0b304a53967cef40b2a4cfc66e69ecaa51/phoenix-core/src/main/java/org/apache/phoenix/compile/DeleteCompiler.java/#L844-L978</td>
    <td align="right">2</td>
    <td align="right">1672</td>
    <td align="right">11637</td>
  </tr>
  <tr valign="top">
    <td align="right">967</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;EObject&quot;, propOrder = { &quot;extensions&quot; }) public class EObject {  	@XmlElement(name = &quot;Extension&quot;, namespace = &quot;http://www.omg.org/XMI&quot;) 	protected List extensions; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	@XmlJavaTypeAdapter(CollapsedStringAdapter.class) 	@XmlID 	protected String id; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected QName type; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected String version; 	@XmlAttribute 	protected String href; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	@XmlIDREF 	protected Object idref; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected String label; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected String uuid;  	/** 	 * Gets the value of the extensions property. 	 *  	 *  	 * This accessor method returns a reference to the live list, not a 	 * snapshot. Therefore any modification you make to the returned list will 	 * be present inside the JAXB object. This is why there is not a 	 * set method for the extensions property. 	 *  	 *  	 * For example, to add a new item, do as follows: 	 *  	 *  	 * getExtensions().add(newItem); 	 *  	 *  	 *  	 *  	 * Objects of the following type(s) are allowed in the list 	 * {@link Extension } 	 *  	 *  	 */ 	public List getExtensions() { 		if (extensions == null) { 			extensions = new ArrayList(); 		} 		return this.extensions; 	}  	/** 	 * Gets the value of the id property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getId() { 		return id; 	}  	/** 	 * Sets the value of the id property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setId(String value) { 		this.id = value; 	}  	/** 	 * Gets the value of the type property. 	 *  	 * @return possible object is {@link QName } 	 *  	 */ 	public QName getType() { 		return type; 	}  	/** 	 * Sets the value of the type property. 	 *  	 * @param value 	 *            allowed object is {@link QName } 	 *  	 */ 	public void setType(QName value) { 		this.type = value; 	}  	/** 	 * Gets the value of the version property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getVersion() { 		if (version == null) { 			return &quot;2.0&quot;; 		} else { 			return version; 		} 	}  	/** 	 * Sets the value of the version property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setVersion(String value) { 		this.version = value; 	}  	/** 	 * Gets the value of the href property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getHref() { 		return href; 	}  	/** 	 * Sets the value of the href property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setHref(String value) { 		this.href = value; 	}  	/** 	 * Gets the value of the idref property. 	 *  	 * @return possible object is {@link Object } 	 *  	 */ 	public Object getIdref() { 		return idref; 	}  	/** 	 * Sets the value of the idref property. 	 *  	 * @param value 	 *            allowed object is {@link Object } 	 *  	 */ 	public void setIdref(Object value) { 		this.idref = value; 	}  	/** 	 * Gets the value of the label property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getLabel() { 		return label; 	}  	/** 	 * Sets the value of the label property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setLabel(String value) { 		this.label = value; 	}  	/** 	 * Gets the value of the uuid property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getUuid() { 		return uuid; 	}  	/** 	 * Sets the value of the uuid property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setUuid(String value) { 		this.uuid = value; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8646</td>
    <td align="left">https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/container/openejb-jee/src/main/java/org/apache/openejb/jee/was/v6/ecore/EObject.java/#L57-L262</td>
    <td align="right">1</td>
    <td align="right">967</td>
    <td align="right">8646</td>
  </tr>
  <tr valign="top">
    <td align="right">608</td>
    <td align="left">&nbsp;{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Data Class&quot;,     &quot;Long Method&quot;   ] }  </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ReferenceProperty     implements Property {     EntityReference reference;      public ReferenceProperty()     {     }      public ReferenceProperty( EntityReference reference )     {         this.reference = reference;     }      @Override     public EntityReference get()     {         return reference;     }      @Override     public void set( EntityReference newValue )         throws IllegalArgumentException, IllegalStateException     {         reference = newValue;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6114</td>
    <td align="left">https://github.com/apache/attic-polygene-java/blob/031beef870302a0bd01bd5895ce849e00f2d5d5b/core/runtime/src/main/java/org/apache/polygene/runtime/value/ReferenceProperty.java/#L28-L54</td>
    <td align="right">1</td>
    <td align="right">608</td>
    <td align="right">6114</td>
  </tr>
  <tr valign="top">
    <td align="right">2656</td>
    <td align="left">&nbsp;{ &quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ElementImpl extends MinimalEObjectImpl.Container implements Element {   /**    * The default value of the '{@link #isA() A}' attribute.    *     *     * @see #isA()    * @generated    * @ordered    */   protected static final boolean A_EDEFAULT = false;    /**    * The cached value of the '{@link #isA() A}' attribute.    *     *     * @see #isA()    * @generated    * @ordered    */   protected boolean a = A_EDEFAULT;    /**    * The default value of the '{@link #getName() Name}' attribute.    *     *     * @see #getName()    * @generated    * @ordered    */   protected static final String NAME_EDEFAULT = null;    /**    * The cached value of the '{@link #getName() Name}' attribute.    *     *     * @see #getName()    * @generated    * @ordered    */   protected String name = NAME_EDEFAULT;    /**    * The cached value of the '{@link #getElements() Elements}' containment reference list.    *     *     * @see #getElements()    * @generated    * @ordered    */   protected EList elements;    /**    *     *     * @generated    */   protected ElementImpl()   {     super();   }    /**    *     *     * @generated    */   @Override   protected EClass eStaticClass()   {     return Bug305397Package.Literals.ELEMENT;   }    /**    *     *     * @generated    */   public boolean isA()   {     return a;   }    /**    *     *     * @generated    */   public void setA(boolean newA)   {     boolean oldA = a;     a = newA;     if (eNotificationRequired())       eNotify(new ENotificationImpl(this, Notification.SET, Bug305397Package.ELEMENT__A, oldA, a));   }    /**    *     *     * @generated    */   public String getName()   {     return name;   }    /**    *     *     * @generated    */   public void setName(String newName)   {     String oldName = name;     name = newName;     if (eNotificationRequired())       eNotify(new ENotificationImpl(this, Notification.SET, Bug305397Package.ELEMENT__NAME, oldName, name));   }    /**    *     *     * @generated    */   public EList getElements()   {     if (elements == null)     {       elements = new EObjectContainmentEList(Element.class, this, Bug305397Package.ELEMENT__ELEMENTS);     }     return elements;   }    /**    *     *     * @generated    */   @Override   public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)   {     switch (featureID)     {       case Bug305397Package.ELEMENT__ELEMENTS:         return ((InternalEList)getElements()).basicRemove(otherEnd, msgs);     }     return super.eInverseRemove(otherEnd, featureID, msgs);   }    /**    *     *     * @generated    */   @Override   public Object eGet(int featureID, boolean resolve, boolean coreType)   {     switch (featureID)     {       case Bug305397Package.ELEMENT__A:         return isA();       case Bug305397Package.ELEMENT__NAME:         return getName();       case Bug305397Package.ELEMENT__ELEMENTS:         return getElements();     }     return super.eGet(featureID, resolve, coreType);   }    /**    *     *     * @generated    */   @SuppressWarnings(&quot;unchecked&quot;)   @Override   public void eSet(int featureID, Object newValue)   {     switch (featureID)     {       case Bug305397Package.ELEMENT__A:         setA((Boolean)newValue);         return;       case Bug305397Package.ELEMENT__NAME:         setName((String)newValue);         return;       case Bug305397Package.ELEMENT__ELEMENTS:         getElements().clear();         getElements().addAll((Collection)newValue);         return;     }     super.eSet(featureID, newValue);   }    /**    *     *     * @generated    */   @Override   public void eUnset(int featureID)   {     switch (featureID)     {       case Bug305397Package.ELEMENT__A:         setA(A_EDEFAULT);         return;       case Bug305397Package.ELEMENT__NAME:         setName(NAME_EDEFAULT);         return;       case Bug305397Package.ELEMENT__ELEMENTS:         getElements().clear();         return;     }     super.eUnset(featureID);   }    /**    *     *     * @generated    */   @Override   public boolean eIsSet(int featureID)   {     switch (featureID)     {       case Bug305397Package.ELEMENT__A:         return a != A_EDEFAULT;       case Bug305397Package.ELEMENT__NAME:         return NAME_EDEFAULT == null ? name != null : !NAME_EDEFAULT.equals(name);       case Bug305397Package.ELEMENT__ELEMENTS:         return elements != null &amp;&amp; !elements.isEmpty();     }     return super.eIsSet(featureID);   }    /**    *     *     * @generated    */   @Override   public String toString()   {     if (eIsProxy()) return super.toString();      StringBuffer result = new StringBuffer(super.toString());     result.append(&quot; (a: &quot;);     result.append(a);     result.append(&quot;, name: &quot;);     result.append(name);     result.append(')');     return result.toString();   }  } //ElementImpl</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15183</td>
    <td align="left">https://github.com/eclipse/xtext-core/blob/e04964e4c2a3e0338c0079bd8333688835e77c31/org.eclipse.xtext.tests/src-gen/org/eclipse/xtext/parsetree/impl/bug305397/impl/ElementImpl.java/#L40-L296</td>
    <td align="right">1</td>
    <td align="right">2656</td>
    <td align="right">15183</td>
  </tr>
  <tr valign="top">
    <td align="right">1036</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
class ResourceMethodConfigImpl implements ResourceMethodConfig {   private final ConfigValue _timeoutMs;    ResourceMethodConfigImpl(ConfigValue timeoutMs)   {     _timeoutMs = timeoutMs;   }    public ConfigValue getTimeoutMs()   {     return _timeoutMs;   }    @Override   public String toString()   {     return &quot;ResourceMethodConfigImpl{&quot; +             &quot;_timeoutMs=&quot; + _timeoutMs +             '}';   }    @Override   public boolean equals(Object o)   {     if (this == o) return true;     if (o == null || getClass() != o.getClass()) return false;     ResourceMethodConfigImpl that = (ResourceMethodConfigImpl) o;     return Objects.equals(_timeoutMs, that._timeoutMs);   }    @Override   public int hashCode()   {     return Objects.hash(_timeoutMs);   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9403</td>
    <td align="left">https://github.com/linkedin/rest.li/blob/ad74aa98da8a55ad9c339d0769a3e8fb495765af/restli-server/src/main/java/com/linkedin/restli/server/config/ResourceMethodConfigImpl.java/#L13-L49</td>
    <td align="right">1</td>
    <td align="right">1036</td>
    <td align="right">9403</td>
  </tr>
  <tr valign="top">
    <td align="right">4238</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;1. Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private static class Success extends Try {          private V value;          public Success(V value) {              super();              this.value = value;          }          @Override          public Boolean isSuccess() {              return true;          }          @Override          public Boolean isFailure() {              return false;          }          @Override          public void throwException() {              //log.error(&quot;Method throwException() called on a Success instance&quot;);          }          @Override         public V get() {             return value;         }          @Override         public Throwable getError() {             return null;         }     }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11157</td>
    <td align="left">https://github.com/apache/archiva/blob/d1242030bf232c0d9b68e4402188ee261924bf4b/archiva-modules/archiva-base/archiva-common/src/main/java/org/apache/archiva/common/Try.java/#L199-L244</td>
    <td align="right">1</td>
    <td align="right">4238</td>
    <td align="right">11157</td>
  </tr>
  <tr valign="top">
    <td align="right">565</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class FunctionExpressionNode extends RSourceSectionNode implements RSyntaxNode, RSyntaxFunction {      public static FunctionExpressionNode create(SourceSection src, RootCallTarget callTarget) {         return new FunctionExpressionNode(src, callTarget);     }      @Child private SetVisibilityNode visibility = SetVisibilityNode.create();      @CompilationFinal private RootCallTarget callTarget;     private final PromiseDeoptimizeFrameNode deoptFrameNode;      @CompilationFinal private boolean initialized = false;      private FunctionExpressionNode(SourceSection src, RootCallTarget callTarget) {         super(src);         this.callTarget = callTarget;         this.deoptFrameNode = EagerEvalHelper.optExprs() || EagerEvalHelper.optVars() || EagerEvalHelper.optDefault() ? new PromiseDeoptimizeFrameNode() : null;     }      @Override     public RFunction execute(VirtualFrame frame) {         visibility.execute(frame, true);         MaterializedFrame matFrame = frame.materialize();         if (deoptFrameNode != null) {             // Deoptimize every promise which is now in this frame, as it might leave it's stack             deoptFrameNode.deoptimizeFrame(RArguments.getArguments(matFrame));         }         if (!initialized) {             CompilerDirectives.transferToInterpreterAndInvalidate();             if (!FrameSlotChangeMonitor.isEnclosingFrameDescriptor(callTarget.getRootNode().getFrameDescriptor(), frame)) {                 if (!FrameSlotChangeMonitor.isEnclosingFrameDescriptor(callTarget.getRootNode().getFrameDescriptor(), null)) {                     RRootNode root = (RRootNode) callTarget.getRootNode();                     callTarget = root.duplicateWithNewFrameDescriptor();                 }                 FrameSlotChangeMonitor.initializeEnclosingFrame(callTarget.getRootNode().getFrameDescriptor(), frame);             }             initialized = true;         }         return RDataFactory.createFunction(RFunction.NO_NAME, RFunction.NO_NAME, callTarget, null, matFrame);     }      public RootCallTarget getCallTarget() {         return callTarget;     }      @Override     public RSyntaxElement[] getSyntaxArgumentDefaults() {         return RASTUtils.asSyntaxNodes(((FunctionDefinitionNode) callTarget.getRootNode()).getFormalArguments().getArguments());     }      @Override     public RSyntaxElement getSyntaxBody() {         return ((FunctionDefinitionNode) callTarget.getRootNode()).getBody();     }      @Override     public ArgumentsSignature getSyntaxSignature() {         return ((FunctionDefinitionNode) callTarget.getRootNode()).getFormalArguments().getSignature();     }      @Override     public String getSyntaxDebugName() {         return ((RRootNode) callTarget.getRootNode()).getName();     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5717</td>
    <td align="left">https://github.com/oracle/fastr/blob/a1ee49060317621c0c9eceea8ec60040aca59b2d/com.oracle.truffle.r.nodes/src/com/oracle/truffle/r/nodes/function/FunctionExpressionNode.java/#L46-L110</td>
    <td align="right">1</td>
    <td align="right">565</td>
    <td align="right">5717</td>
  </tr>
  <tr valign="top">
    <td align="right">878</td>
    <td align="left">&nbsp;{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Shape {      private String type;      private Map members = Collections.emptyMap();      private String documentation;      private List required;      private List enumValues;      private String payload;      private boolean flattened;      private boolean exception;      private boolean streaming;      private boolean wrapper;      private Member listMember;      private Member mapKeyType;      private Member mapValueType;      @JsonProperty(value = &quot;error&quot;)     private ErrorTrait errorTrait;      private long min;      private long max;      private String pattern;      private boolean fault;      private boolean deprecated;      @JsonProperty(value = &quot;eventstream&quot;)     private boolean isEventStream;      @JsonProperty(value = &quot;event&quot;)     private boolean isEvent;      private String timestampFormat;      private boolean sensitive;      public boolean isFault() {         return fault;     }      public void setFault(boolean fault) {         this.fault = fault;     }      public String getPattern() {         return pattern;     }      public void setPattern(String pattern) {         this.pattern = pattern;     }      public String getType() {         return type;     }      public void setType(String type) {         this.type = type;     }      public Map getMembers() {         return members;     }      public void setMembers(Map members) {         this.members = members;     }      public String getDocumentation() {         return documentation;     }      public void setDocumentation(String documentation) {         this.documentation = documentation;     }      public List getRequired() {         return required;     }      public void setRequired(List required) {         this.required = required;     }      public List getEnumValues() {         return enumValues;     }      @JsonProperty(value = &quot;enum&quot;)     public void setEnumValues(List enumValues) {         this.enumValues = enumValues;     }      public String getPayload() {         return payload;     }      public void setPayload(String payload) {         this.payload = payload;     }      public boolean isFlattened() {         return flattened;     }      public void setFlattened(boolean flattened) {         this.flattened = flattened;     }      public boolean isException() {         return exception;     }      public void setException(boolean exception) {         this.exception = exception;     }      public Member getMapKeyType() {         return mapKeyType;     }      @JsonProperty(value = &quot;key&quot;)     public void setMapKeyType(Member mapKeyType) {         this.mapKeyType = mapKeyType;     }      public Member getMapValueType() {         return mapValueType;     }      @JsonProperty(value = &quot;value&quot;)     public void setMapValueType(Member mapValueType) {         this.mapValueType = mapValueType;     }      public Member getListMember() {         return listMember;     }      @JsonProperty(value = &quot;member&quot;)     public void setListMember(Member listMember) {         this.listMember = listMember;     }      public long getMin() {         return min;     }      public void setMin(long min) {         this.min = min;     }      public long getMax() {         return max;     }      public void setMax(long max) {         this.max = max;     }      public boolean isStreaming() {         return streaming;     }      public void setStreaming(boolean streaming) {         this.streaming = streaming;     }      public boolean isWrapper() {         return wrapper;     }      public void setWrapper(boolean wrapper) {         this.wrapper = wrapper;     }      public ErrorTrait getErrorTrait() {         return errorTrait;     }      public void setErrorTrait(ErrorTrait errorTrait) {         this.errorTrait = errorTrait;     }      public boolean isDeprecated() {         return deprecated;     }      public void setDeprecated(boolean deprecated) {         this.deprecated = deprecated;     }      public boolean isEventStream() {         return isEventStream;     }      public void setIsEventStream(boolean eventStream) {         isEventStream = eventStream;     }      public boolean isEvent() {         return isEvent;     }      public void setIsEvent(boolean event) {         isEvent = event;     }      public String getTimestampFormat() {         return timestampFormat;     }      public void setTimestampFormat(String timestampFormat) {         this.timestampFormat = timestampFormat;     }      public boolean isSensitive() {         return sensitive;     }      public void setSensitive(boolean sensitive) {         this.sensitive = sensitive;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8012</td>
    <td align="left">https://github.com/aws/aws-sdk-java-v2/blob/1d5d11e8087c93ab1a3a2d35193052e526fd123c/codegen/src/main/java/software/amazon/awssdk/codegen/model/service/Shape.java/#L23-L261</td>
    <td align="right">1</td>
    <td align="right">878</td>
    <td align="right">8012</td>
  </tr>
  <tr valign="top">
    <td align="right">127</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells. The bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Header {     @SerializedName(&quot;typ&quot;)     public String type;     @SerializedName(&quot;alg&quot;)     public String algorithm;     @SerializedName(&quot;cty&quot;)     public String contentType; }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1581</td>
    <td align="left">https://github.com/vmware/xenon/blob/b6fb48b745985af2efc59b7ee0e5e7d69a289fbc/xenon-common/src/main/java/com/vmware/xenon/common/jwt/Header.java/#L23-L30</td>
    <td align="right">1</td>
    <td align="right">127</td>
    <td align="right">1581</td>
  </tr>
  <tr valign="top">
    <td align="right">26</td>
    <td align="left">{       &quot;message&quot;: &quot;YES I found bad smells&quot;,       &quot;detected_bad_smells&quot;: {           &quot;the bad smells are:&quot;: [               &quot;1. Long Method&quot;,               &quot;2. Data Class&quot;           ]       }   }  </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ConstantPartitioner implements DocumentPartitioner {    /** The list with a single content type, the default one. */   private final List legalContentTypes;    /** The single content type. */   private final String contentType;    /** The full document length. */   private int documentLength = 0;    /** Handle on the document. */   private DocumentHandle documentHandle;    /**    * Constructor for a {@link ConstantPartitioner} that has a single partition of type ContentType.    *    * @param contentType the single content type    */   public ConstantPartitioner(final String contentType) {     this.contentType = contentType;     this.legalContentTypes = Collections.singletonList(this.contentType);   }    /**    * Constructor for a {@link ConstantPartitioner} that has a single partition of type {@link    * DefaultPartitioner#DEFAULT_CONTENT_TYPE}.    */   public ConstantPartitioner() {     this(DEFAULT_CONTENT_TYPE);   }    @Override   public void onDocumentChanged(final DocumentChangedEvent event) {     final int removed = event.getLength();     int added = 0;     if (event.getText() != null) {       added = event.getText().length();     }     final int sizeDelta = added - removed;     this.documentLength += sizeDelta;   }    @Override   public void initialize() {     this.documentLength = getDocumentHandle().getDocument().getContentsCharCount();   }    @Override   public List getLegalContentTypes() {     return legalContentTypes;   }    @Override   public String getContentType(final int offset) {     return this.contentType;   }    @Override   public List computePartitioning(final int offset, final int length) {     final TypedRegion region = getPartition(offset);     return Collections.singletonList(region);   }    @Override   public TypedRegion getPartition(final int offset) {     return new TypedRegionImpl(offset, this.documentLength, this.contentType);   }    @Override   public DocumentHandle getDocumentHandle() {     return documentHandle;   }    @Override   public void setDocumentHandle(DocumentHandle handle) {     this.documentHandle = handle;   }    @Override   public void release() {} }</td>
    <td align="left">data class</td>
    <td align="left">the bad smells are:: 1. long method, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">the bad smells are:: 1. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">695</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/ide/che-core-ide-api/src/main/java/org/eclipse/che/ide/api/editor/partition/ConstantPartitioner.java/#L22-L103</td>
    <td align="right">1</td>
    <td align="right">26</td>
    <td align="right">695</td>
  </tr>
  <tr valign="top">
    <td align="right">360</td>
    <td align="left">&nbsp;&nbsp;YES I found bad smells the bad smells are: 1. Long method, 2. Data class, 3. Feature envy</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class User {   private String name = &quot;nameA&quot;;    private int age = 100;    private int index;    private String[] names;    public String getName() {     return name;   }    public void setName(String name) {     this.name = name;   }    public String[] getNames() {     return names;   }    public void setNames(String[] names) {     this.names = names;   }    public int getAge() {     return age;   }    public void setAge(int age) {     this.age = age;   }    public int getIndex() {     return index;   }    public void setIndex(int index) {     this.index = index;   }    @Override   public String toString() {     return &quot;User [name=&quot; + name + &quot;, age=&quot; + age + &quot;, index=&quot; + index + &quot;]&quot;;   }    public String jsonString() {     try {       return JsonUtils.writeValueAsString(this);     } catch (JsonProcessingException e) {       throw new IllegalStateException(e);     }   } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method, 2 Data class, 3 Feature envy</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">. Long method,  3. Feature envy</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3696</td>
    <td align="left">https://github.com/apache/servicecomb-java-chassis/blob/72cd0e137c4a0c3b899adfa6e19e2fd590743014/integration-tests/it-common/src/main/java/org/apache/servicecomb/it/schema/User.java/#L23-L76</td>
    <td align="right">2</td>
    <td align="right">360</td>
    <td align="right">3696</td>
  </tr>
  <tr valign="top">
    <td align="right">1916</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells the bad smells are:&quot;, &quot;detected_bad_smells&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public class AnElementElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.xtext.ui.tests.editor.contentassist.TwoContextsTestLanguage.AnElement&quot;); 		private final Group cGroup = (Group)rule.eContents().get(1); 		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0); 		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0); 		private final Group cGroup_1 = (Group)cGroup.eContents().get(1); 		private final Keyword cRefersToKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0); 		private final Assignment cReferredAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1); 		private final CrossReference cReferredAnElementCrossReference_1_1_0 = (CrossReference)cReferredAssignment_1_1.eContents().get(0); 		private final RuleCall cReferredAnElementIDTerminalRuleCall_1_1_0_1 = (RuleCall)cReferredAnElementCrossReference_1_1_0.eContents().get(1); 		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2); 		 		//AnElement: 		//	name=ID ('refersTo' referred=[AnElement])? ';'; 		@Override public ParserRule getRule() { return rule; } 		 		//name=ID ('refersTo' referred=[AnElement])? ';' 		public Group getGroup() { return cGroup; } 		 		//name=ID 		public Assignment getNameAssignment_0() { return cNameAssignment_0; } 		 		//ID 		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; } 		 		//('refersTo' referred=[AnElement])? 		public Group getGroup_1() { return cGroup_1; } 		 		//'refersTo' 		public Keyword getRefersToKeyword_1_0() { return cRefersToKeyword_1_0; } 		 		//referred=[AnElement] 		public Assignment getReferredAssignment_1_1() { return cReferredAssignment_1_1; } 		 		//[AnElement] 		public CrossReference getReferredAnElementCrossReference_1_1_0() { return cReferredAnElementCrossReference_1_1_0; } 		 		//ID 		public RuleCall getReferredAnElementIDTerminalRuleCall_1_1_0_1() { return cReferredAnElementIDTerminalRuleCall_1_1_0_1; } 		 		//';' 		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; } 	}</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12408</td>
    <td align="left">https://github.com/eclipse/xtext-eclipse/blob/0c7546b6aaf3644a77fc68eef9f3da368cbbeabd/org.eclipse.xtext.ui.tests/src-gen/org/eclipse/xtext/ui/tests/editor/contentassist/services/TwoContextsTestLanguageGrammarAccess.java/#L40-L82</td>
    <td align="right">1</td>
    <td align="right">1916</td>
    <td align="right">12408</td>
  </tr>
  <tr valign="top">
    <td align="right">105</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;response&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [&quot;Data Class&quot;]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Customer388 {  	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id; 	private String firstName; 	private String lastName;  	protected Customer388() {}  	public Customer388(String firstName, String lastName) { 		this.firstName = firstName; 		this.lastName = lastName; 	}  	@Override 	public String toString() { 		return String.format(&quot;Customer388[id=%d, firstName='%s', lastName='%s']&quot;, id, firstName, lastName); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1384</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer388.java/#L8-L27</td>
    <td align="right">1</td>
    <td align="right">105</td>
    <td align="right">1384</td>
  </tr>
  <tr valign="top">
    <td align="right">1803</td>
    <td align="left">&nbsp;&nbsp;YES, I found bad smells  the bad smells are: 1. Long method 2. Feature envy 3. Data class 4. Inappropriate naming 5. Inconsistent formatting and spacing 6. Deeply nested structure 7. Unused code 8. Code duplication 9. Non-optimized imports 10. Comments that are not helpful or redundant 11. Poor exception handling 12. Misplaced responsibilities 13. Overuse of static methods and variables 14. Insufficient encapsulation 15. Inconsistent use of modifiers 16. Lack of proper logging statements 17. Lack of validation for input parameters 18. Poor naming conventions for variables and methods 19. Excessive depth of inheritance hierarchy </td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
@SuppressWarnings(&quot;serial&quot;) @Entity @Table(name = &quot;TRIGGER&quot;, uniqueConstraints = @UniqueConstraint(columnNames = { &quot;name&quot;, &quot;alert_id&quot; })) public class Trigger extends JPAEntity implements Serializable { 	 	 	public static class Serializer extends JsonSerializer {  		@Override 		public void serialize(Trigger trigger, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException { 			 			jgen.writeStartObject(); 			 			jgen.writeStringField(&quot;id&quot;, trigger.getId().toString()); 			jgen.writeStringField(&quot;name&quot;, trigger.getName()); 			jgen.writeStringField(&quot;type&quot;, trigger.getType().name()); 			jgen.writeNumberField(&quot;threshold&quot;, trigger.getThreshold().doubleValue()); 			 			if(trigger.getSecondaryThreshold() != null) { 				jgen.writeNumberField(&quot;secondaryThreshold&quot;, trigger.getSecondaryThreshold()); 			} 			 			if(trigger.getInertia() != null) { 				jgen.writeNumberField(&quot;inertia&quot;, trigger.getInertia()); 			} 			 			jgen.writeEndObject(); 		} 		 	} 	 	public static class Deserializer extends JsonDeserializer {  		@Override 		public Trigger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {  			Trigger trigger = new Trigger(); 			JsonNode rootNode = jp.getCodec().readTree(jp); 			 			BigInteger id = new BigInteger(rootNode.get(&quot;id&quot;).asText()); 			trigger.id = id; 			 			String name = rootNode.get(&quot;name&quot;).asText(); 			trigger.setName(name); 			 			TriggerType type = TriggerType.fromString(rootNode.get(&quot;type&quot;).asText()); 			trigger.setType(type); 			 			Double threshold = rootNode.get(&quot;threshold&quot;).asDouble(); 			trigger.setThreshold(threshold);  			if(rootNode.get(&quot;secondaryThreshold&quot;) != null) { 				trigger.setSecondaryThreshold(rootNode.get(&quot;secondaryThreshold&quot;).asDouble()); 			} 			 			if(rootNode.get(&quot;inertia&quot;) != null) { 				trigger.setInertia(rootNode.get(&quot;inertia&quot;).asLong()); 			} 			 			return trigger; 		} 		 	} 	      //~ Instance fields ******************************************************************************************************************************  	@Column(nullable = false)     @Enumerated(EnumType.STRING)     private TriggerType type;          @Basic(optional = false)     @Column(name = &quot;name&quot;, nullable = false)     private String name;          @Basic(optional = false)     private Double threshold;          private Double secondaryThreshold;          private Long inertia;      @ManyToOne(optional = false)     @JoinColumn(nullable = false, name = &quot;alert_id&quot;)     private Alert alert;          @ManyToMany(mappedBy = &quot;triggers&quot;, cascade = { CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH })     private List notifications = new ArrayList&lt;&gt;(0);      //~ Constructors *********************************************************************************************************************************      /**      * Creates a new Trigger object.      *      * @param  alert          The alert associated with the trigger. Cannot be null.      * @param  type           The type of the alert. Cannot be null.      * @param  name           The name of the alert. Cannot be null or empty.      * @param  threshold      The threshold value for the alert.      * @param  inertiaMillis  The amount of time in milliseconds a condition must exist for the trigger to fire. Cannot be negative.      */     public Trigger(Alert alert, TriggerType type, String name, double threshold, long inertiaMillis) {         this(alert, type, name, threshold, null, inertiaMillis);     }      /**      * Creates a new Trigger object.      *      * @param  alert               The alert associated with the trigger. Cannot be null.      * @param  type                The type of the alert. Cannot be null.      * @param  name                The name of the alert. Cannot be null or empty.      * @param  threshold           The threshold value for the alert.      * @param  secondaryThreshold  The secondary threshold value for the alert. May be null for types that only require one threshold.      * @param  inertiaMillis       The amount of time in milliseconds a condition must exist for the trigger to fire. Cannot be negative.      */     public Trigger(Alert alert, TriggerType type, String name, Double threshold, Double secondaryThreshold, long inertiaMillis) {         super(alert.getOwner());         setAlert(alert);         setType(type);         setName(name);         setThreshold(threshold);         setSecondaryThreshold(secondaryThreshold);         setInertia(inertiaMillis);         preUpdate();     }      /** Creates a new Trigger object. */     protected Trigger() {         super(null);     }      //~ Methods **************************************************************************************************************************************      /**      * Evaluates the trigger against actualValue (passed as parameter).      *      * @param   trigger      trigger to be evaluated.      * @param   actualValue  value against the trigger to be evaluated.      *      * @return  true if the trigger should be fired so that notification will be sent otherwise false.      *      * @throws  SystemException  If an error in evaluation occurs.      */     public static boolean evaluateTrigger(Trigger trigger, Double actualValue) {         requireArgument(trigger != null, &quot;Trigger cannot be null.&quot;);         requireArgument(actualValue != null, &quot;Trigger cannot be evaulated against null.&quot;);          Double lowThreshold, highThreshold;          switch (trigger.type) {             case GREATER_THAN:                 return actualValue.compareTo(trigger.getThreshold()) &gt; 0;             case GREATER_THAN_OR_EQ:                 return actualValue.compareTo(trigger.getThreshold()) &gt;= 0;             case LESS_THAN:                 return actualValue.compareTo(trigger.getThreshold()) &lt; 0;             case LESS_THAN_OR_EQ:                 return actualValue.compareTo(trigger.getThreshold()) &lt;= 0;             case EQUAL:                 return actualValue.compareTo(trigger.getThreshold()) == 0;             case NOT_EQUAL:                 return actualValue.compareTo(trigger.getThreshold()) != 0;             case BETWEEN:                 lowThreshold = Math.min(trigger.getThreshold(), trigger.getSecondaryThreshold());                 highThreshold = Math.max(trigger.getThreshold(), trigger.getSecondaryThreshold());                 return (actualValue.compareTo(lowThreshold) &gt;= 0 &amp;&amp; actualValue.compareTo(highThreshold) &lt;= 0);             case NOT_BETWEEN:                 lowThreshold = Math.min(trigger.getThreshold(), trigger.getSecondaryThreshold());                 highThreshold = Math.max(trigger.getThreshold(), trigger.getSecondaryThreshold());                 return (actualValue.compareTo(lowThreshold) &lt; 0 || actualValue.compareTo(highThreshold) &gt; 0);             case NO_DATA:             	    return actualValue == null;             default:                 throw new SystemException(&quot;Unsupported trigger type &quot; + trigger.type);         }     }      //~ Methods **************************************************************************************************************************************      /**      * Returns the notifications associated with the trigger.      *      * @return  The associated notifications.      */     public List getNotifications() {         return Collections.unmodifiableList(notifications);     }      /**      * Returns the trigger type.      *      * @return  The trigger type. Will never be null.      */     public TriggerType getType() {         return type;     }      /**      * Sets the trigger type.      *      * @param  type  The trigger type. Cannot be null.      */     public void setType(TriggerType type) {         requireArgument(type != null, &quot;The trigger type cannot be null.&quot;);         this.type = type;     }      /**      * Returns the trigger name.      *      * @return  The trigger name. Will never be null.      */     public String getName() {         return name;     }      /**      * Sets the name of the trigger.      *      * @param  name  The trigger name. Cannot be null or empty.      */     public void setName(String name) {         requireArgument(name != null &amp;&amp; !name.isEmpty(), &quot;Trigger name cannot be null or empty.&quot;);         this.name = name;     }      /**      * Returns the trigger threshold.      *      * @return  The trigger threshold.      */     public Double getThreshold() {         return threshold;     }      /**      * Sets the trigger threshold.      *      * @param  threshold  The trigger threshold. Cannot be null.      */     public void setThreshold(Double threshold) {         requireArgument(threshold != null, &quot;Trigger threshold cannot be null.&quot;);         this.threshold = threshold;     }      /**      * Returns the secondary threshold for the trigger.      *      * @return  The secondary threshold. Can return null for trigger types that only require a single threshold.      */     public Double getSecondaryThreshold() {         return secondaryThreshold;     }      /**      * Sets the secondary threshold for the trigger.      *      * @param  secondaryThreshold  The secondary threshold. Can be null for trigger types that only require a single threshold.      */     public void setSecondaryThreshold(Double secondaryThreshold) {         this.secondaryThreshold = secondaryThreshold;     }      /**      * Returns the inertia associated with the trigger in milliseconds.      *      * @return  The inertia in milliseconds.      */     public Long getInertia() {         return inertia;     }      /**      * Sets the inertia associated with the trigger in milliseconds.      *      * @param  inertiaMillis  The inertia associated with the trigger in milliseconds. Cannot be null or negative.      */     public void setInertia(Long inertiaMillis) {         if (this.alert == null) { // Only during deserialization.             this.inertia = inertiaMillis;         } else {             requireArgument(inertiaMillis != null &amp;&amp; inertiaMillis &gt;= 0, &quot;Inertia cannot be negative.&quot;);             Long longestIntervalLength = AlertUtils.getMaximumIntervalLength(this.alert.getExpression());             if (inertiaMillis &gt; longestIntervalLength)                 throw new IllegalArgumentException(String.format(&quot;Inertia %d cannot be more than width of the longest interval %d.&quot;, inertiaMillis, longestIntervalLength));             this.inertia = inertiaMillis;         }     }      /**      * Returns the alert with which the trigger is associated.      *      * @return  The alert with which the trigger is associated.      */     public Alert getAlert() {         return alert;     }      /**      * Sets the alert with which the trigger is associated.      *      * @param  alert  The alert with which the trigger is associated. Cannot be null.      */     public void setAlert(Alert alert) {         requireArgument(alert != null, &quot;The alert with which a trigger is associated cannot be null.&quot;);         this.alert = alert;     }      @Override     public int hashCode() {         int hash = 7;          hash = 97 * hash + Objects.hashCode(this.name);         hash = 97 * hash + Objects.hashCode(this.alert);         return hash;     }      @Override     public boolean equals(Object obj) {         if (obj == null) {             return false;         }         if (getClass() != obj.getClass()) {             return false;         }          final Trigger other = (Trigger) obj;          if (!Objects.equals(this.name, other.name)) {             return false;         }         if (!Objects.equals(this.alert, other.alert)) {             return false;         }         return true;     }      @Override     public String toString() {         if (type == TriggerType.BETWEEN || type == TriggerType.NOT_BETWEEN)             return &quot;Trigger{&quot; + &quot;type=&quot; + type + &quot;, name=&quot; + name + &quot;, primaryThreshold=&quot; + threshold + &quot;, secondaryThreshold=&quot; + secondaryThreshold +             &quot;, inertia=&quot; + inertia + '}';         else             return &quot;Trigger{&quot; + &quot;type=&quot; + type + &quot;, name=&quot; + name + &quot;, threshold=&quot; + threshold + &quot;, inertia=&quot; + inertia + '}';     }      //~ Enums ****************************************************************************************************************************************      /**      * The type of trigger.      *      * @author  Tom Valine (tvaline@salesforce.com)      */     public enum TriggerType {          /** Greater than. */         GREATER_THAN,         /** Greater than or equal to. */         GREATER_THAN_OR_EQ,         /** Less than. */         LESS_THAN,         /** Less than or equal to. */         LESS_THAN_OR_EQ,         /** Equal to. */         EQUAL,         /** Not equal to. */         NOT_EQUAL,         /** Between. */         BETWEEN,         /** Not between. */         NOT_BETWEEN,     	    /** No Data */     	    NO_DATA;          /**          * Converts a string to a trigger type.          *          * @param   name  The trigger type name.          *          * @return  The corresponding trigger type.          *          * @throws  IllegalArgumentException  If no corresponding trigger type is found.          */         @JsonCreator         public static TriggerType fromString(String name) {             for (TriggerType t : TriggerType.values()) {                 if (t.toString().equalsIgnoreCase(name)) {                     return t;                 }             }             throw new IllegalArgumentException(&quot;Trigger Type does not exist.&quot;);         }          /**          * Returns the name of the trigger type.          *          * @return  The name of the trigger type.          */         @JsonValue         public String value() {             return this.toString();         }      } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method2 Feature envy3 Data class4 Inappropriate naming5 Inconsistent formatting and spacing6 Deeply nested structure7 Unused code8 Code duplication9 Non-optimized imports</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12021</td>
    <td align="left">https://github.com/salesforce/Argus/blob/121b59a268da264316cded6a3e9271366a23cd86/ArgusCore/src/main/java/com/salesforce/dva/argus/entity/Trigger.java/#L88-L491</td>
    <td align="right">2</td>
    <td align="right">1803</td>
    <td align="right">12021</td>
  </tr>
  <tr valign="top">
    <td align="right">3002</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;1. Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  protected class ValueIterable implements Iterable {     private ValueIterator iterator = new ValueIterator();     @Override     public Iterator iterator() {       return iterator;     }    }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3071</td>
    <td align="left">https://github.com/apache/hadoop/blob/128dd91e10080bdcbcd7d555fa3c4105e55a6b51/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/task/ReduceContextImpl.java/#L350-L356</td>
    <td align="right">1</td>
    <td align="right">3002</td>
    <td align="right">3071</td>
  </tr>
  <tr valign="top">
    <td align="right">217</td>
    <td align="left"><br />
  {&quot;message&quot;: &quot;YES I found bad smells the bad smells are: 1.Long method, 2.Magic number, 3.Data class&quot;} </td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells).<br />
 Could you please identify which smells occur in the following code? However, do not describe the smells,<br />
 just list them. <br />
Please start your answer with &quot;YES I found bad smells&quot; when you find any bad smell. <br />
Otherwise, start your answer with &quot;NO, I did not find any bad smell&quot;. <br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells<br />
are:&quot; amongst the text your answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class SubProcessCommandLineArgs {    // Parameters to pass to the sub-process   private List parameters = Lists.newArrayList();    public void addCommand(Integer position, String value) {     parameters.add(new Command(position, value));   }    public void putCommand(Command command) {     parameters.add(command);   }    public List getParameters() {     return parameters;   }    /** Class used to store the SubProcces parameters. */   public static class Command {      // The ordinal position of the command to pass to the sub-process     int ordinalPosition;     String value;      @SuppressWarnings(&quot;unused&quot;)     private Command() {}      public Command(int ordinalPosition, String value) {       this.ordinalPosition = ordinalPosition;       this.value = value;     }      public int getKey() {       return ordinalPosition;     }      public void setKey(int key) {       this.ordinalPosition = key;     }      public String getValue() {       return value;     }      public void setValue(String value) {       this.value = value;     }   } }</td>
    <td align="left">data class</td>
    <td align="left">1.long method, 2.magic number, 3.data class </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1.long method,  2.magic number</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2368</td>
    <td align="left">https://github.com/apache/beam/blob/a956ff77a8448e5f2c12f6695fec608348b5ab60/examples/java/src/main/java/org/apache/beam/examples/subprocess/kernel/SubProcessCommandLineArgs.java/#L24-L72</td>
    <td align="right">2</td>
    <td align="right">217</td>
    <td align="right">2368</td>
  </tr>
  <tr valign="top">
    <td align="right">1950</td>
    <td align="left">&nbsp;{ &quot;message&quot;: &quot;YES, I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement public class Book {      private int id;     private String name;      public Book() {}      public Book(int bookId, String name) {         this.id = bookId;         this.name = name;     }      public int getId() {         return id;     }      public void setId(int id) {         this.id = id;     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">12530</td>
    <td align="left">https://github.com/apache/tomee/blob/d21933b313aff812fe5188b57bf572a9ad649148/examples/mp-rest-client/src/main/java/org/superbiz/rest/Book.java/#L22-L50</td>
    <td align="right">1</td>
    <td align="right">1950</td>
    <td align="right">12530</td>
  </tr>
  <tr valign="top">
    <td align="right">2287</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Blob&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ReportInstance extends AbstractDTOBase {      private String id;     private ReportStatusEnum status;     private String url;     private String ownerId;     private Boolean hasDetailRows;     private ZonedDateTime completionDate;     private ZonedDateTime requestDate;      public String getId() {         return id;     }      public void setId(String id) {         this.id = id;     }      public ReportStatusEnum getStatus() {         return status;     }      public void setStatus(ReportStatusEnum status) {         this.status = status;     }      public String getUrl() {         return url;     }      public void setUrl(String url) {         this.url = url;     }      public String getOwnerId() {         return ownerId;     }      public void setOwnerId(String ownerId) {         this.ownerId = ownerId;     }      public Boolean getHasDetailRows() {         return hasDetailRows;     }      public void setHasDetailRows(Boolean hasDetailRows) {         this.hasDetailRows = hasDetailRows;     }      public ZonedDateTime getCompletionDate() {         return completionDate;     }      public void setCompletionDate(ZonedDateTime completionDate) {         this.completionDate = completionDate;     }      public ZonedDateTime getRequestDate() {         return requestDate;     }      public void setRequestDate(ZonedDateTime requestDate) {         this.requestDate = requestDate;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13890</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/api/dto/analytics/reports/ReportInstance.java/#L26-L91</td>
    <td align="right">1</td>
    <td align="right">2287</td>
    <td align="right">13890</td>
  </tr>
  <tr valign="top">
    <td align="right">2041</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES, I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
        private static class GridMBeanServerData {             /** Set of grid names for selected MBeanServer. */             private Collection igniteInstanceNames = new HashSet&lt;&gt;();              /** */             private ObjectName mbean;              /** Count of grid instances. */             private int cnt;              /**              * Create data container.              *              * @param mbean Object name of MBean.              */             GridMBeanServerData(ObjectName mbean) {                 assert mbean != null;                  this.mbean = mbean;             }              /**              * Add Ignite instance name.              *              * @param igniteInstanceName Ignite instance name.              */             public void addIgniteInstance(String igniteInstanceName) {                 igniteInstanceNames.add(igniteInstanceName);             }              /**              * Remove Ignite instance name.              *              * @param igniteInstanceName Ignite instance name.              */             public void removeIgniteInstance(String igniteInstanceName) {                 igniteInstanceNames.remove(igniteInstanceName);             }              /**              * Returns {@code true} if data contains the specified              * Ignite instance name.              *              * @param igniteInstanceName Ignite instance name.              * @return {@code true} if data contains the specified Ignite instance name.              */             public boolean containsIgniteInstance(String igniteInstanceName) {                 return igniteInstanceNames.contains(igniteInstanceName);             }              /**              * Gets name used in MBean server.              *              * @return Object name of MBean.              */             public ObjectName getMbean() {                 return mbean;             }              /**              * Gets number of grid instances working with MBeanServer.              *              * @return Number of grid instances.              */             public int getCounter() {                 return cnt;             }              /**              * Sets number of grid instances working with MBeanServer.              *              * @param cnt Number of grid instances.              */             public void setCounter(int cnt) {                 this.cnt = cnt;             }         }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">12853</td>
    <td align="left">https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/core/src/main/java/org/apache/ignite/internal/IgnitionEx.java/#L2796-L2872</td>
    <td align="right">1</td>
    <td align="right">2041</td>
    <td align="right">12853</td>
  </tr>
  <tr valign="top">
    <td align="right">2508</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Customer1953 {  	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id; 	private String firstName; 	private String lastName;  	protected Customer1953() {}  	public Customer1953(String firstName, String lastName) { 		this.firstName = firstName; 		this.lastName = lastName; 	}  	@Override 	public String toString() { 		return String.format(&quot;Customer1953[id=%d, firstName='%s', lastName='%s']&quot;, id, firstName, lastName); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14675</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer1953.java/#L8-L27</td>
    <td align="right">1</td>
    <td align="right">2508</td>
    <td align="right">14675</td>
  </tr>
  <tr valign="top">
    <td align="right">1475</td>
    <td align="left">&nbsp;	{ 		&quot;output&quot;: &quot;YES I found bad smells&quot;, 		&quot;detected_bad_smells&quot;: { 			&quot;the bad smells are&quot;: [ 				&quot;Data Class&quot; 			] 		} 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ItemContent {  	private String defaultName = &quot;&quot;; //$NON-NLS-1$ 	private String displayName = &quot;&quot;; //$NON-NLS-1$ 	private String customName = &quot;&quot;; //$NON-NLS-1$ 	private String description = &quot;&quot;; //$NON-NLS-1$  	public ItemContent( String string ) 	{ 		super( ); 		this.setCustomName( string ); 	}  	/** 	 *  	 * @return Return the default name of ItemContent 	 */ 	public String getDefaultName( ) 	{ 		return defaultName; 	}  	/** 	 *  	 * @return Returns the display name of the ItemContent 	 */ 	public String getDisplayName( ) 	{ 		return displayName; 	}  	/** 	 * Set default name for ItemContent 	 *  	 * @param string 	 */ 	public void setDefaultName( String string ) 	{ 		defaultName = string.trim( ); 	}  	/** 	 * Sets the display name for the ItemContent 	 *  	 * @param string 	 */ 	public void setDisplayName( String string ) 	{ 		displayName = string.trim( ); 	}  	/** 	 *  	 * @return custom name of ItemContent 	 */ 	public String getCustomName( ) 	{ 		return customName; 	}  	/** 	 * Set custom name for ItemContent 	 *  	 * @param string 	 */ 	public void setCustomName( String string ) 	{ 		customName = string.trim( ); 	}  	/** 	 *  	 * @return the description of ItemContent 	 */ 	public String getDescription( ) 	{ 		return description; 	}  	/** 	 * Set the description for ItemContent 	 *  	 * @param string 	 */ 	public void setDescription( String string ) 	{ 		description = string.trim( ); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">the bad smells are: data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">&nbsp; </td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">11062</td>
    <td align="left">https://github.com/eclipse/birt/blob/f89264810347de98702db45386a822aabc0fadbf/UI/org.eclipse.birt.report.designer.ui/src/org/eclipse/birt/report/designer/ui/preferences/ItemContent.java/#L22-L112</td>
    <td align="right">1</td>
    <td align="right">1475</td>
    <td align="right">11062</td>
  </tr>
  <tr valign="top">
    <td align="right">103</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
        static class Event {              final Type type;             final TruffleFile file;             final IOException ioe;             final BasicFileAttributes attrs;              Event(Type type, TruffleFile file, BasicFileAttributes attrs) {                 this.type = type;                 this.file = file;                 this.attrs = attrs;                 this.ioe = null;             }              Event(Type type, TruffleFile file, IOException ioe) {                 this.type = type;                 this.file = file;                 this.attrs = null;                 this.ioe = ioe;             }              enum Type {                 PRE_VISIT_DIRECTORY,                 VISIT,                 POST_VISIT_DIRECTORY             }         }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1357</td>
    <td align="left">https://github.com/oracle/graal/blob/4deb681aaaa79c248115037fc8e399c9876619fd/truffle/src/com.oracle.truffle.api/src/com/oracle/truffle/api/TruffleFile.java/#L1837-L1863</td>
    <td align="right">1</td>
    <td align="right">103</td>
    <td align="right">1357</td>
  </tr>
  <tr valign="top">
    <td align="right">2469</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ChannelTypeXmlResult {      private ChannelType channelType;     private ConfigDescription configDescription;     private boolean system;      public ChannelTypeXmlResult(ChannelType channelType, ConfigDescription configDescription) {         this(channelType, configDescription, false);     }      public ChannelTypeXmlResult(ChannelType channelType, ConfigDescription configDescription, boolean system) {         this.channelType = channelType;         this.configDescription = configDescription;         this.system = system;     }      public ChannelType toChannelType() {         return this.channelType;     }      public ConfigDescription getConfigDescription() {         return this.configDescription;     }      public boolean isSystem() {         return system;     }      @Override     public String toString() {         return &quot;ChannelTypeXmlResult [channelType=&quot; + channelType + &quot;, configDescription=&quot; + configDescription + &quot;]&quot;;     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14574</td>
    <td align="left">https://github.com/eclipse/smarthome/blob/b8455de15d65512e8fac4e94d42de6ab2fccf1c5/bundles/core/org.eclipse.smarthome.core.thing.xml/src/main/java/org/eclipse/smarthome/core/thing/xml/internal/ChannelTypeXmlResult.java/#L28-L61</td>
    <td align="right">1</td>
    <td align="right">2469</td>
    <td align="right">14574</td>
  </tr>
  <tr valign="top">
    <td align="right">2219</td>
    <td align="left">{&quot;message&quot;:&quot;YES, I found bad smells&quot;,&quot;bad smells are&quot;:[&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@javax.annotation.Generated(value=&quot;protoc&quot;, comments=&quot;annotations:TraceInfo.java.pb.meta&quot;) public  final class TraceInfo extends     com.google.protobuf.GeneratedMessageV3 implements     // @@protoc_insertion_point(message_implements:facebook.remote_execution.TraceInfo)     TraceInfoOrBuilder { private static final long serialVersionUID = 0L;   // Use TraceInfo.newBuilder() to construct.   private TraceInfo(com.google.protobuf.GeneratedMessageV3.Builder builder) {     super(builder);   }   private TraceInfo() {     traceId_ = &quot;&quot;;     edgeId_ = &quot;&quot;;   }    @java.lang.Override   public final com.google.protobuf.UnknownFieldSet   getUnknownFields() {     return this.unknownFields;   }   private TraceInfo(       com.google.protobuf.CodedInputStream input,       com.google.protobuf.ExtensionRegistryLite extensionRegistry)       throws com.google.protobuf.InvalidProtocolBufferException {     this();     if (extensionRegistry == null) {       throw new java.lang.NullPointerException();     }     int mutable_bitField0_ = 0;     com.google.protobuf.UnknownFieldSet.Builder unknownFields =         com.google.protobuf.UnknownFieldSet.newBuilder();     try {       boolean done = false;       while (!done) {         int tag = input.readTag();         switch (tag) {           case 0:             done = true;             break;           case 10: {             java.lang.String s = input.readStringRequireUtf8();              traceId_ = s;             break;           }           case 18: {             java.lang.String s = input.readStringRequireUtf8();              edgeId_ = s;             break;           }           default: {             if (!parseUnknownFieldProto3(                 input, unknownFields, extensionRegistry, tag)) {               done = true;             }             break;           }         }       }     } catch (com.google.protobuf.InvalidProtocolBufferException e) {       throw e.setUnfinishedMessage(this);     } catch (java.io.IOException e) {       throw new com.google.protobuf.InvalidProtocolBufferException(           e).setUnfinishedMessage(this);     } finally {       this.unknownFields = unknownFields.build();       makeExtensionsImmutable();     }   }   public static final com.google.protobuf.Descriptors.Descriptor       getDescriptor() {     return com.facebook.buck.remoteexecution.proto.RemoteExecutionMetadataProto.internal_static_facebook_remote_execution_TraceInfo_descriptor;   }    @java.lang.Override   protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable       internalGetFieldAccessorTable() {     return com.facebook.buck.remoteexecution.proto.RemoteExecutionMetadataProto.internal_static_facebook_remote_execution_TraceInfo_fieldAccessorTable         .ensureFieldAccessorsInitialized(             com.facebook.buck.remoteexecution.proto.TraceInfo.class, com.facebook.buck.remoteexecution.proto.TraceInfo.Builder.class);   }    public static final int TRACE_ID_FIELD_NUMBER = 1;   private volatile java.lang.Object traceId_;   /**    *     * ID for all the trace information corresponding to the current session.    *     *    * string trace_id = 1;    */   public java.lang.String getTraceId() {     java.lang.Object ref = traceId_;     if (ref instanceof java.lang.String) {       return (java.lang.String) ref;     } else {       com.google.protobuf.ByteString bs =            (com.google.protobuf.ByteString) ref;       java.lang.String s = bs.toStringUtf8();       traceId_ = s;       return s;     }   }   /**    *     * ID for all the trace information corresponding to the current session.    *     *    * string trace_id = 1;    */   public com.google.protobuf.ByteString       getTraceIdBytes() {     java.lang.Object ref = traceId_;     if (ref instanceof java.lang.String) {       com.google.protobuf.ByteString b =            com.google.protobuf.ByteString.copyFromUtf8(               (java.lang.String) ref);       traceId_ = b;       return b;     } else {       return (com.google.protobuf.ByteString) ref;     }   }    public static final int EDGE_ID_FIELD_NUMBER = 2;   private volatile java.lang.Object edgeId_;   /**    *     * ID of an edge that needs to be closed (ie, added a end point).    *     *    * string edge_id = 2;    */   public java.lang.String getEdgeId() {     java.lang.Object ref = edgeId_;     if (ref instanceof java.lang.String) {       return (java.lang.String) ref;     } else {       com.google.protobuf.ByteString bs =            (com.google.protobuf.ByteString) ref;       java.lang.String s = bs.toStringUtf8();       edgeId_ = s;       return s;     }   }   /**    *     * ID of an edge that needs to be closed (ie, added a end point).    *     *    * string edge_id = 2;    */   public com.google.protobuf.ByteString       getEdgeIdBytes() {     java.lang.Object ref = edgeId_;     if (ref instanceof java.lang.String) {       com.google.protobuf.ByteString b =            com.google.protobuf.ByteString.copyFromUtf8(               (java.lang.String) ref);       edgeId_ = b;       return b;     } else {       return (com.google.protobuf.ByteString) ref;     }   }    private byte memoizedIsInitialized = -1;   @java.lang.Override   public final boolean isInitialized() {     byte isInitialized = memoizedIsInitialized;     if (isInitialized == 1) return true;     if (isInitialized == 0) return false;      memoizedIsInitialized = 1;     return true;   }    @java.lang.Override   public void writeTo(com.google.protobuf.CodedOutputStream output)                       throws java.io.IOException {     if (!getTraceIdBytes().isEmpty()) {       com.google.protobuf.GeneratedMessageV3.writeString(output, 1, traceId_);     }     if (!getEdgeIdBytes().isEmpty()) {       com.google.protobuf.GeneratedMessageV3.writeString(output, 2, edgeId_);     }     unknownFields.writeTo(output);   }    @java.lang.Override   public int getSerializedSize() {     int size = memoizedSize;     if (size != -1) return size;      size = 0;     if (!getTraceIdBytes().isEmpty()) {       size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, traceId_);     }     if (!getEdgeIdBytes().isEmpty()) {       size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, edgeId_);     }     size += unknownFields.getSerializedSize();     memoizedSize = size;     return size;   }    @java.lang.Override   public boolean equals(final java.lang.Object obj) {     if (obj == this) {      return true;     }     if (!(obj instanceof com.facebook.buck.remoteexecution.proto.TraceInfo)) {       return super.equals(obj);     }     com.facebook.buck.remoteexecution.proto.TraceInfo other = (com.facebook.buck.remoteexecution.proto.TraceInfo) obj;      boolean result = true;     result = result &amp;&amp; getTraceId()         .equals(other.getTraceId());     result = result &amp;&amp; getEdgeId()         .equals(other.getEdgeId());     result = result &amp;&amp; unknownFields.equals(other.unknownFields);     return result;   }    @java.lang.Override   public int hashCode() {     if (memoizedHashCode != 0) {       return memoizedHashCode;     }     int hash = 41;     hash = (19 * hash) + getDescriptor().hashCode();     hash = (37 * hash) + TRACE_ID_FIELD_NUMBER;     hash = (53 * hash) + getTraceId().hashCode();     hash = (37 * hash) + EDGE_ID_FIELD_NUMBER;     hash = (53 * hash) + getEdgeId().hashCode();     hash = (29 * hash) + unknownFields.hashCode();     memoizedHashCode = hash;     return hash;   }    public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom(       java.nio.ByteBuffer data)       throws com.google.protobuf.InvalidProtocolBufferException {     return PARSER.parseFrom(data);   }   public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom(       java.nio.ByteBuffer data,       com.google.protobuf.ExtensionRegistryLite extensionRegistry)       throws com.google.protobuf.InvalidProtocolBufferException {     return PARSER.parseFrom(data, extensionRegistry);   }   public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom(       com.google.protobuf.ByteString data)       throws com.google.protobuf.InvalidProtocolBufferException {     return PARSER.parseFrom(data);   }   public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom(       com.google.protobuf.ByteString data,       com.google.protobuf.ExtensionRegistryLite extensionRegistry)       throws com.google.protobuf.InvalidProtocolBufferException {     return PARSER.parseFrom(data, extensionRegistry);   }   public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom(byte[] data)       throws com.google.protobuf.InvalidProtocolBufferException {     return PARSER.parseFrom(data);   }   public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom(       byte[] data,       com.google.protobuf.ExtensionRegistryLite extensionRegistry)       throws com.google.protobuf.InvalidProtocolBufferException {     return PARSER.parseFrom(data, extensionRegistry);   }   public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom(java.io.InputStream input)       throws java.io.IOException {     return com.google.protobuf.GeneratedMessageV3         .parseWithIOException(PARSER, input);   }   public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom(       java.io.InputStream input,       com.google.protobuf.ExtensionRegistryLite extensionRegistry)       throws java.io.IOException {     return com.google.protobuf.GeneratedMessageV3         .parseWithIOException(PARSER, input, extensionRegistry);   }   public static com.facebook.buck.remoteexecution.proto.TraceInfo parseDelimitedFrom(java.io.InputStream input)       throws java.io.IOException {     return com.google.protobuf.GeneratedMessageV3         .parseDelimitedWithIOException(PARSER, input);   }   public static com.facebook.buck.remoteexecution.proto.TraceInfo parseDelimitedFrom(       java.io.InputStream input,       com.google.protobuf.ExtensionRegistryLite extensionRegistry)       throws java.io.IOException {     return com.google.protobuf.GeneratedMessageV3         .parseDelimitedWithIOException(PARSER, input, extensionRegistry);   }   public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom(       com.google.protobuf.CodedInputStream input)       throws java.io.IOException {     return com.google.protobuf.GeneratedMessageV3         .parseWithIOException(PARSER, input);   }   public static com.facebook.buck.remoteexecution.proto.TraceInfo parseFrom(       com.google.protobuf.CodedInputStream input,       com.google.protobuf.ExtensionRegistryLite extensionRegistry)       throws java.io.IOException {     return com.google.protobuf.GeneratedMessageV3         .parseWithIOException(PARSER, input, extensionRegistry);   }    @java.lang.Override   public Builder newBuilderForType() { return newBuilder(); }   public static Builder newBuilder() {     return DEFAULT_INSTANCE.toBuilder();   }   public static Builder newBuilder(com.facebook.buck.remoteexecution.proto.TraceInfo prototype) {     return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);   }   @java.lang.Override   public Builder toBuilder() {     return this == DEFAULT_INSTANCE         ? new Builder() : new Builder().mergeFrom(this);   }    @java.lang.Override   protected Builder newBuilderForType(       com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {     Builder builder = new Builder(parent);     return builder;   }   /**    *     * Contains tracing information.    *     *    * Protobuf type {@code facebook.remote_execution.TraceInfo}    */   public static final class Builder extends       com.google.protobuf.GeneratedMessageV3.Builder implements       // @@protoc_insertion_point(builder_implements:facebook.remote_execution.TraceInfo)       com.facebook.buck.remoteexecution.proto.TraceInfoOrBuilder {     public static final com.google.protobuf.Descriptors.Descriptor         getDescriptor() {       return com.facebook.buck.remoteexecution.proto.RemoteExecutionMetadataProto.internal_static_facebook_remote_execution_TraceInfo_descriptor;     }      @java.lang.Override     protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable         internalGetFieldAccessorTable() {       return com.facebook.buck.remoteexecution.proto.RemoteExecutionMetadataProto.internal_static_facebook_remote_execution_TraceInfo_fieldAccessorTable           .ensureFieldAccessorsInitialized(               com.facebook.buck.remoteexecution.proto.TraceInfo.class, com.facebook.buck.remoteexecution.proto.TraceInfo.Builder.class);     }      // Construct using com.facebook.buck.remoteexecution.proto.TraceInfo.newBuilder()     private Builder() {       maybeForceBuilderInitialization();     }      private Builder(         com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {       super(parent);       maybeForceBuilderInitialization();     }     private void maybeForceBuilderInitialization() {       if (com.google.protobuf.GeneratedMessageV3               .alwaysUseFieldBuilders) {       }     }     @java.lang.Override     public Builder clear() {       super.clear();       traceId_ = &quot;&quot;;        edgeId_ = &quot;&quot;;        return this;     }      @java.lang.Override     public com.google.protobuf.Descriptors.Descriptor         getDescriptorForType() {       return com.facebook.buck.remoteexecution.proto.RemoteExecutionMetadataProto.internal_static_facebook_remote_execution_TraceInfo_descriptor;     }      @java.lang.Override     public com.facebook.buck.remoteexecution.proto.TraceInfo getDefaultInstanceForType() {       return com.facebook.buck.remoteexecution.proto.TraceInfo.getDefaultInstance();     }      @java.lang.Override     public com.facebook.buck.remoteexecution.proto.TraceInfo build() {       com.facebook.buck.remoteexecution.proto.TraceInfo result = buildPartial();       if (!result.isInitialized()) {         throw newUninitializedMessageException(result);       }       return result;     }      @java.lang.Override     public com.facebook.buck.remoteexecution.proto.TraceInfo buildPartial() {       com.facebook.buck.remoteexecution.proto.TraceInfo result = new com.facebook.buck.remoteexecution.proto.TraceInfo(this);       result.traceId_ = traceId_;       result.edgeId_ = edgeId_;       onBuilt();       return result;     }      @java.lang.Override     public Builder clone() {       return (Builder) super.clone();     }     @java.lang.Override     public Builder setField(         com.google.protobuf.Descriptors.FieldDescriptor field,         java.lang.Object value) {       return (Builder) super.setField(field, value);     }     @java.lang.Override     public Builder clearField(         com.google.protobuf.Descriptors.FieldDescriptor field) {       return (Builder) super.clearField(field);     }     @java.lang.Override     public Builder clearOneof(         com.google.protobuf.Descriptors.OneofDescriptor oneof) {       return (Builder) super.clearOneof(oneof);     }     @java.lang.Override     public Builder setRepeatedField(         com.google.protobuf.Descriptors.FieldDescriptor field,         int index, java.lang.Object value) {       return (Builder) super.setRepeatedField(field, index, value);     }     @java.lang.Override     public Builder addRepeatedField(         com.google.protobuf.Descriptors.FieldDescriptor field,         java.lang.Object value) {       return (Builder) super.addRepeatedField(field, value);     }     @java.lang.Override     public Builder mergeFrom(com.google.protobuf.Message other) {       if (other instanceof com.facebook.buck.remoteexecution.proto.TraceInfo) {         return mergeFrom((com.facebook.buck.remoteexecution.proto.TraceInfo)other);       } else {         super.mergeFrom(other);         return this;       }     }      public Builder mergeFrom(com.facebook.buck.remoteexecution.proto.TraceInfo other) {       if (other == com.facebook.buck.remoteexecution.proto.TraceInfo.getDefaultInstance()) return this;       if (!other.getTraceId().isEmpty()) {         traceId_ = other.traceId_;         onChanged();       }       if (!other.getEdgeId().isEmpty()) {         edgeId_ = other.edgeId_;         onChanged();       }       this.mergeUnknownFields(other.unknownFields);       onChanged();       return this;     }      @java.lang.Override     public final boolean isInitialized() {       return true;     }      @java.lang.Override     public Builder mergeFrom(         com.google.protobuf.CodedInputStream input,         com.google.protobuf.ExtensionRegistryLite extensionRegistry)         throws java.io.IOException {       com.facebook.buck.remoteexecution.proto.TraceInfo parsedMessage = null;       try {         parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);       } catch (com.google.protobuf.InvalidProtocolBufferException e) {         parsedMessage = (com.facebook.buck.remoteexecution.proto.TraceInfo) e.getUnfinishedMessage();         throw e.unwrapIOException();       } finally {         if (parsedMessage != null) {           mergeFrom(parsedMessage);         }       }       return this;     }      private java.lang.Object traceId_ = &quot;&quot;;     /**      *       * ID for all the trace information corresponding to the current session.      *       *      * string trace_id = 1;      */     public java.lang.String getTraceId() {       java.lang.Object ref = traceId_;       if (!(ref instanceof java.lang.String)) {         com.google.protobuf.ByteString bs =             (com.google.protobuf.ByteString) ref;         java.lang.String s = bs.toStringUtf8();         traceId_ = s;         return s;       } else {         return (java.lang.String) ref;       }     }     /**      *       * ID for all the trace information corresponding to the current session.      *       *      * string trace_id = 1;      */     public com.google.protobuf.ByteString         getTraceIdBytes() {       java.lang.Object ref = traceId_;       if (ref instanceof String) {         com.google.protobuf.ByteString b =              com.google.protobuf.ByteString.copyFromUtf8(                 (java.lang.String) ref);         traceId_ = b;         return b;       } else {         return (com.google.protobuf.ByteString) ref;       }     }     /**      *       * ID for all the trace information corresponding to the current session.      *       *      * string trace_id = 1;      */     public Builder setTraceId(         java.lang.String value) {       if (value == null) {     throw new NullPointerException();   }          traceId_ = value;       onChanged();       return this;     }     /**      *       * ID for all the trace information corresponding to the current session.      *       *      * string trace_id = 1;      */     public Builder clearTraceId() {              traceId_ = getDefaultInstance().getTraceId();       onChanged();       return this;     }     /**      *       * ID for all the trace information corresponding to the current session.      *       *      * string trace_id = 1;      */     public Builder setTraceIdBytes(         com.google.protobuf.ByteString value) {       if (value == null) {     throw new NullPointerException();   }   checkByteStringIsUtf8(value);              traceId_ = value;       onChanged();       return this;     }      private java.lang.Object edgeId_ = &quot;&quot;;     /**      *       * ID of an edge that needs to be closed (ie, added a end point).      *       *      * string edge_id = 2;      */     public java.lang.String getEdgeId() {       java.lang.Object ref = edgeId_;       if (!(ref instanceof java.lang.String)) {         com.google.protobuf.ByteString bs =             (com.google.protobuf.ByteString) ref;         java.lang.String s = bs.toStringUtf8();         edgeId_ = s;         return s;       } else {         return (java.lang.String) ref;       }     }     /**      *       * ID of an edge that needs to be closed (ie, added a end point).      *       *      * string edge_id = 2;      */     public com.google.protobuf.ByteString         getEdgeIdBytes() {       java.lang.Object ref = edgeId_;       if (ref instanceof String) {         com.google.protobuf.ByteString b =              com.google.protobuf.ByteString.copyFromUtf8(                 (java.lang.String) ref);         edgeId_ = b;         return b;       } else {         return (com.google.protobuf.ByteString) ref;       }     }     /**      *       * ID of an edge that needs to be closed (ie, added a end point).      *       *      * string edge_id = 2;      */     public Builder setEdgeId(         java.lang.String value) {       if (value == null) {     throw new NullPointerException();   }          edgeId_ = value;       onChanged();       return this;     }     /**      *       * ID of an edge that needs to be closed (ie, added a end point).      *       *      * string edge_id = 2;      */     public Builder clearEdgeId() {              edgeId_ = getDefaultInstance().getEdgeId();       onChanged();       return this;     }     /**      *       * ID of an edge that needs to be closed (ie, added a end point).      *       *      * string edge_id = 2;      */     public Builder setEdgeIdBytes(         com.google.protobuf.ByteString value) {       if (value == null) {     throw new NullPointerException();   }   checkByteStringIsUtf8(value);              edgeId_ = value;       onChanged();       return this;     }     @java.lang.Override     public final Builder setUnknownFields(         final com.google.protobuf.UnknownFieldSet unknownFields) {       return super.setUnknownFieldsProto3(unknownFields);     }      @java.lang.Override     public final Builder mergeUnknownFields(         final com.google.protobuf.UnknownFieldSet unknownFields) {       return super.mergeUnknownFields(unknownFields);     }       // @@protoc_insertion_point(builder_scope:facebook.remote_execution.TraceInfo)   }    // @@protoc_insertion_point(class_scope:facebook.remote_execution.TraceInfo)   private static final com.facebook.buck.remoteexecution.proto.TraceInfo DEFAULT_INSTANCE;   static {     DEFAULT_INSTANCE = new com.facebook.buck.remoteexecution.proto.TraceInfo();   }    public static com.facebook.buck.remoteexecution.proto.TraceInfo getDefaultInstance() {     return DEFAULT_INSTANCE;   }    private static final com.google.protobuf.Parser       PARSER = new com.google.protobuf.AbstractParser() {     @java.lang.Override     public TraceInfo parsePartialFrom(         com.google.protobuf.CodedInputStream input,         com.google.protobuf.ExtensionRegistryLite extensionRegistry)         throws com.google.protobuf.InvalidProtocolBufferException {       return new TraceInfo(input, extensionRegistry);     }   };    public static com.google.protobuf.Parser parser() {     return PARSER;   }    @java.lang.Override   public com.google.protobuf.Parser getParserForType() {     return PARSER;   }    @java.lang.Override   public com.facebook.buck.remoteexecution.proto.TraceInfo getDefaultInstanceForType() {     return DEFAULT_INSTANCE;   }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13545</td>
    <td align="left">https://github.com/facebook/buck/blob/1bc8d383ea5cb153ca9bf4f2807e6be498648523/src-gen/com/facebook/buck/remoteexecution/proto/TraceInfo.java/#L14-L733</td>
    <td align="right">1</td>
    <td align="right">2219</td>
    <td align="right">13545</td>
  </tr>
  <tr valign="top">
    <td align="right">815</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES, I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class KerningRecord implements IDataType {     private int code1;     private int code2;     private int adjustment;      /**      * @return the code1      */     public int getCode1()     {         return code1;     }      /**      * @param code1 the code1 to set      */     public void setCode1(int code1)     {         this.code1 = code1;     }      /**      * @return the code2      */     public int getCode2()     {         return code2;     }      /**      * @param code2 the code2 to set      */     public void setCode2(int code2)     {         this.code2 = code2;     }      /**      * @return the adjustment      */     public int getAdjustment()     {         return adjustment;     }      /**      * @param adjustment the adjustment to set      */     public void setAdjustment(int adjustment)     {         this.adjustment = adjustment;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7659</td>
    <td align="left">https://github.com/apache/royale-compiler/blob/fbd9bc3b9e48c80dbd8c1d32a6f83221e314efdd/compiler/src/main/java/org/apache/royale/swf/types/KerningRecord.java/#L30-L83</td>
    <td align="right">1</td>
    <td align="right">815</td>
    <td align="right">7659</td>
  </tr>
  <tr valign="top">
    <td align="right">2628</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
		public Action getBinaryBitwiseExpressionLhsAction_1_0_0_0() { return cBinaryBitwiseExpressionLhsAction_1_0_0_0; } 		 		//op=BitwiseOROperator 		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; } 		 		//BitwiseOROperator 		public RuleCall getOpBitwiseOROperatorParserRuleCall_1_0_0_1_0() { return cOpBitwiseOROperatorParserRuleCall_1_0_0_1_0; } 		 		//rhs=BitwiseXORExpression 		public Assignment getRhsAssignment_1_1() { return cRhsAssignment_1_1; } 		 		//BitwiseXORExpression 		public RuleCall getRhsBitwiseXORExpressionParserRuleCall_1_1_0() { return cRhsBitwiseXORExpressionParserRuleCall_1_1_0; } 	} 	public class BitwiseOROperatorElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.n4js.N4JS.BitwiseOROperator&quot;); 		private final Keyword cVerticalLineKeyword = (Keyword)rule.eContents().get(1); 		 		//BitwiseOROperator BinaryBitwiseOperator: 		//	'|'; 		@Override public ParserRule getRule() { return rule; } 		 		//'|' 		public Keyword getVerticalLineKeyword() { return cVerticalLineKeyword; } 	} 	public class LogicalANDExpressionElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.n4js.N4JS.LogicalANDExpression&quot;); 		private final Group cGroup = (Group)rule.eContents().get(1); 		private final RuleCall cBitwiseORExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0); 		private final Group cGroup_1 = (Group)cGroup.eContents().get(1); 		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0); 		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0); 		private final Action cBinaryLogicalExpressionLhsAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0); 		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1); 		private final RuleCall cOpLogicalANDOperatorParserRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0); 		private final Assignment cRhsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1); 		private final RuleCall cRhsBitwiseORExpressionParserRuleCall_1_1_0 = (RuleCall)cRhsAssignment_1_1.eContents().get(0); 		 		//// $ (=&gt; ({BinaryLogicalExpression.lhs=current} op=LogicalANDOperator) 		//	rhs=BitwiseORExpression)*; 		@Override public ParserRule getRule() { return rule; } 		 		//BitwiseORExpression (=&gt; ({BinaryLogicalExpression.lhs=current} op=LogicalANDOperator) 		//rhs=BitwiseORExpression)* 		public Group getGroup() { return cGroup; } 		 		//BitwiseORExpression 		public RuleCall getBitwiseORExpressionParserRuleCall_0() { return cBitwiseORExpressionParserRuleCall_0; } 		</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15087</td>
    <td align="left">https://github.com/eclipse/n4js/blob/f715912fce0352ab574ff878086f77d17a78c908/plugins/org.eclipse.n4js/src-gen/org/eclipse/n4js/services/N4JSGrammarAccess.java/#L6096-L6144</td>
    <td align="right">1</td>
    <td align="right">2628</td>
    <td align="right">15087</td>
  </tr>
  <tr valign="top">
    <td align="right">2360</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }   </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity @Table(name = &quot;ESPM_SUPPLIER&quot;) @NamedQueries({ 	@NamedQuery(name = &quot;Supplier.getAllSuppliers&quot;, query = &quot;SELECT s FROM Supplier s&quot;), 	@NamedQuery(name = &quot;Supplier.getSupplierBySupplierId&quot;, query = &quot;SELECT s FROM Supplier s WHERE s.supplierId= :supplierId&quot;) }) public class Supplier { 	/* Supplier ids are generated within a number range starting with 2 */ 	@TableGenerator(name = &quot;SupplierGenerator&quot;, table = &quot;ESPM_ID_GENERATOR&quot;, pkColumnName = &quot;GENERATOR_NAME&quot;, valueColumnName = &quot;GENERATOR_VALUE&quot;, pkColumnValue = &quot;Customer&quot;, initialValue = 100000000, allocationSize = 100) 	@Id 	@GeneratedValue(strategy = GenerationType.TABLE, generator = &quot;SupplierGenerator&quot;) 	@Column(name = &quot;SUPPLIER_ID&quot;, length = 10) 	private String supplierId;  	@Column(name = &quot;EMAIL_ADDRESS&quot;, unique = true) 	private String emailAddress;  	@Column(name = &quot;PHONE_NUMBER&quot;, length = 30) 	private String phoneNumber;  	@Column(name = &quot;CITY&quot;, length = 40) 	private String city;  	@Column(name = &quot;POSTAL_CODE&quot;, length = 10) 	private String postalCode;  	@Column(name = &quot;STREET&quot;, length = 60) 	private String street;  	@Column(name = &quot;HOUSE_NUMBER&quot;, length = 10) 	private String houseNumber;  	@Column(name = &quot;COUNTRY&quot;, length = 3) 	private String country;  	@Column(name = &quot;SUPPLIER_NAME&quot;, length = 80) 	private String supplierName;  	public String getSupplierId() { 		return supplierId; 	}  	public void setSupplierId(String id) { 		this.supplierId = id; 	}  	public void setEmailAddress(String param) { 		this.emailAddress = param; 	}  	public String getEmailAddress() { 		return emailAddress; 	}  	public void setPhoneNumber(String param) { 		this.phoneNumber = param; 	}  	public String getPhoneNumber() { 		return phoneNumber; 	}  	public void setCity(String param) { 		this.city = param; 	}  	public String getCity() { 		return city; 	}  	public void setPostalCode(String param) { 		this.postalCode = param; 	}  	public String getPostalCode() { 		return postalCode; 	}  	public void setStreet(String param) { 		this.street = param; 	}  	public String getStreet() { 		return street; 	}  	public void setHouseNumber(String param) { 		this.houseNumber = param; 	}  	public String getHouseNumber() { 		return houseNumber; 	}  	public void setCountry(String param) { 		this.country = param; 	}  	public String getCountry() { 		return country; 	}  	public void setSupplierName(String param) { 		this.supplierName = param; 	}  	public String getSupplierName() { 		return supplierName; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14236</td>
    <td align="left">https://github.com/SAP/cloud-espm-v2/blob/a5254f2e6fea9b7226296fbe19eb30ab99192b8d/espm-cloud-jpa/src/main/java/com/sap/espm/model/Supplier.java/#L13-L123</td>
    <td align="right">1</td>
    <td align="right">2360</td>
    <td align="right">14236</td>
  </tr>
  <tr valign="top">
    <td align="right">399</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{       &quot;output&quot;: &quot;YES I found bad smells&quot;,       &quot;detected_bad_smells&quot;: [          &quot;Data Class&quot;,          &quot;Long Method&quot;       ]    } </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface XtypePackage extends EPackage { 	/** 	 * The package name. 	 *  	 *  	 * @generated 	 */ 	String eNAME = &quot;xtype&quot;;  	/** 	 * The package namespace URI. 	 *  	 *  	 * @generated 	 */ 	String eNS_URI = &quot;http://www.eclipse.org/xtext/xbase/Xtype&quot;;  	/** 	 * The package namespace name. 	 *  	 *  	 * @generated 	 */ 	String eNS_PREFIX = &quot;xtype&quot;;  	/** 	 * The singleton instance of the package. 	 *  	 *  	 * @generated 	 */ 	XtypePackage eINSTANCE = org.eclipse.xtext.xtype.impl.XtypePackageImpl.init();  	/** 	 * The meta object id for the '{@link org.eclipse.xtext.xtype.impl.XFunctionTypeRefImpl XFunction Type Ref}' class. 	 *  	 *  	 * @see org.eclipse.xtext.xtype.impl.XFunctionTypeRefImpl 	 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXFunctionTypeRef() 	 * @generated 	 */ 	int XFUNCTION_TYPE_REF = 0;  	/** 	 * The feature id for the 'Equivalent' containment reference. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XFUNCTION_TYPE_REF__EQUIVALENT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE__EQUIVALENT;  	/** 	 * The feature id for the 'Param Types' containment reference list. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XFUNCTION_TYPE_REF__PARAM_TYPES = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 0;  	/** 	 * The feature id for the 'Return Type' containment reference. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XFUNCTION_TYPE_REF__RETURN_TYPE = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 1;  	/** 	 * The feature id for the 'Type' reference. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XFUNCTION_TYPE_REF__TYPE = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 2;  	/** 	 * The feature id for the 'Instance Context' attribute. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XFUNCTION_TYPE_REF__INSTANCE_CONTEXT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 3;  	/** 	 * The number of structural features of the 'XFunction Type Ref' class. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XFUNCTION_TYPE_REF_FEATURE_COUNT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 4;  	/** 	 * The meta object id for the '{@link org.eclipse.xtext.xtype.impl.XComputedTypeReferenceImpl XComputed Type Reference}' class. 	 *  	 *  	 * @see org.eclipse.xtext.xtype.impl.XComputedTypeReferenceImpl 	 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXComputedTypeReference() 	 * @generated 	 */ 	int XCOMPUTED_TYPE_REFERENCE = 1;  	/** 	 * The feature id for the 'Equivalent' containment reference. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XCOMPUTED_TYPE_REFERENCE__EQUIVALENT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE__EQUIVALENT;  	/** 	 * The feature id for the 'Type Provider' attribute. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XCOMPUTED_TYPE_REFERENCE__TYPE_PROVIDER = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 0;  	/** 	 * The number of structural features of the 'XComputed Type Reference' class. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XCOMPUTED_TYPE_REFERENCE_FEATURE_COUNT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 1;  	/** 	 * The meta object id for the '{@link org.eclipse.xtext.xtype.impl.XImportSectionImpl XImport Section}' class. 	 *  	 *  	 * @see org.eclipse.xtext.xtype.impl.XImportSectionImpl 	 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXImportSection() 	 * @generated 	 */ 	int XIMPORT_SECTION = 2;  	/** 	 * The feature id for the 'Import Declarations' containment reference list. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XIMPORT_SECTION__IMPORT_DECLARATIONS = 0;  	/** 	 * The number of structural features of the 'XImport Section' class. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XIMPORT_SECTION_FEATURE_COUNT = 1;  	/** 	 * The meta object id for the '{@link org.eclipse.xtext.xtype.impl.XImportDeclarationImpl XImport Declaration}' class. 	 *  	 *  	 * @see org.eclipse.xtext.xtype.impl.XImportDeclarationImpl 	 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXImportDeclaration() 	 * @generated 	 */ 	int XIMPORT_DECLARATION = 3;  	/** 	 * The feature id for the 'Wildcard' attribute. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XIMPORT_DECLARATION__WILDCARD = 0;  	/** 	 * The feature id for the 'Extension' attribute. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XIMPORT_DECLARATION__EXTENSION = 1;  	/** 	 * The feature id for the 'Static' attribute. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XIMPORT_DECLARATION__STATIC = 2;  	/** 	 * The feature id for the 'Imported Type' reference. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XIMPORT_DECLARATION__IMPORTED_TYPE = 3;  	/** 	 * The feature id for the 'Member Name' attribute. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XIMPORT_DECLARATION__MEMBER_NAME = 4;  	/** 	 * The feature id for the 'Imported Namespace' attribute. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XIMPORT_DECLARATION__IMPORTED_NAMESPACE = 5;  	/** 	 * The number of structural features of the 'XImport Declaration' class. 	 *  	 *  	 * @generated 	 * @ordered 	 */ 	int XIMPORT_DECLARATION_FEATURE_COUNT = 6;  	/** 	 * The meta object id for the 'IJvm Type Reference Provider' data type. 	 *  	 *  	 * @see org.eclipse.xtext.xbase.typing.IJvmTypeReferenceProvider 	 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getIJvmTypeReferenceProvider() 	 * @generated 	 */ 	int IJVM_TYPE_REFERENCE_PROVIDER = 4;   	/** 	 * Returns the meta object for class '{@link org.eclipse.xtext.xtype.XFunctionTypeRef XFunction Type Ref}'. 	 *  	 *  	 * @return the meta object for class 'XFunction Type Ref'. 	 * @see org.eclipse.xtext.xtype.XFunctionTypeRef 	 * @generated 	 */ 	EClass getXFunctionTypeRef();  	/** 	 * Returns the meta object for the containment reference list '{@link org.eclipse.xtext.xtype.XFunctionTypeRef#getParamTypes Param Types}'. 	 *  	 *  	 * @return the meta object for the containment reference list 'Param Types'. 	 * @see org.eclipse.xtext.xtype.XFunctionTypeRef#getParamTypes() 	 * @see #getXFunctionTypeRef() 	 * @generated 	 */ 	EReference getXFunctionTypeRef_ParamTypes();  	/** 	 * Returns the meta object for the containment reference '{@link org.eclipse.xtext.xtype.XFunctionTypeRef#getReturnType Return Type}'. 	 *  	 *  	 * @return the meta object for the containment reference 'Return Type'. 	 * @see org.eclipse.xtext.xtype.XFunctionTypeRef#getReturnType() 	 * @see #getXFunctionTypeRef() 	 * @generated 	 */ 	EReference getXFunctionTypeRef_ReturnType();  	/** 	 * Returns the meta object for the reference '{@link org.eclipse.xtext.xtype.XFunctionTypeRef#getType Type}'. 	 *  	 *  	 * @return the meta object for the reference 'Type'. 	 * @see org.eclipse.xtext.xtype.XFunctionTypeRef#getType() 	 * @see #getXFunctionTypeRef() 	 * @generated 	 */ 	EReference getXFunctionTypeRef_Type();  	/** 	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XFunctionTypeRef#isInstanceContext Instance Context}'. 	 *  	 *  	 * @return the meta object for the attribute 'Instance Context'. 	 * @see org.eclipse.xtext.xtype.XFunctionTypeRef#isInstanceContext() 	 * @see #getXFunctionTypeRef() 	 * @generated 	 */ 	EAttribute getXFunctionTypeRef_InstanceContext();  	/** 	 * Returns the meta object for class '{@link org.eclipse.xtext.xtype.XComputedTypeReference XComputed Type Reference}'. 	 *  	 *  	 * @return the meta object for class 'XComputed Type Reference'. 	 * @see org.eclipse.xtext.xtype.XComputedTypeReference 	 * @generated 	 */ 	EClass getXComputedTypeReference();  	/** 	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XComputedTypeReference#getTypeProvider Type Provider}'. 	 *  	 *  	 * @return the meta object for the attribute 'Type Provider'. 	 * @see org.eclipse.xtext.xtype.XComputedTypeReference#getTypeProvider() 	 * @see #getXComputedTypeReference() 	 * @generated 	 */ 	EAttribute getXComputedTypeReference_TypeProvider();  	/** 	 * Returns the meta object for class '{@link org.eclipse.xtext.xtype.XImportSection XImport Section}'. 	 *  	 *  	 * @return the meta object for class 'XImport Section'. 	 * @see org.eclipse.xtext.xtype.XImportSection 	 * @generated 	 */ 	EClass getXImportSection();  	/** 	 * Returns the meta object for the containment reference list '{@link org.eclipse.xtext.xtype.XImportSection#getImportDeclarations Import Declarations}'. 	 *  	 *  	 * @return the meta object for the containment reference list 'Import Declarations'. 	 * @see org.eclipse.xtext.xtype.XImportSection#getImportDeclarations() 	 * @see #getXImportSection() 	 * @generated 	 */ 	EReference getXImportSection_ImportDeclarations();  	/** 	 * Returns the meta object for class '{@link org.eclipse.xtext.xtype.XImportDeclaration XImport Declaration}'. 	 *  	 *  	 * @return the meta object for class 'XImport Declaration'. 	 * @see org.eclipse.xtext.xtype.XImportDeclaration 	 * @generated 	 */ 	EClass getXImportDeclaration();  	/** 	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XImportDeclaration#isWildcard Wildcard}'. 	 *  	 *  	 * @return the meta object for the attribute 'Wildcard'. 	 * @see org.eclipse.xtext.xtype.XImportDeclaration#isWildcard() 	 * @see #getXImportDeclaration() 	 * @generated 	 */ 	EAttribute getXImportDeclaration_Wildcard();  	/** 	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XImportDeclaration#isExtension Extension}'. 	 *  	 *  	 * @return the meta object for the attribute 'Extension'. 	 * @see org.eclipse.xtext.xtype.XImportDeclaration#isExtension() 	 * @see #getXImportDeclaration() 	 * @generated 	 */ 	EAttribute getXImportDeclaration_Extension();  	/** 	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XImportDeclaration#isStatic Static}'. 	 *  	 *  	 * @return the meta object for the attribute 'Static'. 	 * @see org.eclipse.xtext.xtype.XImportDeclaration#isStatic() 	 * @see #getXImportDeclaration() 	 * @generated 	 */ 	EAttribute getXImportDeclaration_Static();  	/** 	 * Returns the meta object for the reference '{@link org.eclipse.xtext.xtype.XImportDeclaration#getImportedType Imported Type}'. 	 *  	 *  	 * @return the meta object for the reference 'Imported Type'. 	 * @see org.eclipse.xtext.xtype.XImportDeclaration#getImportedType() 	 * @see #getXImportDeclaration() 	 * @generated 	 */ 	EReference getXImportDeclaration_ImportedType();  	/** 	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XImportDeclaration#getMemberName Member Name}'. 	 *  	 *  	 * @return the meta object for the attribute 'Member Name'. 	 * @see org.eclipse.xtext.xtype.XImportDeclaration#getMemberName() 	 * @see #getXImportDeclaration() 	 * @generated 	 */ 	EAttribute getXImportDeclaration_MemberName();  	/** 	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XImportDeclaration#getImportedNamespace Imported Namespace}'. 	 *  	 *  	 * @return the meta object for the attribute 'Imported Namespace'. 	 * @see org.eclipse.xtext.xtype.XImportDeclaration#getImportedNamespace() 	 * @see #getXImportDeclaration() 	 * @generated 	 */ 	EAttribute getXImportDeclaration_ImportedNamespace();  	/** 	 * Returns the meta object for data type '{@link org.eclipse.xtext.xbase.typing.IJvmTypeReferenceProvider IJvm Type Reference Provider}'. 	 *  	 *  	 * @return the meta object for data type 'IJvm Type Reference Provider'. 	 * @see org.eclipse.xtext.xbase.typing.IJvmTypeReferenceProvider 	 * @model instanceClass=&quot;org.eclipse.xtext.xbase.typing.IJvmTypeReferenceProvider&quot; serializeable=&quot;false&quot; 	 * @generated 	 */ 	EDataType getIJvmTypeReferenceProvider();  	/** 	 * Returns the factory that creates the instances of the model. 	 *  	 *  	 * @return the factory that creates the instances of the model. 	 * @generated 	 */ 	XtypeFactory getXtypeFactory();  	/** 	 *  	 * Defines literals for the meta objects that represent 	 *  	 *   each class, 	 *   each feature of each class, 	 *   each enum, 	 *   and each data type 	 *  	 *  	 * @generated 	 */ 	interface Literals 	{ 		/** 		 * The meta object literal for the '{@link org.eclipse.xtext.xtype.impl.XFunctionTypeRefImpl XFunction Type Ref}' class. 		 *  		 *  		 * @see org.eclipse.xtext.xtype.impl.XFunctionTypeRefImpl 		 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXFunctionTypeRef() 		 * @generated 		 */ 		EClass XFUNCTION_TYPE_REF = eINSTANCE.getXFunctionTypeRef();  		/** 		 * The meta object literal for the 'Param Types' containment reference list feature. 		 *  		 *  		 * @generated 		 */ 		EReference XFUNCTION_TYPE_REF__PARAM_TYPES = eINSTANCE.getXFunctionTypeRef_ParamTypes();  		/** 		 * The meta object literal for the 'Return Type' containment reference feature. 		 *  		 *  		 * @generated 		 */ 		EReference XFUNCTION_TYPE_REF__RETURN_TYPE = eINSTANCE.getXFunctionTypeRef_ReturnType();  		/** 		 * The meta object literal for the 'Type' reference feature. 		 *  		 *  		 * @generated 		 */ 		EReference XFUNCTION_TYPE_REF__TYPE = eINSTANCE.getXFunctionTypeRef_Type();  		/** 		 * The meta object literal for the 'Instance Context' attribute feature. 		 *  		 *  		 * @generated 		 */ 		EAttribute XFUNCTION_TYPE_REF__INSTANCE_CONTEXT = eINSTANCE.getXFunctionTypeRef_InstanceContext();  		/** 		 * The meta object literal for the '{@link org.eclipse.xtext.xtype.impl.XComputedTypeReferenceImpl XComputed Type Reference}' class. 		 *  		 *  		 * @see org.eclipse.xtext.xtype.impl.XComputedTypeReferenceImpl 		 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXComputedTypeReference() 		 * @generated 		 */ 		EClass XCOMPUTED_TYPE_REFERENCE = eINSTANCE.getXComputedTypeReference();  		/** 		 * The meta object literal for the 'Type Provider' attribute feature. 		 *  		 *  		 * @generated 		 */ 		EAttribute XCOMPUTED_TYPE_REFERENCE__TYPE_PROVIDER = eINSTANCE.getXComputedTypeReference_TypeProvider();  		/** 		 * The meta object literal for the '{@link org.eclipse.xtext.xtype.impl.XImportSectionImpl XImport Section}' class. 		 *  		 *  		 * @see org.eclipse.xtext.xtype.impl.XImportSectionImpl 		 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXImportSection() 		 * @generated 		 */ 		EClass XIMPORT_SECTION = eINSTANCE.getXImportSection();  		/** 		 * The meta object literal for the 'Import Declarations' containment reference list feature. 		 *  		 *  		 * @generated 		 */ 		EReference XIMPORT_SECTION__IMPORT_DECLARATIONS = eINSTANCE.getXImportSection_ImportDeclarations();  		/** 		 * The meta object literal for the '{@link org.eclipse.xtext.xtype.impl.XImportDeclarationImpl XImport Declaration}' class. 		 *  		 *  		 * @see org.eclipse.xtext.xtype.impl.XImportDeclarationImpl 		 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXImportDeclaration() 		 * @generated 		 */ 		EClass XIMPORT_DECLARATION = eINSTANCE.getXImportDeclaration();  		/** 		 * The meta object literal for the 'Wildcard' attribute feature. 		 *  		 *  		 * @generated 		 */ 		EAttribute XIMPORT_DECLARATION__WILDCARD = eINSTANCE.getXImportDeclaration_Wildcard();  		/** 		 * The meta object literal for the 'Extension' attribute feature. 		 *  		 *  		 * @generated 		 */ 		EAttribute XIMPORT_DECLARATION__EXTENSION = eINSTANCE.getXImportDeclaration_Extension();  		/** 		 * The meta object literal for the 'Static' attribute feature. 		 *  		 *  		 * @generated 		 */ 		EAttribute XIMPORT_DECLARATION__STATIC = eINSTANCE.getXImportDeclaration_Static();  		/** 		 * The meta object literal for the 'Imported Type' reference feature. 		 *  		 *  		 * @generated 		 */ 		EReference XIMPORT_DECLARATION__IMPORTED_TYPE = eINSTANCE.getXImportDeclaration_ImportedType();  		/** 		 * The meta object literal for the 'Member Name' attribute feature. 		 *  		 *  		 * @generated 		 */ 		EAttribute XIMPORT_DECLARATION__MEMBER_NAME = eINSTANCE.getXImportDeclaration_MemberName();  		/** 		 * The meta object literal for the 'Imported Namespace' attribute feature. 		 *  		 *  		 * @generated 		 */ 		EAttribute XIMPORT_DECLARATION__IMPORTED_NAMESPACE = eINSTANCE.getXImportDeclaration_ImportedNamespace();  		/** 		 * The meta object literal for the 'IJvm Type Reference Provider' data type. 		 *  		 *  		 * @see org.eclipse.xtext.xbase.typing.IJvmTypeReferenceProvider 		 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getIJvmTypeReferenceProvider() 		 * @generated 		 */ 		EDataType IJVM_TYPE_REFERENCE_PROVIDER = eINSTANCE.getIJvmTypeReferenceProvider();  	}  } //XtypePackage</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4069</td>
    <td align="left">https://github.com/eclipse/xtext-extras/blob/5634c291880cd46fe2f8e9a47e48ef88b85e8bda/org.eclipse.xtext.xbase/emf-gen/org/eclipse/xtext/xtype/XtypePackage.java/#L38-L639</td>
    <td align="right">1</td>
    <td align="right">399</td>
    <td align="right">4069</td>
  </tr>
  <tr valign="top">
    <td align="right">890</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;3. Long Method&quot;, &quot;4. Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@InterfaceAudience.Public @InterfaceStability.Evolving public class MetricsTag implements MetricsInfo {   private final MetricsInfo info;   private final String value;    /**    * Construct the tag with name, description and value    * @param info  of the tag    * @param value of the tag    */   public MetricsTag(MetricsInfo info, String value) {     this.info = checkNotNull(info, &quot;tag info&quot;);     this.value = value;   }    @Override public String name() {     return info.name();   }    @Override public String description() {     return info.description();   }    /**    * @return the info object of the tag    */   public MetricsInfo info() {     return info;   }    /**    * Get the value of the tag    * @return  the value    */   public String value() {     return value;   }    @Override public boolean equals(Object obj) {     if (obj instanceof MetricsTag) {       final MetricsTag other = (MetricsTag) obj;       return Objects.equal(info, other.info()) &amp;&amp;              Objects.equal(value, other.value());     }     return false;   }    @Override public int hashCode() {     return Objects.hashCode(info, value);   }    @Override public String toString() {     return Objects.toStringHelper(this)         .add(&quot;info&quot;, info)         .add(&quot;value&quot;, value())         .toString();   } }</td>
    <td align="left">data class</td>
    <td align="left">3. long method, 4. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">3. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8082</td>
    <td align="left">https://github.com/apache/hadoop-common/blob/42a61a4fbc88303913c4681f0d40ffcc737e70b5/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/metrics2/MetricsTag.java/#L30-L88</td>
    <td align="right">1</td>
    <td align="right">890</td>
    <td align="right">8082</td>
  </tr>
  <tr valign="top">
    <td align="right">1793</td>
    <td align="left">&nbsp;	{ 		&quot;message&quot;: &quot;YES I found bad smells&quot;, 		&quot;bad smells are&quot;: [ 			&quot;Data Class&quot;, 			&quot;Long Method&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MqttConnectionState {  	// ******* Connection properties ******// 	private Integer receiveMaximum = 65535; 	private Integer maximumQoS = 2; 	private Boolean retainAvailable = true; 	private Long outgoingMaximumPacketSize = null; 	private Long incomingMaximumPacketSize = null; 	private Integer outgoingTopicAliasMaximum = 0; 	private Integer incomingTopicAliasMax = 0; 	private Boolean wildcardSubscriptionsAvailable = true; 	private Boolean subscriptionIdentifiersAvailable = true; 	private Boolean sharedSubscriptionsAvailable = true; 	private boolean sendReasonMessages = false; 	private long keepAlive = 60;  	// ******* Counters ******// 	private AtomicInteger nextOutgoingTopicAlias = new AtomicInteger(1);   	/** 	 * Clears the session and resets. This would be called when the connection has 	 * been lost and cleanStart = True. 	 */ 	public void clearConnectionState() { 		nextOutgoingTopicAlias.set(1); 	}   	public Integer getReceiveMaximum() { 		if (receiveMaximum == null) { 			return 65535; 		} 		return receiveMaximum; 	}  	public void setReceiveMaximum(Integer receiveMaximum) { 		this.receiveMaximum = receiveMaximum; 	}  	public Integer getMaximumQoS() { 		return maximumQoS; 	}  	public void setMaximumQoS(Integer maximumQoS) { 		this.maximumQoS = maximumQoS; 	}  	public Boolean isRetainAvailable() { 		return retainAvailable; 	}  	public void setRetainAvailable(Boolean retainAvailable) { 		this.retainAvailable = retainAvailable; 	}  	public Long getOutgoingMaximumPacketSize() { 		return outgoingMaximumPacketSize; 	}  	public void setOutgoingMaximumPacketSize(Long maximumPacketSize) { 		this.outgoingMaximumPacketSize = maximumPacketSize; 	} 	 	public Long getIncomingMaximumPacketSize() { 		return incomingMaximumPacketSize; 	}   	public void setIncomingMaximumPacketSize(Long incomingMaximumPacketSize) { 		this.incomingMaximumPacketSize = incomingMaximumPacketSize; 	}   	public Integer getOutgoingTopicAliasMaximum() { 		return outgoingTopicAliasMaximum; 	}  	public void setOutgoingTopicAliasMaximum(Integer topicAliasMaximum) { 		this.outgoingTopicAliasMaximum = topicAliasMaximum; 	}  	public Boolean isWildcardSubscriptionsAvailable() { 		return wildcardSubscriptionsAvailable; 	}  	public void setWildcardSubscriptionsAvailable(Boolean wildcardSubscriptionsAvailable) { 		this.wildcardSubscriptionsAvailable = wildcardSubscriptionsAvailable; 	}  	public Boolean isSubscriptionIdentifiersAvailable() { 		return subscriptionIdentifiersAvailable; 	}  	public void setSubscriptionIdentifiersAvailable(Boolean subscriptionIdentifiersAvailable) { 		this.subscriptionIdentifiersAvailable = subscriptionIdentifiersAvailable; 	}  	public Boolean isSharedSubscriptionsAvailable() { 		return sharedSubscriptionsAvailable; 	}  	public void setSharedSubscriptionsAvailable(Boolean sharedSubscriptionsAvailable) { 		this.sharedSubscriptionsAvailable = sharedSubscriptionsAvailable; 	} 	 	public Integer getNextOutgoingTopicAlias() { 		return nextOutgoingTopicAlias.getAndIncrement(); 	}   	public Integer getIncomingTopicAliasMax() { 		return incomingTopicAliasMax; 	}   	public void setIncomingTopicAliasMax(Integer incomingTopicAliasMax) { 		this.incomingTopicAliasMax = incomingTopicAliasMax; 	}   	public boolean isSendReasonMessages() { 		return sendReasonMessages; 	}   	public void setSendReasonMessages(boolean enableReasonMessages) { 		this.sendReasonMessages = enableReasonMessages; 	}   	public long getKeepAlive() { 		return keepAlive; 	}   	public void setKeepAliveSeconds(long keepAlive) { 		this.keepAlive = keepAlive * 1000; 	}   	 }</td>
    <td align="left">data class</td>
    <td align="left">Data Class, Long Method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11996</td>
    <td align="left">https://github.com/eclipse/paho.mqtt.java/blob/5af7b53499e7dbe45b7227b3d41fc870089c0033/org.eclipse.paho.mqttv5.client/src/main/java/org/eclipse/paho/mqttv5/client/internal/MqttConnectionState.java/#L26-L168</td>
    <td align="right">1</td>
    <td align="right">1793</td>
    <td align="right">11996</td>
  </tr>
  <tr valign="top">
    <td align="right">1754</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;1. Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LaunchRequest { 	private String jobName;  	String jobParameters;  	public String getJobName() { 		return jobName; 	}  	public void setJobName(String jobName) { 		this.jobName = jobName; 	}  	public String getJobParameters() { 		return jobParameters; 	}  	public void setJobParameters(String jobParameters) { 		this.jobParameters = jobParameters; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11867</td>
    <td align="left">https://github.com/spring-projects/spring-batch-admin/blob/9e3ad8bff99b8fad8da62426aa7d2959eb841bcf/spring-batch-admin-manager/src/main/java/org/springframework/batch/admin/web/LaunchRequest.java/#L21-L42</td>
    <td align="right">1</td>
    <td align="right">1754</td>
    <td align="right">11867</td>
  </tr>
  <tr valign="top">
    <td align="right">1089</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @WeakOuter     final class EntrySet extends AbstractSet&gt; {         public final int size()                 { return size; }         public final void clear()               { HashMap.this.clear(); }         public final Iterator&gt; iterator() {             return new EntryIterator();         }         public final boolean contains(Object o) {             if (!(o instanceof Map.Entry))                 return false;             Map.Entry e = (Map.Entry) o;             Object key = e.getKey();             Node candidate = getNode(hash(key), key);             return candidate != null &amp;&amp; candidate.equals(e);         }         public final boolean remove(Object o) {             if (o instanceof Map.Entry) {                 Map.Entry e = (Map.Entry) o;                 Object key = e.getKey();                 Object value = e.getValue();                 return removeNode(hash(key), key, value, true, true) != null;             }             return false;         }         public final Spliterator&gt; spliterator() {             return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);         }         public final void forEach(Consumer&gt; action) {             Node[] tab;             if (action == null)                 throw new NullPointerException();             if (size &gt; 0 &amp;&amp; (tab = table) != null) {                 int mc = modCount;                 // Android-changed: Detect changes to modCount early.                 for (int i = 0; (i &lt; tab.length &amp;&amp; modCount == mc); ++i) {                     for (Node e = tab[i]; e != null; e = e.next)                         action.accept(e);                 }                 if (modCount != mc)                     throw new ConcurrentModificationException();             }         }          /*-[         - (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state                                           objects:(__unsafe_unretained id *)stackbuf                                             count:(NSUInteger)len {           return [this$0_ enumerateEntriesWithState:state objects:stackbuf count:len];         }          RETAINED_WITH_CHILD(this$0_)         ]-*/     }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9716</td>
    <td align="left">https://github.com/google/j2objc/blob/471504a735b48d5d4ace51afa1542cc4790a921a/jre_emul/android/platform/libcore/ojluni/src/main/java/java/util/HashMap.java/#L1049-L1101</td>
    <td align="right">1</td>
    <td align="right">1089</td>
    <td align="right">9716</td>
  </tr>
  <tr valign="top">
    <td align="right">435</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   } </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ExprList implements Iterable {     private final List expressions ;     /** Create a copy which does not share the list of expressions with the original */      public static ExprList copy(ExprList other) { return new ExprList(other) ; }          /** Create an ExprList that contains the expressions */     public static ExprList create(Collection exprs) {         ExprList exprList = new ExprList() ;         exprs.forEach(exprList::add) ;         return exprList ;      }           /** Empty, immutable ExprList */     public static final ExprList emptyList = new ExprList(Collections.emptyList()) ;          public ExprList() { expressions = new ArrayList&lt;&gt;() ; }          private ExprList(ExprList other) {         this() ;         expressions.addAll(other.expressions) ;     }      public ExprList(Expr expr) {         this() ;         expressions.add(expr) ;     }      public ExprList(List x)   { expressions = x ; }      public boolean isSatisfied(Binding binding, ExecutionContext execCxt) {         for (Expr expr : expressions) {             if ( !expr.isSatisfied(binding, execCxt) )                 return false ;         }         return true ;     }          public Expr get(int idx)                            { return expressions.get(idx) ; }     public int size()                                   { return expressions.size() ; }     public boolean isEmpty()                            { return expressions.isEmpty() ; }     public ExprList subList(int fromIdx, int toIdx)     { return new ExprList(expressions.subList(fromIdx, toIdx)) ; }     public ExprList tail(int fromIdx)                   { return subList(fromIdx, expressions.size()) ; }          public Set getVarsMentioned() {         Set x = new HashSet&lt;&gt;() ;         varsMentioned(x) ;         return x ;     }      /** @deprecated Use {@link ExprVars#varsMentioned(Collection, ExprList)} */     @Deprecated     public void varsMentioned(Collection acc) {         for (Expr expr : expressions)             ExprVars.varsMentioned(acc, expr);     }          /**      * Rewrite, applying a node{@literal -&gt;}node transformation      */     public ExprList applyNodeTransform(NodeTransform transform) {         ExprList x = new ExprList() ;         for ( Expr e : expressions)             x.add(e.applyNodeTransform(transform));         return x ;      }      public ExprList copySubstitute(Binding binding) {         ExprList x = new ExprList() ;         for (Expr expr : expressions ) {             expr = expr.copySubstitute(binding) ;             x.add(expr) ;         }         return x ;     }      public void addAll(ExprList exprs)      { expressions.addAll(exprs.getList()) ; }     public void add(Expr expr)              { expressions.add(expr) ; }     public List getList()             { return Collections.unmodifiableList(expressions) ; }     /** Use only while building ExprList */     public List getListRaw()          { return expressions ; }     @Override     public Iterator iterator()        { return expressions.iterator() ; }          public void prepareExprs(Context context) {         ExprBuild build = new ExprBuild(context) ;         // Give each expression the chance to set up (bind functions)         for (Expr expr : expressions)             Walker.walk(expr, build) ;     }          @Override     public String toString()     { return expressions.toString() ; }          @Override     public int hashCode() { return expressions.hashCode() ; }      public boolean equals(ExprList other, boolean bySyntax) {         if ( this == other ) return true ;         if (expressions.size() != other.expressions.size()) return false;                  for ( int i = 0 ; i &lt; expressions.size() ; i++ ) {             Expr e1 = expressions.get(i) ;             Expr e2 = other.expressions.get(i) ;             if ( ! e1.equals(e2, bySyntax) )                  return false ;         }         return true ;     }          @Override     public boolean equals(Object other) {         if ( this == other ) return true ;         if ( ! ( other instanceof ExprList ) ) return false ;         ExprList exprs = (ExprList)other ;         //return expressions.equals(exprs.expressions) ;         return equals((ExprList)other, false) ;     }      public static ExprList splitConjunction(ExprList exprList1) {         ExprList exprList2 = new ExprList() ;         for (Expr expr : exprList1)             split(exprList2, expr) ;         return exprList2 ;     }      private static ExprList splitConjunction(Expr expr) {         ExprList exprList = new ExprList() ;         split(exprList, expr) ;         return exprList ;     }      private static void split(ExprList exprList, Expr expr) {         // Explode &amp;&amp;-chain to exprlist.         while (expr instanceof E_LogicalAnd) {             E_LogicalAnd x = (E_LogicalAnd)expr ;             Expr left = x.getArg1() ;             Expr right = x.getArg2() ;             split(exprList, left) ;             expr = right ;         }         // Drop through and add remaining         exprList.add(expr) ;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4284</td>
    <td align="left">https://github.com/apache/jena/blob/1cca775bbf0bb0fd3ee8ac55e31f0f30cdde3b77/jena-arq/src/main/java/org/apache/jena/sparql/expr/ExprList.java/#L30-L175</td>
    <td align="right">1</td>
    <td align="right">435</td>
    <td align="right">4284</td>
  </tr>
  <tr valign="top">
    <td align="right">2281</td>
    <td align="left">&nbsp;	{ 		&quot;output&quot;: &quot;YES I found bad smells&quot;, 		&quot;the bad smells are&quot;: [&quot;Data Class&quot;] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class MetaColumn implements Named {     public final String tableCat;     public final String tableSchem;     public final String tableName;     public final String columnName;     public final int dataType;     public final String typeName;     public final Integer columnSize;     public final Integer bufferLength = null;     public final Integer decimalDigits;     public final Integer numPrecRadix;     public final int nullable;     public final String remarks = null;     public final String columnDef = null;     public final Integer sqlDataType = null;     public final Integer sqlDatetimeSub = null;     public final Integer charOctetLength;     public final int ordinalPosition;     @NotNull     public final String isNullable;     public final String scopeCatalog = null;     public final String scopeSchema = null;     public final String scopeTable = null;     public final Short sourceDataType = null;     @NotNull     public final String isAutoincrement = &quot;&quot;;     @NotNull     public final String isGeneratedcolumn = &quot;&quot;;      public MetaColumn(         String tableCat,         String tableSchem,         String tableName,         String columnName,         int dataType,         String typeName,         Integer columnSize,         Integer decimalDigits,         Integer numPrecRadix,         int nullable,         Integer charOctetLength,         int ordinalPosition,         String isNullable) {       this.tableCat = tableCat;       this.tableSchem = tableSchem;       this.tableName = tableName;       this.columnName = columnName;       this.dataType = dataType;       this.typeName = typeName;       this.columnSize = columnSize;       this.decimalDigits = decimalDigits;       this.numPrecRadix = numPrecRadix;       this.nullable = nullable;       this.charOctetLength = charOctetLength;       this.ordinalPosition = ordinalPosition;       this.isNullable = isNullable;     }      @Override     public String getName() {       return columnName;     }   }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13809</td>
    <td align="left">https://github.com/apache/drill/blob/5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3/exec/jdbc/src/main/java/org/apache/drill/jdbc/impl/DrillMetaImpl.java/#L160-L222</td>
    <td align="right">1</td>
    <td align="right">2281</td>
    <td align="right">13809</td>
  </tr>
  <tr valign="top">
    <td align="right">558</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;:  [&quot;Long Method&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private long prevRecordEndOffset;      public Offset(long lastSyncPoint, long recordsSinceLastSync, long currentRecord) {       this(lastSyncPoint, recordsSinceLastSync, currentRecord, 0, 0 );     }      public Offset(long lastSyncPoint, long recordsSinceLastSync, long currentRecord                   , long currRecordEndOffset, long prevRecordEndOffset) {       this.lastSyncPoint = lastSyncPoint;       this.recordsSinceLastSync = recordsSinceLastSync;       this.currentRecord = currentRecord;       this.prevRecordEndOffset = prevRecordEndOffset;       this.currRecordEndOffset = currRecordEndOffset;     }      public Offset(String offset) {       try {         if(offset==null) {           throw new IllegalArgumentException(&quot;offset cannot be null&quot;);         }         if(offset.equalsIgnoreCase(&quot;0&quot;)) {           this.lastSyncPoint = 0;           this.recordsSinceLastSync = 0;           this.currentRecord = 0;           this.prevRecordEndOffset = 0;           this.currRecordEndOffset = 0;         } else {           String[] parts = offset.split(&quot;:&quot;);           this.lastSyncPoint = Long.parseLong(parts[0].split(&quot;=&quot;)[1]);           this.recordsSinceLastSync = Long.parseLong(parts[1].split(&quot;=&quot;)[1]);           this.currentRecord = Long.parseLong(parts[2].split(&quot;=&quot;)[1]);           this.prevRecordEndOffset = 0;           this.currRecordEndOffset = 0;         }       } catch (Exception e) {         throw new IllegalArgumentException(&quot;'&quot; + offset +                 &quot;' cannot be interpreted. It is not in expected format for SequenceFileReader.&quot; +                 &quot; Format e.g. {sync=123:afterSync=345:record=67}&quot;);       }     }      @Override     public String toString() {       return '{' +               &quot;sync=&quot; + lastSyncPoint +               &quot;:afterSync=&quot; + recordsSinceLastSync +               &quot;:record=&quot; + currentRecord +               &quot;:}&quot;;     }      @Override     public boolean isNextOffset(FileOffset rhs) {       if(rhs instanceof Offset) {         Offset other = ((Offset) rhs);         return  other.currentRecord &gt; currentRecord+1;       }       return false;     }      @Override     public int compareTo(FileOffset o) {       Offset rhs = ((Offset) o);       if(currentRecord&gt;&gt; 32));     }          void increment(boolean syncSeen, long newBytePosition) {       if(!syncSeen) {         ++recordsSinceLastSync;       }  else {         recordsSinceLastSync = 1;         lastSyncPoint = prevRecordEndOffset;       }       ++currentRecord;       prevRecordEndOffset = currRecordEndOffset;       currentRecord = newBytePosition;     }      @Override     public Offset clone() {       return new Offset(lastSyncPoint, recordsSinceLastSync, currentRecord, currRecordEndOffset, prevRecordEndOffset);     }    } //class Offset } //class</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">5621</td>
    <td align="left">https://github.com/alibaba/jstorm/blob/5d6cde22dbca7df3d6e6830bf94f98a6639ab559/jstorm-hdfs/src/main/java/com/alibaba/jstorm/hdfs/spout/SequenceFileReader.java/#L104-L212</td>
    <td align="right">1</td>
    <td align="right">558</td>
    <td align="right">5621</td>
  </tr>
  <tr valign="top">
    <td align="right">1062</td>
    <td align="left">&nbsp;		{ 		  &quot;response&quot;: &quot;YES I found bad smells&quot;, 		  &quot;bad smells are&quot;: [ 		    &quot;Data Class&quot; 		  ] 		}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
final class AvlNode&gt; {     AvlNode parent = null;     AvlNode left = null;     AvlNode right = null;      int height = 0;     int balance = 0;     T value = null;       AvlNode( AvlNode parent, T value )     {         this.parent = parent;         this.value = value;     }       public AvlNode reset( AvlNode parent, T value )     {         this.parent = parent;         left = null;         right = null;          height = 0;         this.value = value;          return this;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9545</td>
    <td align="left">https://github.com/apache/directory-server/blob/310007cc1c7eb5415f93bed67d5553bc70980820/core-avl/src/main/java/org/apache/directory/server/core/avltree/avl/AvlNode.java/#L29-L58</td>
    <td align="right">1</td>
    <td align="right">1062</td>
    <td align="right">9545</td>
  </tr>
  <tr valign="top">
    <td align="right">267</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Long Method&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  private static class MultiPointList extends AbstractList {     private final MultiPoint mp;      public MultiPointList(MultiPoint mp) {       this.mp = mp;     }      @Override     public Point get(int index) {       return mp.getPoint(index);     }      @Override     public int size() {       return mp.getPointCount();     }   }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2884</td>
    <td align="left">https://github.com/Esri/geoportal-server-harvester/blob/b8c69260e3d6ec10df6514c201219e690cfba048/geoportal-commons/geoportal-commons-geometry/src/main/java/com/esri/geoportal/geoportal/commons/geometry/GeometryService.java/#L201-L217</td>
    <td align="right">1</td>
    <td align="right">267</td>
    <td align="right">2884</td>
  </tr>
  <tr valign="top">
    <td align="right">2517</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Customer1149 {  	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id; 	private String firstName; 	private String lastName;  	protected Customer1149() {}  	public Customer1149(String firstName, String lastName) { 		this.firstName = firstName; 		this.lastName = lastName; 	}  	@Override 	public String toString() { 		return String.format(&quot;Customer1149[id=%d, firstName='%s', lastName='%s']&quot;, id, firstName, lastName); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14699</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer1149.java/#L8-L27</td>
    <td align="right">1</td>
    <td align="right">2517</td>
    <td align="right">14699</td>
  </tr>
  <tr valign="top">
    <td align="right">2423</td>
    <td align="left">&nbsp;&nbsp;YES I found bad smells the bad smells are: 1. Data class 2. Dead code - unused imports and variables 3. Magic numbers - the numbers 3472875885259250934 and 0 are used without explanation 4. Shotgun surgery - several methods directly and indirectly manipulate multiple fields and properties of the class, making it difficult to maintain/change in the future 5. Message chain - the chain of method calls in the equals() method can be simplified for better readability and maintainability</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
@XmlRootElement(name = &quot;pagedResult&quot;) @XmlType public class PagedResult implements Serializable {      private static final long serialVersionUID = 3472875885259250934L;      private URI prev;      private URI next;      private final List result = new ArrayList&lt;&gt;();      private int page;      private int size;      private int totalCount;      public URI getPrev() {         return prev;     }      public void setPrev(final URI prev) {         this.prev = prev;     }      public URI getNext() {         return next;     }      public void setNext(final URI next) {         this.next = next;     }      @XmlElementWrapper(name = &quot;result&quot;)     @XmlElement(name = &quot;item&quot;)     @JsonProperty(&quot;result&quot;)     @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = &quot;@class&quot;)     public List getResult() {         return result;     }      public int getPage() {         return page;     }      public void setPage(final int page) {         this.page = page;     }      public int getSize() {         return size;     }      public void setSize(final int size) {         this.size = size;     }      public int getTotalCount() {         return totalCount;     }      public void setTotalCount(final int totalCount) {         this.totalCount = totalCount;     }      @Override     public int hashCode() {         return new HashCodeBuilder().                 append(prev).                 append(next).                 append(result).                 append(page).                 append(size).                 append(totalCount).                 build();     }      @Override     public boolean equals(final Object obj) {         if (this == obj) {             return true;         }         if (obj == null) {             return false;         }         if (getClass() != obj.getClass()) {             return false;         }         @SuppressWarnings(&quot;unchecked&quot;)         final PagedResult other = (PagedResult) obj;         return new EqualsBuilder().                 append(prev, other.prev).                 append(next, other.next).                 append(result, other.result).                 append(page, other.page).                 append(size, other.size).                 append(totalCount, other.totalCount).                 build();     } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Data class2 Dead code - unused imports and variables3 Magic numbers - the numbers 3472875885259250934 and 0 are used without explanation4 Shotgun surgery - several methods directly and indirectly manipulate multiple fields and properties of the class, making it difficult to maintain/change in the future5 Message chain - the chain of method calls in the equals() method can be simplified for better readability and maintainability</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;making it difficult to maintain/change in the future5. Message chain - the chain of method calls in the equals() method can be simplified for better readability and maintainability</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14441</td>
    <td align="left">https://github.com/apache/syncope/blob/114c412afbfba24ffb4fbc804e5308a823a16a78/common/idrepo/lib/src/main/java/org/apache/syncope/common/lib/to/PagedResult.java/#L35-L135</td>
    <td align="right">2</td>
    <td align="right">2423</td>
    <td align="right">14441</td>
  </tr>
  <tr valign="top">
    <td align="right">1814</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Long Method&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@APICommand(name = &quot;updateNetwork&quot;, description = &quot;Updates a network&quot;, responseObject = NetworkResponse.class, responseView = ResponseView.Restricted, entityType = {Network.class},         requestHasSensitiveInfo = false, responseHasSensitiveInfo = false) public class UpdateNetworkCmd extends BaseAsyncCustomIdCmd {     public static final Logger s_logger = Logger.getLogger(UpdateNetworkCmd.class.getName());      private static final String s_name = &quot;updatenetworkresponse&quot;;      /////////////////////////////////////////////////////     //////////////// API parameters /////////////////////     /////////////////////////////////////////////////////     @ACL(accessType = AccessType.OperateEntry)     @Parameter(name=ApiConstants.ID, type=CommandType.UUID, entityType = NetworkResponse.class,             required=true, description=&quot;the ID of the network&quot;)     protected Long id;      @Parameter(name = ApiConstants.NAME, type = CommandType.STRING, description = &quot;the new name for the network&quot;)     private String name;      @Parameter(name = ApiConstants.DISPLAY_TEXT, type = CommandType.STRING, description = &quot;the new display text for the network&quot;)     private String displayText;      @Parameter(name = ApiConstants.NETWORK_DOMAIN, type = CommandType.STRING, description = &quot;network domain&quot;)     private String networkDomain;      @Parameter(name = ApiConstants.CHANGE_CIDR, type = CommandType.BOOLEAN, description = &quot;Force update even if CIDR type is different&quot;)     private Boolean changeCidr;      @Parameter(name = ApiConstants.NETWORK_OFFERING_ID, type = CommandType.UUID, entityType = NetworkOfferingResponse.class, description = &quot;network offering ID&quot;)     private Long networkOfferingId;      @Parameter(name = ApiConstants.GUEST_VM_CIDR, type = CommandType.STRING, description = &quot;CIDR for guest VMs, CloudStack allocates IPs to guest VMs only from this CIDR&quot;)     private String guestVmCidr;      @Parameter(name =ApiConstants.Update_IN_SEQUENCE, type=CommandType.BOOLEAN, description = &quot;if true, we will update the routers one after the other. applicable only for redundant router based networks using virtual router as provider&quot;)     private Boolean updateInSequence;      @Parameter(name = ApiConstants.DISPLAY_NETWORK,                type = CommandType.BOOLEAN,  description = &quot;an optional field, whether to the display the network to the end user or not.&quot;, authorized = {RoleType.Admin})     private Boolean displayNetwork;      @Parameter(name= ApiConstants.FORCED, type = CommandType.BOOLEAN, description = &quot;Setting this to true will cause a forced network update,&quot;, authorized = {RoleType.Admin})     private Boolean forced;      /////////////////////////////////////////////////////     /////////////////// Accessors ///////////////////////     /////////////////////////////////////////////////////      public Long getId() {         return id;     }      public String getNetworkName() {         return name;     }      public String getDisplayText() {         return displayText;     }      public String getNetworkDomain() {         return networkDomain;     }      public Long getNetworkOfferingId() {         return networkOfferingId;     }      public Boolean getChangeCidr() {         if (changeCidr != null) {             return changeCidr;         }         return false;     }      public String getGuestVmCidr() {         return guestVmCidr;     }      public Boolean getDisplayNetwork() {         return displayNetwork;     }      public Boolean getUpdateInSequence(){         if(updateInSequence ==null)             return false;         else             return updateInSequence;     }      public boolean getForced(){         if(forced==null){             return false;         }         return forced;     }     /////////////////////////////////////////////////////     /////////////// API Implementation///////////////////     /////////////////////////////////////////////////////      @Override     public String getCommandName() {         return s_name;     }      @Override     public long getEntityOwnerId() {         Network network = _networkService.getNetwork(id);         if (network == null) {             throw new InvalidParameterValueException(&quot;Networkd ID=&quot; + id + &quot; doesn't exist&quot;);         } else {             return _networkService.getNetwork(id).getAccountId();         }     }      @Override     public void execute() throws InsufficientCapacityException, ConcurrentOperationException {         User callerUser = _accountService.getActiveUser(CallContext.current().getCallingUserId());         Account callerAccount = _accountService.getActiveAccountById(callerUser.getAccountId());         Network network = _networkService.getNetwork(id);         if (network == null) {             throw new InvalidParameterValueException(&quot;Couldn't find network by ID&quot;);         }          Network result =             _networkService.updateGuestNetwork(getId(), getNetworkName(), getDisplayText(), callerAccount, callerUser, getNetworkDomain(), getNetworkOfferingId(),                 getChangeCidr(), getGuestVmCidr(), getDisplayNetwork(), getCustomId(), getUpdateInSequence(), getForced());          if (result != null) {             NetworkResponse response = _responseGenerator.createNetworkResponse(ResponseView.Restricted, result);             response.setResponseName(getCommandName());             setResponseObject(response);         } else {             throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, &quot;Failed to update network&quot;);         }     }      @Override     public String getEventDescription() {         StringBuilder eventMsg = new StringBuilder(&quot;Updating network: &quot; + getId());         if (getNetworkOfferingId() != null) {             Network network = _networkService.getNetwork(getId());             if (network == null) {                 throw new InvalidParameterValueException(&quot;Networkd ID=&quot; + id + &quot; doesn't exist&quot;);             }             if (network.getNetworkOfferingId() != getNetworkOfferingId()) {                 NetworkOffering oldOff = _entityMgr.findById(NetworkOffering.class, network.getNetworkOfferingId());                 NetworkOffering newOff = _entityMgr.findById(NetworkOffering.class, getNetworkOfferingId());                 if (newOff == null) {                     throw new InvalidParameterValueException(&quot;Networkd offering ID supplied is invalid&quot;);                 }                  eventMsg.append(&quot;. Original network offering ID: &quot; + oldOff.getUuid() + &quot;, new network offering ID: &quot; + newOff.getUuid());             }         }          return eventMsg.toString();     }      @Override     public String getEventType() {         return EventTypes.EVENT_NETWORK_UPDATE;     }      @Override     public String getSyncObjType() {         return BaseAsyncCmd.networkSyncObject;     }      @Override     public Long getSyncObjId() {         return id;     }      @Override     public void checkUuid() {         if (getCustomId() != null) {             _uuidMgr.checkUuid(getCustomId(), Network.class);         }     } }</td>
    <td align="left">data class</td>
    <td align="left">Long Method, Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12067</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/api/src/main/java/org/apache/cloudstack/api/command/user/network/UpdateNetworkCmd.java/#L45-L225</td>
    <td align="right">1</td>
    <td align="right">1814</td>
    <td align="right">12067</td>
  </tr>
  <tr valign="top">
    <td align="right">1449</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [&quot;Data Class&quot;]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class NewNodePresentation {    private String nodeText;   private StyleConfigurator nodeTextStyle;   private String nodeInfoText;   private StyleConfigurator nodeInfoTextStyle;   private SVGResource icon;   private Element userElement;    private NewNodePresentation(Builder builder) {     this.nodeText = builder.nodeText;     this.nodeTextStyle = builder.nodeTextStyle;     this.nodeInfoText = builder.nodeInfoText;     this.nodeInfoTextStyle = builder.nodeInfoTextStyle;     this.icon = builder.icon;     this.userElement = builder.userElement;   }    public String getNodeText() {     return nodeText;   }    public StyleConfigurator getNodeTextStyle() {     return nodeTextStyle;   }    public String getNodeInfoText() {     return nodeInfoText;   }    public StyleConfigurator getNodeInfoTextStyle() {     return nodeInfoTextStyle;   }    public SVGResource getIcon() {     return icon;   }    public Element getUserElement() {     return userElement;   }    public static class Builder {     private String nodeText;     private StyleConfigurator nodeTextStyle;     private String nodeInfoText;     private StyleConfigurator nodeInfoTextStyle;     private SVGResource icon;     private Element userElement;      public Builder() {}      public Builder withNodeText(String nodeText) {       this.nodeText = nodeText;       return this;     }      public Builder withNodeTextStyle(StyleConfigurator nodeTextStyle) {       this.nodeTextStyle = nodeTextStyle;       return this;     }      public Builder withNodeInfoText(String nodeInfoText) {       this.nodeInfoText = nodeInfoText;       return this;     }      public Builder withNodeIntoTextStyle(StyleConfigurator nodeInfoTextStyle) {       this.nodeInfoTextStyle = nodeInfoTextStyle;       return this;     }      public Builder withIcon(SVGResource icon) {       this.icon = icon;       return this;     }      public Builder withUserElement(Element userElement) {       this.userElement = userElement;       return this;     }      public NewNodePresentation build() {       return new NewNodePresentation(this);     }   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10991</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/ide/che-core-ide-ui/src/main/java/org/eclipse/che/ide/ui/smartTree/presentation/NewNodePresentation.java/#L25-L111</td>
    <td align="right">1</td>
    <td align="right">1449</td>
    <td align="right">10991</td>
  </tr>
  <tr valign="top">
    <td align="right">656</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Problems {    /** Represents compiler fatal errors. */   public enum FatalError {     FILE_NOT_FOUND(&quot;File '%s' not found.&quot;, 1),     UNKNOWN_INPUT_TYPE(&quot;Cannot recognize input type for file '%s'.&quot;, 1),     OUTPUT_LOCATION(&quot;Output location '%s' must be a directory or .zip file.&quot;, 1),     CANNOT_EXTRACT_ZIP(&quot;Cannot extract zip '%s'.&quot;, 1),     CANNOT_CREATE_ZIP(&quot;Cannot create zip '%s': %s.&quot;, 2),     CANNOT_CLOSE_ZIP(&quot;Cannot close zip: %s.&quot;, 1),     CANNOT_CREATE_TEMP_DIR(&quot;Cannot create temporary directory: %s.&quot;, 1),     CANNOT_OPEN_FILE(&quot;Cannot open file: %s.&quot;, 1),     CANNOT_WRITE_FILE(&quot;Cannot write file: %s.&quot;, 1),     CANNOT_COPY_FILE(&quot;Cannot copy file: %s.&quot;, 1),     PACKAGE_INFO_PARSE(&quot;Resource '%s' was found but it failed to parse.&quot;, 1),     CLASS_PATH_URL(&quot;Class path entry '%s' is not a valid url.&quot;, 1),     GWT_INCOMPATIBLE_FOUND_IN_COMPILE(         &quot;@GwtIncompatible annotations found in %s &quot;             + &quot;Please run this library through the @GwtIncompatible stripper tool.&quot;,         1),     ;      // used for customized message.     private final String message;     // number of arguments the message takes.     private final int numberOfArguments;      FatalError(String message, int numberOfArguments) {       this.message = message;       this.numberOfArguments = numberOfArguments;     }      public String getMessage() {       return message;     }      private int getNumberOfArguments() {       return numberOfArguments;     }   }    /** Represents the severity of the problem */   public enum Severity {     ERROR(&quot;Error&quot;),     WARNING(&quot;Warning&quot;),     INFO(&quot;Info&quot;);      Severity(String messagePrefix) {       this.messagePrefix = messagePrefix;     }      private final String messagePrefix;      public String getMessagePrefix() {       return messagePrefix;     }   }    private final Multimap problemsBySeverity = LinkedHashMultimap.create();    public void fatal(FatalError fatalError, Object... args) {     checkArgument(fatalError.getNumberOfArguments() == args.length);     problemsBySeverity.put(         Severity.ERROR, &quot;Error: &quot; + String.format(fatalError.getMessage(), args));     abort();   }    public void error(SourcePosition sourcePosition, String detailMessage, Object... args) {     problem(Severity.ERROR, sourcePosition, detailMessage, args);   }    public void error(int lineNumber, String filePath, String detailMessage, Object... args) {     problem(Severity.ERROR, lineNumber, filePath, detailMessage, args);   }    public void warning(SourcePosition sourcePosition, String detailMessage, Object... args) {     problem(Severity.WARNING, sourcePosition, detailMessage, args);   }    private void problem(       Severity severity, SourcePosition sourcePosition, String detailMessage, Object... args) {     problem(         severity,         // SourcePosition lines are 0 based.         sourcePosition.getStartFilePosition().getLine() + 1,         sourcePosition.getFilePath(),         detailMessage,         args);   }    private void problem(       Severity severity, int lineNumber, String filePath, String detailMessage, Object... args) {     String message = args.length == 0 ? detailMessage : String.format(detailMessage, args);     problemsBySeverity.put(         severity,         String.format(             &quot;%s:%s:%s: %s&quot;,             severity.getMessagePrefix(),             filePath.substring(filePath.lastIndexOf('/') + 1),             lineNumber,             message));   }    public void error(String detailMessage, Object... args) {     problemsBySeverity.put(Severity.ERROR, &quot;Error: &quot; + String.format(detailMessage, args));   }    public void warning(String detailMessage, Object... args) {     problemsBySeverity.put(Severity.WARNING, String.format(detailMessage, args));   }    public void info(String detailMessage, Object... args) {     problemsBySeverity.put(Severity.INFO, String.format(detailMessage, args));   }    /** Prints all problems to provided output and returns the exit code. */   public int reportAndGetExitCode(PrintStream output) {     return reportAndGetExitCode(new PrintWriter(output, true));   }    /** Prints all problems to provided output and returns the exit code. */   public int reportAndGetExitCode(PrintWriter output) {     for (Map.Entry severityMessagePair : problemsBySeverity.entries()) {       output.println(severityMessagePair.getValue());     }     if (hasErrors() || hasWarnings()) {       output.printf(           &quot;%d error(s), %d warning(s).\n&quot;,           problemsBySeverity.get(Severity.ERROR).size(),           problemsBySeverity.get(Severity.WARNING).size());     }      return hasErrors() ? 1 : 0;   }    public boolean hasWarnings() {     return problemsBySeverity.containsKey(Severity.WARNING);   }    public boolean hasErrors() {     return problemsBySeverity.containsKey(Severity.ERROR);   }    public boolean hasProblems() {     return !problemsBySeverity.isEmpty();   }    public void abortIfHasErrors() {     if (hasErrors()) {       abort();     }   }    public void abort() {     throw new Exit(this);   }    public List getErrors() {     return getMessages(Severity.ERROR);   }    public List getWarnings() {     return getMessages(Severity.WARNING);   }    public List getInfoMessages() {     return getMessages(Severity.INFO);   }    public List getMessages() {     return getMessages(EnumSet.allOf(Severity.class));   }    private List getMessages(Severity severity) {     return getMessages(Collections.singleton(severity));   }    private List getMessages(Collection severities) {     return problemsBySeverity         .entries()         .stream()         .filter(e -&gt; severities.contains(e.getKey()))         .map(Map.Entry::getValue)         .collect(Collectors.toList());   }    /**    * Exit is thrown to signal that a System.exit should be performed at a higher level.    *    * Note: It should never be caught except on the top level.    */   public static class Exit extends java.lang.Error {     private final Problems problems;      private Exit(Problems problems) {       this.problems = problems;     }      public Problems getProblems() {       return problems;     }   } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6405</td>
    <td align="left">https://github.com/google/j2cl/blob/f233ebf547cce390cf87ce346ed82e0512f4fbe1/transpiler/java/com/google/j2cl/common/Problems.java/#L32-L234</td>
    <td align="right">1</td>
    <td align="right">656</td>
    <td align="right">6405</td>
  </tr>
  <tr valign="top">
    <td align="right">583</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{        &quot;message&quot;: &quot;YES I found bad smells&quot;,        &quot;bad smells are&quot;: [            &quot;Data Class&quot;,            &quot;Long Method&quot;        ]    }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ServletContextAttributeFactoryBean implements FactoryBean, ServletContextAware {  	@Nullable 	private String attributeName;  	@Nullable 	private Object attribute;   	/** 	 * Set the name of the ServletContext attribute to expose. 	 */ 	public void setAttributeName(String attributeName) { 		this.attributeName = attributeName; 	}  	@Override 	public void setServletContext(ServletContext servletContext) { 		if (this.attributeName == null) { 			throw new IllegalArgumentException(&quot;Property 'attributeName' is required&quot;); 		} 		this.attribute = servletContext.getAttribute(this.attributeName); 		if (this.attribute == null) { 			throw new IllegalStateException(&quot;No ServletContext attribute '&quot; + this.attributeName + &quot;' found&quot;); 		} 	}   	@Override 	@Nullable 	public Object getObject() throws Exception { 		return this.attribute; 	}  	@Override 	public Class getObjectType() { 		return (this.attribute != null ? this.attribute.getClass() : null); 	}  	@Override 	public boolean isSingleton() { 		return true; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5796</td>
    <td align="left">https://github.com/spring-projects/spring-framework/blob/3a0f309e2c9fdbbf7fb2d348be861528177f8555/spring-web/src/main/java/org/springframework/web/context/support/ServletContextAttributeFactoryBean.java/#L45-L89</td>
    <td align="right">1</td>
    <td align="right">583</td>
    <td align="right">5796</td>
  </tr>
  <tr valign="top">
    <td align="right">1594</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Blob&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ConsoleProxyClientParam {     private String clientHostAddress;     private int clientHostPort;     private String clientHostPassword;     private String clientTag;     private String ticket;     private String locale;     private String clientTunnelUrl;     private String clientTunnelSession;      private String hypervHost;      private String ajaxSessionId;     private String username;     private String password;      public ConsoleProxyClientParam() {         clientHostPort = 0;     }      public String getClientHostAddress() {         return clientHostAddress;     }      public void setClientHostAddress(String clientHostAddress) {         this.clientHostAddress = clientHostAddress;     }      public int getClientHostPort() {         return clientHostPort;     }      public void setClientHostPort(int clientHostPort) {         this.clientHostPort = clientHostPort;     }      public String getClientHostPassword() {         return clientHostPassword;     }      public void setClientHostPassword(String clientHostPassword) {         this.clientHostPassword = clientHostPassword;     }      public String getClientTag() {         return clientTag;     }      public void setClientTag(String clientTag) {         this.clientTag = clientTag;     }      public String getTicket() {         return ticket;     }      public void setTicket(String ticket) {         this.ticket = ticket;     }      public String getClientTunnelUrl() {         return clientTunnelUrl;     }      public void setClientTunnelUrl(String clientTunnelUrl) {         this.clientTunnelUrl = clientTunnelUrl;     }      public String getClientTunnelSession() {         return clientTunnelSession;     }      public void setClientTunnelSession(String clientTunnelSession) {         this.clientTunnelSession = clientTunnelSession;     }      public String getAjaxSessionId() {         return ajaxSessionId;     }      public void setAjaxSessionId(String ajaxSessionId) {         this.ajaxSessionId = ajaxSessionId;     }      public String getLocale() {         return locale;     }      public void setLocale(String locale) {         this.locale = locale;     }      public String getClientMapKey() {         if (clientTag != null &amp;&amp; !clientTag.isEmpty())             return clientTag;          return clientHostAddress + &quot;:&quot; + clientHostPort;     }      public void setHypervHost(String host) {         hypervHost = host;     }      public String getHypervHost() {         return hypervHost;     }      public void setUsername(String username) {         this.username = username;      }      public String getUsername() {         return username;     }      public void setPassword(String password) {         this.password = password;     }      public String getPassword() {         return password;     } }</td>
    <td align="left">data class</td>
    <td align="left">Blob, Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">Blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11407</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/server/src/main/java/com/cloud/servlet/ConsoleProxyClientParam.java/#L20-L143</td>
    <td align="right">1</td>
    <td align="right">1594</td>
    <td align="right">11407</td>
  </tr>
  <tr valign="top">
    <td align="right">928</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class BasicAttributeSensor extends BasicSensor implements AttributeSensor {     private static final long serialVersionUID = -2493209215974820300L;          private final SensorPersistenceMode persistence;      public BasicAttributeSensor(Class type, String name) {         this(type, name, name);     }          public BasicAttributeSensor(Class type, String name, String description) {         this(type, name, description, SensorPersistenceMode.REQUIRED);     }          public BasicAttributeSensor(TypeToken typeToken, String name) {         this(typeToken, name, name);     }     public BasicAttributeSensor(TypeToken typeToken, String name, String description) {         this(typeToken, name, description, SensorPersistenceMode.REQUIRED);     }          public BasicAttributeSensor(Class type, String name, String description, SensorPersistenceMode persistence) {         this(type, null, name, description, persistence);     }     public BasicAttributeSensor(TypeToken typeToken, String name, String description, SensorPersistenceMode persistence) {         this(null, typeToken, name, description, persistence);     }     public BasicAttributeSensor(Class type, TypeToken typeToken, String name, String description, SensorPersistenceMode persistence) {         super(type, typeToken, name, description);         this.persistence = checkNotNull(persistence, &quot;persistence&quot;);     }      @Override     public SensorPersistenceMode getPersistenceMode() {         // persistence could be null if deserializing state written by an old version; in which case default to 'required'         return (persistence != null) ? persistence : SensorPersistenceMode.REQUIRED;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8330</td>
    <td align="left">https://github.com/apache/brooklyn-server/blob/880eb1da00f6358d7fd76d065322e3685bfb1a04/core/src/main/java/org/apache/brooklyn/core/sensor/BasicAttributeSensor.java/#L31-L67</td>
    <td align="right">1</td>
    <td align="right">928</td>
    <td align="right">8330</td>
  </tr>
  <tr valign="top">
    <td align="right">1536</td>
    <td align="left">&nbsp;{ &quot;response&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Graph extends GraphShapeElement { 	public enum Alignment { 		HORIZONTAL, VERTICAL 	}  	private List nodes = new ArrayList&lt;&gt;(); 	private Set edges = new HashSet&lt;&gt;(); 	private Set subgraphs = new HashSet&lt;&gt;(); 	private Alignment alignment = Alignment.VERTICAL;  	/** 	 * Constructs a Graph that uses the specified GraphEventManager to handle 	 * any user generated events on GraphElements. 	 *  	 * @param eventManager 	 */ 	public Graph(GraphController graphController) { 		super(graphController); 	}  	/** 	 * Adds an edge to the Graph and sets its parent to be this Graph. 	 *  	 * @param edge 	 *            the edge to add 	 */ 	public void addEdge(GraphEdge edge) { 		edge.setParent(this); 		edges.add(edge); 	}  	/** 	 * Adds a node to the Graph and sets its parent to be this Graph. 	 *  	 * @param node 	 *            the node to add 	 */ 	public void addNode(GraphNode node) { 		node.setParent(this); 		nodes.add(node); 	}  	/** 	 * Adds a subgraph to the Graph and sets its parent to be this Graph. 	 *  	 * @param subgraph 	 *            the subgraph to add 	 */ 	public void addSubgraph(Graph subgraph) { 		subgraph.setParent(this); 		subgraphs.add(subgraph); 	}  	/** 	 * Returns the alignment of the Graph. 	 *  	 * @return the alignment of the Graph 	 */ 	public Alignment getAlignment() { 		return alignment; 	}  	/** 	 * Returns the edges contained in the Graph. 	 *  	 * @return the edges contained in the Graph 	 */ 	public Set getEdges() { 		return Collections.unmodifiableSet(edges); 	}  	/** 	 * Returns the nodes contained in the Graph. 	 *  	 * @return the nodes contained in the Graph 	 */ 	public List getNodes() { 		return Collections.unmodifiableList(nodes); 	}  	/** 	 * Returns the subgraphs contained in the Graph. 	 *  	 * @return the subgraphs contained in the Graph 	 */ 	public Set getSubgraphs() { 		return Collections.unmodifiableSet(subgraphs); 	}  	/** 	 * Removes an edge from the Graph. 	 *  	 * @param edge 	 *            the edge to remove 	 * @return true if the edge is removed from the Graph 	 */ 	public boolean removeEdge(GraphEdge edge) { 		return edges.remove(edge); 	}  	/** 	 * Removes a node from the Graph. 	 *  	 * @param node 	 *            the node to remove 	 * @return true if the node is removed from the Graph 	 */ 	public boolean removeNode(GraphNode node) { 		return nodes.remove(node); 	}  	/** 	 * Removes a subgraph from the Graph. 	 *  	 * @param subgraph 	 *            the subgraph to remove 	 * @return true if the subgraph is removed from the Graph 	 */ 	public boolean removeSubgraph(Graph subgraph) { 		return subgraphs.remove(subgraph); 	}  	/** 	 * Sets the alignment of the Graph. 	 *  	 * @param alignment 	 *            the new alignment 	 */ 	public void setAlignment(Alignment alignment) { 		this.alignment = alignment; 	} }</td>
    <td align="left">data class</td>
    <td align="left">Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11219</td>
    <td align="left">https://github.com/apache/incubator-taverna-workbench/blob/2b74964ac1ee22e56c5dad3321869d84f7052dcf/taverna-graph-model/src/main/java/org/apache/taverna/workbench/models/graph/Graph.java/#L30-L161</td>
    <td align="right">1</td>
    <td align="right">1536</td>
    <td align="right">11219</td>
  </tr>
  <tr valign="top">
    <td align="right">338</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class BasicBundleInfo {      private String pkgName;      /**      * The main dex depends on + the md5 that is currently dependent      */     private String unique_tag;      private String applicationName;      private String version;       public Boolean getIsMBundle() {         return isMBundle;     }      public void setIsMBundle(boolean mainBundle) {         isMBundle = mainBundle;     }      private Boolean isMBundle = false;      private List dependency = Lists.newArrayList();      private List activities = Lists.newArrayList();      private List services = Lists.newArrayList();      private List receivers = Lists.newArrayList();      private List contentProviders = Lists.newArrayList();      private HashMap remoteFragments= new HashMap();      private HashMap remoteViews = new HashMap();      private HashMap remoteTransactors = new HashMap();      private Boolean isInternal = true;      public HashMap getRemoteViews() {         return remoteViews;     }      public void setRemoteViews(HashMap remoteViews) {         this.remoteViews = remoteViews;     }      public HashMap getRemoteTransactors() {         return remoteTransactors;     }      public void setRemoteTransactors(HashMap remoteTransactors) {         this.remoteTransactors = remoteTransactors;     }      public HashMap getRemoteFragments() {         return remoteFragments;     }      public void setRemoteFragments(HashMap remoteFragments) {         this.remoteFragments = remoteFragments;     }      public String getPkgName() {         return pkgName;     }      public void setPkgName(String pkgName) {         this.pkgName = pkgName;     }      public String getApplicationName() {         return applicationName;     }      public void setApplicationName(String applicationName) {         this.applicationName = applicationName;     }      public String getVersion() {         return version;     }      public void setVersion(String version) {         this.version = version;     }      public List getDependency() {         return dependency;     }      public void setDependency(List dependency) {         this.dependency = dependency;     }      public List getActivities() {         return activities;     }      public void setActivities(List activities) {         this.activities = activities;     }      public List getServices() {         return services;     }      public void setServices(List services) {         this.services = services;     }      public List getReceivers() {         return receivers;     }      public void setReceivers(List receivers) {         this.receivers = receivers;     }      public List getContentProviders() {         return contentProviders;     }      public void setContentProviders(List contentProviders) {         this.contentProviders = contentProviders;     }      public boolean getIsInternal() {         return isInternal;     }      public void setIsInternal(boolean internal) {         isInternal = internal;     }      public String getUnique_tag() {         return unique_tag;     }      public void setUnique_tag(String unique_tag) {         this.unique_tag = unique_tag;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">3483</td>
    <td align="left">https://github.com/alibaba/atlas/blob/e8c7b3f1ff14b2a1df64321c6992b796cae7d732/atlas-gradle-plugin/atlas-plugin/src/main/java/com/taobao/android/builder/tools/bundleinfo/model/BasicBundleInfo.java/#L220-L365</td>
    <td align="right">1</td>
    <td align="right">338</td>
    <td align="right">3483</td>
  </tr>
  <tr valign="top">
    <td align="right">814</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Named @RequestScoped public class UserUpdateBean {     private String name;          private String surname;          private int age;          private String userName;          private String password;          private @Inject @Default UserController controller;          private @Inject @Default SessionTracker tracker;          public UserUpdateBean()     {              }      public String showInfo()     {         //Just show how can access session webbeans         User user = this.controller.getUser(tracker.getUser().getId());                  setName(user.getName());         setSurname(user.getSurname());         setAge(user.getAge());         setUserName(user.getUserName());         setPassword(user.getPassword());                          return &quot;toUpdatePage&quot;;     }      public String clear()     {         setName(&quot;&quot;);         setSurname(&quot;&quot;);         setAge(0);         setUserName(&quot;&quot;);         setPassword(&quot;&quot;);                  return null;     }          public String update()     {         this.controller.updateUserInfo(tracker.getUser().getId(), name, surname, age, userName, password);                  JSFUtility.addInfoMessage(&quot;Personal information is succesfully updated.&quot;, &quot;&quot;);                  return null;     }          /**      * @return the name      */     public String getName()     {         return name;     }      /**      * @param name the name to set      */     public void setName(String name)     {         this.name = name;     }      /**      * @return the surname      */     public String getSurname()     {         return surname;     }      /**      * @param surname the surname to set      */     public void setSurname(String surname)     {         this.surname = surname;     }      /**      * @return the age      */     public int getAge()     {         return age;     }      /**      * @param age the age to set      */     public void setAge(int age)     {         this.age = age;     }      /**      * @return the userName      */     public String getUserName()     {         return userName;     }      /**      * @param userName the userName to set      */     public void setUserName(String userName)     {         this.userName = userName;     }      /**      * @return the password      */     public String getPassword()     {         return password;     }      /**      * @param password the password to set      */     public void setPassword(String password)     {         this.password = password;     }           }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7656</td>
    <td align="left">https://github.com/apache/openwebbeans/blob/7831798861478a035c9e9dcca151b5a67e4a28a3/samples/reservation/src/main/java/org/apache/webbeans/reservation/beans/user/UserUpdateBean.java/#L31-L169</td>
    <td align="right">1</td>
    <td align="right">814</td>
    <td align="right">7656</td>
  </tr>
  <tr valign="top">
    <td align="right">124</td>
    <td align="left">&nbsp;{&quot;answer&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface PropertyPathPart extends EObject {   /**    * Returns the value of the 'Name' attribute.    *     *     * If the meaning of the 'Name' attribute isn't clear,    * there really should be more of a description here...    *     *     * @return the value of the 'Name' attribute.    * @see #setName(String)    * @see org.eclipse.xtext.ui.tests.editor.contentassist.bug332217TestLanguage.Bug332217TestLanguagePackage#getPropertyPathPart_Name()    * @model    * @generated    */   String getName();    /**    * Sets the value of the '{@link org.eclipse.xtext.ui.tests.editor.contentassist.bug332217TestLanguage.PropertyPathPart#getName Name}' attribute.    *     *     * @param value the new value of the 'Name' attribute.    * @see #getName()    * @generated    */   void setName(String value);  } // PropertyPathPart</td>
    <td align="left">data class</td>
    <td align="left">'Data Class'</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">{',D,a,t,a,&quot; &quot;,C,l,a,s,s,'}</td>
    <td align="left">{',D,t,&quot; &quot;,C,'}</td>
    <td align="right">0</td>
    <td align="right">1552</td>
    <td align="left">https://github.com/eclipse/xtext-eclipse/blob/0c7546b6aaf3644a77fc68eef9f3da368cbbeabd/org.eclipse.xtext.ui.tests/src-gen/org/eclipse/xtext/ui/tests/editor/contentassist/bug332217TestLanguage/PropertyPathPart.java/#L24-L52</td>
    <td align="right">1</td>
    <td align="right">124</td>
    <td align="right">1552</td>
  </tr>
  <tr valign="top">
    <td align="right">2588</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES, I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class NotificationsAggregatorState {         public long recentEventLogsCount;         public long activeRequestsCount;     }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14994</td>
    <td align="left">https://github.com/vmware/admiral/blob/e02d0e77f65d0ee3541a378110ecd4233bdb6664/request/src/main/java/com/vmware/admiral/request/notification/NotificationsService.java/#L52-L55</td>
    <td align="right">1</td>
    <td align="right">2588</td>
    <td align="right">14994</td>
  </tr>
  <tr valign="top">
    <td align="right">1526</td>
    <td align="left">{ &quot;answer&quot;: &quot;YES, I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class AccessRoleCreatorImpl extends AbstractKapuaEntityCreator implements AccessRoleCreator {      private static final long serialVersionUID = 972154225756734130L;      private KapuaId accessInfo;     private KapuaId roleId;      /**      * Constructor      *       * @param scopeId      */     public AccessRoleCreatorImpl(KapuaId scopeId) {         super(scopeId);     }      @Override     public KapuaId getAccessInfoId() {         return accessInfo;     }      @Override     public void setAccessInfoId(KapuaId accessInfo) {         this.accessInfo = accessInfo;     }      @Override     public KapuaId getRoleId() {         return roleId;     }      @Override     public void setRoleId(KapuaId roleId) {         this.roleId = roleId;     }  }</td>
    <td align="left">data class</td>
    <td align="left">Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11186</td>
    <td align="left">https://github.com/eclipse/kapua/blob/11e610c657f7e473b52882833e33a2261bd3d67d/service/security/shiro/src/main/java/org/eclipse/kapua/service/authorization/access/shiro/AccessRoleCreatorImpl.java/#L25-L61</td>
    <td align="right">1</td>
    <td align="right">1526</td>
    <td align="right">11186</td>
  </tr>
  <tr valign="top">
    <td align="right">974</td>
    <td align="left">&nbsp;		{ 			&quot;response&quot;: &quot;YES, I found bad smells&quot;, 			&quot;bad smells are&quot;: [ 				&quot;Data Class&quot; 			] 		}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LivePropertySource {  	private final List properties; 	private final String sourceName;   	public LivePropertySource(String sourceName, List properties) { 		this.sourceName = sourceName; 		this.properties = properties != null ? ImmutableList.copyOf(properties) : ImmutableList.of(); 	}  	public String getSourceName() { 		return this.sourceName; 	}  	public LiveProperty getProperty(String propertyName) { 		for (LiveProperty liveProperty : properties) { 			if (liveProperty.getProperty().equals(propertyName)) { 				return liveProperty; 			} 		} 		return null; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8777</td>
    <td align="left">https://github.com/spring-projects/sts4/blob/46e9e985b0c5e28ea1952d9fc640ec12fd9c8fdd/headless-services/commons/commons-boot-app-cli/src/main/java/org/springframework/ide/vscode/commons/boot/app/cli/liveproperties/LivePropertySource.java/#L17-L41</td>
    <td align="right">1</td>
    <td align="right">974</td>
    <td align="right">8777</td>
  </tr>
  <tr valign="top">
    <td align="right">1912</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;output&quot;: &quot;YES I found bad smells&quot;,         &quot;the bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SetOrderReferenceDetailsRequest extends DelegateRequest implements Serializable {      @Override     protected SetOrderReferenceDetailsRequest getThis() {         return this;     }      //required parameters     private String amazonOrderReferenceId;     private String orderAmount;     private CurrencyCode orderCurrencyCode;      //optional parameters     private String platformId;     private String sellerNote;     private String sellerOrderId;     private String storeName;     private String supplementaryData;     private String customInformation;     private Boolean requestPaymentAuthorization;      /**      *      * @param amazonOrderReferenceId      *              This value is retrieved from the Amazon Button widget      *              after the buyer has successfully authenticated with Amazon.      *      * @param orderAmount      *              Specifies the total amount of the order represented by this order reference.      */     public SetOrderReferenceDetailsRequest(String amazonOrderReferenceId, String orderAmount) {         this.amazonOrderReferenceId = amazonOrderReferenceId;         this.orderAmount = orderAmount;     }      /**      * Overrides the Client's currency code with specified currency code in SetOrderReferenceDetailsRequest      *      * @param currencyCode      *              A three-digit currency code, formatted based on the ISO 4217 standard.      *      * @return currenyCode      */     public SetOrderReferenceDetailsRequest setOrderCurrencyCode(CurrencyCode currencyCode) {         this.orderCurrencyCode = currencyCode;         return this;     }      /**      * Represents the SellerId of the Solution Provider that developed the platform.      * This value should only be provided by Solution Providers. It should not be      * provided by merchants creating their own custom integration.      *      * @param platformId Represents the SellerId of the Solution Provider that developed the platform.      *                   This value should only be provided by Solution Providers. It should      *                   not be provided by merchants creating their own custom integration.      *      * @return Returns a reference to this object so that methods can be chained together.      */     public SetOrderReferenceDetailsRequest setPlatformId(String platformId) {         this.platformId = platformId;         return this;     }      /**      * Represents a description of the order that is displayed in emails to the buyer.      *      * @param sellerNote Represents a description of the order that is displayed in emails to the buyer.      *      * @return Returns a reference to this object so that methods can be chained together.      */     public SetOrderReferenceDetailsRequest setSellerNote(String sellerNote) {         this.sellerNote = sellerNote;         return this;     }      /**      * The merchant-specified identifier of this order. This is displayed to the      * buyer in their emails and transaction history on the Amazon Pay website.      *      * @param sellerOrderId merchant-specified identifier of the order.      *      * @return the Seller Order ID      */     public SetOrderReferenceDetailsRequest setSellerOrderId(String sellerOrderId) {         this.sellerOrderId = sellerOrderId;         return this;     }      /**      * The identifier of the store from which the order was placed. This overrides      * the default value in Seller Central under Settings &gt; Account Settings. It is      * displayed to the buyer in their emails and transaction history on the      * Amazon Pay website.      *      * @param storeName the identifier of the store from which the order was placed.      *      * @return the Store Name      */     public SetOrderReferenceDetailsRequest setStoreName(String storeName) {         this.storeName = storeName;         return this;     }      /**      * Set the trusted authorization supplementary data.      * Use only as directed by Amazon Pay.      *      * @param supplementaryData Trusted authorization supplementary data (JSON string)      *      * @return Request object      */     public SetOrderReferenceDetailsRequest setSupplementaryData(final String supplementaryData) {         this.supplementaryData = supplementaryData;         return this;     }      /**      * Any additional information that you want to include with this order reference.      *      * @param customInformation Additional information that merchant wants to pass for the order.      *      * @return Custom Information      */     public SetOrderReferenceDetailsRequest setCustomInformation(String customInformation) {         this.customInformation = customInformation;         return this;     }      /**      *      * @return AmazonOrderReferenceId      */     public String getAmazonOrderReferenceId() {         return amazonOrderReferenceId;     }      /**      *      * @return OrderAmount      */     public String getOrderAmount() {         return orderAmount;     }      /**      *      * @return OrderCurrencyCode      */     public CurrencyCode getOrderCurrencyCode() {         return orderCurrencyCode;     }      /**      *      * @return PlatformId      */     public String getPlatformId() {         return platformId;     }      /**      *      * @return SellerNote      */     public String getSellerNote() {         return sellerNote;     }      /**      *      * @return SellerOrderId      */     public String getSellerOrderId() {         return sellerOrderId;     }      /**      *      * @return StoreName      */     public String getStoreName() {         return storeName;     }      /**      * Returns the trusted authorization supplementary data.      *      * @return supplementaryData as a JSON string      */     public String getSupplementaryData() {         return supplementaryData;     }      /**      *      * @return CustomInformation      */     public String getCustomInformation() {         return customInformation;     }      /**      *Check if payment authorization has been requested or not      *      * @return Value of the requestPaymentAuthorization      */     public Boolean getRequestPaymentAuthorization() {         return requestPaymentAuthorization;     }      /**      * Specifies if the merchants want their buyers to go through multi-factor authentication      *      * @param requestPaymentAuthorization flag exposed to merchants using which merchants      *                                    can enforce their buyers to through multi-factor authentication      *      * @return Value of the requestPaymentAuthorization      */     public SetOrderReferenceDetailsRequest setRequestPaymentAuthorization(Boolean requestPaymentAuthorization) {         this.requestPaymentAuthorization = requestPaymentAuthorization;         return this;     }      /**      * Returns a string representation of this object; useful for testing and      * debugging.      *      * @return A string representation of this object.      *      * @see java.lang.Object#toString()      */     @Override     public String toString() {         return &quot;SetOrderReferenceDetailsRequest{&quot;                 + &quot;amazonOrderReferenceId=&quot; + amazonOrderReferenceId                 + &quot;, orderAmount=&quot; + orderAmount                 + &quot;, orderCurrencyCode=&quot; + orderCurrencyCode                 + &quot;, platformId=&quot; + platformId                 + &quot;, sellerNote=&quot; + sellerNote                 + &quot;, sellerOrderId=&quot; + sellerOrderId                 + &quot;, storeName=&quot; + storeName                 + &quot;, supplementaryData=&quot; + supplementaryData                 + &quot;, customInformation=&quot; + customInformation                 + &quot;, mwsAuthToken=&quot; + getMwsAuthToken() + '}';     }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">12401</td>
    <td align="left">https://github.com/amzn/amazon-pay-sdk-java/blob/5a3547d00c796aab8f0c8ac12e0310f7a5c4678a/src/com/amazon/pay/request/SetOrderReferenceDetailsRequest.java/#L25-L272</td>
    <td align="right">1</td>
    <td align="right">1912</td>
    <td align="right">12401</td>
  </tr>
  <tr valign="top">
    <td align="right">259</td>
    <td align="left">{&quot;output&quot;: &quot;YES I found bad smells\nthe bad smells are: 1. Data class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  @InterfaceAudience.LimitedPrivate({&quot;MapReduce&quot;})   @InterfaceStability.Unstable   public static class Context {     private final MapTask mapTask;     private final JobConf jobConf;     private final TaskReporter reporter;      public Context(MapTask mapTask, JobConf jobConf, TaskReporter reporter) {       this.mapTask = mapTask;       this.jobConf = jobConf;       this.reporter = reporter;     }      public MapTask getMapTask() {       return mapTask;     }      public JobConf getJobConf() {       return jobConf;     }      public TaskReporter getReporter() {       return reporter;     }   }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2812</td>
    <td align="left">https://github.com/apache/hadoop-common/blob/42a61a4fbc88303913c4681f0d40ffcc737e70b5/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/MapOutputCollector.java/#L40-L64</td>
    <td align="right">1</td>
    <td align="right">259</td>
    <td align="right">2812</td>
  </tr>
  <tr valign="top">
    <td align="right">1506</td>
    <td align="left">&nbsp;{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [&quot;Data Class&quot;] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ShuffleWriteMetrics {     private long bytesWritten;      private long recordsWritten;      private long writeTime;      public long getBytesWritten ()     {         return bytesWritten;     }      public void setBytesWritten (long bytesWritten)     {         this.bytesWritten = bytesWritten;     }      public long getRecordsWritten ()     {         return recordsWritten;     }      public void setRecordsWritten (long recordsWritten)     {         this.recordsWritten = recordsWritten;     }      public long getWriteTime ()     {         return writeTime;     }      public void setWriteTime (long writeTime)     {         this.writeTime = writeTime;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11150</td>
    <td align="left">https://github.com/Microsoft/azure-tools-for-java/blob/d121e8ac9cc3ab400e5b49c8b372280ae332f3fb/Utils/hdinsight-node-common/src/com/microsoft/azure/hdinsight/sdk/rest/spark/task/ShuffleWriteMetrics.java/#L24-L60</td>
    <td align="right">1</td>
    <td align="right">1506</td>
    <td align="right">11150</td>
  </tr>
  <tr valign="top">
    <td align="right">284</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@ManagedAttributeValueType public interface AclRule extends ManagedAttributeValue {     String getIdentity();     ObjectType getObjectType();     LegacyOperation getOperation();     Map getAttributes();     RuleOutcome getOutcome(); }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3039</td>
    <td align="left">https://github.com/apache/qpid-broker-j/blob/4c4400b98a5a8493cfb9e5dbb21c97175f433a62/broker-plugins/access-control/src/main/java/org/apache/qpid/server/security/access/plugins/AclRule.java/#L31-L39</td>
    <td align="right">1</td>
    <td align="right">284</td>
    <td align="right">3039</td>
  </tr>
  <tr valign="top">
    <td align="right">72</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class CertificatePolicyMap {     private CertificatePolicyId issuerDomain;     private CertificatePolicyId subjectDomain;      /**      * Create a CertificatePolicyMap with the passed CertificatePolicyId's.      *      * @param issuer the CertificatePolicyId for the issuer CA.      * @param subject the CertificatePolicyId for the subject CA.      */     public CertificatePolicyMap(CertificatePolicyId issuer,                                 CertificatePolicyId subject) {         this.issuerDomain = issuer;         this.subjectDomain = subject;     }      /**      * Create the CertificatePolicyMap from the DER encoded value.      *      * @param val the DER encoded value of the same.      */     public CertificatePolicyMap(DerValue val) throws IOException {         if (val.tag != DerValue.tag_Sequence) {             throw new IOException(&quot;Invalid encoding for CertificatePolicyMap&quot;);         }         issuerDomain = new CertificatePolicyId(val.data.getDerValue());         subjectDomain = new CertificatePolicyId(val.data.getDerValue());     }      /**      * Return the issuer CA part of the policy map.      */     public CertificatePolicyId getIssuerIdentifier() {         return (issuerDomain);     }      /**      * Return the subject CA part of the policy map.      */     public CertificatePolicyId getSubjectIdentifier() {         return (subjectDomain);     }      /**      * Returns a printable representation of the CertificatePolicyId.      */     public String toString() {         String s = &quot;CertificatePolicyMap: [\n&quot;                  + &quot;IssuerDomain:&quot; + issuerDomain.toString()                  + &quot;SubjectDomain:&quot; + subjectDomain.toString()                  + &quot;]\n&quot;;          return (s);     }      /**      * Write the CertificatePolicyMap to the DerOutputStream.      *      * @param out the DerOutputStream to write the object to.      * @exception IOException on errors.      */     public void encode(DerOutputStream out) throws IOException {         DerOutputStream tmp = new DerOutputStream();          issuerDomain.encode(tmp);         subjectDomain.encode(tmp);         out.write(DerValue.tag_Sequence,tmp);     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1106</td>
    <td align="left">https://github.com/google/j2objc/blob/471504a735b48d5d4ace51afa1542cc4790a921a/jre_emul/android/platform/libcore/ojluni/src/main/java/sun/security/x509/CertificatePolicyMap.java/#L38-L106</td>
    <td align="right">1</td>
    <td align="right">72</td>
    <td align="right">1106</td>
  </tr>
  <tr valign="top">
    <td align="right">1405</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Value public class Release {  	private final String id; 	private final ProjectKey projectKey; 	private final String name; 	private final String description; 	private final LocalDate date; }</td>
    <td align="left">data class</td>
    <td align="left">Blob, Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">Blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10874</td>
    <td align="left">https://github.com/spring-projects/spring-data-dev-tools/blob/a25ff3ae28026f132871f7172c6ba5c3b64e1671/release-tools/src/main/java/org/springframework/data/release/model/Release.java/#L25-L33</td>
    <td align="right">1</td>
    <td align="right">1405</td>
    <td align="right">10874</td>
  </tr>
  <tr valign="top">
    <td align="right">1413</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public class TypeRefWithoutModifiersElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.n4js.ts.TypeExpressions.TypeRefWithoutModifiers&quot;); 		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1); 		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0); 		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0); 		private final RuleCall cParameterizedTypeRefParserRuleCall_0_0_0 = (RuleCall)cAlternatives_0_0.eContents().get(0); 		private final RuleCall cThisTypeRefParserRuleCall_0_0_1 = (RuleCall)cAlternatives_0_0.eContents().get(1); 		private final Assignment cDynamicAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1); 		private final Keyword cDynamicPlusSignKeyword_0_1_0 = (Keyword)cDynamicAssignment_0_1.eContents().get(0); 		private final RuleCall cTypeTypeRefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1); 		private final RuleCall cFunctionTypeExpressionOLDParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2); 		private final RuleCall cUnionTypeExpressionOLDParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3); 		private final RuleCall cIntersectionTypeExpressionOLDParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4); 		 		//TypeRefWithoutModifiers StaticBaseTypeRef: 		//	(ParameterizedTypeRef | ThisTypeRef) =&gt; dynamic?='+'? | TypeTypeRef 		//	| FunctionTypeExpressionOLD 		//	| UnionTypeExpressionOLD 		//	| IntersectionTypeExpressionOLD; 		@Override public ParserRule getRule() { return rule; } 		 		//(ParameterizedTypeRef | ThisTypeRef) =&gt; dynamic?='+'? | TypeTypeRef | FunctionTypeExpressionOLD | UnionTypeExpressionOLD 		//| IntersectionTypeExpressionOLD 		public Alternatives getAlternatives() { return cAlternatives; } 		 		//(ParameterizedTypeRef | ThisTypeRef) =&gt; dynamic?='+'? 		public Group getGroup_0() { return cGroup_0; } 		 		//ParameterizedTypeRef | ThisTypeRef 		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; } 		 		//ParameterizedTypeRef 		public RuleCall getParameterizedTypeRefParserRuleCall_0_0_0() { return cParameterizedTypeRefParserRuleCall_0_0_0; } 		 		//ThisTypeRef 		public RuleCall getThisTypeRefParserRuleCall_0_0_1() { return cThisTypeRefParserRuleCall_0_0_1; } 		 		//=&gt; dynamic?='+'? 		public Assignment getDynamicAssignment_0_1() { return cDynamicAssignment_0_1; } 		 		//'+' 		public Keyword getDynamicPlusSignKeyword_0_1_0() { return cDynamicPlusSignKeyword_0_1_0; } 		 		//TypeTypeRef 		public RuleCall getTypeTypeRefParserRuleCall_1() { return cTypeTypeRefParserRuleCall_1; } 		 		//FunctionTypeExpressionOLD 		public RuleCall getFunctionTypeExpressionOLDParserRuleCall_2() { return cFunctionTypeExpressionOLDParserRuleCall_2; } 		 		//UnionTypeExpressionOLD 		public RuleCall getUnionTypeExpressionOLDParserRuleCall_3() { return cUnionTypeExpressionOLDParserRuleCall_3; } 		 		//IntersectionTypeExpressionOLD 		public RuleCall getIntersectionTypeExpressionOLDParserRuleCall_4() { return cIntersectionTypeExpressionOLDParserRuleCall_4; } 	}</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10905</td>
    <td align="left">https://github.com/eclipse/n4js/blob/f715912fce0352ab574ff878086f77d17a78c908/plugins/org.eclipse.n4js.ts/src-gen/org/eclipse/n4js/ts/services/TypeExpressionsGrammarAccess.java/#L201-L255</td>
    <td align="right">1</td>
    <td align="right">1413</td>
    <td align="right">10905</td>
  </tr>
  <tr valign="top">
    <td align="right">2514</td>
    <td align="left">{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are:&quot;: [     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class GridH2DmlResponse implements Message, GridCacheQueryMarshallable {     /** */     private static final long serialVersionUID = 0L;      /** Request id. */     @GridToStringInclude     private long reqId;      /** Number of updated rows. */     @GridToStringInclude     private long updCnt;      /** Error message. */     @GridToStringInclude     private String err;      /** Keys that failed. */     @GridToStringInclude     @GridDirectTransient     private Object[] errKeys;      /** Keys that failed (after marshalling). */     private byte[] errKeysBytes;      /**      * Default constructor.      */     public GridH2DmlResponse() {         // No-op.     }      /**      * Constructor.      *      * @param reqId Request id.      * @param updCnt Updated row number.      * @param errKeys Erroneous keys.      * @param error Error message.      */     public GridH2DmlResponse(long reqId, long updCnt, Object[] errKeys, String error) {         this.reqId = reqId;         this.updCnt = updCnt;         this.errKeys = errKeys;         this.err = error;     }      /**      * @return Request id.      */     public long requestId() {         return reqId;     }      /**      * @return Update counter.      */     public long updateCounter() {         return updCnt;     }      /**      * @return Error keys.      */     public Object[] errorKeys() {         return errKeys;     }      /**      * @return Error message.      */     public String error() {         return err;     }      /** {@inheritDoc} */     @Override public void marshall(Marshaller m) {         if (errKeysBytes != null || errKeys == null)             return;          try {             errKeysBytes = U.marshal(m, errKeys);         }         catch (IgniteCheckedException e) {             throw new IgniteException(e);         }     }      /** {@inheritDoc} */     @SuppressWarnings(&quot;IfMayBeConditional&quot;)     @Override public void unmarshall(Marshaller m, GridKernalContext ctx) {         if (errKeys != null || errKeysBytes == null)             return;          try {             final ClassLoader ldr = U.resolveClassLoader(ctx.config());              if (m instanceof BinaryMarshaller)                 // To avoid deserializing of enum types.                 errKeys = ((BinaryMarshaller)m).binaryMarshaller().unmarshal(errKeysBytes, ldr);             else                 errKeys = U.unmarshal(m, errKeysBytes, ldr);         }         catch (IgniteCheckedException e) {             throw new IgniteException(e);         }     }      /** {@inheritDoc} */     @Override public String toString() {         return S.toString(GridH2DmlResponse.class, this);     }      /** {@inheritDoc} */     @Override public boolean writeTo(ByteBuffer buf, MessageWriter writer) {         writer.setBuffer(buf);          if (!writer.isHeaderWritten()) {             if (!writer.writeHeader(directType(), fieldsCount()))                 return false;              writer.onHeaderWritten();         }          switch (writer.state()) {             case 0:                 if (!writer.writeString(&quot;err&quot;, err))                     return false;                  writer.incrementState();              case 1:                 if (!writer.writeByteArray(&quot;errKeysBytes&quot;, errKeysBytes))                     return false;                  writer.incrementState();              case 2:                 if (!writer.writeLong(&quot;reqId&quot;, reqId))                     return false;                  writer.incrementState();              case 3:                 if (!writer.writeLong(&quot;updCnt&quot;, updCnt))                     return false;                  writer.incrementState();          }          return true;     }      /** {@inheritDoc} */     @Override public boolean readFrom(ByteBuffer buf, MessageReader reader) {         reader.setBuffer(buf);          if (!reader.beforeMessageRead())             return false;          switch (reader.state()) {             case 0:                 err = reader.readString(&quot;err&quot;);                  if (!reader.isLastRead())                     return false;                  reader.incrementState();              case 1:                 errKeysBytes = reader.readByteArray(&quot;errKeysBytes&quot;);                  if (!reader.isLastRead())                     return false;                  reader.incrementState();              case 2:                 reqId = reader.readLong(&quot;reqId&quot;);                  if (!reader.isLastRead())                     return false;                  reader.incrementState();              case 3:                 updCnt = reader.readLong(&quot;updCnt&quot;);                  if (!reader.isLastRead())                     return false;                  reader.incrementState();          }          return reader.afterMessageRead(GridH2DmlResponse.class);     }      /** {@inheritDoc} */     @Override public short directType() {         return -56;     }      /** {@inheritDoc} */     @Override public byte fieldsCount() {         return 4;     }      @Override public void onAckReceived() {         // No-op     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14693</td>
    <td align="left">https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/msg/GridH2DmlResponse.java/#L38-L249</td>
    <td align="right">1</td>
    <td align="right">2514</td>
    <td align="right">14693</td>
  </tr>
  <tr valign="top">
    <td align="right">972</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Capability implements IConvertible {     private String virtualCores;      private String memorySize;      private String memory;      public String getVirtualCores() {         return virtualCores;     }      public void setVirtualCores(String virtualCores) {         this.virtualCores = virtualCores;     }      public String getMemorySize() {         return memorySize;     }      public void setMemorySize(String memorySize) {         this.memorySize = memorySize;     }      public String getMemory() {         return memory;     }      public void setMemory(String memory) {         this.memory = memory;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8715</td>
    <td align="left">https://github.com/Microsoft/azure-tools-for-java/blob/d121e8ac9cc3ab400e5b49c8b372280ae332f3fb/Utils/hdinsight-node-common/src/com/microsoft/azure/hdinsight/sdk/rest/yarn/rm/Capability.java/#L26-L56</td>
    <td align="right">1</td>
    <td align="right">972</td>
    <td align="right">8715</td>
  </tr>
  <tr valign="top">
    <td align="right">2289</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  class TaskRemoval implements WorkerHistoryItem   {     private final String taskId;      @JsonCreator     public TaskRemoval(         @JsonProperty(&quot;taskId&quot;) String taskId     )     {       this.taskId = taskId;     }      @JsonProperty     public String getTaskId()     {       return taskId;     }      @Override     public String toString()     {       return &quot;TaskRemoval{&quot; +              &quot;taskId='&quot; + taskId + '\'' +              '}';     }   }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13914</td>
    <td align="left">https://github.com/apache/incubator-druid/blob/8ca7cb4886dcaeeaaea3a06aceb9e6d50eeecab5/indexing-service/src/main/java/org/apache/druid/indexing/worker/WorkerHistoryItem.java/#L64-L89</td>
    <td align="right">1</td>
    <td align="right">2289</td>
    <td align="right">13914</td>
  </tr>
  <tr valign="top">
    <td align="right">1254</td>
    <td align="left">{&quot;message&quot;: &quot;YES, I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;1. Long Method&quot;, &quot;2. Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class ResolutionOptions {     public static class EncodingStrategy extends TypesafeEnum {         private EncodingStrategy(final int value) {             super(value);         }          /**          * When this strategy is chosen, the file's existing encoding is used.          */         public final static EncodingStrategy DEFAULT = new EncodingStrategy(0);         /**          * When this strategy is chosen, the all files involved in the merge          * will have their encodings treated like the given encoding. No file          * conversion is done.          */         public final static EncodingStrategy OVERRIDE_EXPLICIT = new EncodingStrategy(1);         /**          * When this strategy is chosen, the all files involved in the merge          * will be converted into the explicitly named encoding.          */         public final static EncodingStrategy CONVERT_EXPLICIT = new EncodingStrategy(2);     }      /**      * How to go about resolving encoding conflicts.      */     private EncodingStrategy encodingStrategy = EncodingStrategy.DEFAULT;      /**      * Only used when _encodingStrategy is not default.      */     private FileEncoding explicitEncoding = FileEncoding.AUTOMATICALLY_DETECT;      private boolean useInternalEngine = true;      private FileEncoding acceptMergeEncoding = null;      private String newPath = null;      private boolean acceptMergeWithConflicts = false;      private PropertyValue[] acceptMergeProperties;      /**      * Creates a {@link ResolutionOptions} with the default options set.      */     public ResolutionOptions() {         super();     }      /**      * Sets the strategy for resolving encoding conflicts. If the strategy is      * EncodingStrategy.DEFAULT, explicitEncoding must be null. If the strategy      * is some other value, explicitEncoding must be non-null, and represents      * the overriding encoding, or conversion encoding, or whatever that      * strategy's comment says it represents.      *      * @param strategy      *        the strategy to take for resolving encoding conflicts.      * @param explicitEncoding      *        the encoding to use for resolving conflicts (null if the strategy      *        is EncodingStrategy.DEFAULT).      */     public void setEncodingStrategy(final EncodingStrategy strategy, final FileEncoding explicitEncoding) {         Check.isTrue(             (strategy == EncodingStrategy.DEFAULT &amp;&amp; explicitEncoding == null || explicitEncoding != null),             &quot;explicitEncoding must be null if strategy is EncodingStrategy.DEFAULT&quot;); //$NON-NLS-1$          encodingStrategy = strategy;         this.explicitEncoding = explicitEncoding;     }      /**      * Gets the encoding resolution strategy. If the returned strategy is not      * EncodingStrategy.DEFAULT, call getExplicitEncoding() to get the encoding      * to be used for the strategy.      *      * @return the encoding resolution strategy.      */     public EncodingStrategy getEncodingStrategy() {         return encodingStrategy;     }      /**      * Gets the explicit encoding set previously as part of setting an encoding      * strategy.      *      * @return the encoding to use as part of the encoding resolution strategy,      *         null if not set or if the strategy was EncodingStrategy.DEFAULT.      */     public FileEncoding getExplicitEncoding() {         return explicitEncoding;     }      public void setUseInternalEngine(final boolean useInternalEngine) {         this.useInternalEngine = useInternalEngine;     }      public boolean useInternalEngine() {         return useInternalEngine;     }      /**      * When a conflict is to be resolved with the AcceptMerge resolution and      * there is a conflicting pending encoding change, the given encoding will      * be used (no file conversion is done). If the given encoding is null, the      * conflict will not be resolved.      *      * @param encoding      *        the encoding to use when an automatic merge is desired and there      *        is a conflicting pending change.      */     public void setAcceptMergeEncoding(final FileEncoding encoding) {         acceptMergeEncoding = encoding;     }      /**      * Gets the encoding to use when an AcceptMerge resolution is desired but      * there is a conflicting pending encoding change. If null is returned, the      * encoding should be unchanged.      *      * @return the encoding to use to resolve the case where AcceptMerge must      *         operate on a file with a conflicting pending encoding change,      *         null if the encoding should be unchanged.      */     public FileEncoding getAcceptMergeEncoding() {         return acceptMergeEncoding;     }      /**      * When a conflict is to be resolved with the AcceptMerge resolution and      * there is a conflicting pending property change, this property contains      * the desired properties. If this property is left as null, the conflict      * will not be resolved.      */     public PropertyValue[] getAcceptMergeProperties() {         return acceptMergeProperties;     }      public void setAcceptMergeProperties(final PropertyValue[] acceptMergeProperties) {         this.acceptMergeProperties = acceptMergeProperties;     }      /**      * Sets the new path for a conflicted item or the item in its way when it      * needs needs to move to a new location. This may happen in cases like      * these:      *      * Merge conflict with AcceptMerge chosen, and there's a conflicting pending      * rename: set the desired name. If null, the conflict will not be resolved.      *      * Namespace conflict with AcceptTheirs: set the path that would describe      * their item.      *      * Namespace conflict with AcceptYours: set to the path of the local item      * that was in the way of the server item.      *      * @param newPath      *        the path to use for this conflict resolution, null to defer the      *        resolution in the cases documented above.      */     public void setNewPath(final String newPath) {         this.newPath = newPath;     }      /**      * Gets the new path to use for this resolution. See setNewPath() comments      * for details.      *      * @return the new path, null if not set.      */     public String getNewPath() {         return newPath;     }      /**      * @return true if a merge should be resolved when conflicts remain in the      *         file, false if the merge should not be resolved when conflicts      *         remain      */     public boolean isAcceptMergeWithConflicts() {         return acceptMergeWithConflicts;     }      /**      * Sets the option to accept (resolve a conflict) when the merge resulted in      * conflicts.      *      * @param mergeWithConflicts      *        true if a merge should be resolved when conflicts remain in the      *        file, false if the merge should not be resolved when conflicts      *        remain      */     public void setAcceptMergeWithConflicts(final boolean mergeWithConflicts) {         acceptMergeWithConflicts = mergeWithConflicts;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. long method, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10475</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core/src/com/microsoft/tfs/core/clients/versioncontrol/ResolutionOptions.java/#L17-L213</td>
    <td align="right">1</td>
    <td align="right">1254</td>
    <td align="right">10475</td>
  </tr>
  <tr valign="top">
    <td align="right">3920</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{          &quot;output&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ServletContextAttributeFactoryBean implements FactoryBean, ServletContextAware {  	@Nullable 	private String attributeName;  	@Nullable 	private Object attribute;   	/** 	 * Set the name of the ServletContext attribute to expose. 	 */ 	public void setAttributeName(String attributeName) { 		this.attributeName = attributeName; 	}  	@Override 	public void setServletContext(ServletContext servletContext) { 		if (this.attributeName == null) { 			throw new IllegalArgumentException(&quot;Property 'attributeName' is required&quot;); 		} 		this.attribute = servletContext.getAttribute(this.attributeName); 		if (this.attribute == null) { 			throw new IllegalStateException(&quot;No ServletContext attribute '&quot; + this.attributeName + &quot;' found&quot;); 		} 	}   	@Override 	@Nullable 	public Object getObject() throws Exception { 		return this.attribute; 	}  	@Override 	public Class getObjectType() { 		return (this.attribute != null ? this.attribute.getClass() : null); 	}  	@Override 	public boolean isSingleton() { 		return true; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10262</td>
    <td align="left">https://github.com/spring-projects/spring-framework/blob/3a0f309e2c9fdbbf7fb2d348be861528177f8555/spring-web/src/main/java/org/springframework/web/context/support/ServletContextAttributeFactoryBean.java/#L45-L89</td>
    <td align="right">1</td>
    <td align="right">3920</td>
    <td align="right">10262</td>
  </tr>
  <tr valign="top">
    <td align="right">1992</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class EnsemblExonVO extends EnsemblDBBaseVO {      @JsonProperty(value = &quot;version&quot;)     private Integer version;      @JsonProperty(value = &quot;assembly_name&quot;)     private String assemblyName;      @JsonProperty(value = &quot;seq_region_name&quot;)     private String seqRegionName;      @JsonProperty(value = &quot;strand&quot;)     private String strand;      public Integer getVersion() {         return version;     }      public void setVersion(Integer version) {         this.version = version;     }      public String getAssemblyName() {         return assemblyName;     }      public void setAssemblyName(String assemblyName) {         this.assemblyName = assemblyName;     }      public String getSeqRegionName() {         return seqRegionName;     }      public void setSeqRegionName(String seqRegionName) {         this.seqRegionName = seqRegionName;     }      public String getStrand() {         return strand;     }      public void setStrand(String strand) {         this.strand = strand;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12687</td>
    <td align="left">https://github.com/epam/NGB/blob/340504529fc576eeec92fbae636e437ce486cc4a/server/catgenome/src/main/java/com/epam/catgenome/controller/vo/externaldb/ensemblevo/EnsemblExonVO.java/#L40-L85</td>
    <td align="right">1</td>
    <td align="right">1992</td>
    <td align="right">12687</td>
  </tr>
  <tr valign="top">
    <td align="right">2253</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [       &quot;Data Class&quot;     ]   } </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@JacksonXmlRootElement @JsonIgnoreProperties(ignoreUnknown = true) public class User implements Serializable {      private static final long serialVersionUID = 4247427179764560935L;      private Integer id;     private String username;     private String name;     @JsonProperty(&quot;first_name&quot;)     private String firstName;     @JsonProperty(&quot;last_name&quot;)     private String lastName;     private String email;     private String url;     private String description;     private String link;     private String locale;     private String nickname;     private String slug;     @JsonProperty(&quot;registered_date&quot;)     private String registeredDate;     private List roles;     private Map capabilities;     @JsonProperty(&quot;extra_capabilities&quot;)     private Map extraCapabilities;     @JsonProperty(&quot;avatar_urls&quot;)     private Map avatarUrls;     @JsonProperty(&quot;meta&quot;)     private List&gt; meta;      public User() {      }      public Integer getId() {         return id;     }      public void setId(Integer id) {         this.id = id;     }      public String getUsername() {         return username;     }      public void setUsername(String username) {         this.username = username;     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public String getFirstName() {         return firstName;     }      public void setFirstName(String firstName) {         this.firstName = firstName;     }      public String getLastName() {         return lastName;     }      public void setLastName(String lastName) {         this.lastName = lastName;     }      public String getEmail() {         return email;     }      public void setEmail(String email) {         this.email = email;     }      public String getUrl() {         return url;     }      public void setUrl(String url) {         this.url = url;     }      public String getDescription() {         return description;     }      public void setDescription(String description) {         this.description = description;     }      public String getLink() {         return link;     }      public void setLink(String link) {         this.link = link;     }      public String getLocale() {         return locale;     }      public void setLocale(String locale) {         this.locale = locale;     }      public String getNickname() {         return nickname;     }      public void setNickname(String nickname) {         this.nickname = nickname;     }      public String getSlug() {         return slug;     }      public void setSlug(String slug) {         this.slug = slug;     }      public String getRegisteredDate() {         return registeredDate;     }      public void setRegisteredDate(String registeredDate) {         this.registeredDate = registeredDate;     }      public List getRoles() {         return roles;     }      public void setRoles(List roles) {         this.roles = roles;     }      public Map getCapabilities() {         return capabilities;     }      public void setCapabilities(Map capabilities) {         this.capabilities = capabilities;     }      public Map getExtraCapabilities() {         return extraCapabilities;     }      public void setExtraCapabilities(Map extraCapabilities) {         this.extraCapabilities = extraCapabilities;     }      public Map getAvatarUrls() {         return avatarUrls;     }      public void setAvatarUrls(Map avatarUrls) {         this.avatarUrls = avatarUrls;     }      public List&gt; getMeta() {         return meta;     }      public void setMeta(List&gt; meta) {         this.meta = meta;     }      @Override     public String toString() {         return toStringHelper(this).addValue(this.id).addValue(this.username).addValue(this.email).addValue(this.name).toString();     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13685</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-wordpress/src/main/java/org/apache/camel/component/wordpress/api/model/User.java/#L29-L213</td>
    <td align="right">1</td>
    <td align="right">2253</td>
    <td align="right">13685</td>
  </tr>
  <tr valign="top">
    <td align="right">1171</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{           &quot;message&quot;: &quot;YES I found bad smells&quot;,           &quot;bad smells are&quot;: [               &quot;Data Class&quot;,               &quot;Long Method&quot;           ]       }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @Immutable     private static final class NumberLiteralNode extends PrimitiveLiteralNode {         private static final long serialVersionUID = 1L;          private final Type type = numberGetType(value);          private NumberLiteralNode(final long token, final int finish, final Number value) {             super(Token.recast(token, TokenType.DECIMAL), finish, value);         }          private NumberLiteralNode(final NumberLiteralNode literalNode) {             super(literalNode);         }          private static Type numberGetType(final Number number) {             if (number instanceof Integer) {                 return Type.INT;             } else if (number instanceof Double) {                 return Type.NUMBER;             } else {                 assert false;             }              return null;         }          @Override         public Type getType() {             return type;         }          @Override         public Type getWidestOperationType() {             return getType();         }      }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10196</td>
    <td align="left">https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/ir/LiteralNode.java/#L373-L409</td>
    <td align="right">1</td>
    <td align="right">1171</td>
    <td align="right">10196</td>
  </tr>
  <tr valign="top">
    <td align="right">2080</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad_smells&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class DAOAttachment {         private final AttachmentId attachmentId;         private final BlobId blobId;         private final String type;         private final long size;          private DAOAttachment(AttachmentId attachmentId, BlobId blobId, String type, long size) {             this.attachmentId = attachmentId;             this.blobId = blobId;             this.type = type;             this.size = size;         }          public AttachmentId getAttachmentId() {             return attachmentId;         }          public BlobId getBlobId() {             return blobId;         }          public String getType() {             return type;         }          public long getSize() {             return size;         }          public Attachment toAttachment(byte[] data) {             return Attachment.builder()                 .attachmentId(attachmentId)                 .type(type)                 .bytes(data)                 .build();         }          @Override         public final boolean equals(Object o) {             if (o instanceof DAOAttachment) {                 DAOAttachment that = (DAOAttachment) o;                  return Objects.equals(this.size, that.size)                     &amp;&amp; Objects.equals(this.attachmentId, that.attachmentId)                     &amp;&amp; Objects.equals(this.blobId, that.blobId)                     &amp;&amp; Objects.equals(this.type, that.type);             }             return false;         }          @Override         public final int hashCode() {             return Objects.hash(attachmentId, blobId, type, size);         }     }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13068</td>
    <td align="left">https://github.com/apache/james-project/blob/fa24a096a5853459c3769a34ccc68feb91626bfa/mailbox/cassandra/src/main/java/org/apache/james/mailbox/cassandra/mail/CassandraAttachmentDAOV2.java/#L50-L104</td>
    <td align="right">1</td>
    <td align="right">2080</td>
    <td align="right">13068</td>
  </tr>
  <tr valign="top">
    <td align="right">2627</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class InstantiatedVersionedLabel extends VersionedLabel implements InstantiatedVersionedComponent {     private final String instanceId;     private final String groupId;      public InstantiatedVersionedLabel(final String instanceId, final String instanceGroupId) {         this.instanceId = instanceId;         this.groupId = instanceGroupId;     }      @Override     public String getInstanceId() {         return instanceId;     }      @Override     public String getInstanceGroupId() {         return groupId;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15086</td>
    <td align="left">https://github.com/apache/nifi/blob/c8eff590efa3babcda0b755009224dcac168708b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/registry/flow/mapping/InstantiatedVersionedLabel.java/#L22-L40</td>
    <td align="right">1</td>
    <td align="right">2627</td>
    <td align="right">15086</td>
  </tr>
  <tr valign="top">
    <td align="right">1505</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
        static class Event {              final Type type;             final TruffleFile file;             final IOException ioe;             final BasicFileAttributes attrs;              Event(Type type, TruffleFile file, BasicFileAttributes attrs) {                 this.type = type;                 this.file = file;                 this.attrs = attrs;                 this.ioe = null;             }              Event(Type type, TruffleFile file, IOException ioe) {                 this.type = type;                 this.file = file;                 this.attrs = null;                 this.ioe = ioe;             }              enum Type {                 PRE_VISIT_DIRECTORY,                 VISIT,                 POST_VISIT_DIRECTORY             }         }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11149</td>
    <td align="left">https://github.com/oracle/graal/blob/4deb681aaaa79c248115037fc8e399c9876619fd/truffle/src/com.oracle.truffle.api/src/com/oracle/truffle/api/TruffleFile.java/#L1837-L1863</td>
    <td align="right">1</td>
    <td align="right">1505</td>
    <td align="right">11149</td>
  </tr>
  <tr valign="top">
    <td align="right">602</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;,  &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class Statement extends RoleElt {      @JsonProperty(&quot;Sid&quot;)     public String sid = newSid();      /**      * Default effect is Deny; forces callers to switch on Allow.      */     @JsonProperty(&quot;Effect&quot;)     public Effects effect;      @JsonProperty(&quot;Action&quot;)     public List action = new ArrayList&lt;&gt;(1);      @JsonProperty(&quot;Resource&quot;)     public List resource = new ArrayList&lt;&gt;(1);      public Statement(final Effects effect) {       this.effect = effect;     }      @Override     public void validate() {       requireNonNull(sid, &quot;Sid&quot;);       requireNonNull(effect, &quot;Effect&quot;);       checkState(!(action.isEmpty()), &quot;Empty Action&quot;);       checkState(!(resource.isEmpty()), &quot;Empty Resource&quot;);     }      public Statement setAllowed(boolean f) {       effect = effect(f);       return this;     }      public Statement addActions(String... actions) {       Collections.addAll(action, actions);       return this;     }      public Statement addActions(Collection actions) {       action.addAll(actions);       return this;     }      public Statement addResources(String... resources) {       Collections.addAll(resource, resources);       return this;     }      /**      * Add a list of resources.      * @param resources resource list      * @return this statement.      */     public Statement addResources(Collection resources) {       resource.addAll(resources);       return this;     }   }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6009</td>
    <td align="left">https://github.com/apache/hadoop/blob/128dd91e10080bdcbcd7d555fa3c4105e55a6b51/hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/auth/RoleModel.java/#L284-L342</td>
    <td align="right">1</td>
    <td align="right">602</td>
    <td align="right">6009</td>
  </tr>
  <tr valign="top">
    <td align="right">2047</td>
    <td align="left">&nbsp;&nbsp;YES I found bad smells the bad smells are: 1. Long method 2. Data class 3. Primitive obsession 4. Feature envy 5. Dead code 6. Inconsistent indentation 7. Magic numbers 8. Code duplication 9. Large parameter list 10. Improper naming conventions </td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
@SuppressWarnings(&quot;serial&quot;) public class ForeignKeyInfo implements Serializable {    public class ForeignKeyCol {     public String parentTableName;     public String parentDatabaseName;     public String parentColName;     public String childColName;     public Integer position;      public ForeignKeyCol(String parentTableName, String parentDatabaseName, String parentColName,       String childColName, Integer position) {       this.parentTableName = parentTableName;       this.parentDatabaseName = parentDatabaseName;       this.parentColName = parentColName;       this.childColName = childColName;       this.position = position;     }   }    // Mapping from constraint name to list of foreign keys   Map&gt; foreignKeys;   String childTableName;   String childDatabaseName;    public ForeignKeyInfo() {}    public ForeignKeyInfo(List fks, String childTableName, String childDatabaseName) {     this.childTableName = childTableName;     this.childDatabaseName = childDatabaseName;     foreignKeys = new TreeMap&gt;();     if (fks == null) {       return;     }     for (SQLForeignKey fk : fks) {       if (fk.getFktable_db().equalsIgnoreCase(childDatabaseName) &amp;&amp;           fk.getFktable_name().equalsIgnoreCase(childTableName)) {         ForeignKeyCol currCol = new ForeignKeyCol(fk.getPktable_name(), fk.getPktable_db(),           fk.getPkcolumn_name(), fk.getFkcolumn_name(), fk.getKey_seq());         String constraintName = fk.getFk_name();         if (foreignKeys.containsKey(constraintName)) {           foreignKeys.get(constraintName).add(currCol);         } else {           List currList = new ArrayList();           currList.add(currCol);           foreignKeys.put(constraintName, currList);         }       }     }   }    public String getChildTableName() {     return childTableName;   }    public String getChildDatabaseName() {     return childDatabaseName;   }    public Map&gt; getForeignKeys() {     return foreignKeys;   }    public void setChildTableName(String tableName) {     this.childTableName = tableName;   }    public void setChildDatabaseName(String databaseName) {     this.childDatabaseName = databaseName;   }    public void setForeignKeys(Map&gt; foreignKeys) {     this.foreignKeys = foreignKeys;   }    @Override   public String toString() {     StringBuilder sb = new StringBuilder();     sb.append(&quot;Foreign Keys for &quot; + childDatabaseName+&quot;.&quot;+childTableName+&quot;:&quot;);     sb.append(&quot;[&quot;);     if (foreignKeys != null &amp;&amp; foreignKeys.size() &gt; 0) {       for (Map.Entry&gt; me : foreignKeys.entrySet()) {         sb.append(&quot; {Constraint Name: &quot; + me.getKey() + &quot;,&quot;);         List currCol = me.getValue();         if (currCol != null &amp;&amp; currCol.size() &gt; 0) {           for (ForeignKeyCol fkc : currCol) {             sb.append (&quot; (Parent Column Name: &quot; + fkc.parentDatabaseName +               &quot;.&quot;+ fkc.parentTableName + &quot;.&quot; + fkc.parentColName +               &quot;, Column Name: &quot; + fkc.childColName + &quot;, Key Sequence: &quot; + fkc.position+ &quot;),&quot;);           }           sb.setLength(sb.length()-1);         }         sb.append(&quot;},&quot;);       }       sb.setLength(sb.length()-1);     }     sb.append(&quot;]&quot;);     return sb.toString();   } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method2 Data class3 Primitive obsession4 Feature envy5 Dead code6 Inconsistent indentation7 Magic numbers8 Code duplication9 Large parameter list</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12877</td>
    <td align="left">https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/ql/src/java/org/apache/hadoop/hive/ql/metadata/ForeignKeyInfo.java/#L37-L136</td>
    <td align="right">2</td>
    <td align="right">2047</td>
    <td align="right">12877</td>
  </tr>
  <tr valign="top">
    <td align="right">1444</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells the bad smells are: 1. Data Class&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public static class Undertow {  		/** 		 * Maximum size of the HTTP post content. When the value is -1, the default, the 		 * size is unlimited. 		 */ 		private DataSize maxHttpPostSize = DataSize.ofBytes(-1);  		/** 		 * Size of each buffer. The default is derived from the maximum amount of memory 		 * that is available to the JVM. 		 */ 		private DataSize bufferSize;  		/** 		 * Number of I/O threads to create for the worker. The default is derived from the 		 * number of available processors. 		 */ 		private Integer ioThreads;  		/** 		 * Number of worker threads. The default is 8 times the number of I/O threads. 		 */ 		private Integer workerThreads;  		/** 		 * Whether to allocate buffers outside the Java heap. The default is derived from 		 * the maximum amount of memory that is available to the JVM. 		 */ 		private Boolean directBuffers;  		/** 		 * Whether servlet filters should be initialized on startup. 		 */ 		private boolean eagerFilterInit = true;  		private final Accesslog accesslog = new Accesslog();  		public DataSize getMaxHttpPostSize() { 			return this.maxHttpPostSize; 		}  		public void setMaxHttpPostSize(DataSize maxHttpPostSize) { 			this.maxHttpPostSize = maxHttpPostSize; 		}  		public DataSize getBufferSize() { 			return this.bufferSize; 		}  		public void setBufferSize(DataSize bufferSize) { 			this.bufferSize = bufferSize; 		}  		public Integer getIoThreads() { 			return this.ioThreads; 		}  		public void setIoThreads(Integer ioThreads) { 			this.ioThreads = ioThreads; 		}  		public Integer getWorkerThreads() { 			return this.workerThreads; 		}  		public void setWorkerThreads(Integer workerThreads) { 			this.workerThreads = workerThreads; 		}  		public Boolean getDirectBuffers() { 			return this.directBuffers; 		}  		public void setDirectBuffers(Boolean directBuffers) { 			this.directBuffers = directBuffers; 		}  		public boolean isEagerFilterInit() { 			return this.eagerFilterInit; 		}  		public void setEagerFilterInit(boolean eagerFilterInit) { 			this.eagerFilterInit = eagerFilterInit; 		}  		public Accesslog getAccesslog() { 			return this.accesslog; 		}  		/** 		 * Undertow access log properties. 		 */ 		public static class Accesslog {  			/** 			 * Whether to enable the access log. 			 */ 			private boolean enabled = false;  			/** 			 * Format pattern for access logs. 			 */ 			private String pattern = &quot;common&quot;;  			/** 			 * Log file name prefix. 			 */ 			protected String prefix = &quot;access_log.&quot;;  			/** 			 * Log file name suffix. 			 */ 			private String suffix = &quot;log&quot;;  			/** 			 * Undertow access log directory. 			 */ 			private File dir = new File(&quot;logs&quot;);  			/** 			 * Whether to enable access log rotation. 			 */ 			private boolean rotate = true;  			public boolean isEnabled() { 				return this.enabled; 			}  			public void setEnabled(boolean enabled) { 				this.enabled = enabled; 			}  			public String getPattern() { 				return this.pattern; 			}  			public void setPattern(String pattern) { 				this.pattern = pattern; 			}  			public String getPrefix() { 				return this.prefix; 			}  			public void setPrefix(String prefix) { 				this.prefix = prefix; 			}  			public String getSuffix() { 				return this.suffix; 			}  			public void setSuffix(String suffix) { 				this.suffix = suffix; 			}  			public File getDir() { 				return this.dir; 			}  			public void setDir(File dir) { 				this.dir = dir; 			}  			public boolean isRotate() { 				return this.rotate; 			}  			public void setRotate(boolean rotate) { 				this.rotate = rotate; 			}  		}  	}</td>
    <td align="left">data class</td>
    <td align="left">1. data class </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10980</td>
    <td align="left">https://github.com/spring-projects/spring-boot/blob/2225b362991f225e3a93f00e160526d2b8abdfb2/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java/#L949-L1124</td>
    <td align="right">1</td>
    <td align="right">1444</td>
    <td align="right">10980</td>
  </tr>
  <tr valign="top">
    <td align="right">441</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;,  &quot;bad smells are&quot;:   [&quot;Long Method&quot;,   &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class FieldAttributeModel {    /** Typescript value of the type of the field */   private final String typeName;    /** For Map, List object, need to initialize field first. Like new Field&lt;&gt;() */   private boolean needInitialize;    /** Name of the field */   private String fieldName;    /** Java Type of the object (used internally) */   private Type type;    /** This field type is a List of objects ? */   private boolean isList;    /** This field type is a simple primitive */   private boolean isPrimitive;    /** This field type is a map */   private boolean isMap;    /** This list type is in fact a list of DTOs */   private boolean isListOfDto;    /** This map type is a map of DTOs */   private boolean isMapOfDto;    /**    * The type is a DTO or a list of DTO and then this value is the name of the DTO implementation    */   private String dtoImpl;    /** type is a DTO object. */   private boolean isDto;    /** type is a Enum object. */   private boolean isEnum;    /** Map key type */   private String mapKeyType;    /** Map value type */   private String mapValueType;    /** Dto type for d.ts */   private String dtsType;    /** Dto class where this field declared */   private Class declarationClass;    /**    * Build a new field model based on the name and Java type    *    * @param fieldName the name of the field    * @param type the Java raw type that will allow further analyzes    * @param declarationClass    */   public FieldAttributeModel(String fieldName, Type type, Class declarationClass) {     this.fieldName = fieldName;     this.type = type;     this.typeName = convertType(type);     this.dtsType = convertTypeForDTS(declarationClass, type);     this.declarationClass = declarationClass;      if (typeName.startsWith(&quot;Array&lt;&quot;) || typeName.startsWith(&quot;Map&lt;&quot;)) {       this.needInitialize = true;     }      if (this.type instanceof ParameterizedType) {       ParameterizedType parameterizedType = (ParameterizedType) this.type;       Type rawType = parameterizedType.getRawType();       analyzeParametrizedType(parameterizedType, rawType);     } else if (Primitives.isPrimitive(this.type)         || Primitives.isWrapperType(this.type)         || String.class.equals(this.type)) {       this.isPrimitive = true;     } else if (this.type instanceof Class &amp;&amp; ((Class) this.type).isAnnotationPresent(DTO.class)) {       this.isDto = true;       dtoImpl = this.type.getTypeName() + &quot;Impl&quot;;     } else if (this.type instanceof Class &amp;&amp; ((Class) this.type).isEnum()) {       this.isEnum = true;     }   }    /**    * Analyze a complex parametrized type attribute (which can be a list or map for example)    *    * @param parameterizedType    * @param rawType    */   protected void analyzeParametrizedType(ParameterizedType parameterizedType, Type rawType) {     if (List.class.equals(rawType)) {       this.isList = true;       if (parameterizedType.getActualTypeArguments()[0] instanceof Class           &amp;&amp; ((Class) parameterizedType.getActualTypeArguments()[0])               .isAnnotationPresent(DTO.class)) {         isListOfDto = true;         dtoImpl = convertType(parameterizedType.getActualTypeArguments()[0]) + &quot;Impl&quot;;       }     } else if (Map.class.equals(rawType)) {       isMap = true;       mapKeyType =           convertTypeForDTS(declarationClass, parameterizedType.getActualTypeArguments()[0]);       if (parameterizedType.getActualTypeArguments()[1] instanceof Class           &amp;&amp; ((Class) parameterizedType.getActualTypeArguments()[1])               .isAnnotationPresent(DTO.class)) {          isMapOfDto = true;         dtoImpl = convertType(parameterizedType.getActualTypeArguments()[1]) + &quot;Impl&quot;;       }        mapValueType =           convertTypeForDTS(declarationClass, parameterizedType.getActualTypeArguments()[1]);     }   }    public String getTypeName() {     return typeName;   }    public String getFieldName() {     return fieldName;   }    public Type getType() {     return type;   }    public boolean isList() {     return isList;   }    public boolean isPrimitive() {     return isPrimitive;   }    public boolean isMap() {     return isMap;   }    public boolean isListOfDto() {     return isListOfDto;   }    public boolean isMapOfDto() {     return isMapOfDto;   }    public String getDtoImpl() {     return dtoImpl;   }    public boolean isDto() {     return isDto;   }    public boolean isNeedInitialize() {     return needInitialize;   }    public boolean isEnum() {     return isEnum;   }    public String getName() {     return this.fieldName;   }    public String getSimpleType() {     return this.typeName;   }    public String getMapKeyType() {     return mapKeyType;   }    public String getMapValueType() {     return mapValueType;   }    public String getDtsType() {     return dtsType;   } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">4302</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/core/che-core-typescript-dto-maven-plugin/src/main/java/org/eclipse/che/plugin/typescript/dto/model/FieldAttributeModel.java/#L29-L214</td>
    <td align="right">1</td>
    <td align="right">441</td>
    <td align="right">4302</td>
  </tr>
  <tr valign="top">
    <td align="right">2066</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Config {      public String mysqlAddr;     public Integer mysqlPort;     public String mysqlUsername;     public String mysqlPassword;      public String mqNamesrvAddr;     public String mqTopic;      public String startType = &quot;DEFAULT&quot;;     public String binlogFilename;     public Long nextPosition;     public Integer maxTransactionRows = 100;      public void load() throws IOException {          InputStream in = Config.class.getClassLoader().getResourceAsStream(&quot;rocketmq_mysql.conf&quot;);         Properties properties = new Properties();         properties.load(in);          properties2Object(properties, this);      }      private void properties2Object(final Properties p, final Object object) {         Method[] methods = object.getClass().getMethods();         for (Method method : methods) {             String mn = method.getName();             if (mn.startsWith(&quot;set&quot;)) {                 try {                     String tmp = mn.substring(4);                     String first = mn.substring(3, 4);                      String key = first.toLowerCase() + tmp;                     String property = p.getProperty(key);                     if (property != null) {                         Class[] pt = method.getParameterTypes();                         if (pt != null &amp;&amp; pt.length &gt; 0) {                             String cn = pt[0].getSimpleName();                             Object arg;                             if (cn.equals(&quot;int&quot;) || cn.equals(&quot;Integer&quot;)) {                                 arg = Integer.parseInt(property);                             } else if (cn.equals(&quot;long&quot;) || cn.equals(&quot;Long&quot;)) {                                 arg = Long.parseLong(property);                             } else if (cn.equals(&quot;double&quot;) || cn.equals(&quot;Double&quot;)) {                                 arg = Double.parseDouble(property);                             } else if (cn.equals(&quot;boolean&quot;) || cn.equals(&quot;Boolean&quot;)) {                                 arg = Boolean.parseBoolean(property);                             } else if (cn.equals(&quot;float&quot;) || cn.equals(&quot;Float&quot;)) {                                 arg = Float.parseFloat(property);                             } else if (cn.equals(&quot;String&quot;)) {                                 arg = property;                             } else {                                 continue;                             }                             method.invoke(object, arg);                         }                     }                 } catch (Throwable ignored) {                 }             }         }     }      public void setMysqlAddr(String mysqlAddr) {         this.mysqlAddr = mysqlAddr;     }      public void setMysqlPort(Integer mysqlPort) {         this.mysqlPort = mysqlPort;     }      public void setMysqlUsername(String mysqlUsername) {         this.mysqlUsername = mysqlUsername;     }      public void setMysqlPassword(String mysqlPassword) {         this.mysqlPassword = mysqlPassword;     }      public void setBinlogFilename(String binlogFilename) {         this.binlogFilename = binlogFilename;     }      public void setNextPosition(Long nextPosition) {         this.nextPosition = nextPosition;     }      public void setMaxTransactionRows(Integer maxTransactionRows) {         this.maxTransactionRows = maxTransactionRows;     }      public void setMqNamesrvAddr(String mqNamesrvAddr) {         this.mqNamesrvAddr = mqNamesrvAddr;     }      public void setMqTopic(String mqTopic) {         this.mqTopic = mqTopic;     }      public void setStartType(String startType) {         this.startType = startType;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12994</td>
    <td align="left">https://github.com/apache/rocketmq-externals/blob/dba6eb0c997d5c325f26b3d1da9d739d927228dc/rocketmq-mysql/src/main/java/org/apache/rocketmq/mysql/Config.java/#L26-L130</td>
    <td align="right">1</td>
    <td align="right">2066</td>
    <td align="right">12994</td>
  </tr>
  <tr valign="top">
    <td align="right">1769</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@InterfaceAudience.Private public class HFileBlockDefaultEncodingContext implements     HFileBlockEncodingContext {   private BlockType blockType;   private final DataBlockEncoding encodingAlgo;    private byte[] dummyHeader;    // Compression state    /** Compressor, which is also reused between consecutive blocks. */   private Compressor compressor;   /** Compression output stream */   private CompressionOutputStream compressionStream;   /** Underlying stream to write compressed bytes to */   private ByteArrayOutputStream compressedByteStream;    private HFileContext fileContext;   private TagCompressionContext tagCompressionContext;    // Encryption state    /** Underlying stream to write encrypted bytes to */   private ByteArrayOutputStream cryptoByteStream;   /** Initialization vector */   private byte[] iv;    private EncodingState encoderState;    /**    * @param encoding encoding used    * @param headerBytes dummy header bytes    * @param fileContext HFile meta data    */   public HFileBlockDefaultEncodingContext(DataBlockEncoding encoding, byte[] headerBytes,       HFileContext fileContext) {     this.encodingAlgo = encoding;     this.fileContext = fileContext;     Compression.Algorithm compressionAlgorithm =         fileContext.getCompression() == null ? NONE : fileContext.getCompression();     if (compressionAlgorithm != NONE) {       compressor = compressionAlgorithm.getCompressor();       compressedByteStream = new ByteArrayOutputStream();       try {         compressionStream =             compressionAlgorithm.createPlainCompressionStream(                 compressedByteStream, compressor);       } catch (IOException e) {         throw new RuntimeException(             &quot;Could not create compression stream for algorithm &quot;                 + compressionAlgorithm, e);       }     }      Encryption.Context cryptoContext = fileContext.getEncryptionContext();     if (cryptoContext != Encryption.Context.NONE) {       cryptoByteStream = new ByteArrayOutputStream();       iv = new byte[cryptoContext.getCipher().getIvLength()];       new SecureRandom().nextBytes(iv);     }      dummyHeader = Preconditions.checkNotNull(headerBytes,       &quot;Please pass HConstants.HFILEBLOCK_DUMMY_HEADER instead of null for param headerBytes&quot;);   }    /**    * prepare to start a new encoding.    * @throws IOException    */   public void prepareEncoding(DataOutputStream out) throws IOException {     if (encodingAlgo != null &amp;&amp; encodingAlgo != DataBlockEncoding.NONE) {       encodingAlgo.writeIdInBytes(out);     }   }    @Override   public void postEncoding(BlockType blockType)       throws IOException {     this.blockType = blockType;   }    @Override   public Bytes compressAndEncrypt(byte[] data, int offset, int length) throws IOException {     return compressAfterEncoding(data, offset, length, dummyHeader);   }    private Bytes compressAfterEncoding(byte[] uncompressedBytesWithHeaderBuffer,         int uncompressedBytesWithHeaderOffset, int uncompressedBytesWithHeaderLength, byte[] headerBytes)       throws IOException {     Encryption.Context cryptoContext = fileContext.getEncryptionContext();     if (cryptoContext != Encryption.Context.NONE) {        // Encrypted block format:       // +--------------------------+       // | byte iv length           |       // +--------------------------+       // | iv data ...              |       // +--------------------------+       // | encrypted block data ... |       // +--------------------------+        cryptoByteStream.reset();       // Write the block header (plaintext)       cryptoByteStream.write(headerBytes);        InputStream in;       int plaintextLength;       // Run any compression before encryption       if (fileContext.getCompression() != Compression.Algorithm.NONE) {         compressedByteStream.reset();         compressionStream.resetState();         compressionStream.write(uncompressedBytesWithHeaderBuffer,             headerBytes.length + uncompressedBytesWithHeaderOffset, uncompressedBytesWithHeaderLength - headerBytes.length);         compressionStream.flush();         compressionStream.finish();         byte[] plaintext = compressedByteStream.toByteArray();         plaintextLength = plaintext.length;         in = new ByteArrayInputStream(plaintext);       } else {         plaintextLength = uncompressedBytesWithHeaderLength - headerBytes.length;         in = new ByteArrayInputStream(uncompressedBytesWithHeaderBuffer,           headerBytes.length + uncompressedBytesWithHeaderOffset, plaintextLength);       }        if (plaintextLength &gt; 0) {          // Set up the cipher         Cipher cipher = cryptoContext.getCipher();         Encryptor encryptor = cipher.getEncryptor();         encryptor.setKey(cryptoContext.getKey());          // Set up the IV         int ivLength = iv.length;         Preconditions.checkState(ivLength &lt;= Byte.MAX_VALUE, &quot;IV length out of range&quot;);         cryptoByteStream.write(ivLength);         if (ivLength &gt; 0) {           encryptor.setIv(iv);           cryptoByteStream.write(iv);         }          // Encrypt the data         Encryption.encrypt(cryptoByteStream, in, encryptor);          // Increment the IV given the final block size         Encryption.incrementIv(iv, 1 + (cryptoByteStream.size() / encryptor.getBlockSize()));         return new Bytes(cryptoByteStream.getBuffer(), 0, cryptoByteStream.size());       } else {          cryptoByteStream.write(0);         return new Bytes(cryptoByteStream.getBuffer(), 0, cryptoByteStream.size());       }      } else {        if (this.fileContext.getCompression() != NONE) {         compressedByteStream.reset();         compressedByteStream.write(headerBytes);         compressionStream.resetState();         compressionStream.write(uncompressedBytesWithHeaderBuffer,           headerBytes.length + uncompressedBytesWithHeaderOffset, uncompressedBytesWithHeaderLength               - headerBytes.length);         compressionStream.flush();         compressionStream.finish();         return new Bytes(compressedByteStream.getBuffer(), 0, compressedByteStream.size());       } else {         return null;       }     }   }    @Override   public BlockType getBlockType() {     return blockType;   }    /**    * Releases the compressor this writer uses to compress blocks into the    * compressor pool.    */   @Override   public void close() {     if (compressor != null) {       this.fileContext.getCompression().returnCompressor(compressor);       compressor = null;     }   }    @Override   public DataBlockEncoding getDataBlockEncoding() {     return this.encodingAlgo;   }    @Override   public HFileContext getHFileContext() {     return this.fileContext;   }    public TagCompressionContext getTagCompressionContext() {     return tagCompressionContext;   }    public void setTagCompressionContext(TagCompressionContext tagCompressionContext) {     this.tagCompressionContext = tagCompressionContext;   }    @Override   public EncodingState getEncodingState() {     return this.encoderState;   }    @Override   public void setEncodingState(EncodingState state) {     this.encoderState = state;   } }</td>
    <td align="left">data class</td>
    <td align="left">Data Class, Long Method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11918</td>
    <td align="left">https://github.com/apache/hbase/blob/44f8abd5c65c59e9d09f6ad14b3c825f145d8e4f/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/HFileBlockDefaultEncodingContext.java/#L49-L263</td>
    <td align="right">1</td>
    <td align="right">1769</td>
    <td align="right">11918</td>
  </tr>
  <tr valign="top">
    <td align="right">1640</td>
    <td align="left">{&quot;message&quot;:&quot;YES I found bad smells&quot;,&quot;the bad smells are&quot;:[&quot;Data Class&quot;,&quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SeekableXZInputStream extends SeekableInputStream {     /**      * Cache for big arrays.      */     private final ArrayCache arrayCache;      /**      * The input stream containing XZ compressed data.      */     private SeekableInputStream in;      /**      * Memory usage limit after the memory usage of the IndexDecoders have      * been substracted.      */     private final int memoryLimit;      /**      * Memory usage of the IndexDecoders.      * memoryLimit + indexMemoryUsage equals the original      * memory usage limit that was passed to the constructor.      */     private int indexMemoryUsage = 0;      /**      * List of IndexDecoders, one for each Stream in the file.      * The list is in reverse order: The first element is      * the last Stream in the file.      */     private final ArrayList streams             = new ArrayList();      /**      * Bitmask of all Check IDs seen.      */     private int checkTypes = 0;      /**      * Uncompressed size of the file (all Streams).      */     private long uncompressedSize = 0;      /**      * Uncompressed size of the largest XZ Block in the file.      */     private long largestBlockSize = 0;      /**      * Number of XZ Blocks in the file.      */     private int blockCount = 0;      /**      * Size and position information about the current Block.      * If there are no Blocks, all values will be -1.      */     private final BlockInfo curBlockInfo;      /**      * Temporary (and cached) information about the Block whose information      * is queried via getBlockPos and related functions.      */     private final BlockInfo queriedBlockInfo;      /**      * Integrity Check in the current XZ Stream. The constructor leaves      * this to point to the Check of the first Stream.      */     private Check check;      /**      * Flag indicating if the integrity checks will be verified.      */     private final boolean verifyCheck;      /**      * Decoder of the current XZ Block, if any.      */     private BlockInputStream blockDecoder = null;      /**      * Current uncompressed position.      */     private long curPos = 0;      /**      * Target position for seeking.      */     private long seekPos;      /**      * True when seek(long) has been called but the actual      * seeking hasn't been done yet.      */     private boolean seekNeeded = false;      /**      * True when end of the file was reached. This can be cleared by      * calling seek(long).      */     private boolean endReached = false;      /**      * Pending exception from an earlier error.      */     private IOException exception = null;      /**      * Temporary buffer for read(). This avoids reallocating memory      * on every read() call.      */     private final byte[] tempBuf = new byte[1];      /**      * Creates a new seekable XZ decompressor without a memory usage limit.      *      * @param       in          seekable input stream containing one or more      *                          XZ Streams; the whole input stream is used      *      * @throws      XZFormatException      *                          input is not in the XZ format      *      * @throws      CorruptedInputException      *                          XZ data is corrupt or truncated      *      * @throws      UnsupportedOptionsException      *                          XZ headers seem valid but they specify      *                          options not supported by this implementation      *      * @throws      EOFException      *                          less than 6 bytes of input was available      *                          from in, or (unlikely) the size      *                          of the underlying stream got smaller while      *                          this was reading from it      *      * @throws      IOException may be thrown by in      */     public SeekableXZInputStream(SeekableInputStream in)             throws IOException {         this(in, -1);     }      /**      * Creates a new seekable XZ decompressor without a memory usage limit.      *       * This is identical to      * SeekableXZInputStream(SeekableInputStream) except that      * this also takes the arrayCache argument.      *      * @param       in          seekable input stream containing one or more      *                          XZ Streams; the whole input stream is used      *      * @param       arrayCache  cache to be used for allocating large arrays      *      * @throws      XZFormatException      *                          input is not in the XZ format      *      * @throws      CorruptedInputException      *                          XZ data is corrupt or truncated      *      * @throws      UnsupportedOptionsException      *                          XZ headers seem valid but they specify      *                          options not supported by this implementation      *      * @throws      EOFException      *                          less than 6 bytes of input was available      *                          from in, or (unlikely) the size      *                          of the underlying stream got smaller while      *                          this was reading from it      *      * @throws      IOException may be thrown by in      *      * @since 1.7      */     public SeekableXZInputStream(SeekableInputStream in, ArrayCache arrayCache)             throws IOException {         this(in, -1, arrayCache);     }      /**      * Creates a new seekable XZ decomporessor with an optional      * memory usage limit.      *      * @param       in          seekable input stream containing one or more      *                          XZ Streams; the whole input stream is used      *      * @param       memoryLimit memory usage limit in kibibytes (KiB)      *                          or -1 to impose no      *                          memory usage limit      *      * @throws      XZFormatException      *                          input is not in the XZ format      *      * @throws      CorruptedInputException      *                          XZ data is corrupt or truncated      *      * @throws      UnsupportedOptionsException      *                          XZ headers seem valid but they specify      *                          options not supported by this implementation      *      * @throws      MemoryLimitException      *                          decoded XZ Indexes would need more memory      *                          than allowed by the memory usage limit      *      * @throws      EOFException      *                          less than 6 bytes of input was available      *                          from in, or (unlikely) the size      *                          of the underlying stream got smaller while      *                          this was reading from it      *      * @throws      IOException may be thrown by in      */     public SeekableXZInputStream(SeekableInputStream in, int memoryLimit)             throws IOException {         this(in, memoryLimit, true);     }      /**      * Creates a new seekable XZ decomporessor with an optional      * memory usage limit.      *       * This is identical to      * SeekableXZInputStream(SeekableInputStream,int)      * except that this also takes the arrayCache argument.      *      * @param       in          seekable input stream containing one or more      *                          XZ Streams; the whole input stream is used      *      * @param       memoryLimit memory usage limit in kibibytes (KiB)      *                          or -1 to impose no      *                          memory usage limit      *      * @param       arrayCache  cache to be used for allocating large arrays      *      * @throws      XZFormatException      *                          input is not in the XZ format      *      * @throws      CorruptedInputException      *                          XZ data is corrupt or truncated      *      * @throws      UnsupportedOptionsException      *                          XZ headers seem valid but they specify      *                          options not supported by this implementation      *      * @throws      MemoryLimitException      *                          decoded XZ Indexes would need more memory      *                          than allowed by the memory usage limit      *      * @throws      EOFException      *                          less than 6 bytes of input was available      *                          from in, or (unlikely) the size      *                          of the underlying stream got smaller while      *                          this was reading from it      *      * @throws      IOException may be thrown by in      *      * @since 1.7      */     public SeekableXZInputStream(SeekableInputStream in, int memoryLimit,                                  ArrayCache arrayCache)             throws IOException {         this(in, memoryLimit, true, arrayCache);     }      /**      * Creates a new seekable XZ decomporessor with an optional      * memory usage limit and ability to disable verification      * of integrity checks.      *       * Note that integrity check verification should almost never be disabled.      * Possible reasons to disable integrity check verification:      *       *   Trying to recover data from a corrupt .xz file.      *   Speeding up decompression. This matters mostly with SHA-256      *   or with files that have compressed extremely well. It's recommended      *   that integrity checking isn't disabled for performance reasons      *   unless the file integrity is verified externally in some other      *   way.      *       *       * verifyCheck only affects the integrity check of      * the actual compressed data. The CRC32 fields in the headers      * are always verified.      *      * @param       in          seekable input stream containing one or more      *                          XZ Streams; the whole input stream is used      *      * @param       memoryLimit memory usage limit in kibibytes (KiB)      *                          or -1 to impose no      *                          memory usage limit      *      * @param       verifyCheck if true, the integrity checks      *                          will be verified; this should almost never      *                          be set to false      *      * @throws      XZFormatException      *                          input is not in the XZ format      *      * @throws      CorruptedInputException      *                          XZ data is corrupt or truncated      *      * @throws      UnsupportedOptionsException      *                          XZ headers seem valid but they specify      *                          options not supported by this implementation      *      * @throws      MemoryLimitException      *                          decoded XZ Indexes would need more memory      *                          than allowed by the memory usage limit      *      * @throws      EOFException      *                          less than 6 bytes of input was available      *                          from in, or (unlikely) the size      *                          of the underlying stream got smaller while      *                          this was reading from it      *      * @throws      IOException may be thrown by in      *      * @since 1.6      */     public SeekableXZInputStream(SeekableInputStream in, int memoryLimit,                                  boolean verifyCheck)             throws IOException {         this(in, memoryLimit, verifyCheck, ArrayCache.getDefaultCache());     }      /**      * Creates a new seekable XZ decomporessor with an optional      * memory usage limit and ability to disable verification      * of integrity checks.      *       * This is identical to      * SeekableXZInputStream(SeekableInputStream,int,boolean)      * except that this also takes the arrayCache argument.      *      * @param       in          seekable input stream containing one or more      *                          XZ Streams; the whole input stream is used      *      * @param       memoryLimit memory usage limit in kibibytes (KiB)      *                          or -1 to impose no      *                          memory usage limit      *      * @param       verifyCheck if true, the integrity checks      *                          will be verified; this should almost never      *                          be set to false      *      * @param       arrayCache  cache to be used for allocating large arrays      *      * @throws      XZFormatException      *                          input is not in the XZ format      *      * @throws      CorruptedInputException      *                          XZ data is corrupt or truncated      *      * @throws      UnsupportedOptionsException      *                          XZ headers seem valid but they specify      *                          options not supported by this implementation      *      * @throws      MemoryLimitException      *                          decoded XZ Indexes would need more memory      *                          than allowed by the memory usage limit      *      * @throws      EOFException      *                          less than 6 bytes of input was available      *                          from in, or (unlikely) the size      *                          of the underlying stream got smaller while      *                          this was reading from it      *      * @throws      IOException may be thrown by in      *      * @since 1.7      */     public SeekableXZInputStream(SeekableInputStream in, int memoryLimit,                                  boolean verifyCheck, ArrayCache arrayCache)             throws IOException {         this.arrayCache = arrayCache;         this.verifyCheck = verifyCheck;         this.in = in;         DataInputStream inData = new DataInputStream(in);          // Check the magic bytes in the beginning of the file.         {             in.seek(0);             byte[] buf = new byte[XZ.HEADER_MAGIC.length];             inData.readFully(buf);             if (!Arrays.equals(buf, XZ.HEADER_MAGIC))                 throw new XZFormatException();         }          // Get the file size and verify that it is a multiple of 4 bytes.         long pos = in.length();         if ((pos &amp; 3) != 0)             throw new CorruptedInputException(                     &quot;XZ file size is not a multiple of 4 bytes&quot;);          // Parse the headers starting from the end of the file.         byte[] buf = new byte[DecoderUtil.STREAM_HEADER_SIZE];         long streamPadding = 0;          while (pos &gt; 0) {             if (pos &lt; DecoderUtil.STREAM_HEADER_SIZE)                 throw new CorruptedInputException();              // Read the potential Stream Footer.             in.seek(pos - DecoderUtil.STREAM_HEADER_SIZE);             inData.readFully(buf);              // Skip Stream Padding four bytes at a time.             // Skipping more at once would be faster,             // but usually there isn't much Stream Padding.             if (buf[8] == 0x00 &amp;&amp; buf[9] == 0x00 &amp;&amp; buf[10] == 0x00                     &amp;&amp; buf[11] == 0x00) {                 streamPadding += 4;                 pos -= 4;                 continue;             }              // It's not Stream Padding. Update pos.             pos -= DecoderUtil.STREAM_HEADER_SIZE;              // Decode the Stream Footer and check if Backward Size             // looks reasonable.             StreamFlags streamFooter = DecoderUtil.decodeStreamFooter(buf);             if (streamFooter.backwardSize &gt;= pos)                 throw new CorruptedInputException(                         &quot;Backward Size in XZ Stream Footer is too big&quot;);              // Check that the Check ID is supported. Store it in case this             // is the first Stream in the file.             check = Check.getInstance(streamFooter.checkType);              // Remember which Check IDs have been seen.             checkTypes |= 1 &lt;&lt; streamFooter.checkType;              // Seek to the beginning of the Index.             in.seek(pos - streamFooter.backwardSize);              // Decode the Index field.             IndexDecoder index;             try {                 index = new IndexDecoder(in, streamFooter, streamPadding,                                          memoryLimit);             } catch (MemoryLimitException e) {                 // IndexDecoder doesn't know how much memory we had                 // already needed so we need to recreate the exception.                 assert memoryLimit &gt;= 0;                 throw new MemoryLimitException(                         e.getMemoryNeeded() + indexMemoryUsage,                         memoryLimit + indexMemoryUsage);             }              // Update the memory usage and limit counters.             indexMemoryUsage += index.getMemoryUsage();             if (memoryLimit &gt;= 0) {                 memoryLimit -= index.getMemoryUsage();                 assert memoryLimit &gt;= 0;             }              // Remember the uncompressed size of the largest Block.             if (largestBlockSize &lt; index.getLargestBlockSize())                 largestBlockSize = index.getLargestBlockSize();              // Calculate the offset to the beginning of this XZ Stream and             // check that it looks sane.             long off = index.getStreamSize() - DecoderUtil.STREAM_HEADER_SIZE;             if (pos &lt; off)                 throw new CorruptedInputException(&quot;XZ Index indicates &quot;                         + &quot;too big compressed size for the XZ Stream&quot;);              // Seek to the beginning of this Stream.             pos -= off;             in.seek(pos);              // Decode the Stream Header.             inData.readFully(buf);             StreamFlags streamHeader = DecoderUtil.decodeStreamHeader(buf);              // Verify that the Stream Header matches the Stream Footer.             if (!DecoderUtil.areStreamFlagsEqual(streamHeader, streamFooter))                 throw new CorruptedInputException(                         &quot;XZ Stream Footer does not match Stream Header&quot;);              // Update the total uncompressed size of the file and check that             // it doesn't overflow.             uncompressedSize += index.getUncompressedSize();             if (uncompressedSize &lt; 0)                 throw new UnsupportedOptionsException(&quot;XZ file is too big&quot;);              // Update the Block count and check that it fits into an int.             blockCount += index.getRecordCount();             if (blockCount &lt; 0)                 throw new UnsupportedOptionsException(                         &quot;XZ file has over &quot; + Integer.MAX_VALUE + &quot; Blocks&quot;);              // Add this Stream to the list of Streams.             streams.add(index);              // Reset to be ready to parse the next Stream.             streamPadding = 0;         }          assert pos == 0;          // Save it now that indexMemoryUsage has been substracted from it.         this.memoryLimit = memoryLimit;          // Store the relative offsets of the Streams. This way we don't         // need to recalculate them in this class when seeking; the         // IndexDecoder instances will handle them.         IndexDecoder prev = streams.get(streams.size() - 1);         for (int i = streams.size() - 2; i &gt;= 0; --i) {             IndexDecoder cur = streams.get(i);             cur.setOffsets(prev);             prev = cur;         }          // Initialize curBlockInfo to point to the first Stream.         // The blockNumber will be left to -1 so that .hasNext()         // and .setNext() work to get the first Block when starting         // to decompress from the beginning of the file.         IndexDecoder first = streams.get(streams.size() - 1);         curBlockInfo = new BlockInfo(first);          // queriedBlockInfo needs to be allocated too. The Stream used for         // initialization doesn't matter though.         queriedBlockInfo = new BlockInfo(first);     }      /**      * Gets the types of integrity checks used in the .xz file.      * Multiple checks are possible only if there are multiple      * concatenated XZ Streams.      *       * The returned value has a bit set for every check type that is present.      * For example, if CRC64 and SHA-256 were used, the return value is      * (1 &lt;&lt; XZ.CHECK_CRC64)      * | (1 &lt;&lt; XZ.CHECK_SHA256).      */     public int getCheckTypes() {         return checkTypes;     }      /**      * Gets the amount of memory in kibibytes (KiB) used by      * the data structures needed to locate the XZ Blocks.      * This is usually useless information but since it is calculated      * for memory usage limit anyway, it is nice to make it available to too.      */     public int getIndexMemoryUsage() {         return indexMemoryUsage;     }      /**      * Gets the uncompressed size of the largest XZ Block in bytes.      * This can be useful if you want to check that the file doesn't      * have huge XZ Blocks which could make seeking to arbitrary offsets      * very slow. Note that huge Blocks don't automatically mean that      * seeking would be slow, for example, seeking to the beginning of      * any Block is always fast.      */     public long getLargestBlockSize() {         return largestBlockSize;     }      /**      * Gets the number of Streams in the .xz file.      *      * @since 1.3      */     public int getStreamCount() {         return streams.size();     }      /**      * Gets the number of Blocks in the .xz file.      *      * @since 1.3      */     public int getBlockCount() {         return blockCount;     }      /**      * Gets the uncompressed start position of the given Block.      *      * @throws  IndexOutOfBoundsException if      *          blockNumber &lt; 0 or      *          blockNumber &gt;= getBlockCount().      *      * @since 1.3      */     public long getBlockPos(int blockNumber) {         locateBlockByNumber(queriedBlockInfo, blockNumber);         return queriedBlockInfo.uncompressedOffset;     }      /**      * Gets the uncompressed size of the given Block.      *      * @throws  IndexOutOfBoundsException if      *          blockNumber &lt; 0 or      *          blockNumber &gt;= getBlockCount().      *      * @since 1.3      */     public long getBlockSize(int blockNumber) {         locateBlockByNumber(queriedBlockInfo, blockNumber);         return queriedBlockInfo.uncompressedSize;     }      /**      * Gets the position where the given compressed Block starts in      * the underlying .xz file.      * This information is rarely useful to the users of this class.      *      * @throws  IndexOutOfBoundsException if      *          blockNumber &lt; 0 or      *          blockNumber &gt;= getBlockCount().      *      * @since 1.3      */     public long getBlockCompPos(int blockNumber) {         locateBlockByNumber(queriedBlockInfo, blockNumber);         return queriedBlockInfo.compressedOffset;     }      /**      * Gets the compressed size of the given Block.      * This together with the uncompressed size can be used to calculate      * the compression ratio of the specific Block.      *      * @throws  IndexOutOfBoundsException if      *          blockNumber &lt; 0 or      *          blockNumber &gt;= getBlockCount().      *      * @since 1.3      */     public long getBlockCompSize(int blockNumber) {         locateBlockByNumber(queriedBlockInfo, blockNumber);         return (queriedBlockInfo.unpaddedSize + 3) &amp; ~3;     }      /**      * Gets integrity check type (Check ID) of the given Block.      *      * @throws  IndexOutOfBoundsException if      *          blockNumber &lt; 0 or      *          blockNumber &gt;= getBlockCount().      *      * @see #getCheckTypes()      *      * @since 1.3      */     public int getBlockCheckType(int blockNumber) {         locateBlockByNumber(queriedBlockInfo, blockNumber);         return queriedBlockInfo.getCheckType();     }      /**      * Gets the number of the Block that contains the byte at the given      * uncompressed position.      *      * @throws  IndexOutOfBoundsException if      *          pos &lt; 0 or      *          pos &gt;= length().      *      * @since 1.3      */     public int getBlockNumber(long pos) {         locateBlockByPos(queriedBlockInfo, pos);         return queriedBlockInfo.blockNumber;     }      /**      * Decompresses the next byte from this input stream.      *      * @return      the next decompressed byte, or -1      *              to indicate the end of the compressed stream      *      * @throws      CorruptedInputException      * @throws      UnsupportedOptionsException      * @throws      MemoryLimitException      *      * @throws      XZIOException if the stream has been closed      *      * @throws      IOException may be thrown by in      */     public int read() throws IOException {         return read(tempBuf, 0, 1) == -1 ? -1 : (tempBuf[0] &amp; 0xFF);     }      /**      * Decompresses into an array of bytes.      *       * If len is zero, no bytes are read and 0      * is returned. Otherwise this will try to decompress len      * bytes of uncompressed data. Less than len bytes may      * be read only in the following situations:      *       *   The end of the compressed data was reached successfully.      *   An error is detected after at least one but less than      *       len bytes have already been successfully      *       decompressed. The next call with non-zero len      *       will immediately throw the pending exception.      *   An exception is thrown.      *       *      * @param       buf         target buffer for uncompressed data      * @param       off         start offset in buf      * @param       len         maximum number of uncompressed bytes to read      *      * @return      number of bytes read, or -1 to indicate      *              the end of the compressed stream      *      * @throws      CorruptedInputException      * @throws      UnsupportedOptionsException      * @throws      MemoryLimitException      *      * @throws      XZIOException if the stream has been closed      *      * @throws      IOException may be thrown by in      */     public int read(byte[] buf, int off, int len) throws IOException {         if (off &lt; 0 || len &lt; 0 || off + len &lt; 0 || off + len &gt; buf.length)             throw new IndexOutOfBoundsException();          if (len == 0)             return 0;          if (in == null)             throw new XZIOException(&quot;Stream closed&quot;);          if (exception != null)             throw exception;          int size = 0;          try {             if (seekNeeded)                 seek();              if (endReached)                 return -1;              while (len &gt; 0) {                 if (blockDecoder == null) {                     seek();                     if (endReached)                         break;                 }                  int ret = blockDecoder.read(buf, off, len);                  if (ret &gt; 0) {                     curPos += ret;                     size += ret;                     off += ret;                     len -= ret;                 } else if (ret == -1) {                     blockDecoder = null;                 }             }         } catch (IOException e) {             // We know that the file isn't simply truncated because we could             // parse the Indexes in the constructor. So convert EOFException             // to CorruptedInputException.             if (e instanceof EOFException)                 e = new CorruptedInputException();              exception = e;             if (size == 0)                 throw e;         }          return size;     }      /**      * Returns the number of uncompressed bytes that can be read      * without blocking. The value is returned with an assumption      * that the compressed input data will be valid. If the compressed      * data is corrupt, CorruptedInputException may get      * thrown before the number of bytes claimed to be available have      * been read from this input stream.      *      * @return      the number of uncompressed bytes that can be read      *              without blocking      */     public int available() throws IOException {         if (in == null)             throw new XZIOException(&quot;Stream closed&quot;);          if (exception != null)             throw exception;          if (endReached || seekNeeded || blockDecoder == null)             return 0;          return blockDecoder.available();     }      /**      * Closes the stream and calls in.close().      * If the stream was already closed, this does nothing.      *       * This is equivalent to close(true).      *      * @throws  IOException if thrown by in.close()      */     public void close() throws IOException {         close(true);     }      /**      * Closes the stream and optionally calls in.close().      * If the stream was already closed, this does nothing.      * If close(false) has been called, a further      * call of close(true) does nothing (it doesn't call      * in.close()).      *       * If you don't want to close the underlying InputStream,      * there is usually no need to worry about closing this stream either;      * it's fine to do nothing and let the garbage collector handle it.      * However, if you are using {@link ArrayCache}, close(false)      * can be useful to put the allocated arrays back to the cache without      * closing the underlying InputStream.      *       * Note that if you successfully reach the end of the stream      * (read returns -1), the arrays are      * automatically put back to the cache by that read call. In      * this situation close(false) is redundant (but harmless).      *      * @throws  IOException if thrown by in.close()      *      * @since 1.7      */     public void close(boolean closeInput) throws IOException {         if (in != null) {             if (blockDecoder != null) {                 blockDecoder.close();                 blockDecoder = null;             }              try {                 if (closeInput)                     in.close();             } finally {                 in = null;             }         }     }      /**      * Gets the uncompressed size of this input stream. If there are multiple      * XZ Streams, the total uncompressed size of all XZ Streams is returned.      */     public long length() {         return uncompressedSize;     }      /**      * Gets the current uncompressed position in this input stream.      *      * @throws      XZIOException if the stream has been closed      */     public long position() throws IOException {         if (in == null)             throw new XZIOException(&quot;Stream closed&quot;);          return seekNeeded ? seekPos : curPos;     }      /**      * Seeks to the specified absolute uncompressed position in the stream.      * This only stores the new position, so this function itself is always      * very fast. The actual seek is done when read is called      * to read at least one byte.      *       * Seeking past the end of the stream is possible. In that case      * read will return -1 to indicate      * the end of the stream.      *      * @param       pos         new uncompressed read position      *      * @throws      XZIOException      *                          if pos is negative, or      *                          if stream has been closed      */     public void seek(long pos) throws IOException {         if (in == null)             throw new XZIOException(&quot;Stream closed&quot;);          if (pos &lt; 0)             throw new XZIOException(&quot;Negative seek position: &quot; + pos);          seekPos = pos;         seekNeeded = true;     }      /**      * Seeks to the beginning of the given XZ Block.      *      * @throws      XZIOException      *              if blockNumber &lt; 0 or      *              blockNumber &gt;= getBlockCount(),      *              or if stream has been closed      *      * @since 1.3      */     public void seekToBlock(int blockNumber) throws IOException {         if (in == null)             throw new XZIOException(&quot;Stream closed&quot;);          if (blockNumber &lt; 0 || blockNumber &gt;= blockCount)             throw new XZIOException(&quot;Invalid XZ Block number: &quot; + blockNumber);          // This is a bit silly implementation. Here we locate the uncompressed         // offset of the specified Block, then when doing the actual seek in         // seek(), we need to find the Block number based on seekPos.         seekPos = getBlockPos(blockNumber);         seekNeeded = true;     }      /**      * Does the actual seeking. This is also called when read      * needs a new Block to decode.      */     private void seek() throws IOException {         // If seek(long) wasn't called, we simply need to get the next Block         // from the same Stream. If there are no more Blocks in this Stream,         // then we behave as if seek(long) had been called.         if (!seekNeeded) {             if (curBlockInfo.hasNext()) {                 curBlockInfo.setNext();                 initBlockDecoder();                 return;             }              seekPos = curPos;         }          seekNeeded = false;          // Check if we are seeking to or past the end of the file.         if (seekPos &gt;= uncompressedSize) {             curPos = seekPos;              if (blockDecoder != null) {                 blockDecoder.close();                 blockDecoder = null;             }              endReached = true;             return;         }          endReached = false;          // Locate the Block that contains the uncompressed target position.         locateBlockByPos(curBlockInfo, seekPos);          // Seek in the underlying stream and create a new Block decoder         // only if really needed. We can skip it if the current position         // is already in the correct Block and the target position hasn't         // been decompressed yet.         //         // NOTE: If curPos points to the beginning of this Block, it's         // because it was left there after decompressing an earlier Block.         // In that case, decoding of the current Block hasn't been started         // yet. (Decoding of a Block won't be started until at least one         // byte will also be read from it.)         if (!(curPos &gt; curBlockInfo.uncompressedOffset &amp;&amp; curPos &lt;= seekPos)) {             // Seek to the beginning of the Block.             in.seek(curBlockInfo.compressedOffset);              // Since it is possible that this Block is from a different             // Stream than the previous Block, initialize a new Check.             check = Check.getInstance(curBlockInfo.getCheckType());              // Create a new Block decoder.             initBlockDecoder();             curPos = curBlockInfo.uncompressedOffset;         }          // If the target wasn't at a Block boundary, decompress and throw         // away data to reach the target position.         if (seekPos &gt; curPos) {             // NOTE: The &quot;if&quot; below is there just in case. In this situation,             // blockDecoder.skip will always skip the requested amount             // or throw an exception.             long skipAmount = seekPos - curPos;             if (blockDecoder.skip(skipAmount) != skipAmount)                 throw new CorruptedInputException();              curPos = seekPos;         }     }      /**      * Locates the Block that contains the given uncompressed position.      */     private void locateBlockByPos(BlockInfo info, long pos) {         if (pos &lt; 0 || pos &gt;= uncompressedSize)             throw new IndexOutOfBoundsException(                     &quot;Invalid uncompressed position: &quot; + pos);          // Locate the Stream that contains the target position.         IndexDecoder index;         for (int i = 0; ; ++i) {             index = streams.get(i);             if (index.hasUncompressedOffset(pos))                 break;         }          // Locate the Block from the Stream that contains the target position.         index.locateBlock(info, pos);          assert (info.compressedOffset &amp; 3) == 0;         assert info.uncompressedSize &gt; 0;         assert pos &gt;= info.uncompressedOffset;         assert pos &lt; info.uncompressedOffset + info.uncompressedSize;     }      /**      * Locates the given Block and stores information about it      * to info.      */     private void locateBlockByNumber(BlockInfo info, int blockNumber) {         // Validate.         if (blockNumber &lt; 0 || blockNumber &gt;= blockCount)             throw new IndexOutOfBoundsException(                     &quot;Invalid XZ Block number: &quot; + blockNumber);          // Skip the search if info already points to the correct Block.         if (info.blockNumber == blockNumber)             return;          // Search the Stream that contains the given Block and then         // search the Block from that Stream.         for (int i = 0; ; ++i) {             IndexDecoder index = streams.get(i);             if (index.hasRecord(blockNumber)) {                 index.setBlockInfo(info, blockNumber);                 return;             }         }     }      /**      * Initializes a new BlockInputStream. This is a helper function for      * seek().      */     private void initBlockDecoder() throws IOException {         try {             // Set it to null first so that GC can collect it if memory             // runs tight when initializing a new BlockInputStream.             if (blockDecoder != null) {                 blockDecoder.close();                 blockDecoder = null;             }              blockDecoder = new BlockInputStream(                     in, check, verifyCheck, memoryLimit,                     curBlockInfo.unpaddedSize, curBlockInfo.uncompressedSize,                     arrayCache);         } catch (MemoryLimitException e) {             // BlockInputStream doesn't know how much memory we had             // already needed so we need to recreate the exception.             assert memoryLimit &gt;= 0;             throw new MemoryLimitException(                     e.getMemoryNeeded() + indexMemoryUsage,                     memoryLimit + indexMemoryUsage);         } catch (IndexIndicatorException e) {             // It cannot be Index so the file must be corrupt.             throw new CorruptedInputException();         }     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11534</td>
    <td align="left">https://github.com/eclipse/packagedrone/blob/3869c1643cdc6f7cb8b26097a7b6994683b13d7e/bundles/org.tukani.xz/src/org/tukaani/xz/SeekableXZInputStream.java/#L76-L1152</td>
    <td align="right">1</td>
    <td align="right">1640</td>
    <td align="right">11534</td>
  </tr>
  <tr valign="top">
    <td align="right">2374</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SignatureSupportingConfigProperties {      private String sharedSecret;     private String keyPath;     private long tokenExpirationSeconds = 600L;     private String certificatePath;      /**      * Gets the secret used for creating and validating HmacSHA256 based signatures.      *       * @return The secret or {@code null} if not set.      */     public final String getSharedSecret() {         return sharedSecret;     }      /**      * Sets the secret to use for creating and validating HmacSHA256 based signatures.      *       * @param secret The shared secret.      * @throws NullPointerException if secret is {@code null}.      * @throws IllegalArgumentException if the secret is &lt; 32 bytes.      */     public final void setSharedSecret(final String secret) {         if (Objects.requireNonNull(secret).getBytes(StandardCharsets.UTF_8).length &lt; 32) {             throw new IllegalArgumentException(&quot;shared secret must be at least 32 bytes&quot;);         }         this.sharedSecret = secret;     }      /**      * Sets the path to the file containing the private key to be used      * for creating SHA256withRSA based signatures.      *       * The file must be in PKCS8 PEM format.      *       * @param keyPath The path to the PEM file.      * @throws NullPointerException if the path is {@code null}.      */     public final void setKeyPath(final String keyPath) {         this.keyPath = Objects.requireNonNull(keyPath);     }      /**      * Gets the path to the file containing the private key to be used      * for validating RSA based signatures.      *       * @return The path to the file or {@code null} if not set.      */     public final String getKeyPath() {         return keyPath;     }      /**      * Gets the period of time after which tokens created using this configuration should expire.      *       * @return The number of seconds after which tokens expire.      */     public final long getTokenExpiration() {         return tokenExpirationSeconds;     }      /**      * Sets the period of time after which tokens created using this configuration should expire.      *       * The default value is 600 seconds (10 minutes).      *       * @param seconds The number of seconds after which tokens expire.      * @throws IllegalArgumentException if seconds is &lt;= 0.      */     public final void setTokenExpiration(final long seconds) {         if (seconds &lt;= 0) {             throw new IllegalArgumentException(&quot;token expiration must be &gt; 0&quot;);         }         this.tokenExpirationSeconds = seconds;     }      /**      * Sets the path to the X.509 certificate containing the public key to be used      * for validating SHA256withRSA based signatures.      *       * The file must be in PKCS8 PEM format.      *       * @param certPath The path to the PEM file.      * @throws NullPointerException if the path is {@code null}.      */     public final void setCertPath(final String certPath) {         this.certificatePath = Objects.requireNonNull(certPath);     }      /**      * Gets the path to the X.509 certificate containing the public key to be used      * for validating RSA based signatures.      *       * @return The path to the file or {@code null} if not set.      */     public final String getCertPath() {         return certificatePath;     }      /**      * Checks if this configuration contains enough information for creating assertions.      *       * @return {@code true} if any of sharedSecret or keyPath is not {@code null}.      */     public final boolean isAppropriateForCreating() {         return sharedSecret != null || keyPath != null;     }      /**      * Checks if this configuration contains enough information for validating assertions.      *       * @return {@code true} if any of sharedSecret or certificatePath is not {@code null}.      */     public final boolean isAppropriateForValidating() {         return sharedSecret != null || certificatePath != null;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14314</td>
    <td align="left">https://github.com/eclipse/hono/blob/ec84947227564c6459801f708bdeabd7687a8bf0/core/src/main/java/org/eclipse/hono/config/SignatureSupportingConfigProperties.java/#L22-L139</td>
    <td align="right">1</td>
    <td align="right">2374</td>
    <td align="right">14314</td>
  </tr>
  <tr valign="top">
    <td align="right">2252</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SQLDropTableStatement extends SQLStatementImpl implements SQLDropStatement {     private List hints;      protected List tableSources = new ArrayList();      private boolean                    purge;      protected boolean                  cascade      = false;     protected boolean                  restrict     = false;     protected boolean                  ifExists     = false;     private boolean                    temporary    = false;      public SQLDropTableStatement(){      }          public SQLDropTableStatement(String dbType){         super (dbType);     }      public SQLDropTableStatement(SQLName name, String dbType){         this(new SQLExprTableSource(name), dbType);     }          public SQLDropTableStatement(SQLName name){         this (name, null);     }          public SQLDropTableStatement(SQLExprTableSource tableSource){         this (tableSource, null);     }      public SQLDropTableStatement(SQLExprTableSource tableSource, String dbType){         this (dbType);         this.tableSources.add(tableSource);     }      public List getTableSources() {         return tableSources;     }          public void addPartition(SQLExprTableSource tableSource) {         if (tableSource != null) {             tableSource.setParent(this);         }         this.tableSources.add(tableSource);     }      public void setName(SQLName name) {         this.addTableSource(new SQLExprTableSource(name));     }      public void addTableSource(SQLName name) {         this.addTableSource(new SQLExprTableSource(name));     }      public void addTableSource(SQLExprTableSource tableSource) {         tableSources.add(tableSource);     }      @Override     protected void accept0(SQLASTVisitor visitor) {         if (visitor.visit(this)) {             this.acceptChild(visitor, tableSources);         }         visitor.endVisit(this);     }      @Override     public List getChildren() {         return this.tableSources;     }      public boolean isPurge() {         return purge;     }      public void setPurge(boolean purge) {         this.purge = purge;     }      public boolean isIfExists() {         return ifExists;     }      public void setIfExists(boolean ifExists) {         this.ifExists = ifExists;     }      public boolean isCascade() {         return cascade;     }      public void setCascade(boolean cascade) {         this.cascade = cascade;     }      public boolean isRestrict() {         return restrict;     }      public void setRestrict(boolean restrict) {         this.restrict = restrict;     }      public boolean isTemporary() {         return temporary;     }      public void setTemporary(boolean temporary) {         this.temporary = temporary;     }      public List getHints() {         return hints;     }      public void setHints(List hints) {         this.hints = hints;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13680</td>
    <td align="left">https://github.com/alibaba/druid/blob/768469fe4d1340efe1036453366a58c9ab7e30d1/src/main/java/com/alibaba/druid/sql/ast/statement/SQLDropTableStatement.java/#L26-L146</td>
    <td align="right">1</td>
    <td align="right">2252</td>
    <td align="right">13680</td>
  </tr>
  <tr valign="top">
    <td align="right">1806</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;,  &quot;bad_smells&quot;: [      &quot;Data Class&quot;  ]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class RequireCapability     {         private final String namespace;          private final String filter;          private final String effective;          public RequireCapability ( final String namespace, final String filter, final String effective )         {             this.namespace = namespace;             this.filter = filter;             this.effective = effective;         }          public String getNamespace ()         {             return this.namespace;         }          public String getFilter ()         {             return this.filter;         }          public String getEffective ()         {             return this.effective;         }     }</td>
    <td align="left">data class</td>
    <td align="left">Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12041</td>
    <td align="left">https://github.com/eclipse/packagedrone/blob/3869c1643cdc6f7cb8b26097a7b6994683b13d7e/bundles/org.eclipse.packagedrone.repo.utils.osgi/src/org/eclipse/packagedrone/repo/utils/osgi/bundle/BundleInformation.java/#L377-L406</td>
    <td align="right">1</td>
    <td align="right">1806</td>
    <td align="right">12041</td>
  </tr>
  <tr valign="top">
    <td align="right">2555</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MessageComponent extends UIOutput {       // ------------------------------------------------------------ Constructors       /**      * Create a new {@link MessageComponent} with default properties.      */     public MessageComponent() {          super();         setRendererType(&quot;org.apache.struts.faces.Message&quot;);      }       // ------------------------------------------------------ Instance Variables       /**      * MessageResources attribute key to use for message lookup.      */     private String bundle = null;       /**      * Flag indicating whether output should be filtered.      */     private boolean filter = true;     private boolean filterSet = false;       /**      * Message key to use for message lookup.      */     private String key = null;       /**      * CSS style(s) to be rendered for this component.      */     private String style = null;       /**      * CSS style class(es) to be rendered for this component.      */     private String styleClass = null;       // ---------------------------------------------------- Component Properties       /**      * Return the MessageResources key.      */     public String getBundle() {          ValueBinding vb = getValueBinding(&quot;bundle&quot;);         if (vb != null) {             return (String) vb.getValue(getFacesContext());         } else {             return bundle;         }      }       /**      * Set the MessageResources key.      *      * @param bundle The new key      */     public void setBundle(String bundle) {          this.bundle = bundle;      }       /**      * Return the component family to which this component belongs.      */     public String getFamily() {          return &quot;org.apache.struts.faces.Message&quot;;      }       /**      * Return a flag indicating whether filtering should take place.      */     public boolean isFilter() {          if (filterSet) {             return filter;         }         ValueBinding vb = getValueBinding(&quot;filter&quot;);         if (vb != null) {             Boolean value = (Boolean) vb.getValue(getFacesContext());             if (null == value) {                 return filter;             }             return value.booleanValue();         } else {             return filter;         }      }       /**      * Set the flag indicating that the output value should be filtered.      *      * @param filter The new filter flag      */     public void setFilter(boolean filter) {          this.filter = filter;         this.filterSet = true;      }       /**      * Return the message key.      */     public String getKey() {          ValueBinding vb = getValueBinding(&quot;key&quot;);         if (vb != null) {             return (String) vb.getValue(getFacesContext());         } else {             return key;         }      }       /**      * Set the message key.      *      * @param key The new key      */     public void setKey(String key) {          this.key = key;      }       /**      * Return the CSS style(s) to be rendered for this component.      */     public String getStyle() {          ValueBinding vb = getValueBinding(&quot;style&quot;);         if (vb != null) {             return (String) vb.getValue(getFacesContext());         } else {             return style;         }      }       /**      * Set the CSS style(s) to be rendered for this component.      *      * @param style The new CSS style(s)      */     public void setStyle(String style) {          this.style = style;      }       /**      * Return the CSS style class(es) to be rendered for this component.      */     public String getStyleClass() {          ValueBinding vb = getValueBinding(&quot;styleClass&quot;);         if (vb != null) {             return (String) vb.getValue(getFacesContext());         } else {             return styleClass;         }      }       /**      * Set the CSS style class(es) to be rendered for this component.      *      * @param styleClass The new CSS style class(es)      */     public void setStyleClass(String styleClass) {          this.styleClass = styleClass;      }       // ---------------------------------------------------- StateManager Methods       /**      * Restore the state of this component.      *      * @param context FacesContext for the current request      * @param state State object from which to restore our state      */     public void restoreState(FacesContext context, Object state) {          Object values[] = (Object[]) state;         super.restoreState(context, values[0]);         bundle = (String) values[1];         filter = ((Boolean) values[2]).booleanValue();         filterSet = ((Boolean) values[3]).booleanValue();         key = (String) values[4];         style = (String) values[5];         styleClass = (String) values[6];      }       /**      * Save the state of this component.      *      * @param context FacesContext for the current request      */     public Object saveState(FacesContext context) {          Object values[] = new Object[7];         values[0] = super.saveState(context);         values[1] = bundle;         values[2] = filter ? Boolean.TRUE : Boolean.FALSE;         values[3] = filterSet ? Boolean.TRUE : Boolean.FALSE;         values[4] = key;         values[5] = style;         values[6] = styleClass;         return values;      }   }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14825</td>
    <td align="left">https://github.com/apache/struts1/blob/02c9ff7485b1900515c6e0b32ed54ea46dd97d51/faces/src/main/java/org/apache/struts/faces/component/MessageComponent.java/#L35-L285</td>
    <td align="right">1</td>
    <td align="right">2555</td>
    <td align="right">14825</td>
  </tr>
  <tr valign="top">
    <td align="right">2255</td>
    <td align="left">&nbsp;	{ 		&quot;response&quot;: &quot;YES I found bad smells&quot;, 		&quot;bad smells&quot;: [ 			&quot;Data Class&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ThymeleafAnnotationValues extends AbstractAnnotationValues {    @AutoPopulate   private String[] excludeMethods;    @AutoPopulate   private String[] excludeViews;    /**    * Constructor    *    * @param governorPhysicalTypeMetadata    */   public ThymeleafAnnotationValues(final PhysicalTypeMetadata governorPhysicalTypeMetadata) {     super(governorPhysicalTypeMetadata, ROO_THYMELEAF);     AutoPopulationUtils.populate(this, annotationMetadata);   }     public String[] getExcludeMethods() {     return excludeMethods;   }    public String[] getExcludeViews() {     return excludeViews;   }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13690</td>
    <td align="left">https://github.com/spring-projects/spring-roo/blob/4a2e9f1eb17d4e49ad947503a63afef7d5a37842/addon-web-mvc-thymeleaf/addon/src/main/java/org/springframework/roo/addon/web/mvc/thymeleaf/addon/ThymeleafAnnotationValues.java/#L17-L44</td>
    <td align="right">1</td>
    <td align="right">2255</td>
    <td align="right">13690</td>
  </tr>
  <tr valign="top">
    <td align="right">1581</td>
    <td align="left">&nbsp;&nbsp;YES I found bad smells the bad smells are: 1. Long method  2. Inappropriate coupling  3. Feature envy  4. Duplicated code  5. Magic numbers  6. Dead code  7. Misplaced responsibility  8. Inconsistent naming  9. Data class</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;EObject&quot;, propOrder = { &quot;extensions&quot; }) public class EObject {  	@XmlElement(name = &quot;Extension&quot;, namespace = &quot;http://www.omg.org/XMI&quot;) 	protected List extensions; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	@XmlJavaTypeAdapter(CollapsedStringAdapter.class) 	@XmlID 	protected String id; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected QName type; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected String version; 	@XmlAttribute 	protected String href; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	@XmlIDREF 	protected Object idref; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected String label; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected String uuid;  	/** 	 * Gets the value of the extensions property. 	 *  	 *  	 * This accessor method returns a reference to the live list, not a 	 * snapshot. Therefore any modification you make to the returned list will 	 * be present inside the JAXB object. This is why there is not a 	 * set method for the extensions property. 	 *  	 *  	 * For example, to add a new item, do as follows: 	 *  	 *  	 * getExtensions().add(newItem); 	 *  	 *  	 *  	 *  	 * Objects of the following type(s) are allowed in the list 	 * {@link Extension } 	 *  	 *  	 */ 	public List getExtensions() { 		if (extensions == null) { 			extensions = new ArrayList(); 		} 		return this.extensions; 	}  	/** 	 * Gets the value of the id property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getId() { 		return id; 	}  	/** 	 * Sets the value of the id property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setId(String value) { 		this.id = value; 	}  	/** 	 * Gets the value of the type property. 	 *  	 * @return possible object is {@link QName } 	 *  	 */ 	public QName getType() { 		return type; 	}  	/** 	 * Sets the value of the type property. 	 *  	 * @param value 	 *            allowed object is {@link QName } 	 *  	 */ 	public void setType(QName value) { 		this.type = value; 	}  	/** 	 * Gets the value of the version property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getVersion() { 		if (version == null) { 			return &quot;2.0&quot;; 		} else { 			return version; 		} 	}  	/** 	 * Sets the value of the version property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setVersion(String value) { 		this.version = value; 	}  	/** 	 * Gets the value of the href property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getHref() { 		return href; 	}  	/** 	 * Sets the value of the href property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setHref(String value) { 		this.href = value; 	}  	/** 	 * Gets the value of the idref property. 	 *  	 * @return possible object is {@link Object } 	 *  	 */ 	public Object getIdref() { 		return idref; 	}  	/** 	 * Sets the value of the idref property. 	 *  	 * @param value 	 *            allowed object is {@link Object } 	 *  	 */ 	public void setIdref(Object value) { 		this.idref = value; 	}  	/** 	 * Gets the value of the label property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getLabel() { 		return label; 	}  	/** 	 * Sets the value of the label property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setLabel(String value) { 		this.label = value; 	}  	/** 	 * Gets the value of the uuid property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getUuid() { 		return uuid; 	}  	/** 	 * Sets the value of the uuid property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setUuid(String value) { 		this.uuid = value; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method 2 Inappropriate coupling 3 Feature envy 4 Duplicated code 5 Magic numbers 6 Dead code 7 Misplaced responsibility 8 Inconsistent naming 9 Data class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11362</td>
    <td align="left">https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/container/openejb-jee/src/main/java/org/apache/openejb/jee/was/v6/ecore/EObject.java/#L57-L262</td>
    <td align="right">2</td>
    <td align="right">1581</td>
    <td align="right">11362</td>
  </tr>
  <tr valign="top">
    <td align="right">1265</td>
    <td align="left">	{ 		&quot;message&quot;: &quot;YES I found bad smells&quot;, 		&quot;bad smells are&quot;: [ 			&quot;Data Class&quot;, 			&quot;Long Method&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class DrillScanRelBase extends TableScan implements DrillRelNode {   protected GroupScan groupScan;   protected final DrillTable drillTable;    public DrillScanRelBase(RelOptCluster cluster,                           RelTraitSet traits,                           RelOptTable table,                           final List columns) {     super(cluster, traits, table);     this.drillTable = Utilities.getDrillTable(table);     assert drillTable != null;     try {       this.groupScan = drillTable.getGroupScan().clone(columns);     } catch (final IOException e) {       throw new DrillRuntimeException(&quot;Failure creating scan.&quot;, e);     }   }    public DrillScanRelBase(RelOptCluster cluster,                           RelTraitSet traits,                           GroupScan grpScan,                           RelOptTable table) {     super(cluster, traits, table);     DrillTable unwrap = table.unwrap(DrillTable.class);     if (unwrap == null) {       unwrap = table.unwrap(DrillTranslatableTable.class).getDrillTable();     }     this.drillTable = unwrap;     assert drillTable != null;     this.groupScan = grpScan;   }    public DrillTable getDrillTable() {     return drillTable;   }    public GroupScan getGroupScan() {     return groupScan;   }    @Override public double estimateRowCount(RelMetadataQuery mq) {     return mq.getRowCount(this);   }    @Override public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {     double dRows = estimateRowCount(mq);     double dCpu = dRows + 1; // ensure non-zero cost     double dIo = 0;     return planner.getCostFactory().makeCost(dRows, dCpu, dIo);   } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10541</td>
    <td align="left">https://github.com/apache/drill/blob/5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3/exec/java-exec/src/main/java/org/apache/drill/exec/planner/common/DrillScanRelBase.java/#L39-L89</td>
    <td align="right">1</td>
    <td align="right">1265</td>
    <td align="right">10541</td>
  </tr>
  <tr valign="top">
    <td align="right">2351</td>
    <td align="left">&nbsp;{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;the bad smells are&quot;: [     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Generated(&quot;com.amazonaws:aws-java-sdk-code-generator&quot;) public class ListKeysResult extends com.ibm.cloud.objectstorage.AmazonWebServiceResult implements Serializable, Cloneable {      /**      *       * A list of keys.      *       */     private com.ibm.cloud.objectstorage.internal.SdkInternalList keys;     /**      *       * When Truncated is true, this element is present and contains the value to use for the      * Marker parameter in a subsequent request.      *       */     private String nextMarker;     /**      *       * A flag that indicates whether there are more items in the list. When this value is true, the list in this      * response is truncated. To retrieve more items, pass the value of the NextMarker element in this      * response to the Marker parameter in a subsequent request.      *       */     private Boolean truncated;      /**      *       * A list of keys.      *       *       * @return A list of keys.      */      public java.util.List getKeys() {         if (keys == null) {             keys = new com.ibm.cloud.objectstorage.internal.SdkInternalList();         }         return keys;     }      /**      *       * A list of keys.      *       *       * @param keys      *        A list of keys.      */      public void setKeys(java.util.Collection keys) {         if (keys == null) {             this.keys = null;             return;         }          this.keys = new com.ibm.cloud.objectstorage.internal.SdkInternalList(keys);     }      /**      *       * A list of keys.      *       *       * NOTE: This method appends the values to the existing list (if any). Use      * {@link #setKeys(java.util.Collection)} or {@link #withKeys(java.util.Collection)} if you want to override the      * existing values.      *       *       * @param keys      *        A list of keys.      * @return Returns a reference to this object so that method calls can be chained together.      */      public ListKeysResult withKeys(KeyListEntry... keys) {         if (this.keys == null) {             setKeys(new com.ibm.cloud.objectstorage.internal.SdkInternalList(keys.length));         }         for (KeyListEntry ele : keys) {             this.keys.add(ele);         }         return this;     }      /**      *       * A list of keys.      *       *       * @param keys      *        A list of keys.      * @return Returns a reference to this object so that method calls can be chained together.      */      public ListKeysResult withKeys(java.util.Collection keys) {         setKeys(keys);         return this;     }      /**      *       * When Truncated is true, this element is present and contains the value to use for the      * Marker parameter in a subsequent request.      *       *       * @param nextMarker      *        When Truncated is true, this element is present and contains the value to use for the      *        Marker parameter in a subsequent request.      */      public void setNextMarker(String nextMarker) {         this.nextMarker = nextMarker;     }      /**      *       * When Truncated is true, this element is present and contains the value to use for the      * Marker parameter in a subsequent request.      *       *       * @return When Truncated is true, this element is present and contains the value to use for the      *         Marker parameter in a subsequent request.      */      public String getNextMarker() {         return this.nextMarker;     }      /**      *       * When Truncated is true, this element is present and contains the value to use for the      * Marker parameter in a subsequent request.      *       *       * @param nextMarker      *        When Truncated is true, this element is present and contains the value to use for the      *        Marker parameter in a subsequent request.      * @return Returns a reference to this object so that method calls can be chained together.      */      public ListKeysResult withNextMarker(String nextMarker) {         setNextMarker(nextMarker);         return this;     }      /**      *       * A flag that indicates whether there are more items in the list. When this value is true, the list in this      * response is truncated. To retrieve more items, pass the value of the NextMarker element in this      * response to the Marker parameter in a subsequent request.      *       *       * @param truncated      *        A flag that indicates whether there are more items in the list. When this value is true, the list in this      *        response is truncated. To retrieve more items, pass the value of the NextMarker element in      *        this response to the Marker parameter in a subsequent request.      */      public void setTruncated(Boolean truncated) {         this.truncated = truncated;     }      /**      *       * A flag that indicates whether there are more items in the list. When this value is true, the list in this      * response is truncated. To retrieve more items, pass the value of the NextMarker element in this      * response to the Marker parameter in a subsequent request.      *       *       * @return A flag that indicates whether there are more items in the list. When this value is true, the list in this      *         response is truncated. To retrieve more items, pass the value of the NextMarker element in      *         this response to the Marker parameter in a subsequent request.      */      public Boolean getTruncated() {         return this.truncated;     }      /**      *       * A flag that indicates whether there are more items in the list. When this value is true, the list in this      * response is truncated. To retrieve more items, pass the value of the NextMarker element in this      * response to the Marker parameter in a subsequent request.      *       *       * @param truncated      *        A flag that indicates whether there are more items in the list. When this value is true, the list in this      *        response is truncated. To retrieve more items, pass the value of the NextMarker element in      *        this response to the Marker parameter in a subsequent request.      * @return Returns a reference to this object so that method calls can be chained together.      */      public ListKeysResult withTruncated(Boolean truncated) {         setTruncated(truncated);         return this;     }      /**      *       * A flag that indicates whether there are more items in the list. When this value is true, the list in this      * response is truncated. To retrieve more items, pass the value of the NextMarker element in this      * response to the Marker parameter in a subsequent request.      *       *       * @return A flag that indicates whether there are more items in the list. When this value is true, the list in this      *         response is truncated. To retrieve more items, pass the value of the NextMarker element in      *         this response to the Marker parameter in a subsequent request.      */      public Boolean isTruncated() {         return this.truncated;     }      /**      * Returns a string representation of this object; useful for testing and debugging.      *      * @return A string representation of this object.      *      * @see java.lang.Object#toString()      */     @Override     public String toString() {         StringBuilder sb = new StringBuilder();         sb.append(&quot;{&quot;);         if (getKeys() != null)             sb.append(&quot;Keys: &quot;).append(getKeys()).append(&quot;,&quot;);         if (getNextMarker() != null)             sb.append(&quot;NextMarker: &quot;).append(getNextMarker()).append(&quot;,&quot;);         if (getTruncated() != null)             sb.append(&quot;Truncated: &quot;).append(getTruncated());         sb.append(&quot;}&quot;);         return sb.toString();     }      @Override     public boolean equals(Object obj) {         if (this == obj)             return true;         if (obj == null)             return false;          if (obj instanceof ListKeysResult == false)             return false;         ListKeysResult other = (ListKeysResult) obj;         if (other.getKeys() == null ^ this.getKeys() == null)             return false;         if (other.getKeys() != null &amp;&amp; other.getKeys().equals(this.getKeys()) == false)             return false;         if (other.getNextMarker() == null ^ this.getNextMarker() == null)             return false;         if (other.getNextMarker() != null &amp;&amp; other.getNextMarker().equals(this.getNextMarker()) == false)             return false;         if (other.getTruncated() == null ^ this.getTruncated() == null)             return false;         if (other.getTruncated() != null &amp;&amp; other.getTruncated().equals(this.getTruncated()) == false)             return false;         return true;     }      @Override     public int hashCode() {         final int prime = 31;         int hashCode = 1;          hashCode = prime * hashCode + ((getKeys() == null) ? 0 : getKeys().hashCode());         hashCode = prime * hashCode + ((getNextMarker() == null) ? 0 : getNextMarker().hashCode());         hashCode = prime * hashCode + ((getTruncated() == null) ? 0 : getTruncated().hashCode());         return hashCode;     }      @Override     public ListKeysResult clone() {         try {             return (ListKeysResult) super.clone();         } catch (CloneNotSupportedException e) {             throw new IllegalStateException(&quot;Got a CloneNotSupportedException from Object.clone() &quot; + &quot;even though we're Cloneable!&quot;, e);         }     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14219</td>
    <td align="left">https://github.com/IBM/ibm-cos-sdk-java/blob/d6b03864c15c622ce439e39f20ab41a77dc1cc83/ibm-cos-java-sdk-kms/src/main/java/com/ibm/cloud/objectstorage/services/kms/model/ListKeysResult.java/#L22-L300</td>
    <td align="right">1</td>
    <td align="right">2351</td>
    <td align="right">14219</td>
  </tr>
  <tr valign="top">
    <td align="right">2175</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Implements(NfcAdapter.class) public class ShadowNfcAdapter {   @RealObject NfcAdapter nfcAdapter;   private static boolean hardwareExists = true;   private boolean enabled;   private Activity enabledActivity;   private PendingIntent intent;   private IntentFilter[] filters;   private String[][] techLists;   private Activity disabledActivity;   private NdefMessage ndefPushMessage;   private boolean ndefPushMessageSet;   private NfcAdapter.CreateNdefMessageCallback ndefPushMessageCallback;   private NfcAdapter.OnNdefPushCompleteCallback onNdefPushCompleteCallback;    @Implementation   protected static NfcAdapter getNfcAdapter(Context context) {     if (!hardwareExists) {       return null;     }     return ReflectionHelpers.callConstructor(NfcAdapter.class);   }    @Implementation   protected void enableForegroundDispatch(       Activity activity, PendingIntent intent, IntentFilter[] filters, String[][] techLists) {     this.enabledActivity = activity;     this.intent = intent;     this.filters = filters;     this.techLists = techLists;   }    @Implementation   protected void disableForegroundDispatch(Activity activity) {     disabledActivity = activity;   }    /**    * Mocks setting NDEF push message so that it could be verified in the test. Use {@link    * #getNdefPushMessage()} to verify that message was set.    */   @Implementation   protected void setNdefPushMessage(       NdefMessage message, Activity activity, Activity... activities) {     if (activity == null) {       throw new NullPointerException(&quot;activity cannot be null&quot;);     }     for (Activity a : activities) {       if (a == null) {         throw new NullPointerException(&quot;activities cannot contain null&quot;);       }     }     this.ndefPushMessage = message;     this.ndefPushMessageSet = true;   }    @Implementation   protected void setNdefPushMessageCallback(       NfcAdapter.CreateNdefMessageCallback callback, Activity activity, Activity... activities) {     this.ndefPushMessageCallback = callback;   }    /**    * Sets callback that should be used on successful Android Beam (TM).    *    * The last registered callback is recalled and can be fetched using {@link    * #getOnNdefPushCompleteCallback}.    */   @Implementation   protected void setOnNdefPushCompleteCallback(       NfcAdapter.OnNdefPushCompleteCallback callback, Activity activity, Activity... activities) {     if (activity == null) {       throw new NullPointerException(&quot;activity cannot be null&quot;);     }     for (Activity a : activities) {       if (a == null) {         throw new NullPointerException(&quot;activities cannot contain null&quot;);       }     }     this.onNdefPushCompleteCallback = callback;   }    @Implementation   protected boolean isEnabled() {     return enabled;   }    /**    * Modifies behavior of {@link #getNfcAdapter(Context)} to return {@code null}, to simulate    * absence of NFC hardware.    */   public static void setNfcHardwareExists(boolean hardwareExists) {     ShadowNfcAdapter.hardwareExists = hardwareExists;   }    public void setEnabled(boolean enabled) {     this.enabled = enabled;   }    public Activity getEnabledActivity() {     return enabledActivity;   }    public PendingIntent getIntent() {     return intent;   }    public IntentFilter[] getFilters() {     return filters;   }    public String[][] getTechLists() {     return techLists;   }    public Activity getDisabledActivity() {     return disabledActivity;   }    /** Returns last registered callback, or {@code null} if none was set. */   public NfcAdapter.CreateNdefMessageCallback getNdefPushMessageCallback() {     return ndefPushMessageCallback;   }    public NfcAdapter.OnNdefPushCompleteCallback getOnNdefPushCompleteCallback() {     return onNdefPushCompleteCallback;   }    /** Returns last set NDEF message, or throws {@code IllegalStateException} if it was never set. */   public NdefMessage getNdefPushMessage() {     if (!ndefPushMessageSet) {       throw new IllegalStateException();     }     return ndefPushMessage;   }    @Resetter   public static synchronized void reset() {     hardwareExists = true;   } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13394</td>
    <td align="left">https://github.com/robolectric/robolectric/blob/525bfcfc0e0ed1653ad57341b564c6857e11dc50/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNfcAdapter.java/#L15-L155</td>
    <td align="right">1</td>
    <td align="right">2175</td>
    <td align="right">13394</td>
  </tr>
  <tr valign="top">
    <td align="right">2058</td>
    <td align="left">&nbsp;&nbsp;YES I found bad smells the bad smells are: 1. Long Parameter List 2. Long Method 3. Data Class 4. Feature Envy 5. Switch Statements 6. Lazy Class</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
class CFRouteImpl implements CFRoute {  	final private String domain; 	final private String host; 	final private String path; 	final private int port; 	final private String fullRoute;  	CFRouteImpl(String domain, String host, String path, int port, String fullRoute)  { 		super(); 		this.domain = domain; 		this.host = host; 		this.path = path; 		this.port = port; 		this.fullRoute = fullRoute; 	}  	public String getDomain() { 		return domain; 	}  	public String getHost() { 		return host; 	}  	public String getPath() { 		return path; 	}  	public int getPort() { 		return port; 	}  	public String getRoute() { 		return fullRoute; 	}  	@Override 	public String toString() { 		return &quot;CFRoute [domain=&quot; + domain + &quot;, host=&quot; + host + &quot;, path=&quot; + path + &quot;, port=&quot; + port  +&quot;]&quot;; 	}   	@Override 	public int hashCode() { 		final int prime = 31; 		int result = 1; 		result = prime * result + ((domain == null) ? 0 : domain.hashCode()); 		result = prime * result + ((fullRoute == null) ? 0 : fullRoute.hashCode()); 		result = prime * result + ((host == null) ? 0 : host.hashCode()); 		result = prime * result + ((path == null) ? 0 : path.hashCode()); 		result = prime * result + port; 		return result; 	}  	@Override 	public boolean equals(Object obj) { 		if (this == obj) 			return true; 		if (obj == null) 			return false; 		if (getClass() != obj.getClass()) 			return false; 		CFRouteImpl other = (CFRouteImpl) obj; 		if (domain == null) { 			if (other.domain != null) 				return false; 		} else if (!domain.equals(other.domain)) 			return false; 		if (fullRoute == null) { 			if (other.fullRoute != null) 				return false; 		} else if (!fullRoute.equals(other.fullRoute)) 			return false; 		if (host == null) { 			if (other.host != null) 				return false; 		} else if (!host.equals(other.host)) 			return false; 		if (path == null) { 			if (other.path != null) 				return false; 		} else if (!path.equals(other.path)) 			return false; 		if (port != other.port) 			return false; 		return true; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long Parameter List2 Long Method3 Data Class4 Feature Envy5 Switch Statements6 Lazy Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12960</td>
    <td align="left">https://github.com/spring-projects/sts4/blob/46e9e985b0c5e28ea1952d9fc640ec12fd9c8fdd/headless-services/commons/commons-cf/src/main/java/org/springframework/ide/vscode/commons/cloudfoundry/client/CFRouteImpl.java/#L3-L92</td>
    <td align="right">2</td>
    <td align="right">2058</td>
    <td align="right">12960</td>
  </tr>
  <tr valign="top">
    <td align="right">160</td>
    <td align="left">&nbsp;{ &quot;message&quot;: &quot;YES I found bad smells. The bad smells are: 1. Data Class&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Car2 {   @Id   private String numberPlate;      private String colour;      private int engineSize;      private int numberOfSeats;    public String getNumberPlate() {     return numberPlate;   }    public void setNumberPlate(String numberPlate) {     this.numberPlate = numberPlate;   }    public String getColour() {     return colour;   }    public void setColour(String colour) {     this.colour = colour;   }    public int getEngineSize() {     return engineSize;   }    public void setEngineSize(int engineSize) {     this.engineSize = engineSize;   }    public int getNumberOfSeats() {     return numberOfSeats;   }    public void setNumberOfSeats(int numberOfSeats) {     this.numberOfSeats = numberOfSeats;   }       }</td>
    <td align="left">data class</td>
    <td align="left">1. data class </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1985</td>
    <td align="left">https://github.com/apache/aries-jpa/blob/f8a04dfabbf0853af07926e4d8f8028b0d829bc8/itests/jpa-container-testbundle-eclipselink/src/main/java/org/apache/aries/jpa/container/itest/eclipselink/entities/Car2.java/#L24-L68</td>
    <td align="right">1</td>
    <td align="right">160</td>
    <td align="right">1985</td>
  </tr>
  <tr valign="top">
    <td align="right">5419</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@InterfaceAudience.Private public class HFileBlockDefaultEncodingContext implements     HFileBlockEncodingContext {   private BlockType blockType;   private final DataBlockEncoding encodingAlgo;    private byte[] dummyHeader;    // Compression state    /** Compressor, which is also reused between consecutive blocks. */   private Compressor compressor;   /** Compression output stream */   private CompressionOutputStream compressionStream;   /** Underlying stream to write compressed bytes to */   private ByteArrayOutputStream compressedByteStream;    private HFileContext fileContext;   private TagCompressionContext tagCompressionContext;    // Encryption state    /** Underlying stream to write encrypted bytes to */   private ByteArrayOutputStream cryptoByteStream;   /** Initialization vector */   private byte[] iv;    private EncodingState encoderState;    /**    * @param encoding encoding used    * @param headerBytes dummy header bytes    * @param fileContext HFile meta data    */   public HFileBlockDefaultEncodingContext(DataBlockEncoding encoding, byte[] headerBytes,       HFileContext fileContext) {     this.encodingAlgo = encoding;     this.fileContext = fileContext;     Compression.Algorithm compressionAlgorithm =         fileContext.getCompression() == null ? NONE : fileContext.getCompression();     if (compressionAlgorithm != NONE) {       compressor = compressionAlgorithm.getCompressor();       compressedByteStream = new ByteArrayOutputStream();       try {         compressionStream =             compressionAlgorithm.createPlainCompressionStream(                 compressedByteStream, compressor);       } catch (IOException e) {         throw new RuntimeException(             &quot;Could not create compression stream for algorithm &quot;                 + compressionAlgorithm, e);       }     }      Encryption.Context cryptoContext = fileContext.getEncryptionContext();     if (cryptoContext != Encryption.Context.NONE) {       cryptoByteStream = new ByteArrayOutputStream();       iv = new byte[cryptoContext.getCipher().getIvLength()];       new SecureRandom().nextBytes(iv);     }      dummyHeader = Preconditions.checkNotNull(headerBytes,       &quot;Please pass HConstants.HFILEBLOCK_DUMMY_HEADER instead of null for param headerBytes&quot;);   }    /**    * prepare to start a new encoding.    * @throws IOException    */   public void prepareEncoding(DataOutputStream out) throws IOException {     if (encodingAlgo != null &amp;&amp; encodingAlgo != DataBlockEncoding.NONE) {       encodingAlgo.writeIdInBytes(out);     }   }    @Override   public void postEncoding(BlockType blockType)       throws IOException {     this.blockType = blockType;   }    @Override   public Bytes compressAndEncrypt(byte[] data, int offset, int length) throws IOException {     return compressAfterEncoding(data, offset, length, dummyHeader);   }    private Bytes compressAfterEncoding(byte[] uncompressedBytesWithHeaderBuffer,         int uncompressedBytesWithHeaderOffset, int uncompressedBytesWithHeaderLength, byte[] headerBytes)       throws IOException {     Encryption.Context cryptoContext = fileContext.getEncryptionContext();     if (cryptoContext != Encryption.Context.NONE) {        // Encrypted block format:       // +--------------------------+       // | byte iv length           |       // +--------------------------+       // | iv data ...              |       // +--------------------------+       // | encrypted block data ... |       // +--------------------------+        cryptoByteStream.reset();       // Write the block header (plaintext)       cryptoByteStream.write(headerBytes);        InputStream in;       int plaintextLength;       // Run any compression before encryption       if (fileContext.getCompression() != Compression.Algorithm.NONE) {         compressedByteStream.reset();         compressionStream.resetState();         compressionStream.write(uncompressedBytesWithHeaderBuffer,             headerBytes.length + uncompressedBytesWithHeaderOffset, uncompressedBytesWithHeaderLength - headerBytes.length);         compressionStream.flush();         compressionStream.finish();         byte[] plaintext = compressedByteStream.toByteArray();         plaintextLength = plaintext.length;         in = new ByteArrayInputStream(plaintext);       } else {         plaintextLength = uncompressedBytesWithHeaderLength - headerBytes.length;         in = new ByteArrayInputStream(uncompressedBytesWithHeaderBuffer,           headerBytes.length + uncompressedBytesWithHeaderOffset, plaintextLength);       }        if (plaintextLength &gt; 0) {          // Set up the cipher         Cipher cipher = cryptoContext.getCipher();         Encryptor encryptor = cipher.getEncryptor();         encryptor.setKey(cryptoContext.getKey());          // Set up the IV         int ivLength = iv.length;         Preconditions.checkState(ivLength &lt;= Byte.MAX_VALUE, &quot;IV length out of range&quot;);         cryptoByteStream.write(ivLength);         if (ivLength &gt; 0) {           encryptor.setIv(iv);           cryptoByteStream.write(iv);         }          // Encrypt the data         Encryption.encrypt(cryptoByteStream, in, encryptor);          // Increment the IV given the final block size         Encryption.incrementIv(iv, 1 + (cryptoByteStream.size() / encryptor.getBlockSize()));         return new Bytes(cryptoByteStream.getBuffer(), 0, cryptoByteStream.size());       } else {          cryptoByteStream.write(0);         return new Bytes(cryptoByteStream.getBuffer(), 0, cryptoByteStream.size());       }      } else {        if (this.fileContext.getCompression() != NONE) {         compressedByteStream.reset();         compressedByteStream.write(headerBytes);         compressionStream.resetState();         compressionStream.write(uncompressedBytesWithHeaderBuffer,           headerBytes.length + uncompressedBytesWithHeaderOffset, uncompressedBytesWithHeaderLength               - headerBytes.length);         compressionStream.flush();         compressionStream.finish();         return new Bytes(compressedByteStream.getBuffer(), 0, compressedByteStream.size());       } else {         return null;       }     }   }    @Override   public BlockType getBlockType() {     return blockType;   }    /**    * Releases the compressor this writer uses to compress blocks into the    * compressor pool.    */   @Override   public void close() {     if (compressor != null) {       this.fileContext.getCompression().returnCompressor(compressor);       compressor = null;     }   }    @Override   public DataBlockEncoding getDataBlockEncoding() {     return this.encodingAlgo;   }    @Override   public HFileContext getHFileContext() {     return this.fileContext;   }    public TagCompressionContext getTagCompressionContext() {     return tagCompressionContext;   }    public void setTagCompressionContext(TagCompressionContext tagCompressionContext) {     this.tagCompressionContext = tagCompressionContext;   }    @Override   public EncodingState getEncodingState() {     return this.encoderState;   }    @Override   public void setEncodingState(EncodingState state) {     this.encoderState = state;   } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15209</td>
    <td align="left">https://github.com/apache/hbase/blob/44f8abd5c65c59e9d09f6ad14b3c825f145d8e4f/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/HFileBlockDefaultEncodingContext.java/#L49-L263</td>
    <td align="right">1</td>
    <td align="right">5419</td>
    <td align="right">15209</td>
  </tr>
  <tr valign="top">
    <td align="right">2503</td>
    <td align="left">{     &quot;response&quot;: &quot;YES, I found bad smells&quot;,     &quot;bad_smells&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class Build {          /**          * Project version.          */         private String version = &quot;&quot;;          public String getVersion() {             return version;         }          public void setVersion(final String version) {             this.version = version;         }      }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14665</td>
    <td align="left">https://github.com/eclipse/hawkbit/blob/51be28147f6f575b6c1ab4a5ef84ffd9174f1209/hawkbit-core/src/main/java/org/eclipse/hawkbit/HawkbitServerProperties.java/#L75-L90</td>
    <td align="right">1</td>
    <td align="right">2503</td>
    <td align="right">14665</td>
  </tr>
  <tr valign="top">
    <td align="right">2213</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Customer1392 {  	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id; 	private String firstName; 	private String lastName;  	protected Customer1392() {}  	public Customer1392(String firstName, String lastName) { 		this.firstName = firstName; 		this.lastName = lastName; 	}  	@Override 	public String toString() { 		return String.format(&quot;Customer1392[id=%d, firstName='%s', lastName='%s']&quot;, id, firstName, lastName); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13526</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer1392.java/#L8-L27</td>
    <td align="right">1</td>
    <td align="right">2213</td>
    <td align="right">13526</td>
  </tr>
  <tr valign="top">
    <td align="right">2097</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells&quot;: [&quot;Long Method&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private static class Map4 extends Map3 {         /** */         private static final long serialVersionUID = 0L;          /** */         protected K k4;          /** */         protected V v4;          /**          * Constructs map.          */         Map4() {             // No-op.         }          /**          * Constructs map.          *          * @param k1 Key1.          * @param v1 Value1.          * @param k2 Key2.          * @param v2 Value2.          * @param k3 Key3.          * @param v3 Value3.          * @param k4 Key4.          * @param v4 Value4.          */         Map4(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {             super(k1, v1, k2, v2, k3, v3);              this.k4 = k4;             this.v4 = v4;         }          /** {@inheritDoc} */         @Override public boolean isFull() {             return size() == 4;         }          /** {@inheritDoc} */         @Nullable @Override public V remove(Object key) {             if (F.eq(key, k4)) {                 V res = v4;                  v4 = null;                 k4 = null;                  return res;             }              return super.remove(key);         }          /** {@inheritDoc} */         @Override public int size() {             return super.size() + (k4 != null ? 1 : 0);         }          /** {@inheritDoc} */         @Override public boolean containsKey(Object k) {             return super.containsKey(k) || (k4 != null &amp;&amp; F.eq(k, k4));         }          /** {@inheritDoc} */         @Override public boolean containsValue(Object v) {             return super.containsValue(v) || (k4 != null &amp;&amp; F.eq(v, v4));         }          /** {@inheritDoc} */         @Nullable @Override public V get(Object k) {             V v = super.get(k);              return v != null ? v : (k4 != null &amp;&amp; F.eq(k, k4)) ? v4 : null;         }          /**          * Puts key-value pair into map only if given key is already contained in the map          * or there are free slots.          * Note that this implementation of {@link Map#put(Object, Object)} does not match          * general contract of {@link Map} interface and serves only for internal purposes.          *          * @param key Key.          * @param val Value.          * @return Previous value associated with given key.          */         @Nullable @Override public V put(K key, V val) throws NullPointerException {             V oldVal = get(key);              if (k1 == null || F.eq(k1, key)) {                 k1 = key;                 v1 = val;             }             else if (k2 == null || F.eq(k2, key)) {                 k2 = key;                 v2 = val;             }             else if (k3 == null || F.eq(k3, key)) {                 k3 = key;                 v3 = val;             }             else if (k4 == null || F.eq(k4, key)) {                 k4 = key;                 v4 = val;             }              return oldVal;         }          /** {@inheritDoc} */         @Override public Set&gt; entrySet() {             return new AbstractSet&gt;() {                 @Override public Iterator&gt; iterator() {                     return new Iterator&gt;() {                         private int idx;                          private Entry next;                          {                             if (k1 != null) {                                 idx = 1;                                 next = e(k1, v1);                             }                             else if (k2 != null) {                                 idx = 2;                                 next = e(k2, v2);                             }                             else if (k3 != null) {                                 idx = 3;                                 next = e(k3, v3);                             }                             else if (k4 != null) {                                 idx = 4;                                 next = e(k4, v4);                             }                         }                          @Override public boolean hasNext() {                             return next != null;                         }                          @SuppressWarnings(&quot;fallthrough&quot;)                         @Override public Entry next() {                             if (!hasNext())                                 throw new NoSuchElementException();                              Entry old = next;                              next = null;                              switch (idx) {                                 case 1:                                     if (k2 != null) {                                         idx = 2;                                         next = e(k2, v2);                                          break;                                     }                                  case 2:                                     if (k3 != null) {                                         idx = 3;                                         next = e(k3, v3);                                          break;                                     }                                  case 3:                                     if (k4 != null) {                                         idx = 4;                                         next = e(k4, v4);                                          break;                                     }                             }                              return old;                         }                          @Override public void remove() {                             throw new UnsupportedOperationException();                         }                     };                 }                  @Override public int size() {                     return Map4.this.size();                 }             };         }     }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">13149</td>
    <td align="left">https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/core/src/main/java/org/apache/ignite/internal/util/GridLeanMap.java/#L836-L1027</td>
    <td align="right">1</td>
    <td align="right">2097</td>
    <td align="right">13149</td>
  </tr>
  <tr valign="top">
    <td align="right">2087</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class _RepositorySoap_LabelItem     implements ElementSerializable {     // No attributes          // Elements     protected String workspaceName;     protected String workspaceOwner;     protected _VersionControlLabel label;     protected _LabelItemSpec[] labelSpecs;     protected _LabelChildOption children;      public _RepositorySoap_LabelItem()     {         super();     }      public _RepositorySoap_LabelItem(         final String workspaceName,         final String workspaceOwner,         final _VersionControlLabel label,         final _LabelItemSpec[] labelSpecs,         final _LabelChildOption children)     {         // TODO : Call super() instead of setting all fields directly?         setWorkspaceName(workspaceName);         setWorkspaceOwner(workspaceOwner);         setLabel(label);         setLabelSpecs(labelSpecs);         setChildren(children);     }      public String getWorkspaceName()     {         return this.workspaceName;     }      public void setWorkspaceName(String value)     {         this.workspaceName = value;     }      public String getWorkspaceOwner()     {         return this.workspaceOwner;     }      public void setWorkspaceOwner(String value)     {         this.workspaceOwner = value;     }      public _VersionControlLabel getLabel()     {         return this.label;     }      public void setLabel(_VersionControlLabel value)     {         this.label = value;     }      public _LabelItemSpec[] getLabelSpecs()     {         return this.labelSpecs;     }      public void setLabelSpecs(_LabelItemSpec[] value)     {         this.labelSpecs = value;     }      public _LabelChildOption getChildren()     {         return this.children;     }      public void setChildren(_LabelChildOption value)     {         if (value == null)         {             throw new IllegalArgumentException(&quot;'children' is a required element, its value cannot be null&quot;);         }          this.children = value;     }      public void writeAsElement(         final XMLStreamWriter writer,         final String name)         throws XMLStreamException     {         writer.writeStartElement(name);          // Elements         XMLStreamWriterHelper.writeElement(             writer,             &quot;workspaceName&quot;,             this.workspaceName);         XMLStreamWriterHelper.writeElement(             writer,             &quot;workspaceOwner&quot;,             this.workspaceOwner);          if (this.label != null)         {             this.label.writeAsElement(                 writer,                 &quot;label&quot;);         }          if (this.labelSpecs != null)         {             /*              * The element type is an array.              */             writer.writeStartElement(&quot;labelSpecs&quot;);              for (int iterator0 = 0; iterator0 &lt; this.labelSpecs.length; iterator0++)             {                 this.labelSpecs[iterator0].writeAsElement(                     writer,                     &quot;LabelItemSpec&quot;);             }              writer.writeEndElement();         }          this.children.writeAsElement(             writer,             &quot;children&quot;);          writer.writeEndElement();     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13106</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core.ws/generated-src/ms/tfs/versioncontrol/clientservices/_03/_RepositorySoap_LabelItem.java/#L42-L176</td>
    <td align="right">1</td>
    <td align="right">2087</td>
    <td align="right">13106</td>
  </tr>
  <tr valign="top">
    <td align="right">920</td>
    <td align="left">{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     {       &quot;bad_smells_are&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;       ]     }   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SuppressWarnings(&quot;serial&quot;) public class ForeignKeyInfo implements Serializable {    public class ForeignKeyCol {     public String parentTableName;     public String parentDatabaseName;     public String parentColName;     public String childColName;     public Integer position;      public ForeignKeyCol(String parentTableName, String parentDatabaseName, String parentColName,       String childColName, Integer position) {       this.parentTableName = parentTableName;       this.parentDatabaseName = parentDatabaseName;       this.parentColName = parentColName;       this.childColName = childColName;       this.position = position;     }   }    // Mapping from constraint name to list of foreign keys   Map&gt; foreignKeys;   String childTableName;   String childDatabaseName;    public ForeignKeyInfo() {}    public ForeignKeyInfo(List fks, String childTableName, String childDatabaseName) {     this.childTableName = childTableName;     this.childDatabaseName = childDatabaseName;     foreignKeys = new TreeMap&gt;();     if (fks == null) {       return;     }     for (SQLForeignKey fk : fks) {       if (fk.getFktable_db().equalsIgnoreCase(childDatabaseName) &amp;&amp;           fk.getFktable_name().equalsIgnoreCase(childTableName)) {         ForeignKeyCol currCol = new ForeignKeyCol(fk.getPktable_name(), fk.getPktable_db(),           fk.getPkcolumn_name(), fk.getFkcolumn_name(), fk.getKey_seq());         String constraintName = fk.getFk_name();         if (foreignKeys.containsKey(constraintName)) {           foreignKeys.get(constraintName).add(currCol);         } else {           List currList = new ArrayList();           currList.add(currCol);           foreignKeys.put(constraintName, currList);         }       }     }   }    public String getChildTableName() {     return childTableName;   }    public String getChildDatabaseName() {     return childDatabaseName;   }    public Map&gt; getForeignKeys() {     return foreignKeys;   }    public void setChildTableName(String tableName) {     this.childTableName = tableName;   }    public void setChildDatabaseName(String databaseName) {     this.childDatabaseName = databaseName;   }    public void setForeignKeys(Map&gt; foreignKeys) {     this.foreignKeys = foreignKeys;   }    @Override   public String toString() {     StringBuilder sb = new StringBuilder();     sb.append(&quot;Foreign Keys for &quot; + childDatabaseName+&quot;.&quot;+childTableName+&quot;:&quot;);     sb.append(&quot;[&quot;);     if (foreignKeys != null &amp;&amp; foreignKeys.size() &gt; 0) {       for (Map.Entry&gt; me : foreignKeys.entrySet()) {         sb.append(&quot; {Constraint Name: &quot; + me.getKey() + &quot;,&quot;);         List currCol = me.getValue();         if (currCol != null &amp;&amp; currCol.size() &gt; 0) {           for (ForeignKeyCol fkc : currCol) {             sb.append (&quot; (Parent Column Name: &quot; + fkc.parentDatabaseName +               &quot;.&quot;+ fkc.parentTableName + &quot;.&quot; + fkc.parentColName +               &quot;, Column Name: &quot; + fkc.childColName + &quot;, Key Sequence: &quot; + fkc.position+ &quot;),&quot;);           }           sb.setLength(sb.length()-1);         }         sb.append(&quot;},&quot;);       }       sb.setLength(sb.length()-1);     }     sb.append(&quot;]&quot;);     return sb.toString();   } }</td>
    <td align="left">data class</td>
    <td align="left">bad_smells_are: data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8275</td>
    <td align="left">https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/ql/src/java/org/apache/hadoop/hive/ql/metadata/ForeignKeyInfo.java/#L37-L136</td>
    <td align="right">1</td>
    <td align="right">920</td>
    <td align="right">8275</td>
  </tr>
  <tr valign="top">
    <td align="right">540</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class FilterParams {      private final Collection filterByStatus;     private final Boolean overdueState;     private final String filterBySearchText;     private final Boolean selectTargetWithNoTag;     private final String[] filterByTagNames;     private final Long filterByDistributionId;      /**      * Constructor.      *      * @param filterByInstalledOrAssignedDistributionSetId      *            if set, a filter is added for the given      *            {@link DistributionSet#getId()}      * @param filterByStatus      *            if set, a filter is added for target states included by the      *            collection      * @param overdueState      *            if set, a filter is added for overdued devices      * @param filterBySearchText      *            if set, a filter is added for the given search text      * @param selectTargetWithNoTag      *            if set, tag-filtering is enabled      * @param filterByTagNames      *            if tag-filtering is enabled, a filter is added for the given      *            tag-names      */     public FilterParams(final Collection filterByStatus, final Boolean overdueState,             final String filterBySearchText, final Long filterByInstalledOrAssignedDistributionSetId,             final Boolean selectTargetWithNoTag, final String... filterByTagNames) {         this.filterByStatus = filterByStatus;         this.overdueState = overdueState;         this.filterBySearchText = filterBySearchText;         this.filterByDistributionId = filterByInstalledOrAssignedDistributionSetId;         this.selectTargetWithNoTag = selectTargetWithNoTag;         this.filterByTagNames = filterByTagNames;     }      /**      * Gets {@link DistributionSet#getId()} to filter the result.       * If set to null this filter is disabled.      *      * @return {@link DistributionSet#getId()} to filter the result      */     public Long getFilterByDistributionId() {         return filterByDistributionId;     }      /**      * Gets a collection of target states to filter for.       * If set to null this filter is disabled.      *      * @return collection of target states to filter for      */     public Collection getFilterByStatus() {         return filterByStatus;     }      /**      * Gets the flag for overdue filter; if set to true, the      * overdue filter is activated. Overdued targets a targets that did not      * respond during the configured intervals: poll_itvl + overdue_itvl.       * If set to null this filter is disabled.      *      * @return flag for overdue filter activation      */     public Boolean getOverdueState() {         return overdueState;     }      /**      * Gets the search text to filter for. This is used to find targets having      * the text anywhere in name or description       * If set to null this filter is disabled.      *      * @return the search text to filter for      */     public String getFilterBySearchText() {         return filterBySearchText;     }      /**      * Gets the flag indicating if tagging filter is used.       * If set to null this filter is disabled.      *      * @return the flag indicating if tagging filter is used      */     public Boolean getSelectTargetWithNoTag() {         return selectTargetWithNoTag;     }      /**      * Gets the tags that are used to filter for. The activation of this filter      * is done by {@link #setSelectTargetWithNoTag(Boolean)}.      *      * @return the tags that are used to filter for      */     public String[] getFilterByTagNames() {         return filterByTagNames;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5535</td>
    <td align="left">https://github.com/eclipse/hawkbit/blob/51be28147f6f575b6c1ab4a5ef84ffd9174f1209/hawkbit-repository/hawkbit-repository-api/src/main/java/org/eclipse/hawkbit/repository/FilterParams.java/#L22-L123</td>
    <td align="right">1</td>
    <td align="right">540</td>
    <td align="right">5535</td>
  </tr>
  <tr valign="top">
    <td align="right">897</td>
    <td align="left">&nbsp;&nbsp;YES I found bad smells the bad smells are: 1.Feature envy, 2.Excessive method length, 3.Long parameter list, 4.Data class, 5.Missing encapsulation.</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
@Entity @Table(name = &quot;ESPM_SUPPLIER&quot;) @NamedQueries({ 	@NamedQuery(name = &quot;Supplier.getAllSuppliers&quot;, query = &quot;SELECT s FROM Supplier s&quot;), 	@NamedQuery(name = &quot;Supplier.getSupplierBySupplierId&quot;, query = &quot;SELECT s FROM Supplier s WHERE s.supplierId= :supplierId&quot;) }) public class Supplier { 	/* Supplier ids are generated within a number range starting with 2 */ 	@TableGenerator(name = &quot;SupplierGenerator&quot;, table = &quot;ESPM_ID_GENERATOR&quot;, pkColumnName = &quot;GENERATOR_NAME&quot;, valueColumnName = &quot;GENERATOR_VALUE&quot;, pkColumnValue = &quot;Customer&quot;, initialValue = 100000000, allocationSize = 100) 	@Id 	@GeneratedValue(strategy = GenerationType.TABLE, generator = &quot;SupplierGenerator&quot;) 	@Column(name = &quot;SUPPLIER_ID&quot;, length = 10) 	private String supplierId;  	@Column(name = &quot;EMAIL_ADDRESS&quot;, unique = true) 	private String emailAddress;  	@Column(name = &quot;PHONE_NUMBER&quot;, length = 30) 	private String phoneNumber;  	@Column(name = &quot;CITY&quot;, length = 40) 	private String city;  	@Column(name = &quot;POSTAL_CODE&quot;, length = 10) 	private String postalCode;  	@Column(name = &quot;STREET&quot;, length = 60) 	private String street;  	@Column(name = &quot;HOUSE_NUMBER&quot;, length = 10) 	private String houseNumber;  	@Column(name = &quot;COUNTRY&quot;, length = 3) 	private String country;  	@Column(name = &quot;SUPPLIER_NAME&quot;, length = 80) 	private String supplierName;  	public String getSupplierId() { 		return supplierId; 	}  	public void setSupplierId(String id) { 		this.supplierId = id; 	}  	public void setEmailAddress(String param) { 		this.emailAddress = param; 	}  	public String getEmailAddress() { 		return emailAddress; 	}  	public void setPhoneNumber(String param) { 		this.phoneNumber = param; 	}  	public String getPhoneNumber() { 		return phoneNumber; 	}  	public void setCity(String param) { 		this.city = param; 	}  	public String getCity() { 		return city; 	}  	public void setPostalCode(String param) { 		this.postalCode = param; 	}  	public String getPostalCode() { 		return postalCode; 	}  	public void setStreet(String param) { 		this.street = param; 	}  	public String getStreet() { 		return street; 	}  	public void setHouseNumber(String param) { 		this.houseNumber = param; 	}  	public String getHouseNumber() { 		return houseNumber; 	}  	public void setCountry(String param) { 		this.country = param; 	}  	public String getCountry() { 		return country; 	}  	public void setSupplierName(String param) { 		this.supplierName = param; 	}  	public String getSupplierName() { 		return supplierName; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">Feature envy, 2Excessive method length, 3Long parameter list, 4Data class, 5Missing encapsulation</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">.Feature envy,  2.Excessive method length,  3.Long parameter list,  5.Missing encapsulation.</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8148</td>
    <td align="left">https://github.com/SAP/cloud-espm-v2/blob/a5254f2e6fea9b7226296fbe19eb30ab99192b8d/espm-cloud-jpa/src/main/java/com/sap/espm/model/Supplier.java/#L13-L123</td>
    <td align="right">2</td>
    <td align="right">897</td>
    <td align="right">8148</td>
  </tr>
  <tr valign="top">
    <td align="right">1896</td>
    <td align="left">{&quot;response&quot;: &quot;YES, I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class FileDiskCacheAttributes     extends AbstractDiskCacheAttributes {     /** Don't change. */     private static final long serialVersionUID = -7371586172678836062L;      /** Default file count limit: -1 means no limit */     public static final int DEFAULT_MAX_NUMBER_OF_FILES = -1;      /** Max number of files */     private int maxNumberOfFiles = DEFAULT_MAX_NUMBER_OF_FILES;      /** Default limit on the number of times we will retry a delete. */     public static final int DEFAULT_MAX_RETRIES_ON_DELETE = 10;      /** Max number of retries on delete */     private int maxRetriesOnDelete = DEFAULT_MAX_RETRIES_ON_DELETE;      /** Default touch rule. */     public static final boolean DEFAULT_TOUCH_ON_GET = false;      /** Default limit on the number of times we will retry a delete. */     public static final int DEFAULT_MAX_RETRIES_ON_TOUCH = 10;      /** Max number of retries on touch  */     private int maxRetriesOnTouch = DEFAULT_MAX_RETRIES_ON_TOUCH;      /**      * Should we touch on get. If so, we will reset the last modified time. If you have a max file      * size set, this will make the removal strategy LRU. If this is false, then the oldest will be      * removed.      */     private boolean touchOnGet = DEFAULT_TOUCH_ON_GET;      /**      * @param maxNumberOfFiles the maxNumberOfFiles to set      */     public void setMaxNumberOfFiles( int maxNumberOfFiles )     {         this.maxNumberOfFiles = maxNumberOfFiles;     }      /**      * @return the maxNumberOfFiles      */     public int getMaxNumberOfFiles()     {         return maxNumberOfFiles;     }      /**      * @param maxRetriesOnDelete the maxRetriesOnDelete to set      */     public void setMaxRetriesOnDelete( int maxRetriesOnDelete )     {         this.maxRetriesOnDelete = maxRetriesOnDelete;     }      /**      * @return the maxRetriesOnDelete      */     public int getMaxRetriesOnDelete()     {         return maxRetriesOnDelete;     }      /**      * @param touchOnGet the touchOnGet to set      */     public void setTouchOnGet( boolean touchOnGet )     {         this.touchOnGet = touchOnGet;     }      /**      * @return the touchOnGet      */     public boolean isTouchOnGet()     {         return touchOnGet;     }      /**      * @param maxRetriesOnTouch the maxRetriesOnTouch to set      */     public void setMaxRetriesOnTouch( int maxRetriesOnTouch )     {         this.maxRetriesOnTouch = maxRetriesOnTouch;     }      /**      * @return the maxRetriesOnTouch      */     public int getMaxRetriesOnTouch()     {         return maxRetriesOnTouch;     }      /**      * Write out the values for debugging purposes.      *       * @return String      */     @Override     public String toString()     {         StringBuilder str = new StringBuilder();         str.append( &quot;DiskFileCacheAttributes &quot; );         str.append( &quot;\n diskPath = &quot; + super.getDiskPath() );         str.append( &quot;\n maxNumberOfFiles   = &quot; + getMaxNumberOfFiles() );         str.append( &quot;\n maxRetriesOnDelete  = &quot; + getMaxRetriesOnDelete() );         return str.toString();     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12334</td>
    <td align="left">https://github.com/apache/commons-jcs/blob/ad897014842fc830483f32fdfb903f3bb8f70289/commons-jcs-sandbox/filecache/src/main/java/org/apache/commons/jcs/auxiliary/disk/file/FileDiskCacheAttributes.java/#L27-L140</td>
    <td align="right">1</td>
    <td align="right">1896</td>
    <td align="right">12334</td>
  </tr>
  <tr valign="top">
    <td align="right">1743</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ImportImpl extends ElementImpl implements Import {   /**    * The default value of the '{@link #getImportedNamespace() Imported Namespace}' attribute.    *     *     * @see #getImportedNamespace()    * @generated    * @ordered    */   protected static final String IMPORTED_NAMESPACE_EDEFAULT = null;    /**    * The cached value of the '{@link #getImportedNamespace() Imported Namespace}' attribute.    *     *     * @see #getImportedNamespace()    * @generated    * @ordered    */   protected String importedNamespace = IMPORTED_NAMESPACE_EDEFAULT;    /**    *     *     * @generated    */   protected ImportImpl()   {     super();   }    /**    *     *     * @generated    */   @Override   protected EClass eStaticClass()   {     return SDomainPackage.Literals.IMPORT;   }    /**    *     *     * @generated    */   public String getImportedNamespace()   {     return importedNamespace;   }    /**    *     *     * @generated    */   public void setImportedNamespace(String newImportedNamespace)   {     String oldImportedNamespace = importedNamespace;     importedNamespace = newImportedNamespace;     if (eNotificationRequired())       eNotify(new ENotificationImpl(this, Notification.SET, SDomainPackage.IMPORT__IMPORTED_NAMESPACE, oldImportedNamespace, importedNamespace));   }    /**    *     *     * @generated    */   @Override   public Object eGet(int featureID, boolean resolve, boolean coreType)   {     switch (featureID)     {       case SDomainPackage.IMPORT__IMPORTED_NAMESPACE:         return getImportedNamespace();     }     return super.eGet(featureID, resolve, coreType);   }    /**    *     *     * @generated    */   @Override   public void eSet(int featureID, Object newValue)   {     switch (featureID)     {       case SDomainPackage.IMPORT__IMPORTED_NAMESPACE:         setImportedNamespace((String)newValue);         return;     }     super.eSet(featureID, newValue);   }    /**    *     *     * @generated    */   @Override   public void eUnset(int featureID)   {     switch (featureID)     {       case SDomainPackage.IMPORT__IMPORTED_NAMESPACE:         setImportedNamespace(IMPORTED_NAMESPACE_EDEFAULT);         return;     }     super.eUnset(featureID);   }    /**    *     *     * @generated    */   @Override   public boolean eIsSet(int featureID)   {     switch (featureID)     {       case SDomainPackage.IMPORT__IMPORTED_NAMESPACE:         return IMPORTED_NAMESPACE_EDEFAULT == null ? importedNamespace != null : !IMPORTED_NAMESPACE_EDEFAULT.equals(importedNamespace);     }     return super.eIsSet(featureID);   }    /**    *     *     * @generated    */   @Override   public String toString()   {     if (eIsProxy()) return super.toString();      StringBuffer result = new StringBuffer(super.toString());     result.append(&quot; (importedNamespace: &quot;);     result.append(importedNamespace);     result.append(')');     return result.toString();   }  } //ImportImpl</td>
    <td align="left">data class</td>
    <td align="left">Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11846</td>
    <td align="left">https://github.com/eclipse/xtext-idea/blob/3aa1424ae35f1942dd7c3a457057006f9131de5e/org.eclipse.xtext.idea.sdomain/src-gen/org/eclipse/xtext/idea/sdomain/sDomain/impl/ImportImpl.java/#L34-L183</td>
    <td align="right">1</td>
    <td align="right">1743</td>
    <td align="right">11846</td>
  </tr>
  <tr valign="top">
    <td align="right">1417</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class JdbVariable implements Variable {   private final LocalVariable jdiVariable;   private final SimpleValue value;    public JdbVariable(StackFrame jdiStackFrame, LocalVariable jdiVariable) {     Value jdiValue = jdiStackFrame.getValue(jdiVariable);      this.jdiVariable = jdiVariable;     this.value = jdiValue == null ? new JdbNullValue() : new JdbValue(jdiValue, getVariablePath());   }    public JdbVariable(SimpleValue value, LocalVariable jdiVariable) {     this.jdiVariable = jdiVariable;     this.value = value;   }    @Override   public String getName() {     return jdiVariable.name();   }    @Override   public boolean isPrimitive() {     return JdbType.isPrimitive(jdiVariable.signature());   }    @Override   public SimpleValue getValue() {     return value;   }    @Override   public String getType() {     return jdiVariable.typeName();   }    @Override   public VariablePath getVariablePath() {     return new VariablePathImpl(getName());   } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10917</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/plugins/plugin-java-debugger/che-plugin-java-debugger-server/src/main/java/org/eclipse/che/plugin/jdb/server/model/JdbVariable.java/#L27-L67</td>
    <td align="right">1</td>
    <td align="right">1417</td>
    <td align="right">10917</td>
  </tr>
  <tr valign="top">
    <td align="right">1260</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Blob&quot;,       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  @XmlAccessorType(XmlAccessType.FIELD)   @XmlType(name = &quot;&quot;, propOrder = {&quot;gateways&quot;})   public static class GatewayHub {      @XmlElement(name = &quot;gateway&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)     protected List gateways;     @XmlAttribute(name = &quot;id&quot;, required = true)     protected String id;     @XmlAttribute(name = &quot;bind-address&quot;)     protected String bindAddress;     @XmlAttribute(name = &quot;maximum-time-between-pings&quot;)     protected String maximumTimeBetweenPings;     @XmlAttribute(name = &quot;port&quot;)     protected String port;     @XmlAttribute(name = &quot;socket-buffer-size&quot;)     protected String socketBufferSize;     @XmlAttribute(name = &quot;startup-policy&quot;)     protected String startupPolicy;     @XmlAttribute(name = &quot;manual-start&quot;)     protected Boolean manualStart;     @XmlAttribute(name = &quot;max-connections&quot;)     protected BigInteger maxConnections;      /**      * Gets the value of the gateway property.      *      *       * This accessor method returns a reference to the live list,      * not a snapshot. Therefore any modification you make to the      * returned list will be present inside the JAXB object.      * This is why there is not a set method for the gateway property.      *      *       * For example, to add a new item, do as follows:      *      *       * getGateway().add(newItem);      *       *      *      *       * Objects of the following type(s) are allowed in the list      * {@link CacheConfig.GatewayHub.Gateway }      *      *      */     public List getGateway() {       if (gateways == null) {         gateways = new ArrayList();       }       return this.gateways;     }      /**      * Gets the value of the id property.      *      * possible object is      * {@link String }      *      */     public String getId() {       return id;     }      /**      * Sets the value of the id property.      *      * allowed object is      * {@link String }      *      */     public void setId(String value) {       this.id = value;     }      /**      * Gets the value of the bindAddress property.      *      * possible object is      * {@link String }      *      */     public String getBindAddress() {       return bindAddress;     }      /**      * Sets the value of the bindAddress property.      *      * allowed object is      * {@link String }      *      */     public void setBindAddress(String value) {       this.bindAddress = value;     }      /**      * Gets the value of the maximumTimeBetweenPings property.      *      * possible object is      * {@link String }      *      */     public String getMaximumTimeBetweenPings() {       return maximumTimeBetweenPings;     }      /**      * Sets the value of the maximumTimeBetweenPings property.      *      * allowed object is      * {@link String }      *      */     public void setMaximumTimeBetweenPings(String value) {       this.maximumTimeBetweenPings = value;     }      /**      * Gets the value of the port property.      *      * possible object is      * {@link String }      *      */     public String getPort() {       return port;     }      /**      * Sets the value of the port property.      *      * allowed object is      * {@link String }      *      */     public void setPort(String value) {       this.port = value;     }      /**      * Gets the value of the socketBufferSize property.      *      * possible object is      * {@link String }      *      */     public String getSocketBufferSize() {       return socketBufferSize;     }      /**      * Sets the value of the socketBufferSize property.      *      * allowed object is      * {@link String }      *      */     public void setSocketBufferSize(String value) {       this.socketBufferSize = value;     }      /**      * Gets the value of the startupPolicy property.      *      * possible object is      * {@link String }      *      */     public String getStartupPolicy() {       return startupPolicy;     }      /**      * Sets the value of the startupPolicy property.      *      * allowed object is      * {@link String }      *      */     public void setStartupPolicy(String value) {       this.startupPolicy = value;     }      /**      * Gets the value of the manualStart property.      *      * possible object is      * {@link Boolean }      *      */     public Boolean isManualStart() {       return manualStart;     }      /**      * Sets the value of the manualStart property.      *      * allowed object is      * {@link Boolean }      *      */     public void setManualStart(Boolean value) {       this.manualStart = value;     }      /**      * Gets the value of the maxConnections property.      *      * possible object is      * {@link BigInteger }      *      */     public BigInteger getMaxConnections() {       return maxConnections;     }      /**      * Sets the value of the maxConnections property.      *      * allowed object is      * {@link BigInteger }      *      */     public void setMaxConnections(BigInteger value) {       this.maxConnections = value;     }       /**      *       * Java class for anonymous complex type.      *      *       * The following schema fragment specifies the expected content contained within this class.      *      *       * &lt;complexType&gt;      *   &lt;complexContent&gt;      *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;      *       &lt;sequence&gt;      *         &lt;choice&gt;      *           &lt;element name=&quot;gateway-endpoint&quot; maxOccurs=&quot;unbounded&quot;&gt;      *             &lt;complexType&gt;      *               &lt;complexContent&gt;      *                 &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;      *                   &lt;attribute name=&quot;host&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                   &lt;attribute name=&quot;id&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                   &lt;attribute name=&quot;port&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;/restriction&gt;      *               &lt;/complexContent&gt;      *             &lt;/complexType&gt;      *           &lt;/element&gt;      *           &lt;element name=&quot;gateway-listener&quot; maxOccurs=&quot;unbounded&quot;&gt;      *             &lt;complexType&gt;      *               &lt;complexContent&gt;      *                 &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;      *                   &lt;sequence&gt;      *                     &lt;element name=&quot;class-name&quot; type=&quot;{http://geode.apache.org/schema/cache}class-name-type&quot;/&gt;      *                     &lt;element name=&quot;parameter&quot; type=&quot;{http://geode.apache.org/schema/cache}parameter-type&quot; maxOccurs=&quot;unbounded&quot; minOccurs=&quot;0&quot;/&gt;      *                   &lt;/sequence&gt;      *                 &lt;/restriction&gt;      *               &lt;/complexContent&gt;      *             &lt;/complexType&gt;      *           &lt;/element&gt;      *         &lt;/choice&gt;      *         &lt;element name=&quot;gateway-queue&quot; minOccurs=&quot;0&quot;&gt;      *           &lt;complexType&gt;      *             &lt;complexContent&gt;      *               &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;      *                 &lt;attribute name=&quot;alert-threshold&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;batch-conflation&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;      *                 &lt;attribute name=&quot;batch-size&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;batch-time-interval&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;enable-persistence&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;      *                 &lt;attribute name=&quot;disk-store-name&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;roll-oplogs&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;      *                 &lt;attribute name=&quot;maximum-queue-memory&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;overflow-directory&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *               &lt;/restriction&gt;      *             &lt;/complexContent&gt;      *           &lt;/complexType&gt;      *         &lt;/element&gt;      *       &lt;/sequence&gt;      *       &lt;attribute name=&quot;early-ack&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;      *       &lt;attribute name=&quot;id&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *       &lt;attribute name=&quot;socket-buffer-size&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *       &lt;attribute name=&quot;socket-read-timeout&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *       &lt;attribute name=&quot;concurrency-level&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *       &lt;attribute name=&quot;order-policy&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *     &lt;/restriction&gt;      *   &lt;/complexContent&gt;      * &lt;/complexType&gt;      *       *      *      */     @XmlAccessorType(XmlAccessType.FIELD)     @XmlType(name = &quot;&quot;, propOrder = {&quot;gatewayEndpoints&quot;, &quot;gatewayListeners&quot;, &quot;gatewayQueue&quot;})     public static class Gateway {        @XmlElement(name = &quot;gateway-endpoint&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)       protected List gatewayEndpoints;       @XmlElement(name = &quot;gateway-listener&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)       protected List gatewayListeners;       @XmlElement(name = &quot;gateway-queue&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)       protected CacheConfig.GatewayHub.Gateway.GatewayQueue gatewayQueue;       @XmlAttribute(name = &quot;early-ack&quot;)       protected Boolean earlyAck;       @XmlAttribute(name = &quot;id&quot;, required = true)       protected String id;       @XmlAttribute(name = &quot;socket-buffer-size&quot;)       protected String socketBufferSize;       @XmlAttribute(name = &quot;socket-read-timeout&quot;)       protected String socketReadTimeout;       @XmlAttribute(name = &quot;concurrency-level&quot;)       protected String concurrencyLevel;       @XmlAttribute(name = &quot;order-policy&quot;)       protected String orderPolicy;        /**        * Gets the value of the gatewayEndpoints property.        *        *         * This accessor method returns a reference to the live list,        * not a snapshot. Therefore any modification you make to the        * returned list will be present inside the JAXB object.        * This is why there is not a set method for the gatewayEndpoints property.        *        *         * For example, to add a new item, do as follows:        *        *         * getGatewayEndpoints().add(newItem);        *         *        *        *         * Objects of the following type(s) are allowed in the list        * {@link CacheConfig.GatewayHub.Gateway.GatewayEndpoint }        *        *        */       public List getGatewayEndpoints() {         if (gatewayEndpoints == null) {           gatewayEndpoints = new ArrayList();         }         return this.gatewayEndpoints;       }        /**        * Gets the value of the gatewayListeners property.        *        *         * This accessor method returns a reference to the live list,        * not a snapshot. Therefore any modification you make to the        * returned list will be present inside the JAXB object.        * This is why there is not a set method for the gatewayListeners property.        *        *         * For example, to add a new item, do as follows:        *        *         * getGatewayListeners().add(newItem);        *         *        *        *         * Objects of the following type(s) are allowed in the list        * {@link DeclarableType }        *        *        */       public List getGatewayListeners() {         if (gatewayListeners == null) {           gatewayListeners = new ArrayList();         }         return this.gatewayListeners;       }        /**        * Gets the value of the gatewayQueue property.        *        * possible object is        * {@link CacheConfig.GatewayHub.Gateway.GatewayQueue }        *        */       public CacheConfig.GatewayHub.Gateway.GatewayQueue getGatewayQueue() {         return gatewayQueue;       }        /**        * Sets the value of the gatewayQueue property.        *        * allowed object is        * {@link CacheConfig.GatewayHub.Gateway.GatewayQueue }        *        */       public void setGatewayQueue(CacheConfig.GatewayHub.Gateway.GatewayQueue value) {         this.gatewayQueue = value;       }        /**        * Gets the value of the earlyAck property.        *        * possible object is        * {@link Boolean }        *        */       public Boolean isEarlyAck() {         return earlyAck;       }        /**        * Sets the value of the earlyAck property.        *        * allowed object is        * {@link Boolean }        *        */       public void setEarlyAck(Boolean value) {         this.earlyAck = value;       }        /**        * Gets the value of the id property.        *        * possible object is        * {@link String }        *        */       public String getId() {         return id;       }        /**        * Sets the value of the id property.        *        * allowed object is        * {@link String }        *        */       public void setId(String value) {         this.id = value;       }        /**        * Gets the value of the socketBufferSize property.        *        * possible object is        * {@link String }        *        */       public String getSocketBufferSize() {         return socketBufferSize;       }        /**        * Sets the value of the socketBufferSize property.        *        * allowed object is        * {@link String }        *        */       public void setSocketBufferSize(String value) {         this.socketBufferSize = value;       }        /**        * Gets the value of the socketReadTimeout property.        *        * possible object is        * {@link String }        *        */       public String getSocketReadTimeout() {         return socketReadTimeout;       }        /**        * Sets the value of the socketReadTimeout property.        *        * allowed object is        * {@link String }        *        */       public void setSocketReadTimeout(String value) {         this.socketReadTimeout = value;       }        /**        * Gets the value of the concurrencyLevel property.        *        * possible object is        * {@link String }        *        */       public String getConcurrencyLevel() {         return concurrencyLevel;       }        /**        * Sets the value of the concurrencyLevel property.        *        * allowed object is        * {@link String }        *        */       public void setConcurrencyLevel(String value) {         this.concurrencyLevel = value;       }        /**        * Gets the value of the orderPolicy property.        *        * possible object is        * {@link String }        *        */       public String getOrderPolicy() {         return orderPolicy;       }        /**        * Sets the value of the orderPolicy property.        *        * allowed object is        * {@link String }        *        */       public void setOrderPolicy(String value) {         this.orderPolicy = value;       }         /**        *         * Java class for anonymous complex type.        *        *         * The following schema fragment specifies the expected content contained within this class.        *        *         * &lt;complexType&gt;        *   &lt;complexContent&gt;        *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;        *       &lt;attribute name=&quot;host&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;id&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;port&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *     &lt;/restriction&gt;        *   &lt;/complexContent&gt;        * &lt;/complexType&gt;        *         *        *        */       @XmlAccessorType(XmlAccessType.FIELD)       @XmlType(name = &quot;&quot;)       public static class GatewayEndpoint {          @XmlAttribute(name = &quot;host&quot;, required = true)         protected String host;         @XmlAttribute(name = &quot;id&quot;, required = true)         protected String id;         @XmlAttribute(name = &quot;port&quot;, required = true)         protected String port;          /**          * Gets the value of the host property.          *          * possible object is          * {@link String }          *          */         public String getHost() {           return host;         }          /**          * Sets the value of the host property.          *          * allowed object is          * {@link String }          *          */         public void setHost(String value) {           this.host = value;         }          /**          * Gets the value of the id property.          *          * possible object is          * {@link String }          *          */         public String getId() {           return id;         }          /**          * Sets the value of the id property.          *          * allowed object is          * {@link String }          *          */         public void setId(String value) {           this.id = value;         }          /**          * Gets the value of the port property.          *          * possible object is          * {@link String }          *          */         public String getPort() {           return port;         }          /**          * Sets the value of the port property.          *          * allowed object is          * {@link String }          *          */         public void setPort(String value) {           this.port = value;         }        }        /**        *         * Java class for anonymous complex type.        *        *         * The following schema fragment specifies the expected content contained within this class.        *        *         * &lt;complexType&gt;        *   &lt;complexContent&gt;        *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;        *       &lt;attribute name=&quot;alert-threshold&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;batch-conflation&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;        *       &lt;attribute name=&quot;batch-size&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;batch-time-interval&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;enable-persistence&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;        *       &lt;attribute name=&quot;disk-store-name&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;roll-oplogs&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;        *       &lt;attribute name=&quot;maximum-queue-memory&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;overflow-directory&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *     &lt;/restriction&gt;        *   &lt;/complexContent&gt;        * &lt;/complexType&gt;        *         *        *        */       @XmlAccessorType(XmlAccessType.FIELD)       @XmlType(name = &quot;&quot;)       public static class GatewayQueue {          @XmlAttribute(name = &quot;alert-threshold&quot;)         protected String alertThreshold;         @XmlAttribute(name = &quot;batch-conflation&quot;)         protected Boolean batchConflation;         @XmlAttribute(name = &quot;batch-size&quot;)         protected String batchSize;         @XmlAttribute(name = &quot;batch-time-interval&quot;)         protected String batchTimeInterval;         @XmlAttribute(name = &quot;enable-persistence&quot;)         protected Boolean enablePersistence;         @XmlAttribute(name = &quot;disk-store-name&quot;)         protected String diskStoreName;         @XmlAttribute(name = &quot;roll-oplogs&quot;)         protected Boolean rollOplogs;         @XmlAttribute(name = &quot;maximum-queue-memory&quot;)         protected String maximumQueueMemory;         @XmlAttribute(name = &quot;overflow-directory&quot;)         protected String overflowDirectory;          /**          * Gets the value of the alertThreshold property.          *          * possible object is          * {@link String }          *          */         public String getAlertThreshold() {           return alertThreshold;         }          /**          * Sets the value of the alertThreshold property.          *          * allowed object is          * {@link String }          *          */         public void setAlertThreshold(String value) {           this.alertThreshold = value;         }          /**          * Gets the value of the batchConflation property.          *          * possible object is          * {@link Boolean }          *          */         public Boolean isBatchConflation() {           return batchConflation;         }          /**          * Sets the value of the batchConflation property.          *          * allowed object is          * {@link Boolean }          *          */         public void setBatchConflation(Boolean value) {           this.batchConflation = value;         }          /**          * Gets the value of the batchSize property.          *          * possible object is          * {@link String }          *          */         public String getBatchSize() {           return batchSize;         }          /**          * Sets the value of the batchSize property.          *          * allowed object is          * {@link String }          *          */         public void setBatchSize(String value) {           this.batchSize = value;         }          /**          * Gets the value of the batchTimeInterval property.          *          * possible object is          * {@link String }          *          */         public String getBatchTimeInterval() {           return batchTimeInterval;         }          /**          * Sets the value of the batchTimeInterval property.          *          * allowed object is          * {@link String }          *          */         public void setBatchTimeInterval(String value) {           this.batchTimeInterval = value;         }          /**          * Gets the value of the enablePersistence property.          *          * possible object is          * {@link Boolean }          *          */         public Boolean isEnablePersistence() {           return enablePersistence;         }          /**          * Sets the value of the enablePersistence property.          *          * allowed object is          * {@link Boolean }          *          */         public void setEnablePersistence(Boolean value) {           this.enablePersistence = value;         }          /**          * Gets the value of the diskStoreName property.          *          * possible object is          * {@link String }          *          */         public String getDiskStoreName() {           return diskStoreName;         }          /**          * Sets the value of the diskStoreName property.          *          * allowed object is          * {@link String }          *          */         public void setDiskStoreName(String value) {           this.diskStoreName = value;         }          /**          * Gets the value of the rollOplogs property.          *          * possible object is          * {@link Boolean }          *          */         public Boolean isRollOplogs() {           return rollOplogs;         }          /**          * Sets the value of the rollOplogs property.          *          * allowed object is          * {@link Boolean }          *          */         public void setRollOplogs(Boolean value) {           this.rollOplogs = value;         }          /**          * Gets the value of the maximumQueueMemory property.          *          * possible object is          * {@link String }          *          */         public String getMaximumQueueMemory() {           return maximumQueueMemory;         }          /**          * Sets the value of the maximumQueueMemory property.          *          * allowed object is          * {@link String }          *          */         public void setMaximumQueueMemory(String value) {           this.maximumQueueMemory = value;         }          /**          * Gets the value of the overflowDirectory property.          *          * possible object is          * {@link String }          *          */         public String getOverflowDirectory() {           return overflowDirectory;         }          /**          * Sets the value of the overflowDirectory property.          *          * allowed object is          * {@link String }          *          */         public void setOverflowDirectory(String value) {           this.overflowDirectory = value;         }        }      }    }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10504</td>
    <td align="left">https://github.com/apache/geode/blob/8fd839e8b73e40bd2dfd14f331b587431bd35a66/geode-management/src/main/java/org/apache/geode/cache/configuration/CacheConfig.java/#L1636-L2524</td>
    <td align="right">1</td>
    <td align="right">1260</td>
    <td align="right">10504</td>
  </tr>
  <tr valign="top">
    <td align="right">2186</td>
    <td align="left">&nbsp;&nbsp;YES I found bad smells The bad smells are: 1. Large Class, 2. Large Method, 3. Data Class, 4. Long Parameter List</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class NodeAnnounceMessage extends PacketImpl {     protected String nodeID;     protected String backupGroupName;     protected boolean backup;     protected long currentEventID;     protected TransportConfiguration connector;     protected TransportConfiguration backupConnector;     private String scaleDownGroupName;     // Static --------------------------------------------------------     // Constructors --------------------------------------------------     public NodeAnnounceMessage(final long currentEventID,                               final String nodeID,                               final String backupGroupName,                               final String scaleDownGroupName,                               final boolean backup,                               final TransportConfiguration tc,                               final TransportConfiguration backupConnector) {       super(NODE_ANNOUNCE);        this.currentEventID = currentEventID;        this.nodeID = nodeID;        this.backupGroupName = backupGroupName;        this.backup = backup;        this.connector = tc;        this.backupConnector = backupConnector;        this.scaleDownGroupName = scaleDownGroupName;    }     public NodeAnnounceMessage() {       super(NODE_ANNOUNCE);    }     public NodeAnnounceMessage(byte nodeAnnounceMessage_V2) {       super(nodeAnnounceMessage_V2);    }     // Public --------------------------------------------------------     public String getNodeID() {       return nodeID;    }     public String getBackupGroupName() {       return backupGroupName;    }     public boolean isBackup() {       return backup;    }     public TransportConfiguration getConnector() {       return connector;    }     public TransportConfiguration getBackupConnector() {       return backupConnector;    }     public String getScaleDownGroupName() {       return scaleDownGroupName;    }     /**     * @return the currentEventID     */    public long getCurrentEventID() {       return currentEventID;    }     @Override    public void encodeRest(final ActiveMQBuffer buffer) {       buffer.writeString(nodeID);       buffer.writeNullableString(backupGroupName);       buffer.writeBoolean(backup);       buffer.writeLong(currentEventID);       if (connector != null) {          buffer.writeBoolean(true);          connector.encode(buffer);       } else {          buffer.writeBoolean(false);       }       if (backupConnector != null) {          buffer.writeBoolean(true);          backupConnector.encode(buffer);       } else {          buffer.writeBoolean(false);       }       buffer.writeNullableString(scaleDownGroupName);    }     @Override    public void decodeRest(final ActiveMQBuffer buffer) {       this.nodeID = buffer.readString();       this.backupGroupName = buffer.readNullableString();       this.backup = buffer.readBoolean();       this.currentEventID = buffer.readLong();       if (buffer.readBoolean()) {          connector = new TransportConfiguration();          connector.decode(buffer);       }       if (buffer.readBoolean()) {          backupConnector = new TransportConfiguration();          backupConnector.decode(buffer);       }       scaleDownGroupName = buffer.readNullableString();    }     @Override    public String toString() {       return &quot;NodeAnnounceMessage [backup=&quot; + backup +          &quot;, connector=&quot; +          connector +          &quot;, nodeID=&quot; +          nodeID +          &quot;, toString()=&quot; +          super.toString() +          &quot;]&quot;;    }     @Override    public int hashCode() {       final int prime = 31;       int result = super.hashCode();       result = prime * result + (backup ? 1231 : 1237);       result = prime * result + ((backupConnector == null) ? 0 : backupConnector.hashCode());       result = prime * result + ((connector == null) ? 0 : connector.hashCode());       result = prime * result + (int) (currentEventID ^ (currentEventID &gt;&gt;&gt; 32));       result = prime * result + ((nodeID == null) ? 0 : nodeID.hashCode());       result = prime * result + ((scaleDownGroupName == null) ? 0 : scaleDownGroupName.hashCode());       return result;    }     @Override    public boolean equals(Object obj) {       if (this == obj) {          return true;       }       if (!super.equals(obj)) {          return false;       }       if (!(obj instanceof NodeAnnounceMessage)) {          return false;       }       NodeAnnounceMessage other = (NodeAnnounceMessage) obj;       if (backup != other.backup) {          return false;       }       if (backupConnector == null) {          if (other.backupConnector != null) {             return false;          }       } else if (!backupConnector.equals(other.backupConnector)) {          return false;       }       if (connector == null) {          if (other.connector != null) {             return false;          }       } else if (!connector.equals(other.connector)) {          return false;       }       if (currentEventID != other.currentEventID) {          return false;       }       if (nodeID == null) {          if (other.nodeID != null) {             return false;          }       } else if (!nodeID.equals(other.nodeID)) {          return false;       } else if (!scaleDownGroupName.equals(other.scaleDownGroupName)) {          return false;       }       return true;    } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Large Class, 2 Large Method, 3 Data Class, 4 Long Parameter List</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">. Large Class,  2. Large Method,  4. Long Parameter List</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13435</td>
    <td align="left">https://github.com/apache/activemq-artemis/blob/5bd5c610195d6f4a3dd1ac28170727003f8a5a54/artemis-server/src/main/java/org/apache/activemq/artemis/core/protocol/core/impl/wireformat/NodeAnnounceMessage.java/#L23-L214</td>
    <td align="right">2</td>
    <td align="right">2186</td>
    <td align="right">13435</td>
  </tr>
  <tr valign="top">
    <td align="right">337</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SQLDropTableStatement extends SQLStatementImpl implements SQLDropStatement {     private List hints;      protected List tableSources = new ArrayList();      private boolean                    purge;      protected boolean                  cascade      = false;     protected boolean                  restrict     = false;     protected boolean                  ifExists     = false;     private boolean                    temporary    = false;      public SQLDropTableStatement(){      }          public SQLDropTableStatement(String dbType){         super (dbType);     }      public SQLDropTableStatement(SQLName name, String dbType){         this(new SQLExprTableSource(name), dbType);     }          public SQLDropTableStatement(SQLName name){         this (name, null);     }          public SQLDropTableStatement(SQLExprTableSource tableSource){         this (tableSource, null);     }      public SQLDropTableStatement(SQLExprTableSource tableSource, String dbType){         this (dbType);         this.tableSources.add(tableSource);     }      public List getTableSources() {         return tableSources;     }          public void addPartition(SQLExprTableSource tableSource) {         if (tableSource != null) {             tableSource.setParent(this);         }         this.tableSources.add(tableSource);     }      public void setName(SQLName name) {         this.addTableSource(new SQLExprTableSource(name));     }      public void addTableSource(SQLName name) {         this.addTableSource(new SQLExprTableSource(name));     }      public void addTableSource(SQLExprTableSource tableSource) {         tableSources.add(tableSource);     }      @Override     protected void accept0(SQLASTVisitor visitor) {         if (visitor.visit(this)) {             this.acceptChild(visitor, tableSources);         }         visitor.endVisit(this);     }      @Override     public List getChildren() {         return this.tableSources;     }      public boolean isPurge() {         return purge;     }      public void setPurge(boolean purge) {         this.purge = purge;     }      public boolean isIfExists() {         return ifExists;     }      public void setIfExists(boolean ifExists) {         this.ifExists = ifExists;     }      public boolean isCascade() {         return cascade;     }      public void setCascade(boolean cascade) {         this.cascade = cascade;     }      public boolean isRestrict() {         return restrict;     }      public void setRestrict(boolean restrict) {         this.restrict = restrict;     }      public boolean isTemporary() {         return temporary;     }      public void setTemporary(boolean temporary) {         this.temporary = temporary;     }      public List getHints() {         return hints;     }      public void setHints(List hints) {         this.hints = hints;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3472</td>
    <td align="left">https://github.com/alibaba/druid/blob/768469fe4d1340efe1036453366a58c9ab7e30d1/src/main/java/com/alibaba/druid/sql/ast/statement/SQLDropTableStatement.java/#L26-L146</td>
    <td align="right">1</td>
    <td align="right">337</td>
    <td align="right">3472</td>
  </tr>
  <tr valign="top">
    <td align="right">931</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES, I found bad smells&quot;,         &quot;bad_smells&quot;: [             &quot;Data Class&quot;         ]     } </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class _AdministrationWebServiceSoap_QueryBuildAgentsByUri     implements ElementSerializable {     // No attributes          // Elements     protected String[] agentUris;      public _AdministrationWebServiceSoap_QueryBuildAgentsByUri()     {         super();     }      public _AdministrationWebServiceSoap_QueryBuildAgentsByUri(final String[] agentUris)     {         // TODO : Call super() instead of setting all fields directly?         setAgentUris(agentUris);     }      public String[] getAgentUris()     {         return this.agentUris;     }      public void setAgentUris(String[] value)     {         this.agentUris = value;     }      public void writeAsElement(         final XMLStreamWriter writer,         final String name)         throws XMLStreamException     {         writer.writeStartElement(name);          // Elements         if (this.agentUris != null)         {             /*              * The element type is an array.              */             writer.writeStartElement(&quot;agentUris&quot;);              for (int iterator0 = 0; iterator0 &lt; this.agentUris.length; iterator0++)             {                 XMLStreamWriterHelper.writeElement(                     writer,                     &quot;string&quot;,                     this.agentUris[iterator0]);             }              writer.writeEndElement();         }          writer.writeEndElement();     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8355</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core.ws/generated-src/ms/tfs/build/buildservice/_03/_AdministrationWebServiceSoap_QueryBuildAgentsByUri.java/#L31-L88</td>
    <td align="right">1</td>
    <td align="right">931</td>
    <td align="right">8355</td>
  </tr>
  <tr valign="top">
    <td align="right">256</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells. The bad smells are: 1. Data Class&quot;   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class RowRange {     private Text startRow;     private Text endRow;      public RowRange(KeyExtent ke) {       this.startRow = ke.getPrevEndRow();       this.endRow = ke.getEndRow();     }      public RowRange(TRowRange trr) {       this.startRow = ByteBufferUtil.toText(trr.startRow);       this.endRow = ByteBufferUtil.toText(trr.endRow);     }      public RowRange(Text startRow, Text endRow) {       this.startRow = startRow;       this.endRow = endRow;     }      public Range toRange() {       return new Range(startRow, false, endRow, true);     }      public TRowRange toThrift() {       return new TRowRange(TextUtil.getByteBuffer(startRow), TextUtil.getByteBuffer(endRow));     }      public Text getStartRow() {       return startRow;     }      public Text getEndRow() {       return endRow;     }      @Override     public String toString() {       return startRow + &quot; &quot; + endRow;     }   }</td>
    <td align="left">data class</td>
    <td align="left">1. data class   </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2765</td>
    <td align="left">https://github.com/apache/accumulo/blob/f896c98c2356a52dfa2235d2cc02ae556ab17909/core/src/main/java/org/apache/accumulo/core/summary/Gatherer.java/#L617-L656</td>
    <td align="right">1</td>
    <td align="right">256</td>
    <td align="right">2765</td>
  </tr>
  <tr valign="top">
    <td align="right">2367</td>
    <td align="left">{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Data Class&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = &quot;@class&quot;) @JsonSubTypes({ 	@JsonSubTypes.Type(value = SubtaskCheckpointStatistics.CompletedSubtaskCheckpointStatistics.class, name = &quot;completed&quot;), 	@JsonSubTypes.Type(value = SubtaskCheckpointStatistics.PendingSubtaskCheckpointStatistics.class, name = &quot;pending&quot;)}) public class SubtaskCheckpointStatistics {  	public static final String FIELD_NAME_INDEX = &quot;index&quot;;  	public static final String FIELD_NAME_CHECKPOINT_STATUS = &quot;status&quot;;  	@JsonProperty(FIELD_NAME_INDEX) 	private final int index;  	@JsonProperty(FIELD_NAME_CHECKPOINT_STATUS) 	private final String checkpointStatus;  	@JsonCreator 	private SubtaskCheckpointStatistics( 			@JsonProperty(FIELD_NAME_INDEX) int index, 			@JsonProperty(FIELD_NAME_CHECKPOINT_STATUS) String checkpointStatus) { 		this.index = index; 		this.checkpointStatus = checkpointStatus; 	}  	public int getIndex() { 		return index; 	}  	public String getCheckpointStatus() { 		return checkpointStatus; 	}  	@Override 	public boolean equals(Object o) { 		if (this == o) { 			return true; 		} 		if (o == null || getClass() != o.getClass()) { 			return false; 		} 		SubtaskCheckpointStatistics that = (SubtaskCheckpointStatistics) o; 		return index == that.index &amp;&amp; 			Objects.equals(checkpointStatus, that.checkpointStatus); 	}  	@Override 	public int hashCode() { 		return Objects.hash(index, checkpointStatus); 	}  	// --------------------------------------------------------------------------------- 	// Static inner classes 	// ---------------------------------------------------------------------------------  	/** 	 * Checkpoint statistics for a completed subtask checkpoint. 	 */ 	public static final class CompletedSubtaskCheckpointStatistics extends SubtaskCheckpointStatistics {  		public static final String FIELD_NAME_ACK_TIMESTAMP = &quot;ack_timestamp&quot;;  		public static final String FIELD_NAME_DURATION = &quot;end_to_end_duration&quot;;  		public static final String FIELD_NAME_STATE_SIZE = &quot;state_size&quot;;  		public static final String FIELD_NAME_CHECKPOINT_DURATION = &quot;checkpoint&quot;;  		public static final String FIELD_NAME_ALIGNMENT = &quot;alignment&quot;;  		@JsonProperty(FIELD_NAME_ACK_TIMESTAMP) 		private final long ackTimestamp;  		@JsonProperty(FIELD_NAME_DURATION) 		private final long duration;  		@JsonProperty(FIELD_NAME_STATE_SIZE) 		private final long stateSize;  		@JsonProperty(FIELD_NAME_CHECKPOINT_DURATION) 		private final CheckpointDuration checkpointDuration;  		@JsonProperty(FIELD_NAME_ALIGNMENT) 		private final CheckpointAlignment alignment;  		@JsonCreator 		public CompletedSubtaskCheckpointStatistics( 				@JsonProperty(FIELD_NAME_INDEX) int index, 				@JsonProperty(FIELD_NAME_ACK_TIMESTAMP) long ackTimestamp, 				@JsonProperty(FIELD_NAME_DURATION) long duration, 				@JsonProperty(FIELD_NAME_STATE_SIZE) long stateSize, 				@JsonProperty(FIELD_NAME_CHECKPOINT_DURATION) CheckpointDuration checkpointDuration, 				@JsonProperty(FIELD_NAME_ALIGNMENT) CheckpointAlignment alignment) { 			super(index, &quot;completed&quot;); 			this.ackTimestamp = ackTimestamp; 			this.duration = duration; 			this.stateSize = stateSize; 			this.checkpointDuration = checkpointDuration; 			this.alignment = alignment; 		}  		public long getAckTimestamp() { 			return ackTimestamp; 		}  		public long getDuration() { 			return duration; 		}  		public long getStateSize() { 			return stateSize; 		}  		public CheckpointDuration getCheckpointDuration() { 			return checkpointDuration; 		}  		public CheckpointAlignment getAlignment() { 			return alignment; 		}  		@Override 		public boolean equals(Object o) { 			if (this == o) { 				return true; 			} 			if (o == null || getClass() != o.getClass()) { 				return false; 			} 			CompletedSubtaskCheckpointStatistics that = (CompletedSubtaskCheckpointStatistics) o; 			return ackTimestamp == that.ackTimestamp &amp;&amp; 				duration == that.duration &amp;&amp; 				stateSize == that.stateSize &amp;&amp; 				Objects.equals(checkpointDuration, that.checkpointDuration) &amp;&amp; 				Objects.equals(alignment, that.alignment); 		}  		@Override 		public int hashCode() { 			return Objects.hash(ackTimestamp, duration, stateSize, checkpointDuration, alignment); 		}  		/** 		 * Duration of the checkpoint. 		 */ 		public static final class CheckpointDuration {  			public static final String FIELD_NAME_SYNC_DURATION = &quot;sync&quot;;  			public static final String FIELD_NAME_ASYNC_DURATION = &quot;async&quot;;  			@JsonProperty(FIELD_NAME_SYNC_DURATION) 			private final long syncDuration;  			@JsonProperty(FIELD_NAME_ASYNC_DURATION) 			private final long asyncDuration;  			@JsonCreator 			public CheckpointDuration( 					@JsonProperty(FIELD_NAME_SYNC_DURATION) long syncDuration, 					@JsonProperty(FIELD_NAME_ASYNC_DURATION) long asyncDuration) { 				this.syncDuration = syncDuration; 				this.asyncDuration = asyncDuration; 			}  			public long getSyncDuration() { 				return syncDuration; 			}  			public long getAsyncDuration() { 				return asyncDuration; 			}  			@Override 			public boolean equals(Object o) { 				if (this == o) { 					return true; 				} 				if (o == null || getClass() != o.getClass()) { 					return false; 				} 				CheckpointDuration that = (CheckpointDuration) o; 				return syncDuration == that.syncDuration &amp;&amp; 					asyncDuration == that.asyncDuration; 			}  			@Override 			public int hashCode() { 				return Objects.hash(syncDuration, asyncDuration); 			} 		}  		/** 		 * Alignment statistics of the checkpoint. 		 */ 		public static final class CheckpointAlignment {  			public static final String FIELD_NAME_ALIGNMENT_BUFFERED = &quot;buffered&quot;;  			public static final String FIELD_NAME_ALIGNMENT_DURATION = &quot;duration&quot;;  			@JsonProperty(FIELD_NAME_ALIGNMENT_BUFFERED) 			private final long alignmentBuffered;  			@JsonProperty(FIELD_NAME_ALIGNMENT_DURATION) 			private final long alignmentDuration;  			@JsonCreator 			public CheckpointAlignment( 					@JsonProperty(FIELD_NAME_ALIGNMENT_BUFFERED) long alignmentBuffered, 					@JsonProperty(FIELD_NAME_ALIGNMENT_DURATION) long alignmentDuration) { 				this.alignmentBuffered = alignmentBuffered; 				this.alignmentDuration = alignmentDuration; 			}  			public long getAlignmentBuffered() { 				return alignmentBuffered; 			}  			public long getAlignmentDuration() { 				return alignmentDuration; 			}  			@Override 			public boolean equals(Object o) { 				if (this == o) { 					return true; 				} 				if (o == null || getClass() != o.getClass()) { 					return false; 				} 				CheckpointAlignment that = (CheckpointAlignment) o; 				return alignmentBuffered == that.alignmentBuffered &amp;&amp; 					alignmentDuration == that.alignmentDuration; 			}  			@Override 			public int hashCode() { 				return Objects.hash(alignmentBuffered, alignmentDuration); 			} 		} 	}  	/** 	 * Checkpoint statistics for a pending subtask checkpoint. 	 */ 	public static final class PendingSubtaskCheckpointStatistics extends SubtaskCheckpointStatistics {  		@JsonCreator 		public PendingSubtaskCheckpointStatistics(@JsonProperty(FIELD_NAME_INDEX) int index) { 			super(index, &quot;pending_or_failed&quot;); 		} 	} }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14300</td>
    <td align="left">https://github.com/apache/flink/blob/8068c8775ad067d75828e6360e7e0994348da9b9/flink-runtime/src/main/java/org/apache/flink/runtime/rest/messages/checkpoints/SubtaskCheckpointStatistics.java/#L31-L283</td>
    <td align="right">1</td>
    <td align="right">2367</td>
    <td align="right">14300</td>
  </tr>
  <tr valign="top">
    <td align="right">2278</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells. The bad smells are: 2. Data Class&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Status {  	private StatusCode code; 	private String message; 	private String detail;  	public StatusCode getCode() { 		return code; 	}  	public Status setCode(StatusCode code) { 		this.code = code; 		return this; 	}  	public String getMessage() { 		return message; 	}  	public Status setMessage(String message) { 		this.message = message; 		return this; 	}  	public String getDetail() { 		return detail; 	}  	public Status setDetail(String detail) { 		this.detail = detail; 		return this; 	} }</td>
    <td align="left">data class</td>
    <td align="left">2. data class </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13783</td>
    <td align="left">https://github.com/spring-projects/spring-security-saml/blob/fa46190c8c37c2eb24b0fd424263c219ffe27e25/core/src/main/java/org/springframework/security/saml/saml2/authentication/Status.java/#L25-L57</td>
    <td align="right">1</td>
    <td align="right">2278</td>
    <td align="right">13783</td>
  </tr>
  <tr valign="top">
    <td align="right">2214</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Data Class&quot;     ]   } </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SchemaAndValue {     private final Schema schema;     private final Object value;      public static final SchemaAndValue NULL = new SchemaAndValue(null, null);      public SchemaAndValue(Schema schema, Object value) {         this.value = value;         this.schema = schema;     }      public Schema schema() {         return schema;     }      public Object value() {         return value;     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (o == null || getClass() != o.getClass()) return false;         SchemaAndValue that = (SchemaAndValue) o;         return Objects.equals(schema, that.schema) &amp;&amp;                 Objects.equals(value, that.value);     }      @Override     public int hashCode() {         return Objects.hash(schema, value);     }      @Override     public String toString() {         return &quot;SchemaAndValue{&quot; +                 &quot;schema=&quot; + schema +                 &quot;, value=&quot; + value +                 '}';     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13528</td>
    <td align="left">https://github.com/apache/kafka/blob/c74acb24eb1da5d16cc2721a63931cd87f79ec66/connect/api/src/main/java/org/apache/kafka/connect/data/SchemaAndValue.java/#L21-L61</td>
    <td align="right">1</td>
    <td align="right">2214</td>
    <td align="right">13528</td>
  </tr>
  <tr valign="top">
    <td align="right">2057</td>
    <td align="left">&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement public class Book {      private int id;     private String name;      public Book() {}      public Book(int bookId, String name) {         this.id = bookId;         this.name = name;     }      public int getId() {         return id;     }      public void setId(int id) {         this.id = id;     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12952</td>
    <td align="left">https://github.com/apache/tomee/blob/d21933b313aff812fe5188b57bf572a9ad649148/examples/mp-rest-client/src/main/java/org/superbiz/rest/Book.java/#L22-L50</td>
    <td align="right">1</td>
    <td align="right">2057</td>
    <td align="right">12952</td>
  </tr>
  <tr valign="top">
    <td align="right">1662</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public class TypeRefWithoutModifiersElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.n4js.ts.TypeExpressions.TypeRefWithoutModifiers&quot;); 		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1); 		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0); 		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0); 		private final RuleCall cParameterizedTypeRefParserRuleCall_0_0_0 = (RuleCall)cAlternatives_0_0.eContents().get(0); 		private final RuleCall cThisTypeRefParserRuleCall_0_0_1 = (RuleCall)cAlternatives_0_0.eContents().get(1); 		private final Assignment cDynamicAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1); 		private final Keyword cDynamicPlusSignKeyword_0_1_0 = (Keyword)cDynamicAssignment_0_1.eContents().get(0); 		private final RuleCall cTypeTypeRefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1); 		private final RuleCall cFunctionTypeExpressionOLDParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2); 		private final RuleCall cUnionTypeExpressionOLDParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3); 		private final RuleCall cIntersectionTypeExpressionOLDParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4); 		 		//TypeRefWithoutModifiers StaticBaseTypeRef: 		//	(ParameterizedTypeRef | ThisTypeRef) =&gt; dynamic?='+'? | TypeTypeRef 		//	| FunctionTypeExpressionOLD 		//	| UnionTypeExpressionOLD 		//	| IntersectionTypeExpressionOLD; 		@Override public ParserRule getRule() { return rule; } 		 		//(ParameterizedTypeRef | ThisTypeRef) =&gt; dynamic?='+'? | TypeTypeRef | FunctionTypeExpressionOLD | UnionTypeExpressionOLD 		//| IntersectionTypeExpressionOLD 		public Alternatives getAlternatives() { return cAlternatives; } 		 		//(ParameterizedTypeRef | ThisTypeRef) =&gt; dynamic?='+'? 		public Group getGroup_0() { return cGroup_0; } 		 		//ParameterizedTypeRef | ThisTypeRef 		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; } 		 		//ParameterizedTypeRef 		public RuleCall getParameterizedTypeRefParserRuleCall_0_0_0() { return cParameterizedTypeRefParserRuleCall_0_0_0; } 		 		//ThisTypeRef 		public RuleCall getThisTypeRefParserRuleCall_0_0_1() { return cThisTypeRefParserRuleCall_0_0_1; } 		 		//=&gt; dynamic?='+'? 		public Assignment getDynamicAssignment_0_1() { return cDynamicAssignment_0_1; } 		 		//'+' 		public Keyword getDynamicPlusSignKeyword_0_1_0() { return cDynamicPlusSignKeyword_0_1_0; } 		 		//TypeTypeRef 		public RuleCall getTypeTypeRefParserRuleCall_1() { return cTypeTypeRefParserRuleCall_1; } 		 		//FunctionTypeExpressionOLD 		public RuleCall getFunctionTypeExpressionOLDParserRuleCall_2() { return cFunctionTypeExpressionOLDParserRuleCall_2; } 		 		//UnionTypeExpressionOLD 		public RuleCall getUnionTypeExpressionOLDParserRuleCall_3() { return cUnionTypeExpressionOLDParserRuleCall_3; } 		 		//IntersectionTypeExpressionOLD 		public RuleCall getIntersectionTypeExpressionOLDParserRuleCall_4() { return cIntersectionTypeExpressionOLDParserRuleCall_4; } 	}</td>
    <td align="left">data class</td>
    <td align="left">Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11614</td>
    <td align="left">https://github.com/eclipse/n4js/blob/f715912fce0352ab574ff878086f77d17a78c908/plugins/org.eclipse.n4js.ts/src-gen/org/eclipse/n4js/ts/services/TypeExpressionsGrammarAccess.java/#L201-L255</td>
    <td align="right">1</td>
    <td align="right">1662</td>
    <td align="right">11614</td>
  </tr>
  <tr valign="top">
    <td align="right">1250</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Blob&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;faces-config-propertyType&quot;, propOrder = {     &quot;descriptions&quot;,     &quot;displayNames&quot;,     &quot;icon&quot;,     &quot;propertyName&quot;,     &quot;propertyClass&quot;,     &quot;defaultValue&quot;,     &quot;suggestedValue&quot;,     &quot;propertyExtension&quot; }) public class FacesProperty {      @XmlTransient     protected TextMap description = new TextMap();     @XmlTransient     protected TextMap displayName = new TextMap();     @XmlElement(name = &quot;icon&quot;, required = true)     protected LocalCollection icon = new LocalCollection();     @XmlElement(name = &quot;property-name&quot;, required = true)     protected java.lang.String propertyName;     @XmlElement(name = &quot;property-class&quot;, required = true)     protected java.lang.String propertyClass;     @XmlElement(name = &quot;default-value&quot;)     protected java.lang.String defaultValue;     @XmlElement(name = &quot;suggested-value&quot;)     protected java.lang.String suggestedValue;     @XmlElement(name = &quot;property-extension&quot;)     protected List propertyExtension;     @XmlAttribute     @XmlJavaTypeAdapter(CollapsedStringAdapter.class)     @XmlID     @XmlSchemaType(name = &quot;ID&quot;)     protected java.lang.String id;      @XmlElement(name = &quot;description&quot;, required = true)     public Text[] getDescriptions() {         return description.toArray();     }      public void setDescriptions(Text[] text) {         description.set(text);     }      public String getDescription() {         return description.get();     }      @XmlElement(name = &quot;display-name&quot;, required = true)     public Text[] getDisplayNames() {         return displayName.toArray();     }      public void setDisplayNames(Text[] text) {         displayName.set(text);     }      public String getDisplayName() {         return displayName.get();     }      public Collection getIcons() {         if (icon == null) {             icon = new LocalCollection();         }         return icon;     }      public Map getIconMap() {         if (icon == null) {             icon = new LocalCollection();         }         return icon.toMap();     }      public Icon getIcon() {         return icon.getLocal();     }      /**      * Gets the value of the propertyName property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getPropertyName() {         return propertyName;     }      /**      * Sets the value of the propertyName property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setPropertyName(java.lang.String value) {         this.propertyName = value;     }      /**      * Gets the value of the propertyClass property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getPropertyClass() {         return propertyClass;     }      /**      * Sets the value of the propertyClass property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setPropertyClass(java.lang.String value) {         this.propertyClass = value;     }      /**      * Gets the value of the defaultValue property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getDefaultValue() {         return defaultValue;     }      /**      * Sets the value of the defaultValue property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setDefaultValue(java.lang.String value) {         this.defaultValue = value;     }      /**      * Gets the value of the suggestedValue property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getSuggestedValue() {         return suggestedValue;     }      /**      * Sets the value of the suggestedValue property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setSuggestedValue(java.lang.String value) {         this.suggestedValue = value;     }      /**      * Gets the value of the propertyExtension property.      *       *       * This accessor method returns a reference to the live list,      * not a snapshot. Therefore any modification you make to the      * returned list will be present inside the JAXB object.      * This is why there is not a set method for the propertyExtension property.      *       *       * For example, to add a new item, do as follows:      *       *    getPropertyExtension().add(newItem);      *       *       *       *       * Objects of the following type(s) are allowed in the list      * {@link FacesPropertyExtension }      *       *       */     public List getPropertyExtension() {         if (propertyExtension == null) {             propertyExtension = new ArrayList();         }         return this.propertyExtension;     }      /**      * Gets the value of the id property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getId() {         return id;     }      /**      * Sets the value of the id property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setId(java.lang.String value) {         this.id = value;     }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10436</td>
    <td align="left">https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/container/openejb-jee/src/main/java/org/apache/openejb/jee/FacesProperty.java/#L70-L298</td>
    <td align="right">1</td>
    <td align="right">1250</td>
    <td align="right">10436</td>
  </tr>
  <tr valign="top">
    <td align="right">2267</td>
    <td align="left">{     &quot;output&quot;: &quot;YES, I found bad smells&quot;,     &quot;the bad smells are&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlType(name = &quot;remoteProcessGroup&quot;) public class RemoteProcessGroupDTO extends ComponentDTO {      private String targetUri;     private String targetUris;     private Boolean targetSecure;      private String name;     private String comments;     private String communicationsTimeout;     private String yieldDuration;     private String transportProtocol;     private String localNetworkInterface;     private String proxyHost;     private Integer proxyPort;     private String proxyUser;     private String proxyPassword;      private Collection authorizationIssues;     private Collection validationErrors;     private Boolean transmitting;      private Integer inputPortCount;     private Integer outputPortCount;      private Integer activeRemoteInputPortCount;     private Integer inactiveRemoteInputPortCount;     private Integer activeRemoteOutputPortCount;     private Integer inactiveRemoteOutputPortCount;      private Date flowRefreshed;      private RemoteProcessGroupContentsDTO contents;      public RemoteProcessGroupDTO() {         super();     }      public RemoteProcessGroupDTO(final RemoteProcessGroupDTO toCopy) {         setId(toCopy.getId());         setPosition(toCopy.getPosition());         targetUri = toCopy.getTargetUri();         name = toCopy.getName();     }      public void setTargetUri(final String targetUri) {         this.targetUri = targetUri;     }      /**      * @return target uri of this remote process group.      * If target uri is not set, but uris are set, then returns the first url in the urls.      * If neither target uri nor uris are set, then returns null.      */     @ApiModelProperty(             value = &quot;The target URI of the remote process group.&quot; +                     &quot; If target uri is not set, but uris are set, then returns the first url in the urls.&quot; +                     &quot; If neither target uri nor uris are set, then returns null.&quot;     )     public String getTargetUri() {         if (targetUri == null || targetUri.length() == 0) {             synchronized (this) {                 if (targetUri == null || targetUri.length() == 0) {                     if (targetUris != null &amp;&amp; targetUris.length() &gt; 0) {                         if (targetUris.indexOf(',') &gt; -1) {                             targetUri = targetUris.substring(0, targetUris.indexOf(','));                         } else {                             targetUri = targetUris;                         }                     }                 }             }         }          return this.targetUri;     }      public void setTargetUris(String targetUris) {         this.targetUris = targetUris;     }      /**      * @return target uris of this remote process group      * If targetUris was not set but target uri was set, then returns a collection containing the single uri.      * If neither target uris nor uri were set, then returns null.      */     @ApiModelProperty(             value = &quot;The target URI of the remote process group.&quot; +                     &quot; If target uris is not set but target uri is set,&quot; +                     &quot; then returns a collection containing the single target uri.&quot; +                     &quot; If neither target uris nor uris are set, then returns null.&quot;     )     public String getTargetUris() {         if (targetUris == null || targetUris.length() == 0) {             synchronized (this) {                 if (targetUris == null || targetUris.length() == 0) {                     targetUris = targetUri;                 }             }         }          return this.targetUris;     }      /**      * @param name of this remote process group      */     @ApiModelProperty(             value = &quot;The name of the remote process group.&quot;     )     public void setName(final String name) {         this.name = name;     }      public String getName() {         return this.name;     }      /**      * @return Comments for this remote process group      */     @ApiModelProperty(             value = &quot;The comments for the remote process group.&quot;     )     public String getComments() {         return comments;     }      public void setComments(String comments) {         this.comments = comments;     }      /**      * @return any remote authorization issues for this remote process group      */     @ApiModelProperty(             value = &quot;Any remote authorization issues for the remote process group.&quot;     )     public Collection getAuthorizationIssues() {         return authorizationIssues;     }      public void setAuthorizationIssues(Collection authorizationIssues) {         this.authorizationIssues = authorizationIssues;     }      /**      * @return whether or not this remote process group is actively transmitting      */     @ApiModelProperty(             value = &quot;Whether the remote process group is actively transmitting.&quot;     )     public Boolean isTransmitting() {         return transmitting;     }      public void setTransmitting(Boolean transmitting) {         this.transmitting = transmitting;     }      /**      * @return whether or not the target is running securely      */     @ApiModelProperty(             value = &quot;Whether the target is running securely.&quot;     )     public Boolean isTargetSecure() {         return targetSecure;     }      public void setTargetSecure(Boolean targetSecure) {         this.targetSecure = targetSecure;     }      /**      * @return the time period used for the timeout when communicating with this RemoteProcessGroup      */     @ApiModelProperty(             value = &quot;The time period used for the timeout when communicating with the target.&quot;     )     public String getCommunicationsTimeout() {         return communicationsTimeout;     }      public void setCommunicationsTimeout(String communicationsTimeout) {         this.communicationsTimeout = communicationsTimeout;     }      /**      * @return when yielding, this amount of time must elapse before this remote process group is scheduled again      */     @ApiModelProperty(             value = &quot;When yielding, this amount of time must elapse before the remote process group is scheduled again.&quot;     )     public String getYieldDuration() {         return yieldDuration;     }      public void setYieldDuration(String yieldDuration) {         this.yieldDuration = yieldDuration;     }      /**      * @return number of active remote input ports      */     @ApiModelProperty(             value = &quot;The number of active remote input ports.&quot;     )     public Integer getActiveRemoteInputPortCount() {         return activeRemoteInputPortCount;     }      public void setActiveRemoteInputPortCount(Integer activeRemoteInputPortCount) {         this.activeRemoteInputPortCount = activeRemoteInputPortCount;     }      /**      * @return number of inactive remote input ports      */     @ApiModelProperty(             value = &quot;The number of inactive remote input ports.&quot;     )     public Integer getInactiveRemoteInputPortCount() {         return inactiveRemoteInputPortCount;     }      public void setInactiveRemoteInputPortCount(Integer inactiveRemoteInputPortCount) {         this.inactiveRemoteInputPortCount = inactiveRemoteInputPortCount;     }      /**      * @return number of active remote output ports      */     @ApiModelProperty(             value = &quot;The number of active remote output ports.&quot;     )     public Integer getActiveRemoteOutputPortCount() {         return activeRemoteOutputPortCount;     }      public void setActiveRemoteOutputPortCount(Integer activeRemoteOutputPortCount) {         this.activeRemoteOutputPortCount = activeRemoteOutputPortCount;     }      /**      * @return number of inactive remote output ports      */     @ApiModelProperty(             value = &quot;The number of inactive remote output ports.&quot;     )     public Integer getInactiveRemoteOutputPortCount() {         return inactiveRemoteOutputPortCount;     }      public void setInactiveRemoteOutputPortCount(Integer inactiveRemoteOutputPortCount) {         this.inactiveRemoteOutputPortCount = inactiveRemoteOutputPortCount;     }      /**      * @return number of Remote Input Ports currently available in the remote NiFi instance      */     @ApiModelProperty(             value = &quot;The number of remote input ports currently available on the target.&quot;     )     public Integer getInputPortCount() {         return inputPortCount;     }      public void setInputPortCount(Integer inputPortCount) {         this.inputPortCount = inputPortCount;     }      /**      * @return number of Remote Output Ports currently available in the remote NiFi instance      */     @ApiModelProperty(             value = &quot;The number of remote output ports currently available on the target.&quot;     )     public Integer getOutputPortCount() {         return outputPortCount;     }      public void setOutputPortCount(Integer outputPortCount) {         this.outputPortCount = outputPortCount;     }      /**      * @return contents of this remote process group. Will contain available input/output ports      */     @ApiModelProperty(             value = &quot;The contents of the remote process group. Will contain available input/output ports.&quot;     )     public RemoteProcessGroupContentsDTO getContents() {         return contents;     }      public void setContents(RemoteProcessGroupContentsDTO contents) {         this.contents = contents;     }      /**      * @return the flow for this remote group was last refreshed      */     @XmlJavaTypeAdapter(DateTimeAdapter.class)     @ApiModelProperty(             value = &quot;The timestamp when this remote process group was last refreshed.&quot;,             dataType = &quot;string&quot;     )     public Date getFlowRefreshed() {         return flowRefreshed;     }      public void setFlowRefreshed(Date flowRefreshed) {         this.flowRefreshed = flowRefreshed;     }      public String getTransportProtocol() {         return transportProtocol;     }      public void setTransportProtocol(String transportProtocol) {         this.transportProtocol = transportProtocol;     }      @ApiModelProperty(&quot;The local network interface to send/receive data. If not specified, any local address is used. If clustered, all nodes must have an interface with this identifier.&quot;)     public String getLocalNetworkInterface() {         return localNetworkInterface;     }      public void setLocalNetworkInterface(String localNetworkInterface) {         this.localNetworkInterface = localNetworkInterface;     }      @ApiModelProperty(             &quot;The validation errors for the remote process group. These validation errors represent the problems with the remote process group that must be resolved before it can transmit.&quot;     )     public Collection getValidationErrors() {         return validationErrors;     }      public void setValidationErrors(Collection validationErrors) {         this.validationErrors = validationErrors;     }      public String getProxyHost() {         return proxyHost;     }      public void setProxyHost(String proxyHost) {         this.proxyHost = proxyHost;     }      public Integer getProxyPort() {         return proxyPort;     }      public void setProxyPort(Integer proxyPort) {         this.proxyPort = proxyPort;     }      public String getProxyUser() {         return proxyUser;     }      public void setProxyUser(String proxyUser) {         this.proxyUser = proxyUser;     }      public String getProxyPassword() {         return proxyPassword;     }      public void setProxyPassword(String proxyPassword) {         this.proxyPassword = proxyPassword;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13734</td>
    <td align="left">https://github.com/apache/nifi/blob/c8eff590efa3babcda0b755009224dcac168708b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/RemoteProcessGroupDTO.java/#L30-L405</td>
    <td align="right">1</td>
    <td align="right">2267</td>
    <td align="right">13734</td>
  </tr>
  <tr valign="top">
    <td align="right">1701</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Long Method&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity @Table(name=&quot;xa_access_audit&quot;) public class AuthzAuditEventDbObj implements Serializable {  	private static final Log LOG = LogFactory.getLog(AuthzAuditEventDbObj.class);  	private static final long serialVersionUID = 1L;  	static int MaxValueLengthAccessType = 255; 	static int MaxValueLengthAclEnforcer = 255; 	static int MaxValueLengthAgentId = 255; 	static int MaxValueLengthClientIp = 255; 	static int MaxValueLengthClientType = 255; 	static int MaxValueLengthRepoName = 255; 	static int MaxValueLengthResultReason = 255; 	static int MaxValueLengthSessionId = 255; 	static int MaxValueLengthRequestUser = 255; 	static int MaxValueLengthAction = 2000; 	static int MaxValueLengthRequestData = 4000; 	static int MaxValueLengthResourcePath = 4000; 	static int MaxValueLengthResourceType = 255;  	private long   auditId; 	private int    repositoryType; 	private String repositoryName; 	private String user; 	private Date   timeStamp; 	private String accessType; 	private String resourcePath; 	private String resourceType; 	private String action; 	private int    accessResult; 	private String agentId; 	private long   policyId; 	private String resultReason; 	private String aclEnforcer; 	private String sessionId; 	private String clientType; 	private String clientIP; 	private String requestData; 	private long seqNum; 	private long eventCount; 	private long eventDurationMS; 	private String tags;  	public static void init(Properties props) 	{ 		LOG.info(&quot;AuthzAuditEventDbObj.init()&quot;);  		final String AUDIT_DB_MAX_COLUMN_VALUE = &quot;xasecure.audit.destination.db.max.column.length&quot;; 		MaxValueLengthAccessType = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;access_type&quot;, MaxValueLengthAccessType); 		logMaxColumnValue(&quot;access_type&quot;, MaxValueLengthAccessType);  		MaxValueLengthAclEnforcer = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;acl_enforcer&quot;, MaxValueLengthAclEnforcer); 		logMaxColumnValue(&quot;acl_enforcer&quot;, MaxValueLengthAclEnforcer);  		MaxValueLengthAction = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;action&quot;, MaxValueLengthAction); 		logMaxColumnValue(&quot;action&quot;, MaxValueLengthAction);  		MaxValueLengthAgentId = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;agent_id&quot;, MaxValueLengthAgentId); 		logMaxColumnValue(&quot;agent_id&quot;, MaxValueLengthAgentId);  		MaxValueLengthClientIp = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;client_id&quot;, MaxValueLengthClientIp); 		logMaxColumnValue(&quot;client_id&quot;, MaxValueLengthClientIp);  		MaxValueLengthClientType = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;client_type&quot;, MaxValueLengthClientType); 		logMaxColumnValue(&quot;client_type&quot;, MaxValueLengthClientType);  		MaxValueLengthRepoName = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;repo_name&quot;, MaxValueLengthRepoName); 		logMaxColumnValue(&quot;repo_name&quot;, MaxValueLengthRepoName);  		MaxValueLengthResultReason = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;result_reason&quot;, MaxValueLengthResultReason); 		logMaxColumnValue(&quot;result_reason&quot;, MaxValueLengthResultReason);  		MaxValueLengthSessionId = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;session_id&quot;, MaxValueLengthSessionId); 		logMaxColumnValue(&quot;session_id&quot;, MaxValueLengthSessionId);  		MaxValueLengthRequestUser = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;request_user&quot;, MaxValueLengthRequestUser); 		logMaxColumnValue(&quot;request_user&quot;, MaxValueLengthRequestUser);  		MaxValueLengthRequestData = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;request_data&quot;, MaxValueLengthRequestData); 		logMaxColumnValue(&quot;request_data&quot;, MaxValueLengthRequestData);  		MaxValueLengthResourcePath = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;resource_path&quot;, MaxValueLengthResourcePath); 		logMaxColumnValue(&quot;resource_path&quot;, MaxValueLengthResourcePath);  		MaxValueLengthResourceType = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;resource_type&quot;, MaxValueLengthResourceType); 		logMaxColumnValue(&quot;resource_type&quot;, MaxValueLengthResourceType); 	}  	public static void logMaxColumnValue(String columnName, int configuredMaxValueLength) { 		LOG.info(&quot;Setting max column value for column[&quot; + columnName + &quot;] to [&quot; + configuredMaxValueLength + &quot;].&quot;); 		if (configuredMaxValueLength == 0) { 			LOG.info(&quot;Max length of column[&quot; + columnName + &quot;] was 0! Column will NOT be emitted in the audit.&quot;); 		} else if (configuredMaxValueLength &lt; 0) { 			LOG.info(&quot;Max length of column[&quot; + columnName + &quot;] was less than 0! Column value will never be truncated.&quot;); 		} 	}   	public AuthzAuditEventDbObj() { 		super(); 	}  	public AuthzAuditEventDbObj(AuthzAuditEvent event) { 		super(); 		Date utcDate=null; 		if(event.getEventTime()!=null){ 			utcDate=MiscUtil.getUTCDateForLocalDate(event.getEventTime()); 		}else{ 			utcDate=MiscUtil.getUTCDate(); 		} 		this.repositoryType = event.getRepositoryType(); 		this.repositoryName = event.getRepositoryName(); 		this.user           = event.getUser(); 		this.timeStamp      = utcDate; 		this.accessType     = event.getAccessType(); 		this.resourcePath   = event.getResourcePath(); 		this.resourceType   = event.getResourceType(); 		this.action         = event.getAction(); 		this.accessResult   = event.getAccessResult(); 		this.agentId        = event.getAgentId(); 		this.policyId       = event.getPolicyId(); 		this.resultReason   = event.getResultReason(); 		this.aclEnforcer    = event.getAclEnforcer(); 		this.sessionId      = event.getSessionId(); 		this.clientType     = event.getClientType(); 		this.clientIP       = event.getClientIP(); 		this.requestData    = event.getRequestData(); 		this.seqNum         = event.getSeqNum(); 		this.eventCount     = event.getEventCount(); 		this.eventDurationMS= event.getEventDurationMS(); 		this.tags           = StringUtils.join(event.getTags(), &quot;, &quot;); 	}  	@Id 	@SequenceGenerator(name=&quot;XA_ACCESS_AUDIT_SEQ&quot;,sequenceName=&quot;XA_ACCESS_AUDIT_SEQ&quot;,allocationSize=1) 	@GeneratedValue(strategy=GenerationType.AUTO,generator=&quot;XA_ACCESS_AUDIT_SEQ&quot;) 	@Column(name = &quot;id&quot;, unique = true, nullable = false) 	public long getAuditId() { 		return this.auditId; 	}  	public void setAuditId(long auditId) { 		this.auditId = auditId; 	}  	@Column(name = &quot;repo_type&quot;) 	public int getRepositoryType() { 		return this.repositoryType; 	}  	public void setRepositoryType(int repositoryType) { 		this.repositoryType = repositoryType; 	}  	@Column(name = &quot;repo_name&quot;) 	public String getRepositoryName() { 		return truncate(this.repositoryName, MaxValueLengthRepoName, &quot;repo_name&quot;); 	}  	public void setRepositoryName(String repositoryName) { 		this.repositoryName = repositoryName; 	}  	@Column(name = &quot;request_user&quot;) 	public String getUser() { 		return truncate(this.user, MaxValueLengthRequestUser, &quot;request_user&quot;); 	}  	public void setUser(String user) { 		this.user = user; 	}  	@Temporal(TemporalType.TIMESTAMP) 	@Column(name = &quot;event_time&quot;) 	public Date getTimeStamp() { 		return this.timeStamp; 	}  	public void setTimeStamp(Date timeStamp) { 		this.timeStamp = timeStamp; 	}  	@Column(name = &quot;access_type&quot;) 	public String getAccessType() { 		return truncate(this.accessType, MaxValueLengthAccessType, &quot;access_type&quot;); 	}  	public void setAccessType(String accessType) { 		this.accessType = accessType; 	}  	@Column(name = &quot;resource_path&quot;) 	public String getResourcePath() { 		return truncate(this.resourcePath, MaxValueLengthResourcePath, &quot;resource_path&quot;); 	}  	public void setResourcePath(String resourcePath) { 		this.resourcePath = resourcePath; 	}  	@Column(name = &quot;resource_type&quot;) 	public String getResourceType() { 		return truncate(this.resourceType, MaxValueLengthResourceType, &quot;resource_type&quot;); 	}  	public void setResourceType(String resourceType) { 		this.resourceType = resourceType; 	}  	@Column(name = &quot;action&quot;) 	public String getAction() { 		return truncate(this.action, MaxValueLengthAction, &quot;action&quot;); 	}  	public void setAction(String action) { 		this.action = action; 	}  	@Column(name = &quot;access_result&quot;) 	public int getAccessResult() { 		return this.accessResult; 	}  	public void setAccessResult(int accessResult) { 		this.accessResult = accessResult; 	}  	@Column(name = &quot;agent_id&quot;) 	public String getAgentId() { 		return truncate(this.agentId, MaxValueLengthAgentId, &quot;agent_id&quot;); 	}  	public void setAgentId(String agentId) { 		this.agentId = agentId; 	}  	@Column(name = &quot;policy_id&quot;) 	public long getPolicyId() { 		return this.policyId; 	}  	public void setPolicyId(long policyId) { 		this.policyId = policyId; 	}  	@Column(name = &quot;result_reason&quot;) 	public String getResultReason() { 		return truncate(this.resultReason, MaxValueLengthResultReason, &quot;result_reason&quot;); 	}  	public void setResultReason(String resultReason) { 		this.resultReason = resultReason; 	}  	@Column(name = &quot;acl_enforcer&quot;) 	public String getAclEnforcer() { 		return truncate(this.aclEnforcer, MaxValueLengthAclEnforcer, &quot;acl_enforcer&quot;); 	}  	public void setAclEnforcer(String aclEnforcer) { 		this.aclEnforcer = aclEnforcer; 	}  	@Column(name = &quot;session_id&quot;) 	public String getSessionId() { 		return truncate(this.sessionId, MaxValueLengthSessionId, &quot;session_id&quot;); 	}  	public void setSessionId(String sessionId) { 		this.sessionId = sessionId; 	}  	@Column(name = &quot;client_type&quot;) 	public String getClientType() { 		return truncate(this.clientType, MaxValueLengthClientType, &quot;client_type&quot;); 	}  	public void setClientType(String clientType) { 		this.clientType = clientType; 	}  	@Column(name = &quot;client_ip&quot;) 	public String getClientIP() { 		return truncate(this.clientIP, MaxValueLengthClientIp, &quot;client_ip&quot;); 	}  	public void setClientIP(String clientIP) { 		this.clientIP = clientIP; 	}  	@Column(name = &quot;request_data&quot;) 	public String getRequestData() { 		return truncate(this.requestData, MaxValueLengthRequestData, &quot;request_data&quot;); 	}  	public void setRequestData(String requestData) { 		this.requestData = requestData; 	}  	@Column(name = &quot;seq_num&quot;) 	public long getSeqNum() { return this.seqNum; }  	public void setSeqNum(long seqNum) { this.seqNum = seqNum; }  	@Column(name = &quot;event_count&quot;) 	public long getEventCount() { return this.eventCount; }  	public void setEventCount(long eventCount) { this.eventCount = eventCount; }  	@Column(name = &quot;event_dur_ms&quot;) 	public long getEventDurationMS() { return this.eventDurationMS; }  	public void setEventDurationMS(long eventDurationMS) { this.eventDurationMS = eventDurationMS; }  	@Column(name = &quot;tags&quot;) 	public String getTags() { 		return this.tags; 	}  	public void setTags(String tags) { 		this.tags = tags; 	}  	static final String TruncationMarker = &quot;...&quot;; 	static final int TruncationMarkerLength = TruncationMarker.length();  	protected String truncate(String value, int limit, String columnName) { 		if (LOG.isDebugEnabled()) { 			LOG.debug(String.format(&quot;==&gt; getTrunctedValue(%s, %d, %s)&quot;, value, limit, columnName)); 		}  		String result = value; 		if (value != null) { 			if (limit &lt; 0) { 				if (LOG.isDebugEnabled()) { 					LOG.debug(String.format(&quot;Truncation is suppressed for column[%s]: old value [%s], new value[%s]&quot;, columnName, value, result)); 				} 			} else if (limit == 0) { 				if (LOG.isDebugEnabled()) { 					LOG.debug(String.format(&quot;Column[%s] is to be excluded from audit: old value [%s], new value[%s]&quot;, columnName, value, result)); 				} 				result = null; 			} else { 				if (value.length() &gt; limit) { 					if (limit &lt;= TruncationMarkerLength) { 						// NOTE: If value is to be truncated to a size that is less than of equal to the Truncation Marker then we won't put the marker in!! 						result = value.substring(0, limit); 					} else { 						StringBuilder sb = new StringBuilder(value.substring(0, limit - TruncationMarkerLength)); 						sb.append(TruncationMarker); 						result = sb.toString(); 					} 					if (LOG.isDebugEnabled()) { 						LOG.debug(String.format(&quot;Truncating value for column[%s] to [%d] characters: old value [%s], new value[%s]&quot;, columnName, limit, value, result)); 					} 				} 			} 		}  		if (LOG.isDebugEnabled()) { 			LOG.debug(String.format(&quot;&lt;== getTrunctedValue(%s, %d, %s): %s&quot;, value, limit, columnName, result)); 		} 		return result; 	} }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11736</td>
    <td align="left">https://github.com/apache/ranger/blob/7c52a79a5d0b41bfc94caca9d531e0fefba2bfe7/agents-audit/src/main/java/org/apache/ranger/audit/entity/AuthzAuditEventDbObj.java/#L46-L412</td>
    <td align="right">1</td>
    <td align="right">1701</td>
    <td align="right">11736</td>
  </tr>
  <tr valign="top">
    <td align="right">175</td>
    <td align="left">{     &quot;answer&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         {             &quot;name&quot;: &quot;Data Class&quot;         },         {             &quot;name&quot;: &quot;Long Method&quot;         }     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@APICommand(name = &quot;extractTemplate&quot;, description = &quot;Extracts a template&quot;, responseObject = ExtractResponse.class,         requestHasSensitiveInfo = false, responseHasSensitiveInfo = false) public class ExtractTemplateCmd extends BaseAsyncCmd {     public static final Logger s_logger = Logger.getLogger(ExtractTemplateCmd.class.getName());      private static final String s_name = &quot;extracttemplateresponse&quot;;      /////////////////////////////////////////////////////     //////////////// API parameters /////////////////////     /////////////////////////////////////////////////////      @Parameter(name = ApiConstants.ID, type = CommandType.UUID, entityType = TemplateResponse.class, required = true, description = &quot;the ID of the template&quot;)     private Long id;      @Parameter(name = ApiConstants.URL, type = CommandType.STRING, required = false, length = 2048, description = &quot;the url to which the ISO would be extracted&quot;)     private String url;      @Parameter(name = ApiConstants.ZONE_ID,                type = CommandType.UUID,                entityType = ZoneResponse.class,                required = false,                description = &quot;the ID of the zone where the ISO is originally located&quot;)     private Long zoneId;      @Parameter(name = ApiConstants.MODE, type = CommandType.STRING, required = true, description = &quot;the mode of extraction - HTTP_DOWNLOAD or FTP_UPLOAD&quot;)     private String mode;      /////////////////////////////////////////////////////     /////////////////// Accessors ///////////////////////     /////////////////////////////////////////////////////      public Long getId() {         return id;     }      public String getUrl() {         return url;     }      public Long getZoneId() {         return zoneId;     }      public String getMode() {         return mode;     }      /////////////////////////////////////////////////////     /////////////// API Implementation///////////////////     /////////////////////////////////////////////////////      @Override     public String getCommandName() {         return s_name;     }      public static String getStaticName() {         return s_name;     }      @Override     public long getEntityOwnerId() {         VirtualMachineTemplate template = _entityMgr.findById(VirtualMachineTemplate.class, getId());         if (template != null) {             return template.getAccountId();         }          // invalid id, parent this command to SYSTEM so ERROR events are tracked         return Account.ACCOUNT_ID_SYSTEM;     }      @Override     public String getEventType() {         return EventTypes.EVENT_TEMPLATE_EXTRACT;     }      @Override     public String getEventDescription() {      return &quot;extracting template: &quot; + this._uuidMgr.getUuid(VirtualMachineTemplate.class, getId()) + ((getZoneId() != null) ? &quot; from zone: &quot; + this._uuidMgr.getUuid(DataCenter.class, getZoneId()) : &quot;&quot;);     }      @Override     public ApiCommandJobType getInstanceType() {         return ApiCommandJobType.Template;     }      @Override     public Long getInstanceId() {         return getId();     }      @Override     public void execute() {         try {             CallContext.current().setEventDetails(getEventDescription());             String uploadUrl = _templateService.extract(this);             if (uploadUrl != null) {                 ExtractResponse response = _responseGenerator.createExtractResponse(id, zoneId, getEntityOwnerId(), mode, uploadUrl);                 response.setResponseName(getCommandName());                 this.setResponseObject(response);             } else {                 throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, &quot;Failed to extract template&quot;);             }         } catch (InternalErrorException ex) {             s_logger.warn(&quot;Exception: &quot;, ex);             throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());         }     } }</td>
    <td align="left">data class</td>
    <td align="left">name: data class, name: long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;name: long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2046</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/api/src/main/java/org/apache/cloudstack/api/command/user/template/ExtractTemplateCmd.java/#L39-L147</td>
    <td align="right">1</td>
    <td align="right">175</td>
    <td align="right">2046</td>
  </tr>
  <tr valign="top">
    <td align="right">3862</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ShapeMarshaller {      private String action;      private String verb;      private String target;      private String requestUri;      private String locationName;      private String xmlNameSpaceUri;      public String getAction() {         return action;     }      public void setAction(String action) {         this.action = action;     }      public ShapeMarshaller withAction(String action) {         setAction(action);         return this;     }      public String getVerb() {         return verb;     }      public void setVerb(String verb) {         this.verb = verb;     }      public ShapeMarshaller withVerb(String verb) {         setVerb(verb);         return this;     }      public String getTarget() {         return target;     }      public void setTarget(String target) {         this.target = target;     }      public ShapeMarshaller withTarget(String target) {         setTarget(target);         return this;     }      public String getRequestUri() {         return requestUri;     }      public void setRequestUri(String requestUri) {         this.requestUri = requestUri;     }      public ShapeMarshaller withRequestUri(String requestUri) {         setRequestUri(requestUri);         return this;     }      public String getLocationName() {         return locationName;     }      public void setLocationName(String locationName) {         this.locationName = locationName;     }      public ShapeMarshaller withLocationName(String locationName) {         setLocationName(locationName);         return this;     }      public String getXmlNameSpaceUri() {         return xmlNameSpaceUri;     }      public void setXmlNameSpaceUri(String xmlNameSpaceUri) {         this.xmlNameSpaceUri = xmlNameSpaceUri;     }      public ShapeMarshaller withXmlNameSpaceUri(String xmlNameSpaceUri) {         setXmlNameSpaceUri(xmlNameSpaceUri);         return this;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10055</td>
    <td align="left">https://github.com/aws/aws-sdk-java-v2/blob/1d5d11e8087c93ab1a3a2d35193052e526fd123c/codegen/src/main/java/software/amazon/awssdk/codegen/model/intermediate/ShapeMarshaller.java/#L18-L109</td>
    <td align="right">1</td>
    <td align="right">3862</td>
    <td align="right">10055</td>
  </tr>
  <tr valign="top">
    <td align="right">443</td>
    <td align="left">{   &quot;response&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LaunchRequest { 	private String jobName;  	String jobParameters;  	public String getJobName() { 		return jobName; 	}  	public void setJobName(String jobName) { 		this.jobName = jobName; 	}  	public String getJobParameters() { 		return jobParameters; 	}  	public void setJobParameters(String jobParameters) { 		this.jobParameters = jobParameters; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4309</td>
    <td align="left">https://github.com/spring-projects/spring-batch-admin/blob/9e3ad8bff99b8fad8da62426aa7d2959eb841bcf/spring-batch-admin-manager/src/main/java/org/springframework/batch/admin/web/LaunchRequest.java/#L21-L42</td>
    <td align="right">1</td>
    <td align="right">443</td>
    <td align="right">4309</td>
  </tr>
  <tr valign="top">
    <td align="right">327</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LockMode extends TypesafeEnum {     private LockMode(final int value) {         super(value);     }      /**      * Do not perform any locking. Items are opened for read or write without      * regard to concurrent access by other processes.      */     public static final LockMode NONE = new LockMode(0);      /**      * Wait forever to acquire the lock (or until the thread is interrupted).      */     public static final LockMode WAIT_FOREVER = new LockMode(1);      /**      * Attempt to acquire the lock but return immediately if it could not be      * acquired.      */     public static final LockMode NO_WAIT = new LockMode(2); }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3381</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core/src/com/microsoft/tfs/core/persistence/LockMode.java/#L15-L36</td>
    <td align="right">1</td>
    <td align="right">327</td>
    <td align="right">3381</td>
  </tr>
  <tr valign="top">
    <td align="right">2146</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES, I found bad smells. The bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ShapeMarshaller {      private String action;      private String verb;      private String target;      private String requestUri;      private String locationName;      private String xmlNameSpaceUri;      public String getAction() {         return action;     }      public void setAction(String action) {         this.action = action;     }      public ShapeMarshaller withAction(String action) {         setAction(action);         return this;     }      public String getVerb() {         return verb;     }      public void setVerb(String verb) {         this.verb = verb;     }      public ShapeMarshaller withVerb(String verb) {         setVerb(verb);         return this;     }      public String getTarget() {         return target;     }      public void setTarget(String target) {         this.target = target;     }      public ShapeMarshaller withTarget(String target) {         setTarget(target);         return this;     }      public String getRequestUri() {         return requestUri;     }      public void setRequestUri(String requestUri) {         this.requestUri = requestUri;     }      public ShapeMarshaller withRequestUri(String requestUri) {         setRequestUri(requestUri);         return this;     }      public String getLocationName() {         return locationName;     }      public void setLocationName(String locationName) {         this.locationName = locationName;     }      public ShapeMarshaller withLocationName(String locationName) {         setLocationName(locationName);         return this;     }      public String getXmlNameSpaceUri() {         return xmlNameSpaceUri;     }      public void setXmlNameSpaceUri(String xmlNameSpaceUri) {         this.xmlNameSpaceUri = xmlNameSpaceUri;     }      public ShapeMarshaller withXmlNameSpaceUri(String xmlNameSpaceUri) {         setXmlNameSpaceUri(xmlNameSpaceUri);         return this;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">&nbsp; </td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">13275</td>
    <td align="left">https://github.com/aws/aws-sdk-java-v2/blob/1d5d11e8087c93ab1a3a2d35193052e526fd123c/codegen/src/main/java/software/amazon/awssdk/codegen/model/intermediate/ShapeMarshaller.java/#L18-L109</td>
    <td align="right">1</td>
    <td align="right">2146</td>
    <td align="right">13275</td>
  </tr>
  <tr valign="top">
    <td align="right">658</td>
    <td align="left">{&quot;output&quot;: &quot;YES I found bad smells\nthe bad smells are: 1. Long Method, 2. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MemoryConsumptionTestClient {     private static final Logger LOGGER = LoggerFactory.getLogger(MemoryConsumptionTestClient.class);      private static final String RESULTS_FILE_ARG = &quot;resultsFile&quot;;      private static final String JNDI_PROPERTIES_ARG = &quot;jndiProperties&quot;;     private static final String JNDI_CONNECTION_FACTORY_ARG = &quot;jndiConnectionFactory&quot;;     private static final String JNDI_DESTINATION_ARG = &quot;jndiDestination&quot;;      private static final String CONNECTIONS_ARG = &quot;connections&quot;;     private static final String SESSIONS_ARG = &quot;sessions&quot;;     private static final String PRODUCERS_ARG = &quot;producers&quot;;     private static final String MESSAGE_COUNT_ARG = &quot;messagecount&quot;;     private static final String MESSAGE_SIZE_ARG = &quot;size&quot;;     private static final String PERSISTENT_ARG = &quot;persistent&quot;;     private static final String TIMEOUT_ARG = &quot;timeout&quot;;     private static final String TRANSACTED_ARG = &quot;transacted&quot;;     private static final String JMX_HOST_ARG = &quot;jmxhost&quot;;     private static final String JMX_PORT_ARG = &quot;jmxport&quot;;     private static final String JMX_USER_ARG = &quot;jmxuser&quot;;     private static final String JMX_USER_PASSWORD_ARG = &quot;jmxpassword&quot;;      private static final String RESULTS_FILE_DEFAULT = &quot;results.csv&quot;;     private static final String JNDI_PROPERTIES_DEFAULT = &quot;stress-test-client-qpid-jms-client-0-x.properties&quot;;     private static final String JNDI_CONNECTION_FACTORY_DEFAULT = &quot;qpidConnectionFactory&quot;;     private static final String JNDI_DESTINATION_DEFAULT = &quot;stressTestQueue&quot;;     private static final String CONNECTIONS_DEFAULT = &quot;1&quot;;     private static final String SESSIONS_DEFAULT = &quot;1&quot;;     private static final String PRODUCERS_DEFAULT = &quot;1&quot;;     private static final String MESSAGE_COUNT_DEFAULT = &quot;1&quot;;     private static final String MESSAGE_SIZE_DEFAULT = &quot;256&quot;;     private static final String PERSISTENT_DEFAULT = &quot;false&quot;;     private static final String TIMEOUT_DEFAULT = &quot;1000&quot;;     private static final String TRANSACTED_DEFAULT = &quot;false&quot;;      private static final String JMX_HOST_DEFAULT = &quot;localhost&quot;;     private static final String JMX_PORT_DEFAULT = &quot;8999&quot;;     private static final String JMX_GARBAGE_COLLECTOR_MBEAN = &quot;gc&quot;;      public static void main(String[] args) throws Exception     {         Map options = new HashMap&lt;&gt;();         options.put(RESULTS_FILE_ARG, RESULTS_FILE_DEFAULT);         options.put(JNDI_PROPERTIES_ARG, JNDI_PROPERTIES_DEFAULT);         options.put(JNDI_CONNECTION_FACTORY_ARG, JNDI_CONNECTION_FACTORY_DEFAULT);         options.put(JNDI_DESTINATION_ARG, JNDI_DESTINATION_DEFAULT);         options.put(CONNECTIONS_ARG, CONNECTIONS_DEFAULT);         options.put(SESSIONS_ARG, SESSIONS_DEFAULT);         options.put(PRODUCERS_ARG, PRODUCERS_DEFAULT);         options.put(MESSAGE_COUNT_ARG, MESSAGE_COUNT_DEFAULT);         options.put(MESSAGE_SIZE_ARG, MESSAGE_SIZE_DEFAULT);         options.put(PERSISTENT_ARG, PERSISTENT_DEFAULT);         options.put(TIMEOUT_ARG, TIMEOUT_DEFAULT);         options.put(TRANSACTED_ARG, TRANSACTED_DEFAULT);         options.put(JMX_HOST_ARG, JMX_HOST_DEFAULT);         options.put(JMX_PORT_ARG, JMX_PORT_DEFAULT);         options.put(JMX_USER_ARG, &quot;&quot;);         options.put(JMX_USER_PASSWORD_ARG, &quot;&quot;);         options.put(JMX_GARBAGE_COLLECTOR_MBEAN, &quot;java.lang:type=GarbageCollector,name=ConcurrentMarkSweep&quot;);          if(args.length == 1 &amp;&amp;                 (args[0].equals(&quot;-h&quot;) || args[0].equals(&quot;--help&quot;) || args[0].equals(&quot;help&quot;)))         {             System.out.println(&quot;arg=value options: \n&quot; + options.keySet());             return;         }          parseArgumentsIntoConfig(options, args);          MemoryConsumptionTestClient testClient = new MemoryConsumptionTestClient();         testClient.runTest(options);     }      private static void parseArgumentsIntoConfig(Map initialValues, String[] args)     {         for(String arg: args)         {             int equalPos = arg.indexOf('=');             if(equalPos == -1)             {                 throw new IllegalArgumentException(&quot;arguments must have format =: &quot; + arg);             }              if(initialValues.put(arg.substring(0, equalPos), arg.substring(equalPos + 1)) == null)             {                 throw new IllegalArgumentException(&quot;not a valid configuration property: &quot; + arg);             }         }     }       private void runTest(Map options) throws Exception     {         String resultsFile = options.get(RESULTS_FILE_ARG);         String jndiProperties = options.get(JNDI_PROPERTIES_ARG);         String connectionFactoryString = options.get(JNDI_CONNECTION_FACTORY_ARG);         int numConnections = Integer.parseInt(options.get(CONNECTIONS_ARG));         int numSessions = Integer.parseInt(options.get(SESSIONS_ARG));         int numProducers = Integer.parseInt(options.get(PRODUCERS_ARG));         int numMessage = Integer.parseInt(options.get(MESSAGE_COUNT_ARG));         int messageSize = Integer.parseInt(options.get(MESSAGE_SIZE_ARG));         String queueString = options.get(JNDI_DESTINATION_ARG);         int deliveryMode = Boolean.valueOf(options.get(PERSISTENT_ARG)) ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT;         long receiveTimeout = Long.parseLong(options.get(TIMEOUT_ARG));         boolean transacted = Boolean.valueOf(options.get(TRANSACTED_ARG));          LOGGER.info(&quot;Using options: &quot; + options);           // Load JNDI properties         Context ctx = getInitialContext(jndiProperties);         final ConnectionFactory conFac = (ConnectionFactory) ctx.lookup(connectionFactoryString);          Destination destination = ensureQueueCreated(queueString, conFac);         Map&gt; connectionsAndSessions = openConnectionsAndSessions(numConnections, numSessions, transacted, conFac);         publish(numMessage, messageSize, numProducers, deliveryMode, destination, connectionsAndSessions);         MemoryStatistic memoryStatistics = collectMemoryStatistics(options);         generateCSV(memoryStatistics, numConnections, numSessions, transacted, numMessage, messageSize, numProducers, deliveryMode, resultsFile);         purgeQueue(conFac, queueString, receiveTimeout);         closeConnections(connectionsAndSessions.keySet());         System.exit(0);     }      private void generateCSV(MemoryStatistic memoryStatistics,                              int numConnections,                              int numSessions,                              boolean transacted,                              int numMessage,                              int messageSize,                              int numProducers,                              int deliveryMode,                              final String resultsFile) throws IOException     {         try (FileWriter writer = new FileWriter(resultsFile))         {             writer.write(memoryStatistics.getHeapUsage()                          + &quot;,&quot;                          + memoryStatistics.getDirectMemoryUsage()                          + &quot;,&quot;                          + numConnections                          + &quot;,&quot;                          + numSessions                          + &quot;,&quot;                          + numProducers                          + &quot;,&quot;                          + transacted                          + &quot;,&quot;                          + numMessage                          + &quot;,&quot;                          + messageSize                          + &quot;,&quot;                          + deliveryMode                          + &quot;,&quot;                          + toUserFriendlyName(memoryStatistics.getHeapUsage())                          + &quot;,&quot;                          + toUserFriendlyName(memoryStatistics.getDirectMemoryUsage())                          + System.lineSeparator());         }     }      private void publish(int numberOfMessages, int messageSize, int numberOfProducers, int deliveryMode,                          Destination destination, Map&gt; connectionsAndSessions) throws JMSException     {         byte[] messageBytes = generateMessage(messageSize);         for (List sessions : connectionsAndSessions.values())         {             for (Session session: sessions)             {                 BytesMessage message = session.createBytesMessage();                  if (messageSize &gt; 0)                 {                     message.writeBytes(messageBytes);                 }                  for(int i = 0; i &lt; numberOfProducers ; i++)                 {                     MessageProducer prod = session.createProducer(destination);                     for(int j = 0; j &lt; numberOfMessages ; j++)                     {                         prod.send(message, deliveryMode, Message.DEFAULT_PRIORITY, Message.DEFAULT_TIME_TO_LIVE);                         if(session.getTransacted())                         {                             session.commit();                         }                     }                 }             }         }     }      private Map&gt; openConnectionsAndSessions(int numConnections, int numSessions, boolean transacted, ConnectionFactory conFac) throws JMSException     {         Map&gt; connectionAndSessions = new HashMap&lt;&gt;();         for (int i= 0; i &lt; numConnections ; i++)         {             Connection connection = conFac.createConnection();             connection.setExceptionListener(jmse -&gt; {                 LOGGER.error(&quot;The sample received an exception through the ExceptionListener&quot;, jmse);                 System.exit(1);             });              List sessions = new ArrayList&lt;&gt;();             connectionAndSessions.put(connection, sessions);             connection.start();             for (int s= 0; s &lt; numSessions ; s++)             {                 Session session = connection.createSession(transacted, transacted?Session.SESSION_TRANSACTED:Session.AUTO_ACKNOWLEDGE);                 sessions.add(session);             }         }         return connectionAndSessions;     }      private Context getInitialContext(final String jndiProperties) throws IOException, NamingException     {         Properties properties = new Properties();         try(InputStream is = this.getClass().getClassLoader().getResourceAsStream(jndiProperties))         {             if (is != null)             {                 properties.load(is);                 return new InitialContext(properties);             }         }          System.out.printf(MemoryConsumptionTestClient.class.getSimpleName() + &quot;: Failed to find '%s' on classpath, using fallback\n&quot;, jndiProperties);         return new InitialContext();     }      private Destination ensureQueueCreated(String queueURL, ConnectionFactory connectionFactory) throws JMSException     {         Connection connection = connectionFactory.createConnection();         Destination destination;         try         {             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);             destination = session.createQueue(queueURL);             MessageConsumer consumer = session.createConsumer(destination);             consumer.close();             session.close();         }         finally         {             connection.close();         }         return destination;     }      private void closeConnections(Collection connections) throws JMSException, NamingException     {         for (Connection c: connections)         {             c.close();         }     }      private void purgeQueue(ConnectionFactory connectionFactory, String queueString, long receiveTimeout) throws JMSException     {         LOGGER.debug(&quot;Consuming left over messages, using receive timeout:&quot; + receiveTimeout);          Connection connection = connectionFactory.createConnection();         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);         Destination destination = session.createQueue(queueString);         MessageConsumer consumer = session.createConsumer(destination);         connection.start();          int count = 0;         while (true)         {             BytesMessage msg = (BytesMessage) consumer.receive(receiveTimeout);              if(msg == null)             {                 LOGGER.debug(&quot;Received {} message(s)&quot;, count);                 break;             }             else             {                 count++;             }         }          consumer.close();         session.close();         connection.close();     }      private MemoryStatistic collectMemoryStatistics(Map options) throws Exception     {         String host = options.get(JMX_HOST_ARG);         String port = options.get(JMX_PORT_ARG);         String user = options.get(JMX_USER_ARG);         String password = options.get(JMX_USER_PASSWORD_ARG);          if (!&quot;&quot;.equals(host) &amp;&amp; !&quot;&quot;.equals(port) &amp;&amp; !&quot;&quot;.equals(user) &amp;&amp; !&quot;&quot;.equals(password))         {             Map environment = Collections.singletonMap(JMXConnector.CREDENTIALS, new String[]{user, password});              try(JMXConnector jmxConnector = JMXConnectorFactory.newJMXConnector(new JMXServiceURL(&quot;rmi&quot;, &quot;&quot;, 0, &quot;/jndi/rmi://&quot; + host + &quot;:&quot; + port + &quot;/jmxrmi&quot;), environment))             {                 jmxConnector.connect();                 final MBeanServerConnection mBeanServerConnection = jmxConnector.getMBeanServerConnection();                 final ObjectName memoryMBean = new ObjectName(&quot;java.lang:type=Memory&quot;);                 String gcCollectorMBeanName = options.get(JMX_GARBAGE_COLLECTOR_MBEAN);                 if (gcCollectorMBeanName.equals(&quot;&quot;))                 {                     mBeanServerConnection.invoke(memoryMBean, &quot;gc&quot;, null, null);                     MemoryStatistic memoryStatistics = new MemoryStatistic();                     collectMemoryStatistics(memoryStatistics, mBeanServerConnection, memoryMBean);                     return memoryStatistics;                 }                 else                 {                     ObjectName gcMBean = new ObjectName(gcCollectorMBeanName);                     if (mBeanServerConnection.isRegistered(gcMBean))                     {                         return collectMemoryStatisticsAfterGCNotification(mBeanServerConnection, gcMBean);                     }                     else                     {                         Set existingGCs = mBeanServerConnection.queryNames(new ObjectName(&quot;java.lang:type=GarbageCollector,name=*&quot;), null);                         throw new IllegalArgumentException(&quot;MBean '&quot; +gcCollectorMBeanName + &quot;' does not exists! Registered GC MBeans :&quot; + existingGCs);                     }                 }             }         }         return null;     }      private MemoryStatistic collectMemoryStatisticsAfterGCNotification(final MBeanServerConnection mBeanServerConnection, ObjectName gcMBean)             throws MalformedObjectNameException, IOException, InstanceNotFoundException, ReflectionException, MBeanException, InterruptedException     {         final MemoryStatistic memoryStatistics = new MemoryStatistic();         final CountDownLatch notificationReceived = new CountDownLatch(1);         final ObjectName memoryMBean = new ObjectName(&quot;java.lang:type=Memory&quot;);         mBeanServerConnection.addNotificationListener(gcMBean, (notification, handback) -&gt; {             if (notification.getType().equals(&quot;com.sun.management.gc.notification&quot;))             {                 CompositeData userData = (CompositeData) notification.getUserData();                 try                 {                     Object gcAction = userData.get(&quot;gcAction&quot;);                     Object gcCause = userData.get(&quot;gcCause&quot;);                     if (&quot;System.gc()&quot;.equals(gcCause) &amp;&amp; String.valueOf(gcAction).contains(&quot;end of major GC&quot;))                     {                         try                         {                             collectMemoryStatistics(memoryStatistics, mBeanServerConnection, memoryMBean);                         }                         finally                         {                             notificationReceived.countDown();                         }                      }                 }                 catch (Exception e)                 {                     e.printStackTrace();                     notificationReceived.countDown();                 }             }         }, null, null);          mBeanServerConnection.invoke(memoryMBean, &quot;gc&quot;, null, null);         if (!notificationReceived.await(5, TimeUnit.SECONDS))         {             throw new RuntimeException(&quot;GC notification was not sent in timely manner&quot;);         }         return memoryStatistics;     }      private void collectMemoryStatistics(MemoryStatistic memoryStatistics, MBeanServerConnection mBeanServerConnection, ObjectName memoryMBean) throws MBeanException, AttributeNotFoundException, InstanceNotFoundException, ReflectionException, IOException, MalformedObjectNameException     {         Object heapMemoryUsage = mBeanServerConnection.getAttribute(memoryMBean, &quot;HeapMemoryUsage&quot;);         Object used = ((CompositeData) heapMemoryUsage).get(&quot;used&quot;);         Object directMemoryTotalCapacity = mBeanServerConnection.getAttribute(new ObjectName(&quot;java.nio:type=BufferPool,name=direct&quot;), &quot;TotalCapacity&quot;);         memoryStatistics.setHeapUsage(Long.parseLong(String.valueOf(used)));         memoryStatistics.setDirectMemoryUsage(Long.parseLong(String.valueOf(directMemoryTotalCapacity)));     }      private String toUserFriendlyName(Object intValue)     {         long value = Long.parseLong(String.valueOf(intValue));         if (value &lt;= 1024)         {             return String.valueOf(value) + &quot;B&quot;;         }         else if (value &lt;= 1024 * 1024)         {             return String.valueOf(value/1024) + &quot;kB&quot;;         }         else if (value &lt;= 1024L * 1024L * 1024L)         {             return String.valueOf(value/1024L/1024L) + &quot;MB&quot;;         }         else         {             return String.valueOf(value/1024L/1024L/1024L) + &quot;GB&quot;;         }     }       private byte[] generateMessage(int messageSize)     {         byte[] sentBytes = new byte[messageSize];         for(int r = 0 ; r &lt; messageSize ; r++)         {             sentBytes[r] = (byte) (48 + (r % 10));         }         return sentBytes;     }      private class MemoryStatistic     {         private long heapUsage;         private long directMemoryUsage;          long getHeapUsage()         {             return heapUsage;         }          void setHeapUsage(long heapUsage)         {             this.heapUsage = heapUsage;         }          long getDirectMemoryUsage()         {             return directMemoryUsage;         }          void setDirectMemoryUsage(long directMemoryUsage)         {             this.directMemoryUsage = directMemoryUsage;         }     } }</td>
    <td align="left">data class</td>
    <td align="left">1. long method, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6413</td>
    <td align="left">https://github.com/apache/qpid-broker-j/blob/4c4400b98a5a8493cfb9e5dbb21c97175f433a62/tools/src/main/java/org/apache/qpid/tools/MemoryConsumptionTestClient.java/#L66-L506</td>
    <td align="right">1</td>
    <td align="right">658</td>
    <td align="right">6413</td>
  </tr>
  <tr valign="top">
    <td align="right">603</td>
    <td align="left">&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class DCSerialField extends DCBlockTag implements SerialFieldTree {         public final DCIdentifier name;         public final DCReference type;         public final List description;          DCSerialField(DCIdentifier name, DCReference type, List description) {             this.description = description;             this.name = name;             this.type = type;         }          @Override @DefinedBy(Api.COMPILER_TREE)         public Kind getKind() {             return Kind.SERIAL_FIELD;         }          @Override @DefinedBy(Api.COMPILER_TREE)         public  R accept(DocTreeVisitor v, D d) {             return v.visitSerialField(this, d);         }          @Override @DefinedBy(Api.COMPILER_TREE)         public List getDescription() {             return description;         }          @Override @DefinedBy(Api.COMPILER_TREE)         public IdentifierTree getName() {             return name;         }          @Override @DefinedBy(Api.COMPILER_TREE)         public ReferenceTree getType() {             return type;         }     }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6013</td>
    <td align="left">https://github.com/google/error-prone-javac/blob/a53d069bbdb2c60232ed3811c19b65e41c3e60e0/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/DCTree.java/#L732-L767</td>
    <td align="right">1</td>
    <td align="right">603</td>
    <td align="right">6013</td>
  </tr>
  <tr valign="top">
    <td align="right">1328</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MultiDexConfig {      private String name;      public MultiDexConfig(String name) {         this.name = name;     }      @Config(title = &quot;Whether to enable fast&quot;, message = &quot;Enable atlas , true/false&quot;, order = 0, group = &quot;atlas&quot;)     private boolean fastMultiDex = false;      @Config(title = &quot;The extra first dex class list&quot;, message = &quot;The custom needs to be placed in the entry class in the first dex&quot;, order = 3, group = &quot;atlas&quot;)     private Set firstDexClasses = Sets.newHashSet();     /**      * dex The number of subcontracting, 0 No restrictions, no two merges      */     @Config(title = &quot;dexThe number of&quot;, message = &quot;0unlimited&quot;, order = 1, group = &quot;atlas&quot;)     private int dexCount;      public int getMainDexListCount() {         return mainDexListCount;     }      public void setMainDexListCount(int mainDexListCount) {         this.mainDexListCount = mainDexListCount;     }      private int mainDexListCount;      @Config(title = &quot;dexSeparated rules&quot;, message = &quot;a,b;c,d&quot;, order = 2, group = &quot;atlas&quot;)     private String dexSplitRules;      @Config(title = &quot;Does not enter the list of the first dex's blacklist&quot;, message = &quot;a&quot;, order = 2, group = &quot;atlas&quot;)     private Set mainDexBlackList = Sets.newHashSet();      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public boolean isFastMultiDex() {         return fastMultiDex;     }      public void setFastMultiDex(boolean fastMultiDex) {         this.fastMultiDex = fastMultiDex;     }      public Set getMainDexBlackList() {         return mainDexBlackList;     }      public void setMainDexBlackList(Set mainDexBlackList) {         this.mainDexBlackList = mainDexBlackList;     }      public Set getFirstDexClasses() {         return firstDexClasses;     }      public void setFirstDexClasses(Set firstDexClasses) {         this.firstDexClasses = firstDexClasses;     }      public int getDexCount() {         return dexCount;     }      public void setDexCount(int dexCount) {         this.dexCount = dexCount;     }      public String getDexSplitRules() {         return dexSplitRules;     }      public void setDexSplitRules(String dexSplitRules) {         this.dexSplitRules = dexSplitRules;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10705</td>
    <td align="left">https://github.com/alibaba/atlas/blob/e8c7b3f1ff14b2a1df64321c6992b796cae7d732/atlas-gradle-plugin/atlas-plugin/src/main/java/com/taobao/android/builder/extension/MultiDexConfig.java/#L220-L302</td>
    <td align="right">1</td>
    <td align="right">1328</td>
    <td align="right">10705</td>
  </tr>
  <tr valign="top">
    <td align="right">2191</td>
    <td align="left">{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;detectedBadSmells&quot;: [     {       &quot;bad smells are&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;       ]     }   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class OperatorWrapper {   @SuppressWarnings(&quot;unused&quot;)   private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(OperatorWrapper.class);    private static final DecimalFormat DECIMAL_FORMATTER = new DecimalFormat(&quot;#.##&quot;);   private static final String UNKNOWN_OPERATOR = &quot;UNKNOWN_OPERATOR&quot;;   //Negative valued constant used for denoting invalid index to indicate absence of metric   private static final int NO_SPILL_METRIC_INDEX = Integer.MIN_VALUE;   private final int major;   private final List, String&gt;&gt; opsAndHosts; // [(operatorProfile --&gt; minorFragment number,host), ...]   private final OperatorProfile firstProfile;   private final CoreOperatorType operatorType;   private final String operatorName;   private final int size;   private final int timeSkewMin;   private final double timeSkewRatio;   private final int scanWaitMin;   private final double waitSkewRatio;    public OperatorWrapper(int major, List, String&gt;&gt; opsAndHostsList, Map phyOperMap, DrillConfig config) {     //Threshold to track if the slowest operator ran relatively slow     timeSkewMin = config.getInt(ExecConstants.PROFILE_WARNING_TIME_SKEW_MIN);     timeSkewRatio = config.getDouble(ExecConstants.PROFILE_WARNING_TIME_SKEW_RATIO_PROCESS);     //Threshold to track if the slowest SCAN operator spent more time in wait than processing     scanWaitMin = config.getInt(ExecConstants.PROFILE_WARNING_SCAN_WAIT_MIN);     waitSkewRatio = config.getDouble(ExecConstants.PROFILE_WARNING_TIME_SKEW_RATIO_WAIT);      Preconditions.checkArgument(opsAndHostsList.size() &gt; 0);     this.major = major;     firstProfile = opsAndHostsList.get(0).getLeft().getLeft();     operatorType = CoreOperatorType.valueOf(firstProfile.getOperatorType());     //Update Name from Physical Map     String path = new OperatorPathBuilder().setMajor(major).setOperator(firstProfile).build();     //Use Plan Extracted Operator Names if available     String extractedOpName = phyOperMap.get(path);     String inferredOpName = operatorType == null ? UNKNOWN_OPERATOR : operatorType.toString();     //Revert to inferred names for exceptional cases     // 1. Extracted 'FLATTEN' operator is NULL     // 2. Extracted 'SCAN' could be a PARQUET_ROW_GROUP_SCAN, or KAFKA_SUB_SCAN, or etc.     // 3. Extracted 'UNION_EXCHANGE' could be a SINGLE_SENDER or UNORDERED_RECEIVER     if (extractedOpName == null || inferredOpName.contains(extractedOpName) || extractedOpName.endsWith(&quot;_EXCHANGE&quot;)) {       operatorName =  inferredOpName;     } else {       operatorName =  extractedOpName;     }     this.opsAndHosts = opsAndHostsList;     size = opsAndHostsList.size();   }    public String getDisplayName() {     final String path = new OperatorPathBuilder().setMajor(major).setOperator(firstProfile).build();     return String.format(&quot;%s - %s&quot;, path, operatorName);   }    public String getId() {     return String.format(&quot;operator-%d-%d&quot;, major, opsAndHosts.get(0).getLeft().getLeft().getOperatorId());   }    public static final String [] OPERATOR_COLUMNS = {       OperatorTblTxt.MINOR_FRAGMENT, OperatorTblTxt.HOSTNAME, OperatorTblTxt.SETUP_TIME, OperatorTblTxt.PROCESS_TIME, OperatorTblTxt.WAIT_TIME,       OperatorTblTxt.MAX_BATCHES, OperatorTblTxt.MAX_RECORDS, OperatorTblTxt.PEAK_MEMORY   };    public static final String [] OPERATOR_COLUMNS_TOOLTIP = {       OperatorTblTooltip.MINOR_FRAGMENT, OperatorTblTooltip.HOSTNAME, OperatorTblTooltip.SETUP_TIME, OperatorTblTooltip.PROCESS_TIME, OperatorTblTooltip.WAIT_TIME,       OperatorTblTooltip.MAX_BATCHES, OperatorTblTooltip.MAX_RECORDS, OperatorTblTooltip.PEAK_MEMORY   };    public String getContent() {     TableBuilder builder = new TableBuilder(OPERATOR_COLUMNS, OPERATOR_COLUMNS_TOOLTIP, true);      Map attributeMap = new HashMap&lt;&gt;(); //Reusing for different fragments     for (ImmutablePair, String&gt; ip : opsAndHosts) {       int minor = ip.getLeft().getRight();       OperatorProfile op = ip.getLeft().getLeft();        attributeMap.put(HtmlAttribute.DATA_ORDER, String.valueOf(minor)); //Overwrite values from previous fragments       String path = new OperatorPathBuilder().setMajor(major).setMinor(minor).setOperator(op).build();       builder.appendCell(path, attributeMap);       builder.appendCell(ip.getRight());       builder.appendNanos(op.getSetupNanos());       builder.appendNanos(op.getProcessNanos());       builder.appendNanos(op.getWaitNanos());        long maxBatches = Long.MIN_VALUE;       long maxRecords = Long.MIN_VALUE;       for (StreamProfile sp : op.getInputProfileList()) {         maxBatches = Math.max(sp.getBatches(), maxBatches);         maxRecords = Math.max(sp.getRecords(), maxRecords);       }        builder.appendFormattedInteger(maxBatches);       builder.appendFormattedInteger(maxRecords);       builder.appendBytes(op.getPeakLocalMemoryAllocated());     }     return builder.build();   }    public static final String[] OPERATORS_OVERVIEW_COLUMNS = {       OverviewTblTxt.OPERATOR_ID, OverviewTblTxt.TYPE_OF_OPERATOR,       OverviewTblTxt.AVG_SETUP_TIME, OverviewTblTxt.MAX_SETUP_TIME,       OverviewTblTxt.AVG_PROCESS_TIME, OverviewTblTxt.MAX_PROCESS_TIME,       OverviewTblTxt.MIN_WAIT_TIME, OverviewTblTxt.AVG_WAIT_TIME, OverviewTblTxt.MAX_WAIT_TIME,       OverviewTblTxt.PERCENT_FRAGMENT_TIME, OverviewTblTxt.PERCENT_QUERY_TIME, OverviewTblTxt.ROWS,       OverviewTblTxt.AVG_PEAK_MEMORY, OverviewTblTxt.MAX_PEAK_MEMORY   };    public static final String[] OPERATORS_OVERVIEW_COLUMNS_TOOLTIP = {       OverviewTblTooltip.OPERATOR_ID, OverviewTblTooltip.TYPE_OF_OPERATOR,       OverviewTblTooltip.AVG_SETUP_TIME, OverviewTblTooltip.MAX_SETUP_TIME,       OverviewTblTooltip.AVG_PROCESS_TIME, OverviewTblTooltip.MAX_PROCESS_TIME,       OverviewTblTooltip.MIN_WAIT_TIME, OverviewTblTooltip.AVG_WAIT_TIME, OverviewTblTooltip.MAX_WAIT_TIME,       OverviewTblTooltip.PERCENT_FRAGMENT_TIME, OverviewTblTooltip.PERCENT_QUERY_TIME, OverviewTblTooltip.ROWS,       OverviewTblTooltip.AVG_PEAK_MEMORY, OverviewTblTooltip.MAX_PEAK_MEMORY   };    //Palette to help shade operators sharing a common major fragment   private static final String[] OPERATOR_OVERVIEW_BGCOLOR_PALETTE = {&quot;#ffffff&quot;,&quot;#f2f2f2&quot;};    public void addSummary(TableBuilder tb, Map majorFragmentBusyTally, long majorFragmentBusyTallyTotal) {     //Select background color from palette     String opTblBgColor = OPERATOR_OVERVIEW_BGCOLOR_PALETTE[major%OPERATOR_OVERVIEW_BGCOLOR_PALETTE.length];     String path = new OperatorPathBuilder().setMajor(major).setOperator(firstProfile).build();     tb.appendCell(path, opTblBgColor, null);     tb.appendCell(operatorName);      //Check if spill information is available     int spillCycleMetricIndex = getSpillCycleMetricIndex(operatorType);     boolean isSpillableOp = (spillCycleMetricIndex != NO_SPILL_METRIC_INDEX);     boolean hasSpilledToDisk = false;     boolean isScanOp = operatorName.endsWith(&quot;SCAN&quot;);      //Get MajorFragment Busy+Wait Time Tally     long majorBusyNanos = majorFragmentBusyTally.get(new OperatorPathBuilder().setMajor(major).build());      double setupSum = 0.0;     double processSum = 0.0;     double waitSum = 0.0;     double memSum = 0.0;     double spillCycleSum = 0.0;     long spillCycleMax = 0L;     long recordSum = 0L;      //Construct list for sorting purposes (using legacy Comparators)     final List&gt; opList = new ArrayList&lt;&gt;();      for (ImmutablePair,String&gt; ip : opsAndHosts) {       OperatorProfile profile = ip.getLeft().getLeft();       setupSum += profile.getSetupNanos();       processSum += profile.getProcessNanos();       waitSum += profile.getWaitNanos();       memSum += profile.getPeakLocalMemoryAllocated();       for (final StreamProfile sp : profile.getInputProfileList()) {         recordSum += sp.getRecords();       }       opList.add(ip.getLeft());        //Capture Spill Info       //Check to ensure index &lt; #metrics (old profiles have less metrics); else reset isSpillableOp       if (isSpillableOp) {         //NOTE: We get non-zero value for non-existent metrics, so we can't use getMetric(index)         //profile.getMetric(spillCycleMetricIndex).getLongValue();         //Forced to iterate list         for (MetricValue metricVal : profile.getMetricList()) {           if (metricVal.getMetricId() == spillCycleMetricIndex) {             long spillCycles = metricVal.getLongValue();             spillCycleMax = Math.max(spillCycles, spillCycleMax);             spillCycleSum += spillCycles;             hasSpilledToDisk = (spillCycleSum &gt; 0.0);           }         }       }     }      final ImmutablePair longSetup = Collections.max(opList, Comparators.setupTime);     tb.appendNanos(Math.round(setupSum / size));     tb.appendNanos(longSetup.getLeft().getSetupNanos());      Map timeSkewMap = null;     final ImmutablePair longProcess = Collections.max(opList, Comparators.processTime);     //Calculating average processing time     long avgProcTime = Math.round(processSum / size);     tb.appendNanos(avgProcTime);     long maxProcTime = longProcess.getLeft().getProcessNanos();     //Calculating skew of longest processing fragment w.r.t. average     double maxSkew = (avgProcTime &gt; 0) ? maxProcTime/Double.valueOf(avgProcTime) : 0.0d;     //Marking skew if both thresholds are crossed     if (avgProcTime &gt; TimeUnit.SECONDS.toNanos(timeSkewMin) &amp;&amp; maxSkew &gt; timeSkewRatio ) {       timeSkewMap = new HashMap&lt;&gt;();       timeSkewMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_TIME_SKEW_TAG);       timeSkewMap.put(HtmlAttribute.TITLE,  &quot;One fragment took &quot; + DECIMAL_FORMATTER.format(maxSkew) + &quot; longer than average&quot;);       timeSkewMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);     }     tb.appendNanos(maxProcTime, timeSkewMap);      final ImmutablePair shortWait = Collections.min(opList, Comparators.waitTime);     final ImmutablePair longWait = Collections.max(opList, Comparators.waitTime);     tb.appendNanos(shortWait.getLeft().getWaitNanos());     //Calculating average wait time for fragment     long avgWaitTime = Math.round(waitSum / size);      //Slow Scan Warning     Map slowScanMap = null;     //Marking slow scan if threshold is crossed and wait was longer than processing     if (isScanOp &amp;&amp; (avgWaitTime &gt; TimeUnit.SECONDS.toNanos(scanWaitMin)) &amp;&amp; (avgWaitTime &gt; avgProcTime)) {       slowScanMap = new HashMap&lt;&gt;();       slowScanMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_SCAN_WAIT_TAG);       slowScanMap.put(HtmlAttribute.TITLE, &quot;Avg Wait Time &gt; Avg Processing Time&quot;);       slowScanMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);     }     tb.appendNanos(avgWaitTime, slowScanMap);      long maxWaitTime = longWait.getLeft().getWaitNanos();     //Skewed Wait Warning     timeSkewMap = null; //Resetting     //Calculating skew of longest waiting fragment w.r.t. average     maxSkew = (avgWaitTime &gt; 0) ? maxWaitTime/Double.valueOf(avgWaitTime) : 0.0d;     //Marking skew if both thresholds are crossed     if (avgWaitTime &gt; TimeUnit.SECONDS.toNanos(timeSkewMin) &amp;&amp; maxSkew &gt; waitSkewRatio) {       timeSkewMap = new HashMap&lt;&gt;();       timeSkewMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_TIME_SKEW_TAG);       timeSkewMap.put(HtmlAttribute.TITLE, &quot;One fragment waited &quot; + DECIMAL_FORMATTER.format(maxSkew) + &quot; longer than average&quot;);       timeSkewMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);     }     tb.appendNanos(maxWaitTime, timeSkewMap);      tb.appendPercent(processSum / majorBusyNanos);     tb.appendPercent(processSum / majorFragmentBusyTallyTotal);      tb.appendFormattedInteger(recordSum);      final ImmutablePair peakMem = Collections.max(opList, Comparators.operatorPeakMemory);      //Inject spill-to-disk attributes     Map avgSpillMap = null;     Map maxSpillMap = null;     if (hasSpilledToDisk) {       avgSpillMap = new HashMap&lt;&gt;();       //Average SpillCycle       double avgSpillCycle = spillCycleSum/size;       avgSpillMap.put(HtmlAttribute.TITLE, DECIMAL_FORMATTER.format(avgSpillCycle) + &quot; spills on average&quot;);       avgSpillMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);       avgSpillMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_SPILL_TAG); //JScript will inject Icon       avgSpillMap.put(HtmlAttribute.SPILLS, DECIMAL_FORMATTER.format(avgSpillCycle)); //JScript will inject Count       maxSpillMap = new HashMap&lt;&gt;();       maxSpillMap.put(HtmlAttribute.TITLE, &quot;Most # spills: &quot; + spillCycleMax);       maxSpillMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);       maxSpillMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_SPILL_TAG); //JScript will inject Icon       maxSpillMap.put(HtmlAttribute.SPILLS, String.valueOf(spillCycleMax)); //JScript will inject Count     }      tb.appendBytes(Math.round(memSum / size), avgSpillMap);     tb.appendBytes(peakMem.getLeft().getPeakLocalMemoryAllocated(), maxSpillMap);   }    /**    * Returns index of Spill Count/Cycle metric    * @param operatorType    * @return index of spill metric    */   private int getSpillCycleMetricIndex(CoreOperatorType operatorType) {     // TODO: DRILL-6642, replace null values for ProtocolMessageEnum with UNRECOGNIZED NullValue to avoid null checks     if (operatorType == null) {       return NO_SPILL_METRIC_INDEX;     }     String metricName;      switch (operatorType) {     case EXTERNAL_SORT:       metricName = &quot;SPILL_COUNT&quot;;       break;     case HASH_AGGREGATE:     case HASH_JOIN:       metricName = &quot;SPILL_CYCLE&quot;;       break;     default:       return NO_SPILL_METRIC_INDEX;     }      int metricIndex = 0; //Default     String[] metricNames = OperatorMetricRegistry.getMetricNames(operatorType.getNumber());     for (String name : metricNames) {       if (name.equalsIgnoreCase(metricName)) {         return metricIndex;       }       metricIndex++;     }     //Backward compatibility with rendering older profiles. Ideally we should never touch this if an expected metric is not there     return NO_SPILL_METRIC_INDEX;   }    public String getMetricsTable() {     if (operatorType == null) {       return &quot;&quot;;     }     final String[] metricNames = OperatorMetricRegistry.getMetricNames(operatorType.getNumber());     if (metricNames == null) {       return &quot;&quot;;     }      final String[] metricsTableColumnNames = new String[metricNames.length + 1];     metricsTableColumnNames[0] = &quot;Minor Fragment&quot;;     int i = 1;     for (final String metricName : metricNames) {       metricsTableColumnNames[i++] = metricName;     }     final TableBuilder builder = new TableBuilder(metricsTableColumnNames, null);      for (final ImmutablePair,String&gt; ip : opsAndHosts) {       final OperatorProfile op = ip.getLeft().getLeft();        builder.appendCell(           new OperatorPathBuilder()           .setMajor(major)           .setMinor(ip.getLeft().getRight())           .setOperator(op)           .build());        final Number[] values = new Number[metricNames.length];       //Track new/Unknown Metrics       final Set unknownMetrics = new TreeSet&lt;&gt;();       for (final MetricValue metric : op.getMetricList()) {         if (metric.getMetricId() &lt; metricNames.length) {           if (metric.hasLongValue()) {             values[metric.getMetricId()] = metric.getLongValue();           } else if (metric.hasDoubleValue()) {             values[metric.getMetricId()] = metric.getDoubleValue();           }         } else {           //Tracking unknown metric IDs           unknownMetrics.add(metric.getMetricId());         }       }       for (final Number value : values) {         if (value != null) {           builder.appendFormattedNumber(value);         } else {           builder.appendCell(&quot;&quot;);         }       }     }     return builder.build();   }    private class OperatorTblTxt {     static final String MINOR_FRAGMENT = &quot;Minor Fragment&quot;;     static final String HOSTNAME = &quot;Hostname&quot;;     static final String SETUP_TIME = &quot;Setup Time&quot;;     static final String PROCESS_TIME = &quot;Process Time&quot;;     static final String WAIT_TIME = &quot;Wait Time&quot;;     static final String MAX_BATCHES = &quot;Max Batches&quot;;     static final String MAX_RECORDS = &quot;Max Records&quot;;     static final String PEAK_MEMORY = &quot;Peak Memory&quot;;   }    private class OperatorTblTooltip {     static final String MINOR_FRAGMENT = &quot;Operator's Minor Fragment&quot;;     static final String HOSTNAME = &quot;Host on which the minor fragment ran&quot;;     static final String SETUP_TIME = &quot;Setup Time for the minor fragment's operator&quot;;     static final String PROCESS_TIME = &quot;Process Time for the minor fragment's operator&quot;;     static final String WAIT_TIME = &quot;Wait Time for the minor fragment's operator&quot;;     static final String MAX_BATCHES = &quot;Max Batches processed by the minor fragment's operator&quot;;     static final String MAX_RECORDS = &quot;Max Records processed by the minor fragment's operator&quot;;     static final String PEAK_MEMORY = &quot;Peak Memory usage by the minor fragment's operator&quot;;   }    private class OverviewTblTxt {     static final String OPERATOR_ID = &quot;Operator ID&quot;;     static final String TYPE_OF_OPERATOR = &quot;Type&quot;;     static final String AVG_SETUP_TIME = &quot;Avg Setup Time&quot;;     static final String MAX_SETUP_TIME = &quot;Max Setup Time&quot;;     static final String AVG_PROCESS_TIME = &quot;Avg Process Time&quot;;     static final String MAX_PROCESS_TIME = &quot;Max Process Time&quot;;     static final String MIN_WAIT_TIME = &quot;Min Wait Time&quot;;     static final String AVG_WAIT_TIME = &quot;Avg Wait Time&quot;;     static final String MAX_WAIT_TIME = &quot;Max Wait Time&quot;;     static final String PERCENT_FRAGMENT_TIME = &quot;% Fragment Time&quot;;     static final String PERCENT_QUERY_TIME = &quot;% Query Time&quot;;     static final String ROWS = &quot;Rows&quot;;     static final String AVG_PEAK_MEMORY = &quot;Avg Peak Memory&quot;;     static final String MAX_PEAK_MEMORY = &quot;Max Peak Memory&quot;;   }    private class OverviewTblTooltip {     static final String OPERATOR_ID = &quot;Operator ID&quot;;     static final String TYPE_OF_OPERATOR = &quot;Operator Type&quot;;     static final String AVG_SETUP_TIME = &quot;Average time in setting up fragments&quot;;     static final String MAX_SETUP_TIME = &quot;Longest time a fragment took in setup&quot;;     static final String AVG_PROCESS_TIME = &quot;Average process time for a fragment&quot;;     static final String MAX_PROCESS_TIME = &quot;Longest process time of any fragment&quot;;     static final String MIN_WAIT_TIME = &quot;Shortest time a fragment spent in waiting&quot;;     static final String AVG_WAIT_TIME = &quot;Average wait time for a fragment&quot;;     static final String MAX_WAIT_TIME = &quot;Longest time a fragment spent in waiting&quot;;     static final String PERCENT_FRAGMENT_TIME = &quot;Percentage of the total fragment time that was spent on the operator&quot;;     static final String PERCENT_QUERY_TIME = &quot;Percentage of the total query time that was spent on the operator&quot;;     static final String ROWS = &quot;Rows emitted by scans, or consumed by other operators&quot;;     static final String AVG_PEAK_MEMORY  =  &quot;Average memory consumption by a fragment&quot;;     static final String MAX_PEAK_MEMORY  =  &quot;Highest memory consumption by a fragment&quot;;   } }</td>
    <td align="left">data class</td>
    <td align="left">bad smells are: data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13466</td>
    <td align="left">https://github.com/apache/drill/blob/5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3/exec/java-exec/src/main/java/org/apache/drill/exec/server/rest/profile/OperatorWrapper.java/#L43-L442</td>
    <td align="right">1</td>
    <td align="right">2191</td>
    <td align="right">13466</td>
  </tr>
  <tr valign="top">
    <td align="right">660</td>
    <td align="left">&nbsp;{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;bad_smells&quot;: [     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class JarModule {     private ModuleRevisionId mrid;      private File jar;      public JarModule(ModuleRevisionId mrid, File jar) {         this.mrid = mrid;         this.jar = jar;     }      public File getJar() {         return jar;     }      public ModuleRevisionId getMrid() {         return mrid;     }      public String toString() {         return jar + &quot; &quot; + mrid;     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6430</td>
    <td align="left">https://github.com/apache/ant-ivy/blob/4ffcf8f06f238b17e78e8033c3e8278833e452eb/src/java/org/apache/ivy/tools/analyser/JarModule.java/#L24-L46</td>
    <td align="right">1</td>
    <td align="right">660</td>
    <td align="right">6430</td>
  </tr>
  <tr valign="top">
    <td align="right">5028</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public class IteratorVariableElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.xtext.ui.tests.editor.contentassist.BacktrackingContentAssistTestLanguage.iteratorVariable&quot;); 		private final Group cGroup = (Group)rule.eContents().get(1); 		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0); 		private final RuleCall cNameIdentifierParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0); 		private final Group cGroup_1 = (Group)cGroup.eContents().get(1); 		private final Keyword cColonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0); 		private final Assignment cTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1); 		private final RuleCall cTypeTypeExpParserRuleCall_1_1_0 = (RuleCall)cTypeAssignment_1_1.eContents().get(0); 		 		//iteratorVariable: 		//	name=Identifier (':' type=TypeExp)?; 		@Override public ParserRule getRule() { return rule; } 		 		//name=Identifier (':' type=TypeExp)? 		public Group getGroup() { return cGroup; } 		 		//name=Identifier 		public Assignment getNameAssignment_0() { return cNameAssignment_0; } 		 		//Identifier 		public RuleCall getNameIdentifierParserRuleCall_0_0() { return cNameIdentifierParserRuleCall_0_0; } 		 		//(':' type=TypeExp)? 		public Group getGroup_1() { return cGroup_1; } 		 		//':' 		public Keyword getColonKeyword_1_0() { return cColonKeyword_1_0; } 		 		//type=TypeExp 		public Assignment getTypeAssignment_1_1() { return cTypeAssignment_1_1; } 		 		//TypeExp 		public RuleCall getTypeTypeExpParserRuleCall_1_1_0() { return cTypeTypeExpParserRuleCall_1_1_0; } 	}</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13962</td>
    <td align="left">https://github.com/eclipse/xtext-eclipse/blob/0c7546b6aaf3644a77fc68eef9f3da368cbbeabd/org.eclipse.xtext.ui.tests/src-gen/org/eclipse/xtext/ui/tests/editor/contentassist/services/BacktrackingContentAssistTestLanguageGrammarAccess.java/#L2569-L2603</td>
    <td align="right">1</td>
    <td align="right">5028</td>
    <td align="right">13962</td>
  </tr>
  <tr valign="top">
    <td align="right">2577</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         {             &quot;1&quot;: &quot;Data Class&quot;         }     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@InterfaceAudience.Private @InterfaceStability.Unstable public class JobStatusChangedEvent implements HistoryEvent {   private JobStatusChanged datum = new JobStatusChanged();    /**    * Create an event to record the change in the Job Status    * @param id Job ID    * @param jobStatus The new job status    */   public JobStatusChangedEvent(JobID id, String jobStatus) {     datum.jobid = new Utf8(id.toString());     datum.jobStatus = new Utf8(jobStatus);   }    JobStatusChangedEvent() {}    public Object getDatum() { return datum; }   public void setDatum(Object datum) {     this.datum = (JobStatusChanged)datum;   }    /** Get the Job Id */   public JobID getJobId() { return JobID.forName(datum.jobid.toString()); }   /** Get the event status */   public String getStatus() { return datum.jobStatus.toString(); }   /** Get the event type */   public EventType getEventType() {     return EventType.JOB_STATUS_CHANGED;   }  }</td>
    <td align="left">data class</td>
    <td align="left">1: data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14935</td>
    <td align="left">https://github.com/apache/hadoop-mapreduce/blob/307cb5b316e10defdbbc228d8cdcdb627191ea15/src/java/org/apache/hadoop/mapreduce/jobhistory/JobStatusChangedEvent.java/#L33-L64</td>
    <td align="right">1</td>
    <td align="right">2577</td>
    <td align="right">14935</td>
  </tr>
  <tr valign="top">
    <td align="right">2224</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
class ResourceMethodConfigImpl implements ResourceMethodConfig {   private final ConfigValue _timeoutMs;    ResourceMethodConfigImpl(ConfigValue timeoutMs)   {     _timeoutMs = timeoutMs;   }    public ConfigValue getTimeoutMs()   {     return _timeoutMs;   }    @Override   public String toString()   {     return &quot;ResourceMethodConfigImpl{&quot; +             &quot;_timeoutMs=&quot; + _timeoutMs +             '}';   }    @Override   public boolean equals(Object o)   {     if (this == o) return true;     if (o == null || getClass() != o.getClass()) return false;     ResourceMethodConfigImpl that = (ResourceMethodConfigImpl) o;     return Objects.equals(_timeoutMs, that._timeoutMs);   }    @Override   public int hashCode()   {     return Objects.hash(_timeoutMs);   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13570</td>
    <td align="left">https://github.com/linkedin/rest.li/blob/ad74aa98da8a55ad9c339d0769a3e8fb495765af/restli-server/src/main/java/com/linkedin/restli/server/config/ResourceMethodConfigImpl.java/#L13-L49</td>
    <td align="right">1</td>
    <td align="right">2224</td>
    <td align="right">13570</td>
  </tr>
  <tr valign="top">
    <td align="right">1301</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class RowRange {     private Text startRow;     private Text endRow;      public RowRange(KeyExtent ke) {       this.startRow = ke.getPrevEndRow();       this.endRow = ke.getEndRow();     }      public RowRange(TRowRange trr) {       this.startRow = ByteBufferUtil.toText(trr.startRow);       this.endRow = ByteBufferUtil.toText(trr.endRow);     }      public RowRange(Text startRow, Text endRow) {       this.startRow = startRow;       this.endRow = endRow;     }      public Range toRange() {       return new Range(startRow, false, endRow, true);     }      public TRowRange toThrift() {       return new TRowRange(TextUtil.getByteBuffer(startRow), TextUtil.getByteBuffer(endRow));     }      public Text getStartRow() {       return startRow;     }      public Text getEndRow() {       return endRow;     }      @Override     public String toString() {       return startRow + &quot; &quot; + endRow;     }   }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10658</td>
    <td align="left">https://github.com/apache/accumulo/blob/f896c98c2356a52dfa2235d2cc02ae556ab17909/core/src/main/java/org/apache/accumulo/core/summary/Gatherer.java/#L617-L656</td>
    <td align="right">1</td>
    <td align="right">1301</td>
    <td align="right">10658</td>
  </tr>
  <tr valign="top">
    <td align="right">385</td>
    <td align="left">&nbsp;&nbsp;YES, I found bad smells the bad smells are: 1. Long method 2. Long class 3. Shotgun surgery 4. Feature envy  5. Data class  6. God class 7. Lazy class</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class IgfsHandshakeResponse implements Externalizable {     /** */     private static final long serialVersionUID = 0L;      /** IGFS name. */     private String igfsName;      /** Server block size. */     private long blockSize;      /** Whether to force sampling on client's side. */     private Boolean sampling;      /**      * {@link Externalizable} support.      */     public IgfsHandshakeResponse() {         // No-op.     }      /**      * Constructor.      *      * @param blockSize Server default block size.      */     public IgfsHandshakeResponse(String igfsName, long blockSize, Boolean sampling) {         this.igfsName = igfsName;         this.blockSize = blockSize;         this.sampling = sampling;     }      /**      * @return IGFS name.      */     public String igfsName() {         return igfsName;     }      /**      * @return Server default block size.      */     public long blockSize() {         return blockSize;     }      /**      * @return Sampling flag.      */     public Boolean sampling() {         return sampling;     }      /** {@inheritDoc} */     @Override public void writeExternal(ObjectOutput out) throws IOException {         U.writeString(out, igfsName);          out.writeLong(blockSize);          if (sampling != null) {             out.writeBoolean(true);             out.writeBoolean(sampling);         }         else             out.writeBoolean(false);     }      /** {@inheritDoc} */     @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {         igfsName = U.readString(in);          blockSize = in.readLong();          if (in.readBoolean())             sampling = in.readBoolean();     } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method2 Long class3 Shotgun surgery4 Feature envy 5 Data class 6 God class7 Lazy class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3938</td>
    <td align="left">https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/core/src/main/java/org/apache/ignite/internal/processors/igfs/IgfsHandshakeResponse.java/#L29-L104</td>
    <td align="right">2</td>
    <td align="right">385</td>
    <td align="right">3938</td>
  </tr>
  <tr valign="top">
    <td align="right">1013</td>
    <td align="left">&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [         &quot;Long Method&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DataSourceLoginService extends AbstractLoginService {     private static final Logger LOG = Log.getLogger(DataSourceLoginService.class);      private String _jndiName = &quot;javax.sql.DataSource/default&quot;;     private DataSource _datasource;     private Server _server;     private String _userTableName = &quot;users&quot;;     private String _userTableKey = &quot;id&quot;;     private String _userTableUserField = &quot;username&quot;;     private String _userTablePasswordField = &quot;pwd&quot;;     private String _roleTableName = &quot;roles&quot;;     private String _roleTableKey = &quot;id&quot;;     private String _roleTableRoleField = &quot;role&quot;;     private String _userRoleTableName = &quot;user_roles&quot;;     private String _userRoleTableUserKey = &quot;user_id&quot;;     private String _userRoleTableRoleKey = &quot;role_id&quot;;     private String _userSql;     private String _roleSql;     private boolean _createTables = false;               /**      * DBUser      */     public class DBUserPrincipal extends UserPrincipal     {         private int _key;                  public DBUserPrincipal(String name, Credential credential, int key)         {             super(name, credential);             _key = key;         }                  public int getKey ()         {             return _key;         }              }      /* ------------------------------------------------------------ */     public DataSourceLoginService()     {     }      /* ------------------------------------------------------------ */     public DataSourceLoginService(String name)     {         setName(name);     }      /* ------------------------------------------------------------ */     public DataSourceLoginService(String name, IdentityService identityService)     {         setName(name);         setIdentityService(identityService);     }      /* ------------------------------------------------------------ */     public void setJndiName (String jndi)     {         _jndiName = jndi;     }      /* ------------------------------------------------------------ */     public String getJndiName ()     {         return _jndiName;     }      /* ------------------------------------------------------------ */     public void setServer (Server server)     {         _server=server;     }      /* ------------------------------------------------------------ */     public Server getServer()     {         return _server;     }      /* ------------------------------------------------------------ */     public void setCreateTables(boolean createTables)     {         _createTables = createTables;     }      /* ------------------------------------------------------------ */     public boolean getCreateTables()     {         return _createTables;     }      /* ------------------------------------------------------------ */     public void setUserTableName (String name)     {         _userTableName=name;     }      /* ------------------------------------------------------------ */     public String getUserTableName()     {         return _userTableName;     }      /* ------------------------------------------------------------ */     public String getUserTableKey()     {         return _userTableKey;     }       /* ------------------------------------------------------------ */     public void setUserTableKey(String tableKey)     {         _userTableKey = tableKey;     }       /* ------------------------------------------------------------ */     public String getUserTableUserField()     {         return _userTableUserField;     }       /* ------------------------------------------------------------ */     public void setUserTableUserField(String tableUserField)     {         _userTableUserField = tableUserField;     }       /* ------------------------------------------------------------ */     public String getUserTablePasswordField()     {         return _userTablePasswordField;     }       /* ------------------------------------------------------------ */     public void setUserTablePasswordField(String tablePasswordField)     {         _userTablePasswordField = tablePasswordField;     }       /* ------------------------------------------------------------ */     public String getRoleTableName()     {         return _roleTableName;     }       /* ------------------------------------------------------------ */     public void setRoleTableName(String tableName)     {         _roleTableName = tableName;     }       /* ------------------------------------------------------------ */     public String getRoleTableKey()     {         return _roleTableKey;     }       /* ------------------------------------------------------------ */     public void setRoleTableKey(String tableKey)     {         _roleTableKey = tableKey;     }       /* ------------------------------------------------------------ */     public String getRoleTableRoleField()     {         return _roleTableRoleField;     }       /* ------------------------------------------------------------ */     public void setRoleTableRoleField(String tableRoleField)     {         _roleTableRoleField = tableRoleField;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableName()     {         return _userRoleTableName;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableName(String roleTableName)     {         _userRoleTableName = roleTableName;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableUserKey()     {         return _userRoleTableUserKey;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableUserKey(String roleTableUserKey)     {         _userRoleTableUserKey = roleTableUserKey;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableRoleKey()     {         return _userRoleTableRoleKey;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableRoleKey(String roleTableRoleKey)     {         _userRoleTableRoleKey = roleTableRoleKey;     }              /* ------------------------------------------------------------ */     @Override     public UserPrincipal loadUserInfo (String username)     {         try         {             try (Connection connection = getConnection();                     PreparedStatement statement1 = connection.prepareStatement(_userSql))             {                 statement1.setObject(1, username);                 try (ResultSet rs1 = statement1.executeQuery())                 {                     if (rs1.next())                     {                         int key = rs1.getInt(_userTableKey);                         String credentials = rs1.getString(_userTablePasswordField);                                                  return new DBUserPrincipal(username, Credential.getCredential(credentials), key);                     }                 }             }         }         catch (NamingException e)         {             LOG.warn(&quot;No datasource for &quot;+_jndiName, e);         }         catch (SQLException e)         {             LOG.warn(&quot;Problem loading user info for &quot;+username, e);         }         return null;     }               /* ------------------------------------------------------------ */     @Override     public String[] loadRoleInfo (UserPrincipal user)     {         DBUserPrincipal dbuser = (DBUserPrincipal)user;          try         {             try (Connection connection = getConnection();                     PreparedStatement statement2 = connection.prepareStatement(_roleSql))             {                  List roles = new ArrayList();                  statement2.setInt(1, dbuser.getKey());                 try (ResultSet rs2 = statement2.executeQuery())                 {                     while (rs2.next())                     {                         roles.add(rs2.getString(_roleTableRoleField));                     }                                          return roles.toArray(new String[roles.size()]);                 }             }         }         catch (NamingException e)         {             LOG.warn(&quot;No datasource for &quot;+_jndiName, e);         }         catch (SQLException e)         {             LOG.warn(&quot;Problem loading user info for &quot;+user.getName(), e);         }         return null;     }             /* ------------------------------------------------------------ */     /**      * Lookup the datasource for the jndiName and formulate the      * necessary sql query strings based on the configured table      * and column names.      *      * @throws NamingException if unable to init jndi      * @throws SQLException if unable to init database      */     public void initDb() throws NamingException, SQLException     {         if (_datasource != null)             return;          @SuppressWarnings(&quot;unused&quot;)         InitialContext ic = new InitialContext();         assert ic!=null;          // TODO Should we try webapp scope too?          // try finding the datasource in the Server scope         if (_server != null)         {             try             {                 _datasource = (DataSource)NamingEntryUtil.lookup(_server, _jndiName);             }             catch (NameNotFoundException e)             {                 //next try the jvm scope             }         }           //try finding the datasource in the jvm scope         if (_datasource==null)         {             _datasource = (DataSource)NamingEntryUtil.lookup(null, _jndiName);         }          // set up the select statements based on the table and column names configured         _userSql = &quot;select &quot; + _userTableKey + &quot;,&quot; + _userTablePasswordField                   + &quot; from &quot; + _userTableName                   + &quot; where &quot;+ _userTableUserField + &quot; = ?&quot;;          _roleSql = &quot;select r.&quot; + _roleTableRoleField                   + &quot; from &quot; + _roleTableName + &quot; r, &quot; + _userRoleTableName                   + &quot; u where u.&quot;+ _userRoleTableUserKey + &quot; = ?&quot;                   + &quot; and r.&quot; + _roleTableKey + &quot; = u.&quot; + _userRoleTableRoleKey;          prepareTables();     }      /* ------------------------------------------------------------ */     /**      * @throws NamingException      * @throws SQLException      */     private void prepareTables()     throws NamingException, SQLException     {         if (_createTables)         {             boolean autocommit = true;             Connection connection = getConnection();             try (Statement stmt = connection.createStatement())             {                 autocommit = connection.getAutoCommit();                 connection.setAutoCommit(false);                 DatabaseMetaData metaData = connection.getMetaData();                  //check if tables exist                 String tableName = (metaData.storesLowerCaseIdentifiers()? _userTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userTableName.toUpperCase(Locale.ENGLISH): _userTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //user table default                         /*                          * create table _userTableName (_userTableKey integer,                          * _userTableUserField varchar(100) not null unique,                          * _userTablePasswordField varchar(20) not null, primary key(_userTableKey));                          */                         stmt.executeUpdate(&quot;create table &quot;+_userTableName+ &quot;(&quot;+_userTableKey+&quot; integer,&quot;+                                 _userTableUserField+&quot; varchar(100) not null unique,&quot;+                                 _userTablePasswordField+&quot; varchar(20) not null, primary key(&quot;+_userTableKey+&quot;))&quot;);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_userTableName);                     }                 }                  tableName = (metaData.storesLowerCaseIdentifiers()? _roleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_roleTableName.toUpperCase(Locale.ENGLISH): _roleTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //role table default                         /*                          * create table _roleTableName (_roleTableKey integer,                          * _roleTableRoleField varchar(100) not null unique, primary key(_roleTableKey));                          */                         String str = &quot;create table &quot;+_roleTableName+&quot; (&quot;+_roleTableKey+&quot; integer, &quot;+                         _roleTableRoleField+&quot; varchar(100) not null unique, primary key(&quot;+_roleTableKey+&quot;))&quot;;                         stmt.executeUpdate(str);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_roleTableName);                     }                 }                  tableName = (metaData.storesLowerCaseIdentifiers()? _userRoleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userRoleTableName.toUpperCase(Locale.ENGLISH): _userRoleTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //user-role table                         /*                          * create table _userRoleTableName (_userRoleTableUserKey integer,                          * _userRoleTableRoleKey integer,                          * primary key (_userRoleTableUserKey, _userRoleTableRoleKey));                          *                          * create index idx_user_role on _userRoleTableName (_userRoleTableUserKey);                          */                         stmt.executeUpdate(&quot;create table &quot;+_userRoleTableName+&quot; (&quot;+_userRoleTableUserKey+&quot; integer, &quot;+                                 _userRoleTableRoleKey+&quot; integer, &quot;+                                 &quot;primary key (&quot;+_userRoleTableUserKey+&quot;, &quot;+_userRoleTableRoleKey+&quot;))&quot;);                         stmt.executeUpdate(&quot;create index indx_user_role on &quot;+_userRoleTableName+&quot;(&quot;+_userRoleTableUserKey+&quot;)&quot;);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_userRoleTableName +&quot; and index&quot;);                     }                 }                 connection.commit();             }             finally             {                 try                 {                     connection.setAutoCommit(autocommit);                 }                 catch (SQLException e)                 {                     if (LOG.isDebugEnabled()) LOG.debug(&quot;Prepare tables&quot;, e);                 }                 finally                 {                     try                     {                         connection.close();                     }                     catch (SQLException e)                     {                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Prepare tables&quot;, e);                     }                 }             }         }         else if (LOG.isDebugEnabled())         {             LOG.debug(&quot;createTables false&quot;);         }     }      /* ------------------------------------------------------------ */     /**      * @return      * @throws NamingException      * @throws SQLException      */     private Connection getConnection ()     throws NamingException, SQLException     {         initDb();         return _datasource.getConnection();     } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9294</td>
    <td align="left">https://github.com/eclipse/jetty.project/blob/65528f76c5ef6ddca11385f9721c8f0bc5f2eed7/jetty-plus/src/main/java/org/eclipse/jetty/plus/security/DataSourceLoginService.java/#L52-L530</td>
    <td align="right">1</td>
    <td align="right">1013</td>
    <td align="right">9294</td>
  </tr>
  <tr valign="top">
    <td align="right">1773</td>
    <td align="left">&nbsp;YES I found bad smells the bad smells are:  1. Long method,  2. Data class,  3. Inappropriate intimacy</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class Ipam {   private String driver;   private List config;   private Map options;    public String getDriver() {     return driver;   }    public void setDriver(String driver) {     this.driver = driver;   }    public Ipam withDriver(String driver) {     this.driver = driver;     return this;   }    public List getConfig() {     return config;   }    public void setConfig(List config) {     this.config = config;   }    public Ipam withConfig(List config) {     this.config = config;     return this;   }    public Map getOptions() {     return options;   }    public void setOptions(Map options) {     this.options = options;   }    public Ipam withOptions(Map options) {     this.options = options;     return this;   }    @Override   public boolean equals(Object obj) {     if (this == obj) {       return true;     }     if (!(obj instanceof Ipam)) {       return false;     }     final Ipam that = (Ipam) obj;     return Objects.equals(driver, that.driver)         &amp;&amp; getConfig().equals(that.getConfig())         &amp;&amp; getOptions().equals(that.getOptions());   }    @Override   public int hashCode() {     int hash = 7;     hash = 31 * hash + Objects.hashCode(driver);     hash = 31 * hash + getConfig().hashCode();     hash = 31 * hash + getOptions().hashCode();     return hash;   }    @Override   public String toString() {     return &quot;Ipam{&quot;         + &quot;driver='&quot;         + driver         + '\''         + &quot;, config=&quot;         + config         + &quot;, options=&quot;         + options         + '}';   } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method, 2 Data class, 3 Inappropriate intimacy</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">. Long method,  3. Inappropriate intimacy</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11931</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/infrastructures/docker/docker-client/src/main/java/org/eclipse/che/infrastructure/docker/client/json/network/Ipam.java/#L19-L98</td>
    <td align="right">2</td>
    <td align="right">1773</td>
    <td align="right">11931</td>
  </tr>
  <tr valign="top">
    <td align="right">2124</td>
    <td align="left">	{ 		&quot;output&quot;: &quot;YES I found bad smells&quot;, 		&quot;bad smells are&quot;: [ 			&quot;Long Method&quot;, 			&quot;Data Class&quot; 		] 	} </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TextAndButtonSection extends Section {  	public TextAndButtonSection( String labelText, Composite parent, 			boolean isFormStyle ) 	{ 		super( labelText, parent, isFormStyle ); 	}  	protected int width = -1;  	protected boolean fillText = false;  	protected TextPropertyDescriptor textField;  	public void createSection( ) 	{ 		if ( selectList == null ) 			selectList = new ArrayList( ); 		getLabelControl( parent ); 		getTextControl( parent ); 		getButtonControl( parent ); 		getGridPlaceholder( parent ); 	}  	public void layout( ) 	{ 		GridData gd = (GridData) textField.getControl( ).getLayoutData( ); 		if ( getLayoutNum( ) &gt; 0 ) 			gd.horizontalSpan = getLayoutNum( ) - 2 - placeholder; 		else 			gd.horizontalSpan = ( (GridLayout) parent.getLayout( ) ).numColumns 					- 2 					- placeholder; 		if ( width &gt; -1 ) 		{ 			gd.widthHint = width; 			gd.grabExcessHorizontalSpace = false; 		} 		else 			gd.grabExcessHorizontalSpace = fillText;  		gd = (GridData) button.getLayoutData( );  		if ( buttonWidth &gt; -1 ) 		{ 			if ( !isComputeSize ) 				gd.widthHint = Math.max( button.computeSize( -1, -1 ).x, 						buttonWidth ); 			else 				gd.widthHint = button.computeSize( -1, -1 ).x; 		} 	}  	public TextPropertyDescriptor getTextControl( ) 	{ 		return textField; 	}  	protected TextPropertyDescriptor getTextControl( Composite parent ) 	{ 		if ( textField == null ) 		{ 			textField = DescriptorToolkit.createTextPropertyDescriptor( true ); 			if ( getProvider( ) != null ) 				textField.setDescriptorProvider( getProvider( ) ); 			textField.createControl( parent ); 			textField.getControl( ).setLayoutData( new GridData( ) ); 			textField.getControl( ).addDisposeListener( new DisposeListener( ) {  				public void widgetDisposed( DisposeEvent event ) 				{ 					textField = null; 				} 			} ); 		} 		else 		{ 			checkParent( textField.getControl( ), parent ); 		} 		return textField; 	}  	protected Button button;  	public Button getButtonControl( ) 	{ 		return button; 	}  	protected Button getButtonControl( Composite parent ) 	{ 		if ( button == null ) 		{ 			button = FormWidgetFactory.getInstance( ).createButton( parent, 					SWT.PUSH, 					isFormStyle ); 			button.setFont( parent.getFont( ) );  			button.setLayoutData( new GridData( ) ); 			String text = getButtonText( ); 			if ( text != null ) 			{ 				button.setText( text ); 			}  			text = getButtonTooltipText( ); 			if ( text != null ) 			{ 				button.setToolTipText( text ); 			}  			button.addDisposeListener( new DisposeListener( ) {  				public void widgetDisposed( DisposeEvent event ) 				{ 					button = null; 				} 			} );  			if ( !selectList.isEmpty( ) ) 				button.addSelectionListener( (SelectionListener) selectList.get( 0 ) ); 			else 			{ 				SelectionListener listener = new SelectionAdapter( ) {  					public void widgetSelected( SelectionEvent e ) 					{ 						onClickButton( ); 					} 				}; 				selectList.add( listener ); 			}  		} 		else 		{ 			checkParent( button, parent ); 		} 		return button; 	}  	private String buttonText;  	IDescriptorProvider provider;  	public IDescriptorProvider getProvider( ) 	{ 		return provider; 	}  	public void setProvider( IDescriptorProvider provider ) 	{ 		this.provider = provider; 		if ( textField != null ) 			textField.setDescriptorProvider( provider ); 	}  	protected List selectList = new ArrayList( );  	/** 	 * if use this method , you couldn't use the onClickButton method. 	 */ 	public void addSelectionListener( SelectionListener listener ) 	{ 		if ( !selectList.contains( listener ) ) 		{ 			if ( !selectList.isEmpty( ) ) 				removeSelectionListener( (SelectionListener) selectList.get( 0 ) ); 			selectList.add( listener ); 			if ( button != null ) 				button.addSelectionListener( listener ); 		} 	}  	public void removeSelectionListener( SelectionListener listener ) 	{ 		if ( selectList.contains( listener ) ) 		{ 			selectList.remove( listener ); 			if ( button != null ) 				button.removeSelectionListener( listener ); 		} 	}  	protected void onClickButton( ) 	{ 	};  	public void forceFocus( ) 	{ 		textField.getControl( ).forceFocus( ); 	}  	public void setInput( Object input ) 	{ 		textField.setInput( input ); 	}  	public void load( ) 	{ 		if ( textField != null &amp;&amp; !textField.getControl( ).isDisposed( ) ) 			textField.load( ); 		if ( button != null &amp;&amp; !button.isDisposed( ) ) 			button.setEnabled( !isReadOnly( ) ); 	}  	protected int buttonWidth = 60;  	public void setButtonWidth( int buttonWidth ) 	{ 		this.buttonWidth = buttonWidth; 		if ( button != null ) 		{ 			GridData data = new GridData( ); 			data.widthHint = Math.max( button.computeSize( -1, -1 ).x, 					buttonWidth );; 			data.grabExcessHorizontalSpace = false; 			button.setLayoutData( data ); 		} 	}  	protected boolean isComputeSize = false;  	public int getWidth( ) 	{ 		return width; 	}  	public void setWidth( int width ) 	{ 		this.width = width; 	}  	public int getButtonWidth( ) 	{ 		return buttonWidth; 	}  	private String oldValue;  	public void setStringValue( String value ) 	{ 		if ( textField != null ) 		{ 			if ( value == null ) 			{ 				value = &quot;&quot;;//$NON-NLS-1$ 			} 			oldValue = textField.getText( ); 			if ( !oldValue.equals( value ) ) 			{ 				textField.setText( value ); 			} 		} 	}  	public boolean isFillText( ) 	{ 		return fillText; 	}  	public void setFillText( boolean fillText ) 	{ 		this.fillText = fillText; 	}  	public void setHidden( boolean isHidden ) 	{ 		if ( displayLabel != null ) 			WidgetUtil.setExcludeGridData( displayLabel, isHidden ); 		if ( textField != null ) 			textField.setHidden( isHidden ); 		if ( button != null ) 			WidgetUtil.setExcludeGridData( button, isHidden ); 		if ( placeholderLabel != null ) 			WidgetUtil.setExcludeGridData( placeholderLabel, isHidden ); 	}  	public void setVisible( boolean isVisible ) 	{ 		if ( displayLabel != null ) 			displayLabel.setVisible( isVisible ); 		if ( textField != null ) 			textField.setVisible( isVisible ); 		if ( button != null ) 			button.setVisible( isVisible ); 		if ( placeholderLabel != null ) 			placeholderLabel.setVisible( isVisible ); 	}  	private String buttonTooltipText;  	public void setButtonTooltipText( String string ) 	{ 		this.buttonTooltipText = string; 		if ( button != null ) 			button.setText( buttonTooltipText );  	}  	public String getButtonText( ) 	{ 		return buttonText; 	}  	public void setButtonText( String buttonText ) 	{ 		this.buttonText = buttonText; 		if ( button != null ) 			button.setText( buttonText ); 	}  	public String getButtonTooltipText( ) 	{ 		return buttonTooltipText; 	}  	public boolean buttonIsComputeSize( ) 	{ 		return isComputeSize; 	}  	public void setButtonIsComputeSize( boolean isComputeSize ) 	{ 		this.isComputeSize = isComputeSize; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">13216</td>
    <td align="left">https://github.com/eclipse/birt/blob/f89264810347de98702db45386a822aabc0fadbf/UI/org.eclipse.birt.report.designer.ui.views/src/org/eclipse/birt/report/designer/internal/ui/views/attributes/section/TextAndButtonSection.java/#L23-L351</td>
    <td align="right">1</td>
    <td align="right">2124</td>
    <td align="right">13216</td>
  </tr>
  <tr valign="top">
    <td align="right">408</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;response&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             &quot;1. Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  static class OfflineIteratorEnvironment implements IteratorEnvironment {      private final Authorizations authorizations;     private AccumuloConfiguration conf;     private boolean useSample;     private SamplerConfiguration sampleConf;      public OfflineIteratorEnvironment(Authorizations auths, AccumuloConfiguration acuTableConf,         boolean useSample, SamplerConfiguration samplerConf) {       this.authorizations = auths;       this.conf = acuTableConf;       this.useSample = useSample;       this.sampleConf = samplerConf;     }      @Deprecated     @Override     public AccumuloConfiguration getConfig() {       return conf;     }      @Override     public IteratorScope getIteratorScope() {       return IteratorScope.scan;     }      @Override     public boolean isFullMajorCompaction() {       return false;     }      @Override     public boolean isUserCompaction() {       return false;     }      private ArrayList&gt; topLevelIterators = new ArrayList&lt;&gt;();      @Deprecated     @Override     public void registerSideChannel(SortedKeyValueIterator iter) {       topLevelIterators.add(iter);     }      @Override     public Authorizations getAuthorizations() {       return authorizations;     }      SortedKeyValueIterator getTopLevelIterator(SortedKeyValueIterator iter) {       if (topLevelIterators.isEmpty())         return iter;       ArrayList&gt; allIters = new ArrayList&lt;&gt;(topLevelIterators);       allIters.add(iter);       return new MultiIterator(allIters, false);     }      @Override     public boolean isSamplingEnabled() {       return useSample;     }      @Override     public SamplerConfiguration getSamplerConfiguration() {       return sampleConf;     }      @Override     public IteratorEnvironment cloneWithSamplingEnabled() {       if (sampleConf == null)         throw new SampleNotPresentException();       return new OfflineIteratorEnvironment(authorizations, conf, true, sampleConf);     }   }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4156</td>
    <td align="left">https://github.com/apache/accumulo/blob/f896c98c2356a52dfa2235d2cc02ae556ab17909/core/src/main/java/org/apache/accumulo/core/clientImpl/OfflineIterator.java/#L70-L143</td>
    <td align="right">1</td>
    <td align="right">408</td>
    <td align="right">4156</td>
  </tr>
  <tr valign="top">
    <td align="right">4314</td>
    <td align="left">&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detected bad smells&quot;: [         &quot;1. Blob&quot;,         &quot;2. Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LoopedModelImpl extends MinimalEObjectImpl.Container implements LoopedModel {   /**    * The cached value of the '{@link #getVisibility() Visibility}' attribute list.    *     *     * @see #getVisibility()    * @generated    * @ordered    */   protected EList visibility;    /**    * The cached value of the '{@link #getStatic() Static}' attribute list.    *     *     * @see #getStatic()    * @generated    * @ordered    */   protected EList static_;    /**    * The cached value of the '{@link #getSynchronized() Synchronized}' attribute list.    *     *     * @see #getSynchronized()    * @generated    * @ordered    */   protected EList synchronized_;    /**    * The cached value of the '{@link #getAbstract() Abstract}' attribute list.    *     *     * @see #getAbstract()    * @generated    * @ordered    */   protected EList abstract_;    /**    * The cached value of the '{@link #getFinal() Final}' attribute list.    *     *     * @see #getFinal()    * @generated    * @ordered    */   protected EList final_;    /**    * The default value of the '{@link #getName() Name}' attribute.    *     *     * @see #getName()    * @generated    * @ordered    */   protected static final String NAME_EDEFAULT = null;    /**    * The cached value of the '{@link #getName() Name}' attribute.    *     *     * @see #getName()    * @generated    * @ordered    */   protected String name = NAME_EDEFAULT;    /**    *     *     * @generated    */   protected LoopedModelImpl()   {     super();   }    /**    *     *     * @generated    */   @Override   protected EClass eStaticClass()   {     return UnorderedGroupsTestPackage.Literals.LOOPED_MODEL;   }    /**    *     *     * @generated    */   public EList getVisibility()   {     if (visibility == null)     {       visibility = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY);     }     return visibility;   }    /**    *     *     * @generated    */   public EList getStatic()   {     if (static_ == null)     {       static_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC);     }     return static_;   }    /**    *     *     * @generated    */   public EList getSynchronized()   {     if (synchronized_ == null)     {       synchronized_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED);     }     return synchronized_;   }    /**    *     *     * @generated    */   public EList getAbstract()   {     if (abstract_ == null)     {       abstract_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT);     }     return abstract_;   }    /**    *     *     * @generated    */   public EList getFinal()   {     if (final_ == null)     {       final_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL);     }     return final_;   }    /**    *     *     * @generated    */   public String getName()   {     return name;   }    /**    *     *     * @generated    */   public void setName(String newName)   {     String oldName = name;     name = newName;     if (eNotificationRequired())       eNotify(new ENotificationImpl(this, Notification.SET, UnorderedGroupsTestPackage.LOOPED_MODEL__NAME, oldName, name));   }    /**    *     *     * @generated    */   @Override   public Object eGet(int featureID, boolean resolve, boolean coreType)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         return getVisibility();       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         return getStatic();       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         return getSynchronized();       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         return getAbstract();       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         return getFinal();       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         return getName();     }     return super.eGet(featureID, resolve, coreType);   }    /**    *     *     * @generated    */   @SuppressWarnings(&quot;unchecked&quot;)   @Override   public void eSet(int featureID, Object newValue)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         getVisibility().clear();         getVisibility().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         getStatic().clear();         getStatic().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         getSynchronized().clear();         getSynchronized().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         getAbstract().clear();         getAbstract().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         getFinal().clear();         getFinal().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         setName((String)newValue);         return;     }     super.eSet(featureID, newValue);   }    /**    *     *     * @generated    */   @Override   public void eUnset(int featureID)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         getVisibility().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         getStatic().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         getSynchronized().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         getAbstract().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         getFinal().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         setName(NAME_EDEFAULT);         return;     }     super.eUnset(featureID);   }    /**    *     *     * @generated    */   @Override   public boolean eIsSet(int featureID)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         return visibility != null &amp;&amp; !visibility.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         return static_ != null &amp;&amp; !static_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         return synchronized_ != null &amp;&amp; !synchronized_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         return abstract_ != null &amp;&amp; !abstract_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         return final_ != null &amp;&amp; !final_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         return NAME_EDEFAULT == null ? name != null : !NAME_EDEFAULT.equals(name);     }     return super.eIsSet(featureID);   }    /**    *     *     * @generated    */   @Override   public String toString()   {     if (eIsProxy()) return super.toString();      StringBuffer result = new StringBuffer(super.toString());     result.append(&quot; (visibility: &quot;);     result.append(visibility);     result.append(&quot;, static: &quot;);     result.append(static_);     result.append(&quot;, synchronized: &quot;);     result.append(synchronized_);     result.append(&quot;, abstract: &quot;);     result.append(abstract_);     result.append(&quot;, final: &quot;);     result.append(final_);     result.append(&quot;, name: &quot;);     result.append(name);     result.append(')');     return result.toString();   }  } //LoopedModelImpl</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11368</td>
    <td align="left">https://github.com/eclipse/xtext-eclipse/blob/0c7546b6aaf3644a77fc68eef9f3da368cbbeabd/org.eclipse.xtext.ui.tests/src-gen/org/eclipse/xtext/ui/tests/editor/contentassist/unorderedGroupsTest/impl/LoopedModelImpl.java/#L40-L375</td>
    <td align="right">1</td>
    <td align="right">4314</td>
    <td align="right">11368</td>
  </tr>
  <tr valign="top">
    <td align="right">1765</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class BaseColumnInfo implements Serializable {      /**      * Serial version id.      */     private static final long serialVersionUID = 1L;      /**      * The table and alias info encapsulated in a different class.      */     private TableAliasInfo tabAlias;      /**      * The metastore column information. The column can be null      * and that denotes that the expression is dependent on the row      * of the table and not particular column. This can happen in case      * of count(1).      */     private FieldSchema column;      /**      * @return the tabAlias      */     public TableAliasInfo getTabAlias() {       return tabAlias;     }      /**      * @param tabAlias the tabAlias to set      */     public void setTabAlias(TableAliasInfo tabAlias) {       this.tabAlias = tabAlias;     }      /**      * @return the column      */     public FieldSchema getColumn() {       return column;     }      /**      * @param column the column to set      */     public void setColumn(FieldSchema column) {       this.column = column;     }      @Override     public String toString() {       return tabAlias + &quot;:&quot; + column;     }      @Override     public int hashCode() {       return (column != null ? column.hashCode() : 7)         + (tabAlias != null ? tabAlias.hashCode() : 11);     }      @Override     public boolean equals(Object obj) {       if (this == obj) {         return true;       }       if (!(obj instanceof BaseColumnInfo)) {         return false;       }       BaseColumnInfo ci = (BaseColumnInfo) obj;       return (column == null ? ci.column == null : column.equals(ci.column))         &amp;&amp; (tabAlias == null ? ci.tabAlias == null : tabAlias.equals(ci.tabAlias));     }   }</td>
    <td align="left">data class</td>
    <td align="left">Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11903</td>
    <td align="left">https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/ql/src/java/org/apache/hadoop/hive/ql/hooks/LineageInfo.java/#L217-L288</td>
    <td align="right">1</td>
    <td align="right">1765</td>
    <td align="right">11903</td>
  </tr>
  <tr valign="top">
    <td align="right">2303</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES, I found bad smells&quot;,     &quot;bad smells are&quot;: [&quot;Data Class&quot;]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SchemaAndValue {     private final Schema schema;     private final Object value;      public static final SchemaAndValue NULL = new SchemaAndValue(null, null);      public SchemaAndValue(Schema schema, Object value) {         this.value = value;         this.schema = schema;     }      public Schema schema() {         return schema;     }      public Object value() {         return value;     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (o == null || getClass() != o.getClass()) return false;         SchemaAndValue that = (SchemaAndValue) o;         return Objects.equals(schema, that.schema) &amp;&amp;                 Objects.equals(value, that.value);     }      @Override     public int hashCode() {         return Objects.hash(schema, value);     }      @Override     public String toString() {         return &quot;SchemaAndValue{&quot; +                 &quot;schema=&quot; + schema +                 &quot;, value=&quot; + value +                 '}';     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14060</td>
    <td align="left">https://github.com/apache/kafka/blob/c74acb24eb1da5d16cc2721a63931cd87f79ec66/connect/api/src/main/java/org/apache/kafka/connect/data/SchemaAndValue.java/#L21-L61</td>
    <td align="right">1</td>
    <td align="right">2303</td>
    <td align="right">14060</td>
  </tr>
  <tr valign="top">
    <td align="right">514</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class FieldSchemaWrapper {     @JsonIgnore     private FieldSchema fieldSchema;     @JsonProperty     public String name;     @JsonProperty     public String type;     @JsonProperty     public String comment;      @JsonCreator     public FieldSchemaWrapper(@JsonProperty(&quot;name&quot;) String name, @JsonProperty(&quot;type&quot;) String type, @JsonProperty(&quot;comment&quot;) String comment) {       this.name = name;       this.type = type;       this.comment = comment;       this.fieldSchema = new FieldSchema(name, type, comment);     }      public FieldSchemaWrapper(FieldSchema fieldSchema) {       this.fieldSchema = fieldSchema;       this.name = fieldSchema.getName();       this.type = fieldSchema.getType();       this.comment = fieldSchema.getComment();     }      @JsonIgnore     public FieldSchema getFieldSchema() {       return fieldSchema;     }   }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5287</td>
    <td align="left">https://github.com/apache/drill/blob/5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3/contrib/storage-hive/core/src/main/java/org/apache/drill/exec/store/hive/HiveTableWrapper.java/#L367-L396</td>
    <td align="right">1</td>
    <td align="right">514</td>
    <td align="right">5287</td>
  </tr>
  <tr valign="top">
    <td align="right">2284</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad_smells&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class BindableSolrParameter {  	private final int index; 	private final Object value; 	private float boost;  	public BindableSolrParameter(int index, Object value) { 		super(); 		this.index = index; 		this.value = value; 	}  	public float getBoost() { 		return boost; 	}  	public void setBoost(float boost) { 		this.boost = boost; 	}  	public int getIndex() { 		return index; 	}  	public Object getValue() { 		return value; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13857</td>
    <td align="left">https://github.com/spring-projects/spring-data-solr/blob/6db215cf28337895ec40ed28082fa895846680bb/src/main/java/org/springframework/data/solr/repository/query/BindableSolrParameter.java/#L24-L52</td>
    <td align="right">1</td>
    <td align="right">2284</td>
    <td align="right">13857</td>
  </tr>
  <tr valign="top">
    <td align="right">2209</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;bad_smells&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  @InterfaceAudience.LimitedPrivate({&quot;MapReduce&quot;})   @InterfaceStability.Unstable   public static class Context {     private final MapTask mapTask;     private final JobConf jobConf;     private final TaskReporter reporter;      public Context(MapTask mapTask, JobConf jobConf, TaskReporter reporter) {       this.mapTask = mapTask;       this.jobConf = jobConf;       this.reporter = reporter;     }      public MapTask getMapTask() {       return mapTask;     }      public JobConf getJobConf() {       return jobConf;     }      public TaskReporter getReporter() {       return reporter;     }   }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13518</td>
    <td align="left">https://github.com/apache/hadoop-common/blob/42a61a4fbc88303913c4681f0d40ffcc737e70b5/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/MapOutputCollector.java/#L40-L64</td>
    <td align="right">1</td>
    <td align="right">2209</td>
    <td align="right">13518</td>
  </tr>
  <tr valign="top">
    <td align="right">2651</td>
    <td align="left">&nbsp;{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Data Class&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Shape {      private String type;      private Map members = Collections.emptyMap();      private String documentation;      private List required;      private List enumValues;      private String payload;      private boolean flattened;      private boolean exception;      private boolean streaming;      private boolean wrapper;      private Member listMember;      private Member mapKeyType;      private Member mapValueType;      @JsonProperty(value = &quot;error&quot;)     private ErrorTrait errorTrait;      private long min;      private long max;      private String pattern;      private boolean fault;      private boolean deprecated;      @JsonProperty(value = &quot;eventstream&quot;)     private boolean isEventStream;      @JsonProperty(value = &quot;event&quot;)     private boolean isEvent;      private String timestampFormat;      private boolean sensitive;      public boolean isFault() {         return fault;     }      public void setFault(boolean fault) {         this.fault = fault;     }      public String getPattern() {         return pattern;     }      public void setPattern(String pattern) {         this.pattern = pattern;     }      public String getType() {         return type;     }      public void setType(String type) {         this.type = type;     }      public Map getMembers() {         return members;     }      public void setMembers(Map members) {         this.members = members;     }      public String getDocumentation() {         return documentation;     }      public void setDocumentation(String documentation) {         this.documentation = documentation;     }      public List getRequired() {         return required;     }      public void setRequired(List required) {         this.required = required;     }      public List getEnumValues() {         return enumValues;     }      @JsonProperty(value = &quot;enum&quot;)     public void setEnumValues(List enumValues) {         this.enumValues = enumValues;     }      public String getPayload() {         return payload;     }      public void setPayload(String payload) {         this.payload = payload;     }      public boolean isFlattened() {         return flattened;     }      public void setFlattened(boolean flattened) {         this.flattened = flattened;     }      public boolean isException() {         return exception;     }      public void setException(boolean exception) {         this.exception = exception;     }      public Member getMapKeyType() {         return mapKeyType;     }      @JsonProperty(value = &quot;key&quot;)     public void setMapKeyType(Member mapKeyType) {         this.mapKeyType = mapKeyType;     }      public Member getMapValueType() {         return mapValueType;     }      @JsonProperty(value = &quot;value&quot;)     public void setMapValueType(Member mapValueType) {         this.mapValueType = mapValueType;     }      public Member getListMember() {         return listMember;     }      @JsonProperty(value = &quot;member&quot;)     public void setListMember(Member listMember) {         this.listMember = listMember;     }      public long getMin() {         return min;     }      public void setMin(long min) {         this.min = min;     }      public long getMax() {         return max;     }      public void setMax(long max) {         this.max = max;     }      public boolean isStreaming() {         return streaming;     }      public void setStreaming(boolean streaming) {         this.streaming = streaming;     }      public boolean isWrapper() {         return wrapper;     }      public void setWrapper(boolean wrapper) {         this.wrapper = wrapper;     }      public ErrorTrait getErrorTrait() {         return errorTrait;     }      public void setErrorTrait(ErrorTrait errorTrait) {         this.errorTrait = errorTrait;     }      public boolean isDeprecated() {         return deprecated;     }      public void setDeprecated(boolean deprecated) {         this.deprecated = deprecated;     }      public boolean isEventStream() {         return isEventStream;     }      public void setIsEventStream(boolean eventStream) {         isEventStream = eventStream;     }      public boolean isEvent() {         return isEvent;     }      public void setIsEvent(boolean event) {         isEvent = event;     }      public String getTimestampFormat() {         return timestampFormat;     }      public void setTimestampFormat(String timestampFormat) {         this.timestampFormat = timestampFormat;     }      public boolean isSensitive() {         return sensitive;     }      public void setSensitive(boolean sensitive) {         this.sensitive = sensitive;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15170</td>
    <td align="left">https://github.com/aws/aws-sdk-java-v2/blob/1d5d11e8087c93ab1a3a2d35193052e526fd123c/codegen/src/main/java/software/amazon/awssdk/codegen/model/service/Shape.java/#L23-L261</td>
    <td align="right">1</td>
    <td align="right">2651</td>
    <td align="right">15170</td>
  </tr>
  <tr valign="top">
    <td align="right">2077</td>
    <td align="left">{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     {       &quot;1. Long Method&quot;: &quot;SerializationRegistrationType&quot;,       &quot;2. Data Class&quot;: &quot;Serializer&quot;,       &quot;3. Data Class&quot;: &quot;Instantiator&quot;     }   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;serialization-registration-type&quot;,     namespace = &quot;http://geode.apache.org/schema/cache&quot;,     propOrder = {&quot;serializers&quot;, &quot;instantiators&quot;}) @Experimental public class SerializationRegistrationType {    @XmlElement(name = &quot;serializer&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)   protected List serializers;   @XmlElement(name = &quot;instantiator&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)   protected List instantiators;    /**    * Gets the value of the serializer property.    *    *     * This accessor method returns a reference to the live list,    * not a snapshot. Therefore any modification you make to the    * returned list will be present inside the JAXB object.    * This is why there is not a set method for the serializer property.    *    *     * For example, to add a new item, do as follows:    *    *     * getSerializer().add(newItem);    *     *    *    *     * Objects of the following type(s) are allowed in the list    * {@link SerializationRegistrationType.Serializer }    *    *    */   public List getSerializers() {     if (serializers == null) {       serializers = new ArrayList();     }     return this.serializers;   }    /**    * Gets the value of the instantiator property.    *    *     * This accessor method returns a reference to the live list,    * not a snapshot. Therefore any modification you make to the    * returned list will be present inside the JAXB object.    * This is why there is not a set method for the instantiator property.    *    *     * For example, to add a new item, do as follows:    *    *     * getInstantiator().add(newItem);    *     *    *    *     * Objects of the following type(s) are allowed in the list    * {@link SerializationRegistrationType.Instantiator }    *    *    */   public List getInstantiators() {     if (instantiators == null) {       instantiators = new ArrayList();     }     return this.instantiators;   }     /**    *     * Java class for anonymous complex type.    *    *     * The following schema fragment specifies the expected content contained within this class.    *    *     * &lt;complexType&gt;    *   &lt;complexContent&gt;    *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;    *       &lt;sequence&gt;    *         &lt;element name=&quot;class-name&quot; type=&quot;{http://geode.apache.org/schema/cache}class-name-type&quot;/&gt;    *       &lt;/sequence&gt;    *       &lt;attribute name=&quot;id&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;    *     &lt;/restriction&gt;    *   &lt;/complexContent&gt;    * &lt;/complexType&gt;    *     *    *    */   @XmlAccessorType(XmlAccessType.FIELD)   @XmlType(name = &quot;&quot;, propOrder = {&quot;className&quot;})   public static class Instantiator {      @XmlElement(name = &quot;class-name&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;,         required = true)     protected String className;     @XmlAttribute(name = &quot;id&quot;, required = true)     protected String id;      /**      * Gets the value of the className property.      *      * possible object is      * {@link String }      *      */     public String getClassName() {       return className;     }      /**      * Sets the value of the className property.      *      * allowed object is      * {@link String }      *      */     public void setClassName(String value) {       this.className = value;     }      /**      * Gets the value of the id property.      *      * possible object is      * {@link String }      *      */     public String getId() {       return id;     }      /**      * Sets the value of the id property.      *      * allowed object is      * {@link String }      *      */     public void setId(String value) {       this.id = value;     }    }     /**    *     * Java class for anonymous complex type.    *    *     * The following schema fragment specifies the expected content contained within this class.    *    *     * &lt;complexType&gt;    *   &lt;complexContent&gt;    *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;    *       &lt;sequence&gt;    *         &lt;element name=&quot;class-name&quot; type=&quot;{http://geode.apache.org/schema/cache}class-name-type&quot;/&gt;    *       &lt;/sequence&gt;    *     &lt;/restriction&gt;    *   &lt;/complexContent&gt;    * &lt;/complexType&gt;    *     *    *    */   @XmlAccessorType(XmlAccessType.FIELD)   @XmlType(name = &quot;&quot;, propOrder = {&quot;className&quot;})   public static class Serializer {      @XmlElement(name = &quot;class-name&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;,         required = true)     protected String className;      /**      * Gets the value of the className property.      *      * possible object is      * {@link String }      *      */     public String getClassName() {       return className;     }      /**      * Sets the value of the className property.      *      * allowed object is      * {@link String }      *      */     public void setClassName(String value) {       this.className = value;     }    }  }</td>
    <td align="left">data class</td>
    <td align="left">1. long method: serializationregistrationtype, 2. data class: serializer, 3. data class: instantiator</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. long method: serializationregistrationtype</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">13052</td>
    <td align="left">https://github.com/apache/geode/blob/8fd839e8b73e40bd2dfd14f331b587431bd35a66/geode-management/src/main/java/org/apache/geode/cache/configuration/SerializationRegistrationType.java/#L81-L286</td>
    <td align="right">1</td>
    <td align="right">2077</td>
    <td align="right">13052</td>
  </tr>
  <tr valign="top">
    <td align="right">4135</td>
    <td align="left">{   &quot;response&quot;: &quot;YES I found bad smells, the bad smells are: 1. Data Class&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DefaultResourceService implements ResourceService {  	private String servletPath = &quot;&quot;; 	 	/** 	 * @param servletPath the servletPath to set 	 */ 	public void setServletPath(String servletPath) { 		this.servletPath = servletPath; 	}  	public String getServletPath() { 		return servletPath; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">1. data class </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10881</td>
    <td align="left">https://github.com/spring-projects/spring-batch-admin/blob/9e3ad8bff99b8fad8da62426aa7d2959eb841bcf/spring-batch-admin-resources/src/main/java/org/springframework/batch/admin/web/resources/DefaultResourceService.java/#L23-L38</td>
    <td align="right">1</td>
    <td align="right">4135</td>
    <td align="right">10881</td>
  </tr>
  <tr valign="top">
    <td align="right">473</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells the bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  class TaskRemoval implements WorkerHistoryItem   {     private final String taskId;      @JsonCreator     public TaskRemoval(         @JsonProperty(&quot;taskId&quot;) String taskId     )     {       this.taskId = taskId;     }      @JsonProperty     public String getTaskId()     {       return taskId;     }      @Override     public String toString()     {       return &quot;TaskRemoval{&quot; +              &quot;taskId='&quot; + taskId + '\'' +              '}';     }   }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">&nbsp; </td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">4576</td>
    <td align="left">https://github.com/apache/incubator-druid/blob/8ca7cb4886dcaeeaaea3a06aceb9e6d50eeecab5/indexing-service/src/main/java/org/apache/druid/indexing/worker/WorkerHistoryItem.java/#L64-L89</td>
    <td align="right">1</td>
    <td align="right">473</td>
    <td align="right">4576</td>
  </tr>
  <tr valign="top">
    <td align="right">560</td>
    <td align="left">&nbsp;	{ 		&quot;message&quot;: &quot;YES, I found bad smells&quot;, 		&quot;bad smells are&quot;: [ 			&quot;1. Data Class&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class FakeErrorBoxWidget implements IErrorBox { 	/**  	 * Boolean to signify if a listener was registered. 	 */ 	private boolean observed; 	/**  	 * Boolean to store the display state. 	 */ 	private boolean displayed;  	/**  	 * The error message. 	 */ 	private String errorMsg = null;  	/**  	 * This operation returns true if the display operation is called for the FakeErrorBoxWidget. 	 * @return True if the widget was displayed, false if not. 	 */ 	public boolean widgetDisplayed() { 		return this.displayed; 	}  	/**  	 * This operation implements display() from UIWidget with a simple pass through that makes whether or not the method was called. Nothing is drawn on the screen. 	 */ 	@Override 	public void display() {  		this.displayed = true;  		return;  	}  	/**  	 * (non-Javadoc) 	 * @see IErrorBox#setErrorString(String error) 	 */ 	@Override 	public void setErrorString(String error) {  		// Set the error message 		errorMsg = error;  		return;  	}  	/**  	 * (non-Javadoc) 	 * @see IErrorBox#getErrorString() 	 */ 	@Override 	public String getErrorString() {  		// Return the error message 		return errorMsg;  	}  }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">&nbsp; </td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">5653</td>
    <td align="left">https://github.com/eclipse/ice/blob/3f6e0265f5b476ff90a660397ce83992944142c4/org.eclipse.ice.tests.client/src/org/eclipse/ice/tests/client/FakeErrorBoxWidget.java/#L21-L82</td>
    <td align="right">1</td>
    <td align="right">560</td>
    <td align="right">5653</td>
  </tr>
  <tr valign="top">
    <td align="right">2137</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class CreditBureauData {  	private final long creditBureauId;  	private final String creditBureauName;  	private final String country;  	private final String productName;  	private final String creditBureauSummary;  	private final long implementationKey;  	private CreditBureauData(final long creditBureauId, final String creditBureauName, final String country, 			final String productName, final String creditBureauSummary, final long implementationKey) { 		this.creditBureauId = creditBureauId; 		this.creditBureauName = creditBureauName; 		this.country = country; 		this.productName = productName; 		this.creditBureauSummary = creditBureauSummary; 		this.implementationKey = implementationKey;  	}  	public static CreditBureauData instance(final long creditBureauId, final String creditBureauName, 			final String country, final String productName, final String creditBureauSummary, final long implementationKey) {  		return new CreditBureauData(creditBureauId, creditBureauName, country, productName, creditBureauSummary, 				implementationKey); 	}  	public String getCreditBureauSummary() { 		return this.creditBureauSummary; 	}  	public long getCreditBureauId() { 		return this.creditBureauId; 	}  	public String getCreditBureauName() { 		return this.creditBureauName; 	}  	public String getCountry() { 		return this.country; 	}  	public String getProductName() { 		return this.productName; 	}  	public long getImplementationKey() { 		return this.implementationKey; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13258</td>
    <td align="left">https://github.com/apache/fineract/blob/210e380df3ca5c74c8c2fa09e7fe1cffdb87e20a/fineract-provider/src/main/java/org/apache/fineract/infrastructure/creditbureau/data/CreditBureauData.java/#L21-L77</td>
    <td align="right">1</td>
    <td align="right">2137</td>
    <td align="right">13258</td>
  </tr>
  <tr valign="top">
    <td align="right">4604</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Blob&quot;,             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement(name = &quot;pagedResult&quot;) @XmlType public class PagedResult implements Serializable {      private static final long serialVersionUID = 3472875885259250934L;      private URI prev;      private URI next;      private final List result = new ArrayList&lt;&gt;();      private int page;      private int size;      private int totalCount;      public URI getPrev() {         return prev;     }      public void setPrev(final URI prev) {         this.prev = prev;     }      public URI getNext() {         return next;     }      public void setNext(final URI next) {         this.next = next;     }      @XmlElementWrapper(name = &quot;result&quot;)     @XmlElement(name = &quot;item&quot;)     @JsonProperty(&quot;result&quot;)     @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = &quot;@class&quot;)     public List getResult() {         return result;     }      public int getPage() {         return page;     }      public void setPage(final int page) {         this.page = page;     }      public int getSize() {         return size;     }      public void setSize(final int size) {         this.size = size;     }      public int getTotalCount() {         return totalCount;     }      public void setTotalCount(final int totalCount) {         this.totalCount = totalCount;     }      @Override     public int hashCode() {         return new HashCodeBuilder().                 append(prev).                 append(next).                 append(result).                 append(page).                 append(size).                 append(totalCount).                 build();     }      @Override     public boolean equals(final Object obj) {         if (this == obj) {             return true;         }         if (obj == null) {             return false;         }         if (getClass() != obj.getClass()) {             return false;         }         @SuppressWarnings(&quot;unchecked&quot;)         final PagedResult other = (PagedResult) obj;         return new EqualsBuilder().                 append(prev, other.prev).                 append(next, other.next).                 append(result, other.result).                 append(page, other.page).                 append(size, other.size).                 append(totalCount, other.totalCount).                 build();     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12251</td>
    <td align="left">https://github.com/apache/syncope/blob/114c412afbfba24ffb4fbc804e5308a823a16a78/common/idrepo/lib/src/main/java/org/apache/syncope/common/lib/to/PagedResult.java/#L35-L135</td>
    <td align="right">1</td>
    <td align="right">4604</td>
    <td align="right">12251</td>
  </tr>
  <tr valign="top">
    <td align="right">102</td>
    <td align="left">{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;the bad smells are&quot;: [     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class APIRequestGet extends APIRequest {      AdCampaignActivity lastResponse = null;     @Override     public AdCampaignActivity getLastResponse() {       return lastResponse;     }     public static final String[] PARAMS = {     };      public static final String[] FIELDS = {       &quot;auto_create_lookalike_new&quot;,       &quot;auto_create_lookalike_old&quot;,       &quot;bid_adjustments_spec_new&quot;,       &quot;bid_adjustments_spec_old&quot;,       &quot;bid_amount_new&quot;,       &quot;bid_amount_old&quot;,       &quot;bid_constraints_new&quot;,       &quot;bid_constraints_old&quot;,       &quot;bid_info_new&quot;,       &quot;bid_info_old&quot;,       &quot;bid_strategy_new&quot;,       &quot;bid_strategy_old&quot;,       &quot;bid_type_new&quot;,       &quot;bid_type_old&quot;,       &quot;billing_event_new&quot;,       &quot;billing_event_old&quot;,       &quot;brande_audience_id_new&quot;,       &quot;brande_audience_id_old&quot;,       &quot;budget_limit_new&quot;,       &quot;budget_limit_old&quot;,       &quot;created_time&quot;,       &quot;daily_impressions_new&quot;,       &quot;daily_impressions_old&quot;,       &quot;dco_mode_new&quot;,       &quot;dco_mode_old&quot;,       &quot;delivery_behavior_new&quot;,       &quot;delivery_behavior_old&quot;,       &quot;destination_type_new&quot;,       &quot;destination_type_old&quot;,       &quot;event_time&quot;,       &quot;event_type&quot;,       &quot;id&quot;,       &quot;invoicing_limit_new&quot;,       &quot;invoicing_limit_old&quot;,       &quot;min_spend_target_new&quot;,       &quot;min_spend_target_old&quot;,       &quot;name_new&quot;,       &quot;name_old&quot;,       &quot;optimization_goal_new&quot;,       &quot;optimization_goal_old&quot;,       &quot;pacing_type_new&quot;,       &quot;pacing_type_old&quot;,       &quot;run_status_new&quot;,       &quot;run_status_old&quot;,       &quot;schedule_new&quot;,       &quot;schedule_old&quot;,       &quot;spend_cap_new&quot;,       &quot;spend_cap_old&quot;,       &quot;start_time_new&quot;,       &quot;start_time_old&quot;,       &quot;stop_time_new&quot;,       &quot;stop_time_old&quot;,       &quot;targeting_expansion_new&quot;,       &quot;targeting_expansion_old&quot;,       &quot;updated_time_new&quot;,       &quot;updated_time_old&quot;,     };      @Override     public AdCampaignActivity parseResponse(String response, String header) throws APIException {       return AdCampaignActivity.parseResponse(response, getContext(), this, header).head();     }      @Override     public AdCampaignActivity execute() throws APIException {       return execute(new HashMap());     }      @Override     public AdCampaignActivity execute(Map extraParams) throws APIException {       ResponseWrapper rw = executeInternal(extraParams);       lastResponse = parseResponse(rw.getBody(), rw.getHeader());       return lastResponse;     }      public ListenableFuture executeAsync() throws APIException {       return executeAsync(new HashMap());     };      public ListenableFuture executeAsync(Map extraParams) throws APIException {       return Futures.transform(         executeAsyncInternal(extraParams),         new Function() {            public AdCampaignActivity apply(ResponseWrapper result) {              try {                return APIRequestGet.this.parseResponse(result.getBody(), result.getHeader());              } catch (Exception e) {                throw new RuntimeException(e);              }            }          }       );     };      public APIRequestGet(String nodeId, APIContext context) {       super(context, nodeId, &quot;/&quot;, &quot;GET&quot;, Arrays.asList(PARAMS));     }      @Override     public APIRequestGet setParam(String param, Object value) {       setParamInternal(param, value);       return this;     }      @Override     public APIRequestGet setParams(Map params) {       setParamsInternal(params);       return this;     }       public APIRequestGet requestAllFields () {       return this.requestAllFields(true);     }      public APIRequestGet requestAllFields (boolean value) {       for (String field : FIELDS) {         this.requestField(field, value);       }       return this;     }      @Override     public APIRequestGet requestFields (List fields) {       return this.requestFields(fields, true);     }      @Override     public APIRequestGet requestFields (List fields, boolean value) {       for (String field : fields) {         this.requestField(field, value);       }       return this;     }      @Override     public APIRequestGet requestField (String field) {       this.requestField(field, true);       return this;     }      @Override     public APIRequestGet requestField (String field, boolean value) {       this.requestFieldInternal(field, value);       return this;     }      public APIRequestGet requestAutoCreateLookalikeNewField () {       return this.requestAutoCreateLookalikeNewField(true);     }     public APIRequestGet requestAutoCreateLookalikeNewField (boolean value) {       this.requestField(&quot;auto_create_lookalike_new&quot;, value);       return this;     }     public APIRequestGet requestAutoCreateLookalikeOldField () {       return this.requestAutoCreateLookalikeOldField(true);     }     public APIRequestGet requestAutoCreateLookalikeOldField (boolean value) {       this.requestField(&quot;auto_create_lookalike_old&quot;, value);       return this;     }     public APIRequestGet requestBidAdjustmentsSpecNewField () {       return this.requestBidAdjustmentsSpecNewField(true);     }     public APIRequestGet requestBidAdjustmentsSpecNewField (boolean value) {       this.requestField(&quot;bid_adjustments_spec_new&quot;, value);       return this;     }     public APIRequestGet requestBidAdjustmentsSpecOldField () {       return this.requestBidAdjustmentsSpecOldField(true);     }     public APIRequestGet requestBidAdjustmentsSpecOldField (boolean value) {       this.requestField(&quot;bid_adjustments_spec_old&quot;, value);       return this;     }     public APIRequestGet requestBidAmountNewField () {       return this.requestBidAmountNewField(true);     }     public APIRequestGet requestBidAmountNewField (boolean value) {       this.requestField(&quot;bid_amount_new&quot;, value);       return this;     }     public APIRequestGet requestBidAmountOldField () {       return this.requestBidAmountOldField(true);     }     public APIRequestGet requestBidAmountOldField (boolean value) {       this.requestField(&quot;bid_amount_old&quot;, value);       return this;     }     public APIRequestGet requestBidConstraintsNewField () {       return this.requestBidConstraintsNewField(true);     }     public APIRequestGet requestBidConstraintsNewField (boolean value) {       this.requestField(&quot;bid_constraints_new&quot;, value);       return this;     }     public APIRequestGet requestBidConstraintsOldField () {       return this.requestBidConstraintsOldField(true);     }     public APIRequestGet requestBidConstraintsOldField (boolean value) {       this.requestField(&quot;bid_constraints_old&quot;, value);       return this;     }     public APIRequestGet requestBidInfoNewField () {       return this.requestBidInfoNewField(true);     }     public APIRequestGet requestBidInfoNewField (boolean value) {       this.requestField(&quot;bid_info_new&quot;, value);       return this;     }     public APIRequestGet requestBidInfoOldField () {       return this.requestBidInfoOldField(true);     }     public APIRequestGet requestBidInfoOldField (boolean value) {       this.requestField(&quot;bid_info_old&quot;, value);       return this;     }     public APIRequestGet requestBidStrategyNewField () {       return this.requestBidStrategyNewField(true);     }     public APIRequestGet requestBidStrategyNewField (boolean value) {       this.requestField(&quot;bid_strategy_new&quot;, value);       return this;     }     public APIRequestGet requestBidStrategyOldField () {       return this.requestBidStrategyOldField(true);     }     public APIRequestGet requestBidStrategyOldField (boolean value) {       this.requestField(&quot;bid_strategy_old&quot;, value);       return this;     }     public APIRequestGet requestBidTypeNewField () {       return this.requestBidTypeNewField(true);     }     public APIRequestGet requestBidTypeNewField (boolean value) {       this.requestField(&quot;bid_type_new&quot;, value);       return this;     }     public APIRequestGet requestBidTypeOldField () {       return this.requestBidTypeOldField(true);     }     public APIRequestGet requestBidTypeOldField (boolean value) {       this.requestField(&quot;bid_type_old&quot;, value);       return this;     }     public APIRequestGet requestBillingEventNewField () {       return this.requestBillingEventNewField(true);     }     public APIRequestGet requestBillingEventNewField (boolean value) {       this.requestField(&quot;billing_event_new&quot;, value);       return this;     }     public APIRequestGet requestBillingEventOldField () {       return this.requestBillingEventOldField(true);     }     public APIRequestGet requestBillingEventOldField (boolean value) {       this.requestField(&quot;billing_event_old&quot;, value);       return this;     }     public APIRequestGet requestBrandeAudienceIdNewField () {       return this.requestBrandeAudienceIdNewField(true);     }     public APIRequestGet requestBrandeAudienceIdNewField (boolean value) {       this.requestField(&quot;brande_audience_id_new&quot;, value);       return this;     }     public APIRequestGet requestBrandeAudienceIdOldField () {       return this.requestBrandeAudienceIdOldField(true);     }     public APIRequestGet requestBrandeAudienceIdOldField (boolean value) {       this.requestField(&quot;brande_audience_id_old&quot;, value);       return this;     }     public APIRequestGet requestBudgetLimitNewField () {       return this.requestBudgetLimitNewField(true);     }     public APIRequestGet requestBudgetLimitNewField (boolean value) {       this.requestField(&quot;budget_limit_new&quot;, value);       return this;     }     public APIRequestGet requestBudgetLimitOldField () {       return this.requestBudgetLimitOldField(true);     }     public APIRequestGet requestBudgetLimitOldField (boolean value) {       this.requestField(&quot;budget_limit_old&quot;, value);       return this;     }     public APIRequestGet requestCreatedTimeField () {       return this.requestCreatedTimeField(true);     }     public APIRequestGet requestCreatedTimeField (boolean value) {       this.requestField(&quot;created_time&quot;, value);       return this;     }     public APIRequestGet requestDailyImpressionsNewField () {       return this.requestDailyImpressionsNewField(true);     }     public APIRequestGet requestDailyImpressionsNewField (boolean value) {       this.requestField(&quot;daily_impressions_new&quot;, value);       return this;     }     public APIRequestGet requestDailyImpressionsOldField () {       return this.requestDailyImpressionsOldField(true);     }     public APIRequestGet requestDailyImpressionsOldField (boolean value) {       this.requestField(&quot;daily_impressions_old&quot;, value);       return this;     }     public APIRequestGet requestDcoModeNewField () {       return this.requestDcoModeNewField(true);     }     public APIRequestGet requestDcoModeNewField (boolean value) {       this.requestField(&quot;dco_mode_new&quot;, value);       return this;     }     public APIRequestGet requestDcoModeOldField () {       return this.requestDcoModeOldField(true);     }     public APIRequestGet requestDcoModeOldField (boolean value) {       this.requestField(&quot;dco_mode_old&quot;, value);       return this;     }     public APIRequestGet requestDeliveryBehaviorNewField () {       return this.requestDeliveryBehaviorNewField(true);     }     public APIRequestGet requestDeliveryBehaviorNewField (boolean value) {       this.requestField(&quot;delivery_behavior_new&quot;, value);       return this;     }     public APIRequestGet requestDeliveryBehaviorOldField () {       return this.requestDeliveryBehaviorOldField(true);     }     public APIRequestGet requestDeliveryBehaviorOldField (boolean value) {       this.requestField(&quot;delivery_behavior_old&quot;, value);       return this;     }     public APIRequestGet requestDestinationTypeNewField () {       return this.requestDestinationTypeNewField(true);     }     public APIRequestGet requestDestinationTypeNewField (boolean value) {       this.requestField(&quot;destination_type_new&quot;, value);       return this;     }     public APIRequestGet requestDestinationTypeOldField () {       return this.requestDestinationTypeOldField(true);     }     public APIRequestGet requestDestinationTypeOldField (boolean value) {       this.requestField(&quot;destination_type_old&quot;, value);       return this;     }     public APIRequestGet requestEventTimeField () {       return this.requestEventTimeField(true);     }     public APIRequestGet requestEventTimeField (boolean value) {       this.requestField(&quot;event_time&quot;, value);       return this;     }     public APIRequestGet requestEventTypeField () {       return this.requestEventTypeField(true);     }     public APIRequestGet requestEventTypeField (boolean value) {       this.requestField(&quot;event_type&quot;, value);       return this;     }     public APIRequestGet requestIdField () {       return this.requestIdField(true);     }     public APIRequestGet requestIdField (boolean value) {       this.requestField(&quot;id&quot;, value);       return this;     }     public APIRequestGet requestInvoicingLimitNewField () {       return this.requestInvoicingLimitNewField(true);     }     public APIRequestGet requestInvoicingLimitNewField (boolean value) {       this.requestField(&quot;invoicing_limit_new&quot;, value);       return this;     }     public APIRequestGet requestInvoicingLimitOldField () {       return this.requestInvoicingLimitOldField(true);     }     public APIRequestGet requestInvoicingLimitOldField (boolean value) {       this.requestField(&quot;invoicing_limit_old&quot;, value);       return this;     }     public APIRequestGet requestMinSpendTargetNewField () {       return this.requestMinSpendTargetNewField(true);     }     public APIRequestGet requestMinSpendTargetNewField (boolean value) {       this.requestField(&quot;min_spend_target_new&quot;, value);       return this;     }     public APIRequestGet requestMinSpendTargetOldField () {       return this.requestMinSpendTargetOldField(true);     }     public APIRequestGet requestMinSpendTargetOldField (boolean value) {       this.requestField(&quot;min_spend_target_old&quot;, value);       return this;     }     public APIRequestGet requestNameNewField () {       return this.requestNameNewField(true);     }     public APIRequestGet requestNameNewField (boolean value) {       this.requestField(&quot;name_new&quot;, value);       return this;     }     public APIRequestGet requestNameOldField () {       return this.requestNameOldField(true);     }     public APIRequestGet requestNameOldField (boolean value) {       this.requestField(&quot;name_old&quot;, value);       return this;     }     public APIRequestGet requestOptimizationGoalNewField () {       return this.requestOptimizationGoalNewField(true);     }     public APIRequestGet requestOptimizationGoalNewField (boolean value) {       this.requestField(&quot;optimization_goal_new&quot;, value);       return this;     }     public APIRequestGet requestOptimizationGoalOldField () {       return this.requestOptimizationGoalOldField(true);     }     public APIRequestGet requestOptimizationGoalOldField (boolean value) {       this.requestField(&quot;optimization_goal_old&quot;, value);       return this;     }     public APIRequestGet requestPacingTypeNewField () {       return this.requestPacingTypeNewField(true);     }     public APIRequestGet requestPacingTypeNewField (boolean value) {       this.requestField(&quot;pacing_type_new&quot;, value);       return this;     }     public APIRequestGet requestPacingTypeOldField () {       return this.requestPacingTypeOldField(true);     }     public APIRequestGet requestPacingTypeOldField (boolean value) {       this.requestField(&quot;pacing_type_old&quot;, value);       return this;     }     public APIRequestGet requestRunStatusNewField () {       return this.requestRunStatusNewField(true);     }     public APIRequestGet requestRunStatusNewField (boolean value) {       this.requestField(&quot;run_status_new&quot;, value);       return this;     }     public APIRequestGet requestRunStatusOldField () {       return this.requestRunStatusOldField(true);     }     public APIRequestGet requestRunStatusOldField (boolean value) {       this.requestField(&quot;run_status_old&quot;, value);       return this;     }     public APIRequestGet requestScheduleNewField () {       return this.requestScheduleNewField(true);     }     public APIRequestGet requestScheduleNewField (boolean value) {       this.requestField(&quot;schedule_new&quot;, value);       return this;     }     public APIRequestGet requestScheduleOldField () {       return this.requestScheduleOldField(true);     }     public APIRequestGet requestScheduleOldField (boolean value) {       this.requestField(&quot;schedule_old&quot;, value);       return this;     }     public APIRequestGet requestSpendCapNewField () {       return this.requestSpendCapNewField(true);     }     public APIRequestGet requestSpendCapNewField (boolean value) {       this.requestField(&quot;spend_cap_new&quot;, value);       return this;     }     public APIRequestGet requestSpendCapOldField () {       return this.requestSpendCapOldField(true);     }     public APIRequestGet requestSpendCapOldField (boolean value) {       this.requestField(&quot;spend_cap_old&quot;, value);       return this;     }     public APIRequestGet requestStartTimeNewField () {       return this.requestStartTimeNewField(true);     }     public APIRequestGet requestStartTimeNewField (boolean value) {       this.requestField(&quot;start_time_new&quot;, value);       return this;     }     public APIRequestGet requestStartTimeOldField () {       return this.requestStartTimeOldField(true);     }     public APIRequestGet requestStartTimeOldField (boolean value) {       this.requestField(&quot;start_time_old&quot;, value);       return this;     }     public APIRequestGet requestStopTimeNewField () {       return this.requestStopTimeNewField(true);     }     public APIRequestGet requestStopTimeNewField (boolean value) {       this.requestField(&quot;stop_time_new&quot;, value);       return this;     }     public APIRequestGet requestStopTimeOldField () {       return this.requestStopTimeOldField(true);     }     public APIRequestGet requestStopTimeOldField (boolean value) {       this.requestField(&quot;stop_time_old&quot;, value);       return this;     }     public APIRequestGet requestTargetingExpansionNewField () {       return this.requestTargetingExpansionNewField(true);     }     public APIRequestGet requestTargetingExpansionNewField (boolean value) {       this.requestField(&quot;targeting_expansion_new&quot;, value);       return this;     }     public APIRequestGet requestTargetingExpansionOldField () {       return this.requestTargetingExpansionOldField(true);     }     public APIRequestGet requestTargetingExpansionOldField (boolean value) {       this.requestField(&quot;targeting_expansion_old&quot;, value);       return this;     }     public APIRequestGet requestUpdatedTimeNewField () {       return this.requestUpdatedTimeNewField(true);     }     public APIRequestGet requestUpdatedTimeNewField (boolean value) {       this.requestField(&quot;updated_time_new&quot;, value);       return this;     }     public APIRequestGet requestUpdatedTimeOldField () {       return this.requestUpdatedTimeOldField(true);     }     public APIRequestGet requestUpdatedTimeOldField (boolean value) {       this.requestField(&quot;updated_time_old&quot;, value);       return this;     }   }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1315</td>
    <td align="left">https://github.com/facebook/facebook-java-business-sdk/blob/561f1a75e1220b55a160a1b92b0187f72be9cd08/src/main/java/com/facebook/ads/sdk/AdCampaignActivity.java/#L610-L1160</td>
    <td align="right">1</td>
    <td align="right">102</td>
    <td align="right">1315</td>
  </tr>
  <tr valign="top">
    <td align="right">3875</td>
    <td align="left">&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;1. Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class BuildProperties extends AbstractProperties {      public BuildProperties(PropertiesAccessor accessor) {         super(accessor);     }      public Map getAllProps() {         return accessor.getBuildProperties();     }  }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10123</td>
    <td align="left">https://github.com/apache/asterixdb/blob/223d13a06c4a4a58408aeac19674ac1f36f5ff35/asterixdb/asterix-common/src/main/java/org/apache/asterix/common/config/BuildProperties.java/#L24-L34</td>
    <td align="right">1</td>
    <td align="right">3875</td>
    <td align="right">10123</td>
  </tr>
  <tr valign="top">
    <td align="right">850</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement(name=&quot;mqtt&quot;) @XmlAccessorType(XmlAccessType.FIELD) public class MqttDTO extends ProtocolDTO {      @XmlAttribute(name=&quot;max_message_length&quot;)     public Integer max_message_length;      @XmlElementRef     public List protocol_filters = new ArrayList();      @XmlAttribute(name=&quot;queue_prefix&quot;)     public String queue_prefix;      @XmlAttribute(name=&quot;path_separator&quot;)     public String path_separator;      @XmlAttribute(name=&quot;any_child_wildcard&quot;)     public String any_child_wildcard;      @XmlAttribute(name=&quot;any_descendant_wildcard&quot;)     public String any_descendant_wildcard;      @XmlAttribute(name=&quot;regex_wildcard_start&quot;)     public String regex_wildcard_start;      @XmlAttribute(name=&quot;regex_wildcard_end&quot;)     public String regex_wildcard_end;      @XmlAttribute(name=&quot;part_pattern&quot;)     public String part_pattern;      @XmlAttribute(name=&quot;die_delay&quot;)     public Long die_delay;      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (o == null || getClass() != o.getClass()) return false;         if (!super.equals(o)) return false;          MqttDTO mqttDTO = (MqttDTO) o;          if (any_child_wildcard != null ? !any_child_wildcard.equals(mqttDTO.any_child_wildcard) : mqttDTO.any_child_wildcard != null)             return false;         if (any_descendant_wildcard != null ? !any_descendant_wildcard.equals(mqttDTO.any_descendant_wildcard) : mqttDTO.any_descendant_wildcard != null)             return false;         if (max_message_length != null ? !max_message_length.equals(mqttDTO.max_message_length) : mqttDTO.max_message_length != null)             return false;         if (path_separator != null ? !path_separator.equals(mqttDTO.path_separator) : mqttDTO.path_separator != null)             return false;         if (protocol_filters != null ? !protocol_filters.equals(mqttDTO.protocol_filters) : mqttDTO.protocol_filters != null)             return false;         if (queue_prefix != null ? !queue_prefix.equals(mqttDTO.queue_prefix) : mqttDTO.queue_prefix != null)             return false;         if (regex_wildcard_end != null ? !regex_wildcard_end.equals(mqttDTO.regex_wildcard_end) : mqttDTO.regex_wildcard_end != null)             return false;         if (regex_wildcard_start != null ? !regex_wildcard_start.equals(mqttDTO.regex_wildcard_start) : mqttDTO.regex_wildcard_start != null)             return false;         if (part_pattern != null ? !part_pattern.equals(mqttDTO.part_pattern) : mqttDTO.part_pattern != null)             return false;          return true;     }      @Override     public int hashCode() {         int result = super.hashCode();         result = 31 * result + (max_message_length != null ? max_message_length.hashCode() : 0);         result = 31 * result + (protocol_filters != null ? protocol_filters.hashCode() : 0);         result = 31 * result + (queue_prefix != null ? queue_prefix.hashCode() : 0);         result = 31 * result + (part_pattern != null ? part_pattern.hashCode() : 0);         result = 31 * result + (path_separator != null ? path_separator.hashCode() : 0);         result = 31 * result + (any_child_wildcard != null ? any_child_wildcard.hashCode() : 0);         result = 31 * result + (any_descendant_wildcard != null ? any_descendant_wildcard.hashCode() : 0);         result = 31 * result + (regex_wildcard_start != null ? regex_wildcard_start.hashCode() : 0);         result = 31 * result + (regex_wildcard_end != null ? regex_wildcard_end.hashCode() : 0);         return result;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7851</td>
    <td align="left">https://github.com/apache/activemq-apollo/blob/8e4b134b2a5d3576aa62cd8df9905a9fe2eba2d0/apollo-mqtt/src/main/java/org/apache/activemq/apollo/mqtt/dto/MqttDTO.java/#L31-L109</td>
    <td align="right">1</td>
    <td align="right">850</td>
    <td align="right">7851</td>
  </tr>
  <tr valign="top">
    <td align="right">3960</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Long Method&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private class ClientSelectDeleteMutationPlan implements MutationPlan {         private final StatementContext context;         private final TableRef targetTableRef;         private final QueryPlan dataPlan;         private final QueryPlan bestPlan;         private final boolean hasPreOrPostProcessing;         private final DeletingParallelIteratorFactory parallelIteratorFactory;         private final List otherTableRefs;         private final TableRef projectedTableRef;         private final int maxSize;         private final int maxSizeBytes;         private final PhoenixConnection connection;          public ClientSelectDeleteMutationPlan(TableRef targetTableRef, QueryPlan dataPlan, QueryPlan bestPlan,                                               boolean hasPreOrPostProcessing,                                               DeletingParallelIteratorFactory parallelIteratorFactory,                                               List otherTableRefs, TableRef projectedTableRef, int maxSize,                                               int maxSizeBytes, PhoenixConnection connection) {             this.context = bestPlan.getContext();             this.targetTableRef = targetTableRef;             this.dataPlan = dataPlan;             this.bestPlan = bestPlan;             this.hasPreOrPostProcessing = hasPreOrPostProcessing;             this.parallelIteratorFactory = parallelIteratorFactory;             this.otherTableRefs = otherTableRefs;             this.projectedTableRef = projectedTableRef;             this.maxSize = maxSize;             this.maxSizeBytes = maxSizeBytes;             this.connection = connection;         }          @Override         public ParameterMetaData getParameterMetaData() {             return context.getBindManager().getParameterMetaData();         }          @Override         public StatementContext getContext() {             return context;         }          @Override         public TableRef getTargetRef() {             return targetTableRef;         }          @Override         public Set getSourceRefs() {             return dataPlan.getSourceRefs();         }          @Override         public Operation getOperation() {           return operation;         }          @Override         public MutationState execute() throws SQLException {             ResultIterator iterator = bestPlan.iterator();             try {                 // If we're not doing any pre or post processing, we can produce the delete mutations directly                 // in the parallel threads executed for the scan                 if (!hasPreOrPostProcessing) {                     Tuple tuple;                     long totalRowCount = 0;                     if (parallelIteratorFactory != null) {                         parallelIteratorFactory.setQueryPlan(bestPlan);                         parallelIteratorFactory.setOtherTableRefs(otherTableRefs);                         parallelIteratorFactory.setProjectedTableRef(projectedTableRef);                     }                     while ((tuple=iterator.next()) != null) {// Runs query                         Cell kv = tuple.getValue(0);                         totalRowCount += PLong.INSTANCE.getCodec().decodeLong(kv.getValueArray(), kv.getValueOffset(), SortOrder.getDefault());                     }                     // Return total number of rows that have been deleted from the table. In the case of auto commit being off                     // the mutations will all be in the mutation state of the current connection. We need to divide by the                     // total number of tables we updated as otherwise the client will get an inflated result.                     int totalTablesUpdateClientSide = 1; // data table is always updated                     PTable bestTable = bestPlan.getTableRef().getTable();                     // global immutable tables are also updated client side (but don't double count the data table)                     if (bestPlan != dataPlan &amp;&amp; isMaintainedOnClient(bestTable)) {                         totalTablesUpdateClientSide++;                     }                     for (TableRef otherTableRef : otherTableRefs) {                         PTable otherTable = otherTableRef.getTable();                         // Don't double count the data table here (which morphs when it becomes a projected table, hence this check)                         if (projectedTableRef != otherTableRef &amp;&amp; isMaintainedOnClient(otherTable)) {                             totalTablesUpdateClientSide++;                         }                     }                     MutationState state = new MutationState(maxSize, maxSizeBytes, connection, totalRowCount/totalTablesUpdateClientSide);                      // set the read metrics accumulated in the parent context so that it can be published when the mutations are committed.                     state.setReadMetricQueue(context.getReadMetricsQueue());                      return state;                 } else {                     // Otherwise, we have to execute the query and produce the delete mutations in the single thread                     // producing the query results.                     return deleteRows(context, iterator, bestPlan, projectedTableRef, otherTableRefs);                 }             } finally {                 iterator.close();             }         }          @Override         public ExplainPlan getExplainPlan() throws SQLException {             List queryPlanSteps =  bestPlan.getExplainPlan().getPlanSteps();             List planSteps = Lists.newArrayListWithExpectedSize(queryPlanSteps.size()+1);             planSteps.add(&quot;DELETE ROWS&quot;);             planSteps.addAll(queryPlanSteps);             return new ExplainPlan(planSteps);         }          @Override         public Long getEstimatedRowsToScan() throws SQLException {             return bestPlan.getEstimatedRowsToScan();         }          @Override         public Long getEstimatedBytesToScan() throws SQLException {             return bestPlan.getEstimatedBytesToScan();         }          @Override         public Long getEstimateInfoTimestamp() throws SQLException {             return bestPlan.getEstimateInfoTimestamp();         }          @Override         public QueryPlan getQueryPlan() {             return bestPlan;         }     }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10368</td>
    <td align="left">https://github.com/apache/phoenix/blob/69e5bb0b304a53967cef40b2a4cfc66e69ecaa51/phoenix-core/src/main/java/org/apache/phoenix/compile/DeleteCompiler.java/#L844-L978</td>
    <td align="right">1</td>
    <td align="right">3960</td>
    <td align="right">10368</td>
  </tr>
  <tr valign="top">
    <td align="right">308</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class RewriteLoadBalancerClient implements LoadBalancerClient {   private static final Logger      _log = LoggerFactory.getLogger(TrackerClient.class);    private final String          _serviceName;   private final URI             _uri;   private final RewriteClient _client;    public RewriteLoadBalancerClient(String serviceName, URI uri, TransportClient client)   {     _serviceName = serviceName;     _uri = uri;     _client = new RewriteClient(client, new D2URIRewriter(uri));     debug(_log, &quot;created rewrite client: &quot;, this);   }    @Override   public void restRequest(RestRequest request,                    RequestContext requestContext,                    Map wireAttrs,                    TransportCallback callback)   {     assert _serviceName.equals(LoadBalancerUtil.getServiceNameFromUri(request.getURI()));     _client.restRequest(request, requestContext, wireAttrs, callback);   }    @Override   public void streamRequest(StreamRequest request,                           RequestContext requestContext,                           Map wireAttrs,                           TransportCallback callback)   {     assert _serviceName.equals(LoadBalancerUtil.getServiceNameFromUri(request.getURI()));     _client.streamRequest(request, requestContext, wireAttrs, callback);   }    @Override   public void shutdown(Callback callback)   {     _client.shutdown(callback);   }    @Deprecated   public TransportClient getWrappedClient()   {     return _client;   }    public TransportClient getDecoratedClient()   {     return _client;   }    @Override   public URI getUri()   {     return _uri;   }    public String getServiceName()   {     return _serviceName;   }    @Override   public String toString()   {     return &quot;RewriteLoadBalancerClient [_serviceName=&quot; + _serviceName + &quot;, _uri=&quot; + _uri         + &quot;, _wrappedClient=&quot; + _client + &quot;]&quot;;   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3201</td>
    <td align="left">https://github.com/linkedin/rest.li/blob/ad74aa98da8a55ad9c339d0769a3e8fb495765af/d2/src/main/java/com/linkedin/d2/balancer/clients/RewriteLoadBalancerClient.java/#L41-L111</td>
    <td align="right">1</td>
    <td align="right">308</td>
    <td align="right">3201</td>
  </tr>
  <tr valign="top">
    <td align="right">2672</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Graph extends GraphShapeElement { 	public enum Alignment { 		HORIZONTAL, VERTICAL 	}  	private List nodes = new ArrayList&lt;&gt;(); 	private Set edges = new HashSet&lt;&gt;(); 	private Set subgraphs = new HashSet&lt;&gt;(); 	private Alignment alignment = Alignment.VERTICAL;  	/** 	 * Constructs a Graph that uses the specified GraphEventManager to handle 	 * any user generated events on GraphElements. 	 *  	 * @param eventManager 	 */ 	public Graph(GraphController graphController) { 		super(graphController); 	}  	/** 	 * Adds an edge to the Graph and sets its parent to be this Graph. 	 *  	 * @param edge 	 *            the edge to add 	 */ 	public void addEdge(GraphEdge edge) { 		edge.setParent(this); 		edges.add(edge); 	}  	/** 	 * Adds a node to the Graph and sets its parent to be this Graph. 	 *  	 * @param node 	 *            the node to add 	 */ 	public void addNode(GraphNode node) { 		node.setParent(this); 		nodes.add(node); 	}  	/** 	 * Adds a subgraph to the Graph and sets its parent to be this Graph. 	 *  	 * @param subgraph 	 *            the subgraph to add 	 */ 	public void addSubgraph(Graph subgraph) { 		subgraph.setParent(this); 		subgraphs.add(subgraph); 	}  	/** 	 * Returns the alignment of the Graph. 	 *  	 * @return the alignment of the Graph 	 */ 	public Alignment getAlignment() { 		return alignment; 	}  	/** 	 * Returns the edges contained in the Graph. 	 *  	 * @return the edges contained in the Graph 	 */ 	public Set getEdges() { 		return Collections.unmodifiableSet(edges); 	}  	/** 	 * Returns the nodes contained in the Graph. 	 *  	 * @return the nodes contained in the Graph 	 */ 	public List getNodes() { 		return Collections.unmodifiableList(nodes); 	}  	/** 	 * Returns the subgraphs contained in the Graph. 	 *  	 * @return the subgraphs contained in the Graph 	 */ 	public Set getSubgraphs() { 		return Collections.unmodifiableSet(subgraphs); 	}  	/** 	 * Removes an edge from the Graph. 	 *  	 * @param edge 	 *            the edge to remove 	 * @return true if the edge is removed from the Graph 	 */ 	public boolean removeEdge(GraphEdge edge) { 		return edges.remove(edge); 	}  	/** 	 * Removes a node from the Graph. 	 *  	 * @param node 	 *            the node to remove 	 * @return true if the node is removed from the Graph 	 */ 	public boolean removeNode(GraphNode node) { 		return nodes.remove(node); 	}  	/** 	 * Removes a subgraph from the Graph. 	 *  	 * @param subgraph 	 *            the subgraph to remove 	 * @return true if the subgraph is removed from the Graph 	 */ 	public boolean removeSubgraph(Graph subgraph) { 		return subgraphs.remove(subgraph); 	}  	/** 	 * Sets the alignment of the Graph. 	 *  	 * @param alignment 	 *            the new alignment 	 */ 	public void setAlignment(Alignment alignment) { 		this.alignment = alignment; 	} }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15216</td>
    <td align="left">https://github.com/apache/incubator-taverna-workbench/blob/2b74964ac1ee22e56c5dad3321869d84f7052dcf/taverna-graph-model/src/main/java/org/apache/taverna/workbench/models/graph/Graph.java/#L30-L161</td>
    <td align="right">1</td>
    <td align="right">2672</td>
    <td align="right">15216</td>
  </tr>
  <tr valign="top">
    <td align="right">4807</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class AbstractPmdReport     extends AbstractMavenReport {     /**      * The output directory for the intermediate XML report.      */     @Parameter( property = &quot;project.build.directory&quot;, required = true )     protected File targetDirectory;      /**      * The output directory for the final HTML report. Note that this parameter is only evaluated if the goal is run      * directly from the command line or during the default lifecycle. If the goal is run indirectly as part of a site      * generation, the output directory configured in the Maven Site Plugin is used instead.      */     @Parameter( property = &quot;project.reporting.outputDirectory&quot;, required = true )     protected File outputDirectory;      /**      * Site rendering component for generating the HTML report.      */     @Component     private Renderer siteRenderer;      /**      * The project to analyse.      */     @Parameter( defaultValue = &quot;${project}&quot;, readonly = true, required = true )     protected MavenProject project;      /**      * Set the output format type, in addition to the HTML report. Must be one of: &quot;none&quot;, &quot;csv&quot;, &quot;xml&quot;, &quot;txt&quot; or the      * full class name of the PMD renderer to use. See the net.sourceforge.pmd.renderers package javadoc for available      * renderers. XML is required if the pmd:check goal is being used.      */     @Parameter( property = &quot;format&quot;, defaultValue = &quot;xml&quot; )     protected String format = &quot;xml&quot;;      /**      * Link the violation line numbers to the source xref. Links will be created automatically if the jxr plugin is      * being used.      */     @Parameter( property = &quot;linkXRef&quot;, defaultValue = &quot;true&quot; )     private boolean linkXRef;      /**      * Location of the Xrefs to link to.      */     @Parameter( defaultValue = &quot;${project.reporting.outputDirectory}/xref&quot; )     private File xrefLocation;      /**      * Location of the Test Xrefs to link to.      */     @Parameter( defaultValue = &quot;${project.reporting.outputDirectory}/xref-test&quot; )     private File xrefTestLocation;      /**      * A list of files to exclude from checking. Can contain Ant-style wildcards and double wildcards. Note that these      * exclusion patterns only operate on the path of a source file relative to its source root directory. In other      * words, files are excluded based on their package and/or class name. If you want to exclude entire source root      * directories, use the parameter excludeRoots instead.      *      * @since 2.2      */     @Parameter     private List excludes;      /**      * A list of files to include from checking. Can contain Ant-style wildcards and double wildcards. Defaults to      * **\/*.java.      *      * @since 2.2      */     @Parameter     private List includes;      /**      * Specifies the location of the source directories to be used for PMD.      * Defaults to project.compileSourceRoots.      * @since 3.7      */     @Parameter( defaultValue = &quot;${project.compileSourceRoots}&quot; )     private List compileSourceRoots;      /**      * The directories containing the test-sources to be used for PMD.      * Defaults to project.testCompileSourceRoots      * @since 3.7      */     @Parameter( defaultValue = &quot;${project.testCompileSourceRoots}&quot; )     private List testSourceRoots;      /**      * The project source directories that should be excluded.      *      * @since 2.2      */     @Parameter     private File[] excludeRoots;      /**      * Run PMD on the tests.      *      * @since 2.2      */     @Parameter( defaultValue = &quot;false&quot; )     protected boolean includeTests;      /**      * Whether to build an aggregated report at the root, or build individual reports.      *      * @since 2.2      */     @Parameter( property = &quot;aggregate&quot;, defaultValue = &quot;false&quot; )     protected boolean aggregate;      /**      * The file encoding to use when reading the Java sources.      *      * @since 2.3      */     @Parameter( property = &quot;encoding&quot;, defaultValue = &quot;${project.build.sourceEncoding}&quot; )     private String sourceEncoding;      /**      * The file encoding when writing non-HTML reports.      *      * @since 2.5      */     @Parameter( property = &quot;outputEncoding&quot;, defaultValue = &quot;${project.reporting.outputEncoding}&quot; )     private String outputEncoding;      /**      * The projects in the reactor for aggregation report.      */     @Parameter( property = &quot;reactorProjects&quot;, readonly = true )     protected List reactorProjects;      /**      * Whether to include the xml files generated by PMD/CPD in the site.      *      * @since 3.0      */     @Parameter( defaultValue = &quot;false&quot; )     protected boolean includeXmlInSite;      /**      * Skip the PMD/CPD report generation if there are no violations or duplications found. Defaults to      * true.      *      * @since 3.1      */     @Parameter( defaultValue = &quot;true&quot; )     protected boolean skipEmptyReport;      /**      * File that lists classes and rules to be excluded from failures.      * For PMD, this is a properties file. For CPD, this      * is a text file that contains comma-separated lists of classes      * that are allowed to duplicate.      *      * @since 3.7      */     @Parameter( property = &quot;pmd.excludeFromFailureFile&quot;, defaultValue = &quot;&quot; )     protected String excludeFromFailureFile;       /** The files that are being analyzed. */     protected Map filesToProcess;      /**      * {@inheritDoc}      */     @Override     protected MavenProject getProject()     {         return project;     }      /**      * {@inheritDoc}      */     @Override     protected Renderer getSiteRenderer()     {         return siteRenderer;     }      protected String constructXRefLocation( boolean test )     {         String location = null;         if ( linkXRef )         {             File xrefLoc = test ? xrefTestLocation : xrefLocation;              String relativePath =                 PathTool.getRelativePath( outputDirectory.getAbsolutePath(), xrefLoc.getAbsolutePath() );             if ( StringUtils.isEmpty( relativePath ) )             {                 relativePath = &quot;.&quot;;             }             relativePath = relativePath + &quot;/&quot; + xrefLoc.getName();             if ( xrefLoc.exists() )             {                 // XRef was already generated by manual execution of a lifecycle binding                 location = relativePath;             }             else             {                 // Not yet generated - check if the report is on its way                 @SuppressWarnings( &quot;unchecked&quot; )                 List reportPlugins = project.getReportPlugins();                 for ( ReportPlugin plugin : reportPlugins )                 {                     String artifactId = plugin.getArtifactId();                     if ( &quot;maven-jxr-plugin&quot;.equals( artifactId ) || &quot;jxr-maven-plugin&quot;.equals( artifactId ) )                     {                         location = relativePath;                     }                 }             }              if ( location == null )             {                 getLog().warn( &quot;Unable to locate Source XRef to link to - DISABLED&quot; );             }         }         return location;     }      /**      * Convenience method to get the list of files where the PMD tool will be executed      *      * @return a List of the files where the PMD tool will be executed      * @throws IOException If an I/O error occurs during construction of the      *                     canonical pathnames of the files      */     protected Map getFilesToProcess()         throws IOException     {         if ( aggregate &amp;&amp; !project.isExecutionRoot() )         {             return Collections.emptyMap();         }          if ( excludeRoots == null )         {             excludeRoots = new File[0];         }          Collection excludeRootFiles = new HashSet&lt;&gt;( excludeRoots.length );          for ( File file : excludeRoots )         {             if ( file.isDirectory() )             {                 excludeRootFiles.add( file );             }         }          List directories = new ArrayList&lt;&gt;();          if ( null == compileSourceRoots )         {             compileSourceRoots = project.getCompileSourceRoots();         }         if ( compileSourceRoots != null )         {             for ( String root : compileSourceRoots )             {                 File sroot = new File( root );                 if ( sroot.exists() )                 {                     String sourceXref = constructXRefLocation( false );                     directories.add( new PmdFileInfo( project, sroot, sourceXref ) );                 }             }         }          if ( null == testSourceRoots )         {             testSourceRoots = project.getTestCompileSourceRoots();         }         if ( includeTests )         {             if ( testSourceRoots != null )             {                 for ( String root : testSourceRoots )                 {                     File sroot = new File( root );                     if ( sroot.exists() )                     {                         String testXref = constructXRefLocation( true );                         directories.add( new PmdFileInfo( project, sroot, testXref ) );                     }                 }             }         }         if ( aggregate )         {             for ( MavenProject localProject : reactorProjects )             {                 @SuppressWarnings( &quot;unchecked&quot; )                 List localCompileSourceRoots = localProject.getCompileSourceRoots();                 for ( String root : localCompileSourceRoots )                 {                     File sroot = new File( root );                     if ( sroot.exists() )                     {                         String sourceXref = constructXRefLocation( false );                         directories.add( new PmdFileInfo( localProject, sroot, sourceXref ) );                     }                 }                 if ( includeTests )                 {                     @SuppressWarnings( &quot;unchecked&quot; )                     List localTestCompileSourceRoots = localProject.getTestCompileSourceRoots();                     for ( String root : localTestCompileSourceRoots )                     {                         File sroot = new File( root );                         if ( sroot.exists() )                         {                             String testXref = constructXRefLocation( true );                             directories.add( new PmdFileInfo( localProject, sroot, testXref ) );                         }                     }                 }             }          }          String excluding = getExcludes();         getLog().debug( &quot;Exclusions: &quot; + excluding );         String including = getIncludes();         getLog().debug( &quot;Inclusions: &quot; + including );          Map files = new TreeMap&lt;&gt;();          for ( PmdFileInfo finfo : directories )         {             getLog().debug( &quot;Searching for files in directory &quot; + finfo.getSourceDirectory().toString() );             File sourceDirectory = finfo.getSourceDirectory();             if ( sourceDirectory.isDirectory() &amp;&amp; !isDirectoryExcluded( excludeRootFiles, sourceDirectory ) )             {                 List newfiles = FileUtils.getFiles( sourceDirectory, including, excluding );                 for ( File newfile : newfiles )                 {                     files.put( newfile.getCanonicalFile(), finfo );                 }             }         }          return files;     }      private boolean isDirectoryExcluded( Collection excludeRootFiles, File sourceDirectoryToCheck )     {         boolean returnVal = false;         for ( File excludeDir : excludeRootFiles )         {             try             {                 if ( sourceDirectoryToCheck.getCanonicalPath().startsWith( excludeDir.getCanonicalPath() ) )                 {                     getLog().debug( &quot;Directory &quot; + sourceDirectoryToCheck.getAbsolutePath()                                         + &quot; has been excluded as it matches excludeRoot &quot;                                         + excludeDir.getAbsolutePath() );                     returnVal = true;                     break;                 }             }             catch ( IOException e )             {                 getLog().warn( &quot;Error while checking &quot; + sourceDirectoryToCheck                                + &quot; whether it should be excluded.&quot;, e );             }         }         return returnVal;     }      /**      * Gets the comma separated list of effective include patterns.      *      * @return The comma separated list of effective include patterns, never null.      */     private String getIncludes()     {         Collection patterns = new LinkedHashSet&lt;&gt;();         if ( includes != null )         {             patterns.addAll( includes );         }         if ( patterns.isEmpty() )         {             patterns.add( &quot;**/*.java&quot; );         }         return StringUtils.join( patterns.iterator(), &quot;,&quot; );     }      /**      * Gets the comma separated list of effective exclude patterns.      *      * @return The comma separated list of effective exclude patterns, never null.      */     private String getExcludes()     {         Collection patterns = new LinkedHashSet&lt;&gt;( FileUtils.getDefaultExcludesAsList() );         if ( excludes != null )         {             patterns.addAll( excludes );         }         return StringUtils.join( patterns.iterator(), &quot;,&quot; );     }      protected boolean isHtml()     {         return &quot;html&quot;.equals( format );     }      protected boolean isXml()     {         return &quot;xml&quot;.equals( format );     }      /**      * {@inheritDoc}      */     @Override     public boolean canGenerateReport()     {         if ( aggregate &amp;&amp; !project.isExecutionRoot() )         {             return false;         }          if ( &quot;pom&quot;.equals( project.getPackaging() ) &amp;&amp; !aggregate )         {             return false;         }          // if format is XML, we need to output it even if the file list is empty         // so the &quot;check&quot; goals can check for failures         if ( isXml() )         {             return true;         }         try         {             filesToProcess = getFilesToProcess();             if ( filesToProcess.isEmpty() )             {                 return false;             }         }         catch ( IOException e )         {             getLog().error( e );         }         return true;     }      /**      * {@inheritDoc}      */     @Override     protected String getOutputDirectory()     {         return outputDirectory.getAbsolutePath();     }      protected String getSourceEncoding()     {         return sourceEncoding;     }      /**      * Gets the effective reporting output files encoding.      *      * @return The effective reporting output file encoding, never null.      * @since 2.5      */     protected String getOutputEncoding()     {         return ( outputEncoding != null ) ? outputEncoding : ReaderFactory.UTF_8;     }      static String getPmdVersion()     {         try         {             return (String) PMD.class.getField( &quot;VERSION&quot; ).get( null );         }         catch ( IllegalAccessException e )         {             throw new RuntimeException( &quot;PMD VERSION field not accessible&quot;, e );         }         catch ( NoSuchFieldException e )         {             throw new RuntimeException( &quot;PMD VERSION field not found&quot;, e );         }     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13040</td>
    <td align="left">https://github.com/apache/maven-plugins/blob/a007e769ed5825774d5c31ec06c0013c8ee2b4d4/maven-pmd-plugin/src/main/java/org/apache/maven/plugins/pmd/AbstractPmdReport.java/#L52-L553</td>
    <td align="right">1</td>
    <td align="right">4807</td>
    <td align="right">13040</td>
  </tr>
  <tr valign="top">
    <td align="right">2122</td>
    <td align="left">{ 	&quot;message&quot;: &quot;YES I found bad smells&quot;, 	&quot;detected_bad_smells&quot;: [ 		&quot;Blob&quot;, 		&quot;Data Class&quot;, 		&quot;Long Method&quot; 	] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LuceneIndexForPartitionedRegion extends LuceneIndexImpl {   protected Region fileAndChunkRegion;   protected final FileSystemStats fileSystemStats;    public static final String FILES_REGION_SUFFIX = &quot;.files&quot;;    private final ExecutorService waitingThreadPoolFromDM;    public LuceneIndexForPartitionedRegion(String indexName, String regionPath, InternalCache cache) {     super(indexName, regionPath, cache);     this.waitingThreadPoolFromDM = cache.getDistributionManager().getWaitingThreadPool();      final String statsName = indexName + &quot;-&quot; + regionPath;     this.fileSystemStats = new FileSystemStats(cache.getDistributedSystem(), statsName);   }    @Override   protected RepositoryManager createRepositoryManager(LuceneSerializer luceneSerializer) {     LuceneSerializer mapper = luceneSerializer;     if (mapper == null) {       mapper = new HeterogeneousLuceneSerializer();     }     PartitionedRepositoryManager partitionedRepositoryManager =         new PartitionedRepositoryManager(this, mapper, this.waitingThreadPoolFromDM);     return partitionedRepositoryManager;   }    @Override   public boolean isIndexingInProgress() {     PartitionedRegion userRegion = (PartitionedRegion) cache.getRegion(this.getRegionPath());     Set fileRegionPrimaryBucketIds =         this.getFileAndChunkRegion().getDataStore().getAllLocalPrimaryBucketIds();     for (Integer bucketId : fileRegionPrimaryBucketIds) {       BucketRegion userBucket = userRegion.getDataStore().getLocalBucketById(bucketId);       if (!userBucket.isEmpty() &amp;&amp; !this.isIndexAvailable(bucketId)) {         return true;       }     }     return false;   }    @Override   protected void createLuceneListenersAndFileChunkRegions(       PartitionedRepositoryManager partitionedRepositoryManager) {     partitionedRepositoryManager.setUserRegionForRepositoryManager((PartitionedRegion) dataRegion);     RegionShortcut regionShortCut;     final boolean withPersistence = withPersistence();     RegionAttributes regionAttributes = dataRegion.getAttributes();     final boolean withStorage = regionAttributes.getPartitionAttributes().getLocalMaxMemory() &gt; 0;      // TODO: 1) dataRegion should be withStorage     // 2) Persistence to Persistence     // 3) Replicate to Replicate, Partition To Partition     // 4) Offheap to Offheap     if (!withStorage) {       regionShortCut = RegionShortcut.PARTITION_PROXY;     } else if (withPersistence) {       // TODO: add PartitionedRegionAttributes instead       regionShortCut = RegionShortcut.PARTITION_PERSISTENT;     } else {       regionShortCut = RegionShortcut.PARTITION;     }      // create PR fileAndChunkRegion, but not to create its buckets for now     final String fileRegionName = createFileRegionName();     PartitionAttributes partitionAttributes = dataRegion.getPartitionAttributes();     DistributionManager dm = this.cache.getInternalDistributedSystem().getDistributionManager();     LuceneBucketListener lucenePrimaryBucketListener =         new LuceneBucketListener(partitionedRepositoryManager, dm);      if (!fileRegionExists(fileRegionName)) {       fileAndChunkRegion = createRegion(fileRegionName, regionShortCut, this.regionPath,           partitionAttributes, regionAttributes, lucenePrimaryBucketListener);     }      fileSystemStats         .setBytesSupplier(() -&gt; getFileAndChunkRegion().getPrStats().getDataStoreBytesInUse());    }    public PartitionedRegion getFileAndChunkRegion() {     return (PartitionedRegion) fileAndChunkRegion;   }    public FileSystemStats getFileSystemStats() {     return fileSystemStats;   }    boolean fileRegionExists(String fileRegionName) {     return cache.getRegion(fileRegionName) != null;   }    public String createFileRegionName() {     return LuceneServiceImpl.getUniqueIndexRegionName(indexName, regionPath, FILES_REGION_SUFFIX);   }    private PartitionAttributesFactory configureLuceneRegionAttributesFactory(       PartitionAttributesFactory attributesFactory,       PartitionAttributes dataRegionAttributes) {     attributesFactory.setTotalNumBuckets(dataRegionAttributes.getTotalNumBuckets());     attributesFactory.setRedundantCopies(dataRegionAttributes.getRedundantCopies());     attributesFactory.setPartitionResolver(getPartitionResolver(dataRegionAttributes));     attributesFactory.setRecoveryDelay(dataRegionAttributes.getRecoveryDelay());     attributesFactory.setStartupRecoveryDelay(dataRegionAttributes.getStartupRecoveryDelay());     return attributesFactory;   }    private PartitionResolver getPartitionResolver(PartitionAttributes dataRegionAttributes) {     if (dataRegionAttributes.getPartitionResolver() instanceof FixedPartitionResolver) {       return new BucketTargetingFixedResolver();     } else {       return new BucketTargetingResolver();     }   }    protected  Region createRegion(final String regionName,       final RegionShortcut regionShortCut, final String colocatedWithRegionName,       final PartitionAttributes partitionAttributes, final RegionAttributes regionAttributes,       PartitionListener lucenePrimaryBucketListener) {     PartitionAttributesFactory partitionAttributesFactory = new PartitionAttributesFactory();     if (lucenePrimaryBucketListener != null) {       partitionAttributesFactory.addPartitionListener(lucenePrimaryBucketListener);     }     partitionAttributesFactory.setColocatedWith(colocatedWithRegionName);     configureLuceneRegionAttributesFactory(partitionAttributesFactory, partitionAttributes);      // Create AttributesFactory based on input RegionShortcut     RegionAttributes baseAttributes = this.cache.getRegionAttributes(regionShortCut.toString());     AttributesFactory factory = new AttributesFactory(baseAttributes);     factory.setPartitionAttributes(partitionAttributesFactory.create());     if (regionAttributes.getDataPolicy().withPersistence()) {       factory.setDiskStoreName(regionAttributes.getDiskStoreName());     }     RegionAttributes attributes = factory.create();      return createRegion(regionName, attributes);   }    public void close() {}    @Override   public void dumpFiles(final String directory) {     ResultCollector results = FunctionService.onRegion(getDataRegion())         .setArguments(new String[] {directory, indexName}).execute(DumpDirectoryFiles.ID);     results.getResult();   }    @Override   public void destroy(boolean initiator) {     if (logger.isDebugEnabled()) {       logger.debug(&quot;Destroying index regionPath=&quot; + regionPath + &quot;; indexName=&quot; + indexName           + &quot;; initiator=&quot; + initiator);     }      // Invoke super destroy to remove the extension and async event queue     super.destroy(initiator);      // Destroy index on remote members if necessary     if (initiator) {       destroyOnRemoteMembers();     }      // Destroy the file region (colocated with the application region) if necessary     // localDestroyRegion can't be used because locally destroying regions is not supported on     // colocated regions     if (initiator) {       try {         fileAndChunkRegion.destroyRegion();         if (logger.isDebugEnabled()) {           logger.debug(&quot;Destroyed fileAndChunkRegion=&quot; + fileAndChunkRegion.getName());         }       } catch (RegionDestroyedException e) {         if (logger.isDebugEnabled()) {           logger.debug(&quot;Already destroyed fileAndChunkRegion=&quot; + fileAndChunkRegion.getName());         }       }     }      if (logger.isDebugEnabled()) {       logger.debug(&quot;Destroyed index regionPath=&quot; + regionPath + &quot;; indexName=&quot; + indexName           + &quot;; initiator=&quot; + initiator);     }   }    @Override   public boolean isIndexAvailable(int id) {     PartitionedRegion fileAndChunkRegion = getFileAndChunkRegion();     return (fileAndChunkRegion.get(IndexRepositoryFactory.APACHE_GEODE_INDEX_COMPLETE, id) != null         || !LuceneServiceImpl.LUCENE_REINDEX);   }    private void destroyOnRemoteMembers() {     DistributionManager dm = getDataRegion().getDistributionManager();     Set recipients = dm.getOtherNormalDistributionManagerIds();     if (!recipients.isEmpty()) {       if (logger.isDebugEnabled()) {         logger.debug(&quot;LuceneIndexForPartitionedRegion: About to send destroy message recipients=&quot;             + recipients);       }       ReplyProcessor21 processor = new ReplyProcessor21(dm, recipients);       DestroyLuceneIndexMessage message = new DestroyLuceneIndexMessage(recipients,           processor.getProcessorId(), regionPath, indexName);       dm.putOutgoing(message);       if (logger.isDebugEnabled()) {         logger.debug(&quot;LuceneIndexForPartitionedRegion: Sent message recipients=&quot; + recipients);       }       try {         processor.waitForReplies();       } catch (ReplyException e) {         Throwable cause = e.getCause();         if (cause instanceof IllegalArgumentException) {           // If the IllegalArgumentException is index not found, then its ok; otherwise rethrow it.           String fullRegionPath =               regionPath.startsWith(Region.SEPARATOR) ? regionPath : Region.SEPARATOR + regionPath;           String indexNotFoundMessage = String.format(&quot;Lucene index %s was not found in region %s&quot;,               indexName, fullRegionPath);           if (!cause.getLocalizedMessage().equals(indexNotFoundMessage)) {             throw e;           }         } else if (!(cause instanceof CancelException)) {           throw e;         }       } catch (InterruptedException e) {         dm.getCancelCriterion().checkCancelInProgress(e);         Thread.currentThread().interrupt();       }     }   } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">13214</td>
    <td align="left">https://github.com/apache/geode/blob/8fd839e8b73e40bd2dfd14f331b587431bd35a66/geode-lucene/src/main/java/org/apache/geode/cache/lucene/internal/LuceneIndexForPartitionedRegion.java/#L49-L277</td>
    <td align="right">1</td>
    <td align="right">2122</td>
    <td align="right">13214</td>
  </tr>
  <tr valign="top">
    <td align="right">975</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement(name = &quot;Product&quot;) public class Product {     private long id;     private String description;      public long getId() {         return id;     }      public void setId(long id) {         this.id = id;     }      public String getDescription() {         return description;     }      public void setDescription(String d) {         this.description = d;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8780</td>
    <td align="left">https://github.com/apache/cxf/blob/6bf89e9c8804c8845ec4d38583dd33eea8256439/distribution/src/main/release/samples/jax_rs/spring_security/src/main/java/demo/jaxrs/service/Product.java/#L23-L43</td>
    <td align="right">1</td>
    <td align="right">975</td>
    <td align="right">8780</td>
  </tr>
  <tr valign="top">
    <td align="right">554</td>
    <td align="left">&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Data Class&quot;     ] }  </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Customer223 {  	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id; 	private String firstName; 	private String lastName;  	protected Customer223() {}  	public Customer223(String firstName, String lastName) { 		this.firstName = firstName; 		this.lastName = lastName; 	}  	@Override 	public String toString() { 		return String.format(&quot;Customer223[id=%d, firstName='%s', lastName='%s']&quot;, id, firstName, lastName); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5603</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer223.java/#L8-L27</td>
    <td align="right">1</td>
    <td align="right">554</td>
    <td align="right">5603</td>
  </tr>
  <tr valign="top">
    <td align="right">748</td>
    <td align="left">&nbsp;		{ 			&quot;response&quot;: &quot;YES I found bad smells&quot;, 			&quot;detected_bad_smells&quot;: [ 				&quot;Long Method&quot;, 				&quot;Data Class&quot; 			] 		} </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class PartnerLinkRef extends OBase implements RValue, LValue, Serializable {         public static final long serialVersionUID = -1L;         private static final String PARTNERLINK = &quot;partnerLink&quot;;         private static final String ISMYENDPOINTREFERENCE = &quot;isMyEndpointReference&quot;;          @JsonCreator         public PartnerLinkRef() {             setIsMyEndpointReference(false);         }          public PartnerLinkRef(OProcess owner) {             super(owner);             setIsMyEndpointReference(false);         }          @JsonIgnore         public boolean isIsMyEndpointReference() {             Object o = fieldContainer.get(ISMYENDPOINTREFERENCE);             return o == null ? false : (Boolean) o;         }          @JsonIgnore         public OPartnerLink getPartnerLink() {             Object o = fieldContainer.get(PARTNERLINK);             return o == null ? null : (OPartnerLink) o;         }          // Must fit in a LValue even if it's not variable based         @JsonIgnore         public Variable getVariable() {             return null;         }          public void setIsMyEndpointReference(boolean isMyEndpointReference) {             fieldContainer.put(ISMYENDPOINTREFERENCE, isMyEndpointReference);         }          public void setPartnerLink(OPartnerLink partnerLink) {             fieldContainer.put(PARTNERLINK, partnerLink);         }          public String toString() {             return &quot;{PLinkRef &quot; + getPartnerLink() + &quot;!&quot; + isIsMyEndpointReference() + &quot;}&quot;;         }     }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7018</td>
    <td align="left">https://github.com/apache/ode/blob/b2ddc6436891f84f716ffcbed8c1cd1e374bd805/bpel-nobj/src/main/java/org/apache/ode/bpel/obj/OAssign.java/#L393-L437</td>
    <td align="right">1</td>
    <td align="right">748</td>
    <td align="right">7018</td>
  </tr>
  <tr valign="top">
    <td align="right">4023</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{       &quot;response&quot;: &quot;YES, I found bad smells&quot;,       &quot;bad_smells&quot;: [          &quot;Long Method&quot;,          &quot;Data Class&quot;       ]    }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  protected class ValueIterable implements Iterable {     private ValueIterator iterator = new ValueIterator();     @Override     public Iterator iterator() {       return iterator;     }    }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10632</td>
    <td align="left">https://github.com/apache/hadoop/blob/128dd91e10080bdcbcd7d555fa3c4105e55a6b51/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/task/ReduceContextImpl.java/#L350-L356</td>
    <td align="right">1</td>
    <td align="right">4023</td>
    <td align="right">10632</td>
  </tr>
  <tr valign="top">
    <td align="right">2335</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SSLConfigClient extends SSLConfig {    private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(SSLConfigClient.class);    private final Properties properties;   private final boolean userSslEnabled;   private final String trustStoreType;   private final String trustStorePath;   private final String trustStorePassword;   private final boolean disableHostVerification;   private final boolean disableCertificateVerification;   private final boolean useSystemTrustStore;   private final String protocol;   private final int handshakeTimeout;   private final String provider;    private final String emptyString = new String();    public SSLConfigClient(Properties properties) throws DrillException {     this.properties = properties;     userSslEnabled = getBooleanProperty(DrillProperties.ENABLE_TLS);     trustStoreType = getStringProperty(DrillProperties.TRUSTSTORE_TYPE, &quot;JKS&quot;);     trustStorePath = getStringProperty(DrillProperties.TRUSTSTORE_PATH, &quot;&quot;);     trustStorePassword = getStringProperty(DrillProperties.TRUSTSTORE_PASSWORD, &quot;&quot;);     disableHostVerification = getBooleanProperty(DrillProperties.DISABLE_HOST_VERIFICATION);     disableCertificateVerification = getBooleanProperty(DrillProperties.DISABLE_CERT_VERIFICATION);     useSystemTrustStore = getBooleanProperty(DrillProperties.USE_SYSTEM_TRUSTSTORE);     protocol = getStringProperty(DrillProperties.TLS_PROTOCOL, DEFAULT_SSL_PROTOCOL);     int hsTimeout = getIntProperty(DrillProperties.TLS_HANDSHAKE_TIMEOUT, DEFAULT_SSL_HANDSHAKE_TIMEOUT_MS);     if (hsTimeout &lt;= 0) {       hsTimeout = DEFAULT_SSL_HANDSHAKE_TIMEOUT_MS;     }     handshakeTimeout = hsTimeout;     // If provider is OPENSSL then to debug or run this code in an IDE, you will need to enable     // the dependency on netty-tcnative with the correct classifier for the platform you use.     // This can be done by enabling the openssl profile.     // If the IDE is Eclipse, it requires you to install an additional Eclipse plugin available here:     // http://repo1.maven.org/maven2/kr/motd/maven/os-maven-plugin/1.6.1/os-maven-plugin-1.6.1.jar     // or from your local maven repository:     // ~/.m2/repository/kr/motd/maven/os-maven-plugin/1.6.1/os-maven-plugin-1.6.1.jar     // Note that installing this plugin may require you to start with a new workspace     provider = getStringProperty(DrillProperties.TLS_PROVIDER, DEFAULT_SSL_PROVIDER);   }    private boolean getBooleanProperty(String propName) {     return (properties != null) &amp;&amp; (properties.containsKey(propName))         &amp;&amp; (properties.getProperty(propName).compareToIgnoreCase(&quot;true&quot;) == 0);   }    private String getStringProperty(String name, String defaultValue) {     String value = &quot;&quot;;     if ( (properties != null) &amp;&amp; (properties.containsKey(name))) {       value = properties.getProperty(name);     }     if (value.isEmpty()) {       value = defaultValue;     }     value = value.trim();     return value;   }    private int getIntProperty(String name, int defaultValue) {     int value = defaultValue;     if (properties != null) {       String property = properties.getProperty(name);       if (property != null &amp;&amp; property.length() &gt; 0) {         value = Integer.decode(property);       }     }     return value;   }    public void validateKeyStore() throws DrillException {    }    @Override   public SslContext initNettySslContext() throws DrillException {     final SslContext sslCtx;      if (!userSslEnabled) {       return null;     }      TrustManagerFactory tmf;     try {       tmf = initializeTrustManagerFactory();       sslCtx = SslContextBuilder.forClient()           .sslProvider(getProvider())           .trustManager(tmf)           .protocols(protocol)           .build();     } catch (Exception e) {       // Catch any SSL initialization Exceptions here and abort.       throw new DrillException(new StringBuilder()           .append(&quot;SSL is enabled but cannot be initialized due to the following exception: &quot;)           .append(&quot;[ &quot;)           .append(e.getMessage())           .append(&quot;]. &quot;)           .toString());     }     this.nettySslContext = sslCtx;     return sslCtx;   }    @Override   public SSLContext initJDKSSLContext() throws DrillException {     final SSLContext sslCtx;      if (!userSslEnabled) {       return null;     }      TrustManagerFactory tmf;     try {       tmf = initializeTrustManagerFactory();       sslCtx = SSLContext.getInstance(protocol);       sslCtx.init(null, tmf.getTrustManagers(), null);     } catch (Exception e) {       // Catch any SSL initialization Exceptions here and abort.       throw new DrillException(new StringBuilder()           .append(&quot;SSL is enabled but cannot be initialized due to the following exception: &quot;)           .append(&quot;[ &quot;)           .append(e.getMessage())           .append(&quot;]. &quot;)           .toString());     }     this.jdkSSlContext = sslCtx;     return sslCtx;   }    @Override   public SSLEngine createSSLEngine(BufferAllocator allocator, String peerHost, int peerPort) {     SSLEngine engine = super.createSSLEngine(allocator, peerHost, peerPort);      if (!this.disableHostVerification()) {       SSLParameters sslParameters = engine.getSSLParameters();       // only available since Java 7       sslParameters.setEndpointIdentificationAlgorithm(&quot;HTTPS&quot;);       engine.setSSLParameters(sslParameters);     }      engine.setUseClientMode(true);      try {       engine.setEnableSessionCreation(true);     } catch (Exception e) {       // Openssl implementation may throw this.       logger.debug(&quot;Session creation not enabled. Exception: {}&quot;, e.getMessage());     }      return engine;   }    @Override   public boolean isUserSslEnabled() {     return userSslEnabled;   }    @Override   public boolean isHttpsEnabled() {     return false;   }    @Override   public String getKeyStoreType() {     return emptyString;   }    @Override   public String getKeyStorePath() {     return emptyString;   }    @Override   public String getKeyStorePassword() {     return emptyString;   }    @Override   public String getKeyPassword() {     return emptyString;   }    @Override   public String getTrustStoreType() {     return trustStoreType;   }    @Override   public boolean hasTrustStorePath() {     return !trustStorePath.isEmpty();   }    @Override   public String getTrustStorePath() {     return trustStorePath;   }    @Override   public boolean hasTrustStorePassword() {     return !trustStorePassword.isEmpty();   }    @Override   public String getTrustStorePassword() {     return trustStorePassword;   }    @Override   public String getProtocol() {     return protocol;   }    @Override   public SslProvider getProvider() {     return provider.equalsIgnoreCase(&quot;JDK&quot;) ? SslProvider.JDK : SslProvider.OPENSSL;   }    @Override   public int getHandshakeTimeout() {     return handshakeTimeout;   }    @Override   public Mode getMode() {     return Mode.CLIENT;   }    @Override   public boolean disableHostVerification() {     return disableHostVerification;   }    @Override   public boolean disableCertificateVerification() {     return disableCertificateVerification;   }    @Override   public boolean useSystemTrustStore() {     return useSystemTrustStore;   }    public boolean isSslValid() {     return true;   }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14161</td>
    <td align="left">https://github.com/apache/drill/blob/5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3/exec/java-exec/src/main/java/org/apache/drill/exec/ssl/SSLConfigClient.java/#L33-L281</td>
    <td align="right">1</td>
    <td align="right">2335</td>
    <td align="right">14161</td>
  </tr>
  <tr valign="top">
    <td align="right">2614</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad_smells&quot;: [             &quot;Data Class&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DefaultTypeDeclaration extends AbstractDeclaration implements TypeDeclaration {      private final Element m_componentMetadata;     private final String m_componentName;     private final String m_componentVersion;     private final String m_extension;     private boolean visible = true;      public DefaultTypeDeclaration(BundleContext bundleContext, Element componentMetadata) {         super(bundleContext, TypeDeclaration.class);         m_componentMetadata = componentMetadata;         visible = initVisible();         m_componentName = initComponentName();         m_componentVersion = initComponentVersion(bundleContext);         m_extension = initExtension();     }      private String initExtension() {         if (m_componentMetadata.getNameSpace() == null) {             return m_componentMetadata.getName();         }         return m_componentMetadata.getNameSpace() + &quot;:&quot; + m_componentMetadata.getName();     }      private String initComponentVersion(BundleContext bundleContext) {         String version = m_componentMetadata.getAttribute(&quot;version&quot;);         if (version != null) {             if (&quot;bundle&quot;.equalsIgnoreCase(version)) {                 return bundleContext.getBundle().getHeaders().get(Constants.BUNDLE_VERSION);             }         }         return version;     }      private String initComponentName() {         String name = m_componentMetadata.getAttribute(&quot;name&quot;);         if (name == null) {             name = m_componentMetadata.getAttribute(&quot;classname&quot;);         }         return name;     }      private boolean initVisible() {         String publicAttribute = m_componentMetadata.getAttribute(&quot;public&quot;);         return (publicAttribute == null) || !publicAttribute.equalsIgnoreCase(&quot;false&quot;);     }      public String getComponentName() {         return m_componentName;     }      public String getComponentVersion() {         return m_componentVersion;     }      public String getExtension() {         return m_extension;     }      public Element getComponentMetadata() {         return m_componentMetadata;     }      public boolean isPublic() {         return visible;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15045</td>
    <td align="left">https://github.com/apache/felix/blob/a132994b250751d4ba3b115ee070ba397d9840ca/ipojo/runtime/core/src/main/java/org/apache/felix/ipojo/extender/internal/declaration/DefaultTypeDeclaration.java/#L30-L96</td>
    <td align="right">1</td>
    <td align="right">2614</td>
    <td align="right">15045</td>
  </tr>
  <tr valign="top">
    <td align="right">1575</td>
    <td align="left">{    &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;bad_smells&quot;: [     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Tower extends Item {      private Fit fit;     private String tubing;      public static enum Fit {         Custom,         Exact,         Universal     }      public Fit getFit() {         return fit;     }      public void setFit(Fit fit) {         this.fit = fit;     }      public String getTubing() {         return tubing;     }      public void setTubing(String tubing) {         this.tubing = tubing;     }      ; }</td>
    <td align="left">data class</td>
    <td align="left">Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11348</td>
    <td align="left">https://github.com/apache/tomee/blob/d21933b313aff812fe5188b57bf572a9ad649148/examples/webservice-inheritance/src/main/java/org/superbiz/inheritance/Tower.java/#L21-L50</td>
    <td align="right">1</td>
    <td align="right">1575</td>
    <td align="right">11348</td>
  </tr>
  <tr valign="top">
    <td align="right">1180</td>
    <td align="left">&nbsp;&nbsp;YES I found bad smells the bad smells are: 1. Data class, 2. Lazy class, 3. Long methods</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class ShuffleWriteMetrics {     private long bytesWritten;      private long recordsWritten;      private long writeTime;      public long getBytesWritten ()     {         return bytesWritten;     }      public void setBytesWritten (long bytesWritten)     {         this.bytesWritten = bytesWritten;     }      public long getRecordsWritten ()     {         return recordsWritten;     }      public void setRecordsWritten (long recordsWritten)     {         this.recordsWritten = recordsWritten;     }      public long getWriteTime ()     {         return writeTime;     }      public void setWriteTime (long writeTime)     {         this.writeTime = writeTime;     } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Data class, 2 Lazy class, 3 Long methods</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;2. Lazy class,  3. Long methods</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10230</td>
    <td align="left">https://github.com/Microsoft/azure-tools-for-java/blob/d121e8ac9cc3ab400e5b49c8b372280ae332f3fb/Utils/hdinsight-node-common/src/com/microsoft/azure/hdinsight/sdk/rest/spark/task/ShuffleWriteMetrics.java/#L24-L60</td>
    <td align="right">2</td>
    <td align="right">1180</td>
    <td align="right">10230</td>
  </tr>
  <tr valign="top">
    <td align="right">899</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;response&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class AssemblerConfig {  	// Private Member Variables ------------------------------------------------  	/** The portlet app descriptor, which is usually WEB-INF/portlet.xml. */     private File portletDescriptor;      /** The webapp descriptor to assemble, which is usually WEB-INF/web.xml. */     private File webappDescriptor;      /** The assemble destination, which points to the assembled WAR file. */     private File destination;      /** The class of the servlet that will handle portlet requests */     private String dispatchServletClass;      /** The source archive to assemble */     private File source;          /** Assembler sink buffer size.  Defaults to 4096 bytes. */     private int assemblerSinkBuflen = 1024 * 4; // 4kb      // Public Methods ----------------------------------------------------------      public File getPortletDescriptor() {         return portletDescriptor;     }      public void setPortletDescriptor(File portletDescriptor) {         this.portletDescriptor = portletDescriptor;     }      public File getWebappDescriptor() {         return webappDescriptor;     }      public void setWebappDescriptor(File webappDescriptor) {         this.webappDescriptor = webappDescriptor;     }      public File getDestination() {         return destination;     }      public void setDestination(File destination) {         this.destination = destination;     }      public String getDispatchServletClass() {         return dispatchServletClass;     }      public void setDispatchServletClass(String dispatchServletClass) {         this.dispatchServletClass = dispatchServletClass;     }      /**      * @deprecated use setSource(File) instead.      */     public void setWarSource(File source) {         this.source = source;     }          public void setSource(File source) {         this.source = source;     }          /**      * @deprecated use getSource() instead.      */     public File getWarSource() {         return source;     }          public File getSource() {         return source;     }          public int getAssemblerSinkBuflen() {         return assemblerSinkBuflen;     }          public void setAssemblerSinkBuflen(int buflen) {         this.assemblerSinkBuflen = buflen;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8152</td>
    <td align="left">https://github.com/apache/portals-pluto/blob/4db5ddd26fb2ce642be7b0894858e664c6076a3b/pluto-util/src/main/java/org/apache/pluto/util/assemble/AssemblerConfig.java/#L25-L110</td>
    <td align="right">1</td>
    <td align="right">899</td>
    <td align="right">8152</td>
  </tr>
  <tr valign="top">
    <td align="right">148</td>
    <td align="left">&nbsp;{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public class Attachment {          private String fallback;         private String color;         private String pretext;         private String authorName;         private String authorLink;         private String authorIcon;         private String title;         private String titleLink;         private String text;         private String imageUrl;         private String thumbUrl;         private String footer;         private String footerIcon;         private Long ts;         private List fields;          public String getFallback() {             return fallback;         }          public void setFallback(String fallback) {             this.fallback = fallback;         }          public String getColor() {             return color;         }          public void setColor(String color) {             this.color = color;         }          public String getPretext() {             return pretext;         }          public void setPretext(String pretext) {             this.pretext = pretext;         }          public String getAuthorName() {             return authorName;         }          public void setAuthorName(String authorName) {             this.authorName = authorName;         }          public String getAuthorLink() {             return authorLink;         }          public void setAuthorLink(String authorLink) {             this.authorLink = authorLink;         }          public String getAuthorIcon() {             return authorIcon;         }          public void setAuthorIcon(String authorIcon) {             this.authorIcon = authorIcon;         }          public String getTitle() {             return title;         }          public void setTitle(String title) {             this.title = title;         }          public String getTitleLink() {             return titleLink;         }          public void setTitleLink(String titleLink) {             this.titleLink = titleLink;         }          public String getText() {             return text;         }          public void setText(String text) {             this.text = text;         }          public String getImageUrl() {             return imageUrl;         }          public void setImageUrl(String imageUrl) {             this.imageUrl = imageUrl;         }          public String getThumbUrl() {             return thumbUrl;         }          public void setThumbUrl(String thumbUrl) {             this.thumbUrl = thumbUrl;         }          public String getFooter() {             return footer;         }          public void setFooter(String footer) {             this.footer = footer;         }          public String getFooterIcon() {             return footerIcon;         }          public void setFooterIcon(String footerIcon) {             this.footerIcon = footerIcon;         }          public Long getTs() {             return ts;         }          public void setTs(Long ts) {             this.ts = ts;         }          public List getFields() {             return fields;         }          public void setFields(List fields) {             this.fields = fields;         }          public class Field {              private String title;             private String value;             private Boolean shortValue;              public String getTitle() {                 return title;             }             public void setTitle(String title) {                 this.title = title;             }             public String getValue() {                 return value;             }             public void setValue(String value) {                 this.value = value;             }             public Boolean isShortValue() {                 return shortValue;             }             public void setShortValue(Boolean shortValue) {                 this.shortValue = shortValue;             }         }     }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1844</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-slack/src/main/java/org/apache/camel/component/slack/helper/SlackMessage.java/#L78-L241</td>
    <td align="right">1</td>
    <td align="right">148</td>
    <td align="right">1844</td>
  </tr>
  <tr valign="top">
    <td align="right">2594</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{        &quot;message&quot;: &quot;YES I found bad smells&quot;,        &quot;bad smells are&quot;: [            &quot;Data Class&quot;,            &quot;Long Method&quot;        ]    }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class BinaryExpression implements Expression {     protected Expression left;     protected Expression right;      public BinaryExpression(Expression left, Expression right) {         this.left = left;         this.right = right;     }      public Expression getLeft() {         return left;     }      public Expression getRight() {         return right;     }       /**      * @see java.lang.Object#toString()      */     public String toString() {         return &quot;(&quot; + left.toString() + &quot; &quot; + getExpressionSymbol() + &quot; &quot; + right.toString() + &quot;)&quot;;     }      /**      * TODO: more efficient hashCode()      *      * @see java.lang.Object#hashCode()      */     public int hashCode() {         return toString().hashCode();     }      /**      * TODO: more efficient hashCode()      *      * @see java.lang.Object#equals(java.lang.Object)      */     public boolean equals(Object o) {          if (o == null || !this.getClass().equals(o.getClass())) {             return false;         }         return toString().equals(o.toString());      }      /**      * Returns the symbol that represents this binary expression.  For example, addition is      * represented by &quot;+&quot;      *      * @return      */     public abstract String getExpressionSymbol();      /**      * @param expression      */     public void setRight(Expression expression) {         right = expression;     }      /**      * @param expression      */     public void setLeft(Expression expression) {         left = expression;     }      }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15004</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-client/src/main/java/org/apache/activemq/filter/BinaryExpression.java/#L26-L96</td>
    <td align="right">1</td>
    <td align="right">2594</td>
    <td align="right">15004</td>
  </tr>
  <tr valign="top">
    <td align="right">2524</td>
    <td align="left">&nbsp;{    &quot;response&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;1. Blob&quot;,     &quot;2. Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LivePropertySource {  	private final List properties; 	private final String sourceName;   	public LivePropertySource(String sourceName, List properties) { 		this.sourceName = sourceName; 		this.properties = properties != null ? ImmutableList.copyOf(properties) : ImmutableList.of(); 	}  	public String getSourceName() { 		return this.sourceName; 	}  	public LiveProperty getProperty(String propertyName) { 		for (LiveProperty liveProperty : properties) { 			if (liveProperty.getProperty().equals(propertyName)) { 				return liveProperty; 			} 		} 		return null; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14719</td>
    <td align="left">https://github.com/spring-projects/sts4/blob/46e9e985b0c5e28ea1952d9fc640ec12fd9c8fdd/headless-services/commons/commons-boot-app-cli/src/main/java/org/springframework/ide/vscode/commons/boot/app/cli/liveproperties/LivePropertySource.java/#L17-L41</td>
    <td align="right">1</td>
    <td align="right">2524</td>
    <td align="right">14719</td>
  </tr>
  <tr valign="top">
    <td align="right">109</td>
    <td align="left">{&quot;output&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class BindableSolrParameter {  	private final int index; 	private final Object value; 	private float boost;  	public BindableSolrParameter(int index, Object value) { 		super(); 		this.index = index; 		this.value = value; 	}  	public float getBoost() { 		return boost; 	}  	public void setBoost(float boost) { 		this.boost = boost; 	}  	public int getIndex() { 		return index; 	}  	public Object getValue() { 		return value; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1442</td>
    <td align="left">https://github.com/spring-projects/spring-data-solr/blob/6db215cf28337895ec40ed28082fa895846680bb/src/main/java/org/springframework/data/solr/repository/query/BindableSolrParameter.java/#L24-L52</td>
    <td align="right">1</td>
    <td align="right">109</td>
    <td align="right">1442</td>
  </tr>
  <tr valign="top">
    <td align="right">2308</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ConsoleProxyClientParam {     private String clientHostAddress;     private int clientHostPort;     private String clientHostPassword;     private String clientTag;     private String ticket;     private String locale;     private String clientTunnelUrl;     private String clientTunnelSession;      private String hypervHost;      private String ajaxSessionId;     private String username;     private String password;      public ConsoleProxyClientParam() {         clientHostPort = 0;     }      public String getClientHostAddress() {         return clientHostAddress;     }      public void setClientHostAddress(String clientHostAddress) {         this.clientHostAddress = clientHostAddress;     }      public int getClientHostPort() {         return clientHostPort;     }      public void setClientHostPort(int clientHostPort) {         this.clientHostPort = clientHostPort;     }      public String getClientHostPassword() {         return clientHostPassword;     }      public void setClientHostPassword(String clientHostPassword) {         this.clientHostPassword = clientHostPassword;     }      public String getClientTag() {         return clientTag;     }      public void setClientTag(String clientTag) {         this.clientTag = clientTag;     }      public String getTicket() {         return ticket;     }      public void setTicket(String ticket) {         this.ticket = ticket;     }      public String getClientTunnelUrl() {         return clientTunnelUrl;     }      public void setClientTunnelUrl(String clientTunnelUrl) {         this.clientTunnelUrl = clientTunnelUrl;     }      public String getClientTunnelSession() {         return clientTunnelSession;     }      public void setClientTunnelSession(String clientTunnelSession) {         this.clientTunnelSession = clientTunnelSession;     }      public String getAjaxSessionId() {         return ajaxSessionId;     }      public void setAjaxSessionId(String ajaxSessionId) {         this.ajaxSessionId = ajaxSessionId;     }      public String getLocale() {         return locale;     }      public void setLocale(String locale) {         this.locale = locale;     }      public String getClientMapKey() {         if (clientTag != null &amp;&amp; !clientTag.isEmpty())             return clientTag;          return clientHostAddress + &quot;:&quot; + clientHostPort;     }      public void setHypervHost(String host) {         hypervHost = host;     }      public String getHypervHost() {         return hypervHost;     }      public void setUsername(String username) {         this.username = username;      }      public String getUsername() {         return username;     }      public void setPassword(String password) {         this.password = password;     }      public String getPassword() {         return password;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14094</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/server/src/main/java/com/cloud/servlet/ConsoleProxyClientParam.java/#L20-L143</td>
    <td align="right">1</td>
    <td align="right">2308</td>
    <td align="right">14094</td>
  </tr>
  <tr valign="top">
    <td align="right">2222</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;response&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class AtlasPerfTracer {     protected final Logger logger;     protected final String tag;     private   final long   startTimeMs;      private static long reportingThresholdMs = 0L;      public static Logger getPerfLogger(String name) {         return LoggerFactory.getLogger(&quot;org.apache.atlas.perf.&quot; + name);     }      public static Logger getPerfLogger(Class cls) {         return AtlasPerfTracer.getPerfLogger(cls.getName());     }      public static boolean isPerfTraceEnabled(Logger logger) {         return logger.isDebugEnabled();     }      public static AtlasPerfTracer getPerfTracer(Logger logger, String tag) {         return new AtlasPerfTracer(logger, tag);     }      public static void log(AtlasPerfTracer tracer) {         if (tracer != null) {             tracer.log();         }     }      private AtlasPerfTracer(Logger logger, String tag) {         this.logger = logger;         this.tag    = tag;         startTimeMs = System.currentTimeMillis();     }      public String getTag() {         return tag;     }      public long getStartTime() {         return startTimeMs;     }      public long getElapsedTime() {         return System.currentTimeMillis() - startTimeMs;     }      public void log() {         long elapsedTime = getElapsedTime();         if (elapsedTime &gt; reportingThresholdMs) {             logger.debug(&quot;PERF|{}|{}&quot;, tag, elapsedTime);         }     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13559</td>
    <td align="left">https://github.com/apache/atlas/blob/af1719a3472d1d436d0fc685fe9f88d8a754ef94/common/src/main/java/org/apache/atlas/utils/AtlasPerfTracer.java/#L27-L80</td>
    <td align="right">1</td>
    <td align="right">2222</td>
    <td align="right">13559</td>
  </tr>
  <tr valign="top">
    <td align="right">2564</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detectedBadSmells&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Customer223 {  	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id; 	private String firstName; 	private String lastName;  	protected Customer223() {}  	public Customer223(String firstName, String lastName) { 		this.firstName = firstName; 		this.lastName = lastName; 	}  	@Override 	public String toString() { 		return String.format(&quot;Customer223[id=%d, firstName='%s', lastName='%s']&quot;, id, firstName, lastName); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14847</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer223.java/#L8-L27</td>
    <td align="right">1</td>
    <td align="right">2564</td>
    <td align="right">14847</td>
  </tr>
  <tr valign="top">
    <td align="right">2330</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@APICommand(name = &quot;extractTemplate&quot;, description = &quot;Extracts a template&quot;, responseObject = ExtractResponse.class,         requestHasSensitiveInfo = false, responseHasSensitiveInfo = false) public class ExtractTemplateCmd extends BaseAsyncCmd {     public static final Logger s_logger = Logger.getLogger(ExtractTemplateCmd.class.getName());      private static final String s_name = &quot;extracttemplateresponse&quot;;      /////////////////////////////////////////////////////     //////////////// API parameters /////////////////////     /////////////////////////////////////////////////////      @Parameter(name = ApiConstants.ID, type = CommandType.UUID, entityType = TemplateResponse.class, required = true, description = &quot;the ID of the template&quot;)     private Long id;      @Parameter(name = ApiConstants.URL, type = CommandType.STRING, required = false, length = 2048, description = &quot;the url to which the ISO would be extracted&quot;)     private String url;      @Parameter(name = ApiConstants.ZONE_ID,                type = CommandType.UUID,                entityType = ZoneResponse.class,                required = false,                description = &quot;the ID of the zone where the ISO is originally located&quot;)     private Long zoneId;      @Parameter(name = ApiConstants.MODE, type = CommandType.STRING, required = true, description = &quot;the mode of extraction - HTTP_DOWNLOAD or FTP_UPLOAD&quot;)     private String mode;      /////////////////////////////////////////////////////     /////////////////// Accessors ///////////////////////     /////////////////////////////////////////////////////      public Long getId() {         return id;     }      public String getUrl() {         return url;     }      public Long getZoneId() {         return zoneId;     }      public String getMode() {         return mode;     }      /////////////////////////////////////////////////////     /////////////// API Implementation///////////////////     /////////////////////////////////////////////////////      @Override     public String getCommandName() {         return s_name;     }      public static String getStaticName() {         return s_name;     }      @Override     public long getEntityOwnerId() {         VirtualMachineTemplate template = _entityMgr.findById(VirtualMachineTemplate.class, getId());         if (template != null) {             return template.getAccountId();         }          // invalid id, parent this command to SYSTEM so ERROR events are tracked         return Account.ACCOUNT_ID_SYSTEM;     }      @Override     public String getEventType() {         return EventTypes.EVENT_TEMPLATE_EXTRACT;     }      @Override     public String getEventDescription() {      return &quot;extracting template: &quot; + this._uuidMgr.getUuid(VirtualMachineTemplate.class, getId()) + ((getZoneId() != null) ? &quot; from zone: &quot; + this._uuidMgr.getUuid(DataCenter.class, getZoneId()) : &quot;&quot;);     }      @Override     public ApiCommandJobType getInstanceType() {         return ApiCommandJobType.Template;     }      @Override     public Long getInstanceId() {         return getId();     }      @Override     public void execute() {         try {             CallContext.current().setEventDetails(getEventDescription());             String uploadUrl = _templateService.extract(this);             if (uploadUrl != null) {                 ExtractResponse response = _responseGenerator.createExtractResponse(id, zoneId, getEntityOwnerId(), mode, uploadUrl);                 response.setResponseName(getCommandName());                 this.setResponseObject(response);             } else {                 throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, &quot;Failed to extract template&quot;);             }         } catch (InternalErrorException ex) {             s_logger.warn(&quot;Exception: &quot;, ex);             throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());         }     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14150</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/api/src/main/java/org/apache/cloudstack/api/command/user/template/ExtractTemplateCmd.java/#L39-L147</td>
    <td align="right">1</td>
    <td align="right">2330</td>
    <td align="right">14150</td>
  </tr>
  <tr valign="top">
    <td align="right">914</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Long Method&quot;,       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  @XmlAccessorType(XmlAccessType.FIELD)   @XmlType(name = &quot;&quot;, propOrder = {&quot;gateways&quot;})   public static class GatewayHub {      @XmlElement(name = &quot;gateway&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)     protected List gateways;     @XmlAttribute(name = &quot;id&quot;, required = true)     protected String id;     @XmlAttribute(name = &quot;bind-address&quot;)     protected String bindAddress;     @XmlAttribute(name = &quot;maximum-time-between-pings&quot;)     protected String maximumTimeBetweenPings;     @XmlAttribute(name = &quot;port&quot;)     protected String port;     @XmlAttribute(name = &quot;socket-buffer-size&quot;)     protected String socketBufferSize;     @XmlAttribute(name = &quot;startup-policy&quot;)     protected String startupPolicy;     @XmlAttribute(name = &quot;manual-start&quot;)     protected Boolean manualStart;     @XmlAttribute(name = &quot;max-connections&quot;)     protected BigInteger maxConnections;      /**      * Gets the value of the gateway property.      *      *       * This accessor method returns a reference to the live list,      * not a snapshot. Therefore any modification you make to the      * returned list will be present inside the JAXB object.      * This is why there is not a set method for the gateway property.      *      *       * For example, to add a new item, do as follows:      *      *       * getGateway().add(newItem);      *       *      *      *       * Objects of the following type(s) are allowed in the list      * {@link CacheConfig.GatewayHub.Gateway }      *      *      */     public List getGateway() {       if (gateways == null) {         gateways = new ArrayList();       }       return this.gateways;     }      /**      * Gets the value of the id property.      *      * possible object is      * {@link String }      *      */     public String getId() {       return id;     }      /**      * Sets the value of the id property.      *      * allowed object is      * {@link String }      *      */     public void setId(String value) {       this.id = value;     }      /**      * Gets the value of the bindAddress property.      *      * possible object is      * {@link String }      *      */     public String getBindAddress() {       return bindAddress;     }      /**      * Sets the value of the bindAddress property.      *      * allowed object is      * {@link String }      *      */     public void setBindAddress(String value) {       this.bindAddress = value;     }      /**      * Gets the value of the maximumTimeBetweenPings property.      *      * possible object is      * {@link String }      *      */     public String getMaximumTimeBetweenPings() {       return maximumTimeBetweenPings;     }      /**      * Sets the value of the maximumTimeBetweenPings property.      *      * allowed object is      * {@link String }      *      */     public void setMaximumTimeBetweenPings(String value) {       this.maximumTimeBetweenPings = value;     }      /**      * Gets the value of the port property.      *      * possible object is      * {@link String }      *      */     public String getPort() {       return port;     }      /**      * Sets the value of the port property.      *      * allowed object is      * {@link String }      *      */     public void setPort(String value) {       this.port = value;     }      /**      * Gets the value of the socketBufferSize property.      *      * possible object is      * {@link String }      *      */     public String getSocketBufferSize() {       return socketBufferSize;     }      /**      * Sets the value of the socketBufferSize property.      *      * allowed object is      * {@link String }      *      */     public void setSocketBufferSize(String value) {       this.socketBufferSize = value;     }      /**      * Gets the value of the startupPolicy property.      *      * possible object is      * {@link String }      *      */     public String getStartupPolicy() {       return startupPolicy;     }      /**      * Sets the value of the startupPolicy property.      *      * allowed object is      * {@link String }      *      */     public void setStartupPolicy(String value) {       this.startupPolicy = value;     }      /**      * Gets the value of the manualStart property.      *      * possible object is      * {@link Boolean }      *      */     public Boolean isManualStart() {       return manualStart;     }      /**      * Sets the value of the manualStart property.      *      * allowed object is      * {@link Boolean }      *      */     public void setManualStart(Boolean value) {       this.manualStart = value;     }      /**      * Gets the value of the maxConnections property.      *      * possible object is      * {@link BigInteger }      *      */     public BigInteger getMaxConnections() {       return maxConnections;     }      /**      * Sets the value of the maxConnections property.      *      * allowed object is      * {@link BigInteger }      *      */     public void setMaxConnections(BigInteger value) {       this.maxConnections = value;     }       /**      *       * Java class for anonymous complex type.      *      *       * The following schema fragment specifies the expected content contained within this class.      *      *       * &lt;complexType&gt;      *   &lt;complexContent&gt;      *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;      *       &lt;sequence&gt;      *         &lt;choice&gt;      *           &lt;element name=&quot;gateway-endpoint&quot; maxOccurs=&quot;unbounded&quot;&gt;      *             &lt;complexType&gt;      *               &lt;complexContent&gt;      *                 &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;      *                   &lt;attribute name=&quot;host&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                   &lt;attribute name=&quot;id&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                   &lt;attribute name=&quot;port&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;/restriction&gt;      *               &lt;/complexContent&gt;      *             &lt;/complexType&gt;      *           &lt;/element&gt;      *           &lt;element name=&quot;gateway-listener&quot; maxOccurs=&quot;unbounded&quot;&gt;      *             &lt;complexType&gt;      *               &lt;complexContent&gt;      *                 &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;      *                   &lt;sequence&gt;      *                     &lt;element name=&quot;class-name&quot; type=&quot;{http://geode.apache.org/schema/cache}class-name-type&quot;/&gt;      *                     &lt;element name=&quot;parameter&quot; type=&quot;{http://geode.apache.org/schema/cache}parameter-type&quot; maxOccurs=&quot;unbounded&quot; minOccurs=&quot;0&quot;/&gt;      *                   &lt;/sequence&gt;      *                 &lt;/restriction&gt;      *               &lt;/complexContent&gt;      *             &lt;/complexType&gt;      *           &lt;/element&gt;      *         &lt;/choice&gt;      *         &lt;element name=&quot;gateway-queue&quot; minOccurs=&quot;0&quot;&gt;      *           &lt;complexType&gt;      *             &lt;complexContent&gt;      *               &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;      *                 &lt;attribute name=&quot;alert-threshold&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;batch-conflation&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;      *                 &lt;attribute name=&quot;batch-size&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;batch-time-interval&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;enable-persistence&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;      *                 &lt;attribute name=&quot;disk-store-name&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;roll-oplogs&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;      *                 &lt;attribute name=&quot;maximum-queue-memory&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;overflow-directory&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *               &lt;/restriction&gt;      *             &lt;/complexContent&gt;      *           &lt;/complexType&gt;      *         &lt;/element&gt;      *       &lt;/sequence&gt;      *       &lt;attribute name=&quot;early-ack&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;      *       &lt;attribute name=&quot;id&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *       &lt;attribute name=&quot;socket-buffer-size&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *       &lt;attribute name=&quot;socket-read-timeout&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *       &lt;attribute name=&quot;concurrency-level&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *       &lt;attribute name=&quot;order-policy&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *     &lt;/restriction&gt;      *   &lt;/complexContent&gt;      * &lt;/complexType&gt;      *       *      *      */     @XmlAccessorType(XmlAccessType.FIELD)     @XmlType(name = &quot;&quot;, propOrder = {&quot;gatewayEndpoints&quot;, &quot;gatewayListeners&quot;, &quot;gatewayQueue&quot;})     public static class Gateway {        @XmlElement(name = &quot;gateway-endpoint&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)       protected List gatewayEndpoints;       @XmlElement(name = &quot;gateway-listener&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)       protected List gatewayListeners;       @XmlElement(name = &quot;gateway-queue&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)       protected CacheConfig.GatewayHub.Gateway.GatewayQueue gatewayQueue;       @XmlAttribute(name = &quot;early-ack&quot;)       protected Boolean earlyAck;       @XmlAttribute(name = &quot;id&quot;, required = true)       protected String id;       @XmlAttribute(name = &quot;socket-buffer-size&quot;)       protected String socketBufferSize;       @XmlAttribute(name = &quot;socket-read-timeout&quot;)       protected String socketReadTimeout;       @XmlAttribute(name = &quot;concurrency-level&quot;)       protected String concurrencyLevel;       @XmlAttribute(name = &quot;order-policy&quot;)       protected String orderPolicy;        /**        * Gets the value of the gatewayEndpoints property.        *        *         * This accessor method returns a reference to the live list,        * not a snapshot. Therefore any modification you make to the        * returned list will be present inside the JAXB object.        * This is why there is not a set method for the gatewayEndpoints property.        *        *         * For example, to add a new item, do as follows:        *        *         * getGatewayEndpoints().add(newItem);        *         *        *        *         * Objects of the following type(s) are allowed in the list        * {@link CacheConfig.GatewayHub.Gateway.GatewayEndpoint }        *        *        */       public List getGatewayEndpoints() {         if (gatewayEndpoints == null) {           gatewayEndpoints = new ArrayList();         }         return this.gatewayEndpoints;       }        /**        * Gets the value of the gatewayListeners property.        *        *         * This accessor method returns a reference to the live list,        * not a snapshot. Therefore any modification you make to the        * returned list will be present inside the JAXB object.        * This is why there is not a set method for the gatewayListeners property.        *        *         * For example, to add a new item, do as follows:        *        *         * getGatewayListeners().add(newItem);        *         *        *        *         * Objects of the following type(s) are allowed in the list        * {@link DeclarableType }        *        *        */       public List getGatewayListeners() {         if (gatewayListeners == null) {           gatewayListeners = new ArrayList();         }         return this.gatewayListeners;       }        /**        * Gets the value of the gatewayQueue property.        *        * possible object is        * {@link CacheConfig.GatewayHub.Gateway.GatewayQueue }        *        */       public CacheConfig.GatewayHub.Gateway.GatewayQueue getGatewayQueue() {         return gatewayQueue;       }        /**        * Sets the value of the gatewayQueue property.        *        * allowed object is        * {@link CacheConfig.GatewayHub.Gateway.GatewayQueue }        *        */       public void setGatewayQueue(CacheConfig.GatewayHub.Gateway.GatewayQueue value) {         this.gatewayQueue = value;       }        /**        * Gets the value of the earlyAck property.        *        * possible object is        * {@link Boolean }        *        */       public Boolean isEarlyAck() {         return earlyAck;       }        /**        * Sets the value of the earlyAck property.        *        * allowed object is        * {@link Boolean }        *        */       public void setEarlyAck(Boolean value) {         this.earlyAck = value;       }        /**        * Gets the value of the id property.        *        * possible object is        * {@link String }        *        */       public String getId() {         return id;       }        /**        * Sets the value of the id property.        *        * allowed object is        * {@link String }        *        */       public void setId(String value) {         this.id = value;       }        /**        * Gets the value of the socketBufferSize property.        *        * possible object is        * {@link String }        *        */       public String getSocketBufferSize() {         return socketBufferSize;       }        /**        * Sets the value of the socketBufferSize property.        *        * allowed object is        * {@link String }        *        */       public void setSocketBufferSize(String value) {         this.socketBufferSize = value;       }        /**        * Gets the value of the socketReadTimeout property.        *        * possible object is        * {@link String }        *        */       public String getSocketReadTimeout() {         return socketReadTimeout;       }        /**        * Sets the value of the socketReadTimeout property.        *        * allowed object is        * {@link String }        *        */       public void setSocketReadTimeout(String value) {         this.socketReadTimeout = value;       }        /**        * Gets the value of the concurrencyLevel property.        *        * possible object is        * {@link String }        *        */       public String getConcurrencyLevel() {         return concurrencyLevel;       }        /**        * Sets the value of the concurrencyLevel property.        *        * allowed object is        * {@link String }        *        */       public void setConcurrencyLevel(String value) {         this.concurrencyLevel = value;       }        /**        * Gets the value of the orderPolicy property.        *        * possible object is        * {@link String }        *        */       public String getOrderPolicy() {         return orderPolicy;       }        /**        * Sets the value of the orderPolicy property.        *        * allowed object is        * {@link String }        *        */       public void setOrderPolicy(String value) {         this.orderPolicy = value;       }         /**        *         * Java class for anonymous complex type.        *        *         * The following schema fragment specifies the expected content contained within this class.        *        *         * &lt;complexType&gt;        *   &lt;complexContent&gt;        *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;        *       &lt;attribute name=&quot;host&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;id&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;port&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *     &lt;/restriction&gt;        *   &lt;/complexContent&gt;        * &lt;/complexType&gt;        *         *        *        */       @XmlAccessorType(XmlAccessType.FIELD)       @XmlType(name = &quot;&quot;)       public static class GatewayEndpoint {          @XmlAttribute(name = &quot;host&quot;, required = true)         protected String host;         @XmlAttribute(name = &quot;id&quot;, required = true)         protected String id;         @XmlAttribute(name = &quot;port&quot;, required = true)         protected String port;          /**          * Gets the value of the host property.          *          * possible object is          * {@link String }          *          */         public String getHost() {           return host;         }          /**          * Sets the value of the host property.          *          * allowed object is          * {@link String }          *          */         public void setHost(String value) {           this.host = value;         }          /**          * Gets the value of the id property.          *          * possible object is          * {@link String }          *          */         public String getId() {           return id;         }          /**          * Sets the value of the id property.          *          * allowed object is          * {@link String }          *          */         public void setId(String value) {           this.id = value;         }          /**          * Gets the value of the port property.          *          * possible object is          * {@link String }          *          */         public String getPort() {           return port;         }          /**          * Sets the value of the port property.          *          * allowed object is          * {@link String }          *          */         public void setPort(String value) {           this.port = value;         }        }        /**        *         * Java class for anonymous complex type.        *        *         * The following schema fragment specifies the expected content contained within this class.        *        *         * &lt;complexType&gt;        *   &lt;complexContent&gt;        *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;        *       &lt;attribute name=&quot;alert-threshold&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;batch-conflation&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;        *       &lt;attribute name=&quot;batch-size&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;batch-time-interval&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;enable-persistence&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;        *       &lt;attribute name=&quot;disk-store-name&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;roll-oplogs&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;        *       &lt;attribute name=&quot;maximum-queue-memory&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;overflow-directory&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *     &lt;/restriction&gt;        *   &lt;/complexContent&gt;        * &lt;/complexType&gt;        *         *        *        */       @XmlAccessorType(XmlAccessType.FIELD)       @XmlType(name = &quot;&quot;)       public static class GatewayQueue {          @XmlAttribute(name = &quot;alert-threshold&quot;)         protected String alertThreshold;         @XmlAttribute(name = &quot;batch-conflation&quot;)         protected Boolean batchConflation;         @XmlAttribute(name = &quot;batch-size&quot;)         protected String batchSize;         @XmlAttribute(name = &quot;batch-time-interval&quot;)         protected String batchTimeInterval;         @XmlAttribute(name = &quot;enable-persistence&quot;)         protected Boolean enablePersistence;         @XmlAttribute(name = &quot;disk-store-name&quot;)         protected String diskStoreName;         @XmlAttribute(name = &quot;roll-oplogs&quot;)         protected Boolean rollOplogs;         @XmlAttribute(name = &quot;maximum-queue-memory&quot;)         protected String maximumQueueMemory;         @XmlAttribute(name = &quot;overflow-directory&quot;)         protected String overflowDirectory;          /**          * Gets the value of the alertThreshold property.          *          * possible object is          * {@link String }          *          */         public String getAlertThreshold() {           return alertThreshold;         }          /**          * Sets the value of the alertThreshold property.          *          * allowed object is          * {@link String }          *          */         public void setAlertThreshold(String value) {           this.alertThreshold = value;         }          /**          * Gets the value of the batchConflation property.          *          * possible object is          * {@link Boolean }          *          */         public Boolean isBatchConflation() {           return batchConflation;         }          /**          * Sets the value of the batchConflation property.          *          * allowed object is          * {@link Boolean }          *          */         public void setBatchConflation(Boolean value) {           this.batchConflation = value;         }          /**          * Gets the value of the batchSize property.          *          * possible object is          * {@link String }          *          */         public String getBatchSize() {           return batchSize;         }          /**          * Sets the value of the batchSize property.          *          * allowed object is          * {@link String }          *          */         public void setBatchSize(String value) {           this.batchSize = value;         }          /**          * Gets the value of the batchTimeInterval property.          *          * possible object is          * {@link String }          *          */         public String getBatchTimeInterval() {           return batchTimeInterval;         }          /**          * Sets the value of the batchTimeInterval property.          *          * allowed object is          * {@link String }          *          */         public void setBatchTimeInterval(String value) {           this.batchTimeInterval = value;         }          /**          * Gets the value of the enablePersistence property.          *          * possible object is          * {@link Boolean }          *          */         public Boolean isEnablePersistence() {           return enablePersistence;         }          /**          * Sets the value of the enablePersistence property.          *          * allowed object is          * {@link Boolean }          *          */         public void setEnablePersistence(Boolean value) {           this.enablePersistence = value;         }          /**          * Gets the value of the diskStoreName property.          *          * possible object is          * {@link String }          *          */         public String getDiskStoreName() {           return diskStoreName;         }          /**          * Sets the value of the diskStoreName property.          *          * allowed object is          * {@link String }          *          */         public void setDiskStoreName(String value) {           this.diskStoreName = value;         }          /**          * Gets the value of the rollOplogs property.          *          * possible object is          * {@link Boolean }          *          */         public Boolean isRollOplogs() {           return rollOplogs;         }          /**          * Sets the value of the rollOplogs property.          *          * allowed object is          * {@link Boolean }          *          */         public void setRollOplogs(Boolean value) {           this.rollOplogs = value;         }          /**          * Gets the value of the maximumQueueMemory property.          *          * possible object is          * {@link String }          *          */         public String getMaximumQueueMemory() {           return maximumQueueMemory;         }          /**          * Sets the value of the maximumQueueMemory property.          *          * allowed object is          * {@link String }          *          */         public void setMaximumQueueMemory(String value) {           this.maximumQueueMemory = value;         }          /**          * Gets the value of the overflowDirectory property.          *          * possible object is          * {@link String }          *          */         public String getOverflowDirectory() {           return overflowDirectory;         }          /**          * Sets the value of the overflowDirectory property.          *          * allowed object is          * {@link String }          *          */         public void setOverflowDirectory(String value) {           this.overflowDirectory = value;         }        }      }    }</td>
    <td align="left">data class</td>
    <td align="left">'Long Method', 'Data Class'</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">{',L,o,n,g,&quot; &quot;,M,e,t,h,o,d,',&quot;,&quot;,&quot; &quot;,',D,a,t,a,&quot; &quot;,C,l,a,s,s,'}</td>
    <td align="left">{',o,n,g,&quot; &quot;,M,t,h,o,d,',&quot;,&quot;,&quot; &quot;,',D,t,&quot; &quot;,C,'}</td>
    <td align="right">0</td>
    <td align="right">8245</td>
    <td align="left">https://github.com/apache/geode/blob/8fd839e8b73e40bd2dfd14f331b587431bd35a66/geode-management/src/main/java/org/apache/geode/cache/configuration/CacheConfig.java/#L1636-L2524</td>
    <td align="right">1</td>
    <td align="right">914</td>
    <td align="right">8245</td>
  </tr>
  <tr valign="top">
    <td align="right">2041</td>
    <td align="left">&nbsp;YES, I found bad smells. The bad smells are:  1. Feature envy: the methods within the GridMBeanServerData class are mostly only accessing and manipulating data within that class, which suggests that these methods should be moved into the class itself to avoid feature envy. 2. Long method: the GridMBeanServerData constructor, while not excessively long, could still benefit from being broken down into smaller methods for clarity and maintainability. 3. Magic numbers: the value for the initial capacity in the HashSet creation is a magic number and should be given a descriptive variable name. 4. No encapsulation: the fields in the GridMBeanServerData class are set to public, which could lead to potential issues if these fields are accidentally manipulated by external classes. </td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
        private static class GridMBeanServerData {             /** Set of grid names for selected MBeanServer. */             private Collection igniteInstanceNames = new HashSet&lt;&gt;();              /** */             private ObjectName mbean;              /** Count of grid instances. */             private int cnt;              /**              * Create data container.              *              * @param mbean Object name of MBean.              */             GridMBeanServerData(ObjectName mbean) {                 assert mbean != null;                  this.mbean = mbean;             }              /**              * Add Ignite instance name.              *              * @param igniteInstanceName Ignite instance name.              */             public void addIgniteInstance(String igniteInstanceName) {                 igniteInstanceNames.add(igniteInstanceName);             }              /**              * Remove Ignite instance name.              *              * @param igniteInstanceName Ignite instance name.              */             public void removeIgniteInstance(String igniteInstanceName) {                 igniteInstanceNames.remove(igniteInstanceName);             }              /**              * Returns {@code true} if data contains the specified              * Ignite instance name.              *              * @param igniteInstanceName Ignite instance name.              * @return {@code true} if data contains the specified Ignite instance name.              */             public boolean containsIgniteInstance(String igniteInstanceName) {                 return igniteInstanceNames.contains(igniteInstanceName);             }              /**              * Gets name used in MBean server.              *              * @return Object name of MBean.              */             public ObjectName getMbean() {                 return mbean;             }              /**              * Gets number of grid instances working with MBeanServer.              *              * @return Number of grid instances.              */             public int getCounter() {                 return cnt;             }              /**              * Sets number of grid instances working with MBeanServer.              *              * @param cnt Number of grid instances.              */             public void setCounter(int cnt) {                 this.cnt = cnt;             }         }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Feature envy: the methods within the GridMBeanServerData class are mostly only accessing and manipulating data within that class, which suggests that these methods should be moved into the class itself to avoid feature envy2 Long method: the GridMBeanServerData constructor, while not excessively long, could still benefit from being broken down into smaller methods for clarity and maintainability3 Magic numbers: the value for the initial capacity in the HashSet creation is a magic number and should be given a descriptive variable name4 No encapsulation: the fields in the GridMBeanServerData class are set to public, which could lead to potential issues if these fields are accidentally manipulated by external classes</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;which suggests that these methods should be moved into the class itself to avoid feature envy.2. Long method: the GridMBeanServerData constructor,  while not excessively long,  which could lead to potential issues if these fields are accidentally manipulated by external classes.</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12853</td>
    <td align="left">https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/core/src/main/java/org/apache/ignite/internal/IgnitionEx.java/#L2796-L2872</td>
    <td align="right">2</td>
    <td align="right">2041</td>
    <td align="right">12853</td>
  </tr>
  <tr valign="top">
    <td align="right">1242</td>
    <td align="left">&nbsp;&nbsp;&nbsp;	{   		&quot;message&quot;: &quot;YES, I found bad smells&quot;,   		&quot;detected_bad_smells&quot;: [   			&quot;1. Blob&quot;,   			&quot;2. Data Class&quot;   		]   	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class NexmarkQueryTransform     extends PTransform, PCollection&gt; {    private transient PCollection&gt; sideInput = null;    protected NexmarkQueryTransform(String name) {     super(name);   }    /** Whether this query expects a side input to be populated. Defaults to {@code false}. */   public boolean needsSideInput() {     return false;   }    /**    * Set the side input for the query.    *    * Note that due to the nature of side inputs, this instance of the query is now fixed and can    * only be safely applied in the pipeline where the side input was created.    */   public void setSideInput(PCollection&gt; sideInput) {     this.sideInput = sideInput;   }    /** Get the side input, if any. */   public @Nullable PCollection&gt; getSideInput() {     return sideInput;   } }</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10414</td>
    <td align="left">https://github.com/apache/beam/blob/a956ff77a8448e5f2c12f6695fec608348b5ab60/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/NexmarkQueryTransform.java/#L34-L62</td>
    <td align="right">1</td>
    <td align="right">1242</td>
    <td align="right">10414</td>
  </tr>
  <tr valign="top">
    <td align="right">2689</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Builder {  	public static boolean isForced(Map options) { 		return Boolean.TRUE.equals(options.get(&quot;force&quot;)); 	}  	private Properties options = new Properties(); 	private BuilderExtension[] extensions = new BuilderExtension[0];  	private Logger logger = new NullLogger(); 	private ConfigurationRegistry registry; 	private ConfigObject configObject = null; 	private boolean isIncremental = false; 	private boolean enabledMetadata = false;  	private File sourceDir = null;  	/** 	 * The value is a String[] containing the relative paths of all of the build 	 * files for a given sourceDir. 	 */ 	private final Map buildFilesBySourceDir = new HashMap&lt;&gt;(); 	/*[PR 118220] Incremental builder is not called when file is deleted in base library*/ 	private final Map&gt; deleteFilesBySourceDir = new HashMap&lt;&gt;(); 	private final Map&gt; buildResourcesBySourceDir = new HashMap&lt;&gt;();  	private int buildFileCount = 0; 	private int deleteFileCount = 0; 	private int builtFileCount = 0; 	private int buildResourcesCount = 0; 	private File outputDir = null; 	private boolean verdict = false; 	private boolean includeIfUnsure = false; 	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 	private boolean isTestsBootPath = false; 	private boolean noWarnIncludeIf = false; 	private boolean noWarnInvalidFlags = false; 	private boolean multipleSources = false; 	private boolean updateAllCopyrights = false;  	/** 	 * J9 JCL Preprocessor builder constructor.  Initializes the needed extensions. 	 */ 	public Builder() { 		addExtension(new ExternalMessagesExtension()); 		addExtension(new MacroExtension()); 		addExtension(new JxeRulesExtension()); 		addExtension(new EclipseMetadataExtension()); 		addExtension(new JitAttributesExtension()); 		addExtension(new TagExtension()); 	}  	/** 	 * Sets the preprocess options. 	 * 	 * @param 		options		the preprocess options 	 */ 	public void setOptions(Properties options) { 		if (options != null) { 			this.options.putAll(options); 		} 		this.options = options; 	}  	/** 	 * Returns the preprocess options for this builder. 	 * 	 * @return		the preprocess options 	 */ 	public Properties getOptions() { 		return this.options; 	}  	/** 	 * Adds an extension to the builder. 	 * 	 * @param 		extension	the extension to add 	 */ 	public void addExtension(BuilderExtension extension) { 		if (extension == null) { 			throw new NullPointerException(); 		}  		BuilderExtension[] newExtensions = new BuilderExtension[extensions.length + 1]; 		if (extensions.length &gt; 0) { 			System.arraycopy(extensions, 0, newExtensions, 0, extensions.length); 		} 		newExtensions[newExtensions.length - 1] = extension; 		this.extensions = newExtensions;  		extension.setBuilder(this); 	}  	/** 	 * Returns the builder extensions/ 	 * 	 * @return		the builder extensions 	 */ 	public BuilderExtension[] getExtensions() { 		return extensions; 	}  	/** 	 * Returns the logger associated with this builder. 	 * 	 * @return		the logger 	 */ 	public Logger getLogger() { 		return logger; 	}  	/** 	 * Sets this builder's logger. 	 * 	 * @param 		logger		the new logger 	 */ 	public void setLogger(Logger logger) { 		this.logger = logger; 	}  	/** 	 * Sets whether the build is incremental or not. 	 * 	 * @param 		isIncremental	true if the build is incremental, false otherwise 	 */ 	public void setIncremental(boolean isIncremental) { 		this.isIncremental = isIncremental; 	}  	/** 	 * Returns wheter or not this builder will only do an incremental build. 	 * 	 * @return		true if the build is incremental, false otherwise 	 */ 	public boolean isIncremental() { 		return this.isIncremental; 	}  	/** 	 * Sets whether or not preprocessor metadata will be generated. 	 * 	 * @param 		enabledMetadata		true if metadata is to be generated, 	 * 									false otherwise 	 */ 	public void setMetadata(boolean enabledMetadata) { 		this.enabledMetadata = enabledMetadata; 	}  	/** 	 * Returns whether or not preprocessor metadata is enabled. 	 * 	 * @return		true if metadata will be written, false otherwise 	 */ 	public boolean isMetadataEnabled() { 		return this.enabledMetadata; 	}  	/** 	 * Sets whether or not the preprocessor should include files that do not 	 * have a INCLUDE-IF tag. 	 * 	 * @param 		include		true if files with no INCLUDE-IF should 	 * 							be included, false otherwise 	 */ 	public void setIncludeIfUnsure(boolean include) { 		this.includeIfUnsure = include; 	}  	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 	/** 	 * Sets whether or not the preprocessor is running to generate Tests Boot Path project 	 * 	 * @param 	isTestsBoot		true if preprocessor is running to generate Tests Boot Path project, 	 * 							false otherwise 	 */ 	public void setIsTestsBoot(boolean isTestsBoot) { 		this.isTestsBootPath = isTestsBoot; 	}  	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 	/** 	 * Sets whether or not the preprocessor should give warningsor errors about the files that do not 	 * have a INCLUDE-IF tag. 	 * 	 * @param 		warning		true if files with no INCLUDE-IF should 	 * 							be marked with warning or error, false otherwise 	 */ 	public void setNoWarnIncludeIf(boolean warning) { 		this.noWarnIncludeIf = warning; 	}  	/** 	 * Sets the configuration to preprocess. 	 * 	 * @param 		config		the configuration to preprocess 	 */ 	public void setConfiguration(ConfigObject config) { 		if (config.isSet()) { 			System.err.println(&quot;Warning: Builder is using &quot; + config + &quot;, a set, not a configuration.&quot;); 		} 		this.configObject = config; 		this.registry = config.getRegistry(); 		this.outputDir = config.getOutputDir(); 	}  	/** 	 * Returns this builder's output directory. 	 * 	 * @return		the output directory 	 */ 	public File getOutputDir() { 		return this.outputDir; 	}  	/** 	 * Sets this builder's output directory. 	 * 	 * @param 		outputDir	the new output directory 	 */ 	public void setOutputDir(File outputDir) { 		if (outputDir == null) { 			throw new NullPointerException(); 		} 		this.outputDir = outputDir; 	}  	/** 	 * Returns this builder's configuration source directories. 	 * 	 * @return		the config's source dirs 	 */ 	public File getSourceDir() { 		return this.sourceDir; 	}  	/** 	 * Sets the proprocess job's source directory. 	 * 	 * @param 		sourceDir	the source directory to preprocess 	 */ 	public void setSourceDir(File sourceDir) { 		if (sourceDir == null) { 			throw new NullPointerException(); 		} else { 			this.sourceDir = sourceDir; 		} 	}  	/** 	 * Set builder aware of other sources (to be used by the ExternalMessagesExtension). 	 * 	 * @param 		multipleSources		true if there are other sources, false otherwise 	 */ 	public void setMultipleSources(boolean multipleSources) { 		this.multipleSources = multipleSources; 	}  	/** 	 * Returns whether or not the configuration that setup this builder has multiple sources. 	 * 	 * @return		true if there are other sources, false otherwise 	 */ 	public boolean hasMultipleSources() { 		return multipleSources; 	}  	/** 	 * Performs the build. 	 */ 	public boolean build() { 		//create output dir even if no file is gonna be included in preprocess 		getOutputDir().mkdirs(); 		if (validateOptions()) { 			computeBuildFiles(); 			notifyBuildBegin();  			PreprocessorFactory factory = newPreprocessorFactory(); 			boolean force = isForced(this.options);  			//Ignore folders that do not exist (warning thrown in computeBuildFiles() 			if (sourceDir != null) { 				File metadataDir = new File(outputDir.getParentFile(), &quot;jppmd&quot;); 				String[] buildFiles = buildFilesBySourceDir.get(sourceDir); 				getLogger().log(&quot;\nPreprocessing &quot; + sourceDir.getAbsolutePath(), 1); 				builtFileCount = 0;  				for (String buildFile : buildFiles) { 					File sourceFile = new File(sourceDir, buildFile); 					File outputFile = new File(outputDir, buildFile); 					File metadataFile = new File(metadataDir, buildFile + &quot;.jppmd&quot;);  					notifyBuildFileBegin(sourceFile, outputFile, buildFile);  					try (OutputStream metadataOutput = new PhantomOutputStream(metadataFile); 						 OutputStream output = new PhantomOutputStream(outputFile, force)) {  						// configure the preprocessor and let extensions do the same 						JavaPreprocessor jpp;  						if (enabledMetadata) { 							jpp = factory.newPreprocessor(metadataOutput, sourceFile, output, outputFile); 						} else { 							jpp = factory.newPreprocessor(sourceFile, output); 						}  						Calendar cal = new GregorianCalendar(); 						if (!updateAllCopyrights) { 							cal.setTime(new Date(sourceFile.lastModified())); 						} 						jpp.setCopyrightYear(cal.get(Calendar.YEAR)); 						jpp.addValidFlags(registry.getValidFlags()); 						/*[PR 120411] Use a javadoc tag instead of TestBootpath preprocessor tag*/ 						jpp.setTestBootPath(isTestsBootPath); 						notifyConfigurePreprocessor(jpp);  						// preprocess 						boolean included = false; 						try { 							included = jpp.preprocess(); 							if (included) { 								builtFileCount++; 							} 							handlePreprocessorWarnings(jpp, sourceFile); 						} catch (Throwable t) { 							handlePreprocessorException(t, sourceFile); 						}  						if (!included &amp;&amp; outputFile.exists()) { 							outputFile.delete(); 						}  						if (!included &amp;&amp; metadataFile.exists()) { 							metadataFile.delete(); 						} 					} catch (Throwable t) { 						getLogger().log(&quot;Exception occured in file &quot; + sourceFile.getAbsolutePath() + &quot;, preprocess failed.&quot;, 3, t); 						handleBuildException(t); 					} finally { 						notifyBuildFileEnd(sourceFile, outputFile, buildFile); 					} 				}  				logger.log(builtFileCount + &quot; of &quot; + buildFileCount + &quot; file(s) included in preprocess&quot;, 1);  				/*[PR 118220] Incremental builder is not called when file is deleted in base library*/ 				List deleteFiles = deleteFilesBySourceDir.get(sourceDir); 				if (deleteFiles != null &amp;&amp; deleteFiles.size() != 0) { 					int deletedFilesCount = 0; 					for (String file : deleteFiles) { 						File deleteFile = new File(outputDir, file); 						if (deleteFile.exists()) { 							deletedFilesCount++; 							deleteFile.delete(); 						} 					} 					getLogger().log(deletedFilesCount + &quot; of &quot; + deleteFileCount 							+ &quot; file(s) deleted in preprocess from &quot; + outputDir.getAbsolutePath(), 1); 				} 			} 			/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 			List buildResources = buildResourcesBySourceDir.get(sourceDir); 			if (buildResources != null &amp;&amp; buildResources.size() != 0) { 				int copiedResourcesCount = 0; 				int deletedResorucesCount = 0; 				String outputpath; 				if (isTestsBootPath) { 					outputpath = configObject.getBootTestsOutputPath(); 				} else { 					outputpath = configObject.getTestsOutputPath(); 				} 				for (String file : buildResources) { 					File resource_out = new File(outputpath, file); 					File resource_src = new File(sourceDir, file); 					if (resource_src.exists()) { 						copyResource(resource_src, resource_out); 						copiedResourcesCount++; 					} else { 						resource_out.delete(); 						deletedResorucesCount++; 					} 				}  				getLogger().log(&quot;Total Build Resource Count : &quot; + buildResourcesCount, 1); 				getLogger().log(&quot;  - &quot; + copiedResourcesCount + &quot; resource&quot; + (copiedResourcesCount &gt; 1 ? &quot;s are &quot; : &quot; is &quot;) + &quot;copied to &quot; + outputpath, 1); 				getLogger().log(&quot;  - &quot; + deletedResorucesCount + &quot; resource&quot; + (deletedResorucesCount &gt; 1 ? &quot;s are &quot; : &quot; is &quot;) + &quot;deleted from &quot; + outputpath, 1); 			}  			notifyBuildEnd(); 		}  		if (logger.getErrorCount() == 0) { 			if (verdict) { 				getLogger().log(&quot;PREPROCESS WAS SUCCESSFUL&quot;, 1); 			} 			return true; 		} else { 			if (verdict) { 				getLogger().log(&quot;PREPROCESS WAS NOT SUCCESSFUL&quot;, 1); 			} 			return false; 		} 	}  	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 	public static void copyResource(File source, File destination) { 		destination.delete();  		try { 			SimpleCopy.copyFile(source, destination); 		} catch (IOException e) { 			System.err.println(&quot;ERROR - Could not copy the file to destination&quot;); 			System.err.println(&quot;   Source: &quot; + source.toString()); 			System.err.println(&quot;   Destination: &quot; + destination.toString()); 			e.printStackTrace(); 		} 	}  	/** 	 * Validates the build options. 	 */ 	private boolean validateOptions() { 		boolean isValid = true;  		if (configObject == null) { 			configObject = registry.getConfiguration(options.getProperty(&quot;config&quot;)); 		} 		this.options.putAll(configObject.getOptions());  		// check for the verdict option 		if (options.containsKey(&quot;verdict&quot;)) { 			this.verdict = true; 		}  		if (options.containsKey(&quot;includeifunsure&quot;)) { 			setIncludeIfUnsure(true); 		} 		if (options.containsKey(&quot;nowarnincludeif&quot;)) { 			setNoWarnIncludeIf(true); 		}  		if (options.containsKey(&quot;nowarninvalidflags&quot;)) { 			this.noWarnInvalidFlags = true; 		}  		if (options.containsKey(&quot;updateallcopyrights&quot;)) { 			this.updateAllCopyrights = true; 		}  		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				extension.validateOptions(this.options); 			} 		} catch (BuilderConfigurationException e) { 			logger.log(&quot;A configuration exception occured&quot;, Logger.SEVERITY_FATAL, e); 			isValid = false; 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking validateOptions() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 		return isValid; 	}  	/** 	 * Notifies the extensions that the build is beginning. 	 */ 	private void notifyBuildBegin() { 		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyBuildBegin(); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyBuildBegin() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Notifies the extensions that the build is ending. 	 */ 	private void notifyBuildEnd() { 		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyBuildEnd(); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyBuildEnd() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Notifies the extensions that the build is beginning on the specified 	 * file. 	 */ 	private void notifyBuildFileBegin(File sourceFile, File outputFile, String relativePath) { 		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyBuildFileBegin(sourceFile, outputFile, relativePath); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyBuildFileBegin() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Notifies the extensions that the build is ending on the specified file. 	 */ 	private void notifyBuildFileEnd(File sourceFile, File outputFile, String relativePath) { 		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyBuildFileEnd(sourceFile, outputFile, relativePath); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyBuildFileEnd() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Notifies the extensions that they should configure the preprocessor. 	 */ 	private void notifyConfigurePreprocessor(JavaPreprocessor preprocessor) { 		preprocessor.setIncludeIfUnsure(this.includeIfUnsure); 		preprocessor.setNoWarnIncludeIf(this.noWarnIncludeIf);  		// call the method for all the extensions 		String extensionName = &quot;&quot;; 		try { 			for (BuilderExtension extension : extensions) { 				extensionName = extension.getName(); 				logger.setMessageSource(extensionName); 				extension.notifyConfigurePreprocessor(preprocessor); 				logger.setMessageSource(null); 			} 		} catch (Exception e) { 			StringBuffer buffer = new StringBuffer(&quot;An exception occured while invoking notifyConfigurePreprocessor() for the extension \&quot;&quot;); 			buffer.append(extensionName); 			buffer.append(&quot;\&quot;&quot;); 			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e); 		} 	}  	/** 	 * Handles exceptions thrown while building. 	 */ 	private void handleBuildException(Throwable t) { 		if (t instanceof Error) { 			logger.log(&quot;An error occured while building&quot;, Logger.SEVERITY_FATAL, t); 			throw (Error) t; 		} else { 			logger.log(&quot;An exception occured while building&quot;, Logger.SEVERITY_ERROR, t); 		} 	}  	/** 	 * Handles exceptions thrown by the preprocessor. 	 */ 	private void handlePreprocessorException(Throwable t, File sourceFile) { 		if (t instanceof Error) { 			logger.log(&quot;An error occured while invoking the preprocessor&quot;, &quot;preprocessor&quot;, Logger.SEVERITY_FATAL, sourceFile, t); 			throw (Error) t; 		} else { 			logger.log(&quot;An exception occured while invoking the preprocessor&quot;, &quot;preprocessor&quot;, Logger.SEVERITY_ERROR, sourceFile, t); 		} 	}  	/** 	 * Handles warnings generated by the preprocessor. 	 */ 	private void handlePreprocessorWarnings(JavaPreprocessor jpp, File sourceFile) { 		if (jpp.hasWarnings()) { 			for (PreprocessorWarning warning : jpp.getWarnings()) { 				int severity = warning.shouldFail() ? Logger.SEVERITY_ERROR : Logger.SEVERITY_WARNING; 				/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 				if (warning.getMessage().startsWith(&quot;No INCLUDE-IF&quot;) &amp;&amp; sourceFile.getAbsolutePath().endsWith(&quot;.java&quot;) &amp;&amp; !includeIfUnsure &amp;&amp; !isTestsBootPath) { 					severity = Logger.SEVERITY_ERROR; 				}  				if (warning.getMessage().startsWith(&quot;Ignoring copyright&quot;)) { 					severity = Logger.SEVERITY_INFO; 				}  				logger.log(warning.getMessage(), &quot;preprocessor&quot;, severity, sourceFile, warning.getLine(), warning.getCharstart(), warning.getCharend()); 			} 		}  		if (!noWarnInvalidFlags) { 			for (PreprocessorWarning warning : jpp.getInvalidFlags()) { 				logger.log(warning.getMessage(), &quot;preprocessor&quot;, Logger.SEVERITY_ERROR, sourceFile, warning.getLine(), warning.getCharstart(), warning.getCharend()); 			} 		} 	}  	/** 	 * Determines whether the specified source file should be built. 	 */ 	private boolean shouldBuild(File sourceFile, File outputFile, String relativePath) { 		// call the method for all the extensions 		for (BuilderExtension extension : extensions) { 			logger.setMessageSource(extension.getName()); 			boolean shouldBuild = extension.shouldBuild(sourceFile, outputFile, relativePath); 			logger.setMessageSource(null); 			if (!shouldBuild) { 				return false; 			} 		}  		return true; 	}  	/*[PR 118220] Incremental builder is not called when file is deleted in base library*/ 	/** 	 * Returns the deleted Files 	 */ 	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 	private List getDeletedFiles(File sourceDir) { 		// call the method for all the extensions 		for (BuilderExtension extension : extensions) { 			logger.setMessageSource(extension.getName()); 			List elements = extension.getDeleteFiles(sourceDir); 			logger.setMessageSource(null); 			if (elements != null) { 				return elements; 			} 		}  		return null; 	}  	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 	private List getBuildResources(File sourceDir) { 		// call the method for all the extensions 		for (BuilderExtension extension : extensions) { 			logger.setMessageSource(extension.getName()); 			List elements = extension.getBuildResources(sourceDir); 			logger.setMessageSource(null); 			if (elements != null) { 				return elements; 			} 		} 		return null; 	}  	/** 	 * Creates a new PreprocessorFactory object. 	 */ 	private PreprocessorFactory newPreprocessorFactory() { 		PreprocessorFactory factory = new PreprocessorFactory(); 		/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/ 		factory.setFlags(this.configObject.getFlagsAsArray()); 		factory.setRequiredIncludeFlags(this.configObject.getRequiredIncludeFlagSet()); 		return factory; 	}  	/** 	 * Recursively searches the given root directory to find all files. The file 	 * paths are returned, relative to the root directory. 	 */ 	private List getFiles(File rootDirectory) { 		List fileList = new ArrayList&lt;&gt;(); 		File[] files = rootDirectory.listFiles();  		if (files == null) { 			StringBuffer msg = new StringBuffer(&quot;Error reading the source directory \&quot;&quot;); 			msg.append(rootDirectory.getAbsolutePath()); 			msg.append(&quot;\&quot; - No Files copied&quot;); 			getLogger().log(msg.toString(), 2); 			verdict = false; 		} else { 			getFiles(files, &quot;&quot;, fileList); 		}  		return fileList; 	}  	/** 	 * This is a helper function to getFiles(File); 	 */ 	private static void getFiles(File[] files, String relativePath, List fileList) { 		for (File file : files) { 			if (file.isFile()) { 				fileList.add(relativePath + file.getName()); 			} else { 				String childRelativePath = relativePath + file.getName() + File.separator; 				getFiles(file.listFiles(), childRelativePath, fileList); 			} 		} 	}  	private void computeBuildFiles() { 		if (sourceDir.exists()) { 			List allFiles = getFiles(sourceDir); 			List buildFiles = new ArrayList&lt;&gt;(allFiles.size()); 			for (int j = 0; j &lt; allFiles.size(); j++) { 				String currentFile = allFiles.get(j).toString(); 				if (shouldBuild(sourceDir, outputDir, currentFile)) { 					buildFiles.add(currentFile); 				} 			}  			String[] buildFilesArray = buildFiles.toArray(new String[buildFiles.size()]); 			buildFilesBySourceDir.put(sourceDir, buildFilesArray); 			buildFileCount += buildFilesArray.length; 			/*[PR 118220] Incremental builder is not called when file is deleted in base library*/ 			/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */ 			List deleteFiles = getDeletedFiles(sourceDir); 			if (deleteFiles != null &amp;&amp; deleteFiles.size() != 0) { 				deleteFileCount = deleteFiles.size(); 				deleteFilesBySourceDir.put(sourceDir, deleteFiles); 			}  			List buildResources = getBuildResources(sourceDir); 			if (buildResources != null &amp;&amp; buildResources.size() != 0) { 				buildResourcesCount = buildResources.size(); 				buildResourcesBySourceDir.put(sourceDir, buildResources); 			} 		} else { 			logger.log(&quot;Error: Source directory does not exist: &quot; + sourceDir.getAbsolutePath(), Logger.SEVERITY_ERROR, new NullPointerException()); 			sourceDir = null; 		} 	}  	/** 	 * Returns the number of files preprocessed. 	 * 	 * @return		the number of files preprocessed 	 */ 	public int getBuildFileCount() { 		return buildFileCount; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15284</td>
    <td align="left">https://github.com/eclipse/openj9/blob/4911084853eb75b20e037c434ad4521b7317ebfb/sourcetools/com.ibm.jpp.preprocessor/com/ibm/jpp/om/Builder.java/#L41-L806</td>
    <td align="right">1</td>
    <td align="right">2689</td>
    <td align="right">15284</td>
  </tr>
  <tr valign="top">
    <td align="right">2341</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{             &quot;response&quot;: &quot;YES I found bad smells&quot;,             &quot;detected_bad_smells&quot;: [                 &quot;Blob&quot;,                 &quot;Data Class&quot;             ]         }  </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
final class AvlNode&gt; {     AvlNode parent = null;     AvlNode left = null;     AvlNode right = null;      int height = 0;     int balance = 0;     T value = null;       AvlNode( AvlNode parent, T value )     {         this.parent = parent;         this.value = value;     }       public AvlNode reset( AvlNode parent, T value )     {         this.parent = parent;         left = null;         right = null;          height = 0;         this.value = value;          return this;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14178</td>
    <td align="left">https://github.com/apache/directory-server/blob/310007cc1c7eb5415f93bed67d5553bc70980820/core-avl/src/main/java/org/apache/directory/server/core/avltree/avl/AvlNode.java/#L29-L58</td>
    <td align="right">1</td>
    <td align="right">2341</td>
    <td align="right">14178</td>
  </tr>
  <tr valign="top">
    <td align="right">630</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;the bad smells are&quot;: [           &quot;Data Class&quot;,           &quot;Long Method&quot;         ]       }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface ReplicatedLevelDBStoreViewMBean {      @MBeanInfo(&quot;The address of the ZooKeeper server.&quot;)     String getZkAddress();     @MBeanInfo(&quot;The path in ZooKeeper to hold master elections.&quot;)     String getZkPath();     @MBeanInfo(&quot;The ZooKeeper session timeout.&quot;)     String getZkSessionTimeout();     @MBeanInfo(&quot;The address and port the master will bind for the replication protocol.&quot;)     String getBind();     @MBeanInfo(&quot;The number of replication nodes that will be part of the replication cluster.&quot;)     int getReplicas();      @MBeanInfo(&quot;The role of this node in the replication cluster.&quot;)     String getNodeRole();      @MBeanInfo(&quot;The replication status.&quot;)     String getStatus();      @MBeanInfo(&quot;The status of the connected slaves.&quot;)     CompositeData[] getSlaves();      @MBeanInfo(&quot;The current position of the replication log.&quot;)     Long getPosition();      @MBeanInfo(&quot;When the last entry was added to the replication log.&quot;)     Long getPositionDate();      @MBeanInfo(&quot;The directory holding the data.&quot;)     String getDirectory();      @MBeanInfo(&quot;The sync strategy to use.&quot;)     String getSync();      @MBeanInfo(&quot;The node id of this replication node.&quot;)     String getNodeId(); }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6286</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-leveldb-store/src/main/java/org/apache/activemq/leveldb/replicated/ReplicatedLevelDBStoreViewMBean.java/#L30-L66</td>
    <td align="right">1</td>
    <td align="right">630</td>
    <td align="right">6286</td>
  </tr>
  <tr valign="top">
    <td align="right">1163</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }  </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class _AdministrationWebServiceSoap_QueryBuildAgentsByUri     implements ElementSerializable {     // No attributes          // Elements     protected String[] agentUris;      public _AdministrationWebServiceSoap_QueryBuildAgentsByUri()     {         super();     }      public _AdministrationWebServiceSoap_QueryBuildAgentsByUri(final String[] agentUris)     {         // TODO : Call super() instead of setting all fields directly?         setAgentUris(agentUris);     }      public String[] getAgentUris()     {         return this.agentUris;     }      public void setAgentUris(String[] value)     {         this.agentUris = value;     }      public void writeAsElement(         final XMLStreamWriter writer,         final String name)         throws XMLStreamException     {         writer.writeStartElement(name);          // Elements         if (this.agentUris != null)         {             /*              * The element type is an array.              */             writer.writeStartElement(&quot;agentUris&quot;);              for (int iterator0 = 0; iterator0 &lt; this.agentUris.length; iterator0++)             {                 XMLStreamWriterHelper.writeElement(                     writer,                     &quot;string&quot;,                     this.agentUris[iterator0]);             }              writer.writeEndElement();         }          writer.writeEndElement();     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10179</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core.ws/generated-src/ms/tfs/build/buildservice/_03/_AdministrationWebServiceSoap_QueryBuildAgentsByUri.java/#L31-L88</td>
    <td align="right">1</td>
    <td align="right">1163</td>
    <td align="right">10179</td>
  </tr>
  <tr valign="top">
    <td align="right">4</td>
    <td align="left">{&quot;response&quot;:&quot;YES I found bad smells&quot;,&quot;bad smells are&quot;:[&quot;Long Method&quot;,&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MailChimpServiceImpl implements MailChimpService {      private static Logger logger = LoggerFactory.getLogger(MailChimpServiceImpl.class);      private static final String ACCEPT = &quot;Accept&quot;;     private static final String AUTHORIZATION = &quot;Authorization&quot;;     private static final String LISTS = &quot;lists&quot;;     private static final String ID = &quot;id&quot;;     private static final String NAME = &quot;name&quot;;     private static final String MERGE_FIELDS = &quot;merge_fields&quot;;     private static final String EMAIL_TYPE = &quot;email_type&quot;;     private static final String EMAIL_ADDRESS = &quot;email_address&quot;;     private static final String EMAIL = &quot;email&quot;;     private static final String ERRORS = &quot;errors&quot;;     private static final String LIST_IDENTIFIER = &quot;listIdentifier&quot;;     private static final String STATUS = &quot;status&quot;;     private static final String SUBSCRIBED = &quot;subscribed&quot;;     private static final String UNSUBSCRIBED = &quot;unsubscribed&quot;;     private static final String TAG = &quot;tag&quot;;     private static final String TYPE = &quot;type&quot;;     private static final String UNOMI_ID = &quot;unomiId&quot;;     private static final String MC_SUB_TAG_NAME = &quot;mcSubTagName&quot;;     private static final String ADDR_1 = &quot;addr1&quot;;     private static final String ADDR_2 = &quot;addr2&quot;;     private static final String CITY = &quot;city&quot;;     private static final String COUNTRY = &quot;country&quot;;     private static final String STATE = &quot;state&quot;;     private static final String ZIP = &quot;zip&quot;;     private static final String ADDRESS = &quot;address&quot;;     private static final String DATE_FORMAT = &quot;date_format&quot;;     private static final String OPTIONS = &quot;options&quot;;     private static final String DATE = &quot;date&quot;;     private static final String MC_MM_DD_YYYY = &quot;MM/DD/YYYY&quot;;     private static final String MM_DD_YYYY = &quot;MM/dd/yyyy&quot;;     private static final String DD_MM_YYYY = &quot;dd/MM/yyyy&quot;;     private static final String BIRTHDAY = &quot;birthday&quot;;     private static final String MC_MM_DD = &quot;MM/DD&quot;;     private static final String MM_DD = &quot;MM/dd&quot;;     private static final String DD_MM = &quot;dd/MM&quot;;     private static final String SEPARATOR_CHARS_PROPERTIES = &quot;,&quot;;     private static final String SEPARATOR_CHARS_PROPERTY = &quot;&lt;=&gt;&quot;;      private String apiKey;     private String urlSubDomain;     private Map&gt;&gt; listMergeFieldMapping;     private Boolean isMergeFieldsActivate;     private CloseableHttpClient httpClient;       @Override     public List&gt; getAllLists() {         List&gt; mcLists = new ArrayList&lt;&gt;();         if (isMailChimpConnectorConfigured()) {             JsonNode response = HttpUtils.executeGetRequest(httpClient, getBaseUrl() + &quot;/lists&quot;, getHeaders(), false);             if (response != null) {                 if (response.has(LISTS) &amp;&amp; response.get(LISTS).size() &gt; 0) {                     for (JsonNode list : response.get(LISTS)) {                         if (list.has(ID) &amp;&amp; list.has(NAME)) {                             HashMap mcListInfo = new HashMap&lt;&gt;();                             mcListInfo.put(ID, list.get(ID).asText());                             mcListInfo.put(NAME, list.get(NAME).asText());                             mcLists.add(mcListInfo);                         } else {                             logger.warn(&quot;Missing mandatory information for list, {}&quot;, list.asText());                         }                     }                 } else {                     logger.debug(&quot;No list to return, response was {}&quot;, response.asText());                 }             }         }         return mcLists;     }      @Override     public MailChimpResult addToMCList(Profile profile, Action action) {         if (!isMailChimpConnectorConfigured() || profile.getProperty(EMAIL) == null) {             logger.error(&quot;The visitor does not have an email address&quot;);             return MailChimpResult.ERROR;         }          String listIdentifier = (String) action.getParameterValues().get(LIST_IDENTIFIER);         JsonNode currentMember = isMemberOfMailChimpList(profile, listIdentifier);         JSONObject mergeFields = new JSONObject();          if (currentMember != null &amp;&amp; currentMember.has(STATUS)) {             JSONObject body = new JSONObject();             if (currentMember.get(STATUS).asText().equals(UNSUBSCRIBED)) {                 logger.debug(&quot;The visitor is already in the MailChimp list, his status is unsubscribed&quot;);                 body.put(STATUS, SUBSCRIBED);             }              if (isMergeFieldsActivate &amp;&amp; addProfilePropertiesToMergeFieldsObject(profile, listIdentifier, mergeFields) == MailChimpResult.SUCCESS) {                 body.put(MERGE_FIELDS, mergeFields);             }             return updateSubscription(listIdentifier, body.toString(), currentMember, true);         }          JSONObject userData = new JSONObject();         userData.put(EMAIL_TYPE, &quot;html&quot;);         userData.put(EMAIL_ADDRESS, profile.getProperty(EMAIL).toString());         userData.put(STATUS, SUBSCRIBED);          if (isMergeFieldsActivate) {             addProfilePropertiesToMergeFieldsObject(profile, listIdentifier, mergeFields);         }         userData.put(MERGE_FIELDS, mergeFields);          JsonNode response = HttpUtils.executePostRequest(httpClient, getBaseUrl() + &quot;/lists/&quot; + listIdentifier + &quot;/members&quot;, getHeaders(), userData.toString());         if (response == null || (response.has(ERRORS) &amp;&amp; response.get(ERRORS).size() &gt; 0)) {             logger.error(&quot;Error when adding user to MailChimp list, list identifier was {} and response was {}&quot;, listIdentifier, response);             return MailChimpResult.ERROR;         }          return MailChimpResult.UPDATED;     }      @Override     public MailChimpResult removeFromMCList(Profile profile, Action action) {         if (!isMailChimpConnectorConfigured() || profile.getProperty(EMAIL) == null) {             return MailChimpResult.ERROR;         }          String listIdentifier = (String) action.getParameterValues().get(LIST_IDENTIFIER);         if (StringUtils.isBlank(listIdentifier)) {             logger.warn(&quot;Couldn't get the list identifier from Unomi&quot;);             return MailChimpResult.ERROR;         }          JsonNode currentMember = isMemberOfMailChimpList(profile, listIdentifier);         if (currentMember == null) {             return MailChimpResult.NO_CHANGE;         }          JsonNode response = HttpUtils.executeDeleteRequest(httpClient, getBaseUrl() + &quot;/lists/&quot; + listIdentifier + &quot;/members/&quot; + currentMember.get(ID).asText(), getHeaders());         if (response == null || (response.has(ERRORS) &amp;&amp; response.get(ERRORS).size() &gt; 0)) {             logger.error(&quot;Couldn't remove the visitor from the MailChimp list, list identifier was {} and response was {}&quot;, listIdentifier, response);             return MailChimpResult.ERROR;         }          return MailChimpResult.REMOVED;     }      @Override     public MailChimpResult unsubscribeFromMCList(Profile profile, Action action) {         if (!isMailChimpConnectorConfigured() || profile.getProperty(EMAIL) == null) {             return MailChimpResult.ERROR;         }          String listIdentifier = (String) action.getParameterValues().get(LIST_IDENTIFIER);         if (StringUtils.isBlank(listIdentifier)) {             logger.warn(&quot;Couldn't get the list identifier from Unomi&quot;);             return MailChimpResult.ERROR;         }          JsonNode currentMember = isMemberOfMailChimpList(profile, listIdentifier);         if (currentMember == null) {             return MailChimpResult.REMOVED;         }         if (currentMember.get(STATUS).asText().equals(UNSUBSCRIBED)) {             return MailChimpResult.NO_CHANGE;         }          JSONObject body = new JSONObject();         body.put(STATUS, UNSUBSCRIBED);         return updateSubscription(listIdentifier, body.toString(), currentMember, false);     }       @Override     public MailChimpResult updateMCProfileProperties(Profile profile, Action action) {         if (!isMailChimpConnectorConfigured() || profile.getProperty(EMAIL) == null) {             return MailChimpResult.ERROR;         }          String listIdentifier = (String) action.getParameterValues().get(LIST_IDENTIFIER);         if (StringUtils.isBlank(listIdentifier)) {             logger.warn(&quot;MailChimp list identifier not found&quot;);             return MailChimpResult.ERROR;         }          JsonNode currentMember = isMemberOfMailChimpList(profile, listIdentifier);         if (currentMember == null) {             logger.warn(&quot;The visitor was not part of the list&quot;);             return MailChimpResult.NO_CHANGE;         }           JSONObject mergeFields = new JSONObject();         MailChimpResult result = addProfilePropertiesToMergeFieldsObject(profile, listIdentifier, mergeFields);         if (result != MailChimpResult.SUCCESS) {             return result;         }          JSONObject body = new JSONObject();         body.put(MERGE_FIELDS, mergeFields);          JsonNode response = HttpUtils.executePatchRequest(httpClient, getBaseUrl() + &quot;/lists/&quot; + listIdentifier + &quot;/members/&quot; + currentMember.get(ID).asText(), getHeaders(), body.toString());         if (response == null || (response.has(ERRORS) &amp;&amp; response.get(ERRORS).size() &gt; 0)) {             logger.error(&quot;Error when updating visitor properties to MailChimp list, list identifier was {} and response was {}&quot;, listIdentifier, response);             return MailChimpResult.ERROR;         }          return MailChimpResult.UPDATED;     }      private MailChimpResult addProfilePropertiesToMergeFieldsObject(Profile profile, String listIdentifier, JSONObject mergeFields) {         if (listMergeFieldMapping.isEmpty()) {             logger.error(&quot;List of merge fields is not correctly configured&quot;);             return MailChimpResult.ERROR;         }          JsonNode mergeFieldsDefinitions = getMCListProperties(listIdentifier);         if (mergeFieldsDefinitions == null) {             logger.error(&quot;Could not get MailChimp list's merge fields&quot;);             return MailChimpResult.ERROR;         }          for (JsonNode mergeFieldDefinition : mergeFieldsDefinitions.get(MERGE_FIELDS)) {             if (mergeFieldDefinition.has(TAG) &amp;&amp; mergeFieldDefinition.has(TYPE)) {                 String mcTagName = mergeFieldDefinition.get(TAG).asText();                 if (listMergeFieldMapping.containsKey(mcTagName)) {                     List&gt; fields = listMergeFieldMapping.get(mcTagName);                     for (Map fieldInfo : fields) {                         String unomiId = fieldInfo.get(UNOMI_ID);                         if (profile.getProperty(unomiId) != null) {                             switch (mergeFieldDefinition.get(TYPE).asText()) {                                 case ADDRESS:                                     if (mergeFields.has(mcTagName)) {                                         mergeFields.getJSONObject(mcTagName).put(fieldInfo.get(MC_SUB_TAG_NAME), profile.getProperty(unomiId));                                     } else {                                         JSONObject address = new JSONObject();                                         address.put(ADDR_1, &quot;&quot;);                                         address.put(ADDR_2, &quot;&quot;);                                         address.put(CITY, &quot;&quot;);                                         address.put(COUNTRY, &quot;&quot;);                                         address.put(STATE, &quot;&quot;);                                         address.put(ZIP, &quot;&quot;);                                         address.put(fieldInfo.get(MC_SUB_TAG_NAME), profile.getProperty(unomiId));                                         mergeFields.put(mcTagName, address);                                     }                                     break;                                 case DATE:                                     if (mergeFieldDefinition.has(OPTIONS) &amp;&amp; mergeFieldDefinition.get(OPTIONS).has(DATE_FORMAT)) {                                         mergeFields.put(mcTagName, formatDate(mergeFieldDefinition.get(OPTIONS).get(DATE_FORMAT).asText(), profile.getProperty(unomiId)));                                     }                                     break;                                 case BIRTHDAY:                                     if (mergeFieldDefinition.has(OPTIONS) &amp;&amp; mergeFieldDefinition.get(OPTIONS).has(DATE_FORMAT)) {                                         mergeFields.put(mcTagName, formatDate(mergeFieldDefinition.get(OPTIONS).get(DATE_FORMAT).asText(), profile.getProperty(unomiId)));                                     }                                     break;                                 default:                                     mergeFields.put(mcTagName, profile.getProperty(unomiId));                                     break;                             }                         }                     }                     if (mergeFieldDefinition.get(TYPE).asText().equals(ADDRESS) &amp;&amp; mergeFields.has(mcTagName)                             &amp;&amp; (StringUtils.isBlank(mergeFields.getJSONObject(mcTagName).get(ADDR_1).toString())                             || StringUtils.isBlank(mergeFields.getJSONObject(mcTagName).get(ZIP).toString())                             || StringUtils.isBlank(mergeFields.getJSONObject(mcTagName).get(CITY).toString())                             || StringUtils.isBlank(mergeFields.getJSONObject(mcTagName).get(COUNTRY).toString()))) {                         mergeFields.remove(mcTagName);                         logger.debug(&quot;Can't map the address property {}, one of the mandatory field is missing (addr1, zip, city, country)&quot;, mcTagName);                     }                 } else {                     logger.debug(&quot;Found property {} in MC list, if you need this property please update mapping or add the property to your MC list&quot;, mcTagName);                 }             }         }          return MailChimpResult.SUCCESS;     }      private String formatDate(String mcDateFormat, Object date) {         DateTime dateTime = new DateTime(date);         if (StringUtils.contains(mcDateFormat, &quot;/YYYY&quot;)) {             return DateTimeFormat.forPattern((mcDateFormat.equals(MC_MM_DD_YYYY) ? MM_DD_YYYY : DD_MM_YYYY)).print(dateTime);         } else {             return DateTimeFormat.forPattern((mcDateFormat.equals(MC_MM_DD) ? MM_DD : DD_MM)).print(dateTime);         }     }       private JsonNode getMCListProperties(String listIdentifier) {         JsonNode currentMergeFields = HttpUtils.executeGetRequest(httpClient, getBaseUrl() + &quot;/lists/&quot; + listIdentifier + &quot;/merge-fields&quot;, getHeaders(), false);         if (currentMergeFields == null || !currentMergeFields.has(MERGE_FIELDS)) {             logger.error(&quot;Can't find merge_fields from the response, the response was {}&quot;, currentMergeFields);             return null;         }          return currentMergeFields;     }       private void initHttpClient() {         if (httpClient == null) {             httpClient = HttpUtils.initHttpClient();         }     }      private boolean isMailChimpConnectorConfigured() {         if (StringUtils.isNotBlank(apiKey) &amp;&amp; StringUtils.isNotBlank(urlSubDomain)) {             initHttpClient();             return true;         }         logger.error(&quot;MailChimp extension isn't correctly configured, please check cfg file.&quot;);         return false;     }      private JsonNode isMemberOfMailChimpList(Profile profile, String listIdentifier) {         String email = profile.getProperty(EMAIL).toString().toLowerCase();         String md5Hex = DigestUtils.md5Hex(email);          JsonNode response = HttpUtils.executeGetRequest(httpClient, getBaseUrl() + &quot;/lists/&quot; + listIdentifier + &quot;/members/&quot; + md5Hex, getHeaders(), true);         if (response != null) {             if (response.has(EMAIL_ADDRESS)) {                 if (response.get(EMAIL_ADDRESS).asText().toLowerCase().equals(email)) {                     return response;                 }             }         }         return null;     }      private MailChimpResult updateSubscription(String listIdentifier, String jsonData, JsonNode member, boolean toSubscribe) {         JsonNode response = HttpUtils.executePatchRequest(httpClient, getBaseUrl() + &quot;/lists/&quot; + listIdentifier + &quot;/members/&quot; + member.get(ID).asText(), getHeaders(), jsonData);         if (response != null) {             if (response.has(STATUS)) {                 String responseStatus = response.get(STATUS).asText();                 if ((toSubscribe &amp;&amp; responseStatus.equals(SUBSCRIBED)) || (!toSubscribe &amp;&amp; responseStatus.equals(UNSUBSCRIBED))) {                     return MailChimpResult.UPDATED;                 } else {                     return MailChimpResult.NO_CHANGE;                 }             }         }         logger.error(&quot;Couldn't update the subscription of the visitor&quot;);         return MailChimpResult.ERROR;     }      private String getBaseUrl() {         return &quot;https://&quot; + urlSubDomain + &quot;.api.mailchimp.com/3.0&quot;;     }      private HashMap getHeaders() {         HashMap headers = new HashMap&lt;&gt;();         headers.put(ACCEPT, &quot;application/json&quot;);         headers.put(AUTHORIZATION, &quot;apikey &quot; + apiKey);         return headers;     }      public void setApiKey(String apiKey) {         this.apiKey = apiKey;     }      public void setUrlSubDomain(String urlSubDomain) {         this.urlSubDomain = urlSubDomain;     }      public void setListMergeFieldMapping(String listMergeFields) {         this.listMergeFieldMapping = new HashMap&lt;&gt;();         if (StringUtils.isNotBlank(listMergeFields)) {             String mergeFields[] = StringUtils.split(listMergeFields, SEPARATOR_CHARS_PROPERTIES);             if (mergeFields.length &gt; 0) {                 for (String mergeField : mergeFields) {                     if (StringUtils.isNotBlank(mergeField)) {                         String mergeFieldInfo[] = StringUtils.split(mergeField, SEPARATOR_CHARS_PROPERTY);                         if (mergeFieldInfo.length &gt; 0) {                             Map fieldInfo = new HashMap&lt;&gt;();                             fieldInfo.put(UNOMI_ID, mergeFieldInfo[0]);                             if (mergeFieldInfo.length == 3) {                                 fieldInfo.put(MC_SUB_TAG_NAME, mergeFieldInfo[2]);                             }                              String mcTagName = mergeFieldInfo[1];                             if (listMergeFieldMapping.containsKey(mcTagName)) {                                 listMergeFieldMapping.get(mcTagName).add(fieldInfo);                             } else {                                 List&gt; fields = new ArrayList&lt;&gt;();                                 fields.add(fieldInfo);                                 listMergeFieldMapping.put(mcTagName, fields);                             }                         }                     }                 }             }         }     }      public void setIsMergeFieldsActivate(Boolean isMergeFieldsActivate) {         this.isMergeFieldsActivate = isMergeFieldsActivate;     } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">555</td>
    <td align="left">https://github.com/apache/unomi/blob/1745c5221401a05e66ebf80fbe9cce2790442b3a/extensions/unomi-mailchimp/services/src/main/java/org/apache/unomi/mailchimp/services/internal/MailChimpServiceImpl.java/#L40-L434</td>
    <td align="right">1</td>
    <td align="right">4</td>
    <td align="right">555</td>
  </tr>
  <tr valign="top">
    <td align="right">117</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ThymeleafAnnotationValues extends AbstractAnnotationValues {    @AutoPopulate   private String[] excludeMethods;    @AutoPopulate   private String[] excludeViews;    /**    * Constructor    *    * @param governorPhysicalTypeMetadata    */   public ThymeleafAnnotationValues(final PhysicalTypeMetadata governorPhysicalTypeMetadata) {     super(governorPhysicalTypeMetadata, ROO_THYMELEAF);     AutoPopulationUtils.populate(this, annotationMetadata);   }     public String[] getExcludeMethods() {     return excludeMethods;   }    public String[] getExcludeViews() {     return excludeViews;   }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1507</td>
    <td align="left">https://github.com/spring-projects/spring-roo/blob/4a2e9f1eb17d4e49ad947503a63afef7d5a37842/addon-web-mvc-thymeleaf/addon/src/main/java/org/springframework/roo/addon/web/mvc/thymeleaf/addon/ThymeleafAnnotationValues.java/#L17-L44</td>
    <td align="right">1</td>
    <td align="right">117</td>
    <td align="right">1507</td>
  </tr>
  <tr valign="top">
    <td align="right">2796</td>
    <td align="left">&nbsp;{       &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [&quot;1. Long Method&quot;, &quot;2. Data Class&quot;] }  </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface Type {     //~ Methods ------------------------------------------------------------------------------------------------------------------      /**      * return the human readable name of the type. &quot;object&quot; is returned      * for object type.      * @return name of the type      */     String getName(); }</td>
    <td align="left">data class</td>
    <td align="left">1. long method, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1230</td>
    <td align="left">https://github.com/oracle/visualvm/blob/d9b10575b53d535e10c6e8c41831ebe38483c65b/visualvm/libs.profiler/lib.profiler/src/org/graalvm/visualvm/lib/jfluid/heap/Type.java/#L52-L61</td>
    <td align="right">1</td>
    <td align="right">2796</td>
    <td align="right">1230</td>
  </tr>
  <tr valign="top">
    <td align="right">2276</td>
    <td align="left">&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: {         &quot;1. Blob&quot;: &quot;ObjectInFolderListImpl class might be a Blob code smell as it contains multiple fields and methods that operate on these fields&quot;,         &quot;2. Data Class&quot;: &quot;ObjectInFolderListImpl class might be considered a Data Class since it mainly contains getters and setters for its fields&quot;     } }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ObjectInFolderListImpl extends AbstractExtensionData implements ObjectInFolderList {      private static final long serialVersionUID = 1L;      private List objects;     private Boolean hasMoreItems = Boolean.FALSE;     private BigInteger numItems;      @Override     public List getObjects() {         if (objects == null) {             objects = new ArrayList(0);         }          return objects;     }      public void setObjects(List objects) {         this.objects = objects;     }      @Override     public Boolean hasMoreItems() {         return hasMoreItems;     }      public void setHasMoreItems(Boolean hasMoreItems) {         this.hasMoreItems = hasMoreItems;     }      @Override     public BigInteger getNumItems() {         return numItems;     }      public void setNumItems(BigInteger numItems) {         this.numItems = numItems;     }      @Override     public String toString() {         return &quot;ObjectInFolder List [objects=&quot; + objects + &quot;, has more items=&quot; + hasMoreItems + &quot;, num items=&quot;                 + numItems + &quot;]&quot; + super.toString();     } }</td>
    <td align="left">data class</td>
    <td align="left">1. blob: objectinfolderlistimpl class might be a blob code smell as it contains multiple fields and methods that operate on these fields, 2. data class: objectinfolderlistimpl class might be considered a data class since it mainly contains getters and setters for its fields</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. blob: objectinfolderlistimpl class might be a blob code smell as it contains multiple fields and methods that operate on these fields</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13775</td>
    <td align="left">https://github.com/apache/chemistry-opencmis/blob/ef8513d708e5e21710afe5cafb8b32a62a0ae532/chemistry-opencmis-commons/chemistry-opencmis-commons-impl/src/main/java/org/apache/chemistry/opencmis/commons/impl/dataobjects/ObjectInFolderListImpl.java/#L31-L75</td>
    <td align="right">1</td>
    <td align="right">2276</td>
    <td align="right">13775</td>
  </tr>
  <tr valign="top">
    <td align="right">465</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class RestConfiguration {      public static final String CORS_ACCESS_CONTROL_ALLOW_ORIGIN = &quot;*&quot;;     public static final String CORS_ACCESS_CONTROL_ALLOW_METHODS = &quot;GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, CONNECT, PATCH&quot;;     public static final String CORS_ACCESS_CONTROL_MAX_AGE = &quot;3600&quot;;     public static final String CORS_ACCESS_CONTROL_ALLOW_HEADERS = &quot;Origin, Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers&quot;;      public enum RestBindingMode {         auto, off, json, xml, json_xml     }      public enum RestHostNameResolver {         allLocalIp, localIp, localHostName     }      private String component;     private String apiComponent;     private String producerComponent;     private String producerApiDoc;     private String scheme;     private String host;     private boolean useXForwardHeaders = true;     private String apiHost;     private int port;     private String contextPath;     private String apiContextPath;     private String apiContextRouteId;     private String apiContextIdPattern;     private boolean apiContextListing;     private boolean apiVendorExtension;     private RestHostNameResolver hostNameResolver = RestHostNameResolver.allLocalIp;     private RestBindingMode bindingMode = RestBindingMode.off;     private boolean skipBindingOnErrorCode = true;     private boolean clientRequestValidation;     private boolean enableCORS;     private String jsonDataFormat;     private String xmlDataFormat;     private Map componentProperties;     private Map endpointProperties;     private Map consumerProperties;     private Map dataFormatProperties;     private Map apiProperties;     private Map corsHeaders;      /**      * Gets the name of the Camel component to use as the REST consumer      *      * @return the component name, or null to let Camel search the {@link Registry} to find suitable implementation      */     public String getComponent() {         return component;     }      /**      * Sets the name of the Camel component to use as the REST consumer      *      * @param componentName the name of the component (such as restlet, spark-rest, etc.)      */     public void setComponent(String componentName) {         this.component = componentName;     }      /**      * Gets the name of the Camel component to use as the REST API (such as swagger)      *      * @return the component name, or null to let Camel use the default name swagger      */     public String getApiComponent() {         return apiComponent;     }      /**      * Sets the name of the Camel component to use as the REST API (such as swagger)      *      * @param apiComponent the name of the component (such as swagger)      */     public void setApiComponent(String apiComponent) {         this.apiComponent = apiComponent;     }      /**      * Gets the name of the Camel component to use as the REST producer      *      * @return the component name, or null to let Camel search the {@link Registry} to find suitable implementation      */     public String getProducerComponent() {         return producerComponent;     }      /**      * Sets the name of the Camel component to use as the REST producer      *      * @param componentName the name of the component (such as restlet, jetty, etc.)      */     public void setProducerComponent(String componentName) {         this.producerComponent = componentName;     }      /**      * Gets the location of the api document (swagger api) the REST producer will use      * to validate the REST uri and query parameters are valid accordingly to the api document.      */     public String getProducerApiDoc() {         return producerApiDoc;     }      /**      * Sets the location of the api document (swagger api) the REST producer will use      * to validate the REST uri and query parameters are valid accordingly to the api document.      * This requires adding camel-swagger-java to the classpath, and any miss configuration      * will let Camel fail on startup and report the error(s).      *       * The location of the api document is loaded from classpath by default, but you can use      * file: or http: to refer to resources to load from file or http url.      */     public void setProducerApiDoc(String producerApiDoc) {         this.producerApiDoc = producerApiDoc;     }      /**      * Gets the hostname to use by the REST consumer      *      * @return the hostname, or null to use default hostname      */     public String getHost() {         return host;     }      /**      * Sets the hostname to use by the REST consumer      *      * @param host the hostname      */     public void setHost(String host) {         this.host = host;     }      /**      * WWhether to use X-Forward headers to set host etc. for Swagger.      *       * This option is default true.      */     public boolean isUseXForwardHeaders() {         return useXForwardHeaders;     }      /**      * WWhether to use X-Forward headers to set host etc. for Swagger.      *       * This option is default true.      *       * @param useXForwardHeaders whether to use X-Forward headers      */     public void setUseXForwardHeaders(boolean useXForwardHeaders) {         this.useXForwardHeaders = useXForwardHeaders;     }      public String getApiHost() {         return apiHost;     }      /**      * To use an specific hostname for the API documentation (eg swagger)      *       * This can be used to override the generated host with this configured hostname      */     public void setApiHost(String apiHost) {         this.apiHost = apiHost;     }      /**      * Gets the scheme to use by the REST consumer      *      * @return the scheme, or null to use default scheme      */     public String getScheme() {         return scheme;     }      /**      * Sets the scheme to use by the REST consumer      *      * @param scheme the scheme      */     public void setScheme(String scheme) {         this.scheme = scheme;     }      /**      * Gets the port to use by the REST consumer      *      * @return the port, or 0 or -1 to use default port      */     public int getPort() {         return port;     }      /**      * Sets the port to use by the REST consumer      *      * @param port the port number      */     public void setPort(int port) {         this.port = port;     }      /**      * Gets the configured context-path      *      * @return the context path, or null if none configured.      */     public String getContextPath() {         return contextPath;     }      /**      * Sets a leading context-path the REST services will be using.      *       * This can be used when using components such as camel-servlet where the deployed web application      * is deployed using a context-path. Or for components such as camel-jetty or camel-netty4-http      * that includes a HTTP server.      *      * @param contextPath the context path      */     public void setContextPath(String contextPath) {         this.contextPath = contextPath;     }      public String getApiContextPath() {         return apiContextPath;     }      /**      * Sets a leading API context-path the REST API services will be using.      *       * This can be used when using components such as camel-servlet where the deployed web application      * is deployed using a context-path.      *      * @param contextPath the API context path      */     public void setApiContextPath(String contextPath) {         this.apiContextPath = contextPath;     }      public String getApiContextRouteId() {         return apiContextRouteId;     }      /**      * Sets the route id to use for the route that services the REST API.      *       * The route will by default use an auto assigned route id.      *      * @param apiContextRouteId  the route id      */     public void setApiContextRouteId(String apiContextRouteId) {         this.apiContextRouteId = apiContextRouteId;     }      public String getApiContextIdPattern() {         return apiContextIdPattern;     }      /**      * Optional CamelContext id pattern to only allow Rest APIs from rest services within CamelContext's which name matches the pattern.      *       * The pattern #name# refers to the CamelContext name, to match on the current CamelContext only.      * For any other value, the pattern uses the rules from {@link org.apache.camel.support.EndpointHelper#matchPattern(String, String)}      *      * @param apiContextIdPattern  the pattern      */     public void setApiContextIdPattern(String apiContextIdPattern) {         this.apiContextIdPattern = apiContextIdPattern;     }      public boolean isApiContextListing() {         return apiContextListing;     }      /**      * Sets whether listing of all available CamelContext's with REST services in the JVM is enabled. If enabled it allows to discover      * these contexts, if false then only the current CamelContext is in use.      */     public void setApiContextListing(boolean apiContextListing) {         this.apiContextListing = apiContextListing;     }      public boolean isApiVendorExtension() {         return apiVendorExtension;     }      /**      * Whether vendor extension is enabled in the Rest APIs. If enabled then Camel will include additional information      * as vendor extension (eg keys starting with x-) such as route ids, class names etc.      * Not all 3rd party API gateways and tools supports vendor-extensions when importing your API docs.      */     public void setApiVendorExtension(boolean apiVendorExtension) {         this.apiVendorExtension = apiVendorExtension;     }      /**      * Gets the resolver to use for resolving hostname      *      * @return the resolver      */     public RestHostNameResolver getHostNameResolver() {         return hostNameResolver;     }      /**      * Sets the resolver to use for resolving hostname      *      * @param hostNameResolver the resolver      */     public void setHostNameResolver(RestHostNameResolver hostNameResolver) {         this.hostNameResolver = hostNameResolver;     }      /**      * Sets the resolver to use for resolving hostname      *      * @param hostNameResolver the resolver      */     public void setHostNameResolver(String hostNameResolver) {         this.hostNameResolver = RestHostNameResolver.valueOf(hostNameResolver);     }      /**      * Gets the binding mode used by the REST consumer      *      * @return the binding mode      */     public RestBindingMode getBindingMode() {         return bindingMode;     }      /**      * Sets the binding mode to be used by the REST consumer      *      * @param bindingMode the binding mode      */     public void setBindingMode(RestBindingMode bindingMode) {         this.bindingMode = bindingMode;     }      /**      * Sets the binding mode to be used by the REST consumer      *      * @param bindingMode the binding mode      */     public void setBindingMode(String bindingMode) {         this.bindingMode = RestBindingMode.valueOf(bindingMode);     }      /**      * Whether to skip binding output if there is a custom HTTP error code, and instead use the response body as-is.      *       * This option is default true.      *      * @return whether to skip binding on error code      */     public boolean isSkipBindingOnErrorCode() {         return skipBindingOnErrorCode;     }      /**      * Whether to skip binding output if there is a custom HTTP error code, and instead use the response body as-is.      *       * This option is default true.      *      * @param skipBindingOnErrorCode whether to skip binding on error code      */     public void setSkipBindingOnErrorCode(boolean skipBindingOnErrorCode) {         this.skipBindingOnErrorCode = skipBindingOnErrorCode;     }      public boolean isClientRequestValidation() {         return clientRequestValidation;     }      /**      * Whether to enable validation of the client request to check whether the Content-Type and Accept headers from      * the client is supported by the Rest-DSL configuration of its consumes/produces settings.      *       * This can be turned on, to enable this check. In case of validation error, then HTTP Status codes 415 or 406 is returned.      *       * The default value is false.      */     public void setClientRequestValidation(boolean clientRequestValidation) {         this.clientRequestValidation = clientRequestValidation;     }      /**      * To specify whether to enable CORS which means Camel will automatic include CORS in the HTTP headers in the response.      *       * This option is default false      *      * @return whether CORS is enabled or not      */     public boolean isEnableCORS() {         return enableCORS;     }      /**      * To specify whether to enable CORS which means Camel will automatic include CORS in the HTTP headers in the response.      *       * This option is default false      *      * @param enableCORS true to enable CORS      */     public void setEnableCORS(boolean enableCORS) {         this.enableCORS = enableCORS;     }      /**      * Gets the name of the json data format.      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @return the name, or null to use default      */     public String getJsonDataFormat() {         return jsonDataFormat;     }      /**      * Sets a custom json data format to be used      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @param name name of the data format      */     public void setJsonDataFormat(String name) {         this.jsonDataFormat = name;     }      /**      * Gets the name of the xml data format.      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @return the name, or null to use default      */     public String getXmlDataFormat() {         return xmlDataFormat;     }      /**      * Sets a custom xml data format to be used.      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @param name name of the data format      */     public void setXmlDataFormat(String name) {         this.xmlDataFormat = name;     }      /**      * Gets additional options on component level      *      * @return additional options      */     public Map getComponentProperties() {         return componentProperties;     }      /**      * Sets additional options on component level      *      * @param componentProperties the options      */     public void setComponentProperties(Map componentProperties) {         this.componentProperties = componentProperties;     }      /**      * Gets additional options on endpoint level      *      * @return additional options      */     public Map getEndpointProperties() {         return endpointProperties;     }      /**      * Sets additional options on endpoint level      *      * @param endpointProperties the options      */     public void setEndpointProperties(Map endpointProperties) {         this.endpointProperties = endpointProperties;     }      /**      * Gets additional options on consumer level      *      * @return additional options      */     public Map getConsumerProperties() {         return consumerProperties;     }      /**      * Sets additional options on consumer level      *      * @param consumerProperties the options      */     public void setConsumerProperties(Map consumerProperties) {         this.consumerProperties = consumerProperties;     }      /**      * Gets additional options on data format level      *      * @return additional options      */     public Map getDataFormatProperties() {         return dataFormatProperties;     }      /**      * Sets additional options on data format level      *      * @param dataFormatProperties the options      */     public void setDataFormatProperties(Map dataFormatProperties) {         this.dataFormatProperties = dataFormatProperties;     }      public Map getApiProperties() {         return apiProperties;     }      /**      * Sets additional options on api level      *      * @param apiProperties the options      */     public void setApiProperties(Map apiProperties) {         this.apiProperties = apiProperties;     }      /**      * Gets the CORS headers to use if CORS has been enabled.      *      * @return the CORS headers      */     public Map getCorsHeaders() {         return corsHeaders;     }      /**      * Sets the CORS headers to use if CORS has been enabled.      *      * @param corsHeaders the CORS headers      */     public void setCorsHeaders(Map corsHeaders) {         this.corsHeaders = corsHeaders;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4508</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/core/camel-api/src/main/java/org/apache/camel/spi/RestConfiguration.java/#L25-L585</td>
    <td align="right">1</td>
    <td align="right">465</td>
    <td align="right">4508</td>
  </tr>
  <tr valign="top">
    <td align="right">2312</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Tower extends Item {      private Fit fit;     private String tubing;      public static enum Fit {         Custom,         Exact,         Universal     }      public Fit getFit() {         return fit;     }      public void setFit(Fit fit) {         this.fit = fit;     }      public String getTubing() {         return tubing;     }      public void setTubing(String tubing) {         this.tubing = tubing;     }      ; }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14102</td>
    <td align="left">https://github.com/apache/tomee/blob/d21933b313aff812fe5188b57bf572a9ad649148/examples/webservice-inheritance/src/main/java/org/superbiz/inheritance/Tower.java/#L21-L50</td>
    <td align="right">1</td>
    <td align="right">2312</td>
    <td align="right">14102</td>
  </tr>
  <tr valign="top">
    <td align="right">2266</td>
    <td align="left">&nbsp;&nbsp;&nbsp;	{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Long Method&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class MetaColumn implements Named {     public final String tableCat;     public final String tableSchem;     public final String tableName;     public final String columnName;     public final int dataType;     public final String typeName;     public final Integer columnSize;     public final Integer bufferLength = null;     public final Integer decimalDigits;     public final Integer numPrecRadix;     public final int nullable;     public final String remarks = null;     public final String columnDef = null;     public final Integer sqlDataType = null;     public final Integer sqlDatetimeSub = null;     public final Integer charOctetLength;     public final int ordinalPosition;     @NotNull     public final String isNullable;     public final String scopeCatalog = null;     public final String scopeSchema = null;     public final String scopeTable = null;     public final Short sourceDataType = null;     @NotNull     public final String isAutoincrement = &quot;&quot;;     @NotNull     public final String isGeneratedcolumn = &quot;&quot;;      public MetaColumn(         String tableCat,         String tableSchem,         String tableName,         String columnName,         int dataType,         String typeName,         Integer columnSize,         Integer decimalDigits,         Integer numPrecRadix,         int nullable,         Integer charOctetLength,         int ordinalPosition,         String isNullable) {       this.tableCat = tableCat;       this.tableSchem = tableSchem;       this.tableName = tableName;       this.columnName = columnName;       this.dataType = dataType;       this.typeName = typeName;       this.columnSize = columnSize;       this.decimalDigits = decimalDigits;       this.numPrecRadix = numPrecRadix;       this.nullable = nullable;       this.charOctetLength = charOctetLength;       this.ordinalPosition = ordinalPosition;       this.isNullable = isNullable;     }      @Override     public String getName() {       return columnName;     }   }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13732</td>
    <td align="left">https://github.com/apache/drill/blob/5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3/exec/jdbc/src/main/java/org/apache/drill/jdbc/impl/DrillMetaImpl.java/#L160-L222</td>
    <td align="right">1</td>
    <td align="right">2266</td>
    <td align="right">13732</td>
  </tr>
  <tr valign="top">
    <td align="right">2453</td>
    <td align="left">&nbsp;&nbsp;YES I found bad smells  The bad smells are:   1. Long method 2. Repetitive code  3. Feature envy  4. Primitive obsession  5. Inappropriate intimate accessor  6. Inconsistent naming convention  7. Poor naming  8. Dead code  9. Data class  10. Large class  11. Complex code  12. Shotgun surgery  13. Inappropriate inheritance  14. Refused bequest</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class NetworkBridgeStatistics extends StatsImpl {      protected CountStatisticImpl enqueues;     protected CountStatisticImpl dequeues;     protected CountStatisticImpl receivedCount;      public NetworkBridgeStatistics() {         enqueues = new CountStatisticImpl(&quot;enqueues&quot;, &quot;The current number of enqueues this bridge has, which is the number of potential messages to be forwarded.&quot;);         dequeues = new CountStatisticImpl(&quot;dequeues&quot;, &quot;The current number of dequeues this bridge has, which is the number of messages received by the remote broker.&quot;);         receivedCount = new CountStatisticImpl(&quot;receivedCount&quot;, &quot;The number of messages that have been received by the NetworkBridge from the remote broker.  Only applies for Duplex bridges.&quot;);          addStatistic(&quot;enqueues&quot;, enqueues);         addStatistic(&quot;dequeues&quot;, dequeues);         addStatistic(&quot;receivedCount&quot;, receivedCount);     }      /**      * The current number of enqueues this bridge has, which is the number of potential messages to be forwarded      * Messages may not be forwarded if there is no subscription      *      * @return      */     public CountStatisticImpl getEnqueues() {         return enqueues;     }      /**      * The current number of dequeues this bridge has, which is the number of      * messages actually sent to and received by the remote broker.      *      * @return      */     public CountStatisticImpl getDequeues() {         return dequeues;     }      /**      * The number of messages that have been received by the NetworkBridge from the remote broker.      * Only applies for Duplex bridges.      *      * @return      */     public CountStatisticImpl getReceivedCount() {         return receivedCount;     }      @Override     public void reset() {         if (this.isDoReset()) {             super.reset();             enqueues.reset();             dequeues.reset();             receivedCount.reset();         }     }      @Override     public void setEnabled(boolean enabled) {         super.setEnabled(enabled);         enqueues.setEnabled(enabled);         dequeues.setEnabled(enabled);         receivedCount.setEnabled(enabled);     }      public void setParent(NetworkBridgeStatistics parent) {         if (parent != null) {             enqueues.setParent(parent.enqueues);             dequeues.setParent(parent.dequeues);             receivedCount.setParent(parent.receivedCount);         } else {             enqueues.setParent(null);             dequeues.setParent(null);             receivedCount.setParent(null);         }     }  }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method2 Repetitive code 3 Feature envy 4 Primitive obsession 5 Inappropriate intimate accessor 6 Inconsistent naming convention 7 Poor naming 8 Dead code 9 Data class </td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14518</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-broker/src/main/java/org/apache/activemq/network/NetworkBridgeStatistics.java/#L26-L102</td>
    <td align="right">2</td>
    <td align="right">2453</td>
    <td align="right">14518</td>
  </tr>
  <tr valign="top">
    <td align="right">1081</td>
    <td align="left">   {     &quot;output&quot;: &quot;YES I found bad smells, the bad smells are: 1. Data Class&quot;   }   </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ItemContent {  	private String defaultName = &quot;&quot;; //$NON-NLS-1$ 	private String displayName = &quot;&quot;; //$NON-NLS-1$ 	private String customName = &quot;&quot;; //$NON-NLS-1$ 	private String description = &quot;&quot;; //$NON-NLS-1$  	public ItemContent( String string ) 	{ 		super( ); 		this.setCustomName( string ); 	}  	/** 	 *  	 * @return Return the default name of ItemContent 	 */ 	public String getDefaultName( ) 	{ 		return defaultName; 	}  	/** 	 *  	 * @return Returns the display name of the ItemContent 	 */ 	public String getDisplayName( ) 	{ 		return displayName; 	}  	/** 	 * Set default name for ItemContent 	 *  	 * @param string 	 */ 	public void setDefaultName( String string ) 	{ 		defaultName = string.trim( ); 	}  	/** 	 * Sets the display name for the ItemContent 	 *  	 * @param string 	 */ 	public void setDisplayName( String string ) 	{ 		displayName = string.trim( ); 	}  	/** 	 *  	 * @return custom name of ItemContent 	 */ 	public String getCustomName( ) 	{ 		return customName; 	}  	/** 	 * Set custom name for ItemContent 	 *  	 * @param string 	 */ 	public void setCustomName( String string ) 	{ 		customName = string.trim( ); 	}  	/** 	 *  	 * @return the description of ItemContent 	 */ 	public String getDescription( ) 	{ 		return description; 	}  	/** 	 * Set the description for ItemContent 	 *  	 * @param string 	 */ 	public void setDescription( String string ) 	{ 		description = string.trim( ); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">1. data class      </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9680</td>
    <td align="left">https://github.com/eclipse/birt/blob/f89264810347de98702db45386a822aabc0fadbf/UI/org.eclipse.birt.report.designer.ui/src/org/eclipse/birt/report/designer/ui/preferences/ItemContent.java/#L22-L112</td>
    <td align="right">1</td>
    <td align="right">1081</td>
    <td align="right">9680</td>
  </tr>
  <tr valign="top">
    <td align="right">2488</td>
    <td align="left">	{ 	    &quot;message&quot;: &quot;YES I found bad smells&quot;, 	    &quot;detected_bad_smells&quot;: [ 	        { 	            &quot;1&quot;: &quot;Data Class&quot; 	        } 	    ] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  protected class UnifyRuleCall {     protected final UnifyRule rule;     public final MutableRel query;     public final MutableRel target;     protected final ImmutableList slots;      public UnifyRuleCall(UnifyRule rule, MutableRel query, MutableRel target,         ImmutableList slots) {       this.rule = Objects.requireNonNull(rule);       this.query = Objects.requireNonNull(query);       this.target = Objects.requireNonNull(target);       this.slots = Objects.requireNonNull(slots);     }      public UnifyResult result(MutableRel result) {       assert MutableRels.contains(result, target);       assert equalType(&quot;result&quot;, result, &quot;query&quot;, query,           Litmus.THROW);       MutableRel replace = replacementMap.get(target);       if (replace != null) {         assert false; // replacementMap is always empty         // result =         replace(result, target, replace);       }       register(result, query);       return new UnifyResult(this, result);     }      /**      * Creates a {@link UnifyRuleCall} based on the parent of {@code query}.      */     public UnifyRuleCall create(MutableRel query) {       return new UnifyRuleCall(rule, query, target, slots);     }      public RelOptCluster getCluster() {       return cluster;     }      public RexSimplify getSimplify() {       return simplify;     }   }</td>
    <td align="left">data class</td>
    <td align="left">1: data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14613</td>
    <td align="left">https://github.com/apache/calcite/blob/a648f9c12309cc253628930b0cab98591caa66ab/core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java/#L854-L896</td>
    <td align="right">1</td>
    <td align="right">2488</td>
    <td align="right">14613</td>
  </tr>
  <tr valign="top">
    <td align="right">2914</td>
    <td align="left">&nbsp;&nbsp;YES I found bad smells the bad smells are: 1. Data Class</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
  private static class FieldMetaData {     public final FieldInfo fieldInfo;     public final long numTerms;     public final long sumTotalTermFreq;     public final long sumDocFreq;     public final int docCount;     public final int longsSize;     public final FST dict;      public FieldMetaData(FieldInfo fieldInfo, long numTerms, long sumTotalTermFreq, long sumDocFreq, int docCount, int longsSize, FST fst) {       this.fieldInfo = fieldInfo;       this.numTerms = numTerms;       this.sumTotalTermFreq = sumTotalTermFreq;       this.sumDocFreq = sumDocFreq;       this.docCount = docCount;       this.longsSize = longsSize;       this.dict = fst;     }   }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2250</td>
    <td align="left">https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/lucene/codecs/src/java/org/apache/lucene/codecs/memory/FSTTermsWriter.java/#L229-L247</td>
    <td align="right">2</td>
    <td align="right">2914</td>
    <td align="right">2250</td>
  </tr>
  <tr valign="top">
    <td align="right">519</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES, I found bad smells&quot;, &quot;the bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Targeting extends APINode {   @SerializedName(&quot;adgroup_id&quot;)   private String mAdgroupId = null;   @SerializedName(&quot;age_max&quot;)   private Long mAgeMax = null;   @SerializedName(&quot;age_min&quot;)   private Long mAgeMin = null;   @SerializedName(&quot;alternate_auto_targeting_option&quot;)   private String mAlternateAutoTargetingOption = null;   @SerializedName(&quot;app_install_state&quot;)   private String mAppInstallState = null;   @SerializedName(&quot;audience_network_positions&quot;)   private List mAudienceNetworkPositions = null;   @SerializedName(&quot;behaviors&quot;)   private List mBehaviors = null;   @SerializedName(&quot;brand_safety_content_filter_levels&quot;)   private List mBrandSafetyContentFilterLevels = null;   @SerializedName(&quot;brand_safety_content_severity_levels&quot;)   private List mBrandSafetyContentSeverityLevels = null;   @SerializedName(&quot;catalog_based_targeting&quot;)   private CatalogBasedTargeting mCatalogBasedTargeting = null;   @SerializedName(&quot;cities&quot;)   private List mCities = null;   @SerializedName(&quot;college_years&quot;)   private List mCollegeYears = null;   @SerializedName(&quot;connections&quot;)   private List mConnections = null;   @SerializedName(&quot;contextual_targeting_categories&quot;)   private List mContextualTargetingCategories = null;   @SerializedName(&quot;countries&quot;)   private List mCountries = null;   @SerializedName(&quot;country&quot;)   private List mCountry = null;   @SerializedName(&quot;country_groups&quot;)   private List mCountryGroups = null;   @SerializedName(&quot;custom_audiences&quot;)   private List mCustomAudiences = null;   @SerializedName(&quot;device_platforms&quot;)   private List mDevicePlatforms = null;   @SerializedName(&quot;direct_install_devices&quot;)   private Boolean mDirectInstallDevices = null;   @SerializedName(&quot;dynamic_audience_ids&quot;)   private List mDynamicAudienceIds = null;   @SerializedName(&quot;education_majors&quot;)   private List mEducationMajors = null;   @SerializedName(&quot;education_schools&quot;)   private List mEducationSchools = null;   @SerializedName(&quot;education_statuses&quot;)   private List mEducationStatuses = null;   @SerializedName(&quot;effective_audience_network_positions&quot;)   private List mEffectiveAudienceNetworkPositions = null;   @SerializedName(&quot;effective_device_platforms&quot;)   private List mEffectiveDevicePlatforms = null;   @SerializedName(&quot;effective_facebook_positions&quot;)   private List mEffectiveFacebookPositions = null;   @SerializedName(&quot;effective_instagram_positions&quot;)   private List mEffectiveInstagramPositions = null;   @SerializedName(&quot;effective_messenger_positions&quot;)   private List mEffectiveMessengerPositions = null;   @SerializedName(&quot;effective_publisher_platforms&quot;)   private List mEffectivePublisherPlatforms = null;   @SerializedName(&quot;engagement_specs&quot;)   private List mEngagementSpecs = null;   @SerializedName(&quot;ethnic_affinity&quot;)   private List mEthnicAffinity = null;   @SerializedName(&quot;exclude_reached_since&quot;)   private List mExcludeReachedSince = null;   @SerializedName(&quot;excluded_connections&quot;)   private List mExcludedConnections = null;   @SerializedName(&quot;excluded_custom_audiences&quot;)   private List mExcludedCustomAudiences = null;   @SerializedName(&quot;excluded_dynamic_audience_ids&quot;)   private List mExcludedDynamicAudienceIds = null;   @SerializedName(&quot;excluded_engagement_specs&quot;)   private List mExcludedEngagementSpecs = null;   @SerializedName(&quot;excluded_geo_locations&quot;)   private TargetingGeoLocation mExcludedGeoLocations = null;   @SerializedName(&quot;excluded_mobile_device_model&quot;)   private List mExcludedMobileDeviceModel = null;   @SerializedName(&quot;excluded_product_audience_specs&quot;)   private List mExcludedProductAudienceSpecs = null;   @SerializedName(&quot;excluded_publisher_categories&quot;)   private List mExcludedPublisherCategories = null;   @SerializedName(&quot;excluded_publisher_list_ids&quot;)   private List mExcludedPublisherListIds = null;   @SerializedName(&quot;excluded_user_device&quot;)   private List mExcludedUserDevice = null;   @SerializedName(&quot;exclusions&quot;)   private FlexibleTargeting mExclusions = null;   @SerializedName(&quot;facebook_positions&quot;)   private List mFacebookPositions = null;   @SerializedName(&quot;family_statuses&quot;)   private List mFamilyStatuses = null;   @SerializedName(&quot;fb_deal_id&quot;)   private String mFbDealId = null;   @SerializedName(&quot;flexible_spec&quot;)   private List mFlexibleSpec = null;   @SerializedName(&quot;friends_of_connections&quot;)   private List mFriendsOfConnections = null;   @SerializedName(&quot;genders&quot;)   private List mGenders = null;   @SerializedName(&quot;generation&quot;)   private List mGeneration = null;   @SerializedName(&quot;geo_locations&quot;)   private TargetingGeoLocation mGeoLocations = null;   @SerializedName(&quot;home_ownership&quot;)   private List mHomeOwnership = null;   @SerializedName(&quot;home_type&quot;)   private List mHomeType = null;   @SerializedName(&quot;home_value&quot;)   private List mHomeValue = null;   @SerializedName(&quot;household_composition&quot;)   private List mHouseholdComposition = null;   @SerializedName(&quot;income&quot;)   private List mIncome = null;   @SerializedName(&quot;industries&quot;)   private List mIndustries = null;   @SerializedName(&quot;instagram_positions&quot;)   private List mInstagramPositions = null;   @SerializedName(&quot;instream_video_sponsorship_placements&quot;)   private List mInstreamVideoSponsorshipPlacements = null;   @SerializedName(&quot;interested_in&quot;)   private List mInterestedIn = null;   @SerializedName(&quot;interests&quot;)   private List mInterests = null;   @SerializedName(&quot;is_whatsapp_destination_ad&quot;)   private Boolean mIsWhatsappDestinationAd = null;   @SerializedName(&quot;keywords&quot;)   private List mKeywords = null;   @SerializedName(&quot;life_events&quot;)   private List mLifeEvents = null;   @SerializedName(&quot;locales&quot;)   private List mLocales = null;   @SerializedName(&quot;messenger_positions&quot;)   private List mMessengerPositions = null;   @SerializedName(&quot;moms&quot;)   private List mMoms = null;   @SerializedName(&quot;net_worth&quot;)   private List mNetWorth = null;   @SerializedName(&quot;office_type&quot;)   private List mOfficeType = null;   @SerializedName(&quot;place_page_set_ids&quot;)   private List mPlacePageSetIds = null;   @SerializedName(&quot;political_views&quot;)   private List mPoliticalViews = null;   @SerializedName(&quot;politics&quot;)   private List mPolitics = null;   @SerializedName(&quot;product_audience_specs&quot;)   private List mProductAudienceSpecs = null;   @SerializedName(&quot;prospecting_audience&quot;)   private TargetingProspectingAudience mProspectingAudience = null;   @SerializedName(&quot;publisher_platforms&quot;)   private List mPublisherPlatforms = null;   @SerializedName(&quot;publisher_visibility_categories&quot;)   private List mPublisherVisibilityCategories = null;   @SerializedName(&quot;radius&quot;)   private String mRadius = null;   @SerializedName(&quot;regions&quot;)   private List mRegions = null;   @SerializedName(&quot;relationship_statuses&quot;)   private List mRelationshipStatuses = null;   @SerializedName(&quot;site_category&quot;)   private List mSiteCategory = null;   @SerializedName(&quot;targeting_optimization&quot;)   private String mTargetingOptimization = null;   @SerializedName(&quot;user_adclusters&quot;)   private List mUserAdclusters = null;   @SerializedName(&quot;user_device&quot;)   private List mUserDevice = null;   @SerializedName(&quot;user_event&quot;)   private List mUserEvent = null;   @SerializedName(&quot;user_os&quot;)   private List mUserOs = null;   @SerializedName(&quot;wireless_carrier&quot;)   private List mWirelessCarrier = null;   @SerializedName(&quot;work_employers&quot;)   private List mWorkEmployers = null;   @SerializedName(&quot;work_positions&quot;)   private List mWorkPositions = null;   @SerializedName(&quot;zips&quot;)   private List mZips = null;   protected static Gson gson = null;    public Targeting() {   }    public String getId() {     return null;   }   public static Targeting loadJSON(String json, APIContext context, String header) {     Targeting targeting = getGson().fromJson(json, Targeting.class);     if (context.isDebug()) {       JsonParser parser = new JsonParser();       JsonElement o1 = parser.parse(json);       JsonElement o2 = parser.parse(targeting.toString());       if (o1.getAsJsonObject().get(&quot;__fb_trace_id__&quot;) != null) {         o2.getAsJsonObject().add(&quot;__fb_trace_id__&quot;, o1.getAsJsonObject().get(&quot;__fb_trace_id__&quot;));       }       if (!o1.equals(o2)) {         context.log(&quot;[Warning] When parsing response, object is not consistent with JSON:&quot;);         context.log(&quot;[JSON]&quot; + o1);         context.log(&quot;[Object]&quot; + o2);       };     }     targeting.context = context;     targeting.rawValue = json;     targeting.header = header;     return targeting;   }    public static APINodeList parseResponse(String json, APIContext context, APIRequest request, String header) throws MalformedResponseException {     APINodeList targetings = new APINodeList(request, json, header);     JsonArray arr;     JsonObject obj;     JsonParser parser = new JsonParser();     Exception exception = null;     try{       JsonElement result = parser.parse(json);       if (result.isJsonArray()) {         // First, check if it's a pure JSON Array         arr = result.getAsJsonArray();         for (int i = 0; i &lt; arr.size(); i++) {           targetings.add(loadJSON(arr.get(i).getAsJsonObject().toString(), context, header));         };         return targetings;       } else if (result.isJsonObject()) {         obj = result.getAsJsonObject();         if (obj.has(&quot;data&quot;)) {           if (obj.has(&quot;paging&quot;)) {             JsonObject paging = obj.get(&quot;paging&quot;).getAsJsonObject();             if (paging.has(&quot;cursors&quot;)) {                 JsonObject cursors = paging.get(&quot;cursors&quot;).getAsJsonObject();                 String before = cursors.has(&quot;before&quot;) ? cursors.get(&quot;before&quot;).getAsString() : null;                 String after = cursors.has(&quot;after&quot;) ? cursors.get(&quot;after&quot;).getAsString() : null;                 targetings.setCursors(before, after);             }             String previous = paging.has(&quot;previous&quot;) ? paging.get(&quot;previous&quot;).getAsString() : null;             String next = paging.has(&quot;next&quot;) ? paging.get(&quot;next&quot;).getAsString() : null;             targetings.setPaging(previous, next);             if (context.hasAppSecret()) {               targetings.setAppSecret(context.getAppSecretProof());             }           }           if (obj.get(&quot;data&quot;).isJsonArray()) {             // Second, check if it's a JSON array with &quot;data&quot;             arr = obj.get(&quot;data&quot;).getAsJsonArray();             for (int i = 0; i &lt; arr.size(); i++) {               targetings.add(loadJSON(arr.get(i).getAsJsonObject().toString(), context, header));             };           } else if (obj.get(&quot;data&quot;).isJsonObject()) {             // Third, check if it's a JSON object with &quot;data&quot;             obj = obj.get(&quot;data&quot;).getAsJsonObject();             boolean isRedownload = false;             for (String s : new String[]{&quot;campaigns&quot;, &quot;adsets&quot;, &quot;ads&quot;}) {               if (obj.has(s)) {                 isRedownload = true;                 obj = obj.getAsJsonObject(s);                 for (Map.Entry entry : obj.entrySet()) {                   targetings.add(loadJSON(entry.getValue().toString(), context, header));                 }                 break;               }             }             if (!isRedownload) {               targetings.add(loadJSON(obj.toString(), context, header));             }           }           return targetings;         } else if (obj.has(&quot;images&quot;)) {           // Fourth, check if it's a map of image objects           obj = obj.get(&quot;images&quot;).getAsJsonObject();           for (Map.Entry entry : obj.entrySet()) {               targetings.add(loadJSON(entry.getValue().toString(), context, header));           }           return targetings;         } else {           // Fifth, check if it's an array of objects indexed by id           boolean isIdIndexedArray = true;           for (Map.Entry entry : obj.entrySet()) {             String key = (String) entry.getKey();             if (key.equals(&quot;__fb_trace_id__&quot;)) {               continue;             }             JsonElement value = (JsonElement) entry.getValue();             if (               value != null &amp;&amp;               value.isJsonObject() &amp;&amp;               value.getAsJsonObject().has(&quot;id&quot;) &amp;&amp;               value.getAsJsonObject().get(&quot;id&quot;) != null &amp;&amp;               value.getAsJsonObject().get(&quot;id&quot;).getAsString().equals(key)             ) {               targetings.add(loadJSON(value.toString(), context, header));             } else {               isIdIndexedArray = false;               break;             }           }           if (isIdIndexedArray) {             return targetings;           }            // Sixth, check if it's pure JsonObject           targetings.clear();           targetings.add(loadJSON(json, context, header));           return targetings;         }       }     } catch (Exception e) {       exception = e;     }     throw new MalformedResponseException(       &quot;Invalid response string: &quot; + json,       exception     );   }    @Override   public APIContext getContext() {     return context;   }    @Override   public void setContext(APIContext context) {     this.context = context;   }    @Override   public String toString() {     return getGson().toJson(this);   }     public String getFieldAdgroupId() {     return mAdgroupId;   }    public Targeting setFieldAdgroupId(String value) {     this.mAdgroupId = value;     return this;   }    public Long getFieldAgeMax() {     return mAgeMax;   }    public Targeting setFieldAgeMax(Long value) {     this.mAgeMax = value;     return this;   }    public Long getFieldAgeMin() {     return mAgeMin;   }    public Targeting setFieldAgeMin(Long value) {     this.mAgeMin = value;     return this;   }    public String getFieldAlternateAutoTargetingOption() {     return mAlternateAutoTargetingOption;   }    public Targeting setFieldAlternateAutoTargetingOption(String value) {     this.mAlternateAutoTargetingOption = value;     return this;   }    public String getFieldAppInstallState() {     return mAppInstallState;   }    public Targeting setFieldAppInstallState(String value) {     this.mAppInstallState = value;     return this;   }    public List getFieldAudienceNetworkPositions() {     return mAudienceNetworkPositions;   }    public Targeting setFieldAudienceNetworkPositions(List value) {     this.mAudienceNetworkPositions = value;     return this;   }    public List getFieldBehaviors() {     return mBehaviors;   }    public Targeting setFieldBehaviors(List value) {     this.mBehaviors = value;     return this;   }    public Targeting setFieldBehaviors(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mBehaviors = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldBrandSafetyContentFilterLevels() {     return mBrandSafetyContentFilterLevels;   }    public Targeting setFieldBrandSafetyContentFilterLevels(List value) {     this.mBrandSafetyContentFilterLevels = value;     return this;   }    public List getFieldBrandSafetyContentSeverityLevels() {     return mBrandSafetyContentSeverityLevels;   }    public Targeting setFieldBrandSafetyContentSeverityLevels(List value) {     this.mBrandSafetyContentSeverityLevels = value;     return this;   }    public CatalogBasedTargeting getFieldCatalogBasedTargeting() {     return mCatalogBasedTargeting;   }    public Targeting setFieldCatalogBasedTargeting(CatalogBasedTargeting value) {     this.mCatalogBasedTargeting = value;     return this;   }    public Targeting setFieldCatalogBasedTargeting(String value) {     Type type = new TypeToken(){}.getType();     this.mCatalogBasedTargeting = CatalogBasedTargeting.getGson().fromJson(value, type);     return this;   }   public List getFieldCities() {     return mCities;   }    public Targeting setFieldCities(List value) {     this.mCities = value;     return this;   }    public Targeting setFieldCities(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mCities = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldCollegeYears() {     return mCollegeYears;   }    public Targeting setFieldCollegeYears(List value) {     this.mCollegeYears = value;     return this;   }    public List getFieldConnections() {     return mConnections;   }    public Targeting setFieldConnections(List value) {     this.mConnections = value;     return this;   }    public Targeting setFieldConnections(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mConnections = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldContextualTargetingCategories() {     return mContextualTargetingCategories;   }    public Targeting setFieldContextualTargetingCategories(List value) {     this.mContextualTargetingCategories = value;     return this;   }    public Targeting setFieldContextualTargetingCategories(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mContextualTargetingCategories = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldCountries() {     return mCountries;   }    public Targeting setFieldCountries(List value) {     this.mCountries = value;     return this;   }    public List getFieldCountry() {     return mCountry;   }    public Targeting setFieldCountry(List value) {     this.mCountry = value;     return this;   }    public List getFieldCountryGroups() {     return mCountryGroups;   }    public Targeting setFieldCountryGroups(List value) {     this.mCountryGroups = value;     return this;   }    public List getFieldCustomAudiences() {     return mCustomAudiences;   }    public Targeting setFieldCustomAudiences(List value) {     this.mCustomAudiences = value;     return this;   }    public Targeting setFieldCustomAudiences(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mCustomAudiences = RawCustomAudience.getGson().fromJson(value, type);     return this;   }   public List getFieldDevicePlatforms() {     return mDevicePlatforms;   }    public Targeting setFieldDevicePlatforms(List value) {     this.mDevicePlatforms = value;     return this;   }    public Boolean getFieldDirectInstallDevices() {     return mDirectInstallDevices;   }    public Targeting setFieldDirectInstallDevices(Boolean value) {     this.mDirectInstallDevices = value;     return this;   }    public List getFieldDynamicAudienceIds() {     return mDynamicAudienceIds;   }    public Targeting setFieldDynamicAudienceIds(List value) {     this.mDynamicAudienceIds = value;     return this;   }    public List getFieldEducationMajors() {     return mEducationMajors;   }    public Targeting setFieldEducationMajors(List value) {     this.mEducationMajors = value;     return this;   }    public Targeting setFieldEducationMajors(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mEducationMajors = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldEducationSchools() {     return mEducationSchools;   }    public Targeting setFieldEducationSchools(List value) {     this.mEducationSchools = value;     return this;   }    public Targeting setFieldEducationSchools(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mEducationSchools = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldEducationStatuses() {     return mEducationStatuses;   }    public Targeting setFieldEducationStatuses(List value) {     this.mEducationStatuses = value;     return this;   }    public List getFieldEffectiveAudienceNetworkPositions() {     return mEffectiveAudienceNetworkPositions;   }    public Targeting setFieldEffectiveAudienceNetworkPositions(List value) {     this.mEffectiveAudienceNetworkPositions = value;     return this;   }    public List getFieldEffectiveDevicePlatforms() {     return mEffectiveDevicePlatforms;   }    public Targeting setFieldEffectiveDevicePlatforms(List value) {     this.mEffectiveDevicePlatforms = value;     return this;   }    public List getFieldEffectiveFacebookPositions() {     return mEffectiveFacebookPositions;   }    public Targeting setFieldEffectiveFacebookPositions(List value) {     this.mEffectiveFacebookPositions = value;     return this;   }    public List getFieldEffectiveInstagramPositions() {     return mEffectiveInstagramPositions;   }    public Targeting setFieldEffectiveInstagramPositions(List value) {     this.mEffectiveInstagramPositions = value;     return this;   }    public List getFieldEffectiveMessengerPositions() {     return mEffectiveMessengerPositions;   }    public Targeting setFieldEffectiveMessengerPositions(List value) {     this.mEffectiveMessengerPositions = value;     return this;   }    public List getFieldEffectivePublisherPlatforms() {     return mEffectivePublisherPlatforms;   }    public Targeting setFieldEffectivePublisherPlatforms(List value) {     this.mEffectivePublisherPlatforms = value;     return this;   }    public List getFieldEngagementSpecs() {     return mEngagementSpecs;   }    public Targeting setFieldEngagementSpecs(List value) {     this.mEngagementSpecs = value;     return this;   }    public Targeting setFieldEngagementSpecs(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mEngagementSpecs = TargetingDynamicRule.getGson().fromJson(value, type);     return this;   }   public List getFieldEthnicAffinity() {     return mEthnicAffinity;   }    public Targeting setFieldEthnicAffinity(List value) {     this.mEthnicAffinity = value;     return this;   }    public Targeting setFieldEthnicAffinity(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mEthnicAffinity = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldExcludeReachedSince() {     return mExcludeReachedSince;   }    public Targeting setFieldExcludeReachedSince(List value) {     this.mExcludeReachedSince = value;     return this;   }    public List getFieldExcludedConnections() {     return mExcludedConnections;   }    public Targeting setFieldExcludedConnections(List value) {     this.mExcludedConnections = value;     return this;   }    public Targeting setFieldExcludedConnections(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mExcludedConnections = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldExcludedCustomAudiences() {     return mExcludedCustomAudiences;   }    public Targeting setFieldExcludedCustomAudiences(List value) {     this.mExcludedCustomAudiences = value;     return this;   }    public Targeting setFieldExcludedCustomAudiences(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mExcludedCustomAudiences = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldExcludedDynamicAudienceIds() {     return mExcludedDynamicAudienceIds;   }    public Targeting setFieldExcludedDynamicAudienceIds(List value) {     this.mExcludedDynamicAudienceIds = value;     return this;   }    public List getFieldExcludedEngagementSpecs() {     return mExcludedEngagementSpecs;   }    public Targeting setFieldExcludedEngagementSpecs(List value) {     this.mExcludedEngagementSpecs = value;     return this;   }    public Targeting setFieldExcludedEngagementSpecs(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mExcludedEngagementSpecs = TargetingDynamicRule.getGson().fromJson(value, type);     return this;   }   public TargetingGeoLocation getFieldExcludedGeoLocations() {     return mExcludedGeoLocations;   }    public Targeting setFieldExcludedGeoLocations(TargetingGeoLocation value) {     this.mExcludedGeoLocations = value;     return this;   }    public Targeting setFieldExcludedGeoLocations(String value) {     Type type = new TypeToken(){}.getType();     this.mExcludedGeoLocations = TargetingGeoLocation.getGson().fromJson(value, type);     return this;   }   public List getFieldExcludedMobileDeviceModel() {     return mExcludedMobileDeviceModel;   }    public Targeting setFieldExcludedMobileDeviceModel(List value) {     this.mExcludedMobileDeviceModel = value;     return this;   }    public List getFieldExcludedProductAudienceSpecs() {     return mExcludedProductAudienceSpecs;   }    public Targeting setFieldExcludedProductAudienceSpecs(List value) {     this.mExcludedProductAudienceSpecs = value;     return this;   }    public Targeting setFieldExcludedProductAudienceSpecs(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mExcludedProductAudienceSpecs = TargetingProductAudienceSpec.getGson().fromJson(value, type);     return this;   }   public List getFieldExcludedPublisherCategories() {     return mExcludedPublisherCategories;   }    public Targeting setFieldExcludedPublisherCategories(List value) {     this.mExcludedPublisherCategories = value;     return this;   }    public List getFieldExcludedPublisherListIds() {     return mExcludedPublisherListIds;   }    public Targeting setFieldExcludedPublisherListIds(List value) {     this.mExcludedPublisherListIds = value;     return this;   }    public List getFieldExcludedUserDevice() {     return mExcludedUserDevice;   }    public Targeting setFieldExcludedUserDevice(List value) {     this.mExcludedUserDevice = value;     return this;   }    public FlexibleTargeting getFieldExclusions() {     return mExclusions;   }    public Targeting setFieldExclusions(FlexibleTargeting value) {     this.mExclusions = value;     return this;   }    public Targeting setFieldExclusions(String value) {     Type type = new TypeToken(){}.getType();     this.mExclusions = FlexibleTargeting.getGson().fromJson(value, type);     return this;   }   public List getFieldFacebookPositions() {     return mFacebookPositions;   }    public Targeting setFieldFacebookPositions(List value) {     this.mFacebookPositions = value;     return this;   }    public List getFieldFamilyStatuses() {     return mFamilyStatuses;   }    public Targeting setFieldFamilyStatuses(List value) {     this.mFamilyStatuses = value;     return this;   }    public Targeting setFieldFamilyStatuses(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mFamilyStatuses = IDName.getGson().fromJson(value, type);     return this;   }   public String getFieldFbDealId() {     return mFbDealId;   }    public Targeting setFieldFbDealId(String value) {     this.mFbDealId = value;     return this;   }    public List getFieldFlexibleSpec() {     return mFlexibleSpec;   }    public Targeting setFieldFlexibleSpec(List value) {     this.mFlexibleSpec = value;     return this;   }    public Targeting setFieldFlexibleSpec(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mFlexibleSpec = FlexibleTargeting.getGson().fromJson(value, type);     return this;   }   public List getFieldFriendsOfConnections() {     return mFriendsOfConnections;   }    public Targeting setFieldFriendsOfConnections(List value) {     this.mFriendsOfConnections = value;     return this;   }    public Targeting setFieldFriendsOfConnections(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mFriendsOfConnections = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldGenders() {     return mGenders;   }    public Targeting setFieldGenders(List value) {     this.mGenders = value;     return this;   }    public List getFieldGeneration() {     return mGeneration;   }    public Targeting setFieldGeneration(List value) {     this.mGeneration = value;     return this;   }    public Targeting setFieldGeneration(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mGeneration = IDName.getGson().fromJson(value, type);     return this;   }   public TargetingGeoLocation getFieldGeoLocations() {     return mGeoLocations;   }    public Targeting setFieldGeoLocations(TargetingGeoLocation value) {     this.mGeoLocations = value;     return this;   }    public Targeting setFieldGeoLocations(String value) {     Type type = new TypeToken(){}.getType();     this.mGeoLocations = TargetingGeoLocation.getGson().fromJson(value, type);     return this;   }   public List getFieldHomeOwnership() {     return mHomeOwnership;   }    public Targeting setFieldHomeOwnership(List value) {     this.mHomeOwnership = value;     return this;   }    public Targeting setFieldHomeOwnership(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mHomeOwnership = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldHomeType() {     return mHomeType;   }    public Targeting setFieldHomeType(List value) {     this.mHomeType = value;     return this;   }    public Targeting setFieldHomeType(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mHomeType = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldHomeValue() {     return mHomeValue;   }    public Targeting setFieldHomeValue(List value) {     this.mHomeValue = value;     return this;   }    public Targeting setFieldHomeValue(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mHomeValue = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldHouseholdComposition() {     return mHouseholdComposition;   }    public Targeting setFieldHouseholdComposition(List value) {     this.mHouseholdComposition = value;     return this;   }    public Targeting setFieldHouseholdComposition(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mHouseholdComposition = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldIncome() {     return mIncome;   }    public Targeting setFieldIncome(List value) {     this.mIncome = value;     return this;   }    public Targeting setFieldIncome(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mIncome = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldIndustries() {     return mIndustries;   }    public Targeting setFieldIndustries(List value) {     this.mIndustries = value;     return this;   }    public Targeting setFieldIndustries(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mIndustries = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldInstagramPositions() {     return mInstagramPositions;   }    public Targeting setFieldInstagramPositions(List value) {     this.mInstagramPositions = value;     return this;   }    public List getFieldInstreamVideoSponsorshipPlacements() {     return mInstreamVideoSponsorshipPlacements;   }    public Targeting setFieldInstreamVideoSponsorshipPlacements(List value) {     this.mInstreamVideoSponsorshipPlacements = value;     return this;   }    public List getFieldInterestedIn() {     return mInterestedIn;   }    public Targeting setFieldInterestedIn(List value) {     this.mInterestedIn = value;     return this;   }    public List getFieldInterests() {     return mInterests;   }    public Targeting setFieldInterests(List value) {     this.mInterests = value;     return this;   }    public Targeting setFieldInterests(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mInterests = IDName.getGson().fromJson(value, type);     return this;   }   public Boolean getFieldIsWhatsappDestinationAd() {     return mIsWhatsappDestinationAd;   }    public Targeting setFieldIsWhatsappDestinationAd(Boolean value) {     this.mIsWhatsappDestinationAd = value;     return this;   }    public List getFieldKeywords() {     return mKeywords;   }    public Targeting setFieldKeywords(List value) {     this.mKeywords = value;     return this;   }    public List getFieldLifeEvents() {     return mLifeEvents;   }    public Targeting setFieldLifeEvents(List value) {     this.mLifeEvents = value;     return this;   }    public Targeting setFieldLifeEvents(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mLifeEvents = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldLocales() {     return mLocales;   }    public Targeting setFieldLocales(List value) {     this.mLocales = value;     return this;   }    public List getFieldMessengerPositions() {     return mMessengerPositions;   }    public Targeting setFieldMessengerPositions(List value) {     this.mMessengerPositions = value;     return this;   }    public List getFieldMoms() {     return mMoms;   }    public Targeting setFieldMoms(List value) {     this.mMoms = value;     return this;   }    public Targeting setFieldMoms(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mMoms = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldNetWorth() {     return mNetWorth;   }    public Targeting setFieldNetWorth(List value) {     this.mNetWorth = value;     return this;   }    public Targeting setFieldNetWorth(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mNetWorth = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldOfficeType() {     return mOfficeType;   }    public Targeting setFieldOfficeType(List value) {     this.mOfficeType = value;     return this;   }    public Targeting setFieldOfficeType(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mOfficeType = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldPlacePageSetIds() {     return mPlacePageSetIds;   }    public Targeting setFieldPlacePageSetIds(List value) {     this.mPlacePageSetIds = value;     return this;   }    public List getFieldPoliticalViews() {     return mPoliticalViews;   }    public Targeting setFieldPoliticalViews(List value) {     this.mPoliticalViews = value;     return this;   }    public List getFieldPolitics() {     return mPolitics;   }    public Targeting setFieldPolitics(List value) {     this.mPolitics = value;     return this;   }    public Targeting setFieldPolitics(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mPolitics = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldProductAudienceSpecs() {     return mProductAudienceSpecs;   }    public Targeting setFieldProductAudienceSpecs(List value) {     this.mProductAudienceSpecs = value;     return this;   }    public Targeting setFieldProductAudienceSpecs(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mProductAudienceSpecs = TargetingProductAudienceSpec.getGson().fromJson(value, type);     return this;   }   public TargetingProspectingAudience getFieldProspectingAudience() {     return mProspectingAudience;   }    public Targeting setFieldProspectingAudience(TargetingProspectingAudience value) {     this.mProspectingAudience = value;     return this;   }    public Targeting setFieldProspectingAudience(String value) {     Type type = new TypeToken(){}.getType();     this.mProspectingAudience = TargetingProspectingAudience.getGson().fromJson(value, type);     return this;   }   public List getFieldPublisherPlatforms() {     return mPublisherPlatforms;   }    public Targeting setFieldPublisherPlatforms(List value) {     this.mPublisherPlatforms = value;     return this;   }    public List getFieldPublisherVisibilityCategories() {     return mPublisherVisibilityCategories;   }    public Targeting setFieldPublisherVisibilityCategories(List value) {     this.mPublisherVisibilityCategories = value;     return this;   }    public String getFieldRadius() {     return mRadius;   }    public Targeting setFieldRadius(String value) {     this.mRadius = value;     return this;   }    public List getFieldRegions() {     return mRegions;   }    public Targeting setFieldRegions(List value) {     this.mRegions = value;     return this;   }    public Targeting setFieldRegions(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mRegions = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldRelationshipStatuses() {     return mRelationshipStatuses;   }    public Targeting setFieldRelationshipStatuses(List value) {     this.mRelationshipStatuses = value;     return this;   }    public List getFieldSiteCategory() {     return mSiteCategory;   }    public Targeting setFieldSiteCategory(List value) {     this.mSiteCategory = value;     return this;   }    public String getFieldTargetingOptimization() {     return mTargetingOptimization;   }    public Targeting setFieldTargetingOptimization(String value) {     this.mTargetingOptimization = value;     return this;   }    public List getFieldUserAdclusters() {     return mUserAdclusters;   }    public Targeting setFieldUserAdclusters(List value) {     this.mUserAdclusters = value;     return this;   }    public Targeting setFieldUserAdclusters(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mUserAdclusters = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldUserDevice() {     return mUserDevice;   }    public Targeting setFieldUserDevice(List value) {     this.mUserDevice = value;     return this;   }    public List getFieldUserEvent() {     return mUserEvent;   }    public Targeting setFieldUserEvent(List value) {     this.mUserEvent = value;     return this;   }    public List getFieldUserOs() {     return mUserOs;   }    public Targeting setFieldUserOs(List value) {     this.mUserOs = value;     return this;   }    public List getFieldWirelessCarrier() {     return mWirelessCarrier;   }    public Targeting setFieldWirelessCarrier(List value) {     this.mWirelessCarrier = value;     return this;   }    public List getFieldWorkEmployers() {     return mWorkEmployers;   }    public Targeting setFieldWorkEmployers(List value) {     this.mWorkEmployers = value;     return this;   }    public Targeting setFieldWorkEmployers(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mWorkEmployers = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldWorkPositions() {     return mWorkPositions;   }    public Targeting setFieldWorkPositions(List value) {     this.mWorkPositions = value;     return this;   }    public Targeting setFieldWorkPositions(String value) {     Type type = new TypeToken&gt;(){}.getType();     this.mWorkPositions = IDName.getGson().fromJson(value, type);     return this;   }   public List getFieldZips() {     return mZips;   }    public Targeting setFieldZips(List value) {     this.mZips = value;     return this;   }      public static enum EnumDevicePlatforms {       @SerializedName(&quot;connected_tv&quot;)       VALUE_CONNECTED_TV(&quot;connected_tv&quot;),       @SerializedName(&quot;desktop&quot;)       VALUE_DESKTOP(&quot;desktop&quot;),       @SerializedName(&quot;mobile&quot;)       VALUE_MOBILE(&quot;mobile&quot;),       NULL(null);        private String value;        private EnumDevicePlatforms(String value) {         this.value = value;       }        @Override       public String toString() {         return value;       }   }    public static enum EnumEffectiveDevicePlatforms {       @SerializedName(&quot;connected_tv&quot;)       VALUE_CONNECTED_TV(&quot;connected_tv&quot;),       @SerializedName(&quot;desktop&quot;)       VALUE_DESKTOP(&quot;desktop&quot;),       @SerializedName(&quot;mobile&quot;)       VALUE_MOBILE(&quot;mobile&quot;),       NULL(null);        private String value;        private EnumEffectiveDevicePlatforms(String value) {         this.value = value;       }        @Override       public String toString() {         return value;       }   }     synchronized /*package*/ static Gson getGson() {     if (gson != null) {       return gson;     } else {       gson = new GsonBuilder()         .excludeFieldsWithModifiers(Modifier.STATIC)         .excludeFieldsWithModifiers(Modifier.PROTECTED)         .disableHtmlEscaping()         .create();     }     return gson;   }    public Targeting copyFrom(Targeting instance) {     this.mAdgroupId = instance.mAdgroupId;     this.mAgeMax = instance.mAgeMax;     this.mAgeMin = instance.mAgeMin;     this.mAlternateAutoTargetingOption = instance.mAlternateAutoTargetingOption;     this.mAppInstallState = instance.mAppInstallState;     this.mAudienceNetworkPositions = instance.mAudienceNetworkPositions;     this.mBehaviors = instance.mBehaviors;     this.mBrandSafetyContentFilterLevels = instance.mBrandSafetyContentFilterLevels;     this.mBrandSafetyContentSeverityLevels = instance.mBrandSafetyContentSeverityLevels;     this.mCatalogBasedTargeting = instance.mCatalogBasedTargeting;     this.mCities = instance.mCities;     this.mCollegeYears = instance.mCollegeYears;     this.mConnections = instance.mConnections;     this.mContextualTargetingCategories = instance.mContextualTargetingCategories;     this.mCountries = instance.mCountries;     this.mCountry = instance.mCountry;     this.mCountryGroups = instance.mCountryGroups;     this.mCustomAudiences = instance.mCustomAudiences;     this.mDevicePlatforms = instance.mDevicePlatforms;     this.mDirectInstallDevices = instance.mDirectInstallDevices;     this.mDynamicAudienceIds = instance.mDynamicAudienceIds;     this.mEducationMajors = instance.mEducationMajors;     this.mEducationSchools = instance.mEducationSchools;     this.mEducationStatuses = instance.mEducationStatuses;     this.mEffectiveAudienceNetworkPositions = instance.mEffectiveAudienceNetworkPositions;     this.mEffectiveDevicePlatforms = instance.mEffectiveDevicePlatforms;     this.mEffectiveFacebookPositions = instance.mEffectiveFacebookPositions;     this.mEffectiveInstagramPositions = instance.mEffectiveInstagramPositions;     this.mEffectiveMessengerPositions = instance.mEffectiveMessengerPositions;     this.mEffectivePublisherPlatforms = instance.mEffectivePublisherPlatforms;     this.mEngagementSpecs = instance.mEngagementSpecs;     this.mEthnicAffinity = instance.mEthnicAffinity;     this.mExcludeReachedSince = instance.mExcludeReachedSince;     this.mExcludedConnections = instance.mExcludedConnections;     this.mExcludedCustomAudiences = instance.mExcludedCustomAudiences;     this.mExcludedDynamicAudienceIds = instance.mExcludedDynamicAudienceIds;     this.mExcludedEngagementSpecs = instance.mExcludedEngagementSpecs;     this.mExcludedGeoLocations = instance.mExcludedGeoLocations;     this.mExcludedMobileDeviceModel = instance.mExcludedMobileDeviceModel;     this.mExcludedProductAudienceSpecs = instance.mExcludedProductAudienceSpecs;     this.mExcludedPublisherCategories = instance.mExcludedPublisherCategories;     this.mExcludedPublisherListIds = instance.mExcludedPublisherListIds;     this.mExcludedUserDevice = instance.mExcludedUserDevice;     this.mExclusions = instance.mExclusions;     this.mFacebookPositions = instance.mFacebookPositions;     this.mFamilyStatuses = instance.mFamilyStatuses;     this.mFbDealId = instance.mFbDealId;     this.mFlexibleSpec = instance.mFlexibleSpec;     this.mFriendsOfConnections = instance.mFriendsOfConnections;     this.mGenders = instance.mGenders;     this.mGeneration = instance.mGeneration;     this.mGeoLocations = instance.mGeoLocations;     this.mHomeOwnership = instance.mHomeOwnership;     this.mHomeType = instance.mHomeType;     this.mHomeValue = instance.mHomeValue;     this.mHouseholdComposition = instance.mHouseholdComposition;     this.mIncome = instance.mIncome;     this.mIndustries = instance.mIndustries;     this.mInstagramPositions = instance.mInstagramPositions;     this.mInstreamVideoSponsorshipPlacements = instance.mInstreamVideoSponsorshipPlacements;     this.mInterestedIn = instance.mInterestedIn;     this.mInterests = instance.mInterests;     this.mIsWhatsappDestinationAd = instance.mIsWhatsappDestinationAd;     this.mKeywords = instance.mKeywords;     this.mLifeEvents = instance.mLifeEvents;     this.mLocales = instance.mLocales;     this.mMessengerPositions = instance.mMessengerPositions;     this.mMoms = instance.mMoms;     this.mNetWorth = instance.mNetWorth;     this.mOfficeType = instance.mOfficeType;     this.mPlacePageSetIds = instance.mPlacePageSetIds;     this.mPoliticalViews = instance.mPoliticalViews;     this.mPolitics = instance.mPolitics;     this.mProductAudienceSpecs = instance.mProductAudienceSpecs;     this.mProspectingAudience = instance.mProspectingAudience;     this.mPublisherPlatforms = instance.mPublisherPlatforms;     this.mPublisherVisibilityCategories = instance.mPublisherVisibilityCategories;     this.mRadius = instance.mRadius;     this.mRegions = instance.mRegions;     this.mRelationshipStatuses = instance.mRelationshipStatuses;     this.mSiteCategory = instance.mSiteCategory;     this.mTargetingOptimization = instance.mTargetingOptimization;     this.mUserAdclusters = instance.mUserAdclusters;     this.mUserDevice = instance.mUserDevice;     this.mUserEvent = instance.mUserEvent;     this.mUserOs = instance.mUserOs;     this.mWirelessCarrier = instance.mWirelessCarrier;     this.mWorkEmployers = instance.mWorkEmployers;     this.mWorkPositions = instance.mWorkPositions;     this.mZips = instance.mZips;     this.context = instance.context;     this.rawValue = instance.rawValue;     return this;   }    public static APIRequest.ResponseParser getParser() {     return new APIRequest.ResponseParser() {       public APINodeList parseResponse(String response, APIContext context, APIRequest request, String header) throws MalformedResponseException {         return Targeting.parseResponse(response, context, request, header);       }     };   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5404</td>
    <td align="left">https://github.com/facebook/facebook-java-business-sdk/blob/561f1a75e1220b55a160a1b92b0187f72be9cd08/src/main/java/com/facebook/ads/sdk/Targeting.java/#L57-L1555</td>
    <td align="right">1</td>
    <td align="right">519</td>
    <td align="right">5404</td>
  </tr>
  <tr valign="top">
    <td align="right">1981</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{       &quot;message&quot;: &quot;YES I found bad smells&quot;,       &quot;bad_smells&quot;: [          {             &quot;1&quot;: &quot;Data Class&quot;          },          {             &quot;2&quot;: &quot;Long Method&quot;          }       ]    }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class PageExtractor {     private PDDocument sourceDocument;          // first page to extract is page 1 (by default)     private int startPage = 1;          private int endPage = 0;          /**       * Creates a new instance of PageExtractor      * @param sourceDocument The document to split.      */     public PageExtractor(PDDocument sourceDocument)     {         this.sourceDocument = sourceDocument;         endPage = sourceDocument.getNumberOfPages();     }          /**       * Creates a new instance of PageExtractor      * @param sourceDocument The document to split.      * @param startPage The first page you want extracted (inclusive)      * @param endPage The last page you want extracted (inclusive)      */     public PageExtractor(PDDocument sourceDocument, int startPage, int endPage)     {         this(sourceDocument);         this.startPage = startPage;         this.endPage = endPage;     }          /**      * This will take a document and extract the desired pages into a new       * document.  Both startPage and endPage are included in the extracted       * document.  If the endPage is greater than the number of pages in the       * source document, it will go to the end of the document.  If startPage is      * less than 1, it'll start with page 1.  If startPage is greater than       * endPage or greater than the number of pages in the source document, a       * blank document will be returned.      *       * @return The extracted document      * @throws IOException If there is an IOError      */     public PDDocument extract() throws IOException     {         PDDocument extractedDocument = new PDDocument();         extractedDocument.setDocumentInformation(sourceDocument.getDocumentInformation());         extractedDocument.getDocumentCatalog().setViewerPreferences(                 sourceDocument.getDocumentCatalog().getViewerPreferences());                  for (int i = startPage; i &lt;= endPage; i++)         {             PDPage page = sourceDocument.getPage(i - 1);             PDPage imported = extractedDocument.importPage(page);             imported.setCropBox(page.getCropBox());             imported.setMediaBox(page.getMediaBox());             imported.setResources(page.getResources());             imported.setRotation(page.getRotation());         }                      return extractedDocument;     }      /**      * Gets the first page number to be extracted.      * @return the first page number which should be extracted      */     public int getStartPage()     {         return startPage;     }      /**      * Sets the first page number to be extracted.      * @param startPage the first page number which should be extracted      */     public void setStartPage(int startPage)     {         this.startPage = startPage;     }      /**      * Gets the last page number (inclusive) to be extracted.      * @return the last page number which should be extracted      */     public int getEndPage()     {         return endPage;     }      /**      * Sets the last page number to be extracted.      * @param endPage the last page number which should be extracted      */     public void setEndPage(int endPage)     {         this.endPage = endPage;     } }</td>
    <td align="left">data class</td>
    <td align="left">1: data class, 2: long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">&nbsp;2: long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">12639</td>
    <td align="left">https://github.com/apache/pdfbox/blob/443b7dd95c57bc83598c8c5d514ebb44a4133a43/pdfbox/src/main/java/org/apache/pdfbox/multipdf/PageExtractor.java/#L28-L127</td>
    <td align="right">1</td>
    <td align="right">1981</td>
    <td align="right">12639</td>
  </tr>
  <tr valign="top">
    <td align="right">1183</td>
    <td align="left">&nbsp;&nbsp;YES, I found bad smells: 1. Feature envy  2. Duplicate code  3. Long method  4. Data class  5. Lazy class  6. Large class</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
  protected static class OnheapDecodedCell implements ExtendedCell {     private static final long FIXED_OVERHEAD = ClassSize.align(ClassSize.OBJECT         + (3 * ClassSize.REFERENCE) + (2 * Bytes.SIZEOF_LONG) + (7 * Bytes.SIZEOF_INT)         + (Bytes.SIZEOF_SHORT) + (2 * Bytes.SIZEOF_BYTE) + (3 * ClassSize.ARRAY));     private byte[] keyOnlyBuffer;     private short rowLength;     private int familyOffset;     private byte familyLength;     private int qualifierOffset;     private int qualifierLength;     private long timestamp;     private byte typeByte;     private byte[] valueBuffer;     private int valueOffset;     private int valueLength;     private byte[] tagsBuffer;     private int tagsOffset;     private int tagsLength;     private long seqId;      protected OnheapDecodedCell(byte[] keyBuffer, short rowLength, int familyOffset,         byte familyLength, int qualOffset, int qualLength, long timeStamp, byte typeByte,         byte[] valueBuffer, int valueOffset, int valueLen, long seqId, byte[] tagsBuffer,         int tagsOffset, int tagsLength) {       this.keyOnlyBuffer = keyBuffer;       this.rowLength = rowLength;       this.familyOffset = familyOffset;       this.familyLength = familyLength;       this.qualifierOffset = qualOffset;       this.qualifierLength = qualLength;       this.timestamp = timeStamp;       this.typeByte = typeByte;       this.valueBuffer = valueBuffer;       this.valueOffset = valueOffset;       this.valueLength = valueLen;       this.tagsBuffer = tagsBuffer;       this.tagsOffset = tagsOffset;       this.tagsLength = tagsLength;       setSequenceId(seqId);     }      @Override     public byte[] getRowArray() {       return keyOnlyBuffer;     }      @Override     public byte[] getFamilyArray() {       return keyOnlyBuffer;     }      @Override     public byte[] getQualifierArray() {       return keyOnlyBuffer;     }      @Override     public int getRowOffset() {       return Bytes.SIZEOF_SHORT;     }      @Override     public short getRowLength() {       return rowLength;     }      @Override     public int getFamilyOffset() {       return familyOffset;     }      @Override     public byte getFamilyLength() {       return familyLength;     }      @Override     public int getQualifierOffset() {       return qualifierOffset;     }      @Override     public int getQualifierLength() {       return qualifierLength;     }      @Override     public long getTimestamp() {       return timestamp;     }      @Override     public byte getTypeByte() {       return typeByte;     }      @Override     public long getSequenceId() {       return seqId;     }      @Override     public byte[] getValueArray() {       return this.valueBuffer;     }      @Override     public int getValueOffset() {       return valueOffset;     }      @Override     public int getValueLength() {       return valueLength;     }      @Override     public byte[] getTagsArray() {       return this.tagsBuffer;     }      @Override     public int getTagsOffset() {       return this.tagsOffset;     }      @Override     public int getTagsLength() {       return tagsLength;     }      @Override     public String toString() {       return KeyValue.keyToString(this.keyOnlyBuffer, 0, KeyValueUtil.keyLength(this)) + &quot;/vlen=&quot;           + getValueLength() + &quot;/seqid=&quot; + seqId;     }      @Override     public void setSequenceId(long seqId) {       this.seqId = seqId;     }      @Override     public long heapSize() {       return FIXED_OVERHEAD + rowLength + familyLength + qualifierLength + valueLength + tagsLength;     }      @Override     public int write(OutputStream out, boolean withTags) throws IOException {       int lenToWrite = getSerializedSize(withTags);       ByteBufferUtils.putInt(out, keyOnlyBuffer.length);       ByteBufferUtils.putInt(out, valueLength);       // Write key       out.write(keyOnlyBuffer);       // Write value       out.write(this.valueBuffer, this.valueOffset, this.valueLength);       if (withTags &amp;&amp; this.tagsLength &gt; 0) {         // 2 bytes tags length followed by tags bytes         // tags length is serialized with 2 bytes only(short way) even if the type is int.         // As this is non -ve numbers, we save the sign bit. See HBASE-11437         out.write((byte) (0xff &amp; (this.tagsLength &gt;&gt; 8)));         out.write((byte) (0xff &amp; this.tagsLength));         out.write(this.tagsBuffer, this.tagsOffset, this.tagsLength);       }       return lenToWrite;     }      @Override     public int getSerializedSize(boolean withTags) {       return KeyValueUtil.length(rowLength, familyLength, qualifierLength, valueLength, tagsLength,           withTags);     }      @Override     public void write(ByteBuffer buf, int offset) {       // This is not used in actual flow. Throwing UnsupportedOperationException       throw new UnsupportedOperationException();     }      @Override     public void setTimestamp(long ts) throws IOException {       // This is not used in actual flow. Throwing UnsupportedOperationException       throw new UnsupportedOperationException();     }      @Override     public void setTimestamp(byte[] ts) throws IOException {       // This is not used in actual flow. Throwing UnsupportedOperationException       throw new UnsupportedOperationException();     }      @Override     public ExtendedCell deepClone() {       // This is not used in actual flow. Throwing UnsupportedOperationException       throw new UnsupportedOperationException();     }   }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Feature envy 2 Duplicate code 3 Long method 4 Data class 5 Lazy class 6 Large class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10238</td>
    <td align="left">https://github.com/apache/hbase/blob/44f8abd5c65c59e9d09f6ad14b3c825f145d8e4f/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/BufferedDataBlockEncoder.java/#L282-L478</td>
    <td align="right">2</td>
    <td align="right">1183</td>
    <td align="right">10238</td>
  </tr>
  <tr valign="top">
    <td align="right">2489</td>
    <td align="left">{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;the bad smells are&quot;: [     &quot;Data Class&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class InternalCacheBuilder {   private static final Logger logger = LogService.getLogger();    private static final String USE_ASYNC_EVENT_LISTENERS_PROPERTY =       GEMFIRE_PREFIX + &quot;Cache.ASYNC_EVENT_LISTENERS&quot;;    private static final boolean IS_EXISTING_OK_DEFAULT = true;   private static final boolean IS_CLIENT_DEFAULT = false;    private final Properties configProperties;   private final CacheConfig cacheConfig;   private final CompositeMeterRegistryFactory compositeMeterRegistryFactory;   private final Consumer metricsSessionInitializer;   private final Supplier singletonSystemSupplier;   private final Supplier singletonCacheSupplier;   private final InternalDistributedSystemConstructor internalDistributedSystemConstructor;   private final InternalCacheConstructor internalCacheConstructor;    private boolean isExistingOk = IS_EXISTING_OK_DEFAULT;   private boolean isClient = IS_CLIENT_DEFAULT;    /**    * Setting useAsyncEventListeners to true will invoke event listeners in asynchronously.    *    *     * Default is specified by system property {@code gemfire.Cache.ASYNC_EVENT_LISTENERS}.    */   private boolean useAsyncEventListeners = Boolean.getBoolean(USE_ASYNC_EVENT_LISTENERS_PROPERTY);    private PoolFactory poolFactory;   private TypeRegistry typeRegistry;    /**    * Creates a cache factory with default configuration properties.    */   public InternalCacheBuilder() {     this(new Properties(), new CacheConfig());   }    /**    * Create a cache factory initialized with the given configuration properties. For a list of valid    * configuration properties and their meanings see {@link ConfigurationProperties}.    *    * @param configProperties the configuration properties to initialize the factory with.    */   public InternalCacheBuilder(Properties configProperties) {     this(configProperties == null ? new Properties() : configProperties, new CacheConfig());   }    /**    * Creates a cache factory with default configuration properties.    */   public InternalCacheBuilder(CacheConfig cacheConfig) {     this(new Properties(), cacheConfig);   }    private InternalCacheBuilder(Properties configProperties, CacheConfig cacheConfig) {     this(configProperties,         cacheConfig,         new CacheMeterRegistryFactory(),         CacheLifecycleMetricsSession.builder()::build,         InternalDistributedSystem::getConnectedInstance,         InternalDistributedSystem::connectInternal,         GemFireCacheImpl::getInstance,         GemFireCacheImpl::new);   }    @VisibleForTesting   InternalCacheBuilder(Properties configProperties,       CacheConfig cacheConfig,       CompositeMeterRegistryFactory compositeMeterRegistryFactory,       Consumer metricsSessionInitializer,       Supplier singletonSystemSupplier,       InternalDistributedSystemConstructor internalDistributedSystemConstructor,       Supplier singletonCacheSupplier,       InternalCacheConstructor internalCacheConstructor) {     this.configProperties = configProperties;     this.cacheConfig = cacheConfig;     this.compositeMeterRegistryFactory = compositeMeterRegistryFactory;     this.metricsSessionInitializer = metricsSessionInitializer;     this.singletonSystemSupplier = singletonSystemSupplier;     this.internalDistributedSystemConstructor = internalDistributedSystemConstructor;     this.internalCacheConstructor = internalCacheConstructor;     this.singletonCacheSupplier = singletonCacheSupplier;   }    /**    * @see CacheFactory#create()    *    * @throws CacheXmlException If a problem occurs while parsing the declarative caching XML file.    * @throws TimeoutException If a {@link Region#put(Object, Object)} times out while initializing    *         the cache.    * @throws CacheWriterException If a {@code CacheWriterException} is thrown while initializing the    *         cache.    * @throws GatewayException If a {@code GatewayException} is thrown while initializing the cache.    * @throws RegionExistsException If the declarative caching XML file describes a region that    *         already exists (including the root region).    * @throws IllegalStateException if cache already exists and is not compatible with the new    *         configuration.    * @throws AuthenticationFailedException if authentication fails.    * @throws AuthenticationRequiredException if the distributed system is in secure mode and this    *         new member is not configured with security credentials.    */   public InternalCache create()       throws TimeoutException, CacheWriterException, GatewayException, RegionExistsException {     synchronized (InternalCacheBuilder.class) {       InternalDistributedSystem internalDistributedSystem = findInternalDistributedSystem()           .orElseGet(() -&gt; createInternalDistributedSystem());       return create(internalDistributedSystem);     }   }    /**    * @see CacheFactory#create(DistributedSystem)    *    * @throws IllegalArgumentException If {@code system} is not {@link DistributedSystem#isConnected    *         connected}.    * @throws CacheExistsException If an open cache already exists.    * @throws CacheXmlException If a problem occurs while parsing the declarative caching XML file.    * @throws TimeoutException If a {@link Region#put(Object, Object)} times out while initializing    *         the cache.    * @throws CacheWriterException If a {@code CacheWriterException} is thrown while initializing the    *         cache.    * @throws GatewayException If a {@code GatewayException} is thrown while initializing the cache.    * @throws RegionExistsException If the declarative caching XML file describes a region that    *         already exists (including the root region).    */   public InternalCache create(InternalDistributedSystem internalDistributedSystem)       throws TimeoutException, CacheWriterException, GatewayException, RegionExistsException {     requireNonNull(internalDistributedSystem, &quot;internalDistributedSystem&quot;);     try {       synchronized (InternalCacheBuilder.class) {         synchronized (GemFireCacheImpl.class) {           InternalCache cache =               existingCache(internalDistributedSystem::getCache, singletonCacheSupplier);           if (cache == null) {              int systemId = internalDistributedSystem.getConfig().getDistributedSystemId();             String memberName = internalDistributedSystem.getName();             String hostName = internalDistributedSystem.getDistributedMember().getHost();              CompositeMeterRegistry compositeMeterRegistry = compositeMeterRegistryFactory                 .create(systemId, memberName, hostName);              metricsSessionInitializer.accept(compositeMeterRegistry);              cache =                 internalCacheConstructor.construct(isClient, poolFactory, internalDistributedSystem,                     cacheConfig, useAsyncEventListeners, typeRegistry, compositeMeterRegistry);              internalDistributedSystem.setCache(cache);             cache.initialize();            } else {             internalDistributedSystem.setCache(cache);           }            return cache;         }       }     } catch (CacheXmlException | IllegalArgumentException e) {       logger.error(e.getLocalizedMessage());       throw e;     } catch (Error | RuntimeException e) {       logger.error(e);       throw e;     }   }    /**    * @see CacheFactory#set(String, String)    */   public InternalCacheBuilder set(String name, String value) {     configProperties.setProperty(name, value);     return this;   }    /**    * @see CacheFactory#setPdxReadSerialized(boolean)    */   public InternalCacheBuilder setPdxReadSerialized(boolean readSerialized) {     cacheConfig.setPdxReadSerialized(readSerialized);     return this;   }    /**    * @see CacheFactory#setSecurityManager(SecurityManager)    */   public InternalCacheBuilder setSecurityManager(SecurityManager securityManager) {     cacheConfig.setSecurityManager(securityManager);     return this;   }    /**    * @see CacheFactory#setPostProcessor(PostProcessor)    */   public InternalCacheBuilder setPostProcessor(PostProcessor postProcessor) {     cacheConfig.setPostProcessor(postProcessor);     return this;   }    /**    * @see CacheFactory#setPdxSerializer(PdxSerializer)    */   public InternalCacheBuilder setPdxSerializer(PdxSerializer serializer) {     cacheConfig.setPdxSerializer(serializer);     return this;   }    /**    * @see CacheFactory#setPdxDiskStore(String)    */   public InternalCacheBuilder setPdxDiskStore(String diskStoreName) {     cacheConfig.setPdxDiskStore(diskStoreName);     return this;   }    /**    * @see CacheFactory#setPdxPersistent(boolean)    */   public InternalCacheBuilder setPdxPersistent(boolean isPersistent) {     cacheConfig.setPdxPersistent(isPersistent);     return this;   }    /**    * @see CacheFactory#setPdxIgnoreUnreadFields(boolean)    */   public InternalCacheBuilder setPdxIgnoreUnreadFields(boolean ignore) {     cacheConfig.setPdxIgnoreUnreadFields(ignore);     return this;   }    public InternalCacheBuilder setCacheXMLDescription(String cacheXML) {     if (cacheXML != null) {       cacheConfig.setCacheXMLDescription(cacheXML);     }     return this;   }    /**    * @param isExistingOk default is true.    */   public InternalCacheBuilder setIsExistingOk(boolean isExistingOk) {     this.isExistingOk = isExistingOk;     return this;   }    /**    * @param isClient default is false.    */   public InternalCacheBuilder setIsClient(boolean isClient) {     this.isClient = isClient;     return this;   }    /**    * @param useAsyncEventListeners default is specified by the system property    *        {@code gemfire.Cache.ASYNC_EVENT_LISTENERS}.    */   public InternalCacheBuilder setUseAsyncEventListeners(boolean useAsyncEventListeners) {     this.useAsyncEventListeners = useAsyncEventListeners;     return this;   }    /**    * @param poolFactory default is null.    */   public InternalCacheBuilder setPoolFactory(PoolFactory poolFactory) {     this.poolFactory = poolFactory;     return this;   }    /**    * @param typeRegistry default is null.    */   public InternalCacheBuilder setTypeRegistry(TypeRegistry typeRegistry) {     this.typeRegistry = typeRegistry;     return this;   }    private Optional findInternalDistributedSystem() {     InternalDistributedSystem internalDistributedSystem = null;     if (configProperties.isEmpty() &amp;&amp; !ALLOW_MULTIPLE_SYSTEMS) {       // any ds will do       internalDistributedSystem = singletonSystemSupplier.get();       validateUsabilityOfSecurityCallbacks(internalDistributedSystem, cacheConfig);     }     return Optional.ofNullable(internalDistributedSystem);   }    private InternalDistributedSystem createInternalDistributedSystem() {     SecurityConfig securityConfig = new SecurityConfig(         cacheConfig.getSecurityManager(),         cacheConfig.getPostProcessor());      return internalDistributedSystemConstructor.construct(configProperties, securityConfig);   }    private InternalCache existingCache(Supplier systemCacheSupplier,       Supplier singletonCacheSupplier) {     InternalCache cache = ALLOW_MULTIPLE_SYSTEMS         ? systemCacheSupplier.get()         : singletonCacheSupplier.get();      if (validateExistingCache(cache)) {       return cache;     }      return null;   }    /**    * Validates that isExistingOk is true and existing cache is compatible with cacheConfig.    *    * if instance exists and cacheConfig is incompatible    * if instance exists and isExistingOk is false    */   private boolean validateExistingCache(InternalCache existingCache) {     if (existingCache == null || existingCache.isClosed()) {       return false;     }      if (isExistingOk) {       cacheConfig.validateCacheConfig(existingCache);     } else {       existingCache.throwCacheExistsException();     }      return true;   }    /**    * if existing DistributedSystem connection cannot use specified SecurityManager or    * PostProcessor.    */   private static void validateUsabilityOfSecurityCallbacks(       InternalDistributedSystem internalDistributedSystem, CacheConfig cacheConfig)       throws GemFireSecurityException {     if (internalDistributedSystem == null) {       return;     }     // pre-existing DistributedSystem already has an incompatible SecurityService in use     if (cacheConfig.getSecurityManager() != null) {       throw new GemFireSecurityException(           &quot;Existing DistributedSystem connection cannot use specified SecurityManager&quot;);     }     if (cacheConfig.getPostProcessor() != null) {       throw new GemFireSecurityException(           &quot;Existing DistributedSystem connection cannot use specified PostProcessor&quot;);     }   }    @VisibleForTesting   interface InternalCacheConstructor {     InternalCache construct(boolean isClient, PoolFactory poolFactory,         InternalDistributedSystem internalDistributedSystem, CacheConfig cacheConfig,         boolean useAsyncEventListeners, TypeRegistry typeRegistry, MeterRegistry meterRegistry);   }    @VisibleForTesting   interface InternalDistributedSystemConstructor {     InternalDistributedSystem construct(Properties configProperties, SecurityConfig securityConfig);   } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14615</td>
    <td align="left">https://github.com/apache/geode/blob/8fd839e8b73e40bd2dfd14f331b587431bd35a66/geode-core/src/main/java/org/apache/geode/internal/cache/InternalCacheBuilder.java/#L56-L420</td>
    <td align="right">1</td>
    <td align="right">2489</td>
    <td align="right">14615</td>
  </tr>
  <tr valign="top">
    <td align="right">2218</td>
    <td align="left">&nbsp;	{ 		&quot;message&quot;: &quot;YES I found bad smells&quot;, 		&quot;detected_bad_smells&quot;: [ 			&quot;1. Data Class&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class DQ_EvaluationMethodTypeCode         extends CodeListAdapter {     /**      * Empty constructor for JAXB only.      */     public DQ_EvaluationMethodTypeCode() {     }      /**      * Creates a new adapter for the given value.      */     private DQ_EvaluationMethodTypeCode(final CodeListUID value) {         super(value);     }      /**      * {@inheritDoc}      *      * @return the wrapper for the code list value.      */     @Override     protected DQ_EvaluationMethodTypeCode wrap(final CodeListUID value) {         return new DQ_EvaluationMethodTypeCode(value);     }      /**      * {@inheritDoc}      *      * @return the code list class.      */     @Override     protected Class getCodeListClass() {         return EvaluationMethodType.class;     }      /**      * Invoked by JAXB on marshalling.      *      * @return the value to be marshalled.      */     @Override     @XmlElement(name = &quot;DQ_EvaluationMethodTypeCode&quot;, namespace = Namespaces.MDQ)     public CodeListUID getElement() {         return identifier;     }      /**      * Invoked by JAXB on unmarshalling.      *      * @param  value  the unmarshalled value.      */     public void setElement(final CodeListUID value) {         identifier = value;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13542</td>
    <td align="left">https://github.com/apache/sis/blob/002121abc9b9826fbd51fac7150b3ee0c02cc88b/core/sis-metadata/src/main/java/org/apache/sis/internal/jaxb/code/DQ_EvaluationMethodTypeCode.java/#L36-L91</td>
    <td align="right">1</td>
    <td align="right">2218</td>
    <td align="right">13542</td>
  </tr>
  <tr valign="top">
    <td align="right">428</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [&quot;Data Class&quot;]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class AvroWrapper {   private T datum;    /** Wrap null. Construct {@link AvroWrapper} wrapping no datum. */   public AvroWrapper() { this(null); }    /** Wrap a datum. */   public AvroWrapper(T datum) { this.datum = datum; }    /** Return the wrapped datum. */   public T datum() { return datum; }    /** Set the wrapped datum. */   public void datum(T datum) { this.datum = datum; }    @Override   public int hashCode() {     return (datum == null) ? 0 : datum.hashCode();   }    @Override   public boolean equals(Object obj) {     if (this == obj)       return true;     if (obj == null)       return false;     if (getClass() != obj.getClass())       return false;     AvroWrapper that = (AvroWrapper)obj;     if (this.datum == null) {       return that.datum == null;     } else return datum.equals(that.datum);   }    /** Get the wrapped datum as JSON. */   @Override   public String toString() {     return datum.toString();   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4270</td>
    <td align="left">https://github.com/apache/avro/blob/1119b6eb5b92730b27e9798793bc67f192591c15/lang/java/mapred/src/main/java/org/apache/avro/mapred/AvroWrapper.java/#L22-L61</td>
    <td align="right">1</td>
    <td align="right">428</td>
    <td align="right">4270</td>
  </tr>
  <tr valign="top">
    <td align="right">1922</td>
    <td align="left">JSE I found bad smells: 1. Long method 2. Feature envy 3. Data class 4. Indecent exposure 5. Complexity 6. Shotgun surgery 7. Inappropriate Intimacy</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public abstract class ShareContent         implements ShareModel {     private final Uri contentUrl;     private final List peopleIds;     private final String placeId;     private final String pageId;     private final String ref;     private final ShareHashtag hashtag;      protected ShareContent(final Builder builder) {         super();         this.contentUrl = builder.contentUrl;         this.peopleIds = builder.peopleIds;         this.placeId = builder.placeId;         this.pageId = builder.pageId;         this.ref = builder.ref;         this.hashtag = builder.hashtag;     }      protected ShareContent(final Parcel in) {         this.contentUrl = in.readParcelable(Uri.class.getClassLoader());         this.peopleIds = readUnmodifiableStringList(in);         this.placeId = in.readString();         this.pageId = in.readString();         this.ref = in.readString();         this.hashtag = new ShareHashtag.Builder().readFrom(in).build();     }      /**      * URL for the content being shared.  This URL will be checked for app link meta tags for      * linking in platform specific ways.      *       * See documentation for App Links.      *      * @return {@link android.net.Uri} representation of the content link.      */     @Nullable     public Uri getContentUrl() {         return this.contentUrl;     }      /**      * List of Ids for taggable people to tag with this content.      *       * See documentation for      *       * Taggable Friends.      *      * @return {@link java.util.List} of Ids for people to tag.      */     @Nullable     public List getPeopleIds() {         return this.peopleIds;     }      /**      * The Id for a place to tag with this content.      *      * @return The Id for the place to tag.      */     @Nullable     public String getPlaceId() {         return this.placeId;     }      /**      * For shares into Messenger, this pageID will be used to map the app to page and attach      * attribution to the share.      *      * @return The ID of the Facebook page this share is associated with.      */     @Nullable     public String getPageId() {         return this.pageId;     }      /**      * A value to be added to the referrer URL when a person follows a link from this shared      * content on feed.      *      * @return The ref for the content.      */     @Nullable     public String getRef() {         return this.ref;     }      /**      * Gets the ShareHashtag, if one has been set, for this content.      *      * @return The hashtag      */     @Nullable     public ShareHashtag getShareHashtag() {         return this.hashtag;     }      public int describeContents() {         return 0;     }      public void writeToParcel(final Parcel out, final int flags) {         out.writeParcelable(this.contentUrl, 0);         out.writeStringList(this.peopleIds);         out.writeString(this.placeId);         out.writeString(this.pageId);         out.writeString(this.ref);         out.writeParcelable(this.hashtag, 0);     }      private List readUnmodifiableStringList(final Parcel in) {         final List list = new ArrayList();         in.readStringList(list);         return (list.size() == 0 ? null : Collections.unmodifiableList(list));     }      /**      * Abstract builder for {@link com.facebook.share.model.ShareContent}      */     public abstract static class Builder             implements ShareModelBuilder {         private Uri contentUrl;         private List peopleIds;         private String placeId;         private String pageId;         private String ref;         private ShareHashtag hashtag;          /**          * Set the URL for the content being shared.          *          * @param contentUrl {@link android.net.Uri} representation of the content link.          * @return The builder.          */         public E setContentUrl(@Nullable final Uri contentUrl) {             this.contentUrl = contentUrl;             return (E) this;         }          /**          * Set the list of Ids for taggable people to tag with this content.          *          * @param peopleIds {@link java.util.List} of Ids for people to tag.          * @return The builder.          */         public E setPeopleIds(@Nullable final List peopleIds) {             this.peopleIds = (peopleIds == null ? null : Collections.unmodifiableList(peopleIds));             return (E) this;         }          /**          * Set the Id for a place to tag with this content.          *          * @param placeId The Id for the place to tag.          * @return The builder.          */         public E setPlaceId(@Nullable final String placeId) {             this.placeId = placeId;             return (E) this;         }          /**          * Set the Id of the Facebook page this share is associated with.          *          * @param pageId The Id for the Page          * @return The builder          */         public E setPageId(@Nullable final String pageId) {             this.pageId = pageId;             return (E) this;         }          /**          * Set the value to be added to the referrer URL when a person follows a link from this          * shared content on feed.          *          * @param ref The ref for the content.          * @return The builder.          */         public E setRef(@Nullable final String ref) {             this.ref = ref;             return (E) this;         }          /**          * Set the ShareHashtag for this content          *          * @param shareHashtag The hashtag for this content          * @return The builder          */         public E setShareHashtag(@Nullable final ShareHashtag shareHashtag) {             this.hashtag = shareHashtag;             return (E) this;         }          @Override         public E readFrom(final P content) {             if (content == null) {                 return (E) this;             }             return (E) this                     .setContentUrl(content.getContentUrl())                     .setPeopleIds(content.getPeopleIds())                     .setPlaceId(content.getPlaceId())                     .setPageId(content.getPageId())                     .setRef(content.getRef());         }     } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method2 Feature envy3 Data class4 Indecent exposure5 Complexity6 Shotgun surgery7 Inappropriate Intimacy</td>
    <td align="left">f</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12425</td>
    <td align="left">https://github.com/facebook/facebook-android-sdk/blob/81ca34a2a0f7ee391f90c6051c5a22e5bc8663c2/facebook-common/src/main/java/com/facebook/share/model/ShareContent.java/#L35-L243</td>
    <td align="right">2</td>
    <td align="right">1922</td>
    <td align="right">12425</td>
  </tr>
  <tr valign="top">
    <td align="right">834</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Internal public abstract class LFOAbstractType {      protected int field_1_lsid;     protected int field_2_unused1;     protected int field_3_unused2;     protected byte field_4_clfolvl;     protected byte field_5_ibstFltAutoNum;     protected Grfhic field_6_grfhic;     protected byte field_7_unused3;      protected LFOAbstractType()     {         this.field_6_grfhic = new Grfhic();     }      protected void fillFields( byte[] data, int offset )     {         field_1_lsid                   = LittleEndian.getInt( data, 0x0 + offset );         field_2_unused1                = LittleEndian.getInt( data, 0x4 + offset );         field_3_unused2                = LittleEndian.getInt( data, 0x8 + offset );         field_4_clfolvl                = data[ 0xc + offset ];         field_5_ibstFltAutoNum         = data[ 0xd + offset ];         field_6_grfhic                 = new Grfhic( data, 0xe + offset );         field_7_unused3                = data[ 0xf + offset ];     }      public void serialize( byte[] data, int offset )     {         LittleEndian.putInt( data, 0x0 + offset, field_1_lsid );         LittleEndian.putInt( data, 0x4 + offset, field_2_unused1 );         LittleEndian.putInt( data, 0x8 + offset, field_3_unused2 );         data[ 0xc + offset ] = field_4_clfolvl;         data[ 0xd + offset ] = field_5_ibstFltAutoNum;         field_6_grfhic.serialize( data, 0xe + offset );         data[ 0xf + offset ] = field_7_unused3;     }      public byte[] serialize()     {         final byte[] result = new byte[ getSize() ];         serialize( result, 0 );         return result;     }      /**      * Size of record      */     public static int getSize()     {         return 0 + 4 + 4 + 4 + 1 + 1 + 1 + 1;     }      @Override     public boolean equals( Object obj )     {         if ( this == obj )             return true;         if ( obj == null )             return false;         if ( getClass() != obj.getClass() )             return false;         LFOAbstractType other = (LFOAbstractType) obj;         if ( field_1_lsid != other.field_1_lsid )             return false;         if ( field_2_unused1 != other.field_2_unused1 )             return false;         if ( field_3_unused2 != other.field_3_unused2 )             return false;         if ( field_4_clfolvl != other.field_4_clfolvl )             return false;         if ( field_5_ibstFltAutoNum != other.field_5_ibstFltAutoNum )             return false;         if ( field_6_grfhic == null )         {             if ( other.field_6_grfhic != null )                 return false;         }         else if ( !field_6_grfhic.equals( other.field_6_grfhic ) )             return false;         if ( field_7_unused3 != other.field_7_unused3 )             return false;         return true;     }      @Override     public int hashCode()     {         final int prime = 31;         int result = 1;         result = prime * result + field_1_lsid;         result = prime * result + field_2_unused1;         result = prime * result + field_3_unused2;         result = prime * result + field_4_clfolvl;         result = prime * result + field_5_ibstFltAutoNum;         result = prime * result                 + ((field_6_grfhic == null) ? 0 : field_6_grfhic.hashCode());         result = prime * result + field_7_unused3;         return result;     }      public String toString()     {         StringBuilder builder = new StringBuilder();          builder.append(&quot;[LFO]\n&quot;);         builder.append( &quot;    .lsid                 = &quot; );         builder.append(&quot; ( &quot;).append( field_1_lsid ).append( &quot; )\n&quot; );         builder.append( &quot;    .unused1              = &quot; );         builder.append(&quot; ( &quot;).append( field_2_unused1 ).append( &quot; )\n&quot; );         builder.append( &quot;    .unused2              = &quot; );         builder.append(&quot; ( &quot;).append( field_3_unused2 ).append( &quot; )\n&quot; );         builder.append( &quot;    .clfolvl              = &quot; );         builder.append(&quot; ( &quot;).append( field_4_clfolvl ).append( &quot; )\n&quot; );         builder.append( &quot;    .ibstFltAutoNum       = &quot; );         builder.append(&quot; ( &quot;).append( field_5_ibstFltAutoNum ).append( &quot; )\n&quot; );         builder.append( &quot;    .grfhic               = &quot; );         builder.append(&quot; ( &quot;).append( field_6_grfhic == null ? &quot;null&quot; : field_6_grfhic.toString().replaceAll( &quot;\n&quot;, &quot;\n    &quot; ) ).append( &quot; )\n&quot; );         builder.append( &quot;    .unused3              = &quot; );         builder.append(&quot; ( &quot;).append( field_7_unused3 ).append( &quot; )\n&quot; );          builder.append(&quot;[/LFO]&quot;);         return builder.toString();     }      /**      * A signed integer that specifies the list identifier of an LSTF. This LFO corresponds to the LSTF in PlfLst.rgLstf that has an lsid whose value is equal to this value..      */     @Internal     public int getLsid()     {         return field_1_lsid;     }      /**      * A signed integer that specifies the list identifier of an LSTF. This LFO corresponds to the LSTF in PlfLst.rgLstf that has an lsid whose value is equal to this value..      */     @Internal     public void setLsid( int field_1_lsid )     {         this.field_1_lsid = field_1_lsid;     }      /**      * This field MUST be ignored.      */     @Internal     public int getUnused1()     {         return field_2_unused1;     }      /**      * This field MUST be ignored.      */     @Internal     public void setUnused1( int field_2_unused1 )     {         this.field_2_unused1 = field_2_unused1;     }      /**      * This field MUST be ignored.      */     @Internal     public int getUnused2()     {         return field_3_unused2;     }      /**      * This field MUST be ignored.      */     @Internal     public void setUnused2( int field_3_unused2 )     {         this.field_3_unused2 = field_3_unused2;     }      /**      * An unsigned integer that specifies the field that this LFO represents..      */     @Internal     public byte getClfolvl()     {         return field_4_clfolvl;     }      /**      * An unsigned integer that specifies the field that this LFO represents..      */     @Internal     public void setClfolvl( byte field_4_clfolvl )     {         this.field_4_clfolvl = field_4_clfolvl;     }      /**      * Used for AUTONUM field emulation.      */     @Internal     public byte getIbstFltAutoNum()     {         return field_5_ibstFltAutoNum;     }      /**      * Used for AUTONUM field emulation.      */     @Internal     public void setIbstFltAutoNum( byte field_5_ibstFltAutoNum )     {         this.field_5_ibstFltAutoNum = field_5_ibstFltAutoNum;     }      /**      * HTML compatibility flags.      */     @Internal     public Grfhic getGrfhic()     {         return field_6_grfhic;     }      /**      * HTML compatibility flags.      */     @Internal     public void setGrfhic( Grfhic field_6_grfhic )     {         this.field_6_grfhic = field_6_grfhic;     }      /**      * This field MUST be ignored.      */     @Internal     public byte getUnused3()     {         return field_7_unused3;     }      /**      * This field MUST be ignored.      */     @Internal     public void setUnused3( byte field_7_unused3 )     {         this.field_7_unused3 = field_7_unused3;     }  }  // END OF CLASS</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7749</td>
    <td align="left">https://github.com/apache/poi/blob/351623a86924dab9c565e08e8cecfe151522c448/src/scratchpad/src/org/apache/poi/hwpf/model/types/LFOAbstractType.java/#L38-L290</td>
    <td align="right">1</td>
    <td align="right">834</td>
    <td align="right">7749</td>
  </tr>
  <tr valign="top">
    <td align="right">1297</td>
    <td align="left">&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class UpdateEntityResponse extends UpdateResponse {   private final V _entity;    public UpdateEntityResponse(final HttpStatus status, final V entity)   {     super(status);     _entity = entity;   }    public boolean hasEntity()   {     return _entity != null;   }    public V getEntity()   {     return _entity;   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10637</td>
    <td align="left">https://github.com/linkedin/rest.li/blob/ad74aa98da8a55ad9c339d0769a3e8fb495765af/restli-server/src/main/java/com/linkedin/restli/server/UpdateEntityResponse.java/#L31-L50</td>
    <td align="right">1</td>
    <td align="right">1297</td>
    <td align="right">10637</td>
  </tr>
  <tr valign="top">
    <td align="right">2258</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MachineStoppedEvent extends GwtEvent {    public static final Type TYPE = new Type&lt;&gt;();    private final MachineImpl machine;    public MachineStoppedEvent(MachineImpl machine) {     this.machine = machine;   }    /** Returns the stopped machine. */   public MachineImpl getMachine() {     return machine;   }    @Override   public Type getAssociatedType() {     return TYPE;   }    @Override   protected void dispatch(Handler handler) {     handler.onMachineStopped(this);   }    public interface Handler extends EventHandler {     void onMachineStopped(MachineStoppedEvent event);   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13695</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/ide/che-core-ide-api/src/main/java/org/eclipse/che/ide/api/workspace/event/MachineStoppedEvent.java/#L19-L47</td>
    <td align="right">1</td>
    <td align="right">2258</td>
    <td align="right">13695</td>
  </tr>
  <tr valign="top">
    <td align="right">5148</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;answer&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;     ]   } </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class BaseObject {  	/** Type identifier of the object */ 	public String type;  	/** 	 * Constructs an empty object 	 */ 	public BaseObject() { 		type = this.getClass().getCanonicalName(); 	}  	/** 	 * Constructs object with a given type 	 * @param type the type identifier 	 */ 	public BaseObject(String type) { 		this.type = type; 	}  	/** 	 * Get type of this object. 	 * @return type of the object 	 */ 	public String getType() { 		return type; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14405</td>
    <td align="left">https://github.com/spring-projects/spring-hadoop/blob/cda92b8ab6b5e8a8defe8ae5822e966e0a9d34eb/spring-yarn/spring-yarn-integration/src/main/java/org/springframework/yarn/integration/ip/mind/binding/BaseObject.java/#L24-L52</td>
    <td align="right">1</td>
    <td align="right">5148</td>
    <td align="right">14405</td>
  </tr>
  <tr valign="top">
    <td align="right">1480</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Device {  	private String id;  	private String deviceType;  	private String name;  	private Authentication authentication;  	public String getId() { 		return id; 	}  	public void setId(String id) { 		this.id = id; 	}  	public String getDeviceType() { 		return deviceType; 	}  	public void setDeviceType(String deviceType) { 		this.deviceType = deviceType; 	}  	public String getName() { 		return name; 	}  	public void setName(String name) { 		this.name = name; 	}  	public Authentication getAuthentication() { 		return authentication; 	}  	public void setAuthentication(Authentication authentication) { 		this.authentication = authentication; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11078</td>
    <td align="left">https://github.com/SAP/iot-starterkit/blob/f0d9ce06a1a98569a5a4eed76a2ec0aa87c1a1df/neo/apps/java/authentication/com.sap.iot.starterkit.cert/src/main/java/com/sap/iot/starterkit/cert/type/Device.java/#L3-L45</td>
    <td align="right">1</td>
    <td align="right">1480</td>
    <td align="right">11078</td>
  </tr>
  <tr valign="top">
    <td align="right">676</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;response&quot;: &quot;YES I found bad smells&quot;,         &quot;the bad smells are&quot;: [             &quot;Blob&quot;,             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SchemaAndValue {     private final Schema schema;     private final Object value;      public static final SchemaAndValue NULL = new SchemaAndValue(null, null);      public SchemaAndValue(Schema schema, Object value) {         this.value = value;         this.schema = schema;     }      public Schema schema() {         return schema;     }      public Object value() {         return value;     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (o == null || getClass() != o.getClass()) return false;         SchemaAndValue that = (SchemaAndValue) o;         return Objects.equals(schema, that.schema) &amp;&amp;                 Objects.equals(value, that.value);     }      @Override     public int hashCode() {         return Objects.hash(schema, value);     }      @Override     public String toString() {         return &quot;SchemaAndValue{&quot; +                 &quot;schema=&quot; + schema +                 &quot;, value=&quot; + value +                 '}';     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6576</td>
    <td align="left">https://github.com/apache/kafka/blob/c74acb24eb1da5d16cc2721a63931cd87f79ec66/connect/api/src/main/java/org/apache/kafka/connect/data/SchemaAndValue.java/#L21-L61</td>
    <td align="right">1</td>
    <td align="right">676</td>
    <td align="right">6576</td>
  </tr>
  <tr valign="top">
    <td align="right">2542</td>
    <td align="left">&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class RequireCapability     {         private final String namespace;          private final String filter;          private final String effective;          public RequireCapability ( final String namespace, final String filter, final String effective )         {             this.namespace = namespace;             this.filter = filter;             this.effective = effective;         }          public String getNamespace ()         {             return this.namespace;         }          public String getFilter ()         {             return this.filter;         }          public String getEffective ()         {             return this.effective;         }     }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14785</td>
    <td align="left">https://github.com/eclipse/packagedrone/blob/3869c1643cdc6f7cb8b26097a7b6994683b13d7e/bundles/org.eclipse.packagedrone.repo.utils.osgi/src/org/eclipse/packagedrone/repo/utils/osgi/bundle/BundleInformation.java/#L377-L406</td>
    <td align="right">1</td>
    <td align="right">2542</td>
    <td align="right">14785</td>
  </tr>
  <tr valign="top">
    <td align="right">1494</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SysInfo implements Serializable {      static final long serialVersionUID = -3096346807579L;      public int numCores;     public long maxMemory;      public SysInfo(int nc, long mm) {         numCores = nc;         maxMemory = mm;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11123</td>
    <td align="left">https://github.com/google/error-prone-javac/blob/a53d069bbdb2c60232ed3811c19b65e41c3e60e0/src/jdk.compiler/share/classes/com/sun/tools/sjavac/server/SysInfo.java/#L45-L56</td>
    <td align="right">1</td>
    <td align="right">1494</td>
    <td align="right">11123</td>
  </tr>
  <tr valign="top">
    <td align="right">2572</td>
    <td align="left">&nbsp;YES I found bad smells, the bad smells are: 1.Magic numbers, 2.Data class, 3. Long method, 4.Feature envy:</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
    class ColumnFamilyRegionInfo {         private RegionInfo regionInfo;         private Set familySet;          public ColumnFamilyRegionInfo(RegionInfo regionInfo, Set familySet) {             this.regionInfo = regionInfo;             this.familySet = familySet;         }          public RegionInfo getRegionInfo() {             return regionInfo;         }          public Set getFamilySet() {             return familySet;         }          @Override         public boolean equals(Object obj) {             if (obj == this) { return true; }             if (!(obj instanceof ColumnFamilyRegionInfo)) { return false; }              ColumnFamilyRegionInfo c = (ColumnFamilyRegionInfo)obj;             return c.getRegionInfo().equals(this.regionInfo) &amp;&amp; ByteUtil.match(this.familySet, c.getFamilySet());         }          @Override         public int hashCode() {             return this.getRegionInfo().hashCode();         }     }</td>
    <td align="left">data class</td>
    <td align="left">Magic numbers, 2Data class, 3 Long method, 4Feature envy:</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">.Magic numbers,  3. Long method,  4.Feature envy:</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14907</td>
    <td align="left">https://github.com/apache/phoenix/blob/69e5bb0b304a53967cef40b2a4cfc66e69ecaa51/phoenix-core/src/main/java/org/apache/phoenix/schema/stats/StatisticsCollectionRunTracker.java/#L129-L159</td>
    <td align="right">2</td>
    <td align="right">2572</td>
    <td align="right">14907</td>
  </tr>
  <tr valign="top">
    <td align="right">1633</td>
    <td align="left">{ &quot;output&quot;: &quot;YES I found bad smells\nthe bad smells are: 1. Data class&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class RestConfiguration {      public static final String CORS_ACCESS_CONTROL_ALLOW_ORIGIN = &quot;*&quot;;     public static final String CORS_ACCESS_CONTROL_ALLOW_METHODS = &quot;GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, CONNECT, PATCH&quot;;     public static final String CORS_ACCESS_CONTROL_MAX_AGE = &quot;3600&quot;;     public static final String CORS_ACCESS_CONTROL_ALLOW_HEADERS = &quot;Origin, Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers&quot;;      public enum RestBindingMode {         auto, off, json, xml, json_xml     }      public enum RestHostNameResolver {         allLocalIp, localIp, localHostName     }      private String component;     private String apiComponent;     private String producerComponent;     private String producerApiDoc;     private String scheme;     private String host;     private boolean useXForwardHeaders = true;     private String apiHost;     private int port;     private String contextPath;     private String apiContextPath;     private String apiContextRouteId;     private String apiContextIdPattern;     private boolean apiContextListing;     private boolean apiVendorExtension;     private RestHostNameResolver hostNameResolver = RestHostNameResolver.allLocalIp;     private RestBindingMode bindingMode = RestBindingMode.off;     private boolean skipBindingOnErrorCode = true;     private boolean clientRequestValidation;     private boolean enableCORS;     private String jsonDataFormat;     private String xmlDataFormat;     private Map componentProperties;     private Map endpointProperties;     private Map consumerProperties;     private Map dataFormatProperties;     private Map apiProperties;     private Map corsHeaders;      /**      * Gets the name of the Camel component to use as the REST consumer      *      * @return the component name, or null to let Camel search the {@link Registry} to find suitable implementation      */     public String getComponent() {         return component;     }      /**      * Sets the name of the Camel component to use as the REST consumer      *      * @param componentName the name of the component (such as restlet, spark-rest, etc.)      */     public void setComponent(String componentName) {         this.component = componentName;     }      /**      * Gets the name of the Camel component to use as the REST API (such as swagger)      *      * @return the component name, or null to let Camel use the default name swagger      */     public String getApiComponent() {         return apiComponent;     }      /**      * Sets the name of the Camel component to use as the REST API (such as swagger)      *      * @param apiComponent the name of the component (such as swagger)      */     public void setApiComponent(String apiComponent) {         this.apiComponent = apiComponent;     }      /**      * Gets the name of the Camel component to use as the REST producer      *      * @return the component name, or null to let Camel search the {@link Registry} to find suitable implementation      */     public String getProducerComponent() {         return producerComponent;     }      /**      * Sets the name of the Camel component to use as the REST producer      *      * @param componentName the name of the component (such as restlet, jetty, etc.)      */     public void setProducerComponent(String componentName) {         this.producerComponent = componentName;     }      /**      * Gets the location of the api document (swagger api) the REST producer will use      * to validate the REST uri and query parameters are valid accordingly to the api document.      */     public String getProducerApiDoc() {         return producerApiDoc;     }      /**      * Sets the location of the api document (swagger api) the REST producer will use      * to validate the REST uri and query parameters are valid accordingly to the api document.      * This requires adding camel-swagger-java to the classpath, and any miss configuration      * will let Camel fail on startup and report the error(s).      *       * The location of the api document is loaded from classpath by default, but you can use      * file: or http: to refer to resources to load from file or http url.      */     public void setProducerApiDoc(String producerApiDoc) {         this.producerApiDoc = producerApiDoc;     }      /**      * Gets the hostname to use by the REST consumer      *      * @return the hostname, or null to use default hostname      */     public String getHost() {         return host;     }      /**      * Sets the hostname to use by the REST consumer      *      * @param host the hostname      */     public void setHost(String host) {         this.host = host;     }      /**      * WWhether to use X-Forward headers to set host etc. for Swagger.      *       * This option is default true.      */     public boolean isUseXForwardHeaders() {         return useXForwardHeaders;     }      /**      * WWhether to use X-Forward headers to set host etc. for Swagger.      *       * This option is default true.      *       * @param useXForwardHeaders whether to use X-Forward headers      */     public void setUseXForwardHeaders(boolean useXForwardHeaders) {         this.useXForwardHeaders = useXForwardHeaders;     }      public String getApiHost() {         return apiHost;     }      /**      * To use an specific hostname for the API documentation (eg swagger)      *       * This can be used to override the generated host with this configured hostname      */     public void setApiHost(String apiHost) {         this.apiHost = apiHost;     }      /**      * Gets the scheme to use by the REST consumer      *      * @return the scheme, or null to use default scheme      */     public String getScheme() {         return scheme;     }      /**      * Sets the scheme to use by the REST consumer      *      * @param scheme the scheme      */     public void setScheme(String scheme) {         this.scheme = scheme;     }      /**      * Gets the port to use by the REST consumer      *      * @return the port, or 0 or -1 to use default port      */     public int getPort() {         return port;     }      /**      * Sets the port to use by the REST consumer      *      * @param port the port number      */     public void setPort(int port) {         this.port = port;     }      /**      * Gets the configured context-path      *      * @return the context path, or null if none configured.      */     public String getContextPath() {         return contextPath;     }      /**      * Sets a leading context-path the REST services will be using.      *       * This can be used when using components such as camel-servlet where the deployed web application      * is deployed using a context-path. Or for components such as camel-jetty or camel-netty4-http      * that includes a HTTP server.      *      * @param contextPath the context path      */     public void setContextPath(String contextPath) {         this.contextPath = contextPath;     }      public String getApiContextPath() {         return apiContextPath;     }      /**      * Sets a leading API context-path the REST API services will be using.      *       * This can be used when using components such as camel-servlet where the deployed web application      * is deployed using a context-path.      *      * @param contextPath the API context path      */     public void setApiContextPath(String contextPath) {         this.apiContextPath = contextPath;     }      public String getApiContextRouteId() {         return apiContextRouteId;     }      /**      * Sets the route id to use for the route that services the REST API.      *       * The route will by default use an auto assigned route id.      *      * @param apiContextRouteId  the route id      */     public void setApiContextRouteId(String apiContextRouteId) {         this.apiContextRouteId = apiContextRouteId;     }      public String getApiContextIdPattern() {         return apiContextIdPattern;     }      /**      * Optional CamelContext id pattern to only allow Rest APIs from rest services within CamelContext's which name matches the pattern.      *       * The pattern #name# refers to the CamelContext name, to match on the current CamelContext only.      * For any other value, the pattern uses the rules from {@link org.apache.camel.support.EndpointHelper#matchPattern(String, String)}      *      * @param apiContextIdPattern  the pattern      */     public void setApiContextIdPattern(String apiContextIdPattern) {         this.apiContextIdPattern = apiContextIdPattern;     }      public boolean isApiContextListing() {         return apiContextListing;     }      /**      * Sets whether listing of all available CamelContext's with REST services in the JVM is enabled. If enabled it allows to discover      * these contexts, if false then only the current CamelContext is in use.      */     public void setApiContextListing(boolean apiContextListing) {         this.apiContextListing = apiContextListing;     }      public boolean isApiVendorExtension() {         return apiVendorExtension;     }      /**      * Whether vendor extension is enabled in the Rest APIs. If enabled then Camel will include additional information      * as vendor extension (eg keys starting with x-) such as route ids, class names etc.      * Not all 3rd party API gateways and tools supports vendor-extensions when importing your API docs.      */     public void setApiVendorExtension(boolean apiVendorExtension) {         this.apiVendorExtension = apiVendorExtension;     }      /**      * Gets the resolver to use for resolving hostname      *      * @return the resolver      */     public RestHostNameResolver getHostNameResolver() {         return hostNameResolver;     }      /**      * Sets the resolver to use for resolving hostname      *      * @param hostNameResolver the resolver      */     public void setHostNameResolver(RestHostNameResolver hostNameResolver) {         this.hostNameResolver = hostNameResolver;     }      /**      * Sets the resolver to use for resolving hostname      *      * @param hostNameResolver the resolver      */     public void setHostNameResolver(String hostNameResolver) {         this.hostNameResolver = RestHostNameResolver.valueOf(hostNameResolver);     }      /**      * Gets the binding mode used by the REST consumer      *      * @return the binding mode      */     public RestBindingMode getBindingMode() {         return bindingMode;     }      /**      * Sets the binding mode to be used by the REST consumer      *      * @param bindingMode the binding mode      */     public void setBindingMode(RestBindingMode bindingMode) {         this.bindingMode = bindingMode;     }      /**      * Sets the binding mode to be used by the REST consumer      *      * @param bindingMode the binding mode      */     public void setBindingMode(String bindingMode) {         this.bindingMode = RestBindingMode.valueOf(bindingMode);     }      /**      * Whether to skip binding output if there is a custom HTTP error code, and instead use the response body as-is.      *       * This option is default true.      *      * @return whether to skip binding on error code      */     public boolean isSkipBindingOnErrorCode() {         return skipBindingOnErrorCode;     }      /**      * Whether to skip binding output if there is a custom HTTP error code, and instead use the response body as-is.      *       * This option is default true.      *      * @param skipBindingOnErrorCode whether to skip binding on error code      */     public void setSkipBindingOnErrorCode(boolean skipBindingOnErrorCode) {         this.skipBindingOnErrorCode = skipBindingOnErrorCode;     }      public boolean isClientRequestValidation() {         return clientRequestValidation;     }      /**      * Whether to enable validation of the client request to check whether the Content-Type and Accept headers from      * the client is supported by the Rest-DSL configuration of its consumes/produces settings.      *       * This can be turned on, to enable this check. In case of validation error, then HTTP Status codes 415 or 406 is returned.      *       * The default value is false.      */     public void setClientRequestValidation(boolean clientRequestValidation) {         this.clientRequestValidation = clientRequestValidation;     }      /**      * To specify whether to enable CORS which means Camel will automatic include CORS in the HTTP headers in the response.      *       * This option is default false      *      * @return whether CORS is enabled or not      */     public boolean isEnableCORS() {         return enableCORS;     }      /**      * To specify whether to enable CORS which means Camel will automatic include CORS in the HTTP headers in the response.      *       * This option is default false      *      * @param enableCORS true to enable CORS      */     public void setEnableCORS(boolean enableCORS) {         this.enableCORS = enableCORS;     }      /**      * Gets the name of the json data format.      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @return the name, or null to use default      */     public String getJsonDataFormat() {         return jsonDataFormat;     }      /**      * Sets a custom json data format to be used      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @param name name of the data format      */     public void setJsonDataFormat(String name) {         this.jsonDataFormat = name;     }      /**      * Gets the name of the xml data format.      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @return the name, or null to use default      */     public String getXmlDataFormat() {         return xmlDataFormat;     }      /**      * Sets a custom xml data format to be used.      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @param name name of the data format      */     public void setXmlDataFormat(String name) {         this.xmlDataFormat = name;     }      /**      * Gets additional options on component level      *      * @return additional options      */     public Map getComponentProperties() {         return componentProperties;     }      /**      * Sets additional options on component level      *      * @param componentProperties the options      */     public void setComponentProperties(Map componentProperties) {         this.componentProperties = componentProperties;     }      /**      * Gets additional options on endpoint level      *      * @return additional options      */     public Map getEndpointProperties() {         return endpointProperties;     }      /**      * Sets additional options on endpoint level      *      * @param endpointProperties the options      */     public void setEndpointProperties(Map endpointProperties) {         this.endpointProperties = endpointProperties;     }      /**      * Gets additional options on consumer level      *      * @return additional options      */     public Map getConsumerProperties() {         return consumerProperties;     }      /**      * Sets additional options on consumer level      *      * @param consumerProperties the options      */     public void setConsumerProperties(Map consumerProperties) {         this.consumerProperties = consumerProperties;     }      /**      * Gets additional options on data format level      *      * @return additional options      */     public Map getDataFormatProperties() {         return dataFormatProperties;     }      /**      * Sets additional options on data format level      *      * @param dataFormatProperties the options      */     public void setDataFormatProperties(Map dataFormatProperties) {         this.dataFormatProperties = dataFormatProperties;     }      public Map getApiProperties() {         return apiProperties;     }      /**      * Sets additional options on api level      *      * @param apiProperties the options      */     public void setApiProperties(Map apiProperties) {         this.apiProperties = apiProperties;     }      /**      * Gets the CORS headers to use if CORS has been enabled.      *      * @return the CORS headers      */     public Map getCorsHeaders() {         return corsHeaders;     }      /**      * Sets the CORS headers to use if CORS has been enabled.      *      * @param corsHeaders the CORS headers      */     public void setCorsHeaders(Map corsHeaders) {         this.corsHeaders = corsHeaders;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11514</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/core/camel-api/src/main/java/org/apache/camel/spi/RestConfiguration.java/#L25-L585</td>
    <td align="right">1</td>
    <td align="right">1633</td>
    <td align="right">11514</td>
  </tr>
  <tr valign="top">
    <td align="right">2378</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;response&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_smells&quot;: [             &quot;Blob&quot;,             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    static class Cause {         final Tuple tuple ;         final Mapping     mapping ;          public Cause(Tuple tuple, Mapping mapping) {             super() ;             this.tuple = tuple ;             this.mapping = mapping ;         }     }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14333</td>
    <td align="left">https://github.com/apache/jena/blob/1cca775bbf0bb0fd3ee8ac55e31f0f30cdde3b77/jena-arq/src/main/java/org/apache/jena/sparql/util/IsoMatcher.java/#L113-L122</td>
    <td align="right">1</td>
    <td align="right">2378</td>
    <td align="right">14333</td>
  </tr>
  <tr valign="top">
    <td align="right">1463</td>
    <td align="left">{&quot;response&quot;:&quot;YES I found bad smells&quot;,&quot;detected_bad_smells&quot;:[&quot;Data Class&quot;,&quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TupleImpl extends IndifferentAccessMap implements Seqable, Indexed, IMeta, Tuple {     private List values;     private int taskId;     private String streamId;     private GeneralTopologyContext context;     private MessageId id;     private IPersistentMap _meta = null;     Long _processSampleStartTime = null;     Long _executeSampleStartTime = null;     long _outAckVal = 0;      public TupleImpl() {     }      public TupleImpl(GeneralTopologyContext context, List values, int taskId, String streamId, MessageId id) {         this.values = values;         this.taskId = taskId;         this.streamId = streamId;         this.id = id;         this.context = context;          /*         String componentId = context.getComponentId(taskId);         Fields schema = context.getComponentOutputFields(componentId, streamId);         if (values.size() != schema.size()) {             throw new IllegalArgumentException(&quot;Tuple created with wrong number of fields. &quot; + &quot;Expected &quot; + schema.size() + &quot; fields but got &quot; + values.size()                     + &quot; fields&quot;);         }*/     }      public TupleImpl(GeneralTopologyContext context, List values, int taskId, String streamId) {         this(context, values, taskId, streamId, MessageId.makeUnanchored());     }      public void setProcessSampleStartTime(long ms) {         _processSampleStartTime = ms;     }      public Long getProcessSampleStartTime() {         return _processSampleStartTime;     }      public void setExecuteSampleStartTime(long ms) {         _executeSampleStartTime = ms;     }      public Long getExecuteSampleStartTime() {         return _executeSampleStartTime;     }      public void updateAckVal(long val) {         _outAckVal = _outAckVal ^ val;     }      public long getAckVal() {         return _outAckVal;     }      public int size() {         return values.size();     }      public int fieldIndex(String field) {         return getFields().fieldIndex(field);     }      public boolean contains(String field) {         return getFields().contains(field);     }      public Object getValue(int i) {         return values.get(i);     }      public String getString(int i) {         return (String) values.get(i);     }      public Integer getInteger(int i) {         return (Integer) values.get(i);     }      public Long getLong(int i) {         return (Long) values.get(i);     }      public Boolean getBoolean(int i) {         return (Boolean) values.get(i);     }      public Short getShort(int i) {         return (Short) values.get(i);     }      public Byte getByte(int i) {         return (Byte) values.get(i);     }      public Double getDouble(int i) {         return (Double) values.get(i);     }      public Float getFloat(int i) {         return (Float) values.get(i);     }      public byte[] getBinary(int i) {         return (byte[]) values.get(i);     }      public Object getValueByField(String field) {         return values.get(fieldIndex(field));     }      public String getStringByField(String field) {         return (String) values.get(fieldIndex(field));     }      public Integer getIntegerByField(String field) {         return (Integer) values.get(fieldIndex(field));     }      public Long getLongByField(String field) {         return (Long) values.get(fieldIndex(field));     }      public Boolean getBooleanByField(String field) {         return (Boolean) values.get(fieldIndex(field));     }      public Short getShortByField(String field) {         return (Short) values.get(fieldIndex(field));     }      public Byte getByteByField(String field) {         return (Byte) values.get(fieldIndex(field));     }      public Double getDoubleByField(String field) {         return (Double) values.get(fieldIndex(field));     }      public Float getFloatByField(String field) {         return (Float) values.get(fieldIndex(field));     }      public byte[] getBinaryByField(String field) {         return (byte[]) values.get(fieldIndex(field));     }      public List getValues() {         return values;     }      public Fields getFields() {         return context.getComponentOutputFields(getSourceComponent(), getSourceStreamId());     }      public List select(Fields selector) {         return getFields().select(selector, values);     }      public GlobalStreamId getSourceGlobalStreamid() {         return new GlobalStreamId(getSourceComponent(), streamId);     }      public String getSourceComponent() {         return context.getComponentId(taskId);     }      public int getSourceTask() {         return taskId;     }      public String getSourceStreamId() {         return streamId;     }      public MessageId getMessageId() {         return id;     }      @Override     public String toString() {         return &quot;source: &quot; + getSourceComponent() + &quot;:&quot; + taskId + &quot;, stream: &quot; + streamId + &quot;, id: &quot; + id.toString() + &quot;, &quot; + values.toString();     }      @Override     public boolean equals(Object other) {         return this == other;     }      @Override     public int hashCode() {         return System.identityHashCode(this);     }      private Keyword makeKeyword(String name) {         return Keyword.intern(Symbol.create(name));     }      /* ILookup */     @Override     public Object valAt(Object o) {         try {             if (o instanceof Keyword) {                 return getValueByField(((Keyword) o).getName());             } else if (o instanceof String) {                 return getValueByField((String) o);             }         } catch (IllegalArgumentException ignored) {         }         return null;     }      /* Seqable */     public ISeq seq() {         if (values.size() &gt; 0) {             return new Seq(getFields().toList(), values, 0);         }         return null;     }      static class Seq extends ASeq implements Counted {         final List fields;         final List values;         final int i;          Seq(List fields, List values, int i) {             this.fields = fields;             this.values = values;             assert i &gt;= 0;             this.i = i;         }          public Seq(IPersistentMap meta, List fields, List values, int i) {             super(meta);             this.fields = fields;             this.values = values;             assert i &gt;= 0;             this.i = i;         }          public Object first() {             return new MapEntry(fields.get(i), values.get(i));         }          public ISeq next() {             if (i + 1 &lt; fields.size()) {                 return new Seq(fields, values, i + 1);             }             return null;         }          public int count() {             assert fields.size() - i &gt;= 0 : &quot;index out of bounds&quot;;             // i being the position in the fields of this seq, the remainder of the seq is the size             return fields.size() - i;         }          public Obj withMeta(IPersistentMap meta) {             return new Seq(meta, fields, values, i);         }     }      /* Indexed */     public Object nth(int i) {         if (i &lt; values.size()) {             return values.get(i);         } else {             return null;         }     }      public Object nth(int i, Object notfound) {         Object ret = nth(i);         if (ret == null)             ret = notfound;         return ret;     }      /* Counted */     public int count() {         return values.size();     }      /* IMeta */     public IPersistentMap meta() {         if (_meta == null) {             _meta = new PersistentArrayMap(new Object[]{makeKeyword(&quot;stream&quot;), getSourceStreamId(),                     makeKeyword(&quot;component&quot;), getSourceComponent(), makeKeyword(&quot;task&quot;), getSourceTask()});         }         return _meta;     }      private PersistentArrayMap toMap() {         Object array[] = new Object[values.size() * 2];         List fields = getFields().toList();         for (int i = 0; i &lt; values.size(); i++) {             array[i * 2] = fields.get(i);             array[(i * 2) + 1] = values.get(i);         }         return new PersistentArrayMap(array);     }      public IPersistentMap getMap() {         if (_map == null) {             setMap(toMap());         }         return _map;     }      public void setTopologyContext(GeneralTopologyContext context) {         this.context = context;     }      public GeneralTopologyContext getTopologyContext() {         return context;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11027</td>
    <td align="left">https://github.com/alibaba/jstorm/blob/5d6cde22dbca7df3d6e6830bf94f98a6639ab559/jstorm-core/src/main/java/backtype/storm/tuple/TupleImpl.java/#L37-L356</td>
    <td align="right">1</td>
    <td align="right">1463</td>
    <td align="right">11027</td>
  </tr>
  <tr valign="top">
    <td align="right">1424</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
class MacOSXSocketOptions extends PlatformSocketOptions {      public MacOSXSocketOptions() {     }      @Override     boolean keepAliveOptionsSupported() {         return keepAliveOptionsSupported0();     }      @Override     void setTcpkeepAliveProbes(int fd, final int value) throws SocketException {         setTcpkeepAliveProbes0(fd, value);     }      @Override     void setTcpKeepAliveTime(int fd, final int value) throws SocketException {         setTcpKeepAliveTime0(fd, value);     }      @Override     void setTcpKeepAliveIntvl(int fd, final int value) throws SocketException {         setTcpKeepAliveIntvl0(fd, value);     }      @Override     int getTcpkeepAliveProbes(int fd) throws SocketException {         return getTcpkeepAliveProbes0(fd);     }      @Override     int getTcpKeepAliveTime(int fd) throws SocketException {         return getTcpKeepAliveTime0(fd);     }      @Override     int getTcpKeepAliveIntvl(int fd) throws SocketException {         return getTcpKeepAliveIntvl0(fd);     }      private static native void setTcpkeepAliveProbes0(int fd, int value) throws SocketException;     private static native void setTcpKeepAliveTime0(int fd, int value) throws SocketException;     private static native void setTcpKeepAliveIntvl0(int fd, int value) throws SocketException;     private static native int getTcpkeepAliveProbes0(int fd) throws SocketException;     private static native int getTcpKeepAliveTime0(int fd) throws SocketException;     private static native int getTcpKeepAliveIntvl0(int fd) throws SocketException;     private static native boolean keepAliveOptionsSupported0();     static {         AccessController.doPrivileged((PrivilegedAction) () -&gt; {             System.loadLibrary(&quot;extnet&quot;);             return null;         });     } }</td>
    <td align="left">data class</td>
    <td align="left">Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10935</td>
    <td align="left">https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/jdk.net/macosx/classes/jdk/net/MacOSXSocketOptions.java/#L32-L85</td>
    <td align="right">1</td>
    <td align="right">1424</td>
    <td align="right">10935</td>
  </tr>
  <tr valign="top">
    <td align="right">2506</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class ValidEmail {         @Email         String newEmail;          public String getNewEmail() {             return newEmail;         }          public void setNewEmail(String email) {             this.newEmail = email;         }     }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14669</td>
    <td align="left">https://github.com/cloudfoundry/uaa/blob/f3b66dd2a250c1309a86cade560ac9a9cfeafec7/server/src/main/java/org/cloudfoundry/identity/uaa/account/ChangeEmailController.java/#L147-L158</td>
    <td align="right">1</td>
    <td align="right">2506</td>
    <td align="right">14669</td>
  </tr>
  <tr valign="top">
    <td align="right">1052</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public class Application {         private String name;         private Map inputs;          public Application() {         }          public String getName() {             return name;         }          public void setName(String name) {             this.name = name;         }          public Map getInputs() {             return inputs;         }          public void setInputs(Map inputs) {             this.inputs = inputs;         }     }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9479</td>
    <td align="left">https://github.com/apache/airavata/blob/391843a00eefa7b6213e845f2f044b4e042894d5/modules/test-suite/multi-tenanted-airavata/src/main/java/org/apache/airavata/testsuite/multitenantedairavata/TestFrameworkProps.java/#L199-L221</td>
    <td align="right">1</td>
    <td align="right">1052</td>
    <td align="right">9479</td>
  </tr>
  <tr valign="top">
    <td align="right">2084</td>
    <td align="left">&nbsp;&nbsp;YES, I found bad smells the bad smells are: 1. Long data class, 2. Primitive obsession</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
  private static class FieldMetaData {     public final FieldInfo fieldInfo;     public final long numTerms;     public final long sumTotalTermFreq;     public final long sumDocFreq;     public final int docCount;     public final int longsSize;     public final FST dict;      public FieldMetaData(FieldInfo fieldInfo, long numTerms, long sumTotalTermFreq, long sumDocFreq, int docCount, int longsSize, FST fst) {       this.fieldInfo = fieldInfo;       this.numTerms = numTerms;       this.sumTotalTermFreq = sumTotalTermFreq;       this.sumDocFreq = sumDocFreq;       this.docCount = docCount;       this.longsSize = longsSize;       this.dict = fst;     }   }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long data class, 2 Primitive obsession</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;2. Primitive obsession</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13082</td>
    <td align="left">https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/lucene/codecs/src/java/org/apache/lucene/codecs/memory/FSTTermsWriter.java/#L229-L247</td>
    <td align="right">2</td>
    <td align="right">2084</td>
    <td align="right">13082</td>
  </tr>
  <tr valign="top">
    <td align="right">3714</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Blob&quot;,       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public class ExistingEnumElements extends AbstractEnumRuleElementFinder { 		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.xtext.enumrules.EnumRulesTestLanguage.ExistingEnum&quot;); 		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1); 		private final EnumLiteralDeclaration cSameNameEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0); 		private final Keyword cSameNameSameNameKeyword_0_0 = (Keyword)cSameNameEnumLiteralDeclaration_0.eContents().get(0); 		private final EnumLiteralDeclaration cOverriddenLiteralEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1); 		private final Keyword cOverriddenLiteralOverriddenKeyword_1_0 = (Keyword)cOverriddenLiteralEnumLiteralDeclaration_1.eContents().get(0); 		private final EnumLiteralDeclaration cDifferentNameEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2); 		private final Keyword cDifferentNameDifferentLiteralKeyword_2_0 = (Keyword)cDifferentNameEnumLiteralDeclaration_2.eContents().get(0); 		 		//enum ExistingEnum: 		//	SameName | OverriddenLiteral=&quot;overridden&quot; | DifferentName=&quot;DifferentLiteral&quot;; 		public EnumRule getRule() { return rule; } 		 		//SameName | OverriddenLiteral=&quot;overridden&quot; | DifferentName=&quot;DifferentLiteral&quot; 		public Alternatives getAlternatives() { return cAlternatives; } 		 		//SameName 		public EnumLiteralDeclaration getSameNameEnumLiteralDeclaration_0() { return cSameNameEnumLiteralDeclaration_0; } 		 		//&quot;SameName&quot; 		public Keyword getSameNameSameNameKeyword_0_0() { return cSameNameSameNameKeyword_0_0; } 		 		//OverriddenLiteral=&quot;overridden&quot; 		public EnumLiteralDeclaration getOverriddenLiteralEnumLiteralDeclaration_1() { return cOverriddenLiteralEnumLiteralDeclaration_1; } 		 		//&quot;overridden&quot; 		public Keyword getOverriddenLiteralOverriddenKeyword_1_0() { return cOverriddenLiteralOverriddenKeyword_1_0; } 		 		//DifferentName=&quot;DifferentLiteral&quot; 		public EnumLiteralDeclaration getDifferentNameEnumLiteralDeclaration_2() { return cDifferentNameEnumLiteralDeclaration_2; } 		 		//&quot;DifferentLiteral&quot; 		public Keyword getDifferentNameDifferentLiteralKeyword_2_0() { return cDifferentNameDifferentLiteralKeyword_2_0; } 	}</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8980</td>
    <td align="left">https://github.com/eclipse/xtext-extras/blob/5634c291880cd46fe2f8e9a47e48ef88b85e8bda/org.eclipse.xtext.extras.tests/src-gen/org/eclipse/xtext/enumrules/services/EnumRulesTestLanguageGrammarAccess.java/#L88-L122</td>
    <td align="right">1</td>
    <td align="right">3714</td>
    <td align="right">8980</td>
  </tr>
  <tr valign="top">
    <td align="right">2265</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface ReplicatedLevelDBStoreViewMBean {      @MBeanInfo(&quot;The address of the ZooKeeper server.&quot;)     String getZkAddress();     @MBeanInfo(&quot;The path in ZooKeeper to hold master elections.&quot;)     String getZkPath();     @MBeanInfo(&quot;The ZooKeeper session timeout.&quot;)     String getZkSessionTimeout();     @MBeanInfo(&quot;The address and port the master will bind for the replication protocol.&quot;)     String getBind();     @MBeanInfo(&quot;The number of replication nodes that will be part of the replication cluster.&quot;)     int getReplicas();      @MBeanInfo(&quot;The role of this node in the replication cluster.&quot;)     String getNodeRole();      @MBeanInfo(&quot;The replication status.&quot;)     String getStatus();      @MBeanInfo(&quot;The status of the connected slaves.&quot;)     CompositeData[] getSlaves();      @MBeanInfo(&quot;The current position of the replication log.&quot;)     Long getPosition();      @MBeanInfo(&quot;When the last entry was added to the replication log.&quot;)     Long getPositionDate();      @MBeanInfo(&quot;The directory holding the data.&quot;)     String getDirectory();      @MBeanInfo(&quot;The sync strategy to use.&quot;)     String getSync();      @MBeanInfo(&quot;The node id of this replication node.&quot;)     String getNodeId(); }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13729</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-leveldb-store/src/main/java/org/apache/activemq/leveldb/replicated/ReplicatedLevelDBStoreViewMBean.java/#L30-L66</td>
    <td align="right">1</td>
    <td align="right">2265</td>
    <td align="right">13729</td>
  </tr>
  <tr valign="top">
    <td align="right">360</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;response&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class User {   private String name = &quot;nameA&quot;;    private int age = 100;    private int index;    private String[] names;    public String getName() {     return name;   }    public void setName(String name) {     this.name = name;   }    public String[] getNames() {     return names;   }    public void setNames(String[] names) {     this.names = names;   }    public int getAge() {     return age;   }    public void setAge(int age) {     this.age = age;   }    public int getIndex() {     return index;   }    public void setIndex(int index) {     this.index = index;   }    @Override   public String toString() {     return &quot;User [name=&quot; + name + &quot;, age=&quot; + age + &quot;, index=&quot; + index + &quot;]&quot;;   }    public String jsonString() {     try {       return JsonUtils.writeValueAsString(this);     } catch (JsonProcessingException e) {       throw new IllegalStateException(e);     }   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3696</td>
    <td align="left">https://github.com/apache/servicecomb-java-chassis/blob/72cd0e137c4a0c3b899adfa6e19e2fd590743014/integration-tests/it-common/src/main/java/org/apache/servicecomb/it/schema/User.java/#L23-L76</td>
    <td align="right">1</td>
    <td align="right">360</td>
    <td align="right">3696</td>
  </tr>
  <tr valign="top">
    <td align="right">790</td>
    <td align="left">&nbsp;{    &quot;response&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Customer1149 {  	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id; 	private String firstName; 	private String lastName;  	protected Customer1149() {}  	public Customer1149(String firstName, String lastName) { 		this.firstName = firstName; 		this.lastName = lastName; 	}  	@Override 	public String toString() { 		return String.format(&quot;Customer1149[id=%d, firstName='%s', lastName='%s']&quot;, id, firstName, lastName); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7527</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer1149.java/#L8-L27</td>
    <td align="right">1</td>
    <td align="right">790</td>
    <td align="right">7527</td>
  </tr>
  <tr valign="top">
    <td align="right">356</td>
    <td align="left">{   &quot;response&quot;: &quot;YES, I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;Blob&quot;,     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Value public class Release {  	private final String id; 	private final ProjectKey projectKey; 	private final String name; 	private final String description; 	private final LocalDate date; }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3676</td>
    <td align="left">https://github.com/spring-projects/spring-data-dev-tools/blob/a25ff3ae28026f132871f7172c6ba5c3b64e1671/release-tools/src/main/java/org/springframework/data/release/model/Release.java/#L25-L33</td>
    <td align="right">1</td>
    <td align="right">356</td>
    <td align="right">3676</td>
  </tr>
  <tr valign="top">
    <td align="right">1620</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{       &quot;message&quot;: &quot;YES I found bad smells&quot;,       &quot;bad smells are&quot;: [         &quot;Data Class&quot;       ]     }  </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class FieldSchemaWrapper {     @JsonIgnore     private FieldSchema fieldSchema;     @JsonProperty     public String name;     @JsonProperty     public String type;     @JsonProperty     public String comment;      @JsonCreator     public FieldSchemaWrapper(@JsonProperty(&quot;name&quot;) String name, @JsonProperty(&quot;type&quot;) String type, @JsonProperty(&quot;comment&quot;) String comment) {       this.name = name;       this.type = type;       this.comment = comment;       this.fieldSchema = new FieldSchema(name, type, comment);     }      public FieldSchemaWrapper(FieldSchema fieldSchema) {       this.fieldSchema = fieldSchema;       this.name = fieldSchema.getName();       this.type = fieldSchema.getType();       this.comment = fieldSchema.getComment();     }      @JsonIgnore     public FieldSchema getFieldSchema() {       return fieldSchema;     }   }</td>
    <td align="left">data class</td>
    <td align="left">Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11479</td>
    <td align="left">https://github.com/apache/drill/blob/5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3/contrib/storage-hive/core/src/main/java/org/apache/drill/exec/store/hive/HiveTableWrapper.java/#L367-L396</td>
    <td align="right">1</td>
    <td align="right">1620</td>
    <td align="right">11479</td>
  </tr>
  <tr valign="top">
    <td align="right">957</td>
    <td align="left">&nbsp;YES I found bad smells the bad smells are:  1. Long method 2. Message chain 3. Large class 4. Feature envy 5. Data class 6. Primitive obsession 7. Duplicate code 8. Commented-out code 9. Inappropriate naming 10. Incomplete error handling 11. Inconsistent formatting 12. Use of raw types 13. Inefficient use of constructors 14. Overuse of getters and setters 15. Use of mutable fields </td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class TupleImpl extends IndifferentAccessMap implements Seqable, Indexed, IMeta, Tuple {     private List values;     private int taskId;     private String streamId;     private GeneralTopologyContext context;     private MessageId id;     private IPersistentMap _meta = null;     Long _processSampleStartTime = null;     Long _executeSampleStartTime = null;     long _outAckVal = 0;      public TupleImpl() {     }      public TupleImpl(GeneralTopologyContext context, List values, int taskId, String streamId, MessageId id) {         this.values = values;         this.taskId = taskId;         this.streamId = streamId;         this.id = id;         this.context = context;          /*         String componentId = context.getComponentId(taskId);         Fields schema = context.getComponentOutputFields(componentId, streamId);         if (values.size() != schema.size()) {             throw new IllegalArgumentException(&quot;Tuple created with wrong number of fields. &quot; + &quot;Expected &quot; + schema.size() + &quot; fields but got &quot; + values.size()                     + &quot; fields&quot;);         }*/     }      public TupleImpl(GeneralTopologyContext context, List values, int taskId, String streamId) {         this(context, values, taskId, streamId, MessageId.makeUnanchored());     }      public void setProcessSampleStartTime(long ms) {         _processSampleStartTime = ms;     }      public Long getProcessSampleStartTime() {         return _processSampleStartTime;     }      public void setExecuteSampleStartTime(long ms) {         _executeSampleStartTime = ms;     }      public Long getExecuteSampleStartTime() {         return _executeSampleStartTime;     }      public void updateAckVal(long val) {         _outAckVal = _outAckVal ^ val;     }      public long getAckVal() {         return _outAckVal;     }      public int size() {         return values.size();     }      public int fieldIndex(String field) {         return getFields().fieldIndex(field);     }      public boolean contains(String field) {         return getFields().contains(field);     }      public Object getValue(int i) {         return values.get(i);     }      public String getString(int i) {         return (String) values.get(i);     }      public Integer getInteger(int i) {         return (Integer) values.get(i);     }      public Long getLong(int i) {         return (Long) values.get(i);     }      public Boolean getBoolean(int i) {         return (Boolean) values.get(i);     }      public Short getShort(int i) {         return (Short) values.get(i);     }      public Byte getByte(int i) {         return (Byte) values.get(i);     }      public Double getDouble(int i) {         return (Double) values.get(i);     }      public Float getFloat(int i) {         return (Float) values.get(i);     }      public byte[] getBinary(int i) {         return (byte[]) values.get(i);     }      public Object getValueByField(String field) {         return values.get(fieldIndex(field));     }      public String getStringByField(String field) {         return (String) values.get(fieldIndex(field));     }      public Integer getIntegerByField(String field) {         return (Integer) values.get(fieldIndex(field));     }      public Long getLongByField(String field) {         return (Long) values.get(fieldIndex(field));     }      public Boolean getBooleanByField(String field) {         return (Boolean) values.get(fieldIndex(field));     }      public Short getShortByField(String field) {         return (Short) values.get(fieldIndex(field));     }      public Byte getByteByField(String field) {         return (Byte) values.get(fieldIndex(field));     }      public Double getDoubleByField(String field) {         return (Double) values.get(fieldIndex(field));     }      public Float getFloatByField(String field) {         return (Float) values.get(fieldIndex(field));     }      public byte[] getBinaryByField(String field) {         return (byte[]) values.get(fieldIndex(field));     }      public List getValues() {         return values;     }      public Fields getFields() {         return context.getComponentOutputFields(getSourceComponent(), getSourceStreamId());     }      public List select(Fields selector) {         return getFields().select(selector, values);     }      public GlobalStreamId getSourceGlobalStreamid() {         return new GlobalStreamId(getSourceComponent(), streamId);     }      public String getSourceComponent() {         return context.getComponentId(taskId);     }      public int getSourceTask() {         return taskId;     }      public String getSourceStreamId() {         return streamId;     }      public MessageId getMessageId() {         return id;     }      @Override     public String toString() {         return &quot;source: &quot; + getSourceComponent() + &quot;:&quot; + taskId + &quot;, stream: &quot; + streamId + &quot;, id: &quot; + id.toString() + &quot;, &quot; + values.toString();     }      @Override     public boolean equals(Object other) {         return this == other;     }      @Override     public int hashCode() {         return System.identityHashCode(this);     }      private Keyword makeKeyword(String name) {         return Keyword.intern(Symbol.create(name));     }      /* ILookup */     @Override     public Object valAt(Object o) {         try {             if (o instanceof Keyword) {                 return getValueByField(((Keyword) o).getName());             } else if (o instanceof String) {                 return getValueByField((String) o);             }         } catch (IllegalArgumentException ignored) {         }         return null;     }      /* Seqable */     public ISeq seq() {         if (values.size() &gt; 0) {             return new Seq(getFields().toList(), values, 0);         }         return null;     }      static class Seq extends ASeq implements Counted {         final List fields;         final List values;         final int i;          Seq(List fields, List values, int i) {             this.fields = fields;             this.values = values;             assert i &gt;= 0;             this.i = i;         }          public Seq(IPersistentMap meta, List fields, List values, int i) {             super(meta);             this.fields = fields;             this.values = values;             assert i &gt;= 0;             this.i = i;         }          public Object first() {             return new MapEntry(fields.get(i), values.get(i));         }          public ISeq next() {             if (i + 1 &lt; fields.size()) {                 return new Seq(fields, values, i + 1);             }             return null;         }          public int count() {             assert fields.size() - i &gt;= 0 : &quot;index out of bounds&quot;;             // i being the position in the fields of this seq, the remainder of the seq is the size             return fields.size() - i;         }          public Obj withMeta(IPersistentMap meta) {             return new Seq(meta, fields, values, i);         }     }      /* Indexed */     public Object nth(int i) {         if (i &lt; values.size()) {             return values.get(i);         } else {             return null;         }     }      public Object nth(int i, Object notfound) {         Object ret = nth(i);         if (ret == null)             ret = notfound;         return ret;     }      /* Counted */     public int count() {         return values.size();     }      /* IMeta */     public IPersistentMap meta() {         if (_meta == null) {             _meta = new PersistentArrayMap(new Object[]{makeKeyword(&quot;stream&quot;), getSourceStreamId(),                     makeKeyword(&quot;component&quot;), getSourceComponent(), makeKeyword(&quot;task&quot;), getSourceTask()});         }         return _meta;     }      private PersistentArrayMap toMap() {         Object array[] = new Object[values.size() * 2];         List fields = getFields().toList();         for (int i = 0; i &lt; values.size(); i++) {             array[i * 2] = fields.get(i);             array[(i * 2) + 1] = values.get(i);         }         return new PersistentArrayMap(array);     }      public IPersistentMap getMap() {         if (_map == null) {             setMap(toMap());         }         return _map;     }      public void setTopologyContext(GeneralTopologyContext context) {         this.context = context;     }      public GeneralTopologyContext getTopologyContext() {         return context;     } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method2 Message chain3 Large class4 Feature envy5 Data class6 Primitive obsession7 Duplicate code8 Commented-out code9 Inappropriate naming</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8546</td>
    <td align="left">https://github.com/alibaba/jstorm/blob/5d6cde22dbca7df3d6e6830bf94f98a6639ab559/jstorm-core/src/main/java/backtype/storm/tuple/TupleImpl.java/#L37-L356</td>
    <td align="right">2</td>
    <td align="right">957</td>
    <td align="right">8546</td>
  </tr>
  <tr valign="top">
    <td align="right">1562</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class FilterParams {      private final Collection filterByStatus;     private final Boolean overdueState;     private final String filterBySearchText;     private final Boolean selectTargetWithNoTag;     private final String[] filterByTagNames;     private final Long filterByDistributionId;      /**      * Constructor.      *      * @param filterByInstalledOrAssignedDistributionSetId      *            if set, a filter is added for the given      *            {@link DistributionSet#getId()}      * @param filterByStatus      *            if set, a filter is added for target states included by the      *            collection      * @param overdueState      *            if set, a filter is added for overdued devices      * @param filterBySearchText      *            if set, a filter is added for the given search text      * @param selectTargetWithNoTag      *            if set, tag-filtering is enabled      * @param filterByTagNames      *            if tag-filtering is enabled, a filter is added for the given      *            tag-names      */     public FilterParams(final Collection filterByStatus, final Boolean overdueState,             final String filterBySearchText, final Long filterByInstalledOrAssignedDistributionSetId,             final Boolean selectTargetWithNoTag, final String... filterByTagNames) {         this.filterByStatus = filterByStatus;         this.overdueState = overdueState;         this.filterBySearchText = filterBySearchText;         this.filterByDistributionId = filterByInstalledOrAssignedDistributionSetId;         this.selectTargetWithNoTag = selectTargetWithNoTag;         this.filterByTagNames = filterByTagNames;     }      /**      * Gets {@link DistributionSet#getId()} to filter the result.       * If set to null this filter is disabled.      *      * @return {@link DistributionSet#getId()} to filter the result      */     public Long getFilterByDistributionId() {         return filterByDistributionId;     }      /**      * Gets a collection of target states to filter for.       * If set to null this filter is disabled.      *      * @return collection of target states to filter for      */     public Collection getFilterByStatus() {         return filterByStatus;     }      /**      * Gets the flag for overdue filter; if set to true, the      * overdue filter is activated. Overdued targets a targets that did not      * respond during the configured intervals: poll_itvl + overdue_itvl.       * If set to null this filter is disabled.      *      * @return flag for overdue filter activation      */     public Boolean getOverdueState() {         return overdueState;     }      /**      * Gets the search text to filter for. This is used to find targets having      * the text anywhere in name or description       * If set to null this filter is disabled.      *      * @return the search text to filter for      */     public String getFilterBySearchText() {         return filterBySearchText;     }      /**      * Gets the flag indicating if tagging filter is used.       * If set to null this filter is disabled.      *      * @return the flag indicating if tagging filter is used      */     public Boolean getSelectTargetWithNoTag() {         return selectTargetWithNoTag;     }      /**      * Gets the tags that are used to filter for. The activation of this filter      * is done by {@link #setSelectTargetWithNoTag(Boolean)}.      *      * @return the tags that are used to filter for      */     public String[] getFilterByTagNames() {         return filterByTagNames;     } }</td>
    <td align="left">data class</td>
    <td align="left">Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11312</td>
    <td align="left">https://github.com/eclipse/hawkbit/blob/51be28147f6f575b6c1ab4a5ef84ffd9174f1209/hawkbit-repository/hawkbit-repository-api/src/main/java/org/eclipse/hawkbit/repository/FilterParams.java/#L22-L123</td>
    <td align="right">1</td>
    <td align="right">1562</td>
    <td align="right">11312</td>
  </tr>
  <tr valign="top">
    <td align="right">1001</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;badSmells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private static final class Reference {          private final Tree tree;         private final PropertyState property;          private Reference(Tree tree, String propertyName) {             this.tree = tree;             this.property = tree.getProperty(propertyName);         }          private boolean isMultiple() {             return property.isArray();         }          private void setProperty(String newValue) {             PropertyState prop = PropertyStates.createProperty(property.getName(), newValue, property.getType().tag());             tree.setProperty(prop);         }          private void setProperty(Iterable newValues) {             PropertyState prop = PropertyStates.createProperty(property.getName(), newValues, property.getType());             tree.setProperty(prop);         }     }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">9189</td>
    <td align="left">https://github.com/apache/jackrabbit-oak/blob/fa85f54a065e01c0a1cb8c03af74194fdf521ddd/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java/#L548-L571</td>
    <td align="right">1</td>
    <td align="right">1001</td>
    <td align="right">9189</td>
  </tr>
  <tr valign="top">
    <td align="right">1479</td>
    <td align="left">&nbsp;{   &quot;response&quot;: &quot;YES I found bad smells&quot;,   &quot;the bad smells are&quot;: [     &quot;Blob&quot;,     &quot;Data Class&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlTransient public abstract class PendingActionNotificationResponse     extends ImmutableObject implements ResponseData {    /** The inner name type that contains a name and the result boolean. */   @Embed   static class NameOrId extends ImmutableObject {     @XmlValue     String value;      @XmlAttribute(name = &quot;paResult&quot;)     boolean actionResult;   }    @XmlTransient   NameOrId nameOrId;    @XmlElement(name = &quot;paTRID&quot;)   Trid trid;    @XmlElement(name = &quot;paDate&quot;)   DateTime processedDate;    public String getNameAsString() {     return nameOrId.value;   }    @VisibleForTesting   public Trid getTrid() {     return trid;   }    @VisibleForTesting   public boolean getActionResult() {     return nameOrId.actionResult;   }    protected static  T init(       T response, String nameOrId, boolean actionResult, Trid trid, DateTime processedDate) {     response.nameOrId = new NameOrId();     response.nameOrId.value = nameOrId;     response.nameOrId.actionResult = actionResult;     response.trid = trid;     response.processedDate = processedDate;     return response;   }    /** An adapter to output the XML in response to resolving a pending command on a domain. */   @Embed   @XmlRootElement(name = &quot;panData&quot;, namespace = &quot;urn:ietf:params:xml:ns:domain-1.0&quot;)   @XmlType(       propOrder = {&quot;name&quot;, &quot;trid&quot;, &quot;processedDate&quot;},       namespace = &quot;urn:ietf:params:xml:ns:domain-1.0&quot;)   public static class DomainPendingActionNotificationResponse       extends PendingActionNotificationResponse {      @XmlElement     NameOrId getName() {       return nameOrId;     }      public static DomainPendingActionNotificationResponse create(         String fullyQualifiedDomainName, boolean actionResult, Trid trid, DateTime processedDate) {       return init(           new DomainPendingActionNotificationResponse(),           fullyQualifiedDomainName,           actionResult,           trid,           processedDate);     }   }    /** An adapter to output the XML in response to resolving a pending command on a contact. */   @Embed   @XmlRootElement(name = &quot;panData&quot;, namespace = &quot;urn:ietf:params:xml:ns:contact-1.0&quot;)   @XmlType(       propOrder = {&quot;id&quot;, &quot;trid&quot;, &quot;processedDate&quot;},       namespace = &quot;urn:ietf:params:xml:ns:contact-1.0&quot;)   public static class ContactPendingActionNotificationResponse       extends PendingActionNotificationResponse {      @XmlElement     NameOrId getId() {       return nameOrId;     }      public static ContactPendingActionNotificationResponse create(         String contactId, boolean actionResult, Trid trid, DateTime processedDate) {       return init(           new ContactPendingActionNotificationResponse(),           contactId,           actionResult,           trid,           processedDate);     }   }    /** An adapter to output the XML in response to resolving a pending command on a host. */   @Embed   @XmlRootElement(name = &quot;panData&quot;, namespace = &quot;urn:ietf:params:xml:ns:domain-1.0&quot;)   @XmlType(     propOrder = {&quot;name&quot;, &quot;trid&quot;, &quot;processedDate&quot;},     namespace = &quot;urn:ietf:params:xml:ns:domain-1.0&quot;   )   public static class HostPendingActionNotificationResponse       extends PendingActionNotificationResponse {      @XmlElement     NameOrId getName() {       return nameOrId;     }      public static HostPendingActionNotificationResponse create(         String fullyQualifiedHostName, boolean actionResult, Trid trid, DateTime processedDate) {       return init(           new HostPendingActionNotificationResponse(),           fullyQualifiedHostName,           actionResult,           trid,           processedDate);     }   } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11069</td>
    <td align="left">https://github.com/google/nomulus/blob/2481704d00f10f6b5675dd26f9effaad434ddbea/java/google/registry/model/poll/PendingActionNotificationResponse.java/#L31-L153</td>
    <td align="right">1</td>
    <td align="right">1479</td>
    <td align="right">11069</td>
  </tr>
  <tr valign="top">
    <td align="right">597</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells the bad smells are: Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class GetOperationCompletedEvent extends OperationCompletedEvent {     private final GetRequest[] requests;     private final GetStatus status;      public GetOperationCompletedEvent(         final EventSource source,         final Workspace workspace,         final GetRequest[] requests,         final GetStatus status) {         super(source, workspace, ProcessType.GET);          Check.notNull(requests, &quot;requests&quot;); //$NON-NLS-1$          this.requests = requests;         this.status = status;     }      /**      * @return the status object produced by the get operation that caused this      *         event. null means the get operation did not fully complete.      */     public GetStatus getStatus() {         return status;     }      /**      * @return the request objects that initiated this get operation.      */     public GetRequest[] getRequests() {         return requests;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5956</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core/src/com/microsoft/tfs/core/clients/versioncontrol/events/GetOperationCompletedEvent.java/#L17-L48</td>
    <td align="right">1</td>
    <td align="right">597</td>
    <td align="right">5956</td>
  </tr>
  <tr valign="top">
    <td align="right">2300</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES, I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
class ResourceMethodConfigImpl implements ResourceMethodConfig {   private final ConfigValue _timeoutMs;    ResourceMethodConfigImpl(ConfigValue timeoutMs)   {     _timeoutMs = timeoutMs;   }    public ConfigValue getTimeoutMs()   {     return _timeoutMs;   }    @Override   public String toString()   {     return &quot;ResourceMethodConfigImpl{&quot; +             &quot;_timeoutMs=&quot; + _timeoutMs +             '}';   }    @Override   public boolean equals(Object o)   {     if (this == o) return true;     if (o == null || getClass() != o.getClass()) return false;     ResourceMethodConfigImpl that = (ResourceMethodConfigImpl) o;     return Objects.equals(_timeoutMs, that._timeoutMs);   }    @Override   public int hashCode()   {     return Objects.hash(_timeoutMs);   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14030</td>
    <td align="left">https://github.com/linkedin/rest.li/blob/ad74aa98da8a55ad9c339d0769a3e8fb495765af/restli-server/src/main/java/com/linkedin/restli/server/config/ResourceMethodConfigImpl.java/#L13-L49</td>
    <td align="right">1</td>
    <td align="right">2300</td>
    <td align="right">14030</td>
  </tr>
  <tr valign="top">
    <td align="right">2364</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells. The bad smells are: 1. Data Class&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
        static class Event {              final Type type;             final TruffleFile file;             final IOException ioe;             final BasicFileAttributes attrs;              Event(Type type, TruffleFile file, BasicFileAttributes attrs) {                 this.type = type;                 this.file = file;                 this.attrs = attrs;                 this.ioe = null;             }              Event(Type type, TruffleFile file, IOException ioe) {                 this.type = type;                 this.file = file;                 this.attrs = null;                 this.ioe = ioe;             }              enum Type {                 PRE_VISIT_DIRECTORY,                 VISIT,                 POST_VISIT_DIRECTORY             }         }</td>
    <td align="left">data class</td>
    <td align="left">1. data class </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14255</td>
    <td align="left">https://github.com/oracle/graal/blob/4deb681aaaa79c248115037fc8e399c9876619fd/truffle/src/com.oracle.truffle.api/src/com/oracle/truffle/api/TruffleFile.java/#L1837-L1863</td>
    <td align="right">1</td>
    <td align="right">2364</td>
    <td align="right">14255</td>
  </tr>
  <tr valign="top">
    <td align="right">493</td>
    <td align="left">&nbsp;	{ 		&quot;message&quot;: &quot;YES I found bad smells&quot;, 		&quot;bad smells are&quot;: [ 			&quot;Data Class&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Customer230 {  	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id; 	private String firstName; 	private String lastName;  	protected Customer230() {}  	public Customer230(String firstName, String lastName) { 		this.firstName = firstName; 		this.lastName = lastName; 	}  	@Override 	public String toString() { 		return String.format(&quot;Customer230[id=%d, firstName='%s', lastName='%s']&quot;, id, firstName, lastName); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4960</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer230.java/#L8-L27</td>
    <td align="right">1</td>
    <td align="right">493</td>
    <td align="right">4960</td>
  </tr>
  <tr valign="top">
    <td align="right">2371</td>
    <td align="left">{&quot;response&quot;: &quot;YES, I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  abstract static class RequestParamsBuilder {     T body;      public RequestParamsBuilder(T body) {       this.body = body;     }      abstract RequestParams buildRequestParams();      void setBody(T body) {       this.body = body;     }   }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14308</td>
    <td align="left">https://github.com/oracle/weblogic-kubernetes-operator/blob/1fb059d7e32b9b3514617d54e4dda41ab68e71ea/operator/src/main/java/oracle/kubernetes/operator/helpers/CallBuilder.java/#L179-L191</td>
    <td align="right">1</td>
    <td align="right">2371</td>
    <td align="right">14308</td>
  </tr>
  <tr valign="top">
    <td align="right">2256</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public class AnElementElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.xtext.ui.tests.editor.contentassist.TwoContextsTestLanguage.AnElement&quot;); 		private final Group cGroup = (Group)rule.eContents().get(1); 		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0); 		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0); 		private final Group cGroup_1 = (Group)cGroup.eContents().get(1); 		private final Keyword cRefersToKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0); 		private final Assignment cReferredAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1); 		private final CrossReference cReferredAnElementCrossReference_1_1_0 = (CrossReference)cReferredAssignment_1_1.eContents().get(0); 		private final RuleCall cReferredAnElementIDTerminalRuleCall_1_1_0_1 = (RuleCall)cReferredAnElementCrossReference_1_1_0.eContents().get(1); 		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2); 		 		//AnElement: 		//	name=ID ('refersTo' referred=[AnElement])? ';'; 		@Override public ParserRule getRule() { return rule; } 		 		//name=ID ('refersTo' referred=[AnElement])? ';' 		public Group getGroup() { return cGroup; } 		 		//name=ID 		public Assignment getNameAssignment_0() { return cNameAssignment_0; } 		 		//ID 		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; } 		 		//('refersTo' referred=[AnElement])? 		public Group getGroup_1() { return cGroup_1; } 		 		//'refersTo' 		public Keyword getRefersToKeyword_1_0() { return cRefersToKeyword_1_0; } 		 		//referred=[AnElement] 		public Assignment getReferredAssignment_1_1() { return cReferredAssignment_1_1; } 		 		//[AnElement] 		public CrossReference getReferredAnElementCrossReference_1_1_0() { return cReferredAnElementCrossReference_1_1_0; } 		 		//ID 		public RuleCall getReferredAnElementIDTerminalRuleCall_1_1_0_1() { return cReferredAnElementIDTerminalRuleCall_1_1_0_1; } 		 		//';' 		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; } 	}</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13691</td>
    <td align="left">https://github.com/eclipse/xtext-eclipse/blob/0c7546b6aaf3644a77fc68eef9f3da368cbbeabd/org.eclipse.xtext.ui.tests/src-gen/org/eclipse/xtext/ui/tests/editor/contentassist/services/TwoContextsTestLanguageGrammarAccess.java/#L40-L82</td>
    <td align="right">1</td>
    <td align="right">2256</td>
    <td align="right">13691</td>
  </tr>
  <tr valign="top">
    <td align="right">2192</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Blob&quot;,       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Status {     public String getAction() {         return action;     }      public Result getResult() {         return result;     }      public String getDetails() {         return details;     }      private String action;     private Result result;     private String details;      public Status(String action, Result result, String details) {         this.action = action;         this.result = result;         this.details = details;     }     public static enum Result {         SUCCESSFUL,         FAILED,     }      @Override     public String toString() {         return String.format(&quot;%s\t%s\t%s&quot;, action, result, details);     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13474</td>
    <td align="left">https://github.com/Microsoft/azure-tools-for-java/blob/d121e8ac9cc3ab400e5b49c8b372280ae332f3fb/Utils/azuretools-core/src/com/microsoft/azuretools/authmanage/srvpri/step/Status.java/#L28-L59</td>
    <td align="right">1</td>
    <td align="right">2192</td>
    <td align="right">13474</td>
  </tr>
  <tr valign="top">
    <td align="right">78</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
class Segment {     private byte segmentType;      Segment(byte segmentType) {         this.segmentType = segmentType;     }      /**      * Returns the segmentType value.      *       * @return byte segmentType value.      */     public byte getSegmentType() {         return segmentType;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1160</td>
    <td align="left">https://github.com/Microsoft/mssql-jdbc/blob/84484edf7944de56749fd2648d0af2ffa2459b7a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java/#L1932-L1947</td>
    <td align="right">1</td>
    <td align="right">78</td>
    <td align="right">1160</td>
  </tr>
  <tr valign="top">
    <td align="right">1386</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  protected static class OnheapDecodedCell implements ExtendedCell {     private static final long FIXED_OVERHEAD = ClassSize.align(ClassSize.OBJECT         + (3 * ClassSize.REFERENCE) + (2 * Bytes.SIZEOF_LONG) + (7 * Bytes.SIZEOF_INT)         + (Bytes.SIZEOF_SHORT) + (2 * Bytes.SIZEOF_BYTE) + (3 * ClassSize.ARRAY));     private byte[] keyOnlyBuffer;     private short rowLength;     private int familyOffset;     private byte familyLength;     private int qualifierOffset;     private int qualifierLength;     private long timestamp;     private byte typeByte;     private byte[] valueBuffer;     private int valueOffset;     private int valueLength;     private byte[] tagsBuffer;     private int tagsOffset;     private int tagsLength;     private long seqId;      protected OnheapDecodedCell(byte[] keyBuffer, short rowLength, int familyOffset,         byte familyLength, int qualOffset, int qualLength, long timeStamp, byte typeByte,         byte[] valueBuffer, int valueOffset, int valueLen, long seqId, byte[] tagsBuffer,         int tagsOffset, int tagsLength) {       this.keyOnlyBuffer = keyBuffer;       this.rowLength = rowLength;       this.familyOffset = familyOffset;       this.familyLength = familyLength;       this.qualifierOffset = qualOffset;       this.qualifierLength = qualLength;       this.timestamp = timeStamp;       this.typeByte = typeByte;       this.valueBuffer = valueBuffer;       this.valueOffset = valueOffset;       this.valueLength = valueLen;       this.tagsBuffer = tagsBuffer;       this.tagsOffset = tagsOffset;       this.tagsLength = tagsLength;       setSequenceId(seqId);     }      @Override     public byte[] getRowArray() {       return keyOnlyBuffer;     }      @Override     public byte[] getFamilyArray() {       return keyOnlyBuffer;     }      @Override     public byte[] getQualifierArray() {       return keyOnlyBuffer;     }      @Override     public int getRowOffset() {       return Bytes.SIZEOF_SHORT;     }      @Override     public short getRowLength() {       return rowLength;     }      @Override     public int getFamilyOffset() {       return familyOffset;     }      @Override     public byte getFamilyLength() {       return familyLength;     }      @Override     public int getQualifierOffset() {       return qualifierOffset;     }      @Override     public int getQualifierLength() {       return qualifierLength;     }      @Override     public long getTimestamp() {       return timestamp;     }      @Override     public byte getTypeByte() {       return typeByte;     }      @Override     public long getSequenceId() {       return seqId;     }      @Override     public byte[] getValueArray() {       return this.valueBuffer;     }      @Override     public int getValueOffset() {       return valueOffset;     }      @Override     public int getValueLength() {       return valueLength;     }      @Override     public byte[] getTagsArray() {       return this.tagsBuffer;     }      @Override     public int getTagsOffset() {       return this.tagsOffset;     }      @Override     public int getTagsLength() {       return tagsLength;     }      @Override     public String toString() {       return KeyValue.keyToString(this.keyOnlyBuffer, 0, KeyValueUtil.keyLength(this)) + &quot;/vlen=&quot;           + getValueLength() + &quot;/seqid=&quot; + seqId;     }      @Override     public void setSequenceId(long seqId) {       this.seqId = seqId;     }      @Override     public long heapSize() {       return FIXED_OVERHEAD + rowLength + familyLength + qualifierLength + valueLength + tagsLength;     }      @Override     public int write(OutputStream out, boolean withTags) throws IOException {       int lenToWrite = getSerializedSize(withTags);       ByteBufferUtils.putInt(out, keyOnlyBuffer.length);       ByteBufferUtils.putInt(out, valueLength);       // Write key       out.write(keyOnlyBuffer);       // Write value       out.write(this.valueBuffer, this.valueOffset, this.valueLength);       if (withTags &amp;&amp; this.tagsLength &gt; 0) {         // 2 bytes tags length followed by tags bytes         // tags length is serialized with 2 bytes only(short way) even if the type is int.         // As this is non -ve numbers, we save the sign bit. See HBASE-11437         out.write((byte) (0xff &amp; (this.tagsLength &gt;&gt; 8)));         out.write((byte) (0xff &amp; this.tagsLength));         out.write(this.tagsBuffer, this.tagsOffset, this.tagsLength);       }       return lenToWrite;     }      @Override     public int getSerializedSize(boolean withTags) {       return KeyValueUtil.length(rowLength, familyLength, qualifierLength, valueLength, tagsLength,           withTags);     }      @Override     public void write(ByteBuffer buf, int offset) {       // This is not used in actual flow. Throwing UnsupportedOperationException       throw new UnsupportedOperationException();     }      @Override     public void setTimestamp(long ts) throws IOException {       // This is not used in actual flow. Throwing UnsupportedOperationException       throw new UnsupportedOperationException();     }      @Override     public void setTimestamp(byte[] ts) throws IOException {       // This is not used in actual flow. Throwing UnsupportedOperationException       throw new UnsupportedOperationException();     }      @Override     public ExtendedCell deepClone() {       // This is not used in actual flow. Throwing UnsupportedOperationException       throw new UnsupportedOperationException();     }   }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10834</td>
    <td align="left">https://github.com/apache/hbase/blob/44f8abd5c65c59e9d09f6ad14b3c825f145d8e4f/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/BufferedDataBlockEncoder.java/#L282-L478</td>
    <td align="right">1</td>
    <td align="right">1386</td>
    <td align="right">10834</td>
  </tr>
  <tr valign="top">
    <td align="right">2592</td>
    <td align="left">### YES I found bad smells 1. Long method 2. Feature envy 3. Primitive obsession 4. Data class 5. Inappropriate use of comments 6. Inconsistent formatting and naming conventions 7. Duplicated code 8. Inefficient data serialization handling 9. Inconsistent use of flags and boolean variables 10. Lack of proper exception handling 11. Unused and unnecessary methods 12. Inappropriate use of transient keyword.</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
  public static class PutAllEntryData {      final Object key;      private Object value;      private final Object oldValue;      private final Operation op;      private EventID eventID;      transient EntryEventImpl event;      private Integer bucketId = Integer.valueOf(-1);      protected transient boolean callbacksInvoked = false;      public FilterRoutingInfo filterRouting;      // One flags byte for all booleans     protected byte flags = 0x00;      // TODO: Yogesh, this should be intialized and sent on wire only when     // parallel wan is enabled     private Long tailKey = 0L;      public VersionTag versionTag;      transient boolean inhibitDistribution;      /**      * Constructor to use when preparing to send putall data out      */     public PutAllEntryData(EntryEventImpl event) {        this.key = event.getKey();       this.value = event.getRawNewValueAsHeapObject();       Object oldValue = event.getRawOldValueAsHeapObject();        if (oldValue == Token.NOT_AVAILABLE || Token.isRemoved(oldValue)) {         this.oldValue = null;       } else {         this.oldValue = oldValue;       }        this.op = event.getOperation();       this.eventID = event.getEventId();       this.tailKey = event.getTailKey();       this.versionTag = event.getVersionTag();        setNotifyOnly(!event.getInvokePRCallbacks());       setCallbacksInvoked(event.callbacksInvoked());       setPossibleDuplicate(event.isPossibleDuplicate());       setInhibitDistribution(event.getInhibitDistribution());     }      /**      * Constructor to use when receiving a putall from someone else      */     public PutAllEntryData(DataInput in, EventID baseEventID, int idx, Version version,         ByteArrayDataInput bytesIn) throws IOException, ClassNotFoundException {       this.key = DataSerializer.readObject(in);       byte flgs = in.readByte();       if ((flgs &amp; IS_OBJECT) != 0) {         this.value = DataSerializer.readObject(in);       } else {         byte[] bb = DataSerializer.readByteArray(in);         if ((flgs &amp; IS_CACHED_DESER) != 0) {           this.value = new FutureCachedDeserializable(bb);         } else {           this.value = bb;         }       }       this.oldValue = null;       this.op = Operation.fromOrdinal(in.readByte());       this.flags = in.readByte();       if ((this.flags &amp; FILTER_ROUTING) != 0) {         this.filterRouting = (FilterRoutingInfo) DataSerializer.readObject(in);       }       if ((this.flags &amp; VERSION_TAG) != 0) {         boolean persistentTag = (this.flags &amp; PERSISTENT_TAG) != 0;         this.versionTag = VersionTag.create(persistentTag, in);       }       if (isUsedFakeEventId()) {         this.eventID = new EventID();         InternalDataSerializer.invokeFromData(this.eventID, in);       } else {         this.eventID = new EventID(baseEventID, idx);       }       if ((this.flags &amp; HAS_TAILKEY) != 0) {         this.tailKey = DataSerializer.readLong(in);       }     }      @Override     public String toString() {       StringBuilder sb = new StringBuilder(50);       sb.append(&quot;(&quot;).append(getKey()).append(&quot;,&quot;).append(this.value).append(&quot;,&quot;)           .append(getOldValue());       if (this.bucketId &gt; 0) {         sb.append(&quot;, b&quot;).append(this.bucketId);       }       if (versionTag != null) {         sb.append(versionTag);         // sb.append(&quot;,v&quot;).append(versionTag.getEntryVersion()).append(&quot;,rv&quot;+versionTag.getRegionVersion());       }       if (filterRouting != null) {         sb.append(&quot;, &quot;).append(filterRouting);       }       sb.append(&quot;)&quot;);       return sb.toString();     }      void setSender(InternalDistributedMember sender) {       if (this.versionTag != null) {         this.versionTag.replaceNullIDs(sender);       }     }      /**      * Used to serialize this instances data to out. If changes are made to this method      * make sure that it is backwards compatible by creating toDataPreXX methods. Also make sure      * that the callers to this method are backwards compatible by creating toDataPreXX methods for      * them even if they are not changed.       * Callers for this method are:       * {@link PutAllMessage#toData(DataOutput)}       * {@link PutAllPRMessage#toData(DataOutput)}       * {@link RemotePutAllMessage#toData(DataOutput)}       */     public void toData(final DataOutput out) throws IOException {       Object key = this.key;       final Object v = this.value;       DataSerializer.writeObject(key, out);        if (v instanceof byte[] || v == null) {         out.writeByte(0);         DataSerializer.writeByteArray((byte[]) v, out);       } else if (v instanceof CachedDeserializable) {         CachedDeserializable cd = (CachedDeserializable) v;         out.writeByte(IS_CACHED_DESER);         DataSerializer.writeByteArray(cd.getSerializedValue(), out);       } else {         out.writeByte(IS_CACHED_DESER);         DataSerializer.writeObjectAsByteArray(v, out);       }       out.writeByte(this.op.ordinal);       byte bits = this.flags;       if (this.filterRouting != null)         bits |= FILTER_ROUTING;       if (this.versionTag != null) {         bits |= VERSION_TAG;         if (this.versionTag instanceof DiskVersionTag) {           bits |= PERSISTENT_TAG;         }       }       // TODO: Yogesh, this should be conditional,       // make sure that we sent it on wire only       // when parallel wan is enabled       bits |= HAS_TAILKEY;       out.writeByte(bits);        if (this.filterRouting != null) {         DataSerializer.writeObject(this.filterRouting, out);       }       if (this.versionTag != null) {         InternalDataSerializer.invokeToData(this.versionTag, out);       }       if (isUsedFakeEventId()) {         // fake event id should be serialized         InternalDataSerializer.invokeToData(this.eventID, out);       }       // TODO: Yogesh, this should be conditional,       // make sure that we sent it on wire only       // when parallel wan is enabled       DataSerializer.writeLong(this.tailKey, out);     }      /**      * Returns the key      */     public Object getKey() {       return this.key;     }      /**      * Returns the value      */     public Object getValue(InternalCache cache) {       Object result = this.value;       if (result instanceof FutureCachedDeserializable) {         FutureCachedDeserializable future = (FutureCachedDeserializable) result;         result = future.create(cache);         this.value = result;       }       return result;     }      /**      * Returns the old value      */     public Object getOldValue() {       return this.oldValue;     }      public Long getTailKey() {       return this.tailKey;     }      public void setTailKey(Long key) {       this.tailKey = key;     }      /**      * Returns the operation      */     public Operation getOp() {       return this.op;     }      public EventID getEventID() {       return this.eventID;     }      /**      * change event id for the entry      *      * @param eventId new event id      */     public void setEventId(EventID eventId) {       this.eventID = eventId;     }      /**      * change bucket id for the entry      *      * @param bucketId new bucket id      */     public void setBucketId(Integer bucketId) {       this.bucketId = bucketId;     }      /**      * get bucket id for the entry      *      * @return bucket id      */     public Integer getBucketId() {       return this.bucketId;     }      /**      * change event id into fake event id The algorithm is to change the threadid into      * bucketid*MAX_THREAD_PER_CLIENT+oldthreadid. So from the log, we can derive the original      * thread id.      *      * @return wether current event id is fake or not new bucket id      */     public boolean setFakeEventID() {       if (bucketId.intValue() &lt; 0) {         return false;       }        if (!isUsedFakeEventId()) {         // assign a fake big thread id. bucket id starts from 0. In order to distinguish         // with other read thread, let bucket id starts from 1 in fake thread id         long threadId = ThreadIdentifier.createFakeThreadIDForBulkOp(bucketId.intValue(),             eventID.getThreadID());         this.eventID = new EventID(eventID.getMembershipID(), threadId, eventID.getSequenceID());         this.setUsedFakeEventId(true);       }       return true;     }      public boolean isUsedFakeEventId() {       return (flags &amp; USED_FAKE_EVENT_ID) != 0;     }      public void setUsedFakeEventId(boolean usedFakeEventId) {       if (usedFakeEventId) {         flags |= USED_FAKE_EVENT_ID;       } else {         flags &amp;= ~(USED_FAKE_EVENT_ID);       }     }      public boolean isNotifyOnly() {       return (flags &amp; NOTIFY_ONLY) != 0;     }      public void setNotifyOnly(boolean notifyOnly) {       if (notifyOnly) {         flags |= NOTIFY_ONLY;       } else {         flags &amp;= ~(NOTIFY_ONLY);       }     }      boolean isPossibleDuplicate() {       return (this.flags &amp; POSDUP) != 0;     }      public void setPossibleDuplicate(boolean possibleDuplicate) {       if (possibleDuplicate) {         flags |= POSDUP;       } else {         flags &amp;= ~(POSDUP);       }     }      public boolean isInhibitDistribution() {       return this.inhibitDistribution;     }      public void setInhibitDistribution(boolean inhibitDistribution) {       this.inhibitDistribution = inhibitDistribution;     }      public boolean isCallbacksInvoked() {       return this.callbacksInvoked;     }      public void setCallbacksInvoked(boolean callbacksInvoked) {       this.callbacksInvoked = callbacksInvoked;     }   }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method2 Feature envy3 Primitive obsession4 Data class5 Inappropriate use of comments6 Inconsistent formatting and naming conventions7 Duplicated code8 Inefficient data serialization handling9 Inconsistent use of flags and boolean variables</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15000</td>
    <td align="left">https://github.com/apache/geode/blob/8fd839e8b73e40bd2dfd14f331b587431bd35a66/geode-core/src/main/java/org/apache/geode/internal/cache/DistributedPutAllOperation.java/#L274-L599</td>
    <td align="right">2</td>
    <td align="right">2592</td>
    <td align="right">15000</td>
  </tr>
  <tr valign="top">
    <td align="right">2317</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;1. Long Method&quot;, &quot;2. Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class PartitionCollapsingSchemas implements Serializable {     private static String DATED_INTERMEDIATE_VALUE_SCHEMA_NAME = &quot;DatedMapValue&quot;;   private static String KEY_SCHEMA = &quot;key.schema&quot;;   private static String INTERMEDIATE_VALUE_SCHEMA = &quot;intermediate.value.schema&quot;;   private static String OUTPUT_VALUE_SCHEMA = &quot;output.value.schema&quot;;      private final String _outputSchemaName;   private final String _outputSchemaNamespace;   private transient Schema _keySchema;   private transient Schema _intermediateValueSchema;   private transient Schema _outputValueSchema;      // generated schemas   private transient Schema _mapOutputSchema;   private transient Schema _dateIntermediateValueSchema;   private transient Schema _mapOutputValueSchema;   private transient Schema _reduceOutputSchema;   private transient Map _mapInputSchemas;      //schemas are stored here so the object can be serialized   private Map conf;    private Map _inputSchemas;      public PartitionCollapsingSchemas(TaskSchemas schemas, Map inputSchemas, String outputSchemaName, String outputSchemaNamespace)   {     if (schemas == null)     {       throw new NullArgumentException(&quot;schemas&quot;);     }     if (inputSchemas == null)     {       throw new NullArgumentException(&quot;inputSchema&quot;);     }     if (outputSchemaName == null)     {       throw new NullArgumentException(&quot;outputSchemaName&quot;);     }     if (outputSchemaName == outputSchemaNamespace)     {       throw new NullArgumentException(&quot;outputSchemaNamespace&quot;);     }     _outputSchemaName = outputSchemaName;     _outputSchemaNamespace = outputSchemaNamespace;          conf = new HashMap();     conf.put(KEY_SCHEMA, schemas.getKeySchema().toString());     conf.put(INTERMEDIATE_VALUE_SCHEMA, schemas.getIntermediateValueSchema().toString());     conf.put(OUTPUT_VALUE_SCHEMA, schemas.getOutputValueSchema().toString());          _inputSchemas = new HashMap();     for (Entry schema : inputSchemas.entrySet())     {       _inputSchemas.put(schema.getKey(), schema.getValue().toString());     }   }        public Map getMapInputSchemas()   {         if (_mapInputSchemas == null)     {       _mapInputSchemas = new HashMap();              for (Entry schemaPair : _inputSchemas.entrySet())       {         Schema schema = new Schema.Parser().parse(schemaPair.getValue());                  List mapInputSchemas = new ArrayList();                  if (schema.getType() == Type.UNION)         {           mapInputSchemas.addAll(schema.getTypes());         }         else         {           mapInputSchemas.add(schema);         }                  // feedback from output (optional)         mapInputSchemas.add(getReduceOutputSchema());                  _mapInputSchemas.put(schemaPair.getKey(), Schema.createUnion(mapInputSchemas));       }                   }     return Collections.unmodifiableMap(_mapInputSchemas);   }        public Schema getMapOutputSchema()   {     if (_mapOutputSchema == null)     {       _mapOutputSchema = Pair.getPairSchema(getMapOutputKeySchema(),                                              getMapOutputValueSchema());     }     return _mapOutputSchema;   }      public Schema getKeySchema()   {     if (_keySchema == null)     {       _keySchema = new Schema.Parser().parse(conf.get(KEY_SCHEMA));     }     return _keySchema;   }          public Schema getMapOutputKeySchema()   {     return getKeySchema();   }        public Schema getReduceOutputSchema()   {     if (_reduceOutputSchema == null)     {       _reduceOutputSchema = Schema.createRecord(_outputSchemaName, null, _outputSchemaNamespace, false);                   List fields = Arrays.asList(new Field(&quot;key&quot;,getKeySchema(), null, null),                                          new Field(&quot;value&quot;, getOutputValueSchema(), null, null));           _reduceOutputSchema.setFields(fields);     }     return _reduceOutputSchema;   }        public Schema getDatedIntermediateValueSchema()   {     if (_dateIntermediateValueSchema == null)     {       _dateIntermediateValueSchema = Schema.createRecord(DATED_INTERMEDIATE_VALUE_SCHEMA_NAME, null, _outputSchemaNamespace, false);       List intermediateValueFields = Arrays.asList(new Field(&quot;value&quot;, getIntermediateValueSchema(), null, null),                                                          new Field(&quot;time&quot;, Schema.create(Type.LONG), null, null));       _dateIntermediateValueSchema.setFields(intermediateValueFields);     }     return _dateIntermediateValueSchema;   }      public Schema getOutputValueSchema()   {     if (_outputValueSchema == null)     {       _outputValueSchema = new Schema.Parser().parse(conf.get(OUTPUT_VALUE_SCHEMA));     }     return _outputValueSchema;   }      public Schema getIntermediateValueSchema()   {     if (_intermediateValueSchema == null)     {       _intermediateValueSchema = new Schema.Parser().parse(conf.get(INTERMEDIATE_VALUE_SCHEMA));     }     return _intermediateValueSchema;   }        public Schema getMapOutputValueSchema()   {         if (_mapOutputValueSchema == null)     {       List unionSchemas = new ArrayList();              unionSchemas.add(getIntermediateValueSchema());              // intermediate values tagged with the date       unionSchemas.add(getDatedIntermediateValueSchema());              // feedback from output of second pass       if (!unionSchemas.contains(getOutputValueSchema()))       {         unionSchemas.add(getOutputValueSchema());       }              _mapOutputValueSchema = Schema.createUnion(unionSchemas);     }     return _mapOutputValueSchema;   } }</td>
    <td align="left">data class</td>
    <td align="left">1. long method, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14122</td>
    <td align="left">https://github.com/apache/datafu/blob/3e52d11f75956ac3e6d2384816affeba565ab61d/datafu-hourglass/src/main/java/datafu/hourglass/schemas/PartitionCollapsingSchemas.java/#L41-L218</td>
    <td align="right">1</td>
    <td align="right">2317</td>
    <td align="right">14122</td>
  </tr>
  <tr valign="top">
    <td align="right">576</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells. The bad smells are: 1. Long Method, 2. Data Class&quot;   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public class IteratorVariableElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.xtext.ui.tests.editor.contentassist.BacktrackingContentAssistTestLanguage.iteratorVariable&quot;); 		private final Group cGroup = (Group)rule.eContents().get(1); 		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0); 		private final RuleCall cNameIdentifierParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0); 		private final Group cGroup_1 = (Group)cGroup.eContents().get(1); 		private final Keyword cColonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0); 		private final Assignment cTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1); 		private final RuleCall cTypeTypeExpParserRuleCall_1_1_0 = (RuleCall)cTypeAssignment_1_1.eContents().get(0); 		 		//iteratorVariable: 		//	name=Identifier (':' type=TypeExp)?; 		@Override public ParserRule getRule() { return rule; } 		 		//name=Identifier (':' type=TypeExp)? 		public Group getGroup() { return cGroup; } 		 		//name=Identifier 		public Assignment getNameAssignment_0() { return cNameAssignment_0; } 		 		//Identifier 		public RuleCall getNameIdentifierParserRuleCall_0_0() { return cNameIdentifierParserRuleCall_0_0; } 		 		//(':' type=TypeExp)? 		public Group getGroup_1() { return cGroup_1; } 		 		//':' 		public Keyword getColonKeyword_1_0() { return cColonKeyword_1_0; } 		 		//type=TypeExp 		public Assignment getTypeAssignment_1_1() { return cTypeAssignment_1_1; } 		 		//TypeExp 		public RuleCall getTypeTypeExpParserRuleCall_1_1_0() { return cTypeTypeExpParserRuleCall_1_1_0; } 	}</td>
    <td align="left">data class</td>
    <td align="left">1. long method, 2. data class   </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5781</td>
    <td align="left">https://github.com/eclipse/xtext-eclipse/blob/0c7546b6aaf3644a77fc68eef9f3da368cbbeabd/org.eclipse.xtext.ui.tests/src-gen/org/eclipse/xtext/ui/tests/editor/contentassist/services/BacktrackingContentAssistTestLanguageGrammarAccess.java/#L2569-L2603</td>
    <td align="right">1</td>
    <td align="right">576</td>
    <td align="right">5781</td>
  </tr>
  <tr valign="top">
    <td align="right">2646</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TemporaryFolderExtension implements ParameterResolver, BeforeEachCallback, AfterEachCallback {      private TemporaryFolder temporaryFolder;      @Override     public void beforeEach(ExtensionContext context) throws Exception {         temporaryFolder = new TemporaryFolder(Files.createTempDir());     }      @Override     public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {         return (parameterContext.getParameter().getType() == TemporaryFolder.class);     }      @Override     public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {         return temporaryFolder;     }      @Override     public void afterEach(ExtensionContext context) throws Exception {         FileUtils.deleteDirectory(temporaryFolder.getTempDir());     }      public TemporaryFolder getTemporaryFolder() {         return temporaryFolder;     }      public static class TemporaryFolder {         private final File tempDir;         private final String folderPath;          public TemporaryFolder(File tempDir) {             this.tempDir = tempDir;             this.folderPath = tempDir.getPath() + &quot;/&quot;;         }          public File getTempDir() {             return tempDir;         }          public String getFolderPath() {             return folderPath;         }     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15154</td>
    <td align="left">https://github.com/apache/james-project/blob/fa24a096a5853459c3769a34ccc68feb91626bfa/server/testing/src/main/java/org/apache/james/junit/TemporaryFolderExtension.java/#L34-L79</td>
    <td align="right">1</td>
    <td align="right">2646</td>
    <td align="right">15154</td>
  </tr>
  <tr valign="top">
    <td align="right">2228</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells the bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  class TaskRemoval implements WorkerHistoryItem   {     private final String taskId;      @JsonCreator     public TaskRemoval(         @JsonProperty(&quot;taskId&quot;) String taskId     )     {       this.taskId = taskId;     }      @JsonProperty     public String getTaskId()     {       return taskId;     }      @Override     public String toString()     {       return &quot;TaskRemoval{&quot; +              &quot;taskId='&quot; + taskId + '\'' +              '}';     }   }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13581</td>
    <td align="left">https://github.com/apache/incubator-druid/blob/8ca7cb4886dcaeeaaea3a06aceb9e6d50eeecab5/indexing-service/src/main/java/org/apache/druid/indexing/worker/WorkerHistoryItem.java/#L64-L89</td>
    <td align="right">1</td>
    <td align="right">2228</td>
    <td align="right">13581</td>
  </tr>
  <tr valign="top">
    <td align="right">599</td>
    <td align="left">{ &quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DeploymentPlannersResponse extends BaseResponse {     @SerializedName(ApiConstants.NAME)     @Param(description = &quot;Deployment Planner name&quot;)     private String name;      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5988</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/api/src/main/java/org/apache/cloudstack/api/response/DeploymentPlannersResponse.java/#L26-L38</td>
    <td align="right">1</td>
    <td align="right">599</td>
    <td align="right">5988</td>
  </tr>
  <tr valign="top">
    <td align="right">45</td>
    <td align="left">{      &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [          &quot;Data Class&quot;     ]  }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    final static class TypeList {         Hashtable types;          TypeList()         {          }          TypeList(Vector typeNames)         {             types = new Hashtable();             for ( int i = 0; i &lt; typeNames.size(); i++ ) {                 String t = ((String) typeNames.elementAt(i)).toLowerCase();                 types.put(t, t);             }         }          final boolean contains(String type)         {             if ( types == null ) {                 return true; //defaults to all             }             return types.containsKey(type);         }     }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">833</td>
    <td align="left">https://github.com/eclipse/openj9/blob/4911084853eb75b20e037c434ad4521b7317ebfb/jcl/src/openj9.traceformat/share/classes/com/ibm/jvm/format/Util.java/#L631-L655</td>
    <td align="right">1</td>
    <td align="right">45</td>
    <td align="right">833</td>
  </tr>
  <tr valign="top">
    <td align="right">2525</td>
    <td align="left">{&quot;answer&quot;: &quot;YES I found bad smells&quot;, &quot;detected_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@InterfaceAudience.Private public class MetricsAssignmentManagerSourceImpl     extends BaseSourceImpl     implements MetricsAssignmentManagerSource {    private MutableGaugeLong ritGauge;   private MutableGaugeLong ritCountOverThresholdGauge;   private MutableGaugeLong ritOldestAgeGauge;   private MetricHistogram ritDurationHisto;    private MutableFastCounter operationCounter;    private OperationMetrics assignMetrics;   private OperationMetrics unassignMetrics;   private OperationMetrics moveMetrics;   private OperationMetrics reopenMetrics;   private OperationMetrics openMetrics;   private OperationMetrics closeMetrics;   private OperationMetrics splitMetrics;   private OperationMetrics mergeMetrics;    public MetricsAssignmentManagerSourceImpl() {     this(METRICS_NAME, METRICS_DESCRIPTION, METRICS_CONTEXT, METRICS_JMX_CONTEXT);   }    public MetricsAssignmentManagerSourceImpl(String metricsName,                                             String metricsDescription,                                             String metricsContext, String metricsJmxContext) {     super(metricsName, metricsDescription, metricsContext, metricsJmxContext);   }    public void init() {     ritGauge = metricsRegistry.newGauge(RIT_COUNT_NAME, RIT_COUNT_DESC, 0L);     ritCountOverThresholdGauge = metricsRegistry.newGauge(RIT_COUNT_OVER_THRESHOLD_NAME,         RIT_COUNT_OVER_THRESHOLD_DESC,0L);     ritOldestAgeGauge = metricsRegistry.newGauge(RIT_OLDEST_AGE_NAME, RIT_OLDEST_AGE_DESC, 0L);     ritDurationHisto = metricsRegistry.newTimeHistogram(RIT_DURATION_NAME, RIT_DURATION_DESC);     operationCounter = metricsRegistry.getCounter(OPERATION_COUNT_NAME, 0L);      /**      * NOTE: Please refer to HBASE-9774 and HBASE-14282. Based on these two issues, HBase is      * moving away from using Hadoop's metric2 to having independent HBase specific Metrics. Use      * {@link BaseSourceImpl#registry} to register the new metrics.      */     assignMetrics = new OperationMetrics(registry, ASSIGN_METRIC_PREFIX);     unassignMetrics = new OperationMetrics(registry, UNASSIGN_METRIC_PREFIX);     moveMetrics = new OperationMetrics(registry, MOVE_METRIC_PREFIX);     reopenMetrics = new OperationMetrics(registry, REOPEN_METRIC_PREFIX);     openMetrics = new OperationMetrics(registry, OPEN_METRIC_PREFIX);     closeMetrics = new OperationMetrics(registry, CLOSE_METRIC_PREFIX);     splitMetrics = new OperationMetrics(registry, SPLIT_METRIC_PREFIX);     mergeMetrics = new OperationMetrics(registry, MERGE_METRIC_PREFIX);   }    @Override   public void setRIT(final int ritCount) {     ritGauge.set(ritCount);   }    @Override   public void setRITCountOverThreshold(final int ritCount) {     ritCountOverThresholdGauge.set(ritCount);   }    @Override   public void setRITOldestAge(final long ritOldestAge) {     ritOldestAgeGauge.set(ritOldestAge);   }    @Override   public void incrementOperationCounter() {     operationCounter.incr();   }    @Override   public void updateRitDuration(long duration) {     ritDurationHisto.add(duration);   }    @Override   public OperationMetrics getAssignMetrics() {     return assignMetrics;   }    @Override   public OperationMetrics getUnassignMetrics() {     return unassignMetrics;   }    @Override   public OperationMetrics getSplitMetrics() {     return splitMetrics;   }    @Override   public OperationMetrics getMergeMetrics() {     return mergeMetrics;   }    @Override   public OperationMetrics getMoveMetrics() {     return moveMetrics;   }    @Override   public OperationMetrics getReopenMetrics() {     return reopenMetrics;   }    @Override   public OperationMetrics getOpenMetrics() {     return openMetrics;   }    @Override   public OperationMetrics getCloseMetrics() {     return closeMetrics;   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14720</td>
    <td align="left">https://github.com/apache/hbase/blob/44f8abd5c65c59e9d09f6ad14b3c825f145d8e4f/hbase-hadoop2-compat/src/main/java/org/apache/hadoop/hbase/master/MetricsAssignmentManagerSourceImpl.java/#L28-L146</td>
    <td align="right">1</td>
    <td align="right">2525</td>
    <td align="right">14720</td>
  </tr>
  <tr valign="top">
    <td align="right">1263</td>
    <td align="left">&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ImportImpl extends ElementImpl implements Import {   /**    * The default value of the '{@link #getImportedNamespace() Imported Namespace}' attribute.    *     *     * @see #getImportedNamespace()    * @generated    * @ordered    */   protected static final String IMPORTED_NAMESPACE_EDEFAULT = null;    /**    * The cached value of the '{@link #getImportedNamespace() Imported Namespace}' attribute.    *     *     * @see #getImportedNamespace()    * @generated    * @ordered    */   protected String importedNamespace = IMPORTED_NAMESPACE_EDEFAULT;    /**    *     *     * @generated    */   protected ImportImpl()   {     super();   }    /**    *     *     * @generated    */   @Override   protected EClass eStaticClass()   {     return SDomainPackage.Literals.IMPORT;   }    /**    *     *     * @generated    */   public String getImportedNamespace()   {     return importedNamespace;   }    /**    *     *     * @generated    */   public void setImportedNamespace(String newImportedNamespace)   {     String oldImportedNamespace = importedNamespace;     importedNamespace = newImportedNamespace;     if (eNotificationRequired())       eNotify(new ENotificationImpl(this, Notification.SET, SDomainPackage.IMPORT__IMPORTED_NAMESPACE, oldImportedNamespace, importedNamespace));   }    /**    *     *     * @generated    */   @Override   public Object eGet(int featureID, boolean resolve, boolean coreType)   {     switch (featureID)     {       case SDomainPackage.IMPORT__IMPORTED_NAMESPACE:         return getImportedNamespace();     }     return super.eGet(featureID, resolve, coreType);   }    /**    *     *     * @generated    */   @Override   public void eSet(int featureID, Object newValue)   {     switch (featureID)     {       case SDomainPackage.IMPORT__IMPORTED_NAMESPACE:         setImportedNamespace((String)newValue);         return;     }     super.eSet(featureID, newValue);   }    /**    *     *     * @generated    */   @Override   public void eUnset(int featureID)   {     switch (featureID)     {       case SDomainPackage.IMPORT__IMPORTED_NAMESPACE:         setImportedNamespace(IMPORTED_NAMESPACE_EDEFAULT);         return;     }     super.eUnset(featureID);   }    /**    *     *     * @generated    */   @Override   public boolean eIsSet(int featureID)   {     switch (featureID)     {       case SDomainPackage.IMPORT__IMPORTED_NAMESPACE:         return IMPORTED_NAMESPACE_EDEFAULT == null ? importedNamespace != null : !IMPORTED_NAMESPACE_EDEFAULT.equals(importedNamespace);     }     return super.eIsSet(featureID);   }    /**    *     *     * @generated    */   @Override   public String toString()   {     if (eIsProxy()) return super.toString();      StringBuffer result = new StringBuffer(super.toString());     result.append(&quot; (importedNamespace: &quot;);     result.append(importedNamespace);     result.append(')');     return result.toString();   }  } //ImportImpl</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10524</td>
    <td align="left">https://github.com/eclipse/xtext-idea/blob/3aa1424ae35f1942dd7c3a457057006f9131de5e/org.eclipse.xtext.idea.sdomain/src-gen/org/eclipse/xtext/idea/sdomain/sDomain/impl/ImportImpl.java/#L34-L183</td>
    <td align="right">1</td>
    <td align="right">1263</td>
    <td align="right">10524</td>
  </tr>
  <tr valign="top">
    <td align="right">539</td>
    <td align="left">{&quot;result&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
final class MachOSymtab {      /**      * ByteBuffer holding the LC_SYMTAB command contents.      */     private final ByteBuffer symtabCmd;      private int symtabDataSize;      private final ArrayList localSymbols = new ArrayList&lt;&gt;();     private final ArrayList globalSymbols = new ArrayList&lt;&gt;();     private final ArrayList undefSymbols = new ArrayList&lt;&gt;();      /**      * Number of symbols added.      */     private int symbolCount;      /**      * String holding symbol table strings.      */     private final StringBuilder strTabContent = new StringBuilder();      /**      * Keeps track of bytes in string table since strTabContent.length() is number of chars, not      * bytes.      */     private int strTabNrOfBytes = 0;      MachOSymtab() {         symtabCmd = MachOByteBuffer.allocate(symtab_command.totalsize);          symtabCmd.putInt(symtab_command.cmd.off, symtab_command.LC_SYMTAB);         symtabCmd.putInt(symtab_command.cmdsize.off, symtab_command.totalsize);          symbolCount = 0;      }      static int getAlign() {         return (4);     }      MachOSymbol addSymbolEntry(String name, byte type, byte secHdrIndex, long offset) {         // Get the current symbol index and append symbol name to string table.         int index;         MachOSymbol sym;          if (name.isEmpty()) {             index = 0;             strTabContent.append('\0');             strTabNrOfBytes += 1;             sym = new MachOSymbol(symbolCount, index, type, secHdrIndex, offset);             localSymbols.add(sym);         } else {             // We can't trust strTabContent.length() since that is             // chars (UTF16), keep track of bytes on our own.             index = strTabNrOfBytes;             strTabContent.append(&quot;_&quot;).append(name).append('\0');             // + 1 for null, + 1 for &quot;_&quot;             strTabNrOfBytes += (name.getBytes().length + 1 + 1);              sym = new MachOSymbol(symbolCount, index, type, secHdrIndex, offset);             switch (type) {                 case nlist_64.N_EXT:                     undefSymbols.add(sym);                     break;                 case nlist_64.N_SECT:                 case nlist_64.N_UNDF:  // null symbol                     localSymbols.add(sym);                     break;                 case nlist_64.N_SECT | nlist_64.N_EXT:                     globalSymbols.add(sym);                     break;                 default:                     System.out.println(&quot;Unsupported Symbol type &quot; + type);                     break;             }         }         symbolCount++;         return (sym);     }      void setOffset(int symoff) {         symtabCmd.putInt(symtab_command.symoff.off, symoff);     }      // Update the symbol indexes once all symbols have been added.     // This is required since we'll be reordering the symbols in the     // file to be in the order of Local, global and Undefined.     void updateIndexes() {         int index = 0;          // Update the local symbol indexes         for (int i = 0; i &lt; localSymbols.size(); i++) {             MachOSymbol sym = localSymbols.get(i);             sym.setIndex(index++);         }          // Update the global symbol indexes         for (int i = 0; i &lt; globalSymbols.size(); i++) {             MachOSymbol sym = globalSymbols.get(i);             sym.setIndex(index++);         }          // Update the undefined symbol indexes         for (int i = index; i &lt; undefSymbols.size(); i++) {             MachOSymbol sym = undefSymbols.get(i);             sym.setIndex(index++);         }     }      // Update LC_SYMTAB command fields based on the number of symbols added     // return the file size taken up by symbol table entries and strings     int calcSizes() {         int stroff;          stroff = symtabCmd.getInt(symtab_command.symoff.off) + (nlist_64.totalsize * symbolCount);         symtabCmd.putInt(symtab_command.nsyms.off, symbolCount);         symtabCmd.putInt(symtab_command.stroff.off, stroff);         symtabCmd.putInt(symtab_command.strsize.off, strTabNrOfBytes);         symtabDataSize = (nlist_64.totalsize * symbolCount) + strTabNrOfBytes;          return (symtabDataSize);     }      int getNumLocalSyms() {         return localSymbols.size();     }      int getNumGlobalSyms() {         return globalSymbols.size();     }      int getNumUndefSyms() {         return undefSymbols.size();     }      byte[] getCmdArray() {         return symtabCmd.array();     }      // Create a single byte array that contains the symbol table entries     // and string table     byte[] getDataArray() {         ByteBuffer symtabData = MachOByteBuffer.allocate(symtabDataSize);         byte[] retarray;          // Add the local symbols         for (int i = 0; i &lt; localSymbols.size(); i++) {             MachOSymbol sym = localSymbols.get(i);             byte[] arr = sym.getArray();             symtabData.put(arr);         }         // Add the global symbols         for (int i = 0; i &lt; globalSymbols.size(); i++) {             MachOSymbol sym = globalSymbols.get(i);             byte[] arr = sym.getArray();             symtabData.put(arr);         }         // Add the undefined symbols         for (int i = 0; i &lt; undefSymbols.size(); i++) {             MachOSymbol sym = undefSymbols.get(i);             byte[] arr = sym.getArray();             symtabData.put(arr);         }          // Add the stringtable         byte[] strs = strTabContent.toString().getBytes();         symtabData.put(strs);          retarray = symtabData.array();          return (retarray);     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5502</td>
    <td align="left">https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/jdk.aot/share/classes/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/macho/MachOSymtab.java/#L34-L209</td>
    <td align="right">1</td>
    <td align="right">539</td>
    <td align="right">5502</td>
  </tr>
  <tr valign="top">
    <td align="right">2461</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;&quot;, propOrder = {     &quot;content&quot; }) @XmlRootElement(name = &quot;cache-policy-conf-other&quot;) public class CachePolicyConfOther {      @XmlMixed     @XmlAnyElement     protected List content;      /**      * Gets the value of the content property.      *       *       * This accessor method returns a reference to the live list,      * not a snapshot. Therefore any modification you make to the      * returned list will be present inside the JAXB object.      * This is why there is not a set method for the content property.      *       *       * For example, to add a new item, do as follows:      *       *    getContent().add(newItem);      *       *       *       *       * Objects of the following type(s) are allowed in the list      * {@link Element }      * {@link String }      */     public List getContent() {         if (content == null) {             content = new ArrayList();         }         return this.content;     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14541</td>
    <td align="left">https://github.com/apache/tomee/blob/d21933b313aff812fe5188b57bf572a9ad649148/container/openejb-jee/src/main/java/org/apache/openejb/jee/jba/CachePolicyConfOther.java/#L32-L71</td>
    <td align="right">1</td>
    <td align="right">2461</td>
    <td align="right">14541</td>
  </tr>
  <tr valign="top">
    <td align="right">600</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SetOrderReferenceDetailsRequest extends DelegateRequest implements Serializable {      @Override     protected SetOrderReferenceDetailsRequest getThis() {         return this;     }      //required parameters     private String amazonOrderReferenceId;     private String orderAmount;     private CurrencyCode orderCurrencyCode;      //optional parameters     private String platformId;     private String sellerNote;     private String sellerOrderId;     private String storeName;     private String supplementaryData;     private String customInformation;     private Boolean requestPaymentAuthorization;      /**      *      * @param amazonOrderReferenceId      *              This value is retrieved from the Amazon Button widget      *              after the buyer has successfully authenticated with Amazon.      *      * @param orderAmount      *              Specifies the total amount of the order represented by this order reference.      */     public SetOrderReferenceDetailsRequest(String amazonOrderReferenceId, String orderAmount) {         this.amazonOrderReferenceId = amazonOrderReferenceId;         this.orderAmount = orderAmount;     }      /**      * Overrides the Client's currency code with specified currency code in SetOrderReferenceDetailsRequest      *      * @param currencyCode      *              A three-digit currency code, formatted based on the ISO 4217 standard.      *      * @return currenyCode      */     public SetOrderReferenceDetailsRequest setOrderCurrencyCode(CurrencyCode currencyCode) {         this.orderCurrencyCode = currencyCode;         return this;     }      /**      * Represents the SellerId of the Solution Provider that developed the platform.      * This value should only be provided by Solution Providers. It should not be      * provided by merchants creating their own custom integration.      *      * @param platformId Represents the SellerId of the Solution Provider that developed the platform.      *                   This value should only be provided by Solution Providers. It should      *                   not be provided by merchants creating their own custom integration.      *      * @return Returns a reference to this object so that methods can be chained together.      */     public SetOrderReferenceDetailsRequest setPlatformId(String platformId) {         this.platformId = platformId;         return this;     }      /**      * Represents a description of the order that is displayed in emails to the buyer.      *      * @param sellerNote Represents a description of the order that is displayed in emails to the buyer.      *      * @return Returns a reference to this object so that methods can be chained together.      */     public SetOrderReferenceDetailsRequest setSellerNote(String sellerNote) {         this.sellerNote = sellerNote;         return this;     }      /**      * The merchant-specified identifier of this order. This is displayed to the      * buyer in their emails and transaction history on the Amazon Pay website.      *      * @param sellerOrderId merchant-specified identifier of the order.      *      * @return the Seller Order ID      */     public SetOrderReferenceDetailsRequest setSellerOrderId(String sellerOrderId) {         this.sellerOrderId = sellerOrderId;         return this;     }      /**      * The identifier of the store from which the order was placed. This overrides      * the default value in Seller Central under Settings &gt; Account Settings. It is      * displayed to the buyer in their emails and transaction history on the      * Amazon Pay website.      *      * @param storeName the identifier of the store from which the order was placed.      *      * @return the Store Name      */     public SetOrderReferenceDetailsRequest setStoreName(String storeName) {         this.storeName = storeName;         return this;     }      /**      * Set the trusted authorization supplementary data.      * Use only as directed by Amazon Pay.      *      * @param supplementaryData Trusted authorization supplementary data (JSON string)      *      * @return Request object      */     public SetOrderReferenceDetailsRequest setSupplementaryData(final String supplementaryData) {         this.supplementaryData = supplementaryData;         return this;     }      /**      * Any additional information that you want to include with this order reference.      *      * @param customInformation Additional information that merchant wants to pass for the order.      *      * @return Custom Information      */     public SetOrderReferenceDetailsRequest setCustomInformation(String customInformation) {         this.customInformation = customInformation;         return this;     }      /**      *      * @return AmazonOrderReferenceId      */     public String getAmazonOrderReferenceId() {         return amazonOrderReferenceId;     }      /**      *      * @return OrderAmount      */     public String getOrderAmount() {         return orderAmount;     }      /**      *      * @return OrderCurrencyCode      */     public CurrencyCode getOrderCurrencyCode() {         return orderCurrencyCode;     }      /**      *      * @return PlatformId      */     public String getPlatformId() {         return platformId;     }      /**      *      * @return SellerNote      */     public String getSellerNote() {         return sellerNote;     }      /**      *      * @return SellerOrderId      */     public String getSellerOrderId() {         return sellerOrderId;     }      /**      *      * @return StoreName      */     public String getStoreName() {         return storeName;     }      /**      * Returns the trusted authorization supplementary data.      *      * @return supplementaryData as a JSON string      */     public String getSupplementaryData() {         return supplementaryData;     }      /**      *      * @return CustomInformation      */     public String getCustomInformation() {         return customInformation;     }      /**      *Check if payment authorization has been requested or not      *      * @return Value of the requestPaymentAuthorization      */     public Boolean getRequestPaymentAuthorization() {         return requestPaymentAuthorization;     }      /**      * Specifies if the merchants want their buyers to go through multi-factor authentication      *      * @param requestPaymentAuthorization flag exposed to merchants using which merchants      *                                    can enforce their buyers to through multi-factor authentication      *      * @return Value of the requestPaymentAuthorization      */     public SetOrderReferenceDetailsRequest setRequestPaymentAuthorization(Boolean requestPaymentAuthorization) {         this.requestPaymentAuthorization = requestPaymentAuthorization;         return this;     }      /**      * Returns a string representation of this object; useful for testing and      * debugging.      *      * @return A string representation of this object.      *      * @see java.lang.Object#toString()      */     @Override     public String toString() {         return &quot;SetOrderReferenceDetailsRequest{&quot;                 + &quot;amazonOrderReferenceId=&quot; + amazonOrderReferenceId                 + &quot;, orderAmount=&quot; + orderAmount                 + &quot;, orderCurrencyCode=&quot; + orderCurrencyCode                 + &quot;, platformId=&quot; + platformId                 + &quot;, sellerNote=&quot; + sellerNote                 + &quot;, sellerOrderId=&quot; + sellerOrderId                 + &quot;, storeName=&quot; + storeName                 + &quot;, supplementaryData=&quot; + supplementaryData                 + &quot;, customInformation=&quot; + customInformation                 + &quot;, mwsAuthToken=&quot; + getMwsAuthToken() + '}';     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5993</td>
    <td align="left">https://github.com/amzn/amazon-pay-sdk-java/blob/5a3547d00c796aab8f0c8ac12e0310f7a5c4678a/src/com/amazon/pay/request/SetOrderReferenceDetailsRequest.java/#L25-L272</td>
    <td align="right">1</td>
    <td align="right">600</td>
    <td align="right">5993</td>
  </tr>
  <tr valign="top">
    <td align="right">420</td>
    <td align="left">&nbsp;{&quot;message&quot;:&quot;YES I found bad smells&quot;,&quot;detected_bad_smells&quot;:[&quot;Long Method&quot;,&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class PerforceScmProvider     extends AbstractScmProvider {     private static final String[] PROTOCOLS = { &quot;tcp&quot;, &quot;tcp4&quot;, &quot;tcp6&quot;, &quot;tcp46&quot;, &quot;tcp64&quot;, &quot;ssl&quot;, &quot;ssl4&quot;, &quot;ssl6&quot;,         &quot;ssl46&quot;, &quot;ssl64&quot; };      // ----------------------------------------------------------------------     // ScmProvider Implementation     // ----------------------------------------------------------------------      public boolean requiresEditMode()     {         return true;     }      public ScmProviderRepository makeProviderScmRepository( String scmSpecificUrl, char delimiter )         throws ScmRepositoryException     {         String protocol = null;         String path;         int port = 0;         String host = null;          //minimal logic to support perforce protocols in scm url, and keep the next part unchange         int i0 = scmSpecificUrl.indexOf( delimiter );         if ( i0 &gt; 0 )         {             protocol = scmSpecificUrl.substring( 0, i0 );             HashSet protocols = new HashSet( Arrays.asList( PROTOCOLS ) );             if ( protocols.contains( protocol ) )             {                 scmSpecificUrl = scmSpecificUrl.substring( i0 + 1 );             }             else             {                 protocol = null;             }         }          int i1 = scmSpecificUrl.indexOf( delimiter );         int i2 = scmSpecificUrl.indexOf( delimiter, i1 + 1 );          if ( i1 &gt; 0 )         {             int lastDelimiter = scmSpecificUrl.lastIndexOf( delimiter );             path = scmSpecificUrl.substring( lastDelimiter + 1 );             host = scmSpecificUrl.substring( 0, i1 );              // If there is tree parts in the scm url, the second is the port             if ( i2 &gt;= 0 )             {                 try                 {                     String tmp = scmSpecificUrl.substring( i1 + 1, lastDelimiter );                     port = Integer.parseInt( tmp );                 }                 catch ( NumberFormatException ex )                 {                     throw new ScmRepositoryException( &quot;The port has to be a number.&quot; );                 }             }         }         else         {             path = scmSpecificUrl;         }          String user = null;         String password = null;         if ( host != null &amp;&amp; host.indexOf( '@' ) &gt; 1 )         {             user = host.substring( 0, host.indexOf( '@' ) );             host = host.substring( host.indexOf( '@' ) + 1 );         }          if ( path.indexOf( '@' ) &gt; 1 )         {             if ( host != null )             {                 if ( getLogger().isWarnEnabled() )                 {                     getLogger().warn(                                       &quot;Username as part of path is deprecated, the new format is &quot;                                           + &quot;scm:perforce:[username@]host:port:path_to_repository&quot; );                 }             }              user = path.substring( 0, path.indexOf( '@' ) );             path = path.substring( path.indexOf( '@' ) + 1 );         }          return new PerforceScmProviderRepository( protocol, host, port, path, user, password );     }      public String getScmType()     {         return &quot;perforce&quot;;     }      /** {@inheritDoc} */     protected ChangeLogScmResult changelog( ScmProviderRepository repository, ScmFileSet fileSet,                                             CommandParameters parameters )         throws ScmException     {         PerforceChangeLogCommand command = new PerforceChangeLogCommand();         command.setLogger( getLogger() );         return (ChangeLogScmResult) command.execute( repository, fileSet, parameters );     }      public AddScmResult add( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )         throws ScmException     {         PerforceAddCommand command = new PerforceAddCommand();         command.setLogger( getLogger() );         return (AddScmResult) command.execute( repository, fileSet, params );     }      protected RemoveScmResult remove( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )         throws ScmException     {         PerforceRemoveCommand command = new PerforceRemoveCommand();         command.setLogger( getLogger() );         return (RemoveScmResult) command.execute( repository, fileSet, params );     }      protected CheckInScmResult checkin( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )         throws ScmException     {         PerforceCheckInCommand command = new PerforceCheckInCommand();         command.setLogger( getLogger() );         return (CheckInScmResult) command.execute( repository, fileSet, params );     }      protected CheckOutScmResult checkout( ScmProviderRepository repository, ScmFileSet fileSet,                                           CommandParameters params )         throws ScmException     {         PerforceCheckOutCommand command = new PerforceCheckOutCommand();         command.setLogger( getLogger() );         return (CheckOutScmResult) command.execute( repository, fileSet, params );     }      protected DiffScmResult diff( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )         throws ScmException     {         PerforceDiffCommand command = new PerforceDiffCommand();         command.setLogger( getLogger() );         return (DiffScmResult) command.execute( repository, fileSet, params );     }      protected EditScmResult edit( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )         throws ScmException     {         PerforceEditCommand command = new PerforceEditCommand();         command.setLogger( getLogger() );         return (EditScmResult) command.execute( repository, fileSet, params );     }      protected LoginScmResult login( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )         throws ScmException     {         PerforceLoginCommand command = new PerforceLoginCommand();         command.setLogger( getLogger() );         return (LoginScmResult) command.execute( repository, fileSet, params );     }      protected StatusScmResult status( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )         throws ScmException     {         PerforceStatusCommand command = new PerforceStatusCommand();         command.setLogger( getLogger() );         return (StatusScmResult) command.execute( repository, fileSet, params );     }      protected TagScmResult tag( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )         throws ScmException     {         PerforceTagCommand command = new PerforceTagCommand();         command.setLogger( getLogger() );         return (TagScmResult) command.execute( repository, fileSet, params );     }      protected UnEditScmResult unedit( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )         throws ScmException     {         PerforceUnEditCommand command = new PerforceUnEditCommand();         command.setLogger( getLogger() );         return (UnEditScmResult) command.execute( repository, fileSet, params );     }      protected UpdateScmResult update( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )         throws ScmException     {         PerforceUpdateCommand command = new PerforceUpdateCommand();         command.setLogger( getLogger() );         return (UpdateScmResult) command.execute( repository, fileSet, params );     }      protected BlameScmResult blame( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )         throws ScmException     {         PerforceBlameCommand command = new PerforceBlameCommand();         command.setLogger( getLogger() );         return (BlameScmResult) command.execute( repository, fileSet, params );     }      public static Commandline createP4Command( PerforceScmProviderRepository repo, File workingDir )     {         Commandline command = new Commandline();         command.setExecutable( &quot;p4&quot; );         if ( workingDir != null )         {             // SCM-209             command.createArg().setValue( &quot;-d&quot; );             command.createArg().setValue( workingDir.getAbsolutePath() );         }           if ( repo.getHost() != null )         {             command.createArg().setValue( &quot;-p&quot; );             String value = &quot;&quot;;             if ( ! StringUtils.isBlank( repo.getProtocol() ) )             {                 value += repo.getProtocol() + &quot;:&quot;;             }             value += repo.getHost();             if ( repo.getPort() != 0 )             {                 value += &quot;:&quot; + Integer.toString( repo.getPort() );             }             command.createArg().setValue( value );         }          if ( StringUtils.isNotEmpty( repo.getUser() ) )         {             command.createArg().setValue( &quot;-u&quot; );             command.createArg().setValue( repo.getUser() );         }          if ( StringUtils.isNotEmpty( repo.getPassword() ) )         {             command.createArg().setValue( &quot;-P&quot; );             command.createArg().setValue( repo.getPassword() );         }         return command;     }      public static String clean( String string )     {         if ( string.indexOf( &quot; -P &quot; ) == -1 )         {             return string;         }         int idx = string.indexOf( &quot; -P &quot; ) + 4;         int end = string.indexOf( ' ', idx );         return string.substring( 0, idx ) + StringUtils.repeat( &quot;*&quot;, end - idx ) + string.substring( end );     }      /**      * Given a path like &quot;//depot/foo/bar&quot;, returns the      * proper path to include everything beneath it.      *       * //depot/foo/bar -&gt; //depot/foo/bar/...      * //depot/foo/bar/ -&gt; //depot/foo/bar/...      * //depot/foo/bar/... -&gt; //depot/foo/bar/...      *      * @param repoPath      * @return      */     public static String getCanonicalRepoPath( String repoPath )     {         if ( repoPath.endsWith( &quot;/...&quot; ) )         {             return repoPath;         }         else if ( repoPath.endsWith( &quot;/&quot; ) )         {             return repoPath + &quot;...&quot;;         }         else         {             return repoPath + &quot;/...&quot;;         }     }      private static final String NEWLINE = &quot;\r\n&quot;;      /*      * Clientspec name can be overridden with the system property below.  I don't      * know of any way for this code to get access to maven's settings.xml so this      * is the best I can do.      *      * Sample clientspec:       Client: mperham-mikeperham-dt-maven      Root: d:\temp\target      Owner: mperham      View:      //depot/sandbox/mperham/tsa/tsa-domain/... //mperham-mikeperham-dt-maven/...      Description:      Created by maven-scm-provider-perforce       */     public static String createClientspec( ScmLogger logger, PerforceScmProviderRepository repo, File workDir,                                            String repoPath )     {         String clientspecName = getClientspecName( logger, repo, workDir );         String userName = getUsername( logger, repo );          String rootDir;         try         {             // SCM-184             rootDir = workDir.getCanonicalPath();         }         catch ( IOException ex )         {             //getLogger().error(&quot;Error getting canonical path for working directory: &quot; + workDir, ex);             rootDir = workDir.getAbsolutePath();         }          StringBuilder buf = new StringBuilder();         buf.append( &quot;Client: &quot; ).append( clientspecName ).append( NEWLINE );         buf.append( &quot;Root: &quot; ).append( rootDir ).append( NEWLINE );         buf.append( &quot;Owner: &quot; ).append( userName ).append( NEWLINE );         buf.append( &quot;View:&quot; ).append( NEWLINE );         buf.append( &quot;\t&quot; ).append( PerforceScmProvider.getCanonicalRepoPath( repoPath ) );         buf.append( &quot; //&quot; ).append( clientspecName ).append( &quot;/...&quot; ).append( NEWLINE );         buf.append( &quot;Description:&quot; ).append( NEWLINE );         buf.append( &quot;\t&quot; ).append( &quot;Created by maven-scm-provider-perforce&quot; ).append( NEWLINE );         return buf.toString();     }      public static final String DEFAULT_CLIENTSPEC_PROPERTY = &quot;maven.scm.perforce.clientspec.name&quot;;      public static String getClientspecName( ScmLogger logger, PerforceScmProviderRepository repo, File workDir )     {         String def = generateDefaultClientspecName( logger, repo, workDir );         // until someone put clearProperty in DefaultContinuumScm.getScmRepository( Project , boolean  )         String l = System.getProperty( DEFAULT_CLIENTSPEC_PROPERTY, def );         if ( l == null || &quot;&quot;.equals( l.trim() ) )         {             return def;         }         return l;     }      private static String generateDefaultClientspecName( ScmLogger logger, PerforceScmProviderRepository repo,                                                          File workDir )     {         String username = getUsername( logger, repo );         String hostname;         String path;         try         {             hostname = InetAddress.getLocalHost().getHostName();             // [SCM-370][SCM-351] client specs cannot contain forward slashes, spaces and ~; &quot;-&quot; is okay             path = workDir.getCanonicalPath().replaceAll( &quot;[/ ~]&quot;, &quot;-&quot; );         }         catch ( UnknownHostException e )         {             // Should never happen             throw new RuntimeException( e );         }         catch ( IOException e )         {             throw new RuntimeException( e );         }         return username + &quot;-&quot; + hostname + &quot;-MavenSCM-&quot; + path;     }      private static String getUsername( ScmLogger logger, PerforceScmProviderRepository repo )     {         String username = PerforceInfoCommand.getInfo( logger, repo ).getEntry( &quot;User name&quot; );         if ( username == null )         {             // os user != perforce user             username = repo.getUser();             if ( username == null )             {                 username = System.getProperty( &quot;user.name&quot;, &quot;nouser&quot; );             }         }         return username;     }      /**      * This is a &quot;safe&quot; method which handles cases where repo.getPath() is      * not actually a valid Perforce depot location.  This is a frequent error      * due to branches and directory naming where dir name != artifactId.      *      * @param log     the logging object to use      * @param repo    the Perforce repo      * @param basedir the base directory we are operating in.  If pom.xml exists in this directory,      *                this method will verify repo.getPath()/pom.xml == p4 where basedir/pom.xml      * @return repo.getPath if it is determined to be accurate.  The p4 where location otherwise.      */     public static String getRepoPath( ScmLogger log, PerforceScmProviderRepository repo, File basedir )     {         PerforceWhereCommand where = new PerforceWhereCommand( log, repo );          // Handle an edge case where we release:prepare'd a module with an invalid SCM location.         // In this case, the release.properties will contain the invalid URL for checkout purposes         // during release:perform.  In this case, the basedir is not the module root so we detect that         // and remove the trailing target/checkout directory.         if ( basedir.toString().replace( '\\', '/' ).endsWith( &quot;/target/checkout&quot; ) )         {             String dir = basedir.toString();             basedir = new File( dir.substring( 0, dir.length() - &quot;/target/checkout&quot;.length() ) );             log.debug( &quot;Fixing checkout URL: &quot; + basedir );         }         File pom = new File( basedir, &quot;pom.xml&quot; );         String loc = repo.getPath();         log.debug( &quot;SCM path in pom: &quot; + loc );         if ( pom.exists() )         {             loc = where.getDepotLocation( pom );             if ( loc == null )             {                 loc = repo.getPath();                 log.debug( &quot;cannot find depot =&gt; using &quot; + loc );             }             else if ( loc.endsWith( &quot;/pom.xml&quot; ) )             {                 loc = loc.substring( 0, loc.length() - &quot;/pom.xml&quot;.length() );                 log.debug( &quot;Actual POM location: &quot; + loc );                 if ( !repo.getPath().equals( loc ) )                 {                     log.info( &quot;The SCM location in your pom.xml (&quot; + repo.getPath()                         + &quot;) is not equal to the depot location (&quot; + loc                         + &quot;).  This happens frequently with branches.  &quot; + &quot;Ignoring the SCM location.&quot; );                 }             }         }         return loc;     }       private static Boolean live = null;      public static boolean isLive()     {         if ( live == null )         {             if ( !Boolean.getBoolean( &quot;maven.scm.testing&quot; ) )             {                 // We are not executing in the tests so we are live.                 live = Boolean.TRUE;             }             else             {                 // During unit tests, we need to check the local system                 // to see if the user has Perforce installed.  If not, we mark                 // the provider as &quot;not live&quot; (or dead, I suppose!) and skip                 // anything that requires an active server connection.                 try                 {                     Commandline command = new Commandline();                     command.setExecutable( &quot;p4&quot; );                     Process proc = command.execute();                     BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );                     @SuppressWarnings( &quot;unused&quot; )                     String line;                     while ( ( line = br.readLine() ) != null )                     {                         //System.out.println(line);                     }                     int rc = proc.exitValue();                     live = ( rc == 0 ? Boolean.TRUE : Boolean.FALSE );                 }                 catch ( Exception e )                 {                     e.printStackTrace();                     live = Boolean.FALSE;                 }             }         }          return live.booleanValue();     } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4240</td>
    <td align="left">https://github.com/apache/maven-scm/blob/6f876b4dc33372a8527f09c23c6f698e04a771c6/maven-scm-providers/maven-scm-provider-perforce/src/main/java/org/apache/maven/scm/provider/perforce/PerforceScmProvider.java/#L77-L558</td>
    <td align="right">1</td>
    <td align="right">420</td>
    <td align="right">4240</td>
  </tr>
  <tr valign="top">
    <td align="right">2579</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class Build {          /**          * Project version.          */         private String version = &quot;&quot;;          public String getVersion() {             return version;         }          public void setVersion(final String version) {             this.version = version;         }      }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14944</td>
    <td align="left">https://github.com/eclipse/hawkbit/blob/51be28147f6f575b6c1ab4a5ef84ffd9174f1209/hawkbit-core/src/main/java/org/eclipse/hawkbit/HawkbitServerProperties.java/#L75-L90</td>
    <td align="right">1</td>
    <td align="right">2579</td>
    <td align="right">14944</td>
  </tr>
  <tr valign="top">
    <td align="right">54</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells, the bad smells are: 3. Data class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
/*package*/ class WafFolderContent {   private final WafFolder rootFolder;   private final List subFolders;   private final List files;    /**    * Creates instance of the folder content.    * @param rootFolder root folder    * @param subFolders sub folders    * @param files files    */   public WafFolderContent(WafFolder rootFolder, List subFolders, List files) {     this.rootFolder = rootFolder;     this.subFolders = subFolders;     this.files = files;   }    /**    * Gets root folder.    * @return root folder    */   public WafFolder getRootFolder() {     return rootFolder;   }    /**    * Gets sub folders.    * @return sub folders    */   public List getSubFolders() {     return subFolders;   }    /**    * Gets files.    * @return files    */   public List getFiles() {     return files;   }       }</td>
    <td align="left">data class</td>
    <td align="left">3. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">953</td>
    <td align="left">https://github.com/Esri/geoportal-server-harvester/blob/b8c69260e3d6ec10df6514c201219e690cfba048/geoportal-connectors/geoportal-harvester-waf/src/main/java/com/esri/geoportal/harvester/waf/WafFolderContent.java/#L23-L65</td>
    <td align="right">1</td>
    <td align="right">54</td>
    <td align="right">953</td>
  </tr>
  <tr valign="top">
    <td align="right">1992</td>
    <td align="left">YES I found bad smells the bad smells are: 1. Long class, 2. Data class, 3. Getter and setter methods, 4. Duplicate code, 5. Lack of encapsulation.</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class EnsemblExonVO extends EnsemblDBBaseVO {      @JsonProperty(value = &quot;version&quot;)     private Integer version;      @JsonProperty(value = &quot;assembly_name&quot;)     private String assemblyName;      @JsonProperty(value = &quot;seq_region_name&quot;)     private String seqRegionName;      @JsonProperty(value = &quot;strand&quot;)     private String strand;      public Integer getVersion() {         return version;     }      public void setVersion(Integer version) {         this.version = version;     }      public String getAssemblyName() {         return assemblyName;     }      public void setAssemblyName(String assemblyName) {         this.assemblyName = assemblyName;     }      public String getSeqRegionName() {         return seqRegionName;     }      public void setSeqRegionName(String seqRegionName) {         this.seqRegionName = seqRegionName;     }      public String getStrand() {         return strand;     }      public void setStrand(String strand) {         this.strand = strand;     } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long class, 2 Data class, 3 Getter and setter methods, 4 Duplicate code, 5 Lack of encapsulation</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">. Long class,  3. Getter and setter methods,  4. Duplicate code,  5. Lack of encapsulation.</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12687</td>
    <td align="left">https://github.com/epam/NGB/blob/340504529fc576eeec92fbae636e437ce486cc4a/server/catgenome/src/main/java/com/epam/catgenome/controller/vo/externaldb/ensemblevo/EnsemblExonVO.java/#L40-L85</td>
    <td align="right">2</td>
    <td align="right">1992</td>
    <td align="right">12687</td>
  </tr>
  <tr valign="top">
    <td align="right">314</td>
    <td align="left">&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad_smells&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class NexmarkQueryTransform     extends PTransform, PCollection&gt; {    private transient PCollection&gt; sideInput = null;    protected NexmarkQueryTransform(String name) {     super(name);   }    /** Whether this query expects a side input to be populated. Defaults to {@code false}. */   public boolean needsSideInput() {     return false;   }    /**    * Set the side input for the query.    *    * Note that due to the nature of side inputs, this instance of the query is now fixed and can    * only be safely applied in the pipeline where the side input was created.    */   public void setSideInput(PCollection&gt; sideInput) {     this.sideInput = sideInput;   }    /** Get the side input, if any. */   public @Nullable PCollection&gt; getSideInput() {     return sideInput;   } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3227</td>
    <td align="left">https://github.com/apache/beam/blob/a956ff77a8448e5f2c12f6695fec608348b5ab60/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/NexmarkQueryTransform.java/#L34-L62</td>
    <td align="right">1</td>
    <td align="right">314</td>
    <td align="right">3227</td>
  </tr>
  <tr valign="top">
    <td align="right">2337</td>
    <td align="left">{ &quot;response&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     { &quot;1. Data Class&quot;: &quot;DCSerialField class seems to be a Data Class as it holds only data and has minimal behavior&quot; }   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class DCSerialField extends DCBlockTag implements SerialFieldTree {         public final DCIdentifier name;         public final DCReference type;         public final List description;          DCSerialField(DCIdentifier name, DCReference type, List description) {             this.description = description;             this.name = name;             this.type = type;         }          @Override @DefinedBy(Api.COMPILER_TREE)         public Kind getKind() {             return Kind.SERIAL_FIELD;         }          @Override @DefinedBy(Api.COMPILER_TREE)         public  R accept(DocTreeVisitor v, D d) {             return v.visitSerialField(this, d);         }          @Override @DefinedBy(Api.COMPILER_TREE)         public List getDescription() {             return description;         }          @Override @DefinedBy(Api.COMPILER_TREE)         public IdentifierTree getName() {             return name;         }          @Override @DefinedBy(Api.COMPILER_TREE)         public ReferenceTree getType() {             return type;         }     }</td>
    <td align="left">data class</td>
    <td align="left">1. data class: dcserialfield class seems to be a data class as it holds only data and has minimal behavior</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14166</td>
    <td align="left">https://github.com/google/error-prone-javac/blob/a53d069bbdb2c60232ed3811c19b65e41c3e60e0/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/DCTree.java/#L732-L767</td>
    <td align="right">1</td>
    <td align="right">2337</td>
    <td align="right">14166</td>
  </tr>
  <tr valign="top">
    <td align="right">2059</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Header {     @SerializedName(&quot;typ&quot;)     public String type;     @SerializedName(&quot;alg&quot;)     public String algorithm;     @SerializedName(&quot;cty&quot;)     public String contentType; }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">12962</td>
    <td align="left">https://github.com/vmware/xenon/blob/b6fb48b745985af2efc59b7ee0e5e7d69a289fbc/xenon-common/src/main/java/com/vmware/xenon/common/jwt/Header.java/#L23-L30</td>
    <td align="right">1</td>
    <td align="right">2059</td>
    <td align="right">12962</td>
  </tr>
  <tr valign="top">
    <td align="right">2632</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;1. Blob&quot;, &quot;2. Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ReferenceProperty     implements Property {     EntityReference reference;      public ReferenceProperty()     {     }      public ReferenceProperty( EntityReference reference )     {         this.reference = reference;     }      @Override     public EntityReference get()     {         return reference;     }      @Override     public void set( EntityReference newValue )         throws IllegalArgumentException, IllegalStateException     {         reference = newValue;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15108</td>
    <td align="left">https://github.com/apache/attic-polygene-java/blob/031beef870302a0bd01bd5895ce849e00f2d5d5b/core/runtime/src/main/java/org/apache/polygene/runtime/value/ReferenceProperty.java/#L28-L54</td>
    <td align="right">1</td>
    <td align="right">2632</td>
    <td align="right">15108</td>
  </tr>
  <tr valign="top">
    <td align="right">1812</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Long Method&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Callout implements Comparable {   /** The callout number. */   private int callout = 0;   /** The area Element item that generated this callout. */   private Element area = null;   /** The line on which this callout occurs. */   private int line = 0;   /** The column in which this callout appears. */   private int col = 0;   /** The type of callout. */   private int type = 0;   /** The other type of callout. */   private String otherType = null;    public static final int CALS_PAIR = 1;   public static final int LINE_COLUMN = 2;   public static final int LINE_COLUMN_PAIR = 3;   public static final int LINE_RANGE = 4;   public static final int OTHER = 5;    /** The constructor; initialize the private data structures. */   public Callout(int callout, Element area, int line, int col, int type) {     this.callout = callout;     this.area = area;     this.line = line;     this.col = col;     this.type = type;     this.otherType = null;   }    /** The constructor; initialize the private data structures. */   public Callout(int callout, Element area, int line, int col, String otherType) {     this.callout = callout;     this.area = area;     this.line = line;     this.col = col;     this.type = Callout.OTHER;     this.otherType = otherType;   }    /**    * The compareTo method compares this Callout with another.    *    * Given two Callouts, A and B, A &lt; B if:    *    *     * A.line &lt; B.line, or    * A.line = B.line &amp;&amp; A.col &lt; B.col, or    * A.line = B.line &amp;&amp; A.col = B.col &amp;&amp; A.callout &lt; B.callout    * Otherwise, they're equal.    *     */   public int compareTo (Object o) {     Callout c = (Callout) o;      if (line == c.getLine()) {       if (col &gt; c.getColumn()) { 	return 1;       } else if (col &lt; c.getColumn()) { 	return -1;       } else { 	if (callout &lt; c.getCallout()) { 	  return -1; 	} else if (callout &gt; c.getCallout()) { 	  return 1; 	} else { 	  return 0; 	}       }     } else {       if (line &gt; c.getLine()) { 	return 1;       } else { 	return -1;       }     }   }    /** Access the Callout's area. */   public Element getArea() {     return area;   }    /** Access the Callout's line. */   public int getLine() {     return line;   }    /** Access the Callout's column. */   public int getColumn() {     return col;   }    /** Access the Callout's callout number. */   public int getCallout() {     return callout;   }    /** Access the Callout's type. */   public int getType() {     return type;   }    /** Access the Callout's otherType. */   public String getOtherType() {     return otherType;   }   }</td>
    <td align="left">data class</td>
    <td align="left">Long Method, Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12063</td>
    <td align="left">https://github.com/eclipse/org.aspectj/blob/370f291c359cd159c5f3f0abd6e9e53e81234a07/lib/docbook/docbook-xsl/extensions/xalan2/com/nwalsh/xalan/Callout.java/#L33-L142</td>
    <td align="right">1</td>
    <td align="right">1812</td>
    <td align="right">12063</td>
  </tr>
  <tr valign="top">
    <td align="right">2631</td>
    <td align="left">&nbsp;		{ 			&quot;message&quot;: &quot;YES I found bad smells&quot;, 			&quot;detected_smells&quot;: [ 				&quot;the bad smells are: 1. Data Class&quot; 			] 		}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class InstantiatedVersionedLabel extends VersionedLabel implements InstantiatedVersionedComponent {     private final String instanceId;     private final String groupId;      public InstantiatedVersionedLabel(final String instanceId, final String instanceGroupId) {         this.instanceId = instanceId;         this.groupId = instanceGroupId;     }      @Override     public String getInstanceId() {         return instanceId;     }      @Override     public String getInstanceGroupId() {         return groupId;     } }</td>
    <td align="left">data class</td>
    <td align="left">the bad smells are: 1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15100</td>
    <td align="left">https://github.com/apache/nifi/blob/c8eff590efa3babcda0b755009224dcac168708b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/registry/flow/mapping/InstantiatedVersionedLabel.java/#L22-L40</td>
    <td align="right">1</td>
    <td align="right">2631</td>
    <td align="right">15100</td>
  </tr>
  <tr valign="top">
    <td align="right">2589</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;&quot;, propOrder = {         &quot;setOrderAttributesResult&quot;,         &quot;responseMetadata&quot; }) @XmlRootElement(name = &quot;SetOrderAttributesResponse&quot;) public class SetOrderAttributesResponse {        @XmlElement(name = &quot;SetOrderAttributesResult&quot;, required = true)      protected SetOrderAttributesResult setOrderAttributesResult;     @XmlElement(name = &quot;ResponseMetadata&quot;, required = true)     protected ResponseMetadata responseMetadata;      public SetOrderAttributesResponse() {         super();     }      public SetOrderAttributesResult getSetOrderAttributesResult() {         return setOrderAttributesResult;     }     public ResponseMetadata getResponseMetadata() {         return responseMetadata;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14996</td>
    <td align="left">https://github.com/amzn/amazon-pay-sdk-java/blob/5a3547d00c796aab8f0c8ac12e0310f7a5c4678a/src/com/amazon/pay/response/model/SetOrderAttributesResponse.java/#L39-L65</td>
    <td align="right">1</td>
    <td align="right">2589</td>
    <td align="right">14996</td>
  </tr>
  <tr valign="top">
    <td align="right">2432</td>
    <td align="left">&nbsp;YES I found bad smells the bad smells are: 1. Data class 2. Long method 3. Setters and getters (they are not necessary in this case) 4. Lack of encapsulation (id and description are public) 5. Primitive obsession (using long and string instead of more specific types) 6. Tight coupling (the class is tied to the @XmlRootElement annotation and cannot easily be replaced)</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
@XmlRootElement(name = &quot;Product&quot;) public class Product {     private long id;     private String description;      public long getId() {         return id;     }      public void setId(long id) {         this.id = id;     }      public String getDescription() {         return description;     }      public void setDescription(String d) {         this.description = d;     } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Data class2 Long method3 Setters and getters (they are not necessary in this case)4 Lack of encapsulation (id and description are public)5 Primitive obsession (using long and string instead of more specific types)6 Tight coupling (the class is tied to the @XmlRootElement annotation and cannot easily be replaced)</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14460</td>
    <td align="left">https://github.com/apache/cxf/blob/6bf89e9c8804c8845ec4d38583dd33eea8256439/distribution/src/main/release/samples/jax_rs/spring_security/src/main/java/demo/jaxrs/service/Product.java/#L23-L43</td>
    <td align="right">2</td>
    <td align="right">2432</td>
    <td align="right">14460</td>
  </tr>
  <tr valign="top">
    <td align="right">1757</td>
    <td align="left">{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Table(name = &quot;clusters&quot;) @NamedQueries({     @NamedQuery(name = &quot;clusterByName&quot;, query =         &quot;SELECT cluster &quot; +             &quot;FROM ClusterEntity cluster &quot; +             &quot;WHERE cluster.clusterName=:clusterName&quot;),     @NamedQuery(name = &quot;allClusters&quot;, query =         &quot;SELECT clusters &quot; +             &quot;FROM ClusterEntity clusters&quot;),     @NamedQuery(name = &quot;clusterByResourceId&quot;, query =         &quot;SELECT cluster &quot; +             &quot;FROM ClusterEntity cluster &quot; +             &quot;WHERE cluster.resource.id=:resourceId&quot;) }) @Entity @TableGenerator(name = &quot;cluster_id_generator&quot;,     table = &quot;ambari_sequences&quot;, pkColumnName = &quot;sequence_name&quot;, valueColumnName = &quot;sequence_value&quot;     , pkColumnValue = &quot;cluster_id_seq&quot;     , initialValue = 1 ) public class ClusterEntity {    @Id   @Column(name = &quot;cluster_id&quot;, nullable = false, insertable = true, updatable = true)   @GeneratedValue(strategy = GenerationType.TABLE, generator = &quot;cluster_id_generator&quot;)   private Long clusterId;    @Basic   @Column(name = &quot;cluster_name&quot;, nullable = false, insertable = true,       updatable = true, unique = true, length = 100)   private String clusterName;    @Basic   @Enumerated(value = EnumType.STRING)   @Column(name = &quot;provisioning_state&quot;, insertable = true, updatable = true)   private State provisioningState = State.INIT;    @Basic   @Enumerated(value = EnumType.STRING)   @Column(name = &quot;security_type&quot;, nullable = false, insertable = true, updatable = true)   private SecurityType securityType = SecurityType.NONE;    @Basic   @Column(name = &quot;desired_cluster_state&quot;, insertable = true, updatable = true)   private String desiredClusterState = &quot;&quot;;    @Basic   @Column(name = &quot;cluster_info&quot;, insertable = true, updatable = true)   private String clusterInfo = &quot;&quot;;    /**    * Unidirectional one-to-one association to {@link StackEntity}    */   @OneToOne   @JoinColumn(name = &quot;desired_stack_id&quot;, unique = false, nullable = false, insertable = true, updatable = true)   private StackEntity desiredStack;    @OneToMany(mappedBy = &quot;clusterEntity&quot;)   private Collection clusterServiceEntities;    @OneToOne(mappedBy = &quot;clusterEntity&quot;, cascade = CascadeType.REMOVE)   private ClusterStateEntity clusterStateEntity;    @ManyToMany(mappedBy = &quot;clusterEntities&quot;)   private Collection hostEntities;    @OneToMany(mappedBy = &quot;clusterEntity&quot;, cascade = CascadeType.ALL)   private Collection configEntities;    @OneToMany(mappedBy = &quot;clusterEntity&quot;, cascade = CascadeType.ALL)   private Collection configGroupEntities;    @OneToMany(mappedBy = &quot;clusterEntity&quot;, cascade = CascadeType.ALL)   private Collection requestScheduleEntities;    @OneToMany(mappedBy = &quot;clusterEntity&quot;, cascade = CascadeType.REMOVE)   private Collection serviceConfigEntities;    @OneToMany(mappedBy = &quot;clusterEntity&quot;, cascade = CascadeType.REMOVE, fetch = FetchType.LAZY)   private Collection alertDefinitionEntities;    @OneToMany(mappedBy = &quot;clusterEntity&quot;, cascade = CascadeType.REMOVE, fetch = FetchType.LAZY)   private Collection widgetEntities;    @OneToMany(mappedBy = &quot;clusterEntity&quot;, cascade = CascadeType.REMOVE, fetch = FetchType.LAZY)   private Collection widgetLayoutEntities;    @OneToOne(cascade = CascadeType.ALL)   @JoinColumns({       @JoinColumn(name = &quot;resource_id&quot;, referencedColumnName = &quot;resource_id&quot;, nullable = false)   })   private ResourceEntity resource;    @Basic   @Column(name = &quot;upgrade_id&quot;, nullable = true, insertable = false, updatable = false)   private Long upgradeId;    /**    * {@code null} when there is no upgrade/downgrade in progress.    */   @OneToOne(cascade = CascadeType.REMOVE)   @JoinColumn(       name = &quot;upgrade_id&quot;,       referencedColumnName = &quot;upgrade_id&quot;,       nullable = true,       insertable = false,       updatable = true)   private UpgradeEntity upgradeEntity = null;    public Long getClusterId() {     return clusterId;   }    public void setClusterId(Long clusterId) {     this.clusterId = clusterId;   }    public String getClusterName() {     return clusterName;   }    public void setClusterName(String clusterName) {     this.clusterName = clusterName;   }    public String getDesiredClusterState() {     return defaultString(desiredClusterState);   }    public void setDesiredClusterState(String desiredClusterState) {     this.desiredClusterState = desiredClusterState;   }    public String getClusterInfo() {     return defaultString(clusterInfo);   }    public void setClusterInfo(String clusterInfo) {     this.clusterInfo = clusterInfo;   }    public StackEntity getDesiredStack() {     return desiredStack;   }    public void setDesiredStack(StackEntity desiredStack) {     this.desiredStack = desiredStack;   }    /**    * Gets whether the cluster is still initializing or has finished with its    * deployment requests.    *    * @return either {@link State#INIT} or {@link State#INSTALLED},    * never {@code null}.    */   public State getProvisioningState(){     return provisioningState;   }    /**    * Sets whether the cluster is still initializing or has finished with its    * deployment requests.    *    * @param provisioningState either {@link State#INIT} or    * {@link State#INSTALLED}, never {@code null}.    */   public void setProvisioningState(State provisioningState){     this.provisioningState = provisioningState;   }    /**    * Gets this ClusterEntity's security type.    *    * @return the current SecurityType    */   public SecurityType getSecurityType() {     return securityType;   }    /**    * Set's this ClusterEntity's security type    *    * @param securityType the new SecurityType    */   public void setSecurityType(SecurityType securityType) {     this.securityType = securityType;   }    @Override   public boolean equals(Object o) {     if (this == o) {       return true;     }     if (o == null || getClass() != o.getClass()) {       return false;     }      ClusterEntity that = (ClusterEntity) o;      if (!clusterId.equals(that.clusterId)) {       return false;     }     if (!clusterName.equals(that.clusterName)) {       return false;     }      return true;   }    @Override   public int hashCode() {     int result = null == clusterId ? 0 : clusterId.hashCode();     result = 31 * result + clusterName.hashCode();     return result;   }    public Collection getClusterServiceEntities() {     return clusterServiceEntities;   }    public void setClusterServiceEntities(Collection clusterServiceEntities) {     this.clusterServiceEntities = clusterServiceEntities;   }    public ClusterStateEntity getClusterStateEntity() {     return clusterStateEntity;   }    public void setClusterStateEntity(ClusterStateEntity clusterStateEntity) {     this.clusterStateEntity = clusterStateEntity;   }    public Collection getHostEntities() {     return hostEntities;   }    public void setHostEntities(Collection hostEntities) {     this.hostEntities = hostEntities;   }    public Collection getClusterConfigEntities() {     return configEntities;   }    public void setClusterConfigEntities(Collection entities) {     configEntities = entities;   }    public Collection getConfigGroupEntities() {     return configGroupEntities;   }    public void setConfigGroupEntities(Collection configGroupEntities) {     this.configGroupEntities = configGroupEntities;   }    public Collection getRequestScheduleEntities() {     return requestScheduleEntities;   }    public void setRequestScheduleEntities(Collection requestScheduleEntities) {     this.requestScheduleEntities = requestScheduleEntities;   }    public Collection getServiceConfigEntities() {     return serviceConfigEntities;   }    public void setServiceConfigEntities(Collection serviceConfigEntities) {     this.serviceConfigEntities = serviceConfigEntities;   }    public Collection getAlertDefinitionEntities() {     return alertDefinitionEntities;   }    /**    * Get the admin resource entity.    *    * @return the resource entity    */   public ResourceEntity getResource() {     return resource;   }    /**    * Set the admin resource entity.    *    * @param resource  the resource entity    */   public void setResource(ResourceEntity resource) {     this.resource = resource;   }    public UpgradeEntity getUpgradeEntity() {     return upgradeEntity;   }    public void setUpgradeEntity(UpgradeEntity upgradeEntity) {     this.upgradeEntity = upgradeEntity;   } }</td>
    <td align="left">data class</td>
    <td align="left">'Data Class'</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">{',D,a,t,a,&quot; &quot;,C,l,a,s,s,'}</td>
    <td align="left">{',D,a,a,&quot; &quot;,C,l,a,s,s,'}</td>
    <td align="right">0</td>
    <td align="right">11877</td>
    <td align="left">https://github.com/apache/ambari/blob/2bc4779a1e6aabe638101fc8b0e28cd1963d6b13/ambari-server/src/main/java/org/apache/ambari/server/orm/entities/ClusterEntity.java/#L48-L350</td>
    <td align="right">1</td>
    <td align="right">1757</td>
    <td align="right">11877</td>
  </tr>
  <tr valign="top">
    <td align="right">1291</td>
    <td align="left">&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DeploymentPlannersResponse extends BaseResponse {     @SerializedName(ApiConstants.NAME)     @Param(description = &quot;Deployment Planner name&quot;)     private String name;      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10618</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/api/src/main/java/org/apache/cloudstack/api/response/DeploymentPlannersResponse.java/#L26-L38</td>
    <td align="right">1</td>
    <td align="right">1291</td>
    <td align="right">10618</td>
  </tr>
  <tr valign="top">
    <td align="right">306</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public final static class Builder {          private Supplier initialValue;         private UnaryOperator splitOperator = null;         private BinaryOperator mergeOperator = null;          private Builder() {         }          public Builder initialValue(final Supplier initialValue) {             this.initialValue = initialValue;             return this;         }          public Builder splitOperator(final UnaryOperator splitOperator) {             this.splitOperator = splitOperator;             return this;         }          public Builder mergeOperator(final BinaryOperator mergeOperator) {             this.mergeOperator = mergeOperator;             return this;         }          public SackStrategy create() {             return new SackStrategy(this.initialValue, this.splitOperator, this.mergeOperator);         }     }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3195</td>
    <td align="left">https://github.com/apache/tinkerpop/blob/7d9df0f0acf08f9e675ca7b337fc5e0243c09b53/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/decoration/SackStrategy.java/#L58-L85</td>
    <td align="right">1</td>
    <td align="right">306</td>
    <td align="right">3195</td>
  </tr>
  <tr valign="top">
    <td align="right">1773</td>
    <td align="left">&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Ipam {   private String driver;   private List config;   private Map options;    public String getDriver() {     return driver;   }    public void setDriver(String driver) {     this.driver = driver;   }    public Ipam withDriver(String driver) {     this.driver = driver;     return this;   }    public List getConfig() {     return config;   }    public void setConfig(List config) {     this.config = config;   }    public Ipam withConfig(List config) {     this.config = config;     return this;   }    public Map getOptions() {     return options;   }    public void setOptions(Map options) {     this.options = options;   }    public Ipam withOptions(Map options) {     this.options = options;     return this;   }    @Override   public boolean equals(Object obj) {     if (this == obj) {       return true;     }     if (!(obj instanceof Ipam)) {       return false;     }     final Ipam that = (Ipam) obj;     return Objects.equals(driver, that.driver)         &amp;&amp; getConfig().equals(that.getConfig())         &amp;&amp; getOptions().equals(that.getOptions());   }    @Override   public int hashCode() {     int hash = 7;     hash = 31 * hash + Objects.hashCode(driver);     hash = 31 * hash + getConfig().hashCode();     hash = 31 * hash + getOptions().hashCode();     return hash;   }    @Override   public String toString() {     return &quot;Ipam{&quot;         + &quot;driver='&quot;         + driver         + '\''         + &quot;, config=&quot;         + config         + &quot;, options=&quot;         + options         + '}';   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11931</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/infrastructures/docker/docker-client/src/main/java/org/eclipse/che/infrastructure/docker/client/json/network/Ipam.java/#L19-L98</td>
    <td align="right">1</td>
    <td align="right">1773</td>
    <td align="right">11931</td>
  </tr>
  <tr valign="top">
    <td align="right">116</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	private static class BeanRegistration {  		private final Class annotatedClass;  		@Nullable 		private final Supplier supplier;  		private final Class[] qualifiers;  		public BeanRegistration( 				Class annotatedClass, @Nullable Supplier supplier, Class[] qualifiers) { 			this.annotatedClass = annotatedClass; 			this.supplier = supplier; 			this.qualifiers = qualifiers; 		}  		public Class getAnnotatedClass() { 			return this.annotatedClass; 		}  		@Nullable 		@SuppressWarnings(&quot;rawtypes&quot;) 		public Supplier getSupplier() { 			return this.supplier; 		}  		public Class[] getQualifiers() { 			return this.qualifiers; 		}  		@Override 		public String toString() { 			return this.annotatedClass.getName(); 		} 	}</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1503</td>
    <td align="left">https://github.com/spring-projects/spring-framework/blob/3a0f309e2c9fdbbf7fb2d348be861528177f8555/spring-web/src/main/java/org/springframework/web/context/support/AnnotationConfigWebApplicationContext.java/#L342-L376</td>
    <td align="right">1</td>
    <td align="right">116</td>
    <td align="right">1503</td>
  </tr>
  <tr valign="top">
    <td align="right">2291</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  protected static final class PersistenceWithIntOffset extends PersistenceWithIntOffsetNoLL {     /**      * Used by DiskRegion for compaction      *      * @since GemFire prPersistSprint1      */     private DiskEntry prev;     /**      * Used by DiskRegion for compaction      *      * @since GemFire prPersistSprint1      */     private DiskEntry next;      @Override     public DiskEntry getPrev() {       return this.prev;     }      @Override     public DiskEntry getNext() {       return this.next;     }      @Override     public void setPrev(DiskEntry v) {       this.prev = v;     }      @Override     public void setNext(DiskEntry v) {       this.next = v;     }   }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13942</td>
    <td align="left">https://github.com/apache/geode/blob/8fd839e8b73e40bd2dfd14f331b587431bd35a66/geode-core/src/main/java/org/apache/geode/internal/cache/DiskId.java/#L531-L564</td>
    <td align="right">1</td>
    <td align="right">2291</td>
    <td align="right">13942</td>
  </tr>
  <tr valign="top">
    <td align="right">5025</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES, I found bad smells&quot;,     &quot;the bad smells are&quot;: [       &quot;Long Method&quot;,       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Socket {      /* Standard socket defines */     public static final int SOCK_STREAM = 0;     public static final int SOCK_DGRAM  = 1;     /*      * apr_sockopt Socket option definitions      */     public static final int APR_SO_LINGER       = 1;    /** Linger */     public static final int APR_SO_KEEPALIVE    = 2;    /** Keepalive */     public static final int APR_SO_DEBUG        = 4;    /** Debug */     public static final int APR_SO_NONBLOCK     = 8;    /** Non-blocking IO */     public static final int APR_SO_REUSEADDR    = 16;   /** Reuse addresses */     public static final int APR_SO_SNDBUF       = 64;   /** Send buffer */     public static final int APR_SO_RCVBUF       = 128;  /** Receive buffer */     public static final int APR_SO_DISCONNECTED = 256;  /** Disconnected */     /** For SCTP sockets, this is mapped to STCP_NODELAY internally. */     public static final int APR_TCP_NODELAY     = 512;     public static final int APR_TCP_NOPUSH      = 1024; /** No push */     /** This flag is ONLY set internally when we set APR_TCP_NOPUSH with      * APR_TCP_NODELAY set to tell us that APR_TCP_NODELAY should be turned on      * again when NOPUSH is turned off      */     public static final int APR_RESET_NODELAY   = 2048;     /** Set on non-blocking sockets (timeout != 0) on which the      * previous read() did not fill a buffer completely.  the next      * apr_socket_recv()  will first call select()/poll() rather than      * going straight into read().  (Can also be set by an application to      * force a select()/poll() call before the next read, in cases where      * the app expects that an immediate read would fail.)      */     public static final int APR_INCOMPLETE_READ = 4096;     /** like APR_INCOMPLETE_READ, but for write      */     public static final int APR_INCOMPLETE_WRITE = 8192;     /** Don't accept IPv4 connections on an IPv6 listening socket.      */     public static final int APR_IPV6_V6ONLY      = 16384;     /** Delay accepting of new connections until data is available.      */     public static final int APR_TCP_DEFER_ACCEPT = 32768;      /** Define what type of socket shutdown should occur.      * apr_shutdown_how_e enum      */     public static final int APR_SHUTDOWN_READ      = 0; /** no longer allow read request */     public static final int APR_SHUTDOWN_WRITE     = 1; /** no longer allow write requests */     public static final int APR_SHUTDOWN_READWRITE = 2; /** no longer allow read or write requests */      public static final int APR_IPV4_ADDR_OK = 0x01;     public static final int APR_IPV6_ADDR_OK = 0x02;      public static final int APR_UNSPEC = 0;     public static final int APR_INET   = 1;     public static final int APR_INET6  = 2;      public static final int APR_PROTO_TCP  =   6; /** TCP  */     public static final int APR_PROTO_UDP  =  17; /** UDP  */     public static final int APR_PROTO_SCTP = 132; /** SCTP */      /**      * Enum to tell us if we're interested in remote or local socket      * apr_interface_e      */     public static final int APR_LOCAL  = 0;     public static final int APR_REMOTE = 1;      /* Socket.get types */     public static final int SOCKET_GET_POOL = 0;     public static final int SOCKET_GET_IMPL = 1;     public static final int SOCKET_GET_APRS = 2;     public static final int SOCKET_GET_TYPE = 3;      /**      * Create a socket.      * @param family The address family of the socket (e.g., APR_INET).      * @param type The type of the socket (e.g., SOCK_STREAM).      * @param protocol The protocol of the socket (e.g., APR_PROTO_TCP).      * @param cont The parent pool to use      * @return The new socket that has been set up.      * @throws Exception Error creating socket      */     public static native long create(int family, int type,                                      int protocol, long cont)         throws Exception;       /**      * Shutdown either reading, writing, or both sides of a socket.      *       * This does not actually close the socket descriptor, it just      *      controls which calls are still valid on the socket.      * @param thesocket The socket to close      * @param how How to shutdown the socket.  One of:      *       * APR_SHUTDOWN_READ         no longer allow read requests      * APR_SHUTDOWN_WRITE        no longer allow write requests      * APR_SHUTDOWN_READWRITE    no longer allow read or write requests      *       * @return the operation status      */     public static native int shutdown(long thesocket, int how);      /**      * Close a socket.      * @param thesocket The socket to close      * @return the operation status      */     public static native int close(long thesocket);      /**      * Destroy a pool associated with socket      * @param thesocket The destroy      */     public static native void destroy(long thesocket);      /**      * Bind the socket to its associated port      * @param sock The socket to bind      * @param sa The socket address to bind to      * This may be where we will find out if there is any other process      *      using the selected port.      * @return the operation status      */     public static native int bind(long sock, long sa);      /**      * Listen to a bound socket for connections.      * @param sock The socket to listen on      * @param backlog The number of outstanding connections allowed in the sockets      *                listen queue.  If this value is less than zero, the listen      *                queue size is set to zero.      * @return the operation status      */     public static native int listen(long sock, int backlog);      /**      * Accept a new connection request      * @param sock The socket we are listening on.      * @param pool The pool for the new socket.      * @return  A copy of the socket that is connected to the socket that      *          made the connection request.  This is the socket which should      *          be used for all future communication.      * @throws Exception Socket accept error      */     public static native long acceptx(long sock, long pool)         throws Exception;      /**      * Accept a new connection request      * @param sock The socket we are listening on.      * @return  A copy of the socket that is connected to the socket that      *          made the connection request.  This is the socket which should      *          be used for all future communication.      * @throws Exception Socket accept error      */     public static native long accept(long sock)         throws Exception;      /**      * Set an OS level accept filter.      * @param sock The socket to put the accept filter on.      * @param name The accept filter      * @param args Any extra args to the accept filter.  Passing NULL here removes      *             the accept filter.      * @return the operation status      */     public static native int acceptfilter(long sock, String name, String args);      /**      * Query the specified socket if at the OOB/Urgent data mark      * @param sock The socket to query      * @return true if socket is at the OOB/urgent mark,      *         otherwise false.      */     public static native boolean atmark(long sock);      /**      * Issue a connection request to a socket either on the same machine      * or a different one.      * @param sock The socket we wish to use for our side of the connection      * @param sa The address of the machine we wish to connect to.      * @return the operation status      */     public static native int connect(long sock, long sa);      /**      * Send data over a network.      *       * This functions acts like a blocking write by default.  To change      * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK      * socket option.      *      * It is possible for both bytes to be sent and an error to be returned.      *      * APR_EINTR is never returned.      *       * @param sock The socket to send the data over.      * @param buf The buffer which contains the data to be sent.      * @param offset Offset in the byte buffer.      * @param len The number of bytes to write; (-1) for full array.      * @return The number of bytes sent      */     public static native int send(long sock, byte[] buf, int offset, int len);      /**      * Send data over a network.      *       * This functions acts like a blocking write by default.  To change      * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK      * socket option.      *      * It is possible for both bytes to be sent and an error to be returned.      *      * APR_EINTR is never returned.      *       * @param sock The socket to send the data over.      * @param buf The Byte buffer which contains the data to be sent.      * @param offset The offset within the buffer array of the first buffer from      *               which bytes are to be retrieved; must be non-negative      *               and no larger than buf.length      * @param len The maximum number of buffers to be accessed; must be non-negative      *            and no larger than buf.length - offset      * @return The number of bytes sent      */     public static native int sendb(long sock, ByteBuffer buf,                                    int offset, int len);      /**      * Send data over a network without retry      *       * This functions acts like a blocking write by default.  To change      * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK      * socket option.      *      * It is possible for both bytes to be sent and an error to be returned.      *      *       * @param sock The socket to send the data over.      * @param buf The Byte buffer which contains the data to be sent.      * @param offset The offset within the buffer array of the first buffer from      *               which bytes are to be retrieved; must be non-negative      *               and no larger than buf.length      * @param len The maximum number of buffers to be accessed; must be non-negative      *            and no larger than buf.length - offset      * @return The number of bytes sent      */     public static native int sendib(long sock, ByteBuffer buf,                                     int offset, int len);      /**      * Send data over a network using internally set ByteBuffer      * @param sock The socket to send the data over.      * @param offset The offset within the buffer array of the first buffer from      *               which bytes are to be retrieved; must be non-negative      *               and no larger than buf.length      * @param len The maximum number of buffers to be accessed; must be non-negative      *            and no larger than buf.length - offset      * @return The number of bytes sent      */     public static native int sendbb(long sock,                                    int offset, int len);      /**      * Send data over a network using internally set ByteBuffer      * without internal retry.      * @param sock The socket to send the data over.      * @param offset The offset within the buffer array of the first buffer from      *               which bytes are to be retrieved; must be non-negative      *               and no larger than buf.length      * @param len The maximum number of buffers to be accessed; must be non-negative      *            and no larger than buf.length - offset      * @return The number of bytes sent      */     public static native int sendibb(long sock,                                      int offset, int len);      /**      * Send multiple packets of data over a network.      *       * This functions acts like a blocking write by default.  To change      * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK      * socket option.      * The number of bytes actually sent is stored in argument 3.      *      * It is possible for both bytes to be sent and an error to be returned.      *      * APR_EINTR is never returned.      *       * @param sock The socket to send the data over.      * @param vec The array from which to get the data to send.      * @return The number of bytes sent      */     public static native int sendv(long sock, byte[][] vec);      /**      * @param sock The socket to send from      * @param where The apr_sockaddr_t describing where to send the data      * @param flags The flags to use      * @param buf  The data to send      * @param offset Offset in the byte buffer.      * @param len  The length of the data to send      * @return The number of bytes sent      */     public static native int sendto(long sock, long where, int flags,                                     byte[] buf, int offset, int len);      /**      * Read data from a network.      *      *       * This functions acts like a blocking read by default.  To change      * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK      * socket option.      * The number of bytes actually received is stored in argument 3.      *      * It is possible for both bytes to be received and an APR_EOF or      * other error to be returned.      *      * APR_EINTR is never returned.      *       * @param sock The socket to read the data from.      * @param buf The buffer to store the data in.      * @param offset Offset in the byte buffer.      * @param nbytes The number of bytes to read (-1) for full array.      * @return the number of bytes received.      */     public static native int recv(long sock, byte[] buf, int offset, int nbytes);      /**      * Read data from a network with timeout.      *      *       * This functions acts like a blocking read by default.  To change      * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK      * socket option.      * The number of bytes actually received is stored in argument 3.      *      * It is possible for both bytes to be received and an APR_EOF or      * other error to be returned.      *      * APR_EINTR is never returned.      *       * @param sock The socket to read the data from.      * @param buf The buffer to store the data in.      * @param offset Offset in the byte buffer.      * @param nbytes The number of bytes to read (-1) for full array.      * @param timeout The socket timeout in microseconds.      * @return the number of bytes received.      */     public static native int recvt(long sock, byte[] buf, int offset,                                    int nbytes, long timeout);      /**      * Read data from a network.      *      *       * This functions acts like a blocking read by default.  To change      * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK      * socket option.      * The number of bytes actually received is stored in argument 3.      *      * It is possible for both bytes to be received and an APR_EOF or      * other error to be returned.      *      * APR_EINTR is never returned.      *       * @param sock The socket to read the data from.      * @param buf The buffer to store the data in.      * @param offset Offset in the byte buffer.      * @param nbytes The number of bytes to read (-1) for full array.      * @return If ≥ 0, the return value is the number of bytes read. Note a      *         non-blocking read with no data current available will return      *         {@link Status#EAGAIN} and EOF will return {@link Status#APR_EOF}.      */     public static native int recvb(long sock, ByteBuffer buf,                                    int offset, int nbytes);      /**      * Read data from a network using internally set ByteBuffer.      *      * @param sock The socket to read the data from.      * @param offset Offset in the byte buffer.      * @param nbytes The number of bytes to read (-1) for full array.      * @return If &gt; 0, the return value is the number of bytes read. If == 0,      *         the return value indicates EOF and if &lt; 0 the return value is the      *         error code. Note a non-blocking read with no data current      *         available will return {@link Status#EAGAIN} not zero.      */     public static native int recvbb(long sock,                                     int offset, int nbytes);     /**      * Read data from a network with timeout.      *      *       * This functions acts like a blocking read by default.  To change      * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK      * socket option.      * The number of bytes actually received is stored in argument 3.      *      * It is possible for both bytes to be received and an APR_EOF or      * other error to be returned.      *      * APR_EINTR is never returned.      *       * @param sock The socket to read the data from.      * @param buf The buffer to store the data in.      * @param offset Offset in the byte buffer.      * @param nbytes The number of bytes to read (-1) for full array.      * @param timeout The socket timeout in microseconds.      * @return the number of bytes received.      */     public static native int recvbt(long sock, ByteBuffer buf,                                     int offset, int nbytes, long timeout);     /**      * Read data from a network with timeout using internally set ByteBuffer      * @param sock The socket to read the data from.      * @param offset Offset in the byte buffer.      * @param nbytes The number of bytes to read (-1) for full array.      * @param timeout The socket timeout in microseconds.      * @return the number of bytes received.      */     public static native int recvbbt(long sock,                                      int offset, int nbytes, long timeout);      /**      * @param from The apr_sockaddr_t to fill in the recipient info      * @param sock The socket to use      * @param flags The flags to use      * @param buf  The buffer to use      * @param offset Offset in the byte buffer.      * @param nbytes The number of bytes to read (-1) for full array.      * @return the number of bytes received.      */     public static native int recvfrom(long from, long sock, int flags,                                       byte[] buf, int offset, int nbytes);      /**      * Setup socket options for the specified socket      * @param sock The socket to set up.      * @param opt The option we would like to configure.  One of:      *       * APR_SO_DEBUG      --  turn on debugging information      * APR_SO_KEEPALIVE  --  keep connections active      * APR_SO_LINGER     --  lingers on close if data is present      * APR_SO_NONBLOCK   --  Turns blocking on/off for socket      *                       When this option is enabled, use      *                       the APR_STATUS_IS_EAGAIN() macro to      *                       see if a send or receive function      *                       could not transfer data without      *                       blocking.      * APR_SO_REUSEADDR  --  The rules used in validating addresses      *                       supplied to bind should allow reuse      *                       of local addresses.      * APR_SO_SNDBUF     --  Set the SendBufferSize      * APR_SO_RCVBUF     --  Set the ReceiveBufferSize      *       * @param on Value for the option.      * @return the operation status      */     public static native int optSet(long sock, int opt, int on);      /**      * Query socket options for the specified socket      * @param sock The socket to query      * @param opt The option we would like to query.  One of:      *       * APR_SO_DEBUG      --  turn on debugging information      * APR_SO_KEEPALIVE  --  keep connections active      * APR_SO_LINGER     --  lingers on close if data is present      * APR_SO_NONBLOCK   --  Turns blocking on/off for socket      * APR_SO_REUSEADDR  --  The rules used in validating addresses      *                       supplied to bind should allow reuse      *                       of local addresses.      * APR_SO_SNDBUF     --  Set the SendBufferSize      * APR_SO_RCVBUF     --  Set the ReceiveBufferSize      * APR_SO_DISCONNECTED -- Query the disconnected state of the socket.      *                       (Currently only used on Windows)      *       * @return Socket option returned on the call.      * @throws Exception An error occurred      */     public static native int optGet(long sock, int opt)         throws Exception;      /**      * Setup socket timeout for the specified socket      * @param sock The socket to set up.      * @param t Value for the timeout in microseconds.      *       * t &gt; 0  -- read and write calls return APR_TIMEUP if specified time      *           elapses with no data read or written      * t == 0 -- read and write calls never block      * t &lt; 0  -- read and write calls block      *       * @return the operation status      */     public static native int timeoutSet(long sock, long t);      /**      * Query socket timeout for the specified socket      * @param sock The socket to query      * @return Socket timeout returned from the query.      * @throws Exception An error occurred      */     public static native long timeoutGet(long sock)         throws Exception;      /**      * Send a file from an open file descriptor to a socket, along with      * optional headers and trailers.      *       * This functions acts like a blocking write by default.  To change      *         this behavior, use apr_socket_timeout_set() or the      *         APR_SO_NONBLOCK socket option.      * The number of bytes actually sent is stored in the len parameter.      * The offset parameter is passed by reference for no reason; its      * value will never be modified by the apr_socket_sendfile() function.      * @param sock The socket to which we're writing      * @param file The open file from which to read      * @param headers Array containing the headers to send      * @param trailers Array containing the trailers to send      * @param offset Offset into the file where we should begin writing      * @param len Number of bytes to send from the file      * @param flags APR flags that are mapped to OS specific flags      * @return Number of bytes actually sent, including headers,      *         file, and trailers      */     public static native long sendfile(long sock, long file, byte [][] headers,                                        byte[][] trailers, long offset,                                        long len, int flags);      /**      * Send a file without header and trailer arrays.      * @param sock The socket to which we're writing      * @param file The open file from which to read      * @param offset Offset into the file where we should begin writing      * @param len Number of bytes to send from the file      * @param flags APR flags that are mapped to OS specific flags      * @return Number of bytes actually sent      */     public static native long sendfilen(long sock, long file, long offset,                                         long len, int flags);      /**      * Create a child pool from associated socket pool.      * @param thesocket The socket to use      * @return a pointer to the pool      * @throws Exception An error occurred      */     public static native long pool(long thesocket)         throws Exception;      /**      * Private method for getting the socket struct members      * @param socket The socket to use      * @param what Struct member to obtain      *       * SOCKET_GET_POOL  - The socket pool      * SOCKET_GET_IMPL  - The socket implementation object      * SOCKET_GET_APRS  - APR socket      * SOCKET_GET_TYPE  - Socket type      *       * @return The structure member address      */     private static native long get(long socket, int what);      /**      * Set internal send ByteBuffer.      * This function will preset internal Java ByteBuffer for      * consecutive sendbb calls.      * @param sock The socket to use      * @param buf The ByteBuffer      */     public static native void setsbb(long sock, ByteBuffer buf);      /**      * Set internal receive ByteBuffer.      * This function will preset internal Java ByteBuffer for      * consecutive revcvbb/recvbbt calls.      * @param sock The socket to use      * @param buf The ByteBuffer      */     public static native void setrbb(long sock, ByteBuffer buf);      /**      * Set the data associated with the current socket.      * @param sock The currently open socket.      * @param data The user data to associate with the socket.      * @param key The key to associate with the data.      * @return the operation status      */       public static native int dataSet(long sock, String key, Object data);      /**      * Return the data associated with the current socket      * @param sock The currently open socket.      * @param key The key to associate with the user data.      * @return Data or null in case of error.      */      public static native Object dataGet(long sock, String key);  }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13928</td>
    <td align="left">https://github.com/apache/tomcat/blob/a9c1a0661198d9ba37c1facd8385fe05d538c4ad/java/org/apache/tomcat/jni/Socket.java/#L27-L629</td>
    <td align="right">1</td>
    <td align="right">5025</td>
    <td align="right">13928</td>
  </tr>
  <tr valign="top">
    <td align="right">1854</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Long Method&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class RSLSettings {     /**      * A RSL URL and a policy file URL.      */     public static class RSLAndPolicyFileURLPair     {         /**          * Create a new RSL URL and Policy File URL pair.          *           * @param rslURL THe URL of the runtime shared library.          * @param policyFileURL The URL of the policy file.          */         public RSLAndPolicyFileURLPair(String rslURL, String policyFileURL)         {             this.rslURL = rslURL;             this.policyFileURL = policyFileURL;         }          private String rslURL;         private String policyFileURL;                  /**          * @return the url of the RSL to load.          */         public String getRSLURL()         {             return rslURL;         }          /**          * @return the url of the policy file.          */         public String getPolicyFileURL()         {             return policyFileURL;         }     }      /**      * The extension given to a signed RLS that is assumed to be signed.      * Unsigned RSLs should use the standard &quot;swf&quot; extension.      */     private static final String SIGNED_RSL_URL_EXTENSION = &quot;swz&quot;;     private static final String SIGNED_RSL_URL_DOT_EXTENSION = &quot;.&quot; + SIGNED_RSL_URL_EXTENSION;          /**      * Test if the url is a signed RSL. Signed RSL have a .swz extension.      *       * @param url url to test, the file specified by the url does not       *            need to exist.      * @return true if the url specifies a signed rsl, false otherwise.      */     public static boolean isSignedRSL(String url)     {         if (url == null)             return false;                  return url.endsWith(SIGNED_RSL_URL_DOT_EXTENSION);     }      /**      * Create RSLSettings with:      *  - a default {@link ApplicationDomainTarget}      *  - verify digest set to true       *        *  @param libraryFile the library whose classes will be removed      *  from the application. May not be null.      *  @throws NullPointerException if libraryFile is null.      */     RSLSettings(IFileSpecification libraryFile)     {         if (libraryFile == null)             throw new NullPointerException(&quot;libraryFile may not be null&quot;);                  this.libraryFile = new File(libraryFile.getPath());         rslURLs = new ArrayList();         setApplicationDomain(ApplicationDomainTarget.DEFAULT);         setVerifyDigest(true);     }      /**      * Create RSLSettings with:      *  - a default {@link ApplicationDomainTarget}      *  - verify digest set to true       *        *  @param libraryFile the library whose classes will be removed      *  from the application. May not be null.      *  @throws NullPointerException if libraryFile is null.      */     public RSLSettings(File libraryFile)     {         if (libraryFile == null)             throw new NullPointerException(&quot;libraryFile may not be null&quot;);                  this.libraryFile = libraryFile;         rslURLs = new ArrayList();         setApplicationDomain(ApplicationDomainTarget.DEFAULT);         setVerifyDigest(true);     }      private File libraryFile;   // the library whose definitions are externed     private List rslURLs; // list of rsls and failovers     private ApplicationDomainTarget applicationDomain;       private boolean verifyDigest;   // if true the digest will be verified at runtime     private boolean forceLoad;      // true if the RSL should be forced to load regardless of its use          /**      * @return true if the RSL should be force loaded, false otherwise.      */     public boolean isForceLoad()     {         return forceLoad;     }      /**      * Sets a flag on the RSL so the compiler is not allowed to remove it when      * the &quot;remove unused RSLs&quot; feature is on.       *       * @param forceLoad true to force the RSL to be loaded at runtime, false otherwise.      */     public void setForceLoad(boolean forceLoad)     {         this.forceLoad = forceLoad;     }      /**      * @return a List of {@link RSLAndPolicyFileURLPair}      */     public List getRSLURLs()     {         return rslURLs;     }      /**      * Add a new RSL URL and Policy file URL. This first pair is the primary      * RSL and the following RSLs are failover RSLs.      *       * @param rslURL A String representing the URL to load the RSL from. May      * not be null.       * @param policyFileURL A String representing the URL to load a policy file      * from. This is optional and may be null to indicate there is no policy       * file.      * @throws NullPointerException if rslURL is null.      */     public void addRSLURLAndPolicyFileURL(String rslURL, String policyFileURL)     {        if (rslURL == null)            throw new NullPointerException(&quot;rslURL may not be null&quot;);                rslURLs.add(new RSLAndPolicyFileURLPair(rslURL, policyFileURL));      }          /**      * @return the libraryFile      */     public File getLibraryFile()     {         return libraryFile;     }      /**      * @param applicationDomain the new value of the applicationDomain.      */     public void setApplicationDomain(ApplicationDomainTarget applicationDomain)     {         this.applicationDomain = applicationDomain;     }      /**      * One of {@link ApplicationDomainTarget} that control which domain an RSL      * is loaded into.      *       * @return the applicationDomain      */     public ApplicationDomainTarget getApplicationDomain()     {         return applicationDomain;     }      /**      * Change the value of the verify digests flag.      *       * @param verifyDigest The new value of the verify digests flag.      */     public void setVerifyDigest(boolean verifyDigest)     {         this.verifyDigest = verifyDigest;     }      /**      * @return if true, the RSL's digest must be verified at runtime.      */     public boolean getVerifyDigest()     {         return verifyDigest;     }           }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12206</td>
    <td align="left">https://github.com/apache/royale-compiler/blob/fbd9bc3b9e48c80dbd8c1d32a6f83221e314efdd/compiler-common/src/main/java/org/apache/royale/compiler/config/RSLSettings.java/#L34-L233</td>
    <td align="right">1</td>
    <td align="right">1854</td>
    <td align="right">12206</td>
  </tr>
  <tr valign="top">
    <td align="right">1292</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES, I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;,             &quot;Blob&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    class ColumnFamilyRegionInfo {         private RegionInfo regionInfo;         private Set familySet;          public ColumnFamilyRegionInfo(RegionInfo regionInfo, Set familySet) {             this.regionInfo = regionInfo;             this.familySet = familySet;         }          public RegionInfo getRegionInfo() {             return regionInfo;         }          public Set getFamilySet() {             return familySet;         }          @Override         public boolean equals(Object obj) {             if (obj == this) { return true; }             if (!(obj instanceof ColumnFamilyRegionInfo)) { return false; }              ColumnFamilyRegionInfo c = (ColumnFamilyRegionInfo)obj;             return c.getRegionInfo().equals(this.regionInfo) &amp;&amp; ByteUtil.match(this.familySet, c.getFamilySet());         }          @Override         public int hashCode() {             return this.getRegionInfo().hashCode();         }     }</td>
    <td align="left">data class</td>
    <td align="left">data class, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10621</td>
    <td align="left">https://github.com/apache/phoenix/blob/69e5bb0b304a53967cef40b2a4cfc66e69ecaa51/phoenix-core/src/main/java/org/apache/phoenix/schema/stats/StatisticsCollectionRunTracker.java/#L129-L159</td>
    <td align="right">1</td>
    <td align="right">1292</td>
    <td align="right">10621</td>
  </tr>
  <tr valign="top">
    <td align="right">1174</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LaunchRequest { 	private String jobName;  	String jobParameters;  	public String getJobName() { 		return jobName; 	}  	public void setJobName(String jobName) { 		this.jobName = jobName; 	}  	public String getJobParameters() { 		return jobParameters; 	}  	public void setJobParameters(String jobParameters) { 		this.jobParameters = jobParameters; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10210</td>
    <td align="left">https://github.com/spring-projects/spring-batch-admin/blob/9e3ad8bff99b8fad8da62426aa7d2959eb841bcf/spring-batch-admin-manager/src/main/java/org/springframework/batch/admin/web/LaunchRequest.java/#L21-L42</td>
    <td align="right">1</td>
    <td align="right">1174</td>
    <td align="right">10210</td>
  </tr>
  <tr valign="top">
    <td align="right">1730</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{       &quot;output&quot;: &quot;YES I found bad smells&quot;,       &quot;bad smells are&quot;: [          &quot;Long Method&quot;,          &quot;Data Class&quot;       ]    }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class AbstractDeadLetterStrategy implements DeadLetterStrategy {     private static final Logger LOG = LoggerFactory.getLogger(AbstractDeadLetterStrategy.class);     private boolean processNonPersistent = false;     private boolean processExpired = true;     private boolean enableAudit = true;     private final ActiveMQMessageAudit messageAudit = new ActiveMQMessageAudit();     private long expiration;      @Override     public void rollback(Message message) {         if (message != null &amp;&amp; this.enableAudit) {             messageAudit.rollback(message);         }     }      @Override     public boolean isSendToDeadLetterQueue(Message message) {         boolean result = false;         if (message != null) {             result = true;             if (enableAudit &amp;&amp; messageAudit.isDuplicate(message)) {                 result = false;                 LOG.debug(&quot;Not adding duplicate to DLQ: {}, dest: {}&quot;, message.getMessageId(), message.getDestination());             }             if (!message.isPersistent() &amp;&amp; !processNonPersistent) {                 result = false;             }             if (message.isExpired() &amp;&amp; !processExpired) {                 result = false;             }         }         return result;     }      /**      * @return the processExpired      */     @Override     public boolean isProcessExpired() {         return this.processExpired;     }      /**      * @param processExpired the processExpired to set      */     @Override     public void setProcessExpired(boolean processExpired) {         this.processExpired = processExpired;     }      /**      * @return the processNonPersistent      */     @Override     public boolean isProcessNonPersistent() {         return this.processNonPersistent;     }      /**      * @param processNonPersistent the processNonPersistent to set      */     @Override     public void setProcessNonPersistent(boolean processNonPersistent) {         this.processNonPersistent = processNonPersistent;     }      public boolean isEnableAudit() {         return enableAudit;     }      public void setEnableAudit(boolean enableAudit) {         this.enableAudit = enableAudit;     }      public long getExpiration() {         return expiration;     }      public void setExpiration(long expiration) {         this.expiration = expiration;     }      public int getMaxProducersToAudit() {         return messageAudit.getMaximumNumberOfProducersToTrack();     }      public void setMaxProducersToAudit(int maxProducersToAudit) {         messageAudit.setMaximumNumberOfProducersToTrack(maxProducersToAudit);     }      public void setMaxAuditDepth(int maxAuditDepth) {         messageAudit.setAuditDepth(maxAuditDepth);     }      public int getMaxAuditDepth() {         return messageAudit.getAuditDepth();     }  }</td>
    <td align="left">data class</td>
    <td align="left">Long Method, Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11819</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-broker/src/main/java/org/apache/activemq/broker/region/policy/AbstractDeadLetterStrategy.java/#L29-L127</td>
    <td align="right">1</td>
    <td align="right">1730</td>
    <td align="right">11819</td>
  </tr>
  <tr valign="top">
    <td align="right">571</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;response&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class DirContextType {     private String name;      private DirContextType(String name) {         this.name = name;     }      public String toString() {         return name;     }          /**      * The type of {@link DirContext} returned by {@link ContextSource#getReadOnlyContext()}      */     public static final DirContextType READ_ONLY = new DirContextType(&quot;READ_ONLY&quot;);          /**      * The type of {@link DirContext} returned by {@link ContextSource#getReadWriteContext()}      */     public static final DirContextType READ_WRITE = new DirContextType(&quot;READ_WRITE&quot;); }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5739</td>
    <td align="left">https://github.com/spring-projects/spring-ldap/blob/6a9bde34811b87b5425c05068a31ff61d7e59170/core/src/main/java/org/springframework/ldap/pool2/DirContextType.java/#L30-L50</td>
    <td align="right">1</td>
    <td align="right">571</td>
    <td align="right">5739</td>
  </tr>
  <tr valign="top">
    <td align="right">2227</td>
    <td align="left">&nbsp;{&quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private class ClientSelectDeleteMutationPlan implements MutationPlan {         private final StatementContext context;         private final TableRef targetTableRef;         private final QueryPlan dataPlan;         private final QueryPlan bestPlan;         private final boolean hasPreOrPostProcessing;         private final DeletingParallelIteratorFactory parallelIteratorFactory;         private final List otherTableRefs;         private final TableRef projectedTableRef;         private final int maxSize;         private final int maxSizeBytes;         private final PhoenixConnection connection;          public ClientSelectDeleteMutationPlan(TableRef targetTableRef, QueryPlan dataPlan, QueryPlan bestPlan,                                               boolean hasPreOrPostProcessing,                                               DeletingParallelIteratorFactory parallelIteratorFactory,                                               List otherTableRefs, TableRef projectedTableRef, int maxSize,                                               int maxSizeBytes, PhoenixConnection connection) {             this.context = bestPlan.getContext();             this.targetTableRef = targetTableRef;             this.dataPlan = dataPlan;             this.bestPlan = bestPlan;             this.hasPreOrPostProcessing = hasPreOrPostProcessing;             this.parallelIteratorFactory = parallelIteratorFactory;             this.otherTableRefs = otherTableRefs;             this.projectedTableRef = projectedTableRef;             this.maxSize = maxSize;             this.maxSizeBytes = maxSizeBytes;             this.connection = connection;         }          @Override         public ParameterMetaData getParameterMetaData() {             return context.getBindManager().getParameterMetaData();         }          @Override         public StatementContext getContext() {             return context;         }          @Override         public TableRef getTargetRef() {             return targetTableRef;         }          @Override         public Set getSourceRefs() {             return dataPlan.getSourceRefs();         }          @Override         public Operation getOperation() {           return operation;         }          @Override         public MutationState execute() throws SQLException {             ResultIterator iterator = bestPlan.iterator();             try {                 // If we're not doing any pre or post processing, we can produce the delete mutations directly                 // in the parallel threads executed for the scan                 if (!hasPreOrPostProcessing) {                     Tuple tuple;                     long totalRowCount = 0;                     if (parallelIteratorFactory != null) {                         parallelIteratorFactory.setQueryPlan(bestPlan);                         parallelIteratorFactory.setOtherTableRefs(otherTableRefs);                         parallelIteratorFactory.setProjectedTableRef(projectedTableRef);                     }                     while ((tuple=iterator.next()) != null) {// Runs query                         Cell kv = tuple.getValue(0);                         totalRowCount += PLong.INSTANCE.getCodec().decodeLong(kv.getValueArray(), kv.getValueOffset(), SortOrder.getDefault());                     }                     // Return total number of rows that have been deleted from the table. In the case of auto commit being off                     // the mutations will all be in the mutation state of the current connection. We need to divide by the                     // total number of tables we updated as otherwise the client will get an inflated result.                     int totalTablesUpdateClientSide = 1; // data table is always updated                     PTable bestTable = bestPlan.getTableRef().getTable();                     // global immutable tables are also updated client side (but don't double count the data table)                     if (bestPlan != dataPlan &amp;&amp; isMaintainedOnClient(bestTable)) {                         totalTablesUpdateClientSide++;                     }                     for (TableRef otherTableRef : otherTableRefs) {                         PTable otherTable = otherTableRef.getTable();                         // Don't double count the data table here (which morphs when it becomes a projected table, hence this check)                         if (projectedTableRef != otherTableRef &amp;&amp; isMaintainedOnClient(otherTable)) {                             totalTablesUpdateClientSide++;                         }                     }                     MutationState state = new MutationState(maxSize, maxSizeBytes, connection, totalRowCount/totalTablesUpdateClientSide);                      // set the read metrics accumulated in the parent context so that it can be published when the mutations are committed.                     state.setReadMetricQueue(context.getReadMetricsQueue());                      return state;                 } else {                     // Otherwise, we have to execute the query and produce the delete mutations in the single thread                     // producing the query results.                     return deleteRows(context, iterator, bestPlan, projectedTableRef, otherTableRefs);                 }             } finally {                 iterator.close();             }         }          @Override         public ExplainPlan getExplainPlan() throws SQLException {             List queryPlanSteps =  bestPlan.getExplainPlan().getPlanSteps();             List planSteps = Lists.newArrayListWithExpectedSize(queryPlanSteps.size()+1);             planSteps.add(&quot;DELETE ROWS&quot;);             planSteps.addAll(queryPlanSteps);             return new ExplainPlan(planSteps);         }          @Override         public Long getEstimatedRowsToScan() throws SQLException {             return bestPlan.getEstimatedRowsToScan();         }          @Override         public Long getEstimatedBytesToScan() throws SQLException {             return bestPlan.getEstimatedBytesToScan();         }          @Override         public Long getEstimateInfoTimestamp() throws SQLException {             return bestPlan.getEstimateInfoTimestamp();         }          @Override         public QueryPlan getQueryPlan() {             return bestPlan;         }     }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13578</td>
    <td align="left">https://github.com/apache/phoenix/blob/69e5bb0b304a53967cef40b2a4cfc66e69ecaa51/phoenix-core/src/main/java/org/apache/phoenix/compile/DeleteCompiler.java/#L844-L978</td>
    <td align="right">1</td>
    <td align="right">2227</td>
    <td align="right">13578</td>
  </tr>
  <tr valign="top">
    <td align="right">1230</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;1. Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Capability implements IConvertible {     private String virtualCores;      private String memorySize;      private String memory;      public String getVirtualCores() {         return virtualCores;     }      public void setVirtualCores(String virtualCores) {         this.virtualCores = virtualCores;     }      public String getMemorySize() {         return memorySize;     }      public void setMemorySize(String memorySize) {         this.memorySize = memorySize;     }      public String getMemory() {         return memory;     }      public void setMemory(String memory) {         this.memory = memory;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10362</td>
    <td align="left">https://github.com/Microsoft/azure-tools-for-java/blob/d121e8ac9cc3ab400e5b49c8b372280ae332f3fb/Utils/hdinsight-node-common/src/com/microsoft/azure/hdinsight/sdk/rest/yarn/rm/Capability.java/#L26-L56</td>
    <td align="right">1</td>
    <td align="right">1230</td>
    <td align="right">10362</td>
  </tr>
  <tr valign="top">
    <td align="right">385</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells&quot;: [             &quot;Data Class&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class IgfsHandshakeResponse implements Externalizable {     /** */     private static final long serialVersionUID = 0L;      /** IGFS name. */     private String igfsName;      /** Server block size. */     private long blockSize;      /** Whether to force sampling on client's side. */     private Boolean sampling;      /**      * {@link Externalizable} support.      */     public IgfsHandshakeResponse() {         // No-op.     }      /**      * Constructor.      *      * @param blockSize Server default block size.      */     public IgfsHandshakeResponse(String igfsName, long blockSize, Boolean sampling) {         this.igfsName = igfsName;         this.blockSize = blockSize;         this.sampling = sampling;     }      /**      * @return IGFS name.      */     public String igfsName() {         return igfsName;     }      /**      * @return Server default block size.      */     public long blockSize() {         return blockSize;     }      /**      * @return Sampling flag.      */     public Boolean sampling() {         return sampling;     }      /** {@inheritDoc} */     @Override public void writeExternal(ObjectOutput out) throws IOException {         U.writeString(out, igfsName);          out.writeLong(blockSize);          if (sampling != null) {             out.writeBoolean(true);             out.writeBoolean(sampling);         }         else             out.writeBoolean(false);     }      /** {@inheritDoc} */     @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {         igfsName = U.readString(in);          blockSize = in.readLong();          if (in.readBoolean())             sampling = in.readBoolean();     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3938</td>
    <td align="left">https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/core/src/main/java/org/apache/ignite/internal/processors/igfs/IgfsHandshakeResponse.java/#L29-L104</td>
    <td align="right">1</td>
    <td align="right">385</td>
    <td align="right">3938</td>
  </tr>
  <tr valign="top">
    <td align="right">2098</td>
    <td align="left">{&quot;response&quot;:&quot;YES I found bad smells&quot;,&quot;bad smells are&quot;:[&quot;Data Class&quot;,&quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@APICommand(name = &quot;extractTemplate&quot;, description = &quot;Extracts a template&quot;, responseObject = ExtractResponse.class,         requestHasSensitiveInfo = false, responseHasSensitiveInfo = false) public class ExtractTemplateCmd extends BaseAsyncCmd {     public static final Logger s_logger = Logger.getLogger(ExtractTemplateCmd.class.getName());      private static final String s_name = &quot;extracttemplateresponse&quot;;      /////////////////////////////////////////////////////     //////////////// API parameters /////////////////////     /////////////////////////////////////////////////////      @Parameter(name = ApiConstants.ID, type = CommandType.UUID, entityType = TemplateResponse.class, required = true, description = &quot;the ID of the template&quot;)     private Long id;      @Parameter(name = ApiConstants.URL, type = CommandType.STRING, required = false, length = 2048, description = &quot;the url to which the ISO would be extracted&quot;)     private String url;      @Parameter(name = ApiConstants.ZONE_ID,                type = CommandType.UUID,                entityType = ZoneResponse.class,                required = false,                description = &quot;the ID of the zone where the ISO is originally located&quot;)     private Long zoneId;      @Parameter(name = ApiConstants.MODE, type = CommandType.STRING, required = true, description = &quot;the mode of extraction - HTTP_DOWNLOAD or FTP_UPLOAD&quot;)     private String mode;      /////////////////////////////////////////////////////     /////////////////// Accessors ///////////////////////     /////////////////////////////////////////////////////      public Long getId() {         return id;     }      public String getUrl() {         return url;     }      public Long getZoneId() {         return zoneId;     }      public String getMode() {         return mode;     }      /////////////////////////////////////////////////////     /////////////// API Implementation///////////////////     /////////////////////////////////////////////////////      @Override     public String getCommandName() {         return s_name;     }      public static String getStaticName() {         return s_name;     }      @Override     public long getEntityOwnerId() {         VirtualMachineTemplate template = _entityMgr.findById(VirtualMachineTemplate.class, getId());         if (template != null) {             return template.getAccountId();         }          // invalid id, parent this command to SYSTEM so ERROR events are tracked         return Account.ACCOUNT_ID_SYSTEM;     }      @Override     public String getEventType() {         return EventTypes.EVENT_TEMPLATE_EXTRACT;     }      @Override     public String getEventDescription() {      return &quot;extracting template: &quot; + this._uuidMgr.getUuid(VirtualMachineTemplate.class, getId()) + ((getZoneId() != null) ? &quot; from zone: &quot; + this._uuidMgr.getUuid(DataCenter.class, getZoneId()) : &quot;&quot;);     }      @Override     public ApiCommandJobType getInstanceType() {         return ApiCommandJobType.Template;     }      @Override     public Long getInstanceId() {         return getId();     }      @Override     public void execute() {         try {             CallContext.current().setEventDetails(getEventDescription());             String uploadUrl = _templateService.extract(this);             if (uploadUrl != null) {                 ExtractResponse response = _responseGenerator.createExtractResponse(id, zoneId, getEntityOwnerId(), mode, uploadUrl);                 response.setResponseName(getCommandName());                 this.setResponseObject(response);             } else {                 throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, &quot;Failed to extract template&quot;);             }         } catch (InternalErrorException ex) {             s_logger.warn(&quot;Exception: &quot;, ex);             throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());         }     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13153</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/api/src/main/java/org/apache/cloudstack/api/command/user/template/ExtractTemplateCmd.java/#L39-L147</td>
    <td align="right">1</td>
    <td align="right">2098</td>
    <td align="right">13153</td>
  </tr>
  <tr valign="top">
    <td align="right">679</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }  </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class BeanIOIterator implements Iterator, Closeable {      private BeanReader reader;     private transient Object next;     private transient Object forceNext;      public BeanIOIterator(BeanReader reader) {         this.reader = reader;         this.next = next();     }      @Override     public void close() throws IOException {         if (reader != null) {             reader.close();             reader = null;         }     }      @Override     public boolean hasNext() {         return next != null;     }      @Override     public Object next() {         Object answer = next;         if (answer == null) {             answer = reader.read();             // after read we may force a next             if (forceNext != null) {                 answer = forceNext;                 forceNext = null;             }         } else {             next = reader.read();             // after read we may force a next             if (forceNext != null) {                 next = forceNext;                 forceNext = null;             }         }         return answer;     }      @Override     public void remove() {         // noop     }      /**      * Sets a custom object as the next, such as from a custom error handler      */     public void setNext(Object next) {         this.forceNext = next;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6586</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-beanio/src/main/java/org/apache/camel/dataformat/beanio/BeanIOIterator.java/#L25-L81</td>
    <td align="right">1</td>
    <td align="right">679</td>
    <td align="right">6586</td>
  </tr>
  <tr valign="top">
    <td align="right">324</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
		public Action getBinaryBitwiseExpressionLhsAction_1_0_0_0() { return cBinaryBitwiseExpressionLhsAction_1_0_0_0; } 		 		//op=BitwiseOROperator 		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; } 		 		//BitwiseOROperator 		public RuleCall getOpBitwiseOROperatorParserRuleCall_1_0_0_1_0() { return cOpBitwiseOROperatorParserRuleCall_1_0_0_1_0; } 		 		//rhs=BitwiseXORExpression 		public Assignment getRhsAssignment_1_1() { return cRhsAssignment_1_1; } 		 		//BitwiseXORExpression 		public RuleCall getRhsBitwiseXORExpressionParserRuleCall_1_1_0() { return cRhsBitwiseXORExpressionParserRuleCall_1_1_0; } 	} 	public class BitwiseOROperatorElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.n4js.N4JS.BitwiseOROperator&quot;); 		private final Keyword cVerticalLineKeyword = (Keyword)rule.eContents().get(1); 		 		//BitwiseOROperator BinaryBitwiseOperator: 		//	'|'; 		@Override public ParserRule getRule() { return rule; } 		 		//'|' 		public Keyword getVerticalLineKeyword() { return cVerticalLineKeyword; } 	} 	public class LogicalANDExpressionElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.n4js.N4JS.LogicalANDExpression&quot;); 		private final Group cGroup = (Group)rule.eContents().get(1); 		private final RuleCall cBitwiseORExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0); 		private final Group cGroup_1 = (Group)cGroup.eContents().get(1); 		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0); 		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0); 		private final Action cBinaryLogicalExpressionLhsAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0); 		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1); 		private final RuleCall cOpLogicalANDOperatorParserRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0); 		private final Assignment cRhsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1); 		private final RuleCall cRhsBitwiseORExpressionParserRuleCall_1_1_0 = (RuleCall)cRhsAssignment_1_1.eContents().get(0); 		 		//// $ (=&gt; ({BinaryLogicalExpression.lhs=current} op=LogicalANDOperator) 		//	rhs=BitwiseORExpression)*; 		@Override public ParserRule getRule() { return rule; } 		 		//BitwiseORExpression (=&gt; ({BinaryLogicalExpression.lhs=current} op=LogicalANDOperator) 		//rhs=BitwiseORExpression)* 		public Group getGroup() { return cGroup; } 		 		//BitwiseORExpression 		public RuleCall getBitwiseORExpressionParserRuleCall_0() { return cBitwiseORExpressionParserRuleCall_0; } 		</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3343</td>
    <td align="left">https://github.com/eclipse/n4js/blob/f715912fce0352ab574ff878086f77d17a78c908/plugins/org.eclipse.n4js/src-gen/org/eclipse/n4js/services/N4JSGrammarAccess.java/#L6096-L6144</td>
    <td align="right">1</td>
    <td align="right">324</td>
    <td align="right">3343</td>
  </tr>
  <tr valign="top">
    <td align="right">2296</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells, the bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
class Segment {     private byte segmentType;      Segment(byte segmentType) {         this.segmentType = segmentType;     }      /**      * Returns the segmentType value.      *       * @return byte segmentType value.      */     public byte getSegmentType() {         return segmentType;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14009</td>
    <td align="left">https://github.com/Microsoft/mssql-jdbc/blob/84484edf7944de56749fd2648d0af2ffa2459b7a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java/#L1932-L1947</td>
    <td align="right">1</td>
    <td align="right">2296</td>
    <td align="right">14009</td>
  </tr>
  <tr valign="top">
    <td align="right">985</td>
    <td align="left">{&quot;output&quot;: &quot;YES I found bad smells\n the bad smells are:\n 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement(name = &quot;pagedResult&quot;) @XmlType public class PagedResult implements Serializable {      private static final long serialVersionUID = 3472875885259250934L;      private URI prev;      private URI next;      private final List result = new ArrayList&lt;&gt;();      private int page;      private int size;      private int totalCount;      public URI getPrev() {         return prev;     }      public void setPrev(final URI prev) {         this.prev = prev;     }      public URI getNext() {         return next;     }      public void setNext(final URI next) {         this.next = next;     }      @XmlElementWrapper(name = &quot;result&quot;)     @XmlElement(name = &quot;item&quot;)     @JsonProperty(&quot;result&quot;)     @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = &quot;@class&quot;)     public List getResult() {         return result;     }      public int getPage() {         return page;     }      public void setPage(final int page) {         this.page = page;     }      public int getSize() {         return size;     }      public void setSize(final int size) {         this.size = size;     }      public int getTotalCount() {         return totalCount;     }      public void setTotalCount(final int totalCount) {         this.totalCount = totalCount;     }      @Override     public int hashCode() {         return new HashCodeBuilder().                 append(prev).                 append(next).                 append(result).                 append(page).                 append(size).                 append(totalCount).                 build();     }      @Override     public boolean equals(final Object obj) {         if (this == obj) {             return true;         }         if (obj == null) {             return false;         }         if (getClass() != obj.getClass()) {             return false;         }         @SuppressWarnings(&quot;unchecked&quot;)         final PagedResult other = (PagedResult) obj;         return new EqualsBuilder().                 append(prev, other.prev).                 append(next, other.next).                 append(result, other.result).                 append(page, other.page).                 append(size, other.size).                 append(totalCount, other.totalCount).                 build();     } }</td>
    <td align="left">data class</td>
    <td align="left">\n 1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8878</td>
    <td align="left">https://github.com/apache/syncope/blob/114c412afbfba24ffb4fbc804e5308a823a16a78/common/idrepo/lib/src/main/java/org/apache/syncope/common/lib/to/PagedResult.java/#L35-L135</td>
    <td align="right">1</td>
    <td align="right">985</td>
    <td align="right">8878</td>
  </tr>
  <tr valign="top">
    <td align="right">2244</td>
    <td align="left">&nbsp;&nbsp;{ &quot;output&quot;: &quot;YES I found bad smells. the bad smells are: 1. Data Class&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TeamContext {      /**     * The team project Id or name.  Ignored if ProjectId is set.     */     private String project;     /**     * The Team Project ID.  Required if Project is not set.     */     private UUID projectId;     /**     * The Team Id or name.  Ignored if TeamId is set.     */     private String team;     /**     * The Team Id     */     private UUID teamId;      /**     * The team project Id or name.  Ignored if ProjectId is set.     */     public String getProject() {         return project;     }      /**     * The team project Id or name.  Ignored if ProjectId is set.     */     public void setProject(final String project) {         this.project = project;     }      /**     * The Team Project ID.  Required if Project is not set.     */     public UUID getProjectId() {         return projectId;     }      /**     * The Team Project ID.  Required if Project is not set.     */     public void setProjectId(final UUID projectId) {         this.projectId = projectId;     }      /**     * The Team Id or name.  Ignored if TeamId is set.     */     public String getTeam() {         return team;     }      /**     * The Team Id or name.  Ignored if TeamId is set.     */     public void setTeam(final String team) {         this.team = team;     }      /**     * The Team Id     */     public UUID getTeamId() {         return teamId;     }      /**     * The Team Id     */     public void setTeamId(final UUID teamId) {         this.teamId = teamId;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13631</td>
    <td align="left">https://github.com/Microsoft/vso-httpclient-java/blob/7b6329238498d7ad1934243150f955bea594df37/Rest/alm-tfs-client/src/main/generated/com/microsoft/alm/teamfoundation/core/webapi/types/TeamContext.java/#L24-L98</td>
    <td align="right">1</td>
    <td align="right">2244</td>
    <td align="right">13631</td>
  </tr>
  <tr valign="top">
    <td align="right">897</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity @Table(name = &quot;ESPM_SUPPLIER&quot;) @NamedQueries({ 	@NamedQuery(name = &quot;Supplier.getAllSuppliers&quot;, query = &quot;SELECT s FROM Supplier s&quot;), 	@NamedQuery(name = &quot;Supplier.getSupplierBySupplierId&quot;, query = &quot;SELECT s FROM Supplier s WHERE s.supplierId= :supplierId&quot;) }) public class Supplier { 	/* Supplier ids are generated within a number range starting with 2 */ 	@TableGenerator(name = &quot;SupplierGenerator&quot;, table = &quot;ESPM_ID_GENERATOR&quot;, pkColumnName = &quot;GENERATOR_NAME&quot;, valueColumnName = &quot;GENERATOR_VALUE&quot;, pkColumnValue = &quot;Customer&quot;, initialValue = 100000000, allocationSize = 100) 	@Id 	@GeneratedValue(strategy = GenerationType.TABLE, generator = &quot;SupplierGenerator&quot;) 	@Column(name = &quot;SUPPLIER_ID&quot;, length = 10) 	private String supplierId;  	@Column(name = &quot;EMAIL_ADDRESS&quot;, unique = true) 	private String emailAddress;  	@Column(name = &quot;PHONE_NUMBER&quot;, length = 30) 	private String phoneNumber;  	@Column(name = &quot;CITY&quot;, length = 40) 	private String city;  	@Column(name = &quot;POSTAL_CODE&quot;, length = 10) 	private String postalCode;  	@Column(name = &quot;STREET&quot;, length = 60) 	private String street;  	@Column(name = &quot;HOUSE_NUMBER&quot;, length = 10) 	private String houseNumber;  	@Column(name = &quot;COUNTRY&quot;, length = 3) 	private String country;  	@Column(name = &quot;SUPPLIER_NAME&quot;, length = 80) 	private String supplierName;  	public String getSupplierId() { 		return supplierId; 	}  	public void setSupplierId(String id) { 		this.supplierId = id; 	}  	public void setEmailAddress(String param) { 		this.emailAddress = param; 	}  	public String getEmailAddress() { 		return emailAddress; 	}  	public void setPhoneNumber(String param) { 		this.phoneNumber = param; 	}  	public String getPhoneNumber() { 		return phoneNumber; 	}  	public void setCity(String param) { 		this.city = param; 	}  	public String getCity() { 		return city; 	}  	public void setPostalCode(String param) { 		this.postalCode = param; 	}  	public String getPostalCode() { 		return postalCode; 	}  	public void setStreet(String param) { 		this.street = param; 	}  	public String getStreet() { 		return street; 	}  	public void setHouseNumber(String param) { 		this.houseNumber = param; 	}  	public String getHouseNumber() { 		return houseNumber; 	}  	public void setCountry(String param) { 		this.country = param; 	}  	public String getCountry() { 		return country; 	}  	public void setSupplierName(String param) { 		this.supplierName = param; 	}  	public String getSupplierName() { 		return supplierName; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8148</td>
    <td align="left">https://github.com/SAP/cloud-espm-v2/blob/a5254f2e6fea9b7226296fbe19eb30ab99192b8d/espm-cloud-jpa/src/main/java/com/sap/espm/model/Supplier.java/#L13-L123</td>
    <td align="right">1</td>
    <td align="right">897</td>
    <td align="right">8148</td>
  </tr>
  <tr valign="top">
    <td align="right">1341</td>
    <td align="left">{&quot;output&quot;: &quot;YES I found bad smells, the bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class TemplateConfiguration extends Configurable implements ParserConfiguration {      private boolean parentConfigurationSet;     private Integer tagSyntax;     private Integer interpolationSyntax;     private Integer namingConvention;     private Boolean whitespaceStripping;     private Boolean strictSyntaxMode;     private Integer autoEscapingPolicy;     private Boolean recognizeStandardFileExtensions;     private OutputFormat outputFormat;     private String encoding;     private Integer tabSize;      /**      * Creates a new instance. The parent will be {@link Configuration#getDefaultConfiguration()} initially, but it will      * be changed to the real parent {@link Configuration} when this object is added to the {@link Configuration}. (It's      * not allowed to add the same instance to multiple {@link Configuration}-s).      */     public TemplateConfiguration() {         super(Configuration.getDefaultConfiguration());     }      /**      * Same as {@link #setParentConfiguration(Configuration)}.      */     @Override     void setParent(Configurable cfg) {         NullArgumentException.check(&quot;cfg&quot;, cfg);         if (!(cfg instanceof Configuration)) {             throw new IllegalArgumentException(&quot;The parent of a TemplateConfiguration can only be a Configuration&quot;);         }                  if (parentConfigurationSet) {             if (getParent() != cfg) {                 throw new IllegalStateException(                         &quot;This TemplateConfiguration is already associated with a different Configuration instance.&quot;);             }             return;         }                  if (((Configuration) cfg).getIncompatibleImprovements().intValue() &lt; _TemplateAPI.VERSION_INT_2_3_22                 &amp;&amp; hasAnyConfigurableSet()) {             throw new IllegalStateException(                     &quot;This TemplateConfiguration can't be associated to a Configuration that has &quot;                     + &quot;incompatibleImprovements less than 2.3.22, because it changes non-parser settings.&quot;);         }                  super.setParent(cfg);         parentConfigurationSet = true;     }      /**      * Associates this instance with a {@link Configuration}; usually you don't call this, as it's called internally      * when this instance is added to a {@link Configuration}. This method can be called only once (except with the same      * {@link Configuration} parameter again, as that changes nothing anyway).      *       * @throws IllegalArgumentException      *             if the argument is {@code null} or not a {@link Configuration}      * @throws IllegalStateException      *             if this object is already associated to a different {@link Configuration} object,      *             or if the {@code Configuration} has {@code #getIncompatibleImprovements()} less than 2.3.22 and      *             this object tries to change any non-parser settings        */     public void setParentConfiguration(Configuration cfg) {         setParent(cfg);     }      /**      * Returns the parent {@link Configuration}, or {@code null} if none was associated yet.      */     public Configuration getParentConfiguration() {         return parentConfigurationSet ? (Configuration) getParent() : null;     }      private Configuration getNonNullParentConfiguration() {         checkParentConfigurationSet();         return (Configuration) getParent();     }          /**      * Set all settings in this {@link TemplateConfiguration} that were set in the parameter      * {@link TemplateConfiguration}, possibly overwriting the earlier value in this object. (A setting is said to be      * set in a {@link TemplateConfiguration} if it was explicitly set via a setter method, as opposed to be inherited.)      */     public void merge(TemplateConfiguration tc) {         if (tc.isAPIBuiltinEnabledSet()) {             setAPIBuiltinEnabled(tc.isAPIBuiltinEnabled());         }         if (tc.isArithmeticEngineSet()) {             setArithmeticEngine(tc.getArithmeticEngine());         }         if (tc.isAutoEscapingPolicySet()) {             setAutoEscapingPolicy(tc.getAutoEscapingPolicy());         }         if (tc.isAutoFlushSet()) {             setAutoFlush(tc.getAutoFlush());         }         if (tc.isBooleanFormatSet()) {             setBooleanFormat(tc.getBooleanFormat());         }         if (tc.isClassicCompatibleSet()) {             setClassicCompatibleAsInt(tc.getClassicCompatibleAsInt());         }         if (tc.isCustomDateFormatsSet()) {             setCustomDateFormats(mergeMaps(getCustomDateFormats(), tc.getCustomDateFormats(), false));         }         if (tc.isCustomNumberFormatsSet()) {             setCustomNumberFormats(mergeMaps(getCustomNumberFormats(), tc.getCustomNumberFormats(), false));         }         if (tc.isDateFormatSet()) {             setDateFormat(tc.getDateFormat());         }         if (tc.isDateTimeFormatSet()) {             setDateTimeFormat(tc.getDateTimeFormat());         }         if (tc.isEncodingSet()) {             setEncoding(tc.getEncoding());         }         if (tc.isLocaleSet()) {             setLocale(tc.getLocale());         }         if (tc.isLogTemplateExceptionsSet()) {             setLogTemplateExceptions(tc.getLogTemplateExceptions());         }         if (tc.isWrapUncheckedExceptionsSet()) {             setWrapUncheckedExceptions(tc.getWrapUncheckedExceptions());         }         if (tc.isNamingConventionSet()) {             setNamingConvention(tc.getNamingConvention());         }         if (tc.isNewBuiltinClassResolverSet()) {             setNewBuiltinClassResolver(tc.getNewBuiltinClassResolver());         }         if (tc.isTruncateBuiltinAlgorithmSet()) {             setTruncateBuiltinAlgorithm(tc.getTruncateBuiltinAlgorithm());         }         if (tc.isNumberFormatSet()) {             setNumberFormat(tc.getNumberFormat());         }         if (tc.isObjectWrapperSet()) {             setObjectWrapper(tc.getObjectWrapper());         }         if (tc.isOutputEncodingSet()) {             setOutputEncoding(tc.getOutputEncoding());         }         if (tc.isOutputFormatSet()) {             setOutputFormat(tc.getOutputFormat());         }         if (tc.isRecognizeStandardFileExtensionsSet()) {             setRecognizeStandardFileExtensions(tc.getRecognizeStandardFileExtensions());         }         if (tc.isShowErrorTipsSet()) {             setShowErrorTips(tc.getShowErrorTips());         }         if (tc.isSQLDateAndTimeTimeZoneSet()) {             setSQLDateAndTimeTimeZone(tc.getSQLDateAndTimeTimeZone());         }         if (tc.isStrictSyntaxModeSet()) {             setStrictSyntaxMode(tc.getStrictSyntaxMode());         }         if (tc.isTagSyntaxSet()) {             setTagSyntax(tc.getTagSyntax());         }         if (tc.isInterpolationSyntaxSet()) {             setInterpolationSyntax(tc.getInterpolationSyntax());         }         if (tc.isTemplateExceptionHandlerSet()) {             setTemplateExceptionHandler(tc.getTemplateExceptionHandler());         }         if (tc.isAttemptExceptionReporterSet()) {             setAttemptExceptionReporter(tc.getAttemptExceptionReporter());         }         if (tc.isTimeFormatSet()) {             setTimeFormat(tc.getTimeFormat());         }         if (tc.isTimeZoneSet()) {             setTimeZone(tc.getTimeZone());         }         if (tc.isURLEscapingCharsetSet()) {             setURLEscapingCharset(tc.getURLEscapingCharset());         }         if (tc.isWhitespaceStrippingSet()) {             setWhitespaceStripping(tc.getWhitespaceStripping());         }         if (tc.isTabSizeSet()) {             setTabSize(tc.getTabSize());         }         if (tc.isLazyImportsSet()) {             setLazyImports(tc.getLazyImports());         }         if (tc.isLazyAutoImportsSet()) {             setLazyAutoImports(tc.getLazyAutoImports());         }         if (tc.isAutoImportsSet()) {             setAutoImports(mergeMaps(getAutoImportsWithoutFallback(), tc.getAutoImportsWithoutFallback(), true));         }         if (tc.isAutoIncludesSet()) {             setAutoIncludes(mergeLists(getAutoIncludesWithoutFallback(), tc.getAutoIncludesWithoutFallback()));         }                  tc.copyDirectCustomAttributes(this, true);     }      /**      * Sets those settings of the {@link Template} which aren't yet set in the {@link Template} and are set in this      * {@link TemplateConfiguration}, leaves the other settings as is. A setting is said to be set in a      * {@link TemplateConfiguration} or {@link Template} if it was explicitly set via a setter method on that object, as      * opposed to be inherited from the {@link Configuration}.      *       *       * Note that this method doesn't deal with settings that influence the parser, as those are already baked in at this      * point via the {@link ParserConfiguration}.       *       *       * Note that the {@code encoding} setting of the {@link Template} counts as unset if it's {@code null},      * even if {@code null} was set via {@link Template#setEncoding(String)}.      *      * @throws IllegalStateException      *             If the parent configuration wasn't yet set.      */     public void apply(Template template) {         Configuration cfg = getNonNullParentConfiguration();         if (template.getConfiguration() != cfg) {             // This is actually not a problem right now, but for future BC we enforce this.             throw new IllegalArgumentException(                     &quot;The argument Template doesn't belong to the same Configuration as the TemplateConfiguration&quot;);         }          if (isAPIBuiltinEnabledSet() &amp;&amp; !template.isAPIBuiltinEnabledSet()) {             template.setAPIBuiltinEnabled(isAPIBuiltinEnabled());         }         if (isArithmeticEngineSet() &amp;&amp; !template.isArithmeticEngineSet()) {             template.setArithmeticEngine(getArithmeticEngine());         }         if (isAutoFlushSet() &amp;&amp; !template.isAutoFlushSet()) {             template.setAutoFlush(getAutoFlush());         }         if (isBooleanFormatSet() &amp;&amp; !template.isBooleanFormatSet()) {             template.setBooleanFormat(getBooleanFormat());         }         if (isClassicCompatibleSet() &amp;&amp; !template.isClassicCompatibleSet()) {             template.setClassicCompatibleAsInt(getClassicCompatibleAsInt());         }         if (isCustomDateFormatsSet()) {             template.setCustomDateFormats(                     mergeMaps(getCustomDateFormats(), template.getCustomDateFormatsWithoutFallback(), false));         }         if (isCustomNumberFormatsSet()) {             template.setCustomNumberFormats(                     mergeMaps(getCustomNumberFormats(), template.getCustomNumberFormatsWithoutFallback(), false));         }         if (isDateFormatSet() &amp;&amp; !template.isDateFormatSet()) {             template.setDateFormat(getDateFormat());         }         if (isDateTimeFormatSet() &amp;&amp; !template.isDateTimeFormatSet()) {             template.setDateTimeFormat(getDateTimeFormat());         }         if (isEncodingSet() &amp;&amp; template.getEncoding() == null) {             template.setEncoding(getEncoding());         }         if (isLocaleSet() &amp;&amp; !template.isLocaleSet()) {             template.setLocale(getLocale());         }         if (isLogTemplateExceptionsSet() &amp;&amp; !template.isLogTemplateExceptionsSet()) {             template.setLogTemplateExceptions(getLogTemplateExceptions());         }         if (isWrapUncheckedExceptionsSet() &amp;&amp; !template.isWrapUncheckedExceptionsSet()) {             template.setWrapUncheckedExceptions(getWrapUncheckedExceptions());         }         if (isNewBuiltinClassResolverSet() &amp;&amp; !template.isNewBuiltinClassResolverSet()) {             template.setNewBuiltinClassResolver(getNewBuiltinClassResolver());         }         if (isTruncateBuiltinAlgorithmSet() &amp;&amp; !template.isTruncateBuiltinAlgorithmSet()) {             template.setTruncateBuiltinAlgorithm(getTruncateBuiltinAlgorithm());         }         if (isNumberFormatSet() &amp;&amp; !template.isNumberFormatSet()) {             template.setNumberFormat(getNumberFormat());         }         if (isObjectWrapperSet() &amp;&amp; !template.isObjectWrapperSet()) {             template.setObjectWrapper(getObjectWrapper());         }         if (isOutputEncodingSet() &amp;&amp; !template.isOutputEncodingSet()) {             template.setOutputEncoding(getOutputEncoding());         }         if (isShowErrorTipsSet() &amp;&amp; !template.isShowErrorTipsSet()) {             template.setShowErrorTips(getShowErrorTips());         }         if (isSQLDateAndTimeTimeZoneSet() &amp;&amp; !template.isSQLDateAndTimeTimeZoneSet()) {             template.setSQLDateAndTimeTimeZone(getSQLDateAndTimeTimeZone());         }         if (isTemplateExceptionHandlerSet() &amp;&amp; !template.isTemplateExceptionHandlerSet()) {             template.setTemplateExceptionHandler(getTemplateExceptionHandler());         }         if (isAttemptExceptionReporterSet() &amp;&amp; !template.isAttemptExceptionReporterSet()) {             template.setAttemptExceptionReporter(getAttemptExceptionReporter());         }         if (isTimeFormatSet() &amp;&amp; !template.isTimeFormatSet()) {             template.setTimeFormat(getTimeFormat());         }         if (isTimeZoneSet() &amp;&amp; !template.isTimeZoneSet()) {             template.setTimeZone(getTimeZone());         }         if (isURLEscapingCharsetSet() &amp;&amp; !template.isURLEscapingCharsetSet()) {             template.setURLEscapingCharset(getURLEscapingCharset());         }         if (isLazyImportsSet() &amp;&amp; !template.isLazyImportsSet()) {             template.setLazyImports(getLazyImports());         }         if (isLazyAutoImportsSet() &amp;&amp; !template.isLazyAutoImportsSet()) {             template.setLazyAutoImports(getLazyAutoImports());         }         if (isAutoImportsSet()) {             // Regarding the order of the maps in the merge:             // - Existing template-level imports have precedence over those coming from the TC (just as with the others             //   apply()-ed settings), thus for clashing import prefixes they must win.             // - Template-level imports count as more specific, and so come after the more generic ones from TC.             template.setAutoImports(mergeMaps(getAutoImports(), template.getAutoImportsWithoutFallback(), true));         }         if (isAutoIncludesSet()) {             template.setAutoIncludes(mergeLists(getAutoIncludes(), template.getAutoIncludesWithoutFallback()));         }                  copyDirectCustomAttributes(template, false);     }      /**      * See {@link Configuration#setTagSyntax(int)}.      */     public void setTagSyntax(int tagSyntax) {         _TemplateAPI.valideTagSyntaxValue(tagSyntax);         this.tagSyntax = Integer.valueOf(tagSyntax);     }      /**      * The getter pair of {@link #setTagSyntax(int)}.      */     public int getTagSyntax() {         return tagSyntax != null ? tagSyntax.intValue() : getNonNullParentConfiguration().getTagSyntax();     }      /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isTagSyntaxSet() {         return tagSyntax != null;     }      /**      * See {@link Configuration#setInterpolationSyntax(int)}.      */     public void setInterpolationSyntax(int interpolationSyntax) {         _TemplateAPI.valideInterpolationSyntaxValue(interpolationSyntax);         this.interpolationSyntax = Integer.valueOf(interpolationSyntax);     }          /**      * The getter pair of {@link #setInterpolationSyntax(int)}.      */     public int getInterpolationSyntax() {         return interpolationSyntax != null ? interpolationSyntax.intValue()                 : getNonNullParentConfiguration().getInterpolationSyntax();     }      /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isInterpolationSyntaxSet() {         return interpolationSyntax != null;     }          /**      * See {@link Configuration#setNamingConvention(int)}.      */     public void setNamingConvention(int namingConvention) {         _TemplateAPI.validateNamingConventionValue(namingConvention);         this.namingConvention = Integer.valueOf(namingConvention);     }      /**      * The getter pair of {@link #setNamingConvention(int)}.      */     public int getNamingConvention() {         return namingConvention != null ? namingConvention.intValue()                 : getNonNullParentConfiguration().getNamingConvention();     }      /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isNamingConventionSet() {         return namingConvention != null;     }      /**      * See {@link Configuration#setWhitespaceStripping(boolean)}.      */     public void setWhitespaceStripping(boolean whitespaceStripping) {         this.whitespaceStripping = Boolean.valueOf(whitespaceStripping);     }      /**      * The getter pair of {@link #getWhitespaceStripping()}.      */     public boolean getWhitespaceStripping() {         return whitespaceStripping != null ? whitespaceStripping.booleanValue()                 : getNonNullParentConfiguration().getWhitespaceStripping();     }      /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isWhitespaceStrippingSet() {         return whitespaceStripping != null;     }      /**      * Sets the output format of the template; see {@link Configuration#setAutoEscapingPolicy(int)} for more.      */     public void setAutoEscapingPolicy(int autoEscapingPolicy) {         _TemplateAPI.validateAutoEscapingPolicyValue(autoEscapingPolicy);         this.autoEscapingPolicy = Integer.valueOf(autoEscapingPolicy);     }      /**      * The getter pair of {@link #setAutoEscapingPolicy(int)}.      */     public int getAutoEscapingPolicy() {         return autoEscapingPolicy != null ? autoEscapingPolicy.intValue()                 : getNonNullParentConfiguration().getAutoEscapingPolicy();     }      /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isAutoEscapingPolicySet() {         return autoEscapingPolicy != null;     }      /**      * Sets the output format of the template; see {@link Configuration#setOutputFormat(OutputFormat)} for more.      */     public void setOutputFormat(OutputFormat outputFormat) {         NullArgumentException.check(&quot;outputFormat&quot;, outputFormat);         this.outputFormat = outputFormat;     }      /**      * The getter pair of {@link #setOutputFormat(OutputFormat)}.      */     public OutputFormat getOutputFormat() {         return outputFormat != null ? outputFormat : getNonNullParentConfiguration().getOutputFormat();     }      /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isOutputFormatSet() {         return outputFormat != null;     }          /**      * See {@link Configuration#setRecognizeStandardFileExtensions(boolean)}.       */     public void setRecognizeStandardFileExtensions(boolean recognizeStandardFileExtensions) {         this.recognizeStandardFileExtensions = Boolean.valueOf(recognizeStandardFileExtensions);     }      /**      * Getter pair of {@link #setRecognizeStandardFileExtensions(boolean)}.      */     public boolean getRecognizeStandardFileExtensions() {         return recognizeStandardFileExtensions != null ? recognizeStandardFileExtensions.booleanValue()                 : getNonNullParentConfiguration().getRecognizeStandardFileExtensions();     }          /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isRecognizeStandardFileExtensionsSet() {         return recognizeStandardFileExtensions != null;     }          /**      * See {@link Configuration#setStrictSyntaxMode(boolean)}.      */     public void setStrictSyntaxMode(boolean strictSyntaxMode) {         this.strictSyntaxMode = Boolean.valueOf(strictSyntaxMode);     }      /**      * The getter pair of {@link #setStrictSyntaxMode(boolean)}.      */     public boolean getStrictSyntaxMode() {         return strictSyntaxMode != null ? strictSyntaxMode.booleanValue()                 : getNonNullParentConfiguration().getStrictSyntaxMode();     }          /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isStrictSyntaxModeSet() {         return strictSyntaxMode != null;     }      @Override     public void setStrictBeanModels(boolean strict) {         throw new UnsupportedOperationException(                 &quot;Setting strictBeanModels on &quot; + TemplateConfiguration.class.getSimpleName() + &quot; level isn't supported.&quot;);     }      public String getEncoding() {         return encoding != null ? encoding : getNonNullParentConfiguration().getDefaultEncoding();     }      /**      * When the standard template loading/caching mechanism is used, this forces the charset used for reading the      * template &quot;file&quot;, overriding everything but the encoding coming from the {@code #ftl} header. This setting      * overrides the locale-specific encodings set via {@link Configuration#setEncoding(java.util.Locale, String)}. It      * also overrides the {@code encoding} parameter of {@link Configuration#getTemplate(String, String)} (and of its      * overloads) and the {@code encoding} parameter of the {@code #include} directive. This works like that because      * specifying the encoding where you are requesting the template is error prone and deprecated.      *       *       * If you are developing your own template loading/caching mechanism instead of the standard one, note that the      * above behavior is not guaranteed by this class alone; you have to ensure it. Also, read the note on      * {@code encoding} in the documentation of {@link #apply(Template)}.      */     public void setEncoding(String encoding) {         NullArgumentException.check(&quot;encoding&quot;, encoding);         this.encoding = encoding;     }      public boolean isEncodingSet() {         return encoding != null;     }          /**      * See {@link Configuration#setTabSize(int)}.       *       * @since 2.3.25      */     public void setTabSize(int tabSize) {         this.tabSize = Integer.valueOf(tabSize);     }      /**      * Getter pair of {@link #setTabSize(int)}.      *       * @since 2.3.25      */     public int getTabSize() {         return tabSize != null ? tabSize.intValue()                 : getNonNullParentConfiguration().getTabSize();     }          /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      *       * @since 2.3.25      */     public boolean isTabSizeSet() {         return tabSize != null;     }          /**      * Returns {@link Configuration#getIncompatibleImprovements()} from the parent {@link Configuration}. This mostly      * just exist to satisfy the {@link ParserConfiguration} interface.      *       * @throws IllegalStateException      *             If the parent configuration wasn't yet set.      */     public Version getIncompatibleImprovements() {         return getNonNullParentConfiguration().getIncompatibleImprovements();     }      private void checkParentConfigurationSet() {         if (!parentConfigurationSet) {             throw new IllegalStateException(&quot;The TemplateConfiguration wasn't associated with a Configuration yet.&quot;);         }     }      private boolean hasAnyConfigurableSet() {         return                 isAPIBuiltinEnabledSet()                 || isArithmeticEngineSet()                 || isAutoFlushSet()                 || isAutoImportsSet()                 || isAutoIncludesSet()                 || isBooleanFormatSet()                 || isClassicCompatibleSet()                 || isCustomDateFormatsSet()                 || isCustomNumberFormatsSet()                 || isDateFormatSet()                 || isDateTimeFormatSet()                 || isLazyImportsSet()                 || isLazyAutoImportsSet()                 || isLocaleSet()                 || isLogTemplateExceptionsSet()                 || isWrapUncheckedExceptionsSet()                 || isNewBuiltinClassResolverSet()                 || isTruncateBuiltinAlgorithmSet()                 || isNumberFormatSet()                 || isObjectWrapperSet()                 || isOutputEncodingSet()                 || isShowErrorTipsSet()                 || isSQLDateAndTimeTimeZoneSet()                 || isTemplateExceptionHandlerSet()                 || isAttemptExceptionReporterSet()                 || isTimeFormatSet()                 || isTimeZoneSet()                 || isURLEscapingCharsetSet();     }          private Map mergeMaps(Map m1, Map m2, boolean overwriteUpdatesOrder) {         if (m1 == null) return m2;         if (m2 == null) return m1;         if (m1.isEmpty()) return m2;         if (m2.isEmpty()) return m1;                  LinkedHashMap mergedM = new LinkedHashMap((m1.size() + m2.size()) * 4 / 3 + 1, 0.75f);         mergedM.putAll(m1);         for (Object m2Key : m2.keySet()) {             mergedM.remove(m2Key); // So that duplicate keys are moved after m1 keys         }         mergedM.putAll(m2);         return mergedM;     }      private List mergeLists(List list1, List list2) {         if (list1 == null) return list2;         if (list2 == null) return list1;         if (list1.isEmpty()) return list2;         if (list2.isEmpty()) return list1;                  ArrayList mergedList = new ArrayList(list1.size() + list2.size());         mergedList.addAll(list1);         mergedList.addAll(list2);         return mergedList;     }      }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10742</td>
    <td align="left">https://github.com/apache/freemarker/blob/02fa5edb3cde53f284551c09ecc13301b0e83d0b/src/main/java/freemarker/core/TemplateConfiguration.java/#L77-L718</td>
    <td align="right">1</td>
    <td align="right">1341</td>
    <td align="right">10742</td>
  </tr>
  <tr valign="top">
    <td align="right">2232</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;1. Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity @Table(name = JPADynRealmMembership.TABLE) public class JPADynRealmMembership extends AbstractGeneratedKeyEntity implements DynRealmMembership {      private static final long serialVersionUID = 8157856850557493134L;      public static final String TABLE = &quot;DynRealmMembership&quot;;      @OneToOne     private JPADynRealm dynRealm;      @ManyToOne     private JPAAnyType anyType;      @NotNull     private String fiql;      @Override     public DynRealm getDynRealm() {         return dynRealm;     }      @Override     public void setDynRealm(final DynRealm dynRealm) {         checkType(dynRealm, JPADynRealm.class);         this.dynRealm = (JPADynRealm) dynRealm;     }      @Override     public AnyType getAnyType() {         return anyType;     }      @Override     public void setAnyType(final AnyType anyType) {         checkType(anyType, JPAAnyType.class);         this.anyType = (JPAAnyType) anyType;     }      @Override     public String getFIQLCond() {         return fiql;     }      @Override     public void setFIQLCond(final String fiql) {         this.fiql = fiql;     }  }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13594</td>
    <td align="left">https://github.com/apache/syncope/blob/114c412afbfba24ffb4fbc804e5308a823a16a78/core/persistence-jpa/src/main/java/org/apache/syncope/core/persistence/jpa/entity/JPADynRealmMembership.java/#L30-L79</td>
    <td align="right">1</td>
    <td align="right">2232</td>
    <td align="right">13594</td>
  </tr>
  <tr valign="top">
    <td align="right">2626</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Customer230 {  	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id; 	private String firstName; 	private String lastName;  	protected Customer230() {}  	public Customer230(String firstName, String lastName) { 		this.firstName = firstName; 		this.lastName = lastName; 	}  	@Override 	public String toString() { 		return String.format(&quot;Customer230[id=%d, firstName='%s', lastName='%s']&quot;, id, firstName, lastName); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15080</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer230.java/#L8-L27</td>
    <td align="right">1</td>
    <td align="right">2626</td>
    <td align="right">15080</td>
  </tr>
  <tr valign="top">
    <td align="right">659</td>
    <td align="left">YES I found bad smells the bad smells are: 1. Long Constructor 2. Data class 3. Feature envy: the createJobMasterService method uses more variables from the constructor instead of its own parameters.</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class DefaultJobMasterServiceFactory implements JobMasterServiceFactory {  	private final JobMasterConfiguration jobMasterConfiguration;  	private final SlotPoolFactory slotPoolFactory;  	private final SchedulerFactory schedulerFactory;  	private final RpcService rpcService;  	private final HighAvailabilityServices haServices;  	private final JobManagerSharedServices jobManagerSharedServices;  	private final HeartbeatServices heartbeatServices;  	private final JobManagerJobMetricGroupFactory jobManagerJobMetricGroupFactory;  	private final FatalErrorHandler fatalErrorHandler;  	public DefaultJobMasterServiceFactory( 			JobMasterConfiguration jobMasterConfiguration, 			SlotPoolFactory slotPoolFactory, 			SchedulerFactory schedulerFactory, 			RpcService rpcService, 			HighAvailabilityServices haServices, 			JobManagerSharedServices jobManagerSharedServices, 			HeartbeatServices heartbeatServices, 			JobManagerJobMetricGroupFactory jobManagerJobMetricGroupFactory, 			FatalErrorHandler fatalErrorHandler) { 		this.jobMasterConfiguration = jobMasterConfiguration; 		this.slotPoolFactory = slotPoolFactory; 		this.schedulerFactory = schedulerFactory; 		this.rpcService = rpcService; 		this.haServices = haServices; 		this.jobManagerSharedServices = jobManagerSharedServices; 		this.heartbeatServices = heartbeatServices; 		this.jobManagerJobMetricGroupFactory = jobManagerJobMetricGroupFactory; 		this.fatalErrorHandler = fatalErrorHandler; 	}  	@Override 	public JobMaster createJobMasterService(JobGraph jobGraph, OnCompletionActions jobCompletionActions, ClassLoader userCodeClassloader) throws Exception { 		return new JobMaster( 			rpcService, 			jobMasterConfiguration, 			ResourceID.generate(), 			jobGraph, 			haServices, 			slotPoolFactory, 			schedulerFactory, 			jobManagerSharedServices, 			heartbeatServices, 			jobManagerJobMetricGroupFactory, 			jobCompletionActions, 			fatalErrorHandler, 			userCodeClassloader); 	} }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long Constructor2 Data class3 Feature envy: the createJobMasterService method uses more variables from the constructor instead of its own parameters</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6424</td>
    <td align="left">https://github.com/apache/flink/blob/8068c8775ad067d75828e6360e7e0994348da9b9/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/factories/DefaultJobMasterServiceFactory.java/#L37-L95</td>
    <td align="right">2</td>
    <td align="right">659</td>
    <td align="right">6424</td>
  </tr>
  <tr valign="top">
    <td align="right">2286</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SimpleMessage implements Message {      private final MessageId messageId;     private final String subType;     private final String mediaType;     private final SharedInputStream content;     private final int bodyStartOctet;     private final Date internalDate;     private final long size;     private final Long textualLineCount;     private final List properties;     private final List attachments;      public SimpleMessage(MessageId messageId, SharedInputStream content, long size, Date internalDate, String subType, String mediaType, int bodyStartOctet, Long textualLineCount, List properties, List attachments) {         this.messageId = messageId;         this.subType = subType;         this.mediaType = mediaType;         this.content = content;         this.bodyStartOctet = bodyStartOctet;         this.internalDate = internalDate;         this.size = size;         this.textualLineCount = textualLineCount;         this.properties = properties;         this.attachments = attachments;     }      public SimpleMessage(MessageId messageId, SharedInputStream content, long size, Date internalDate, String subType, String mediaType, int bodyStartOctet, Long textualLineCount, List properties) {         this(messageId, content, size, internalDate, subType, mediaType, bodyStartOctet, textualLineCount, properties, ImmutableList.of());     }      @Override     public MessageId getMessageId() {         return messageId;     }      @Override     public Date getInternalDate() {         return internalDate;     }      @Override     public InputStream getBodyContent() throws IOException {         return content.newStream(bodyStartOctet, -1);     }      @Override     public String getMediaType() {         return mediaType;     }      @Override     public String getSubType() {         return subType;     }      @Override     public long getBodyOctets() {         return getFullContentOctets() - bodyStartOctet;     }      @Override     public long getHeaderOctets() {         return bodyStartOctet;     }      @Override     public long getFullContentOctets() {         return size;     }      @Override     public Long getTextualLineCount() {         return textualLineCount;     }      @Override     public InputStream getHeaderContent() throws IOException {         long headerEnd = bodyStartOctet;         if (headerEnd &lt; 0) {             headerEnd = 0;         }         return content.newStream(0, headerEnd);     }      @Override     public InputStream getFullContent() throws IOException {         return content.newStream(0, -1);     }      @Override     public List getProperties() {         return properties;     }      @Override     public List getAttachments() {         return attachments;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13880</td>
    <td align="left">https://github.com/apache/james-project/blob/fa24a096a5853459c3769a34ccc68feb91626bfa/mailbox/store/src/main/java/org/apache/james/mailbox/store/mail/model/impl/SimpleMessage.java/#L35-L133</td>
    <td align="right">1</td>
    <td align="right">2286</td>
    <td align="right">13880</td>
  </tr>
  <tr valign="top">
    <td align="right">328</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;1. Blob&quot;, &quot;2. Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Config {      public String mysqlAddr;     public Integer mysqlPort;     public String mysqlUsername;     public String mysqlPassword;      public String mqNamesrvAddr;     public String mqTopic;      public String startType = &quot;DEFAULT&quot;;     public String binlogFilename;     public Long nextPosition;     public Integer maxTransactionRows = 100;      public void load() throws IOException {          InputStream in = Config.class.getClassLoader().getResourceAsStream(&quot;rocketmq_mysql.conf&quot;);         Properties properties = new Properties();         properties.load(in);          properties2Object(properties, this);      }      private void properties2Object(final Properties p, final Object object) {         Method[] methods = object.getClass().getMethods();         for (Method method : methods) {             String mn = method.getName();             if (mn.startsWith(&quot;set&quot;)) {                 try {                     String tmp = mn.substring(4);                     String first = mn.substring(3, 4);                      String key = first.toLowerCase() + tmp;                     String property = p.getProperty(key);                     if (property != null) {                         Class[] pt = method.getParameterTypes();                         if (pt != null &amp;&amp; pt.length &gt; 0) {                             String cn = pt[0].getSimpleName();                             Object arg;                             if (cn.equals(&quot;int&quot;) || cn.equals(&quot;Integer&quot;)) {                                 arg = Integer.parseInt(property);                             } else if (cn.equals(&quot;long&quot;) || cn.equals(&quot;Long&quot;)) {                                 arg = Long.parseLong(property);                             } else if (cn.equals(&quot;double&quot;) || cn.equals(&quot;Double&quot;)) {                                 arg = Double.parseDouble(property);                             } else if (cn.equals(&quot;boolean&quot;) || cn.equals(&quot;Boolean&quot;)) {                                 arg = Boolean.parseBoolean(property);                             } else if (cn.equals(&quot;float&quot;) || cn.equals(&quot;Float&quot;)) {                                 arg = Float.parseFloat(property);                             } else if (cn.equals(&quot;String&quot;)) {                                 arg = property;                             } else {                                 continue;                             }                             method.invoke(object, arg);                         }                     }                 } catch (Throwable ignored) {                 }             }         }     }      public void setMysqlAddr(String mysqlAddr) {         this.mysqlAddr = mysqlAddr;     }      public void setMysqlPort(Integer mysqlPort) {         this.mysqlPort = mysqlPort;     }      public void setMysqlUsername(String mysqlUsername) {         this.mysqlUsername = mysqlUsername;     }      public void setMysqlPassword(String mysqlPassword) {         this.mysqlPassword = mysqlPassword;     }      public void setBinlogFilename(String binlogFilename) {         this.binlogFilename = binlogFilename;     }      public void setNextPosition(Long nextPosition) {         this.nextPosition = nextPosition;     }      public void setMaxTransactionRows(Integer maxTransactionRows) {         this.maxTransactionRows = maxTransactionRows;     }      public void setMqNamesrvAddr(String mqNamesrvAddr) {         this.mqNamesrvAddr = mqNamesrvAddr;     }      public void setMqTopic(String mqTopic) {         this.mqTopic = mqTopic;     }      public void setStartType(String startType) {         this.startType = startType;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">3385</td>
    <td align="left">https://github.com/apache/rocketmq-externals/blob/dba6eb0c997d5c325f26b3d1da9d739d927228dc/rocketmq-mysql/src/main/java/org/apache/rocketmq/mysql/Config.java/#L26-L130</td>
    <td align="right">1</td>
    <td align="right">328</td>
    <td align="right">3385</td>
  </tr>
  <tr valign="top">
    <td align="right">4998</td>
    <td align="left">&nbsp;{   &quot;response&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;Data Class&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class BacktrackingBug325745TestLanguagePackageImpl extends EPackageImpl implements BacktrackingBug325745TestLanguagePackage {   /**    *     *     * @generated    */   private EClass modelEClass = null;    /**    *     *     * @generated    */   private EClass elementEClass = null;    /**    *     *     * @generated    */   private EClass dataTypeEClass = null;    /**    *     *     * @generated    */   private EClass expressionEClass = null;    /**    *     *     * @generated    */   private EClass simpleTermEClass = null;    /**    * Creates an instance of the model Package, registered with    * {@link org.eclipse.emf.ecore.EPackage.Registry EPackage.Registry} by the package    * package URI value.    * Note: the correct way to create the package is via the static    * factory method {@link #init init()}, which also performs    * initialization of the package, or returns the registered package,    * if one already exists.    *     *     * @see org.eclipse.emf.ecore.EPackage.Registry    * @see org.eclipse.xtext.parser.unorderedGroups.backtrackingBug325745TestLanguage.BacktrackingBug325745TestLanguagePackage#eNS_URI    * @see #init()    * @generated    */   private BacktrackingBug325745TestLanguagePackageImpl()   {     super(eNS_URI, BacktrackingBug325745TestLanguageFactory.eINSTANCE);   }    /**    *     *     * @generated    */   private static boolean isInited = false;    /**    * Creates, registers, and initializes the Package for this model, and for any others upon which it depends.    *     * This method is used to initialize {@link BacktrackingBug325745TestLanguagePackage#eINSTANCE} when that field is accessed.    * Clients should not invoke it directly. Instead, they should simply access that field to obtain the package.    *     *     * @see #eNS_URI    * @see #createPackageContents()    * @see #initializePackageContents()    * @generated    */   public static BacktrackingBug325745TestLanguagePackage init()   {     if (isInited) return (BacktrackingBug325745TestLanguagePackage)EPackage.Registry.INSTANCE.getEPackage(BacktrackingBug325745TestLanguagePackage.eNS_URI);      // Obtain or create and register package     BacktrackingBug325745TestLanguagePackageImpl theBacktrackingBug325745TestLanguagePackage = (BacktrackingBug325745TestLanguagePackageImpl)(EPackage.Registry.INSTANCE.get(eNS_URI) instanceof BacktrackingBug325745TestLanguagePackageImpl ? EPackage.Registry.INSTANCE.get(eNS_URI) : new BacktrackingBug325745TestLanguagePackageImpl());      isInited = true;      // Initialize simple dependencies     EcorePackage.eINSTANCE.eClass();      // Create package meta-data objects     theBacktrackingBug325745TestLanguagePackage.createPackageContents();      // Initialize created meta-data     theBacktrackingBug325745TestLanguagePackage.initializePackageContents();      // Mark meta-data to indicate it can't be changed     theBacktrackingBug325745TestLanguagePackage.freeze();         // Update the registry and return the package     EPackage.Registry.INSTANCE.put(BacktrackingBug325745TestLanguagePackage.eNS_URI, theBacktrackingBug325745TestLanguagePackage);     return theBacktrackingBug325745TestLanguagePackage;   }    /**    *     *     * @generated    */   public EClass getModel()   {     return modelEClass;   }    /**    *     *     * @generated    */   public EReference getModel_Fields()   {     return (EReference)modelEClass.getEStructuralFeatures().get(0);   }    /**    *     *     * @generated    */   public EClass getElement()   {     return elementEClass;   }    /**    *     *     * @generated    */   public EAttribute getElement_Name()   {     return (EAttribute)elementEClass.getEStructuralFeatures().get(0);   }    /**    *     *     * @generated    */   public EReference getElement_DataType()   {     return (EReference)elementEClass.getEStructuralFeatures().get(1);   }    /**    *     *     * @generated    */   public EReference getElement_Expression()   {     return (EReference)elementEClass.getEStructuralFeatures().get(2);   }    /**    *     *     * @generated    */   public EClass getDataType()   {     return dataTypeEClass;   }    /**    *     *     * @generated    */   public EAttribute getDataType_BaseType()   {     return (EAttribute)dataTypeEClass.getEStructuralFeatures().get(0);   }    /**    *     *     * @generated    */   public EAttribute getDataType_DefaultValue()   {     return (EAttribute)dataTypeEClass.getEStructuralFeatures().get(1);   }    /**    *     *     * @generated    */   public EClass getExpression()   {     return expressionEClass;   }    /**    *     *     * @generated    */   public EAttribute getExpression_Prefix()   {     return (EAttribute)expressionEClass.getEStructuralFeatures().get(0);   }    /**    *     *     * @generated    */   public EReference getExpression_Terms()   {     return (EReference)expressionEClass.getEStructuralFeatures().get(1);   }    /**    *     *     * @generated    */   public EAttribute getExpression_Postfix()   {     return (EAttribute)expressionEClass.getEStructuralFeatures().get(2);   }    /**    *     *     * @generated    */   public EClass getSimpleTerm()   {     return simpleTermEClass;   }    /**    *     *     * @generated    */   public EAttribute getSimpleTerm_LineCount()   {     return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(0);   }    /**    *     *     * @generated    */   public EAttribute getSimpleTerm_CharCount()   {     return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(1);   }    /**    *     *     * @generated    */   public EAttribute getSimpleTerm_CharSet()   {     return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(2);   }    /**    *     *     * @generated    */   public EAttribute getSimpleTerm_RefChar()   {     return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(3);   }    /**    *     *     * @generated    */   public BacktrackingBug325745TestLanguageFactory getBacktrackingBug325745TestLanguageFactory()   {     return (BacktrackingBug325745TestLanguageFactory)getEFactoryInstance();   }    /**    *     *     * @generated    */   private boolean isCreated = false;    /**    * Creates the meta-model objects for the package.  This method is    * guarded to have no affect on any invocation but its first.    *     *     * @generated    */   public void createPackageContents()   {     if (isCreated) return;     isCreated = true;      // Create classes and their features     modelEClass = createEClass(MODEL);     createEReference(modelEClass, MODEL__FIELDS);      elementEClass = createEClass(ELEMENT);     createEAttribute(elementEClass, ELEMENT__NAME);     createEReference(elementEClass, ELEMENT__DATA_TYPE);     createEReference(elementEClass, ELEMENT__EXPRESSION);      dataTypeEClass = createEClass(DATA_TYPE);     createEAttribute(dataTypeEClass, DATA_TYPE__BASE_TYPE);     createEAttribute(dataTypeEClass, DATA_TYPE__DEFAULT_VALUE);      expressionEClass = createEClass(EXPRESSION);     createEAttribute(expressionEClass, EXPRESSION__PREFIX);     createEReference(expressionEClass, EXPRESSION__TERMS);     createEAttribute(expressionEClass, EXPRESSION__POSTFIX);      simpleTermEClass = createEClass(SIMPLE_TERM);     createEAttribute(simpleTermEClass, SIMPLE_TERM__LINE_COUNT);     createEAttribute(simpleTermEClass, SIMPLE_TERM__CHAR_COUNT);     createEAttribute(simpleTermEClass, SIMPLE_TERM__CHAR_SET);     createEAttribute(simpleTermEClass, SIMPLE_TERM__REF_CHAR);   }    /**    *     *     * @generated    */   private boolean isInitialized = false;    /**    * Complete the initialization of the package and its meta-model.  This    * method is guarded to have no affect on any invocation but its first.    *     *     * @generated    */   public void initializePackageContents()   {     if (isInitialized) return;     isInitialized = true;      // Initialize package     setName(eNAME);     setNsPrefix(eNS_PREFIX);     setNsURI(eNS_URI);      // Obtain other dependent packages     EcorePackage theEcorePackage = (EcorePackage)EPackage.Registry.INSTANCE.getEPackage(EcorePackage.eNS_URI);      // Create type parameters      // Set bounds for type parameters      // Add supertypes to classes      // Initialize classes and features; add operations and parameters     initEClass(modelEClass, Model.class, &quot;Model&quot;, !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);     initEReference(getModel_Fields(), this.getElement(), null, &quot;fields&quot;, null, 0, -1, Model.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);      initEClass(elementEClass, Element.class, &quot;Element&quot;, !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);     initEAttribute(getElement_Name(), theEcorePackage.getEString(), &quot;name&quot;, null, 0, 1, Element.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEReference(getElement_DataType(), this.getDataType(), null, &quot;dataType&quot;, null, 0, 1, Element.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEReference(getElement_Expression(), this.getExpression(), null, &quot;expression&quot;, null, 0, 1, Element.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);      initEClass(dataTypeEClass, DataType.class, &quot;DataType&quot;, !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);     initEAttribute(getDataType_BaseType(), theEcorePackage.getEString(), &quot;baseType&quot;, null, 0, 1, DataType.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEAttribute(getDataType_DefaultValue(), theEcorePackage.getEString(), &quot;defaultValue&quot;, null, 0, 1, DataType.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);      initEClass(expressionEClass, Expression.class, &quot;Expression&quot;, !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);     initEAttribute(getExpression_Prefix(), theEcorePackage.getEString(), &quot;prefix&quot;, null, 0, 1, Expression.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEReference(getExpression_Terms(), this.getSimpleTerm(), null, &quot;terms&quot;, null, 0, -1, Expression.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEAttribute(getExpression_Postfix(), theEcorePackage.getEString(), &quot;postfix&quot;, null, 0, 1, Expression.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);      initEClass(simpleTermEClass, SimpleTerm.class, &quot;SimpleTerm&quot;, !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);     initEAttribute(getSimpleTerm_LineCount(), theEcorePackage.getEInt(), &quot;lineCount&quot;, null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEAttribute(getSimpleTerm_CharCount(), theEcorePackage.getEInt(), &quot;charCount&quot;, null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEAttribute(getSimpleTerm_CharSet(), theEcorePackage.getEString(), &quot;charSet&quot;, null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEAttribute(getSimpleTerm_RefChar(), theEcorePackage.getEString(), &quot;refChar&quot;, null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);      // Create resource     createResource(eNS_URI);   }  } //BacktrackingBug325745TestLanguagePackageImpl</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13726</td>
    <td align="left">https://github.com/eclipse/xtext-core/blob/e04964e4c2a3e0338c0079bd8333688835e77c31/org.eclipse.xtext.tests/src-gen/org/eclipse/xtext/parser/unorderedGroups/backtrackingBug325745TestLanguage/impl/BacktrackingBug325745TestLanguagePackageImpl.java/#L28-L426</td>
    <td align="right">1</td>
    <td align="right">4998</td>
    <td align="right">13726</td>
  </tr>
  <tr valign="top">
    <td align="right">2356</td>
    <td align="left">&nbsp;{ &quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Customer1953 {  	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id; 	private String firstName; 	private String lastName;  	protected Customer1953() {}  	public Customer1953(String firstName, String lastName) { 		this.firstName = firstName; 		this.lastName = lastName; 	}  	@Override 	public String toString() { 		return String.format(&quot;Customer1953[id=%d, firstName='%s', lastName='%s']&quot;, id, firstName, lastName); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14230</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer1953.java/#L8-L27</td>
    <td align="right">1</td>
    <td align="right">2356</td>
    <td align="right">14230</td>
  </tr>
  <tr valign="top">
    <td align="right">764</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @XmlRootElement(name = &quot;header&quot;)     @XmlAccessorType(XmlAccessType.FIELD)     public static class Header {          @XmlAttribute         private String key;          @XmlAttribute         private String type;          @XmlValue         private String value;          public String getKey() {             return key;         }          public void setKey(String key) {             this.key = key;         }          public String getType() {             return type;         }          public void setType(String type) {             this.type = type;         }          public String getValue() {             return value;         }          public void setValue(String value) {             this.value = value;         }     }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7134</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/core/camel-base/src/main/java/org/apache/camel/support/dump/MessageDump.java/#L41-L77</td>
    <td align="right">1</td>
    <td align="right">764</td>
    <td align="right">7134</td>
  </tr>
  <tr valign="top">
    <td align="right">659</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DefaultJobMasterServiceFactory implements JobMasterServiceFactory {  	private final JobMasterConfiguration jobMasterConfiguration;  	private final SlotPoolFactory slotPoolFactory;  	private final SchedulerFactory schedulerFactory;  	private final RpcService rpcService;  	private final HighAvailabilityServices haServices;  	private final JobManagerSharedServices jobManagerSharedServices;  	private final HeartbeatServices heartbeatServices;  	private final JobManagerJobMetricGroupFactory jobManagerJobMetricGroupFactory;  	private final FatalErrorHandler fatalErrorHandler;  	public DefaultJobMasterServiceFactory( 			JobMasterConfiguration jobMasterConfiguration, 			SlotPoolFactory slotPoolFactory, 			SchedulerFactory schedulerFactory, 			RpcService rpcService, 			HighAvailabilityServices haServices, 			JobManagerSharedServices jobManagerSharedServices, 			HeartbeatServices heartbeatServices, 			JobManagerJobMetricGroupFactory jobManagerJobMetricGroupFactory, 			FatalErrorHandler fatalErrorHandler) { 		this.jobMasterConfiguration = jobMasterConfiguration; 		this.slotPoolFactory = slotPoolFactory; 		this.schedulerFactory = schedulerFactory; 		this.rpcService = rpcService; 		this.haServices = haServices; 		this.jobManagerSharedServices = jobManagerSharedServices; 		this.heartbeatServices = heartbeatServices; 		this.jobManagerJobMetricGroupFactory = jobManagerJobMetricGroupFactory; 		this.fatalErrorHandler = fatalErrorHandler; 	}  	@Override 	public JobMaster createJobMasterService(JobGraph jobGraph, OnCompletionActions jobCompletionActions, ClassLoader userCodeClassloader) throws Exception { 		return new JobMaster( 			rpcService, 			jobMasterConfiguration, 			ResourceID.generate(), 			jobGraph, 			haServices, 			slotPoolFactory, 			schedulerFactory, 			jobManagerSharedServices, 			heartbeatServices, 			jobManagerJobMetricGroupFactory, 			jobCompletionActions, 			fatalErrorHandler, 			userCodeClassloader); 	} }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6424</td>
    <td align="left">https://github.com/apache/flink/blob/8068c8775ad067d75828e6360e7e0994348da9b9/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/factories/DefaultJobMasterServiceFactory.java/#L37-L95</td>
    <td align="right">1</td>
    <td align="right">659</td>
    <td align="right">6424</td>
  </tr>
  <tr valign="top">
    <td align="right">3994</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{   &quot;response&quot;: &quot;YES I found bad smells&quot;,   &quot;bad_smells&quot;: [     &quot;1. Data Class&quot;   ] }  </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LiteralKey {      private Object value;      private String type;      private String lang;      public LiteralKey(Object value, String type, String lang) {         this.value = value;         this.type = type != null ? type.intern() : null;         this.lang = lang != null ? lang.intern() : null;     }      public String getLang() {         return lang;     }      public String getType() {         return type;     }      public Object getValue() {         return value;     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (o == null || getClass() != o.getClass()) return false;          LiteralKey that = (LiteralKey) o;          if (lang != null ? !lang.equals(that.lang) : that.lang != null) return false;         if (type != null ? !type.equals(that.type) : that.type != null) return false;         return value.equals(that.value);      }      @Override     public int hashCode() {         int result = value.hashCode();         result = 31 * result + (type != null ? type.hashCode() : 0);         result = 31 * result + (lang != null ? lang.hashCode() : 0);         return result;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10543</td>
    <td align="left">https://github.com/apache/marmotta/blob/28c9b8b0791ea1693578af302981a1358e56933d/commons/marmotta-commons/src/main/java/org/apache/marmotta/commons/sesame/model/LiteralKey.java/#L25-L71</td>
    <td align="right">1</td>
    <td align="right">3994</td>
    <td align="right">10543</td>
  </tr>
  <tr valign="top">
    <td align="right">2465</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells the bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
class Segment {     private byte segmentType;      Segment(byte segmentType) {         this.segmentType = segmentType;     }      /**      * Returns the segmentType value.      *       * @return byte segmentType value.      */     public byte getSegmentType() {         return segmentType;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14561</td>
    <td align="left">https://github.com/Microsoft/mssql-jdbc/blob/84484edf7944de56749fd2648d0af2ffa2459b7a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java/#L1932-L1947</td>
    <td align="right">1</td>
    <td align="right">2465</td>
    <td align="right">14561</td>
  </tr>
  <tr valign="top">
    <td align="right">391</td>
    <td align="left">&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [         &quot;Long method&quot;,         &quot;Duplicate code&quot;,         &quot;Deeply nested code&quot;,         &quot;Feature envy&quot;,         &quot;Data class&quot;,         &quot;Shotgun surgery&quot;     ] }</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells).<br />
 Could you please identify which smells occur in the following code? However, do not describe the smells,<br />
 just list them. <br />
Please start your answer with &quot;YES I found bad smells&quot; when you find any bad smell. <br />
Otherwise, start your answer with &quot;NO, I did not find any bad smell&quot;. <br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells<br />
are:&quot; amongst the text your answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
final class PolyglotExceptionImpl extends AbstractExceptionImpl implements com.oracle.truffle.polyglot.PolyglotImpl.VMObject {      private static final String CAUSE_CAPTION = &quot;Caused by host exception: &quot;;      private static final boolean TRACE_STACK_TRACE_WALKING = false;      private PolyglotException api;      final PolyglotContextImpl context;     private final PolyglotEngineImpl engine;     final Throwable exception;     private final List guestFrames;      private StackTraceElement[] javaStackTrace;     private List materializedFrames;      private final SourceSection sourceLocation;     private final boolean internal;     private final boolean cancelled;     private final boolean exit;     private final boolean incompleteSource;     private final boolean syntaxError;     private final int exitStatus;     private final Value guestObject;     private final String message;     private Object fileSystemContext;      // Exception coming from a language     PolyglotExceptionImpl(PolyglotLanguageContext languageContext, Throwable original) {         this(languageContext.getImpl(), languageContext.getEngine(), languageContext, original);     }      // Exception coming from an instrument     PolyglotExceptionImpl(PolyglotEngineImpl engine, Throwable original) {         this(engine.impl, engine, null, original);     }      private PolyglotExceptionImpl(AbstractPolyglotImpl impl, PolyglotEngineImpl engine, PolyglotLanguageContext languageContext, Throwable original) {         super(impl);         Objects.requireNonNull(engine);         this.engine = engine;         this.context = (languageContext != null) ? languageContext.context : null;         this.exception = original;         this.guestFrames = TruffleStackTrace.getStackTrace(original);          if (exception instanceof TruffleException) {             TruffleException truffleException = (TruffleException) exception;             this.internal = truffleException.isInternalError();             this.cancelled = truffleException.isCancelled();             this.syntaxError = truffleException.isSyntaxError();             this.incompleteSource = truffleException.isIncompleteSource();             this.exit = truffleException.isExit();             this.exitStatus = this.exit ? truffleException.getExitStatus() : 0;              com.oracle.truffle.api.source.SourceSection section = truffleException.getSourceLocation();             if (section != null) {                 Objects.requireNonNull(languageContext, &quot;Source location can not be accepted without language context.&quot;);                 com.oracle.truffle.api.source.Source truffleSource = section.getSource();                 String language = truffleSource.getLanguage();                 if (language == null) {                     PolyglotLanguage foundLanguage = languageContext.getEngine().findLanguage(language, truffleSource.getMimeType(), false);                     if (foundLanguage != null) {                         language = foundLanguage.getId();                     }                 }                 Source source = getAPIAccess().newSource(language, truffleSource);                 this.sourceLocation = getAPIAccess().newSourceSection(source, section);             } else {                 this.sourceLocation = null;             }             Object exceptionObject;             if (languageContext != null &amp;&amp; !(exception instanceof HostException) &amp;&amp; (exceptionObject = ((TruffleException) exception).getExceptionObject()) != null) {                 /*                  * Allow proxies in guest language objects. This is for legacy support. Ideally we                  * should get rid of this if it is no longer relied upon.                  */                 Object receiver = exceptionObject;                 if (receiver instanceof Proxy) {                     receiver = languageContext.toGuestValue(receiver);                 }                 this.guestObject = languageContext.asValue(receiver);             } else {                 this.guestObject = null;             }         } else {             this.cancelled = false;             this.internal = true;             this.syntaxError = false;             this.incompleteSource = false;             this.exit = false;             this.exitStatus = 0;             this.sourceLocation = null;             this.guestObject = null;         }         if (isHostException()) {             this.message = asHostException().getMessage();         } else {             if (internal) {                 this.message = exception.toString();             } else {                 this.message = exception.getMessage();             }         }          // late materialization of host frames. only needed if polyglot exceptions cross the         // host boundary.         VMAccessor.LANGUAGE.materializeHostFrames(original);     }      @Override     public boolean equals(Object obj) {         if (obj instanceof PolyglotExceptionImpl) {             return exception == ((PolyglotExceptionImpl) obj).exception;         }         return false;     }      @Override     public int hashCode() {         return exception.hashCode();     }      @Override     public org.graalvm.polyglot.SourceSection getSourceLocation() {         return sourceLocation;     }      @Override     public void onCreate(PolyglotException instance) {         this.api = instance;     }      @Override     public boolean isHostException() {         return exception instanceof HostException;     }      @Override     public Throwable asHostException() {         if (!(exception instanceof HostException)) {             throw new PolyglotUnsupportedException(                             String.format(&quot;Unsupported operation %s.%s. You can ensure that the operation is supported using %s.%s.&quot;,                                             PolyglotException.class.getSimpleName(), &quot;asHostException()&quot;,                                             PolyglotException.class.getSimpleName(), &quot;isHostException()&quot;));         }         return ((HostException) exception).getOriginal();     }      @Override     public void printStackTrace(PrintWriter s) {         printStackTrace(new WrappedPrintWriter(s));     }      @Override     public void printStackTrace(PrintStream s) {         printStackTrace(new WrappedPrintStream(s));     }      private void printStackTrace(PrintStreamOrWriter s) {         // Guard against malicious overrides of Throwable.equals by         // using a Set with identity equality semantics.         synchronized (s.lock()) {             // Print our stack trace             if (isInternalError() || getMessage() == null || getMessage().isEmpty()) {                 s.println(api);             } else {                 s.println(getMessage());             }              materialize();             int languageIdLength = 0; // java             for (StackFrame traceElement : getPolyglotStackTrace()) {                 if (!traceElement.isHostFrame()) {                     languageIdLength = Math.max(languageIdLength, getAPIAccess().getImpl(traceElement).getLanguage().getId().length());                 }             }              for (StackFrame traceElement : getPolyglotStackTrace()) {                 s.println(&quot;\tat &quot; + getAPIAccess().getImpl(traceElement).toStringImpl(languageIdLength));             }              // Print cause, if any             if (isHostException()) {                 s.println(CAUSE_CAPTION + asHostException());             }             if (isInternalError()) {                 s.println(&quot;Original Internal Error: &quot;);                 s.printStackTrace(exception);             }         }     }      @Override     public String getMessage() {         return message;     }      public StackTraceElement[] getJavaStackTrace() {         if (javaStackTrace == null) {             materialize();             javaStackTrace = new StackTraceElement[materializedFrames.size()];             for (int i = 0; i &lt; javaStackTrace.length; i++) {                 javaStackTrace[i] = materializedFrames.get(i).toHostFrame();             }         }         return javaStackTrace;     }      private void materialize() {         if (this.materializedFrames == null) {             List frames = new ArrayList&lt;&gt;();             for (StackFrame frame : getPolyglotStackTrace()) {                 frames.add(frame);             }             this.materializedFrames = Collections.unmodifiableList(frames);         }     }      @Override     public StackTraceElement[] getStackTrace() {         return getJavaStackTrace().clone();     }      @Override     public PolyglotEngineImpl getEngine() {         return engine;     }      @Override     public boolean isInternalError() {         return internal;     }      @Override     public Iterable getPolyglotStackTrace() {         if (materializedFrames != null) {             return materializedFrames;         } else {             return new Iterable() {                 public Iterator iterator() {                     return new StackFrameIterator(PolyglotExceptionImpl.this);                 }             };         }     }      @Override     public boolean isCancelled() {         return cancelled;     }      @Override     public boolean isExit() {         return exit;     }      @Override     public boolean isIncompleteSource() {         return incompleteSource;     }      @Override     public int getExitStatus() {         return exitStatus;     }      @Override     public boolean isSyntaxError() {         return syntaxError;     }      @Override     public Value getGuestObject() {         return guestObject;     }      Object getFileSystemContext() {         if (fileSystemContext != null) {             return fileSystemContext;         }         if (context == null) {             return null;         }         return VMAccessor.LANGUAGE.createFileSystemContext(context.config.fileSystem, context.engine.getFileTypeDetectorsSupplier());     }      /**      * Wrapper class for PrintStream and PrintWriter to enable a single implementation of      * printStackTrace.      */     private abstract static class PrintStreamOrWriter {         /** Returns the object to be locked when using this StreamOrWriter. */         abstract Object lock();          /** Prints the specified string as a line on this StreamOrWriter. */         abstract void println(Object o);          abstract void printStackTrace(Throwable t);     }      private static class WrappedPrintStream extends PrintStreamOrWriter {         private final PrintStream printStream;          WrappedPrintStream(PrintStream printStream) {             this.printStream = printStream;         }          @Override         Object lock() {             return printStream;         }          @Override         void println(Object o) {             printStream.println(o);         }          @Override         void printStackTrace(Throwable t) {             t.printStackTrace(printStream);         }     }      private static class WrappedPrintWriter extends PrintStreamOrWriter {         private final PrintWriter printWriter;          WrappedPrintWriter(PrintWriter printWriter) {             this.printWriter = printWriter;         }          @Override         Object lock() {             return printWriter;         }          @Override         void println(Object o) {             printWriter.println(o);         }          @Override         void printStackTrace(Throwable t) {             t.printStackTrace(printWriter);         }     }      private static class StackFrameIterator implements Iterator {          private static final String POLYGLOT_PACKAGE = Engine.class.getName().substring(0, Engine.class.getName().lastIndexOf('.') + 1);         private static final String HOST_INTEROP_PACKAGE = &quot;com.oracle.truffle.polyglot.&quot;;         private static final String[] JAVA_INTEROP_HOST_TO_GUEST = {                         HOST_INTEROP_PACKAGE + &quot;PolyglotMap&quot;,                         HOST_INTEROP_PACKAGE + &quot;PolyglotList&quot;,                         HOST_INTEROP_PACKAGE + &quot;PolyglotFunction&quot;,                         HOST_INTEROP_PACKAGE + &quot;FunctionProxyHandler&quot;,                         HOST_INTEROP_PACKAGE + &quot;ObjectProxyHandler&quot;         };          final PolyglotExceptionImpl impl;         final Iterator guestFrames;         final StackTraceElement[] hostStack;         final ListIterator hostFrames;         /*          * Initial host frames are skipped if the error is a regular non-internal guest language          * error.          */         final APIAccess apiAccess;          boolean inHostLanguage;         boolean firstGuestFrame = true;         PolyglotExceptionFrame fetchedNext;          StackFrameIterator(PolyglotExceptionImpl impl) {             this.impl = impl;             this.apiAccess = impl.getAPIAccess();              Throwable cause = impl.exception;             while (cause.getCause() != null &amp;&amp; cause.getStackTrace().length == 0) {                 if (cause instanceof HostException) {                     cause = ((HostException) cause).getOriginal();                 } else {                     cause = cause.getCause();                 }             }             if (VMAccessor.LANGUAGE.isTruffleStackTrace(cause)) {                 this.hostStack = VMAccessor.LANGUAGE.getInternalStackTraceElements(cause);             } else if (cause.getStackTrace() == null || cause.getStackTrace().length == 0) {                 this.hostStack = impl.exception.getStackTrace();             } else {                 this.hostStack = cause.getStackTrace();             }             this.guestFrames = impl.guestFrames == null ? Collections. emptyList().iterator() : impl.guestFrames.iterator();             this.hostFrames = Arrays.asList(hostStack).listIterator();             // we always start in some host stack frame             this.inHostLanguage = impl.isHostException() || impl.isInternalError();              if (TRACE_STACK_TRACE_WALKING) {                 // To mark the beginning of the stack trace and separate from the previous one                 PrintStream out = System.out;                 out.println();             }         }          public boolean hasNext() {             return fetchNext() != null;         }          public StackFrame next() {             PolyglotExceptionFrame next = fetchNext();             if (next == null) {                 throw new NoSuchElementException();             }             fetchedNext = null;             return apiAccess.newPolyglotStackTraceElement(impl.api, next);         }          PolyglotExceptionFrame fetchNext() {             if (fetchedNext != null) {                 return fetchedNext;             }              while (hostFrames.hasNext()) {                 StackTraceElement element = hostFrames.next();                 traceStackTraceElement(element);                 // we need to flip inHostLanguage state in opposite order as the stack is top to                 // bottom.                 if (inHostLanguage) {                     int guestToHost = isGuestToHost(element, hostStack, hostFrames.nextIndex());                     if (guestToHost &gt;= 0) {                         assert !isHostToGuest(element);                         inHostLanguage = false;                          for (int i = 0; i &lt; guestToHost; i++) {                             assert isGuestToHostReflectiveCall(element);                             element = hostFrames.next();                             traceStackTraceElement(element);                         }                          assert isGuestToHostCallFromHostInterop(element);                     }                 } else {                     if (isHostToGuest(element)) {                         inHostLanguage = true;                          // skip extra host-to-guest frames                         while (hostFrames.hasNext()) {                             StackTraceElement next = hostFrames.next();                             traceStackTraceElement(next);                             if (isHostToGuest(next)) {                                 element = next;                             } else {                                 hostFrames.previous();                                 break;                             }                         }                     }                 }                  if (isGuestCall(element)) {                     inHostLanguage = false;                     // construct guest frame                     TruffleStackTraceElement guestFrame = null;                     if (guestFrames.hasNext()) {                         guestFrame = guestFrames.next();                     }                     PolyglotExceptionFrame frame = PolyglotExceptionFrame.createGuest(impl, guestFrame, firstGuestFrame);                     firstGuestFrame = false;                     if (frame != null) {                         fetchedNext = frame;                         return fetchedNext;                     }                 } else if (inHostLanguage) {                     // construct host frame                     fetchedNext = (PolyglotExceptionFrame.createHost(impl, element));                     return fetchedNext;                 } else {                     // skip stack frame that is part of guest language stack                 }             }              // consume guest frames             if (guestFrames.hasNext()) {                 TruffleStackTraceElement guestFrame = guestFrames.next();                 PolyglotExceptionFrame frame = PolyglotExceptionFrame.createGuest(impl, guestFrame, firstGuestFrame);                 firstGuestFrame = false;                 if (frame != null) {                     fetchedNext = frame;                     return fetchedNext;                 }             }              return null;         }          static boolean isLazyStackTraceElement(StackTraceElement element) {             return element == null;         }          static boolean isGuestCall(StackTraceElement element) {             return isLazyStackTraceElement(element) || VMAccessor.SPI.isGuestCallStackElement(element);         }          static boolean isHostToGuest(StackTraceElement element) {             if (isLazyStackTraceElement(element)) {                 return false;             }             if (element.getClassName().startsWith(POLYGLOT_PACKAGE) &amp;&amp; element.getClassName().indexOf('.', POLYGLOT_PACKAGE.length()) &lt; 0) {                 return true;             } else if (element.getClassName().startsWith(HOST_INTEROP_PACKAGE)) {                 for (String hostToGuestClassName : JAVA_INTEROP_HOST_TO_GUEST) {                     if (element.getClassName().equals(hostToGuestClassName)) {                         return true;                     }                 }             }             return false;         }          // Return the number of frames with reflective calls to skip         static int isGuestToHost(StackTraceElement firstElement, StackTraceElement[] hostStack, int nextElementIndex) {             if (isLazyStackTraceElement(firstElement)) {                 return -1;             }              StackTraceElement element = firstElement;             int index = nextElementIndex;             while (isGuestToHostReflectiveCall(element) &amp;&amp; nextElementIndex &lt; hostStack.length) {                 element = hostStack[index++];             }             if (isGuestToHostCallFromHostInterop(element)) {                 return index - nextElementIndex;             } else {                 return -1;             }         }          private static boolean isGuestToHostCallFromHostInterop(StackTraceElement element) {             switch (element.getClassName()) {                 case &quot;com.oracle.truffle.polyglot.HostMethodDesc$SingleMethod$MHBase&quot;:                     return element.getMethodName().equals(&quot;invokeHandle&quot;);                 case &quot;com.oracle.truffle.polyglot.HostMethodDesc$SingleMethod$MethodReflectImpl&quot;:                     return element.getMethodName().equals(&quot;reflectInvoke&quot;);                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$ExecuteNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$InstantiateNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$AsPointerNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$ArrayGetNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$ArraySetNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$ArrayRemoveNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$ArraySizeNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$GetMemberKeysNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$PutMemberNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$RemoveMemberNode&quot;:                 case &quot;com.oracle.truffle.polyglot.PolyglotProxy$HasMemberNode&quot;:                     return element.getMethodName().equals(&quot;executeImpl&quot;);                 default:                     return false;             }         }          private static boolean isGuestToHostReflectiveCall(StackTraceElement element) {             switch (element.getClassName()) {                 case &quot;sun.reflect.NativeMethodAccessorImpl&quot;:                 case &quot;sun.reflect.DelegatingMethodAccessorImpl&quot;:                 case &quot;jdk.internal.reflect.NativeMethodAccessorImpl&quot;:                 case &quot;jdk.internal.reflect.DelegatingMethodAccessorImpl&quot;:                 case &quot;java.lang.reflect.Method&quot;:                     return element.getMethodName().startsWith(&quot;invoke&quot;);                 default:                     return false;             }         }          private void traceStackTraceElement(StackTraceElement element) {             if (TRACE_STACK_TRACE_WALKING) {                 PrintStream out = System.out;                 out.printf(&quot;host: %5s, guestToHost: %2s, hostToGuest: %5s, guestCall: %5s, -- %s %n&quot;, inHostLanguage,                                 isGuestToHost(element, hostStack, hostFrames.nextIndex()), isHostToGuest(element),                                 isGuestCall(element), element);             }         }     }  }</td>
    <td align="left">data class</td>
    <td align="left">long method, duplicate code, deeply nested code, feature envy, data class, shotgun surgery</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method,  duplicate code,  deeply nested code,  feature envy,  shotgun surgery</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">3964</td>
    <td align="left">https://github.com/oracle/graal/blob/4deb681aaaa79c248115037fc8e399c9876619fd/truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotExceptionImpl.java/#L69-L651</td>
    <td align="right">2</td>
    <td align="right">391</td>
    <td align="right">3964</td>
  </tr>
  <tr valign="top">
    <td align="right">2325</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TransportConnectionState extends org.apache.activemq.state.ConnectionState {      private ConnectionContext context;     private TransportConnection connection;     private AtomicInteger referenceCounter = new AtomicInteger();     private final Object connectionMutex = new Object();      public TransportConnectionState(ConnectionInfo info, TransportConnection transportConnection) {         super(info);         connection = transportConnection;     }      public ConnectionContext getContext() {         return context;     }      public TransportConnection getConnection() {         return connection;     }      public void setContext(ConnectionContext context) {         this.context = context;     }      public void setConnection(TransportConnection connection) {         this.connection = connection;     }      public int incrementReference() {         return referenceCounter.incrementAndGet();     }      public int decrementReference() {         return referenceCounter.decrementAndGet();     }  	public AtomicInteger getReferenceCounter() { 		return referenceCounter; 	}  	public void setReferenceCounter(AtomicInteger referenceCounter) { 		this.referenceCounter = referenceCounter; 	}  	public Object getConnectionMutex() { 		return connectionMutex; 	} }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14140</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-broker/src/main/java/org/apache/activemq/broker/TransportConnectionState.java/#L27-L74</td>
    <td align="right">1</td>
    <td align="right">2325</td>
    <td align="right">14140</td>
  </tr>
  <tr valign="top">
    <td align="right">2233</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;response&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Customer1762 {  	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id; 	private String firstName; 	private String lastName;  	protected Customer1762() {}  	public Customer1762(String firstName, String lastName) { 		this.firstName = firstName; 		this.lastName = lastName; 	}  	@Override 	public String toString() { 		return String.format(&quot;Customer1762[id=%d, firstName='%s', lastName='%s']&quot;, id, firstName, lastName); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13595</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer1762.java/#L8-L27</td>
    <td align="right">1</td>
    <td align="right">2233</td>
    <td align="right">13595</td>
  </tr>
  <tr valign="top">
    <td align="right">2178</td>
    <td align="left">&nbsp;{ &quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    class LastAck {         long lastAckedSequence;         byte priority;          public LastAck(LastAck source) {             this.lastAckedSequence = source.lastAckedSequence;             this.priority = source.priority;         }          public LastAck() {             this.priority = MessageOrderIndex.HI;         }          public LastAck(long ackLocation) {             this.lastAckedSequence = ackLocation;             this.priority = MessageOrderIndex.LO;         }          public LastAck(long ackLocation, byte priority) {             this.lastAckedSequence = ackLocation;             this.priority = priority;         }          @Override         public String toString() {             return &quot;[&quot; + lastAckedSequence + &quot;:&quot; + priority + &quot;]&quot;;         }     }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13410</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-kahadb-store/src/main/java/org/apache/activemq/store/kahadb/MessageDatabase.java/#L2313-L2340</td>
    <td align="right">1</td>
    <td align="right">2178</td>
    <td align="right">13410</td>
  </tr>
  <tr valign="top">
    <td align="right">2020</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;output&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
class CFRouteImpl implements CFRoute {  	final private String domain; 	final private String host; 	final private String path; 	final private int port; 	final private String fullRoute;  	CFRouteImpl(String domain, String host, String path, int port, String fullRoute)  { 		super(); 		this.domain = domain; 		this.host = host; 		this.path = path; 		this.port = port; 		this.fullRoute = fullRoute; 	}  	public String getDomain() { 		return domain; 	}  	public String getHost() { 		return host; 	}  	public String getPath() { 		return path; 	}  	public int getPort() { 		return port; 	}  	public String getRoute() { 		return fullRoute; 	}  	@Override 	public String toString() { 		return &quot;CFRoute [domain=&quot; + domain + &quot;, host=&quot; + host + &quot;, path=&quot; + path + &quot;, port=&quot; + port  +&quot;]&quot;; 	}   	@Override 	public int hashCode() { 		final int prime = 31; 		int result = 1; 		result = prime * result + ((domain == null) ? 0 : domain.hashCode()); 		result = prime * result + ((fullRoute == null) ? 0 : fullRoute.hashCode()); 		result = prime * result + ((host == null) ? 0 : host.hashCode()); 		result = prime * result + ((path == null) ? 0 : path.hashCode()); 		result = prime * result + port; 		return result; 	}  	@Override 	public boolean equals(Object obj) { 		if (this == obj) 			return true; 		if (obj == null) 			return false; 		if (getClass() != obj.getClass()) 			return false; 		CFRouteImpl other = (CFRouteImpl) obj; 		if (domain == null) { 			if (other.domain != null) 				return false; 		} else if (!domain.equals(other.domain)) 			return false; 		if (fullRoute == null) { 			if (other.fullRoute != null) 				return false; 		} else if (!fullRoute.equals(other.fullRoute)) 			return false; 		if (host == null) { 			if (other.host != null) 				return false; 		} else if (!host.equals(other.host)) 			return false; 		if (path == null) { 			if (other.path != null) 				return false; 		} else if (!path.equals(other.path)) 			return false; 		if (port != other.port) 			return false; 		return true; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12785</td>
    <td align="left">https://github.com/spring-projects/sts4/blob/46e9e985b0c5e28ea1952d9fc640ec12fd9c8fdd/headless-services/commons/commons-cf/src/main/java/org/springframework/ide/vscode/commons/cloudfoundry/client/CFRouteImpl.java/#L3-L92</td>
    <td align="right">1</td>
    <td align="right">2020</td>
    <td align="right">12785</td>
  </tr>
  <tr valign="top">
    <td align="right">2225</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells\nthe bad smells are:\n1. Data Class&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public static class Undertow {  		/** 		 * Maximum size of the HTTP post content. When the value is -1, the default, the 		 * size is unlimited. 		 */ 		private DataSize maxHttpPostSize = DataSize.ofBytes(-1);  		/** 		 * Size of each buffer. The default is derived from the maximum amount of memory 		 * that is available to the JVM. 		 */ 		private DataSize bufferSize;  		/** 		 * Number of I/O threads to create for the worker. The default is derived from the 		 * number of available processors. 		 */ 		private Integer ioThreads;  		/** 		 * Number of worker threads. The default is 8 times the number of I/O threads. 		 */ 		private Integer workerThreads;  		/** 		 * Whether to allocate buffers outside the Java heap. The default is derived from 		 * the maximum amount of memory that is available to the JVM. 		 */ 		private Boolean directBuffers;  		/** 		 * Whether servlet filters should be initialized on startup. 		 */ 		private boolean eagerFilterInit = true;  		private final Accesslog accesslog = new Accesslog();  		public DataSize getMaxHttpPostSize() { 			return this.maxHttpPostSize; 		}  		public void setMaxHttpPostSize(DataSize maxHttpPostSize) { 			this.maxHttpPostSize = maxHttpPostSize; 		}  		public DataSize getBufferSize() { 			return this.bufferSize; 		}  		public void setBufferSize(DataSize bufferSize) { 			this.bufferSize = bufferSize; 		}  		public Integer getIoThreads() { 			return this.ioThreads; 		}  		public void setIoThreads(Integer ioThreads) { 			this.ioThreads = ioThreads; 		}  		public Integer getWorkerThreads() { 			return this.workerThreads; 		}  		public void setWorkerThreads(Integer workerThreads) { 			this.workerThreads = workerThreads; 		}  		public Boolean getDirectBuffers() { 			return this.directBuffers; 		}  		public void setDirectBuffers(Boolean directBuffers) { 			this.directBuffers = directBuffers; 		}  		public boolean isEagerFilterInit() { 			return this.eagerFilterInit; 		}  		public void setEagerFilterInit(boolean eagerFilterInit) { 			this.eagerFilterInit = eagerFilterInit; 		}  		public Accesslog getAccesslog() { 			return this.accesslog; 		}  		/** 		 * Undertow access log properties. 		 */ 		public static class Accesslog {  			/** 			 * Whether to enable the access log. 			 */ 			private boolean enabled = false;  			/** 			 * Format pattern for access logs. 			 */ 			private String pattern = &quot;common&quot;;  			/** 			 * Log file name prefix. 			 */ 			protected String prefix = &quot;access_log.&quot;;  			/** 			 * Log file name suffix. 			 */ 			private String suffix = &quot;log&quot;;  			/** 			 * Undertow access log directory. 			 */ 			private File dir = new File(&quot;logs&quot;);  			/** 			 * Whether to enable access log rotation. 			 */ 			private boolean rotate = true;  			public boolean isEnabled() { 				return this.enabled; 			}  			public void setEnabled(boolean enabled) { 				this.enabled = enabled; 			}  			public String getPattern() { 				return this.pattern; 			}  			public void setPattern(String pattern) { 				this.pattern = pattern; 			}  			public String getPrefix() { 				return this.prefix; 			}  			public void setPrefix(String prefix) { 				this.prefix = prefix; 			}  			public String getSuffix() { 				return this.suffix; 			}  			public void setSuffix(String suffix) { 				this.suffix = suffix; 			}  			public File getDir() { 				return this.dir; 			}  			public void setDir(File dir) { 				this.dir = dir; 			}  			public boolean isRotate() { 				return this.rotate; 			}  			public void setRotate(boolean rotate) { 				this.rotate = rotate; 			}  		}  	}</td>
    <td align="left">data class</td>
    <td align="left">\n1. data class </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13573</td>
    <td align="left">https://github.com/spring-projects/spring-boot/blob/2225b362991f225e3a93f00e160526d2b8abdfb2/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java/#L949-L1124</td>
    <td align="right">1</td>
    <td align="right">2225</td>
    <td align="right">13573</td>
  </tr>
  <tr valign="top">
    <td align="right">2126</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES, I found bad smells.&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class Value {         int        count = 0;         BigInteger txid;     }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13221</td>
    <td align="left">https://github.com/alibaba/jstorm/blob/5d6cde22dbca7df3d6e6830bf94f98a6639ab559/example/sequence-split-merge/src/main/java/com/alipay/dw/jstorm/transcation/TransactionalGlobalCount.java/#L93-L96</td>
    <td align="right">1</td>
    <td align="right">2126</td>
    <td align="right">13221</td>
  </tr>
  <tr valign="top">
    <td align="right">1808</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class User {   private String name = &quot;nameA&quot;;    private int age = 100;    private int index;    private String[] names;    public String getName() {     return name;   }    public void setName(String name) {     this.name = name;   }    public String[] getNames() {     return names;   }    public void setNames(String[] names) {     this.names = names;   }    public int getAge() {     return age;   }    public void setAge(int age) {     this.age = age;   }    public int getIndex() {     return index;   }    public void setIndex(int index) {     this.index = index;   }    @Override   public String toString() {     return &quot;User [name=&quot; + name + &quot;, age=&quot; + age + &quot;, index=&quot; + index + &quot;]&quot;;   }    public String jsonString() {     try {       return JsonUtils.writeValueAsString(this);     } catch (JsonProcessingException e) {       throw new IllegalStateException(e);     }   } }</td>
    <td align="left">data class</td>
    <td align="left">Data Class, Long Method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12049</td>
    <td align="left">https://github.com/apache/servicecomb-java-chassis/blob/72cd0e137c4a0c3b899adfa6e19e2fd590743014/integration-tests/it-common/src/main/java/org/apache/servicecomb/it/schema/User.java/#L23-L76</td>
    <td align="right">1</td>
    <td align="right">1808</td>
    <td align="right">12049</td>
  </tr>
  <tr valign="top">
    <td align="right">2406</td>
    <td align="left">&nbsp;YES, I found bad smells the bad smells are:  1. Long method 2. Feature envy  3. Data class without behavior  4. Inappropriate name for entity class 5. Inconsistent formatting and spacing</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
@Entity public class Customer223 {  	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id; 	private String firstName; 	private String lastName;  	protected Customer223() {}  	public Customer223(String firstName, String lastName) { 		this.firstName = firstName; 		this.lastName = lastName; 	}  	@Override 	public String toString() { 		return String.format(&quot;Customer223[id=%d, firstName='%s', lastName='%s']&quot;, id, firstName, lastName); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method2 Feature envy 3 Data class without behavior 4 Inappropriate name for entity class5 Inconsistent formatting and spacing</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14388</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer223.java/#L8-L27</td>
    <td align="right">2</td>
    <td align="right">2406</td>
    <td align="right">14388</td>
  </tr>
  <tr valign="top">
    <td align="right">1902</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;2. Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SSLConfigClient extends SSLConfig {    private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(SSLConfigClient.class);    private final Properties properties;   private final boolean userSslEnabled;   private final String trustStoreType;   private final String trustStorePath;   private final String trustStorePassword;   private final boolean disableHostVerification;   private final boolean disableCertificateVerification;   private final boolean useSystemTrustStore;   private final String protocol;   private final int handshakeTimeout;   private final String provider;    private final String emptyString = new String();    public SSLConfigClient(Properties properties) throws DrillException {     this.properties = properties;     userSslEnabled = getBooleanProperty(DrillProperties.ENABLE_TLS);     trustStoreType = getStringProperty(DrillProperties.TRUSTSTORE_TYPE, &quot;JKS&quot;);     trustStorePath = getStringProperty(DrillProperties.TRUSTSTORE_PATH, &quot;&quot;);     trustStorePassword = getStringProperty(DrillProperties.TRUSTSTORE_PASSWORD, &quot;&quot;);     disableHostVerification = getBooleanProperty(DrillProperties.DISABLE_HOST_VERIFICATION);     disableCertificateVerification = getBooleanProperty(DrillProperties.DISABLE_CERT_VERIFICATION);     useSystemTrustStore = getBooleanProperty(DrillProperties.USE_SYSTEM_TRUSTSTORE);     protocol = getStringProperty(DrillProperties.TLS_PROTOCOL, DEFAULT_SSL_PROTOCOL);     int hsTimeout = getIntProperty(DrillProperties.TLS_HANDSHAKE_TIMEOUT, DEFAULT_SSL_HANDSHAKE_TIMEOUT_MS);     if (hsTimeout &lt;= 0) {       hsTimeout = DEFAULT_SSL_HANDSHAKE_TIMEOUT_MS;     }     handshakeTimeout = hsTimeout;     // If provider is OPENSSL then to debug or run this code in an IDE, you will need to enable     // the dependency on netty-tcnative with the correct classifier for the platform you use.     // This can be done by enabling the openssl profile.     // If the IDE is Eclipse, it requires you to install an additional Eclipse plugin available here:     // http://repo1.maven.org/maven2/kr/motd/maven/os-maven-plugin/1.6.1/os-maven-plugin-1.6.1.jar     // or from your local maven repository:     // ~/.m2/repository/kr/motd/maven/os-maven-plugin/1.6.1/os-maven-plugin-1.6.1.jar     // Note that installing this plugin may require you to start with a new workspace     provider = getStringProperty(DrillProperties.TLS_PROVIDER, DEFAULT_SSL_PROVIDER);   }    private boolean getBooleanProperty(String propName) {     return (properties != null) &amp;&amp; (properties.containsKey(propName))         &amp;&amp; (properties.getProperty(propName).compareToIgnoreCase(&quot;true&quot;) == 0);   }    private String getStringProperty(String name, String defaultValue) {     String value = &quot;&quot;;     if ( (properties != null) &amp;&amp; (properties.containsKey(name))) {       value = properties.getProperty(name);     }     if (value.isEmpty()) {       value = defaultValue;     }     value = value.trim();     return value;   }    private int getIntProperty(String name, int defaultValue) {     int value = defaultValue;     if (properties != null) {       String property = properties.getProperty(name);       if (property != null &amp;&amp; property.length() &gt; 0) {         value = Integer.decode(property);       }     }     return value;   }    public void validateKeyStore() throws DrillException {    }    @Override   public SslContext initNettySslContext() throws DrillException {     final SslContext sslCtx;      if (!userSslEnabled) {       return null;     }      TrustManagerFactory tmf;     try {       tmf = initializeTrustManagerFactory();       sslCtx = SslContextBuilder.forClient()           .sslProvider(getProvider())           .trustManager(tmf)           .protocols(protocol)           .build();     } catch (Exception e) {       // Catch any SSL initialization Exceptions here and abort.       throw new DrillException(new StringBuilder()           .append(&quot;SSL is enabled but cannot be initialized due to the following exception: &quot;)           .append(&quot;[ &quot;)           .append(e.getMessage())           .append(&quot;]. &quot;)           .toString());     }     this.nettySslContext = sslCtx;     return sslCtx;   }    @Override   public SSLContext initJDKSSLContext() throws DrillException {     final SSLContext sslCtx;      if (!userSslEnabled) {       return null;     }      TrustManagerFactory tmf;     try {       tmf = initializeTrustManagerFactory();       sslCtx = SSLContext.getInstance(protocol);       sslCtx.init(null, tmf.getTrustManagers(), null);     } catch (Exception e) {       // Catch any SSL initialization Exceptions here and abort.       throw new DrillException(new StringBuilder()           .append(&quot;SSL is enabled but cannot be initialized due to the following exception: &quot;)           .append(&quot;[ &quot;)           .append(e.getMessage())           .append(&quot;]. &quot;)           .toString());     }     this.jdkSSlContext = sslCtx;     return sslCtx;   }    @Override   public SSLEngine createSSLEngine(BufferAllocator allocator, String peerHost, int peerPort) {     SSLEngine engine = super.createSSLEngine(allocator, peerHost, peerPort);      if (!this.disableHostVerification()) {       SSLParameters sslParameters = engine.getSSLParameters();       // only available since Java 7       sslParameters.setEndpointIdentificationAlgorithm(&quot;HTTPS&quot;);       engine.setSSLParameters(sslParameters);     }      engine.setUseClientMode(true);      try {       engine.setEnableSessionCreation(true);     } catch (Exception e) {       // Openssl implementation may throw this.       logger.debug(&quot;Session creation not enabled. Exception: {}&quot;, e.getMessage());     }      return engine;   }    @Override   public boolean isUserSslEnabled() {     return userSslEnabled;   }    @Override   public boolean isHttpsEnabled() {     return false;   }    @Override   public String getKeyStoreType() {     return emptyString;   }    @Override   public String getKeyStorePath() {     return emptyString;   }    @Override   public String getKeyStorePassword() {     return emptyString;   }    @Override   public String getKeyPassword() {     return emptyString;   }    @Override   public String getTrustStoreType() {     return trustStoreType;   }    @Override   public boolean hasTrustStorePath() {     return !trustStorePath.isEmpty();   }    @Override   public String getTrustStorePath() {     return trustStorePath;   }    @Override   public boolean hasTrustStorePassword() {     return !trustStorePassword.isEmpty();   }    @Override   public String getTrustStorePassword() {     return trustStorePassword;   }    @Override   public String getProtocol() {     return protocol;   }    @Override   public SslProvider getProvider() {     return provider.equalsIgnoreCase(&quot;JDK&quot;) ? SslProvider.JDK : SslProvider.OPENSSL;   }    @Override   public int getHandshakeTimeout() {     return handshakeTimeout;   }    @Override   public Mode getMode() {     return Mode.CLIENT;   }    @Override   public boolean disableHostVerification() {     return disableHostVerification;   }    @Override   public boolean disableCertificateVerification() {     return disableCertificateVerification;   }    @Override   public boolean useSystemTrustStore() {     return useSystemTrustStore;   }    public boolean isSslValid() {     return true;   }  }</td>
    <td align="left">data class</td>
    <td align="left">2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">&nbsp; </td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">12364</td>
    <td align="left">https://github.com/apache/drill/blob/5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3/exec/java-exec/src/main/java/org/apache/drill/exec/ssl/SSLConfigClient.java/#L33-L281</td>
    <td align="right">1</td>
    <td align="right">1902</td>
    <td align="right">12364</td>
  </tr>
  <tr valign="top">
    <td align="right">806</td>
    <td align="left">&nbsp;{&quot;message&quot;:&quot;YES I found bad smells&quot;,&quot;detected_bad_smells&quot;:[&quot;Data Class&quot;,&quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class TemplateConfiguration extends Configurable implements ParserConfiguration {      private boolean parentConfigurationSet;     private Integer tagSyntax;     private Integer interpolationSyntax;     private Integer namingConvention;     private Boolean whitespaceStripping;     private Boolean strictSyntaxMode;     private Integer autoEscapingPolicy;     private Boolean recognizeStandardFileExtensions;     private OutputFormat outputFormat;     private String encoding;     private Integer tabSize;      /**      * Creates a new instance. The parent will be {@link Configuration#getDefaultConfiguration()} initially, but it will      * be changed to the real parent {@link Configuration} when this object is added to the {@link Configuration}. (It's      * not allowed to add the same instance to multiple {@link Configuration}-s).      */     public TemplateConfiguration() {         super(Configuration.getDefaultConfiguration());     }      /**      * Same as {@link #setParentConfiguration(Configuration)}.      */     @Override     void setParent(Configurable cfg) {         NullArgumentException.check(&quot;cfg&quot;, cfg);         if (!(cfg instanceof Configuration)) {             throw new IllegalArgumentException(&quot;The parent of a TemplateConfiguration can only be a Configuration&quot;);         }                  if (parentConfigurationSet) {             if (getParent() != cfg) {                 throw new IllegalStateException(                         &quot;This TemplateConfiguration is already associated with a different Configuration instance.&quot;);             }             return;         }                  if (((Configuration) cfg).getIncompatibleImprovements().intValue() &lt; _TemplateAPI.VERSION_INT_2_3_22                 &amp;&amp; hasAnyConfigurableSet()) {             throw new IllegalStateException(                     &quot;This TemplateConfiguration can't be associated to a Configuration that has &quot;                     + &quot;incompatibleImprovements less than 2.3.22, because it changes non-parser settings.&quot;);         }                  super.setParent(cfg);         parentConfigurationSet = true;     }      /**      * Associates this instance with a {@link Configuration}; usually you don't call this, as it's called internally      * when this instance is added to a {@link Configuration}. This method can be called only once (except with the same      * {@link Configuration} parameter again, as that changes nothing anyway).      *       * @throws IllegalArgumentException      *             if the argument is {@code null} or not a {@link Configuration}      * @throws IllegalStateException      *             if this object is already associated to a different {@link Configuration} object,      *             or if the {@code Configuration} has {@code #getIncompatibleImprovements()} less than 2.3.22 and      *             this object tries to change any non-parser settings        */     public void setParentConfiguration(Configuration cfg) {         setParent(cfg);     }      /**      * Returns the parent {@link Configuration}, or {@code null} if none was associated yet.      */     public Configuration getParentConfiguration() {         return parentConfigurationSet ? (Configuration) getParent() : null;     }      private Configuration getNonNullParentConfiguration() {         checkParentConfigurationSet();         return (Configuration) getParent();     }          /**      * Set all settings in this {@link TemplateConfiguration} that were set in the parameter      * {@link TemplateConfiguration}, possibly overwriting the earlier value in this object. (A setting is said to be      * set in a {@link TemplateConfiguration} if it was explicitly set via a setter method, as opposed to be inherited.)      */     public void merge(TemplateConfiguration tc) {         if (tc.isAPIBuiltinEnabledSet()) {             setAPIBuiltinEnabled(tc.isAPIBuiltinEnabled());         }         if (tc.isArithmeticEngineSet()) {             setArithmeticEngine(tc.getArithmeticEngine());         }         if (tc.isAutoEscapingPolicySet()) {             setAutoEscapingPolicy(tc.getAutoEscapingPolicy());         }         if (tc.isAutoFlushSet()) {             setAutoFlush(tc.getAutoFlush());         }         if (tc.isBooleanFormatSet()) {             setBooleanFormat(tc.getBooleanFormat());         }         if (tc.isClassicCompatibleSet()) {             setClassicCompatibleAsInt(tc.getClassicCompatibleAsInt());         }         if (tc.isCustomDateFormatsSet()) {             setCustomDateFormats(mergeMaps(getCustomDateFormats(), tc.getCustomDateFormats(), false));         }         if (tc.isCustomNumberFormatsSet()) {             setCustomNumberFormats(mergeMaps(getCustomNumberFormats(), tc.getCustomNumberFormats(), false));         }         if (tc.isDateFormatSet()) {             setDateFormat(tc.getDateFormat());         }         if (tc.isDateTimeFormatSet()) {             setDateTimeFormat(tc.getDateTimeFormat());         }         if (tc.isEncodingSet()) {             setEncoding(tc.getEncoding());         }         if (tc.isLocaleSet()) {             setLocale(tc.getLocale());         }         if (tc.isLogTemplateExceptionsSet()) {             setLogTemplateExceptions(tc.getLogTemplateExceptions());         }         if (tc.isWrapUncheckedExceptionsSet()) {             setWrapUncheckedExceptions(tc.getWrapUncheckedExceptions());         }         if (tc.isNamingConventionSet()) {             setNamingConvention(tc.getNamingConvention());         }         if (tc.isNewBuiltinClassResolverSet()) {             setNewBuiltinClassResolver(tc.getNewBuiltinClassResolver());         }         if (tc.isTruncateBuiltinAlgorithmSet()) {             setTruncateBuiltinAlgorithm(tc.getTruncateBuiltinAlgorithm());         }         if (tc.isNumberFormatSet()) {             setNumberFormat(tc.getNumberFormat());         }         if (tc.isObjectWrapperSet()) {             setObjectWrapper(tc.getObjectWrapper());         }         if (tc.isOutputEncodingSet()) {             setOutputEncoding(tc.getOutputEncoding());         }         if (tc.isOutputFormatSet()) {             setOutputFormat(tc.getOutputFormat());         }         if (tc.isRecognizeStandardFileExtensionsSet()) {             setRecognizeStandardFileExtensions(tc.getRecognizeStandardFileExtensions());         }         if (tc.isShowErrorTipsSet()) {             setShowErrorTips(tc.getShowErrorTips());         }         if (tc.isSQLDateAndTimeTimeZoneSet()) {             setSQLDateAndTimeTimeZone(tc.getSQLDateAndTimeTimeZone());         }         if (tc.isStrictSyntaxModeSet()) {             setStrictSyntaxMode(tc.getStrictSyntaxMode());         }         if (tc.isTagSyntaxSet()) {             setTagSyntax(tc.getTagSyntax());         }         if (tc.isInterpolationSyntaxSet()) {             setInterpolationSyntax(tc.getInterpolationSyntax());         }         if (tc.isTemplateExceptionHandlerSet()) {             setTemplateExceptionHandler(tc.getTemplateExceptionHandler());         }         if (tc.isAttemptExceptionReporterSet()) {             setAttemptExceptionReporter(tc.getAttemptExceptionReporter());         }         if (tc.isTimeFormatSet()) {             setTimeFormat(tc.getTimeFormat());         }         if (tc.isTimeZoneSet()) {             setTimeZone(tc.getTimeZone());         }         if (tc.isURLEscapingCharsetSet()) {             setURLEscapingCharset(tc.getURLEscapingCharset());         }         if (tc.isWhitespaceStrippingSet()) {             setWhitespaceStripping(tc.getWhitespaceStripping());         }         if (tc.isTabSizeSet()) {             setTabSize(tc.getTabSize());         }         if (tc.isLazyImportsSet()) {             setLazyImports(tc.getLazyImports());         }         if (tc.isLazyAutoImportsSet()) {             setLazyAutoImports(tc.getLazyAutoImports());         }         if (tc.isAutoImportsSet()) {             setAutoImports(mergeMaps(getAutoImportsWithoutFallback(), tc.getAutoImportsWithoutFallback(), true));         }         if (tc.isAutoIncludesSet()) {             setAutoIncludes(mergeLists(getAutoIncludesWithoutFallback(), tc.getAutoIncludesWithoutFallback()));         }                  tc.copyDirectCustomAttributes(this, true);     }      /**      * Sets those settings of the {@link Template} which aren't yet set in the {@link Template} and are set in this      * {@link TemplateConfiguration}, leaves the other settings as is. A setting is said to be set in a      * {@link TemplateConfiguration} or {@link Template} if it was explicitly set via a setter method on that object, as      * opposed to be inherited from the {@link Configuration}.      *       *       * Note that this method doesn't deal with settings that influence the parser, as those are already baked in at this      * point via the {@link ParserConfiguration}.       *       *       * Note that the {@code encoding} setting of the {@link Template} counts as unset if it's {@code null},      * even if {@code null} was set via {@link Template#setEncoding(String)}.      *      * @throws IllegalStateException      *             If the parent configuration wasn't yet set.      */     public void apply(Template template) {         Configuration cfg = getNonNullParentConfiguration();         if (template.getConfiguration() != cfg) {             // This is actually not a problem right now, but for future BC we enforce this.             throw new IllegalArgumentException(                     &quot;The argument Template doesn't belong to the same Configuration as the TemplateConfiguration&quot;);         }          if (isAPIBuiltinEnabledSet() &amp;&amp; !template.isAPIBuiltinEnabledSet()) {             template.setAPIBuiltinEnabled(isAPIBuiltinEnabled());         }         if (isArithmeticEngineSet() &amp;&amp; !template.isArithmeticEngineSet()) {             template.setArithmeticEngine(getArithmeticEngine());         }         if (isAutoFlushSet() &amp;&amp; !template.isAutoFlushSet()) {             template.setAutoFlush(getAutoFlush());         }         if (isBooleanFormatSet() &amp;&amp; !template.isBooleanFormatSet()) {             template.setBooleanFormat(getBooleanFormat());         }         if (isClassicCompatibleSet() &amp;&amp; !template.isClassicCompatibleSet()) {             template.setClassicCompatibleAsInt(getClassicCompatibleAsInt());         }         if (isCustomDateFormatsSet()) {             template.setCustomDateFormats(                     mergeMaps(getCustomDateFormats(), template.getCustomDateFormatsWithoutFallback(), false));         }         if (isCustomNumberFormatsSet()) {             template.setCustomNumberFormats(                     mergeMaps(getCustomNumberFormats(), template.getCustomNumberFormatsWithoutFallback(), false));         }         if (isDateFormatSet() &amp;&amp; !template.isDateFormatSet()) {             template.setDateFormat(getDateFormat());         }         if (isDateTimeFormatSet() &amp;&amp; !template.isDateTimeFormatSet()) {             template.setDateTimeFormat(getDateTimeFormat());         }         if (isEncodingSet() &amp;&amp; template.getEncoding() == null) {             template.setEncoding(getEncoding());         }         if (isLocaleSet() &amp;&amp; !template.isLocaleSet()) {             template.setLocale(getLocale());         }         if (isLogTemplateExceptionsSet() &amp;&amp; !template.isLogTemplateExceptionsSet()) {             template.setLogTemplateExceptions(getLogTemplateExceptions());         }         if (isWrapUncheckedExceptionsSet() &amp;&amp; !template.isWrapUncheckedExceptionsSet()) {             template.setWrapUncheckedExceptions(getWrapUncheckedExceptions());         }         if (isNewBuiltinClassResolverSet() &amp;&amp; !template.isNewBuiltinClassResolverSet()) {             template.setNewBuiltinClassResolver(getNewBuiltinClassResolver());         }         if (isTruncateBuiltinAlgorithmSet() &amp;&amp; !template.isTruncateBuiltinAlgorithmSet()) {             template.setTruncateBuiltinAlgorithm(getTruncateBuiltinAlgorithm());         }         if (isNumberFormatSet() &amp;&amp; !template.isNumberFormatSet()) {             template.setNumberFormat(getNumberFormat());         }         if (isObjectWrapperSet() &amp;&amp; !template.isObjectWrapperSet()) {             template.setObjectWrapper(getObjectWrapper());         }         if (isOutputEncodingSet() &amp;&amp; !template.isOutputEncodingSet()) {             template.setOutputEncoding(getOutputEncoding());         }         if (isShowErrorTipsSet() &amp;&amp; !template.isShowErrorTipsSet()) {             template.setShowErrorTips(getShowErrorTips());         }         if (isSQLDateAndTimeTimeZoneSet() &amp;&amp; !template.isSQLDateAndTimeTimeZoneSet()) {             template.setSQLDateAndTimeTimeZone(getSQLDateAndTimeTimeZone());         }         if (isTemplateExceptionHandlerSet() &amp;&amp; !template.isTemplateExceptionHandlerSet()) {             template.setTemplateExceptionHandler(getTemplateExceptionHandler());         }         if (isAttemptExceptionReporterSet() &amp;&amp; !template.isAttemptExceptionReporterSet()) {             template.setAttemptExceptionReporter(getAttemptExceptionReporter());         }         if (isTimeFormatSet() &amp;&amp; !template.isTimeFormatSet()) {             template.setTimeFormat(getTimeFormat());         }         if (isTimeZoneSet() &amp;&amp; !template.isTimeZoneSet()) {             template.setTimeZone(getTimeZone());         }         if (isURLEscapingCharsetSet() &amp;&amp; !template.isURLEscapingCharsetSet()) {             template.setURLEscapingCharset(getURLEscapingCharset());         }         if (isLazyImportsSet() &amp;&amp; !template.isLazyImportsSet()) {             template.setLazyImports(getLazyImports());         }         if (isLazyAutoImportsSet() &amp;&amp; !template.isLazyAutoImportsSet()) {             template.setLazyAutoImports(getLazyAutoImports());         }         if (isAutoImportsSet()) {             // Regarding the order of the maps in the merge:             // - Existing template-level imports have precedence over those coming from the TC (just as with the others             //   apply()-ed settings), thus for clashing import prefixes they must win.             // - Template-level imports count as more specific, and so come after the more generic ones from TC.             template.setAutoImports(mergeMaps(getAutoImports(), template.getAutoImportsWithoutFallback(), true));         }         if (isAutoIncludesSet()) {             template.setAutoIncludes(mergeLists(getAutoIncludes(), template.getAutoIncludesWithoutFallback()));         }                  copyDirectCustomAttributes(template, false);     }      /**      * See {@link Configuration#setTagSyntax(int)}.      */     public void setTagSyntax(int tagSyntax) {         _TemplateAPI.valideTagSyntaxValue(tagSyntax);         this.tagSyntax = Integer.valueOf(tagSyntax);     }      /**      * The getter pair of {@link #setTagSyntax(int)}.      */     public int getTagSyntax() {         return tagSyntax != null ? tagSyntax.intValue() : getNonNullParentConfiguration().getTagSyntax();     }      /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isTagSyntaxSet() {         return tagSyntax != null;     }      /**      * See {@link Configuration#setInterpolationSyntax(int)}.      */     public void setInterpolationSyntax(int interpolationSyntax) {         _TemplateAPI.valideInterpolationSyntaxValue(interpolationSyntax);         this.interpolationSyntax = Integer.valueOf(interpolationSyntax);     }          /**      * The getter pair of {@link #setInterpolationSyntax(int)}.      */     public int getInterpolationSyntax() {         return interpolationSyntax != null ? interpolationSyntax.intValue()                 : getNonNullParentConfiguration().getInterpolationSyntax();     }      /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isInterpolationSyntaxSet() {         return interpolationSyntax != null;     }          /**      * See {@link Configuration#setNamingConvention(int)}.      */     public void setNamingConvention(int namingConvention) {         _TemplateAPI.validateNamingConventionValue(namingConvention);         this.namingConvention = Integer.valueOf(namingConvention);     }      /**      * The getter pair of {@link #setNamingConvention(int)}.      */     public int getNamingConvention() {         return namingConvention != null ? namingConvention.intValue()                 : getNonNullParentConfiguration().getNamingConvention();     }      /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isNamingConventionSet() {         return namingConvention != null;     }      /**      * See {@link Configuration#setWhitespaceStripping(boolean)}.      */     public void setWhitespaceStripping(boolean whitespaceStripping) {         this.whitespaceStripping = Boolean.valueOf(whitespaceStripping);     }      /**      * The getter pair of {@link #getWhitespaceStripping()}.      */     public boolean getWhitespaceStripping() {         return whitespaceStripping != null ? whitespaceStripping.booleanValue()                 : getNonNullParentConfiguration().getWhitespaceStripping();     }      /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isWhitespaceStrippingSet() {         return whitespaceStripping != null;     }      /**      * Sets the output format of the template; see {@link Configuration#setAutoEscapingPolicy(int)} for more.      */     public void setAutoEscapingPolicy(int autoEscapingPolicy) {         _TemplateAPI.validateAutoEscapingPolicyValue(autoEscapingPolicy);         this.autoEscapingPolicy = Integer.valueOf(autoEscapingPolicy);     }      /**      * The getter pair of {@link #setAutoEscapingPolicy(int)}.      */     public int getAutoEscapingPolicy() {         return autoEscapingPolicy != null ? autoEscapingPolicy.intValue()                 : getNonNullParentConfiguration().getAutoEscapingPolicy();     }      /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isAutoEscapingPolicySet() {         return autoEscapingPolicy != null;     }      /**      * Sets the output format of the template; see {@link Configuration#setOutputFormat(OutputFormat)} for more.      */     public void setOutputFormat(OutputFormat outputFormat) {         NullArgumentException.check(&quot;outputFormat&quot;, outputFormat);         this.outputFormat = outputFormat;     }      /**      * The getter pair of {@link #setOutputFormat(OutputFormat)}.      */     public OutputFormat getOutputFormat() {         return outputFormat != null ? outputFormat : getNonNullParentConfiguration().getOutputFormat();     }      /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isOutputFormatSet() {         return outputFormat != null;     }          /**      * See {@link Configuration#setRecognizeStandardFileExtensions(boolean)}.       */     public void setRecognizeStandardFileExtensions(boolean recognizeStandardFileExtensions) {         this.recognizeStandardFileExtensions = Boolean.valueOf(recognizeStandardFileExtensions);     }      /**      * Getter pair of {@link #setRecognizeStandardFileExtensions(boolean)}.      */     public boolean getRecognizeStandardFileExtensions() {         return recognizeStandardFileExtensions != null ? recognizeStandardFileExtensions.booleanValue()                 : getNonNullParentConfiguration().getRecognizeStandardFileExtensions();     }          /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isRecognizeStandardFileExtensionsSet() {         return recognizeStandardFileExtensions != null;     }          /**      * See {@link Configuration#setStrictSyntaxMode(boolean)}.      */     public void setStrictSyntaxMode(boolean strictSyntaxMode) {         this.strictSyntaxMode = Boolean.valueOf(strictSyntaxMode);     }      /**      * The getter pair of {@link #setStrictSyntaxMode(boolean)}.      */     public boolean getStrictSyntaxMode() {         return strictSyntaxMode != null ? strictSyntaxMode.booleanValue()                 : getNonNullParentConfiguration().getStrictSyntaxMode();     }          /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      */     public boolean isStrictSyntaxModeSet() {         return strictSyntaxMode != null;     }      @Override     public void setStrictBeanModels(boolean strict) {         throw new UnsupportedOperationException(                 &quot;Setting strictBeanModels on &quot; + TemplateConfiguration.class.getSimpleName() + &quot; level isn't supported.&quot;);     }      public String getEncoding() {         return encoding != null ? encoding : getNonNullParentConfiguration().getDefaultEncoding();     }      /**      * When the standard template loading/caching mechanism is used, this forces the charset used for reading the      * template &quot;file&quot;, overriding everything but the encoding coming from the {@code #ftl} header. This setting      * overrides the locale-specific encodings set via {@link Configuration#setEncoding(java.util.Locale, String)}. It      * also overrides the {@code encoding} parameter of {@link Configuration#getTemplate(String, String)} (and of its      * overloads) and the {@code encoding} parameter of the {@code #include} directive. This works like that because      * specifying the encoding where you are requesting the template is error prone and deprecated.      *       *       * If you are developing your own template loading/caching mechanism instead of the standard one, note that the      * above behavior is not guaranteed by this class alone; you have to ensure it. Also, read the note on      * {@code encoding} in the documentation of {@link #apply(Template)}.      */     public void setEncoding(String encoding) {         NullArgumentException.check(&quot;encoding&quot;, encoding);         this.encoding = encoding;     }      public boolean isEncodingSet() {         return encoding != null;     }          /**      * See {@link Configuration#setTabSize(int)}.       *       * @since 2.3.25      */     public void setTabSize(int tabSize) {         this.tabSize = Integer.valueOf(tabSize);     }      /**      * Getter pair of {@link #setTabSize(int)}.      *       * @since 2.3.25      */     public int getTabSize() {         return tabSize != null ? tabSize.intValue()                 : getNonNullParentConfiguration().getTabSize();     }          /**      * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.      *       * @since 2.3.25      */     public boolean isTabSizeSet() {         return tabSize != null;     }          /**      * Returns {@link Configuration#getIncompatibleImprovements()} from the parent {@link Configuration}. This mostly      * just exist to satisfy the {@link ParserConfiguration} interface.      *       * @throws IllegalStateException      *             If the parent configuration wasn't yet set.      */     public Version getIncompatibleImprovements() {         return getNonNullParentConfiguration().getIncompatibleImprovements();     }      private void checkParentConfigurationSet() {         if (!parentConfigurationSet) {             throw new IllegalStateException(&quot;The TemplateConfiguration wasn't associated with a Configuration yet.&quot;);         }     }      private boolean hasAnyConfigurableSet() {         return                 isAPIBuiltinEnabledSet()                 || isArithmeticEngineSet()                 || isAutoFlushSet()                 || isAutoImportsSet()                 || isAutoIncludesSet()                 || isBooleanFormatSet()                 || isClassicCompatibleSet()                 || isCustomDateFormatsSet()                 || isCustomNumberFormatsSet()                 || isDateFormatSet()                 || isDateTimeFormatSet()                 || isLazyImportsSet()                 || isLazyAutoImportsSet()                 || isLocaleSet()                 || isLogTemplateExceptionsSet()                 || isWrapUncheckedExceptionsSet()                 || isNewBuiltinClassResolverSet()                 || isTruncateBuiltinAlgorithmSet()                 || isNumberFormatSet()                 || isObjectWrapperSet()                 || isOutputEncodingSet()                 || isShowErrorTipsSet()                 || isSQLDateAndTimeTimeZoneSet()                 || isTemplateExceptionHandlerSet()                 || isAttemptExceptionReporterSet()                 || isTimeFormatSet()                 || isTimeZoneSet()                 || isURLEscapingCharsetSet();     }          private Map mergeMaps(Map m1, Map m2, boolean overwriteUpdatesOrder) {         if (m1 == null) return m2;         if (m2 == null) return m1;         if (m1.isEmpty()) return m2;         if (m2.isEmpty()) return m1;                  LinkedHashMap mergedM = new LinkedHashMap((m1.size() + m2.size()) * 4 / 3 + 1, 0.75f);         mergedM.putAll(m1);         for (Object m2Key : m2.keySet()) {             mergedM.remove(m2Key); // So that duplicate keys are moved after m1 keys         }         mergedM.putAll(m2);         return mergedM;     }      private List mergeLists(List list1, List list2) {         if (list1 == null) return list2;         if (list2 == null) return list1;         if (list1.isEmpty()) return list2;         if (list2.isEmpty()) return list1;                  ArrayList mergedList = new ArrayList(list1.size() + list2.size());         mergedList.addAll(list1);         mergedList.addAll(list2);         return mergedList;     }      }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7625</td>
    <td align="left">https://github.com/apache/freemarker/blob/02fa5edb3cde53f284551c09ecc13301b0e83d0b/src/main/java/freemarker/core/TemplateConfiguration.java/#L77-L718</td>
    <td align="right">1</td>
    <td align="right">806</td>
    <td align="right">7625</td>
  </tr>
  <tr valign="top">
    <td align="right">302</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Long Method&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface UpgradeRequest {     /**      * Add WebSocket Extension Configuration(s) to Upgrade Request.      *       * This is merely the list of requested Extensions to use, see {@link UpgradeResponse#getExtensions()} for what was      * negotiated      *      * @param configs the configuration(s) to add      */     void addExtensions(ExtensionConfig... configs);      /**      * Add WebSocket Extension Configuration(s) to request      *       * This is merely the list of requested Extensions to use, see {@link UpgradeResponse#getExtensions()} for what was      * negotiated      *      * @param configs the configuration(s) to add      */     void addExtensions(String... configs);      /**      * Remove all headers from request.      * @deprecated (no longer supported, as this can undo the required upgrade request headers)      */     @Deprecated     void clearHeaders();      /**      * Get the list of Cookies on the Upgrade request      *      * @return the list of Cookies      */     List getCookies();      /**      * Get the list of WebSocket Extension Configurations for this Upgrade Request.      *       * This is merely the list of requested Extensions to use, see {@link UpgradeResponse#getExtensions()} for what was      * negotiated      *      * @return the list of Extension configurations (in the order they were specified)      */     List getExtensions();      /**      * Get a specific Header value from Upgrade Request      *      * @param name the name of the header      * @return the value of the header (null if header does not exist)      */     String getHeader(String name);      /**      * Get the specific Header value, as an int, from the Upgrade Request.      *      * @param name the name of the header      * @return the value of the header as an int (-1 if header does not exist)      * @throws NumberFormatException if unable to parse value as an int.      */     int getHeaderInt(String name);      /**      * Get the headers as a Map of keys to value lists.      *      * @return the headers      */     Map&gt; getHeaders();      /**      * Get the specific header values (for multi-value headers)      *      * @param name the header name      * @return the value list (null if no header exists)      */     List getHeaders(String name);      /**      * The host of the Upgrade Request URI      *      * @return host of the request URI      */     String getHost();      /**      * The HTTP version used for this Upgrade Request      *       * As of RFC6455 (December 2011) this is always      * HTTP/1.1      *      * @return the HTTP Version used      */     String getHttpVersion();      /**      * The HTTP method for this Upgrade Request.      *       * As of RFC6455 (December 2011) this is always GET      *      * @return the HTTP method used      */     String getMethod();      /**      * The WebSocket Origin of this Upgrade Request      *       * See RFC6455: Section 10.2 for details.      *       * Equivalent to {@link #getHeader(String)} passed the &quot;Origin&quot; header.      *      * @return the Origin header      */     String getOrigin();      /**      * Returns a map of the query parameters of the request.      *      * @return a unmodifiable map of query parameters of the request.      */     Map&gt; getParameterMap();      /**      * Get the WebSocket Protocol Version      *       * As of RFC6455, Jetty only supports version      * 13      *      * @return the WebSocket protocol version      */     String getProtocolVersion();      /**      * Get the Query String of the request URI.      *      * @return the request uri query string      */     String getQueryString();      /**      * Get the Request URI      *      * @return the request URI      */     URI getRequestURI();      /**      * Access the Servlet HTTP Session (if present)      *       * Note: Never present on a Client UpgradeRequest.      *      * @return the Servlet HTTPSession on server side UpgradeRequests      */     Object getSession();      /**      * Get the list of offered WebSocket sub-protocols.      *      * @return the list of offered sub-protocols      */     List getSubProtocols();      /**      * Get the User Principal for this request.      *       * Only applicable when using UpgradeRequest from server side.      *      * @return the user principal      */     Principal getUserPrincipal();      /**      * Test if a specific sub-protocol is offered      *      * @param test the sub-protocol to test for      * @return true if sub-protocol exists on request      */     boolean hasSubProtocol(String test);      /**      * Test if supplied Origin is the same as the Request      *      * @param test the supplied origin      * @return true if the supplied origin matches the request origin      */     boolean isOrigin(String test);      /**      * Test if connection is secure.      *      * @return true if connection is secure.      */     boolean isSecure();      /**      * Set the list of Cookies on the request      *      * @param cookies the cookies to use      */     void setCookies(List cookies);      /**      * Set the list of WebSocket Extension configurations on the request.      * @param configs the list of extension configurations      */     void setExtensions(List configs);      /**      * Set a specific header with multi-value field      *       * Overrides any previous value for this named header      *      * @param name the name of the header      * @param values the multi-value field      */     void setHeader(String name, List values);      /**      * Set a specific header value      *       * Overrides any previous value for this named header      *      * @param name the header to set      * @param value the value to set it to      */     void setHeader(String name, String value);      /**      * Sets multiple headers on the request.      *       * Only sets those headers provided, does not remove      * headers that exist on request and are not provided in the      * parameter for this method.      *       * Convenience method vs calling {@link #setHeader(String, List)} multiple times.      *      * @param headers the headers to set      */     void setHeaders(Map&gt; headers);      /**      * Set the HTTP Version to use.      *       * As of RFC6455 (December 2011) this should always be      * HTTP/1.1      *      * @param httpVersion the HTTP version to use.      */     void setHttpVersion(String httpVersion);      /**      * Set the HTTP method to use.      *       * As of RFC6455 (December 2011) this is always GET      *      * @param method the HTTP method to use.      */     void setMethod(String method);      /**      * Set the Request URI to use for this request.      *       * Must be an absolute URI with scheme 'ws' or 'wss'      *      * @param uri the Request URI      */     void setRequestURI(URI uri);      /**      * Set the Session associated with this request.      *       * Typically used to associate the Servlet HttpSession object.      *      * @param session the session object to associate with this request      */     void setSession(Object session);      /**      * Set the offered WebSocket Sub-Protocol list.      *      * @param protocols the offered sub-protocol list      */     void setSubProtocols(List protocols);      /**      * Set the offered WebSocket Sub-Protocol list.      *      * @param protocols the offered sub-protocol list      */     void setSubProtocols(String... protocols);  }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3165</td>
    <td align="left">https://github.com/eclipse/jetty.project/blob/65528f76c5ef6ddca11385f9721c8f0bc5f2eed7/jetty-websocket/websocket-api/src/main/java/org/eclipse/jetty/websocket/api/UpgradeRequest.java/#L32-L323</td>
    <td align="right">1</td>
    <td align="right">302</td>
    <td align="right">3165</td>
  </tr>
  <tr valign="top">
    <td align="right">1609</td>
    <td align="left">{       &quot;response&quot;: &quot;YES I found bad smells&quot;,       &quot;detected_bad_smells&quot;: [           &quot;1. Data Class&quot;       ]   }  </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class BaseClassInfo {     //~ Instance fields ----------------------------------------------------------------------------------------------------------      protected String name;     protected String nameAndLoader; // A combinarion of class name and loader, uniquely identifying this ClassInfo      // Management of multiple versions for the same-named (but possibly not same-code) class, loaded by different classloaders     protected int classLoaderId; // IDs of all loaders with which versions of this class are loaded      // Data used by our object allocation instrumentation mechanism: integer class ID     private int instrClassId;      //~ Constructors -------------------------------------------------------------------------------------------------------------      public BaseClassInfo(String className, int classLoaderId) {         this.name = className.intern();         this.classLoaderId = classLoaderId;         nameAndLoader = (name + &quot;#&quot; + classLoaderId).intern(); // NOI18N         instrClassId = -1;     }      //~ Methods ------------------------------------------------------------------------------------------------------------------      public void setInstrClassId(int id) {         instrClassId = id;     }      public int getInstrClassId() {         return instrClassId;     }      public void setLoaderId(int loaderId) {         classLoaderId = loaderId;     }      public int getLoaderId() {         return classLoaderId;     }      public String getName() {         return name;     }      public String getNameAndLoader() {         return nameAndLoader;     }      public String toString() {         return name;     } }</td>
    <td align="left">data class</td>
    <td align="left">1 Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11456</td>
    <td align="left">https://github.com/oracle/visualvm/blob/d9b10575b53d535e10c6e8c41831ebe38483c65b/visualvm/libs.profiler/lib.profiler/src/org/graalvm/visualvm/lib/jfluid/classfile/BaseClassInfo.java/#L53-L103</td>
    <td align="right">1</td>
    <td align="right">1609</td>
    <td align="right">11456</td>
  </tr>
  <tr valign="top">
    <td align="right">289</td>
    <td align="left">&nbsp;{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;bad_smells&quot;: [     &quot;1. Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
      @AutoValue       public abstract static class CreatePayload {           public abstract String name();           public abstract Location location();        }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3068</td>
    <td align="left">https://github.com/apache/jclouds/blob/c2670079fabe74f163f43fbade0866469f7a84ec/providers/profitbricks/src/main/java/org/jclouds/profitbricks/domain/DataCenter.java/#L103-L110</td>
    <td align="right">1</td>
    <td align="right">289</td>
    <td align="right">3068</td>
  </tr>
  <tr valign="top">
    <td align="right">2095</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class JarModule {     private ModuleRevisionId mrid;      private File jar;      public JarModule(ModuleRevisionId mrid, File jar) {         this.mrid = mrid;         this.jar = jar;     }      public File getJar() {         return jar;     }      public ModuleRevisionId getMrid() {         return mrid;     }      public String toString() {         return jar + &quot; &quot; + mrid;     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13145</td>
    <td align="left">https://github.com/apache/ant-ivy/blob/4ffcf8f06f238b17e78e8033c3e8278833e452eb/src/java/org/apache/ivy/tools/analyser/JarModule.java/#L24-L46</td>
    <td align="right">1</td>
    <td align="right">2095</td>
    <td align="right">13145</td>
  </tr>
  <tr valign="top">
    <td align="right">3326</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class RestConfiguration {      public static final String CORS_ACCESS_CONTROL_ALLOW_ORIGIN = &quot;*&quot;;     public static final String CORS_ACCESS_CONTROL_ALLOW_METHODS = &quot;GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, CONNECT, PATCH&quot;;     public static final String CORS_ACCESS_CONTROL_MAX_AGE = &quot;3600&quot;;     public static final String CORS_ACCESS_CONTROL_ALLOW_HEADERS = &quot;Origin, Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers&quot;;      public enum RestBindingMode {         auto, off, json, xml, json_xml     }      public enum RestHostNameResolver {         allLocalIp, localIp, localHostName     }      private String component;     private String apiComponent;     private String producerComponent;     private String producerApiDoc;     private String scheme;     private String host;     private boolean useXForwardHeaders = true;     private String apiHost;     private int port;     private String contextPath;     private String apiContextPath;     private String apiContextRouteId;     private String apiContextIdPattern;     private boolean apiContextListing;     private boolean apiVendorExtension;     private RestHostNameResolver hostNameResolver = RestHostNameResolver.allLocalIp;     private RestBindingMode bindingMode = RestBindingMode.off;     private boolean skipBindingOnErrorCode = true;     private boolean clientRequestValidation;     private boolean enableCORS;     private String jsonDataFormat;     private String xmlDataFormat;     private Map componentProperties;     private Map endpointProperties;     private Map consumerProperties;     private Map dataFormatProperties;     private Map apiProperties;     private Map corsHeaders;      /**      * Gets the name of the Camel component to use as the REST consumer      *      * @return the component name, or null to let Camel search the {@link Registry} to find suitable implementation      */     public String getComponent() {         return component;     }      /**      * Sets the name of the Camel component to use as the REST consumer      *      * @param componentName the name of the component (such as restlet, spark-rest, etc.)      */     public void setComponent(String componentName) {         this.component = componentName;     }      /**      * Gets the name of the Camel component to use as the REST API (such as swagger)      *      * @return the component name, or null to let Camel use the default name swagger      */     public String getApiComponent() {         return apiComponent;     }      /**      * Sets the name of the Camel component to use as the REST API (such as swagger)      *      * @param apiComponent the name of the component (such as swagger)      */     public void setApiComponent(String apiComponent) {         this.apiComponent = apiComponent;     }      /**      * Gets the name of the Camel component to use as the REST producer      *      * @return the component name, or null to let Camel search the {@link Registry} to find suitable implementation      */     public String getProducerComponent() {         return producerComponent;     }      /**      * Sets the name of the Camel component to use as the REST producer      *      * @param componentName the name of the component (such as restlet, jetty, etc.)      */     public void setProducerComponent(String componentName) {         this.producerComponent = componentName;     }      /**      * Gets the location of the api document (swagger api) the REST producer will use      * to validate the REST uri and query parameters are valid accordingly to the api document.      */     public String getProducerApiDoc() {         return producerApiDoc;     }      /**      * Sets the location of the api document (swagger api) the REST producer will use      * to validate the REST uri and query parameters are valid accordingly to the api document.      * This requires adding camel-swagger-java to the classpath, and any miss configuration      * will let Camel fail on startup and report the error(s).      *       * The location of the api document is loaded from classpath by default, but you can use      * file: or http: to refer to resources to load from file or http url.      */     public void setProducerApiDoc(String producerApiDoc) {         this.producerApiDoc = producerApiDoc;     }      /**      * Gets the hostname to use by the REST consumer      *      * @return the hostname, or null to use default hostname      */     public String getHost() {         return host;     }      /**      * Sets the hostname to use by the REST consumer      *      * @param host the hostname      */     public void setHost(String host) {         this.host = host;     }      /**      * WWhether to use X-Forward headers to set host etc. for Swagger.      *       * This option is default true.      */     public boolean isUseXForwardHeaders() {         return useXForwardHeaders;     }      /**      * WWhether to use X-Forward headers to set host etc. for Swagger.      *       * This option is default true.      *       * @param useXForwardHeaders whether to use X-Forward headers      */     public void setUseXForwardHeaders(boolean useXForwardHeaders) {         this.useXForwardHeaders = useXForwardHeaders;     }      public String getApiHost() {         return apiHost;     }      /**      * To use an specific hostname for the API documentation (eg swagger)      *       * This can be used to override the generated host with this configured hostname      */     public void setApiHost(String apiHost) {         this.apiHost = apiHost;     }      /**      * Gets the scheme to use by the REST consumer      *      * @return the scheme, or null to use default scheme      */     public String getScheme() {         return scheme;     }      /**      * Sets the scheme to use by the REST consumer      *      * @param scheme the scheme      */     public void setScheme(String scheme) {         this.scheme = scheme;     }      /**      * Gets the port to use by the REST consumer      *      * @return the port, or 0 or -1 to use default port      */     public int getPort() {         return port;     }      /**      * Sets the port to use by the REST consumer      *      * @param port the port number      */     public void setPort(int port) {         this.port = port;     }      /**      * Gets the configured context-path      *      * @return the context path, or null if none configured.      */     public String getContextPath() {         return contextPath;     }      /**      * Sets a leading context-path the REST services will be using.      *       * This can be used when using components such as camel-servlet where the deployed web application      * is deployed using a context-path. Or for components such as camel-jetty or camel-netty4-http      * that includes a HTTP server.      *      * @param contextPath the context path      */     public void setContextPath(String contextPath) {         this.contextPath = contextPath;     }      public String getApiContextPath() {         return apiContextPath;     }      /**      * Sets a leading API context-path the REST API services will be using.      *       * This can be used when using components such as camel-servlet where the deployed web application      * is deployed using a context-path.      *      * @param contextPath the API context path      */     public void setApiContextPath(String contextPath) {         this.apiContextPath = contextPath;     }      public String getApiContextRouteId() {         return apiContextRouteId;     }      /**      * Sets the route id to use for the route that services the REST API.      *       * The route will by default use an auto assigned route id.      *      * @param apiContextRouteId  the route id      */     public void setApiContextRouteId(String apiContextRouteId) {         this.apiContextRouteId = apiContextRouteId;     }      public String getApiContextIdPattern() {         return apiContextIdPattern;     }      /**      * Optional CamelContext id pattern to only allow Rest APIs from rest services within CamelContext's which name matches the pattern.      *       * The pattern #name# refers to the CamelContext name, to match on the current CamelContext only.      * For any other value, the pattern uses the rules from {@link org.apache.camel.support.EndpointHelper#matchPattern(String, String)}      *      * @param apiContextIdPattern  the pattern      */     public void setApiContextIdPattern(String apiContextIdPattern) {         this.apiContextIdPattern = apiContextIdPattern;     }      public boolean isApiContextListing() {         return apiContextListing;     }      /**      * Sets whether listing of all available CamelContext's with REST services in the JVM is enabled. If enabled it allows to discover      * these contexts, if false then only the current CamelContext is in use.      */     public void setApiContextListing(boolean apiContextListing) {         this.apiContextListing = apiContextListing;     }      public boolean isApiVendorExtension() {         return apiVendorExtension;     }      /**      * Whether vendor extension is enabled in the Rest APIs. If enabled then Camel will include additional information      * as vendor extension (eg keys starting with x-) such as route ids, class names etc.      * Not all 3rd party API gateways and tools supports vendor-extensions when importing your API docs.      */     public void setApiVendorExtension(boolean apiVendorExtension) {         this.apiVendorExtension = apiVendorExtension;     }      /**      * Gets the resolver to use for resolving hostname      *      * @return the resolver      */     public RestHostNameResolver getHostNameResolver() {         return hostNameResolver;     }      /**      * Sets the resolver to use for resolving hostname      *      * @param hostNameResolver the resolver      */     public void setHostNameResolver(RestHostNameResolver hostNameResolver) {         this.hostNameResolver = hostNameResolver;     }      /**      * Sets the resolver to use for resolving hostname      *      * @param hostNameResolver the resolver      */     public void setHostNameResolver(String hostNameResolver) {         this.hostNameResolver = RestHostNameResolver.valueOf(hostNameResolver);     }      /**      * Gets the binding mode used by the REST consumer      *      * @return the binding mode      */     public RestBindingMode getBindingMode() {         return bindingMode;     }      /**      * Sets the binding mode to be used by the REST consumer      *      * @param bindingMode the binding mode      */     public void setBindingMode(RestBindingMode bindingMode) {         this.bindingMode = bindingMode;     }      /**      * Sets the binding mode to be used by the REST consumer      *      * @param bindingMode the binding mode      */     public void setBindingMode(String bindingMode) {         this.bindingMode = RestBindingMode.valueOf(bindingMode);     }      /**      * Whether to skip binding output if there is a custom HTTP error code, and instead use the response body as-is.      *       * This option is default true.      *      * @return whether to skip binding on error code      */     public boolean isSkipBindingOnErrorCode() {         return skipBindingOnErrorCode;     }      /**      * Whether to skip binding output if there is a custom HTTP error code, and instead use the response body as-is.      *       * This option is default true.      *      * @param skipBindingOnErrorCode whether to skip binding on error code      */     public void setSkipBindingOnErrorCode(boolean skipBindingOnErrorCode) {         this.skipBindingOnErrorCode = skipBindingOnErrorCode;     }      public boolean isClientRequestValidation() {         return clientRequestValidation;     }      /**      * Whether to enable validation of the client request to check whether the Content-Type and Accept headers from      * the client is supported by the Rest-DSL configuration of its consumes/produces settings.      *       * This can be turned on, to enable this check. In case of validation error, then HTTP Status codes 415 or 406 is returned.      *       * The default value is false.      */     public void setClientRequestValidation(boolean clientRequestValidation) {         this.clientRequestValidation = clientRequestValidation;     }      /**      * To specify whether to enable CORS which means Camel will automatic include CORS in the HTTP headers in the response.      *       * This option is default false      *      * @return whether CORS is enabled or not      */     public boolean isEnableCORS() {         return enableCORS;     }      /**      * To specify whether to enable CORS which means Camel will automatic include CORS in the HTTP headers in the response.      *       * This option is default false      *      * @param enableCORS true to enable CORS      */     public void setEnableCORS(boolean enableCORS) {         this.enableCORS = enableCORS;     }      /**      * Gets the name of the json data format.      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @return the name, or null to use default      */     public String getJsonDataFormat() {         return jsonDataFormat;     }      /**      * Sets a custom json data format to be used      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @param name name of the data format      */     public void setJsonDataFormat(String name) {         this.jsonDataFormat = name;     }      /**      * Gets the name of the xml data format.      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @return the name, or null to use default      */     public String getXmlDataFormat() {         return xmlDataFormat;     }      /**      * Sets a custom xml data format to be used.      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @param name name of the data format      */     public void setXmlDataFormat(String name) {         this.xmlDataFormat = name;     }      /**      * Gets additional options on component level      *      * @return additional options      */     public Map getComponentProperties() {         return componentProperties;     }      /**      * Sets additional options on component level      *      * @param componentProperties the options      */     public void setComponentProperties(Map componentProperties) {         this.componentProperties = componentProperties;     }      /**      * Gets additional options on endpoint level      *      * @return additional options      */     public Map getEndpointProperties() {         return endpointProperties;     }      /**      * Sets additional options on endpoint level      *      * @param endpointProperties the options      */     public void setEndpointProperties(Map endpointProperties) {         this.endpointProperties = endpointProperties;     }      /**      * Gets additional options on consumer level      *      * @return additional options      */     public Map getConsumerProperties() {         return consumerProperties;     }      /**      * Sets additional options on consumer level      *      * @param consumerProperties the options      */     public void setConsumerProperties(Map consumerProperties) {         this.consumerProperties = consumerProperties;     }      /**      * Gets additional options on data format level      *      * @return additional options      */     public Map getDataFormatProperties() {         return dataFormatProperties;     }      /**      * Sets additional options on data format level      *      * @param dataFormatProperties the options      */     public void setDataFormatProperties(Map dataFormatProperties) {         this.dataFormatProperties = dataFormatProperties;     }      public Map getApiProperties() {         return apiProperties;     }      /**      * Sets additional options on api level      *      * @param apiProperties the options      */     public void setApiProperties(Map apiProperties) {         this.apiProperties = apiProperties;     }      /**      * Gets the CORS headers to use if CORS has been enabled.      *      * @return the CORS headers      */     public Map getCorsHeaders() {         return corsHeaders;     }      /**      * Sets the CORS headers to use if CORS has been enabled.      *      * @param corsHeaders the CORS headers      */     public void setCorsHeaders(Map corsHeaders) {         this.corsHeaders = corsHeaders;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6173</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/core/camel-api/src/main/java/org/apache/camel/spi/RestConfiguration.java/#L25-L585</td>
    <td align="right">1</td>
    <td align="right">3326</td>
    <td align="right">6173</td>
  </tr>
  <tr valign="top">
    <td align="right">840</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Signal {   public enum Type { LEAVE_LOOP, LEAVE_ROUTINE, LEAVE_PROGRAM, SQLEXCEPTION, NOTFOUND, UNSUPPORTED_OPERATION, USERDEFINED };   Type type;   String value = &quot;&quot;;   Exception exception = null;      Signal(Type type, String value) {     this.type = type;     this.value = value;     this.exception = null;   }      Signal(Type type, String value, Exception exception) {     this.type = type;     this.value = value;     this.exception = exception;   }      /**    * Get the signal value (message text)    */   public String getValue() {     return value;   } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7789</td>
    <td align="left">https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/hplsql/src/main/java/org/apache/hive/hplsql/Signal.java/#L24-L48</td>
    <td align="right">1</td>
    <td align="right">840</td>
    <td align="right">7789</td>
  </tr>
  <tr valign="top">
    <td align="right">2045</td>
    <td align="left">&nbsp;&nbsp;YES, I found bad smells. The bad smells are: 1. Long method 2. Feature envy 3. Duplicate code 4. Magic numbers 5. Inappropriate comments 6. Data class 7. Many parameters 8. Primitive obsession 9. Dead code 10. Null pointer exceptions 11. Inconsistent naming conventions</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
@SuppressWarnings(&quot;serial&quot;) @Entity @Table(name = &quot;TRIGGER&quot;, uniqueConstraints = @UniqueConstraint(columnNames = { &quot;name&quot;, &quot;alert_id&quot; })) public class Trigger extends JPAEntity implements Serializable { 	 	 	public static class Serializer extends JsonSerializer {  		@Override 		public void serialize(Trigger trigger, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException { 			 			jgen.writeStartObject(); 			 			jgen.writeStringField(&quot;id&quot;, trigger.getId().toString()); 			jgen.writeStringField(&quot;name&quot;, trigger.getName()); 			jgen.writeStringField(&quot;type&quot;, trigger.getType().name()); 			jgen.writeNumberField(&quot;threshold&quot;, trigger.getThreshold().doubleValue()); 			 			if(trigger.getSecondaryThreshold() != null) { 				jgen.writeNumberField(&quot;secondaryThreshold&quot;, trigger.getSecondaryThreshold()); 			} 			 			if(trigger.getInertia() != null) { 				jgen.writeNumberField(&quot;inertia&quot;, trigger.getInertia()); 			} 			 			jgen.writeEndObject(); 		} 		 	} 	 	public static class Deserializer extends JsonDeserializer {  		@Override 		public Trigger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {  			Trigger trigger = new Trigger(); 			JsonNode rootNode = jp.getCodec().readTree(jp); 			 			BigInteger id = new BigInteger(rootNode.get(&quot;id&quot;).asText()); 			trigger.id = id; 			 			String name = rootNode.get(&quot;name&quot;).asText(); 			trigger.setName(name); 			 			TriggerType type = TriggerType.fromString(rootNode.get(&quot;type&quot;).asText()); 			trigger.setType(type); 			 			Double threshold = rootNode.get(&quot;threshold&quot;).asDouble(); 			trigger.setThreshold(threshold);  			if(rootNode.get(&quot;secondaryThreshold&quot;) != null) { 				trigger.setSecondaryThreshold(rootNode.get(&quot;secondaryThreshold&quot;).asDouble()); 			} 			 			if(rootNode.get(&quot;inertia&quot;) != null) { 				trigger.setInertia(rootNode.get(&quot;inertia&quot;).asLong()); 			} 			 			return trigger; 		} 		 	} 	      //~ Instance fields ******************************************************************************************************************************  	@Column(nullable = false)     @Enumerated(EnumType.STRING)     private TriggerType type;          @Basic(optional = false)     @Column(name = &quot;name&quot;, nullable = false)     private String name;          @Basic(optional = false)     private Double threshold;          private Double secondaryThreshold;          private Long inertia;      @ManyToOne(optional = false)     @JoinColumn(nullable = false, name = &quot;alert_id&quot;)     private Alert alert;          @ManyToMany(mappedBy = &quot;triggers&quot;, cascade = { CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH })     private List notifications = new ArrayList&lt;&gt;(0);      //~ Constructors *********************************************************************************************************************************      /**      * Creates a new Trigger object.      *      * @param  alert          The alert associated with the trigger. Cannot be null.      * @param  type           The type of the alert. Cannot be null.      * @param  name           The name of the alert. Cannot be null or empty.      * @param  threshold      The threshold value for the alert.      * @param  inertiaMillis  The amount of time in milliseconds a condition must exist for the trigger to fire. Cannot be negative.      */     public Trigger(Alert alert, TriggerType type, String name, double threshold, long inertiaMillis) {         this(alert, type, name, threshold, null, inertiaMillis);     }      /**      * Creates a new Trigger object.      *      * @param  alert               The alert associated with the trigger. Cannot be null.      * @param  type                The type of the alert. Cannot be null.      * @param  name                The name of the alert. Cannot be null or empty.      * @param  threshold           The threshold value for the alert.      * @param  secondaryThreshold  The secondary threshold value for the alert. May be null for types that only require one threshold.      * @param  inertiaMillis       The amount of time in milliseconds a condition must exist for the trigger to fire. Cannot be negative.      */     public Trigger(Alert alert, TriggerType type, String name, Double threshold, Double secondaryThreshold, long inertiaMillis) {         super(alert.getOwner());         setAlert(alert);         setType(type);         setName(name);         setThreshold(threshold);         setSecondaryThreshold(secondaryThreshold);         setInertia(inertiaMillis);         preUpdate();     }      /** Creates a new Trigger object. */     protected Trigger() {         super(null);     }      //~ Methods **************************************************************************************************************************************      /**      * Evaluates the trigger against actualValue (passed as parameter).      *      * @param   trigger      trigger to be evaluated.      * @param   actualValue  value against the trigger to be evaluated.      *      * @return  true if the trigger should be fired so that notification will be sent otherwise false.      *      * @throws  SystemException  If an error in evaluation occurs.      */     public static boolean evaluateTrigger(Trigger trigger, Double actualValue) {         requireArgument(trigger != null, &quot;Trigger cannot be null.&quot;);         requireArgument(actualValue != null, &quot;Trigger cannot be evaulated against null.&quot;);          Double lowThreshold, highThreshold;          switch (trigger.type) {             case GREATER_THAN:                 return actualValue.compareTo(trigger.getThreshold()) &gt; 0;             case GREATER_THAN_OR_EQ:                 return actualValue.compareTo(trigger.getThreshold()) &gt;= 0;             case LESS_THAN:                 return actualValue.compareTo(trigger.getThreshold()) &lt; 0;             case LESS_THAN_OR_EQ:                 return actualValue.compareTo(trigger.getThreshold()) &lt;= 0;             case EQUAL:                 return actualValue.compareTo(trigger.getThreshold()) == 0;             case NOT_EQUAL:                 return actualValue.compareTo(trigger.getThreshold()) != 0;             case BETWEEN:                 lowThreshold = Math.min(trigger.getThreshold(), trigger.getSecondaryThreshold());                 highThreshold = Math.max(trigger.getThreshold(), trigger.getSecondaryThreshold());                 return (actualValue.compareTo(lowThreshold) &gt;= 0 &amp;&amp; actualValue.compareTo(highThreshold) &lt;= 0);             case NOT_BETWEEN:                 lowThreshold = Math.min(trigger.getThreshold(), trigger.getSecondaryThreshold());                 highThreshold = Math.max(trigger.getThreshold(), trigger.getSecondaryThreshold());                 return (actualValue.compareTo(lowThreshold) &lt; 0 || actualValue.compareTo(highThreshold) &gt; 0);             case NO_DATA:             	    return actualValue == null;             default:                 throw new SystemException(&quot;Unsupported trigger type &quot; + trigger.type);         }     }      //~ Methods **************************************************************************************************************************************      /**      * Returns the notifications associated with the trigger.      *      * @return  The associated notifications.      */     public List getNotifications() {         return Collections.unmodifiableList(notifications);     }      /**      * Returns the trigger type.      *      * @return  The trigger type. Will never be null.      */     public TriggerType getType() {         return type;     }      /**      * Sets the trigger type.      *      * @param  type  The trigger type. Cannot be null.      */     public void setType(TriggerType type) {         requireArgument(type != null, &quot;The trigger type cannot be null.&quot;);         this.type = type;     }      /**      * Returns the trigger name.      *      * @return  The trigger name. Will never be null.      */     public String getName() {         return name;     }      /**      * Sets the name of the trigger.      *      * @param  name  The trigger name. Cannot be null or empty.      */     public void setName(String name) {         requireArgument(name != null &amp;&amp; !name.isEmpty(), &quot;Trigger name cannot be null or empty.&quot;);         this.name = name;     }      /**      * Returns the trigger threshold.      *      * @return  The trigger threshold.      */     public Double getThreshold() {         return threshold;     }      /**      * Sets the trigger threshold.      *      * @param  threshold  The trigger threshold. Cannot be null.      */     public void setThreshold(Double threshold) {         requireArgument(threshold != null, &quot;Trigger threshold cannot be null.&quot;);         this.threshold = threshold;     }      /**      * Returns the secondary threshold for the trigger.      *      * @return  The secondary threshold. Can return null for trigger types that only require a single threshold.      */     public Double getSecondaryThreshold() {         return secondaryThreshold;     }      /**      * Sets the secondary threshold for the trigger.      *      * @param  secondaryThreshold  The secondary threshold. Can be null for trigger types that only require a single threshold.      */     public void setSecondaryThreshold(Double secondaryThreshold) {         this.secondaryThreshold = secondaryThreshold;     }      /**      * Returns the inertia associated with the trigger in milliseconds.      *      * @return  The inertia in milliseconds.      */     public Long getInertia() {         return inertia;     }      /**      * Sets the inertia associated with the trigger in milliseconds.      *      * @param  inertiaMillis  The inertia associated with the trigger in milliseconds. Cannot be null or negative.      */     public void setInertia(Long inertiaMillis) {         if (this.alert == null) { // Only during deserialization.             this.inertia = inertiaMillis;         } else {             requireArgument(inertiaMillis != null &amp;&amp; inertiaMillis &gt;= 0, &quot;Inertia cannot be negative.&quot;);             Long longestIntervalLength = AlertUtils.getMaximumIntervalLength(this.alert.getExpression());             if (inertiaMillis &gt; longestIntervalLength)                 throw new IllegalArgumentException(String.format(&quot;Inertia %d cannot be more than width of the longest interval %d.&quot;, inertiaMillis, longestIntervalLength));             this.inertia = inertiaMillis;         }     }      /**      * Returns the alert with which the trigger is associated.      *      * @return  The alert with which the trigger is associated.      */     public Alert getAlert() {         return alert;     }      /**      * Sets the alert with which the trigger is associated.      *      * @param  alert  The alert with which the trigger is associated. Cannot be null.      */     public void setAlert(Alert alert) {         requireArgument(alert != null, &quot;The alert with which a trigger is associated cannot be null.&quot;);         this.alert = alert;     }      @Override     public int hashCode() {         int hash = 7;          hash = 97 * hash + Objects.hashCode(this.name);         hash = 97 * hash + Objects.hashCode(this.alert);         return hash;     }      @Override     public boolean equals(Object obj) {         if (obj == null) {             return false;         }         if (getClass() != obj.getClass()) {             return false;         }          final Trigger other = (Trigger) obj;          if (!Objects.equals(this.name, other.name)) {             return false;         }         if (!Objects.equals(this.alert, other.alert)) {             return false;         }         return true;     }      @Override     public String toString() {         if (type == TriggerType.BETWEEN || type == TriggerType.NOT_BETWEEN)             return &quot;Trigger{&quot; + &quot;type=&quot; + type + &quot;, name=&quot; + name + &quot;, primaryThreshold=&quot; + threshold + &quot;, secondaryThreshold=&quot; + secondaryThreshold +             &quot;, inertia=&quot; + inertia + '}';         else             return &quot;Trigger{&quot; + &quot;type=&quot; + type + &quot;, name=&quot; + name + &quot;, threshold=&quot; + threshold + &quot;, inertia=&quot; + inertia + '}';     }      //~ Enums ****************************************************************************************************************************************      /**      * The type of trigger.      *      * @author  Tom Valine (tvaline@salesforce.com)      */     public enum TriggerType {          /** Greater than. */         GREATER_THAN,         /** Greater than or equal to. */         GREATER_THAN_OR_EQ,         /** Less than. */         LESS_THAN,         /** Less than or equal to. */         LESS_THAN_OR_EQ,         /** Equal to. */         EQUAL,         /** Not equal to. */         NOT_EQUAL,         /** Between. */         BETWEEN,         /** Not between. */         NOT_BETWEEN,     	    /** No Data */     	    NO_DATA;          /**          * Converts a string to a trigger type.          *          * @param   name  The trigger type name.          *          * @return  The corresponding trigger type.          *          * @throws  IllegalArgumentException  If no corresponding trigger type is found.          */         @JsonCreator         public static TriggerType fromString(String name) {             for (TriggerType t : TriggerType.values()) {                 if (t.toString().equalsIgnoreCase(name)) {                     return t;                 }             }             throw new IllegalArgumentException(&quot;Trigger Type does not exist.&quot;);         }          /**          * Returns the name of the trigger type.          *          * @return  The name of the trigger type.          */         @JsonValue         public String value() {             return this.toString();         }      } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method2 Feature envy3 Duplicate code4 Magic numbers5 Inappropriate comments6 Data class7 Many parameters8 Primitive obsession9 Dead code</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12871</td>
    <td align="left">https://github.com/salesforce/Argus/blob/121b59a268da264316cded6a3e9271366a23cd86/ArgusCore/src/main/java/com/salesforce/dva/argus/entity/Trigger.java/#L88-L491</td>
    <td align="right">2</td>
    <td align="right">2045</td>
    <td align="right">12871</td>
  </tr>
  <tr valign="top">
    <td align="right">1180</td>
    <td align="left">{&quot;response&quot;: &quot;YES, I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ShuffleWriteMetrics {     private long bytesWritten;      private long recordsWritten;      private long writeTime;      public long getBytesWritten ()     {         return bytesWritten;     }      public void setBytesWritten (long bytesWritten)     {         this.bytesWritten = bytesWritten;     }      public long getRecordsWritten ()     {         return recordsWritten;     }      public void setRecordsWritten (long recordsWritten)     {         this.recordsWritten = recordsWritten;     }      public long getWriteTime ()     {         return writeTime;     }      public void setWriteTime (long writeTime)     {         this.writeTime = writeTime;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10230</td>
    <td align="left">https://github.com/Microsoft/azure-tools-for-java/blob/d121e8ac9cc3ab400e5b49c8b372280ae332f3fb/Utils/hdinsight-node-common/src/com/microsoft/azure/hdinsight/sdk/rest/spark/task/ShuffleWriteMetrics.java/#L24-L60</td>
    <td align="right">1</td>
    <td align="right">1180</td>
    <td align="right">10230</td>
  </tr>
  <tr valign="top">
    <td align="right">1851</td>
    <td align="left">&nbsp;&nbsp;YES, I found bad smells the bad smells are: 1. Long method 2. Feature envy: multiple methods operate on the same instance variables  3. Primitive obsession: use of multiple boolean variables to represent different types  4. Message chain: method chaining in multiple places  5. Data class: class contains no behavior and just stores data  6. Duplicated code: similar logic repeated in multiple methods  7. Lack of encapsulation: direct access to all instance variables from outside the class  8. Switch statements instead of polymorphism: if/else statements used to handle different types instead of creating subclasses  9. Lack of abstraction: many specific boolean variables used instead of a single abstracted class  10. Comments used instead of meaningful method names: non-descriptive method names with comments explaining functionality instead  11. Unnecessary constructor parameters: excessive parameters in constructor that are not used in the class </td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class FieldAttributeModel {    /** Typescript value of the type of the field */   private final String typeName;    /** For Map, List object, need to initialize field first. Like new Field&lt;&gt;() */   private boolean needInitialize;    /** Name of the field */   private String fieldName;    /** Java Type of the object (used internally) */   private Type type;    /** This field type is a List of objects ? */   private boolean isList;    /** This field type is a simple primitive */   private boolean isPrimitive;    /** This field type is a map */   private boolean isMap;    /** This list type is in fact a list of DTOs */   private boolean isListOfDto;    /** This map type is a map of DTOs */   private boolean isMapOfDto;    /**    * The type is a DTO or a list of DTO and then this value is the name of the DTO implementation    */   private String dtoImpl;    /** type is a DTO object. */   private boolean isDto;    /** type is a Enum object. */   private boolean isEnum;    /** Map key type */   private String mapKeyType;    /** Map value type */   private String mapValueType;    /** Dto type for d.ts */   private String dtsType;    /** Dto class where this field declared */   private Class declarationClass;    /**    * Build a new field model based on the name and Java type    *    * @param fieldName the name of the field    * @param type the Java raw type that will allow further analyzes    * @param declarationClass    */   public FieldAttributeModel(String fieldName, Type type, Class declarationClass) {     this.fieldName = fieldName;     this.type = type;     this.typeName = convertType(type);     this.dtsType = convertTypeForDTS(declarationClass, type);     this.declarationClass = declarationClass;      if (typeName.startsWith(&quot;Array&lt;&quot;) || typeName.startsWith(&quot;Map&lt;&quot;)) {       this.needInitialize = true;     }      if (this.type instanceof ParameterizedType) {       ParameterizedType parameterizedType = (ParameterizedType) this.type;       Type rawType = parameterizedType.getRawType();       analyzeParametrizedType(parameterizedType, rawType);     } else if (Primitives.isPrimitive(this.type)         || Primitives.isWrapperType(this.type)         || String.class.equals(this.type)) {       this.isPrimitive = true;     } else if (this.type instanceof Class &amp;&amp; ((Class) this.type).isAnnotationPresent(DTO.class)) {       this.isDto = true;       dtoImpl = this.type.getTypeName() + &quot;Impl&quot;;     } else if (this.type instanceof Class &amp;&amp; ((Class) this.type).isEnum()) {       this.isEnum = true;     }   }    /**    * Analyze a complex parametrized type attribute (which can be a list or map for example)    *    * @param parameterizedType    * @param rawType    */   protected void analyzeParametrizedType(ParameterizedType parameterizedType, Type rawType) {     if (List.class.equals(rawType)) {       this.isList = true;       if (parameterizedType.getActualTypeArguments()[0] instanceof Class           &amp;&amp; ((Class) parameterizedType.getActualTypeArguments()[0])               .isAnnotationPresent(DTO.class)) {         isListOfDto = true;         dtoImpl = convertType(parameterizedType.getActualTypeArguments()[0]) + &quot;Impl&quot;;       }     } else if (Map.class.equals(rawType)) {       isMap = true;       mapKeyType =           convertTypeForDTS(declarationClass, parameterizedType.getActualTypeArguments()[0]);       if (parameterizedType.getActualTypeArguments()[1] instanceof Class           &amp;&amp; ((Class) parameterizedType.getActualTypeArguments()[1])               .isAnnotationPresent(DTO.class)) {          isMapOfDto = true;         dtoImpl = convertType(parameterizedType.getActualTypeArguments()[1]) + &quot;Impl&quot;;       }        mapValueType =           convertTypeForDTS(declarationClass, parameterizedType.getActualTypeArguments()[1]);     }   }    public String getTypeName() {     return typeName;   }    public String getFieldName() {     return fieldName;   }    public Type getType() {     return type;   }    public boolean isList() {     return isList;   }    public boolean isPrimitive() {     return isPrimitive;   }    public boolean isMap() {     return isMap;   }    public boolean isListOfDto() {     return isListOfDto;   }    public boolean isMapOfDto() {     return isMapOfDto;   }    public String getDtoImpl() {     return dtoImpl;   }    public boolean isDto() {     return isDto;   }    public boolean isNeedInitialize() {     return needInitialize;   }    public boolean isEnum() {     return isEnum;   }    public String getName() {     return this.fieldName;   }    public String getSimpleType() {     return this.typeName;   }    public String getMapKeyType() {     return mapKeyType;   }    public String getMapValueType() {     return mapValueType;   }    public String getDtsType() {     return dtsType;   } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method2 Feature envy: multiple methods operate on the same instance variables 3 Primitive obsession: use of multiple boolean variables to represent different types 4 Message chain: method chaining in multiple places 5 Data class: class contains no behavior and just stores data 6 Duplicated code: similar logic repeated in multiple methods 7 Lack of encapsulation: direct access to all instance variables from outside the class 8 Switch statements instead of polymorphism: if/else statements used to handle different types instead of creating subclasses 9 Lack of abstraction: many specific boolean variables used instead of a single abstracted class </td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12190</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/core/che-core-typescript-dto-maven-plugin/src/main/java/org/eclipse/che/plugin/typescript/dto/model/FieldAttributeModel.java/#L29-L214</td>
    <td align="right">2</td>
    <td align="right">1851</td>
    <td align="right">12190</td>
  </tr>
  <tr valign="top">
    <td align="right">1524</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TeamContext {      /**     * The team project Id or name.  Ignored if ProjectId is set.     */     private String project;     /**     * The Team Project ID.  Required if Project is not set.     */     private UUID projectId;     /**     * The Team Id or name.  Ignored if TeamId is set.     */     private String team;     /**     * The Team Id     */     private UUID teamId;      /**     * The team project Id or name.  Ignored if ProjectId is set.     */     public String getProject() {         return project;     }      /**     * The team project Id or name.  Ignored if ProjectId is set.     */     public void setProject(final String project) {         this.project = project;     }      /**     * The Team Project ID.  Required if Project is not set.     */     public UUID getProjectId() {         return projectId;     }      /**     * The Team Project ID.  Required if Project is not set.     */     public void setProjectId(final UUID projectId) {         this.projectId = projectId;     }      /**     * The Team Id or name.  Ignored if TeamId is set.     */     public String getTeam() {         return team;     }      /**     * The Team Id or name.  Ignored if TeamId is set.     */     public void setTeam(final String team) {         this.team = team;     }      /**     * The Team Id     */     public UUID getTeamId() {         return teamId;     }      /**     * The Team Id     */     public void setTeamId(final UUID teamId) {         this.teamId = teamId;     } }</td>
    <td align="left">data class</td>
    <td align="left">Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11182</td>
    <td align="left">https://github.com/Microsoft/vso-httpclient-java/blob/7b6329238498d7ad1934243150f955bea594df37/Rest/alm-tfs-client/src/main/generated/com/microsoft/alm/teamfoundation/core/webapi/types/TeamContext.java/#L24-L98</td>
    <td align="right">1</td>
    <td align="right">1524</td>
    <td align="right">11182</td>
  </tr>
  <tr valign="top">
    <td align="right">108</td>
    <td align="left">&nbsp;{   &quot;answer&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells&quot;: [     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Customer1953 {  	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id; 	private String firstName; 	private String lastName;  	protected Customer1953() {}  	public Customer1953(String firstName, String lastName) { 		this.firstName = firstName; 		this.lastName = lastName; 	}  	@Override 	public String toString() { 		return String.format(&quot;Customer1953[id=%d, firstName='%s', lastName='%s']&quot;, id, firstName, lastName); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1440</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer1953.java/#L8-L27</td>
    <td align="right">1</td>
    <td align="right">108</td>
    <td align="right">1440</td>
  </tr>
  <tr valign="top">
    <td align="right">229</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TransformIterator implements Iterator {      /** The iterator being used */     private Iterator iterator;     /** The transformer being used */     private Transformer transformer;      //-----------------------------------------------------------------------     /**      * Constructs a new TransformIterator that will not function      * until the {@link #setIterator(Iterator) setIterator} and      * {@link #setTransformer(Transformer)} methods are invoked.      */     public TransformIterator() {         super();     }      /**      * Constructs a new TransformIterator that won't transform      * elements from the given iterator.      *      * @param iterator  the iterator to use      */     public TransformIterator(final Iterator iterator) {         super();         this.iterator = iterator;     }      /**      * Constructs a new TransformIterator that will use the      * given iterator and transformer.  If the given transformer is null,      * then objects will not be transformed.      *      * @param iterator  the iterator to use      * @param transformer  the transformer to use      */     public TransformIterator(final Iterator iterator,                              final Transformer transformer) {         super();         this.iterator = iterator;         this.transformer = transformer;     }      //-----------------------------------------------------------------------     @Override     public boolean hasNext() {         return iterator.hasNext();     }      /**      * Gets the next object from the iteration, transforming it using the      * current transformer. If the transformer is null, no transformation      * occurs and the object from the iterator is returned directly.      *      * @return the next object      * @throws java.util.NoSuchElementException if there are no more elements      */     @Override     public O next() {         return transform(iterator.next());     }      @Override     public void remove() {         iterator.remove();     }      //-----------------------------------------------------------------------     /**      * Gets the iterator this iterator is using.      *      * @return the iterator.      */     public Iterator getIterator() {         return iterator;     }      /**      * Sets the iterator for this iterator to use.      * If iteration has started, this effectively resets the iterator.      *      * @param iterator  the iterator to use      */     public void setIterator(final Iterator iterator) {         this.iterator = iterator;     }      //-----------------------------------------------------------------------     /**      * Gets the transformer this iterator is using.      *      * @return the transformer.      */     public Transformer getTransformer() {         return transformer;     }      /**      * Sets the transformer this the iterator to use.      * A null transformer is a no-op transformer.      *      * @param transformer  the transformer to use      */     public void setTransformer(final Transformer transformer) {         this.transformer = transformer;     }      //-----------------------------------------------------------------------     /**      * Transforms the given object using the transformer.      * If the transformer is null, the original object is returned as-is.      *      * @param source  the object to transform      * @return the transformed object      */     protected O transform(final I source) {         return transformer.transform(source);     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2506</td>
    <td align="left">https://github.com/apache/commons-collections/blob/bb0781551c7f1d7ddd28733acff95e1f130e766c/src/main/java/org/apache/commons/collections4/iterators/TransformIterator.java/#L28-L146</td>
    <td align="right">1</td>
    <td align="right">229</td>
    <td align="right">2506</td>
  </tr>
  <tr valign="top">
    <td align="right">97</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public static class Undertow {  		/** 		 * Maximum size of the HTTP post content. When the value is -1, the default, the 		 * size is unlimited. 		 */ 		private DataSize maxHttpPostSize = DataSize.ofBytes(-1);  		/** 		 * Size of each buffer. The default is derived from the maximum amount of memory 		 * that is available to the JVM. 		 */ 		private DataSize bufferSize;  		/** 		 * Number of I/O threads to create for the worker. The default is derived from the 		 * number of available processors. 		 */ 		private Integer ioThreads;  		/** 		 * Number of worker threads. The default is 8 times the number of I/O threads. 		 */ 		private Integer workerThreads;  		/** 		 * Whether to allocate buffers outside the Java heap. The default is derived from 		 * the maximum amount of memory that is available to the JVM. 		 */ 		private Boolean directBuffers;  		/** 		 * Whether servlet filters should be initialized on startup. 		 */ 		private boolean eagerFilterInit = true;  		private final Accesslog accesslog = new Accesslog();  		public DataSize getMaxHttpPostSize() { 			return this.maxHttpPostSize; 		}  		public void setMaxHttpPostSize(DataSize maxHttpPostSize) { 			this.maxHttpPostSize = maxHttpPostSize; 		}  		public DataSize getBufferSize() { 			return this.bufferSize; 		}  		public void setBufferSize(DataSize bufferSize) { 			this.bufferSize = bufferSize; 		}  		public Integer getIoThreads() { 			return this.ioThreads; 		}  		public void setIoThreads(Integer ioThreads) { 			this.ioThreads = ioThreads; 		}  		public Integer getWorkerThreads() { 			return this.workerThreads; 		}  		public void setWorkerThreads(Integer workerThreads) { 			this.workerThreads = workerThreads; 		}  		public Boolean getDirectBuffers() { 			return this.directBuffers; 		}  		public void setDirectBuffers(Boolean directBuffers) { 			this.directBuffers = directBuffers; 		}  		public boolean isEagerFilterInit() { 			return this.eagerFilterInit; 		}  		public void setEagerFilterInit(boolean eagerFilterInit) { 			this.eagerFilterInit = eagerFilterInit; 		}  		public Accesslog getAccesslog() { 			return this.accesslog; 		}  		/** 		 * Undertow access log properties. 		 */ 		public static class Accesslog {  			/** 			 * Whether to enable the access log. 			 */ 			private boolean enabled = false;  			/** 			 * Format pattern for access logs. 			 */ 			private String pattern = &quot;common&quot;;  			/** 			 * Log file name prefix. 			 */ 			protected String prefix = &quot;access_log.&quot;;  			/** 			 * Log file name suffix. 			 */ 			private String suffix = &quot;log&quot;;  			/** 			 * Undertow access log directory. 			 */ 			private File dir = new File(&quot;logs&quot;);  			/** 			 * Whether to enable access log rotation. 			 */ 			private boolean rotate = true;  			public boolean isEnabled() { 				return this.enabled; 			}  			public void setEnabled(boolean enabled) { 				this.enabled = enabled; 			}  			public String getPattern() { 				return this.pattern; 			}  			public void setPattern(String pattern) { 				this.pattern = pattern; 			}  			public String getPrefix() { 				return this.prefix; 			}  			public void setPrefix(String prefix) { 				this.prefix = prefix; 			}  			public String getSuffix() { 				return this.suffix; 			}  			public void setSuffix(String suffix) { 				this.suffix = suffix; 			}  			public File getDir() { 				return this.dir; 			}  			public void setDir(File dir) { 				this.dir = dir; 			}  			public boolean isRotate() { 				return this.rotate; 			}  			public void setRotate(boolean rotate) { 				this.rotate = rotate; 			}  		}  	}</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1279</td>
    <td align="left">https://github.com/spring-projects/spring-boot/blob/2225b362991f225e3a93f00e160526d2b8abdfb2/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java/#L949-L1124</td>
    <td align="right">1</td>
    <td align="right">97</td>
    <td align="right">1279</td>
  </tr>
  <tr valign="top">
    <td align="right">2044</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DebugInfoDecoder {     /** encoded debug info */     private final byte[] encoded;      /** positions decoded */     private final ArrayList positions;      /** locals decoded */     private final ArrayList locals;      /** size of code block in code units */     private final int codesize;      /** indexed by register, the last local variable live in a reg */     private final LocalEntry[] lastEntryForReg;      /** method descriptor of method this debug info is for */     private final Prototype desc;      /** true if method is static */     private final boolean isStatic;      /** dex file this debug info will be stored in */     private final DexFile file;      /**      * register size, in register units, of the register space      * used by this method      */     private final int regSize;      /** current decoding state: line number */     private int line = 1;      /** current decoding state: bytecode address */     private int address = 0;      /** string index of the string &quot;this&quot; */     private final int thisStringIdx;      /**      * Constructs an instance.      *      * @param encoded encoded debug info      * @param codesize size of code block in code units      * @param regSize register size, in register units, of the register space      * used by this method      * @param isStatic true if method is static      * @param ref method descriptor of method this debug info is for      * @param file dex file this debug info will be stored in      */     DebugInfoDecoder(byte[] encoded, int codesize, int regSize,             boolean isStatic, CstMethodRef ref, DexFile file) {         if (encoded == null) {             throw new NullPointerException(&quot;encoded == null&quot;);         }          this.encoded = encoded;         this.isStatic = isStatic;         this.desc = ref.getPrototype();         this.file = file;         this.regSize = regSize;          positions = new ArrayList();         locals = new ArrayList();         this.codesize = codesize;         lastEntryForReg = new LocalEntry[regSize];          int idx = -1;          try {             idx = file.getStringIds().indexOf(new CstString(&quot;this&quot;));         } catch (IllegalArgumentException ex) {             /*              * Silently tolerate not finding &quot;this&quot;. It just means that              * no method has local variable info that looks like              * a standard instance method.              */         }          thisStringIdx = idx;     }      /**      * An entry in the resulting postions table      */     static private class PositionEntry {         /** bytecode address */         public int address;          /** line number */         public int line;          public PositionEntry(int address, int line) {             this.address = address;             this.line = line;         }     }      /**      * An entry in the resulting locals table      */     static private class LocalEntry {         /** address of event */         public int address;          /** {@code true} iff it's a local start */         public boolean isStart;          /** register number */         public int reg;          /** index of name in strings table */         public int nameIndex;          /** index of type in types table */         public int typeIndex;          /** index of type signature in strings table */         public int signatureIndex;          public LocalEntry(int address, boolean isStart, int reg, int nameIndex,                 int typeIndex, int signatureIndex) {             this.address        = address;             this.isStart        = isStart;             this.reg            = reg;             this.nameIndex      = nameIndex;             this.typeIndex      = typeIndex;             this.signatureIndex = signatureIndex;         }          public String toString() {             return String.format(&quot;[%x %s v%d %04x %04x %04x]&quot;,                     address, isStart ? &quot;start&quot; : &quot;end&quot;, reg,                     nameIndex, typeIndex, signatureIndex);         }     }      /**      * Gets the decoded positions list.      * Valid after calling {@code decode}.      *      * @return positions list in ascending address order.      */     public List getPositionList() {         return positions;     }      /**      * Gets the decoded locals list, in ascending start-address order.      * Valid after calling {@code decode}.      *      * @return locals list in ascending address order.      */     public List getLocals() {         return locals;     }      /**      * Decodes the debug info sequence.      */     public void decode() {         try {             decode0();         } catch (Exception ex) {             throw ExceptionWithContext.withContext(ex,                     &quot;...while decoding debug info&quot;);         }     }      /**      * Reads a string index. String indicies are offset by 1, and a 0 value      * in the stream (-1 as returned by this method) means &quot;null&quot;      *      * @return index into file's string ids table, -1 means null      * @throws IOException      */     private int readStringIndex(ByteInput bs) throws IOException {         int offsetIndex = Leb128.readUnsignedLeb128(bs);          return offsetIndex - 1;     }      /**      * Gets the register that begins the method's parameter range (including      * the 'this' parameter for non-static methods). The range continues until      * {@code regSize}      *      * @return register as noted above.      */     private int getParamBase() {         return regSize                 - desc.getParameterTypes().getWordCount() - (isStatic? 0 : 1);     }      private void decode0() throws IOException {         ByteInput bs = new ByteArrayByteInput(encoded);          line = Leb128.readUnsignedLeb128(bs);         int szParams = Leb128.readUnsignedLeb128(bs);         StdTypeList params = desc.getParameterTypes();         int curReg = getParamBase();          if (szParams != params.size()) {             throw new RuntimeException(                     &quot;Mismatch between parameters_size and prototype&quot;);         }          if (!isStatic) {             // Start off with implicit 'this' entry             LocalEntry thisEntry =                 new LocalEntry(0, true, curReg, thisStringIdx, 0, 0);             locals.add(thisEntry);             lastEntryForReg[curReg] = thisEntry;             curReg++;         }          for (int i = 0; i &lt; szParams; i++) {             Type paramType = params.getType(i);             LocalEntry le;              int nameIdx = readStringIndex(bs);              if (nameIdx == -1) {                 /*                  * Unnamed parameter; often but not always filled in by an                  * extended start op after the prologue                  */                 le = new LocalEntry(0, true, curReg, -1, 0, 0);             } else {                 // TODO: Final 0 should be idx of paramType.getDescriptor().                 le = new LocalEntry(0, true, curReg, nameIdx, 0, 0);             }              locals.add(le);             lastEntryForReg[curReg] = le;             curReg += paramType.getCategory();         }          for (;;) {             int opcode = bs.readByte() &amp; 0xff;              switch (opcode) {                 case DBG_START_LOCAL: {                     int reg = Leb128.readUnsignedLeb128(bs);                     int nameIdx = readStringIndex(bs);                     int typeIdx = readStringIndex(bs);                     LocalEntry le = new LocalEntry(                             address, true, reg, nameIdx, typeIdx, 0);                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_START_LOCAL_EXTENDED: {                     int reg = Leb128.readUnsignedLeb128(bs);                     int nameIdx = readStringIndex(bs);                     int typeIdx = readStringIndex(bs);                     int sigIdx = readStringIndex(bs);                     LocalEntry le = new LocalEntry(                             address, true, reg, nameIdx, typeIdx, sigIdx);                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_RESTART_LOCAL: {                     int reg = Leb128.readUnsignedLeb128(bs);                     LocalEntry prevle;                     LocalEntry le;                      try {                         prevle = lastEntryForReg[reg];                          if (prevle.isStart) {                             throw new RuntimeException(&quot;nonsensical &quot;                                     + &quot;RESTART_LOCAL on live register v&quot;                                     + reg);                         }                          le = new LocalEntry(address, true, reg,                                 prevle.nameIndex, prevle.typeIndex, 0);                     } catch (NullPointerException ex) {                         throw new RuntimeException(                                 &quot;Encountered RESTART_LOCAL on new v&quot; + reg);                     }                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_END_LOCAL: {                     int reg = Leb128.readUnsignedLeb128(bs);                     LocalEntry prevle;                     LocalEntry le;                      try {                         prevle = lastEntryForReg[reg];                          if (!prevle.isStart) {                             throw new RuntimeException(&quot;nonsensical &quot;                                     + &quot;END_LOCAL on dead register v&quot; + reg);                         }                          le = new LocalEntry(address, false, reg,                                 prevle.nameIndex, prevle.typeIndex,                                 prevle.signatureIndex);                     } catch (NullPointerException ex) {                         throw new RuntimeException(                                 &quot;Encountered END_LOCAL on new v&quot; + reg);                     }                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_END_SEQUENCE:                     // all done                 return;                  case DBG_ADVANCE_PC:                     address += Leb128.readUnsignedLeb128(bs);                 break;                  case DBG_ADVANCE_LINE:                     line += Leb128.readSignedLeb128(bs);                 break;                  case DBG_SET_PROLOGUE_END:                     //TODO do something with this.                 break;                  case DBG_SET_EPILOGUE_BEGIN:                     //TODO do something with this.                 break;                  case DBG_SET_FILE:                     //TODO do something with this.                 break;                  default:                     if (opcode &lt; DBG_FIRST_SPECIAL) {                         throw new RuntimeException(                                 &quot;Invalid extended opcode encountered &quot;                                         + opcode);                     }                      int adjopcode = opcode - DBG_FIRST_SPECIAL;                      address += adjopcode / DBG_LINE_RANGE;                     line += DBG_LINE_BASE + (adjopcode % DBG_LINE_RANGE);                      positions.add(new PositionEntry(address, line));                 break;              }         }     }      /**      * Validates an encoded debug info stream against data used to encode it,      * throwing an exception if they do not match. Used to validate the      * encoder.      *      * @param info encoded debug info      * @param file {@code non-null;} file to refer to during decoding      * @param ref {@code non-null;} method whose info is being decoded      * @param code {@code non-null;} original code object that was encoded      * @param isStatic whether the method is static      */     public static void validateEncode(byte[] info, DexFile file,             CstMethodRef ref, DalvCode code, boolean isStatic) {         PositionList pl = code.getPositions();         LocalList ll = code.getLocals();         DalvInsnList insns = code.getInsns();         int codeSize = insns.codeSize();         int countRegisters = insns.getRegistersSize();          try {             validateEncode0(info, codeSize, countRegisters,                     isStatic, ref, file, pl, ll);         } catch (RuntimeException ex) {             System.err.println(&quot;instructions:&quot;);             insns.debugPrint(System.err, &quot;  &quot;, true);             System.err.println(&quot;local list:&quot;);             ll.debugPrint(System.err, &quot;  &quot;);             throw ExceptionWithContext.withContext(ex,                     &quot;while processing &quot; + ref.toHuman());         }     }      private static void validateEncode0(byte[] info, int codeSize,             int countRegisters, boolean isStatic, CstMethodRef ref,             DexFile file, PositionList pl, LocalList ll) {         DebugInfoDecoder decoder                 = new DebugInfoDecoder(info, codeSize, countRegisters,                     isStatic, ref, file);          decoder.decode();          /*          * Go through the decoded position entries, matching up          * with original entries.          */          List decodedEntries = decoder.getPositionList();          if (decodedEntries.size() != pl.size()) {             throw new RuntimeException(                     &quot;Decoded positions table not same size was &quot;                     + decodedEntries.size() + &quot; expected &quot; + pl.size());         }          for (PositionEntry entry : decodedEntries) {             boolean found = false;             for (int i = pl.size() - 1; i &gt;= 0; i--) {                 PositionList.Entry ple = pl.get(i);                  if (entry.line == ple.getPosition().getLine()                         &amp;&amp; entry.address == ple.getAddress()) {                     found = true;                     break;                 }             }              if (!found) {                 throw new RuntimeException (&quot;Could not match position entry: &quot;                         + entry.address + &quot;, &quot; + entry.line);             }         }          /*          * Go through the original local list, in order, matching up          * with decoded entries.          */          List decodedLocals = decoder.getLocals();         int thisStringIdx = decoder.thisStringIdx;         int decodedSz = decodedLocals.size();         int paramBase = decoder.getParamBase();          /*          * Preflight to fill in any parameters that were skipped in          * the prologue (including an implied &quot;this&quot;) but then          * identified by full signature.          */         for (int i = 0; i &lt; decodedSz; i++) {             LocalEntry entry = decodedLocals.get(i);             int idx = entry.nameIndex;              if ((idx &lt; 0) || (idx == thisStringIdx)) {                 for (int j = i + 1; j &lt; decodedSz; j++) {                     LocalEntry e2 = decodedLocals.get(j);                     if (e2.address != 0) {                         break;                     }                     if ((entry.reg == e2.reg) &amp;&amp; e2.isStart) {                         decodedLocals.set(i, e2);                         decodedLocals.remove(j);                         decodedSz--;                         break;                     }                 }             }         }          int origSz = ll.size();         int decodeAt = 0;         boolean problem = false;          for (int i = 0; i &lt; origSz; i++) {             LocalList.Entry origEntry = ll.get(i);              if (origEntry.getDisposition()                     == LocalList.Disposition.END_REPLACED) {                 /*                  * The encoded list doesn't represent replacements, so                  * ignore them for the sake of comparison.                  */                 continue;             }              LocalEntry decodedEntry;              do {                 decodedEntry = decodedLocals.get(decodeAt);                 if (decodedEntry.nameIndex &gt;= 0) {                     break;                 }                 /*                  * A negative name index means this is an anonymous                  * parameter, and we shouldn't expect to see it in the                  * original list. So, skip it.                  */                 decodeAt++;             } while (decodeAt &lt; decodedSz);              int decodedAddress = decodedEntry.address;              if (decodedEntry.reg != origEntry.getRegister()) {                 System.err.println(&quot;local register mismatch at orig &quot; + i +                         &quot; / decoded &quot; + decodeAt);                 problem = true;                 break;             }              if (decodedEntry.isStart != origEntry.isStart()) {                 System.err.println(&quot;local start/end mismatch at orig &quot; + i +                         &quot; / decoded &quot; + decodeAt);                 problem = true;                 break;             }              /*              * The secondary check here accounts for the fact that a              * parameter might not be marked as starting at 0 in the              * original list.              */             if ((decodedAddress != origEntry.getAddress())                     &amp;&amp; !((decodedAddress == 0)                             &amp;&amp; (decodedEntry.reg &gt;= paramBase))) {                 System.err.println(&quot;local address mismatch at orig &quot; + i +                         &quot; / decoded &quot; + decodeAt);                 problem = true;                 break;             }              decodeAt++;         }          if (problem) {             System.err.println(&quot;decoded locals:&quot;);             for (LocalEntry e : decodedLocals) {                 System.err.println(&quot;  &quot; + e);             }             throw new RuntimeException(&quot;local table problem&quot;);         }     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12869</td>
    <td align="left">https://github.com/facebook/buck/blob/1bc8d383ea5cb153ca9bf4f2807e6be498648523/third-party/java/dx/src/com/android/dx/dex/file/DebugInfoDecoder.java/#L54-L596</td>
    <td align="right">1</td>
    <td align="right">2044</td>
    <td align="right">12869</td>
  </tr>
  <tr valign="top">
    <td align="right">251</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Long Method&quot;,       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Internal public final class ShortSerializer extends TypeSerializerSingleton {  	private static final long serialVersionUID = 1L;  	/** Sharable instance of the ShortSerializer. */ 	public static final ShortSerializer INSTANCE = new ShortSerializer();  	private static final Short ZERO = (short) 0;  	@Override 	public boolean isImmutableType() { 		return true; 	}  	@Override 	public Short createInstance() { 		return ZERO; 	}  	@Override 	public Short copy(Short from) { 		return from; 	}  	@Override 	public Short copy(Short from, Short reuse) { 		return from; 	}  	@Override 	public int getLength() { 		return 2; 	}  	@Override 	public void serialize(Short record, DataOutputView target) throws IOException { 		target.writeShort(record); 	}  	@Override 	public Short deserialize(DataInputView source) throws IOException { 		return source.readShort(); 	}  	@Override 	public Short deserialize(Short reuse, DataInputView source) throws IOException { 		return deserialize(source); 	}  	@Override 	public void copy(DataInputView source, DataOutputView target) throws IOException { 		target.writeShort(source.readShort()); 	}  	@Override 	public TypeSerializerSnapshot snapshotConfiguration() { 		return new ShortSerializerSnapshot(); 	}  	// ------------------------------------------------------------------------  	/** 	 * Serializer configuration snapshot for compatibility and format evolution. 	 */ 	@SuppressWarnings(&quot;WeakerAccess&quot;) 	public static final class ShortSerializerSnapshot extends SimpleTypeSerializerSnapshot {  		public ShortSerializerSnapshot() { 			super(() -&gt; INSTANCE); 		} 	} }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2690</td>
    <td align="left">https://github.com/apache/flink/blob/8068c8775ad067d75828e6360e7e0994348da9b9/flink-core/src/main/java/org/apache/flink/api/common/typeutils/base/ShortSerializer.java/#L32-L104</td>
    <td align="right">1</td>
    <td align="right">251</td>
    <td align="right">2690</td>
  </tr>
  <tr valign="top">
    <td align="right">827</td>
    <td align="left">{        &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@GroovyASTTransformation(phase = CompilePhase.CANONICALIZATION)  public class SortableASTTransformation extends AbstractASTTransformation {     private static final ClassNode MY_TYPE = make(Sortable.class);     private static final String MY_TYPE_NAME = &quot;@&quot; + MY_TYPE.getNameWithoutPackage();     private static final ClassNode COMPARABLE_TYPE = makeClassSafe(Comparable.class);     private static final ClassNode COMPARATOR_TYPE = makeClassSafe(Comparator.class);      private static final String VALUE = &quot;value&quot;;     private static final String OTHER = &quot;other&quot;;     private static final String THIS_HASH = &quot;thisHash&quot;;     private static final String OTHER_HASH = &quot;otherHash&quot;;     private static final String ARG0 = &quot;arg0&quot;;     private static final String ARG1 = &quot;arg1&quot;;      public void visit(ASTNode[] nodes, SourceUnit source) {         init(nodes, source);         AnnotationNode annotation = (AnnotationNode) nodes[0];         AnnotatedNode parent = (AnnotatedNode) nodes[1];         if (parent instanceof ClassNode) {             createSortable(annotation, (ClassNode) parent);         }     }      private void createSortable(AnnotationNode anno, ClassNode classNode) {         List includes = getMemberStringList(anno, &quot;includes&quot;);         List excludes = getMemberStringList(anno, &quot;excludes&quot;);         boolean reversed = memberHasValue(anno, &quot;reversed&quot;, true);         boolean includeSuperProperties = memberHasValue(anno, &quot;includeSuperProperties&quot;, true);         boolean allNames = memberHasValue(anno, &quot;allNames&quot;, true);         boolean allProperties = !memberHasValue(anno, &quot;allProperties&quot;, false);         if (!checkIncludeExcludeUndefinedAware(anno, excludes, includes, MY_TYPE_NAME)) return;         if (!checkPropertyList(classNode, includes, &quot;includes&quot;, anno, MY_TYPE_NAME, false, includeSuperProperties, allProperties)) return;         if (!checkPropertyList(classNode, excludes, &quot;excludes&quot;, anno, MY_TYPE_NAME, false, includeSuperProperties, allProperties)) return;         if (classNode.isInterface()) {             addError(MY_TYPE_NAME + &quot; cannot be applied to interface &quot; + classNode.getName(), anno);         }         List properties = findProperties(anno, classNode, includes, excludes, allProperties, includeSuperProperties, allNames);         implementComparable(classNode);          addGeneratedMethod(classNode,                 &quot;compareTo&quot;,                 ACC_PUBLIC,                 ClassHelper.int_TYPE,                 params(param(newClass(classNode), OTHER)),                 ClassNode.EMPTY_ARRAY,                 createCompareToMethodBody(properties, reversed)         );          for (PropertyNode property : properties) {             createComparatorFor(classNode, property, reversed);         }         new VariableScopeVisitor(sourceUnit, true).visitClass(classNode);     }      private static void implementComparable(ClassNode classNode) {         if (!classNode.implementsInterface(COMPARABLE_TYPE)) {             classNode.addInterface(makeClassSafeWithGenerics(Comparable.class, classNode));         }     }      private static Statement createCompareToMethodBody(List properties, boolean reversed) {         List statements = new ArrayList();          // if (this.is(other)) return 0;         statements.add(ifS(callThisX(&quot;is&quot;, args(OTHER)), returnS(constX(0))));          if (properties.isEmpty()) {             // perhaps overkill but let compareTo be based on hashes for commutativity             // return this.hashCode() &lt;=&gt; other.hashCode()             statements.add(declS(localVarX(THIS_HASH, ClassHelper.Integer_TYPE), callX(varX(&quot;this&quot;), &quot;hashCode&quot;)));             statements.add(declS(localVarX(OTHER_HASH, ClassHelper.Integer_TYPE), callX(varX(OTHER), &quot;hashCode&quot;)));             statements.add(returnS(compareExpr(varX(THIS_HASH), varX(OTHER_HASH), reversed)));         } else {             // int value = 0;             statements.add(declS(localVarX(VALUE, ClassHelper.int_TYPE), constX(0)));             for (PropertyNode property : properties) {                 String propName = property.getName();                 // value = this.prop &lt;=&gt; other.prop;                 statements.add(assignS(varX(VALUE), compareExpr(propX(varX(&quot;this&quot;), propName), propX(varX(OTHER), propName), reversed)));                 // if (value != 0) return value;                 statements.add(ifS(neX(varX(VALUE), constX(0)), returnS(varX(VALUE))));             }             // objects are equal             statements.add(returnS(constX(0)));         }          final BlockStatement body = new BlockStatement();         body.addStatements(statements);         return body;     }      private static Statement createCompareMethodBody(PropertyNode property, boolean reversed) {         String propName = property.getName();         return block(                 // if (arg0 == arg1) return 0;                 ifS(eqX(varX(ARG0), varX(ARG1)), returnS(constX(0))),                 // if (arg0 != null &amp;&amp; arg1 == null) return -1;                 ifS(andX(notNullX(varX(ARG0)), equalsNullX(varX(ARG1))), returnS(constX(-1))),                 // if (arg0 == null &amp;&amp; arg1 != null) return 1;                 ifS(andX(equalsNullX(varX(ARG0)), notNullX(varX(ARG1))), returnS(constX(1))),                 // return arg0.prop &lt;=&gt; arg1.prop;                 returnS(compareExpr(propX(varX(ARG0), propName), propX(varX(ARG1), propName), reversed))         );     }      private static void createComparatorFor(ClassNode classNode, PropertyNode property, boolean reversed) {         String propName = StringGroovyMethods.capitalize((CharSequence) property.getName());         String className = classNode.getName() + &quot;$&quot; + propName + &quot;Comparator&quot;;         ClassNode superClass = makeClassSafeWithGenerics(AbstractComparator.class, classNode);         InnerClassNode cmpClass = new InnerClassNode(classNode, className, ACC_PRIVATE | ACC_STATIC, superClass);         addGeneratedInnerClass(classNode, cmpClass);          addGeneratedMethod(cmpClass,                 &quot;compare&quot;,                 ACC_PUBLIC,                 ClassHelper.int_TYPE,                 params(param(newClass(classNode), ARG0), param(newClass(classNode), ARG1)),                 ClassNode.EMPTY_ARRAY,                 createCompareMethodBody(property, reversed)         );          String fieldName = &quot;this$&quot; + propName + &quot;Comparator&quot;;         // private final Comparator this$Comparator = new $Comparator();         FieldNode cmpField = classNode.addField(                 fieldName,                 ACC_STATIC | ACC_FINAL | ACC_PRIVATE | ACC_SYNTHETIC,                 COMPARATOR_TYPE,                 ctorX(cmpClass));          addGeneratedMethod(classNode,                 &quot;comparatorBy&quot; + propName,                 ACC_PUBLIC | ACC_STATIC,                 COMPARATOR_TYPE,                 Parameter.EMPTY_ARRAY,                 ClassNode.EMPTY_ARRAY,                 returnS(fieldX(cmpField))         );     }      private List findProperties(AnnotationNode annotation, final ClassNode classNode, final List includes,                                               final List excludes, final boolean allProperties,                                               final boolean includeSuperProperties, final boolean allNames) {         Set names = new HashSet();         List props = getAllProperties(names, classNode, classNode, true, false, allProperties,                 false, includeSuperProperties, false, false, allNames, false);         List properties = new ArrayList();         for (PropertyNode property : props) {             String propertyName = property.getName();             if ((excludes != null &amp;&amp; excludes.contains(propertyName)) ||                     includes != null &amp;&amp; !includes.contains(propertyName)) continue;             properties.add(property);         }         for (PropertyNode pNode : properties) {             checkComparable(pNode);         }         if (includes != null) {             Comparator includeComparator = new Comparator() {                 public int compare(PropertyNode o1, PropertyNode o2) {                     return Integer.compare(includes.indexOf(o1.getName()), includes.indexOf(o2.getName()));                 }             };             Collections.sort(properties, includeComparator);         }         return properties;     }      private void checkComparable(PropertyNode pNode) {         if (pNode.getType().implementsInterface(COMPARABLE_TYPE) || isPrimitiveType(pNode.getType()) || hasAnnotation(pNode.getType(), MY_TYPE)) {             return;         }         addError(&quot;Error during &quot; + MY_TYPE_NAME + &quot; processing: property '&quot; +                 pNode.getName() + &quot;' must be Comparable&quot;, pNode);     }      /**      * Helper method used to build a binary expression that compares two values      * with the option to handle reverse order.      */     private static BinaryExpression compareExpr(Expression lhv, Expression rhv, boolean reversed) {         return (reversed) ? cmpX(rhv, lhv) : cmpX(lhv, rhv);     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7725</td>
    <td align="left">https://github.com/apache/groovy/blob/00ee0547c00673a93e0843a9d72c8e4293d1efdb/src/main/java/org/codehaus/groovy/transform/SortableASTTransformation.java/#L82-L265</td>
    <td align="right">1</td>
    <td align="right">827</td>
    <td align="right">7725</td>
  </tr>
  <tr valign="top">
    <td align="right">2187</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement( name = &quot;artifactTransferRequest&quot; ) public class ArtifactTransferRequest     extends Artifact     implements Serializable {     private String targetRepositoryId;      public String getTargetRepositoryId()     {         return targetRepositoryId;     }      public void setTargetRepositoryId( String targetRepositoryId )     {         this.targetRepositoryId = targetRepositoryId;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13438</td>
    <td align="left">https://github.com/apache/archiva/blob/d1242030bf232c0d9b68e4402188ee261924bf4b/archiva-modules/archiva-web/archiva-rest/archiva-rest-api/src/main/java/org/apache/archiva/rest/api/model/ArtifactTransferRequest.java/#L29-L45</td>
    <td align="right">1</td>
    <td align="right">2187</td>
    <td align="right">13438</td>
  </tr>
  <tr valign="top">
    <td align="right">1139</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement(name = &quot;roles&quot;, namespace = &quot;http://org.apache.cxf.fediz/&quot;) public class Roles {      private Collection roles;      public Roles() {     }      public Roles(Collection roles) {         this.roles = roles;     }      @XmlElementRef     public Collection getRoles() {         return roles;     }      public void setRoles(Collection roles) {         this.roles = roles;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10076</td>
    <td align="left">https://github.com/apache/cxf-fediz/blob/553ae6e3adeb92b7d6300e5c0ad83ed6322e28bd/services/idp-core/src/main/java/org/apache/cxf/fediz/service/idp/rest/Roles.java/#L29-L49</td>
    <td align="right">1</td>
    <td align="right">1139</td>
    <td align="right">10076</td>
  </tr>
  <tr valign="top">
    <td align="right">439</td>
    <td align="left">&nbsp;	{ 		&quot;message&quot;: &quot;YES I found bad smells&quot;, 		&quot;detected_bad_smells&quot;: [ 			&quot;1. Data Class&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SCOMMetricHelper {   private static final String SQLSERVER_PROPERTIES_FILE = &quot;sqlserver_properties.json&quot;;   private static final String JMX_PROPERTIES_FILE = &quot;jmx_properties.json&quot;;    private static final Map&gt;&gt; JMX_PROPERTY_IDS = readPropertyProviderIds(JMX_PROPERTIES_FILE);   private static final Map&gt;&gt; SQLSERVER_PROPERTY_IDS = readPropertyProviderIds(SQLSERVER_PROPERTIES_FILE);    public static Map&gt; getSqlServerPropertyIds(Resource.Type resourceType) {     return SQLSERVER_PROPERTY_IDS.get(resourceType.getInternalType());   }    public static Map&gt; getJMXPropertyIds(Resource.Type resourceType) {     return JMX_PROPERTY_IDS.get(resourceType.getInternalType());   }    protected static class Metric {     private String metric;     private boolean pointInTime;     private boolean temporal;      private Metric() {     }      protected Metric(String metric, boolean pointInTime, boolean temporal) {       this.metric = metric;       this.pointInTime = pointInTime;       this.temporal = temporal;     }      public String getMetric() {       return metric;     }      public void setMetric(String metric) {       this.metric = metric;     }      public boolean isPointInTime() {       return pointInTime;     }      public void setPointInTime(boolean pointInTime) {       this.pointInTime = pointInTime;     }      public boolean isTemporal() {       return temporal;     }      public void setTemporal(boolean temporal) {       this.temporal = temporal;     }   }    private static Map&gt;&gt; readPropertyProviderIds(String filename) {     ObjectMapper mapper = new ObjectMapper();      try {       Map&gt;&gt; resourceMetricMap =               mapper.readValue(ClassLoader.getSystemResourceAsStream(filename),                       new TypeReference&gt;&gt;&gt;() {});        Map&gt;&gt; resourceMetrics =               new HashMap&gt;&gt;();        for (Map.Entry&gt;&gt; resourceEntry : resourceMetricMap.entrySet()) {         Map&gt; componentMetrics = new HashMap&gt;();          for (Map.Entry&gt; componentEntry : resourceEntry.getValue().entrySet()) {           Map metrics = new HashMap();            for (Map.Entry metricEntry : componentEntry.getValue().entrySet()) {             String property = metricEntry.getKey();             Metric metric = metricEntry.getValue();              metrics.put(property, new PropertyInfo(metric.getMetric(), metric.isTemporal(), metric.isPointInTime()));           }           componentMetrics.put(componentEntry.getKey(), metrics);         }         resourceMetrics.put(resourceEntry.getKey(), componentMetrics);       }       return resourceMetrics;     }     catch (IOException e) {       throw new IllegalStateException(&quot;Can't read properties file &quot; + filename, e);     }   } }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">&nbsp; </td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">4294</td>
    <td align="left">https://github.com/apache/ambari/blob/2bc4779a1e6aabe638101fc8b0e28cd1963d6b13/contrib/ambari-scom/ambari-scom-server/src/main/java/org/apache/ambari/scom/utilities/SCOMMetricHelper.java/#L32-L119</td>
    <td align="right">1</td>
    <td align="right">439</td>
    <td align="right">4294</td>
  </tr>
  <tr valign="top">
    <td align="right">410</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DIRuntimeException extends RuntimeException {     	private static final long serialVersionUID = 396131653561690312L;  	/**      * Creates new ConfigurationException without detail message.      */     public DIRuntimeException() {     }      /**      * Constructs an exception with the specified message with an optional list      * of message formatting arguments. Message formatting rules follow      * &quot;String.format(..)&quot; conventions.      */     public DIRuntimeException(String messageFormat, Object... messageArgs) {         super(String.format(messageFormat, messageArgs));     }      /**      * Constructs an exception wrapping another exception thrown elsewhere.      */     public DIRuntimeException(Throwable cause) {         super(cause);     }      public DIRuntimeException(String messageFormat, Throwable cause, Object... messageArgs) {         super(String.format(messageFormat, messageArgs), cause);     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4172</td>
    <td align="left">https://github.com/apache/cayenne/blob/5be5235ed1c02589b6300e9729cf3c308c0173e8/cayenne-di/src/main/java/org/apache/cayenne/di/DIRuntimeException.java/#L26-L55</td>
    <td align="right">1</td>
    <td align="right">410</td>
    <td align="right">4172</td>
  </tr>
  <tr valign="top">
    <td align="right">4197</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class ResolutionOptions {     public static class EncodingStrategy extends TypesafeEnum {         private EncodingStrategy(final int value) {             super(value);         }          /**          * When this strategy is chosen, the file's existing encoding is used.          */         public final static EncodingStrategy DEFAULT = new EncodingStrategy(0);         /**          * When this strategy is chosen, the all files involved in the merge          * will have their encodings treated like the given encoding. No file          * conversion is done.          */         public final static EncodingStrategy OVERRIDE_EXPLICIT = new EncodingStrategy(1);         /**          * When this strategy is chosen, the all files involved in the merge          * will be converted into the explicitly named encoding.          */         public final static EncodingStrategy CONVERT_EXPLICIT = new EncodingStrategy(2);     }      /**      * How to go about resolving encoding conflicts.      */     private EncodingStrategy encodingStrategy = EncodingStrategy.DEFAULT;      /**      * Only used when _encodingStrategy is not default.      */     private FileEncoding explicitEncoding = FileEncoding.AUTOMATICALLY_DETECT;      private boolean useInternalEngine = true;      private FileEncoding acceptMergeEncoding = null;      private String newPath = null;      private boolean acceptMergeWithConflicts = false;      private PropertyValue[] acceptMergeProperties;      /**      * Creates a {@link ResolutionOptions} with the default options set.      */     public ResolutionOptions() {         super();     }      /**      * Sets the strategy for resolving encoding conflicts. If the strategy is      * EncodingStrategy.DEFAULT, explicitEncoding must be null. If the strategy      * is some other value, explicitEncoding must be non-null, and represents      * the overriding encoding, or conversion encoding, or whatever that      * strategy's comment says it represents.      *      * @param strategy      *        the strategy to take for resolving encoding conflicts.      * @param explicitEncoding      *        the encoding to use for resolving conflicts (null if the strategy      *        is EncodingStrategy.DEFAULT).      */     public void setEncodingStrategy(final EncodingStrategy strategy, final FileEncoding explicitEncoding) {         Check.isTrue(             (strategy == EncodingStrategy.DEFAULT &amp;&amp; explicitEncoding == null || explicitEncoding != null),             &quot;explicitEncoding must be null if strategy is EncodingStrategy.DEFAULT&quot;); //$NON-NLS-1$          encodingStrategy = strategy;         this.explicitEncoding = explicitEncoding;     }      /**      * Gets the encoding resolution strategy. If the returned strategy is not      * EncodingStrategy.DEFAULT, call getExplicitEncoding() to get the encoding      * to be used for the strategy.      *      * @return the encoding resolution strategy.      */     public EncodingStrategy getEncodingStrategy() {         return encodingStrategy;     }      /**      * Gets the explicit encoding set previously as part of setting an encoding      * strategy.      *      * @return the encoding to use as part of the encoding resolution strategy,      *         null if not set or if the strategy was EncodingStrategy.DEFAULT.      */     public FileEncoding getExplicitEncoding() {         return explicitEncoding;     }      public void setUseInternalEngine(final boolean useInternalEngine) {         this.useInternalEngine = useInternalEngine;     }      public boolean useInternalEngine() {         return useInternalEngine;     }      /**      * When a conflict is to be resolved with the AcceptMerge resolution and      * there is a conflicting pending encoding change, the given encoding will      * be used (no file conversion is done). If the given encoding is null, the      * conflict will not be resolved.      *      * @param encoding      *        the encoding to use when an automatic merge is desired and there      *        is a conflicting pending change.      */     public void setAcceptMergeEncoding(final FileEncoding encoding) {         acceptMergeEncoding = encoding;     }      /**      * Gets the encoding to use when an AcceptMerge resolution is desired but      * there is a conflicting pending encoding change. If null is returned, the      * encoding should be unchanged.      *      * @return the encoding to use to resolve the case where AcceptMerge must      *         operate on a file with a conflicting pending encoding change,      *         null if the encoding should be unchanged.      */     public FileEncoding getAcceptMergeEncoding() {         return acceptMergeEncoding;     }      /**      * When a conflict is to be resolved with the AcceptMerge resolution and      * there is a conflicting pending property change, this property contains      * the desired properties. If this property is left as null, the conflict      * will not be resolved.      */     public PropertyValue[] getAcceptMergeProperties() {         return acceptMergeProperties;     }      public void setAcceptMergeProperties(final PropertyValue[] acceptMergeProperties) {         this.acceptMergeProperties = acceptMergeProperties;     }      /**      * Sets the new path for a conflicted item or the item in its way when it      * needs needs to move to a new location. This may happen in cases like      * these:      *      * Merge conflict with AcceptMerge chosen, and there's a conflicting pending      * rename: set the desired name. If null, the conflict will not be resolved.      *      * Namespace conflict with AcceptTheirs: set the path that would describe      * their item.      *      * Namespace conflict with AcceptYours: set to the path of the local item      * that was in the way of the server item.      *      * @param newPath      *        the path to use for this conflict resolution, null to defer the      *        resolution in the cases documented above.      */     public void setNewPath(final String newPath) {         this.newPath = newPath;     }      /**      * Gets the new path to use for this resolution. See setNewPath() comments      * for details.      *      * @return the new path, null if not set.      */     public String getNewPath() {         return newPath;     }      /**      * @return true if a merge should be resolved when conflicts remain in the      *         file, false if the merge should not be resolved when conflicts      *         remain      */     public boolean isAcceptMergeWithConflicts() {         return acceptMergeWithConflicts;     }      /**      * Sets the option to accept (resolve a conflict) when the merge resulted in      * conflicts.      *      * @param mergeWithConflicts      *        true if a merge should be resolved when conflicts remain in the      *        file, false if the merge should not be resolved when conflicts      *        remain      */     public void setAcceptMergeWithConflicts(final boolean mergeWithConflicts) {         acceptMergeWithConflicts = mergeWithConflicts;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11045</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core/src/com/microsoft/tfs/core/clients/versioncontrol/ResolutionOptions.java/#L17-L213</td>
    <td align="right">1</td>
    <td align="right">4197</td>
    <td align="right">11045</td>
  </tr>
  <tr valign="top">
    <td align="right">2317</td>
    <td align="left">&nbsp;&nbsp;YES I found bad smells The bad smells are:  1. Long method 2. Feature envy 3. Temporary field 4. Shotgun surgery 5. Primitive obsession 6. Message chain 7. Inappropriate intimacy 8. Data clumps 9. Data class 10. Inconsistent naming convention 11. Deeply nested code 12. Feature envy between Map and PartitionCollapsingSchemas classes.</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class PartitionCollapsingSchemas implements Serializable {     private static String DATED_INTERMEDIATE_VALUE_SCHEMA_NAME = &quot;DatedMapValue&quot;;   private static String KEY_SCHEMA = &quot;key.schema&quot;;   private static String INTERMEDIATE_VALUE_SCHEMA = &quot;intermediate.value.schema&quot;;   private static String OUTPUT_VALUE_SCHEMA = &quot;output.value.schema&quot;;      private final String _outputSchemaName;   private final String _outputSchemaNamespace;   private transient Schema _keySchema;   private transient Schema _intermediateValueSchema;   private transient Schema _outputValueSchema;      // generated schemas   private transient Schema _mapOutputSchema;   private transient Schema _dateIntermediateValueSchema;   private transient Schema _mapOutputValueSchema;   private transient Schema _reduceOutputSchema;   private transient Map _mapInputSchemas;      //schemas are stored here so the object can be serialized   private Map conf;    private Map _inputSchemas;      public PartitionCollapsingSchemas(TaskSchemas schemas, Map inputSchemas, String outputSchemaName, String outputSchemaNamespace)   {     if (schemas == null)     {       throw new NullArgumentException(&quot;schemas&quot;);     }     if (inputSchemas == null)     {       throw new NullArgumentException(&quot;inputSchema&quot;);     }     if (outputSchemaName == null)     {       throw new NullArgumentException(&quot;outputSchemaName&quot;);     }     if (outputSchemaName == outputSchemaNamespace)     {       throw new NullArgumentException(&quot;outputSchemaNamespace&quot;);     }     _outputSchemaName = outputSchemaName;     _outputSchemaNamespace = outputSchemaNamespace;          conf = new HashMap();     conf.put(KEY_SCHEMA, schemas.getKeySchema().toString());     conf.put(INTERMEDIATE_VALUE_SCHEMA, schemas.getIntermediateValueSchema().toString());     conf.put(OUTPUT_VALUE_SCHEMA, schemas.getOutputValueSchema().toString());          _inputSchemas = new HashMap();     for (Entry schema : inputSchemas.entrySet())     {       _inputSchemas.put(schema.getKey(), schema.getValue().toString());     }   }        public Map getMapInputSchemas()   {         if (_mapInputSchemas == null)     {       _mapInputSchemas = new HashMap();              for (Entry schemaPair : _inputSchemas.entrySet())       {         Schema schema = new Schema.Parser().parse(schemaPair.getValue());                  List mapInputSchemas = new ArrayList();                  if (schema.getType() == Type.UNION)         {           mapInputSchemas.addAll(schema.getTypes());         }         else         {           mapInputSchemas.add(schema);         }                  // feedback from output (optional)         mapInputSchemas.add(getReduceOutputSchema());                  _mapInputSchemas.put(schemaPair.getKey(), Schema.createUnion(mapInputSchemas));       }                   }     return Collections.unmodifiableMap(_mapInputSchemas);   }        public Schema getMapOutputSchema()   {     if (_mapOutputSchema == null)     {       _mapOutputSchema = Pair.getPairSchema(getMapOutputKeySchema(),                                              getMapOutputValueSchema());     }     return _mapOutputSchema;   }      public Schema getKeySchema()   {     if (_keySchema == null)     {       _keySchema = new Schema.Parser().parse(conf.get(KEY_SCHEMA));     }     return _keySchema;   }          public Schema getMapOutputKeySchema()   {     return getKeySchema();   }        public Schema getReduceOutputSchema()   {     if (_reduceOutputSchema == null)     {       _reduceOutputSchema = Schema.createRecord(_outputSchemaName, null, _outputSchemaNamespace, false);                   List fields = Arrays.asList(new Field(&quot;key&quot;,getKeySchema(), null, null),                                          new Field(&quot;value&quot;, getOutputValueSchema(), null, null));           _reduceOutputSchema.setFields(fields);     }     return _reduceOutputSchema;   }        public Schema getDatedIntermediateValueSchema()   {     if (_dateIntermediateValueSchema == null)     {       _dateIntermediateValueSchema = Schema.createRecord(DATED_INTERMEDIATE_VALUE_SCHEMA_NAME, null, _outputSchemaNamespace, false);       List intermediateValueFields = Arrays.asList(new Field(&quot;value&quot;, getIntermediateValueSchema(), null, null),                                                          new Field(&quot;time&quot;, Schema.create(Type.LONG), null, null));       _dateIntermediateValueSchema.setFields(intermediateValueFields);     }     return _dateIntermediateValueSchema;   }      public Schema getOutputValueSchema()   {     if (_outputValueSchema == null)     {       _outputValueSchema = new Schema.Parser().parse(conf.get(OUTPUT_VALUE_SCHEMA));     }     return _outputValueSchema;   }      public Schema getIntermediateValueSchema()   {     if (_intermediateValueSchema == null)     {       _intermediateValueSchema = new Schema.Parser().parse(conf.get(INTERMEDIATE_VALUE_SCHEMA));     }     return _intermediateValueSchema;   }        public Schema getMapOutputValueSchema()   {         if (_mapOutputValueSchema == null)     {       List unionSchemas = new ArrayList();              unionSchemas.add(getIntermediateValueSchema());              // intermediate values tagged with the date       unionSchemas.add(getDatedIntermediateValueSchema());              // feedback from output of second pass       if (!unionSchemas.contains(getOutputValueSchema()))       {         unionSchemas.add(getOutputValueSchema());       }              _mapOutputValueSchema = Schema.createUnion(unionSchemas);     }     return _mapOutputValueSchema;   } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method2 Feature envy3 Temporary field4 Shotgun surgery5 Primitive obsession6 Message chain7 Inappropriate intimacy8 Data clumps9 Data class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14122</td>
    <td align="left">https://github.com/apache/datafu/blob/3e52d11f75956ac3e6d2384816affeba565ab61d/datafu-hourglass/src/main/java/datafu/hourglass/schemas/PartitionCollapsingSchemas.java/#L41-L218</td>
    <td align="right">2</td>
    <td align="right">2317</td>
    <td align="right">14122</td>
  </tr>
  <tr valign="top">
    <td align="right">280</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class NetworkBridgeStatistics extends StatsImpl {      protected CountStatisticImpl enqueues;     protected CountStatisticImpl dequeues;     protected CountStatisticImpl receivedCount;      public NetworkBridgeStatistics() {         enqueues = new CountStatisticImpl(&quot;enqueues&quot;, &quot;The current number of enqueues this bridge has, which is the number of potential messages to be forwarded.&quot;);         dequeues = new CountStatisticImpl(&quot;dequeues&quot;, &quot;The current number of dequeues this bridge has, which is the number of messages received by the remote broker.&quot;);         receivedCount = new CountStatisticImpl(&quot;receivedCount&quot;, &quot;The number of messages that have been received by the NetworkBridge from the remote broker.  Only applies for Duplex bridges.&quot;);          addStatistic(&quot;enqueues&quot;, enqueues);         addStatistic(&quot;dequeues&quot;, dequeues);         addStatistic(&quot;receivedCount&quot;, receivedCount);     }      /**      * The current number of enqueues this bridge has, which is the number of potential messages to be forwarded      * Messages may not be forwarded if there is no subscription      *      * @return      */     public CountStatisticImpl getEnqueues() {         return enqueues;     }      /**      * The current number of dequeues this bridge has, which is the number of      * messages actually sent to and received by the remote broker.      *      * @return      */     public CountStatisticImpl getDequeues() {         return dequeues;     }      /**      * The number of messages that have been received by the NetworkBridge from the remote broker.      * Only applies for Duplex bridges.      *      * @return      */     public CountStatisticImpl getReceivedCount() {         return receivedCount;     }      @Override     public void reset() {         if (this.isDoReset()) {             super.reset();             enqueues.reset();             dequeues.reset();             receivedCount.reset();         }     }      @Override     public void setEnabled(boolean enabled) {         super.setEnabled(enabled);         enqueues.setEnabled(enabled);         dequeues.setEnabled(enabled);         receivedCount.setEnabled(enabled);     }      public void setParent(NetworkBridgeStatistics parent) {         if (parent != null) {             enqueues.setParent(parent.enqueues);             dequeues.setParent(parent.dequeues);             receivedCount.setParent(parent.receivedCount);         } else {             enqueues.setParent(null);             dequeues.setParent(null);             receivedCount.setParent(null);         }     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3003</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-broker/src/main/java/org/apache/activemq/network/NetworkBridgeStatistics.java/#L26-L102</td>
    <td align="right">1</td>
    <td align="right">280</td>
    <td align="right">3003</td>
  </tr>
  <tr valign="top">
    <td align="right">2438</td>
    <td align="left">{   &quot;response&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;Long Method&quot;,     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class MessageTransfer extends Method {      public static final int TYPE = 1025;     private int _bodySize;      @Override     public final int getStructType() {         return TYPE;     }      @Override     public final int getSizeWidth() {         return 0;     }      @Override     public final int getPackWidth() {         return 2;     }      @Override     public final boolean hasPayload() {         return true;     }      @Override     public final byte getEncodedTrack() {         return Frame.L4;     }      @Override     public final boolean isConnectionControl()     {         return false;     }      private short packing_flags = 0;     private String destination;     private MessageAcceptMode acceptMode;     private MessageAcquireMode acquireMode;     private Header header;     private QpidByteBuffer _body;       public MessageTransfer() {}      public MessageTransfer(String destination, MessageAcceptMode acceptMode, MessageAcquireMode acquireMode, Header header, java.nio.ByteBuffer body, Option ... options)     {         this(destination,              acceptMode,              acquireMode,              header,              QpidByteBuffer.wrap(body),              options);     }      public MessageTransfer(String destination, MessageAcceptMode acceptMode, MessageAcquireMode acquireMode, Header header, QpidByteBuffer body, Option ... _options) {         if(destination != null) {             setDestination(destination);         }         if(acceptMode != null) {             setAcceptMode(acceptMode);         }         if(acquireMode != null) {             setAcquireMode(acquireMode);         }         setHeader(header);         setBody(body);          for (int i=0; i &lt; _options.length; i++) {             switch (_options[i]) {             case SYNC: this.setSync(true); break;             case BATCH: this.setBatch(true); break;             case UNRELIABLE: this.setUnreliable(true); break;             case NONE: break;             default: throw new IllegalArgumentException(&quot;invalid option: &quot; + _options[i]);             }         }      }      @Override     public  void dispatch(C context, MethodDelegate delegate) {         delegate.messageTransfer(context, this);     }       public final boolean hasDestination() {         return (packing_flags &amp; 256) != 0;     }      public final MessageTransfer clearDestination() {         packing_flags &amp;= ~256;         this.destination = null;         setDirty(true);         return this;     }      public final String getDestination() {         return destination;     }      public final MessageTransfer setDestination(String value) {         this.destination = value;         packing_flags |= 256;         setDirty(true);         return this;     }      public final MessageTransfer destination(String value) {         return setDestination(value);     }      public final boolean hasAcceptMode() {         return (packing_flags &amp; 512) != 0;     }      public final MessageTransfer clearAcceptMode() {         packing_flags &amp;= ~512;         this.acceptMode = null;         setDirty(true);         return this;     }      public final MessageAcceptMode getAcceptMode() {         return acceptMode;     }      public final MessageTransfer setAcceptMode(MessageAcceptMode value) {         this.acceptMode = value;         packing_flags |= 512;         setDirty(true);         return this;     }      public final MessageTransfer acceptMode(MessageAcceptMode value) {         return setAcceptMode(value);     }      public final boolean hasAcquireMode() {         return (packing_flags &amp; 1024) != 0;     }      public final MessageTransfer clearAcquireMode() {         packing_flags &amp;= ~1024;         this.acquireMode = null;         setDirty(true);         return this;     }      public final MessageAcquireMode getAcquireMode() {         return acquireMode;     }      public final MessageTransfer setAcquireMode(MessageAcquireMode value) {         this.acquireMode = value;         packing_flags |= 1024;         setDirty(true);         return this;     }      public final MessageTransfer acquireMode(MessageAcquireMode value) {         return setAcquireMode(value);     }       @Override     public final Header getHeader() {         return this.header;     }      @Override     public final void setHeader(Header header) {         this.header = header;     }      public final MessageTransfer header(Header header)     {         setHeader(header);         return this;     }      @Override     public final QpidByteBuffer getBody()     {         return _body;     }      @Override     public final void setBody(QpidByteBuffer body)     {         if (body == null)         {             _bodySize = 0;             if (_body != null)             {                 _body.dispose();             }             _body = null;         }         else         {             _body = body.duplicate();             _bodySize = _body.remaining();         }     }      @Override     public int getBodySize()     {         return _bodySize;     }      @Override     public void write(Encoder enc)     {         enc.writeUint16(packing_flags);         if ((packing_flags &amp; 256) != 0)         {             enc.writeStr8(this.destination);         }         if ((packing_flags &amp; 512) != 0)         {             enc.writeUint8(this.acceptMode.getValue());         }         if ((packing_flags &amp; 1024) != 0)         {             enc.writeUint8(this.acquireMode.getValue());         }      }      @Override     public void read(Decoder dec)     {         packing_flags = (short) dec.readUint16();         if ((packing_flags &amp; 256) != 0)         {             this.destination = dec.readStr8();         }         if ((packing_flags &amp; 512) != 0)         {             this.acceptMode = MessageAcceptMode.get(dec.readUint8());         }         if ((packing_flags &amp; 1024) != 0)         {             this.acquireMode = MessageAcquireMode.get(dec.readUint8());         }      }      @Override     public Map getFields()     {         Map result = new LinkedHashMap();          if ((packing_flags &amp; 256) != 0)         {             result.put(&quot;destination&quot;, getDestination());         }         if ((packing_flags &amp; 512) != 0)         {             result.put(&quot;acceptMode&quot;, getAcceptMode());         }         if ((packing_flags &amp; 1024) != 0)         {             result.put(&quot;acquireMode&quot;, getAcquireMode());         }           return result;     }      public void dispose()     {         if (_body != null)         {             _body.dispose();             _body = null;         }     } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14474</td>
    <td align="left">https://github.com/apache/qpid-broker-j/blob/4c4400b98a5a8493cfb9e5dbb21c97175f433a62/broker-plugins/amqp-0-10-protocol/src/main/java/org/apache/qpid/server/protocol/v0_10/transport/MessageTransfer.java/#L31-L312</td>
    <td align="right">1</td>
    <td align="right">2438</td>
    <td align="right">14474</td>
  </tr>
  <tr valign="top">
    <td align="right">16</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;answer&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: &quot;Data Class&quot;   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ErrorDataException extends Exception {      /** serialVersionUID. */     private static final long serialVersionUID = -9052741930614009382L;          /** The rpc data package. */     private RpcDataPackage rpcDataPackage;          /** The error code. */     private int errorCode;          /**      * Gets the error code.      *      * @return the error code      */     public int getErrorCode() {         return errorCode;     }      /**      * Sets the error code.      *      * @param errorCode the new error code      */     public void setErrorCode(int errorCode) {         this.errorCode = errorCode;     }      /**      * Gets the rpc data package.      *      * @return the rpc data package      */     public RpcDataPackage getRpcDataPackage() {         return rpcDataPackage;     }      /**      * Sets the rpc data package.      *      * @param rpcDataPackage the new rpc data package      */     public void setRpcDataPackage(RpcDataPackage rpcDataPackage) {         this.rpcDataPackage = rpcDataPackage;     }      /**      * Instantiates a new error data exception.      */     public ErrorDataException() {         super();     }      /**      * Instantiates a new error data exception.      *      * @param message the message      * @param cause the cause      */     public ErrorDataException(String message, Throwable cause) {         super(message, cause);     }          /**      * Instantiates a new error data exception.      *      * @param message the message      * @param cause the cause      * @param errorCode the error code      */     public ErrorDataException(String message, Throwable cause, int errorCode) {         super(message, cause);         this.errorCode = errorCode;     }      /**      * Instantiates a new error data exception.      *      * @param message the message      */     public ErrorDataException(String message) {         super(message);     }      /**      * Instantiates a new error data exception.      *      * @param message the message      * @param errorCode the error code      */     public ErrorDataException(String message, int errorCode) {         super(message);         this.errorCode = errorCode;     }          /**      * Instantiates a new error data exception.      *      * @param cause the cause      */     public ErrorDataException(Throwable cause) {         super(cause);     }          /**      * Instantiates a new error data exception.      *      * @param cause the cause      * @param errorCode the error code      */     public ErrorDataException(Throwable cause, int errorCode) {         super(cause);         this.errorCode = errorCode;     }       }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">642</td>
    <td align="left">https://github.com/baidu/Jprotobuf-rpc-socket/blob/4422e24c725eaf1f76646f674718bcc8750a4e1d/jprotobuf-rpc-core/src/main/java/com/baidu/jprotobuf/pbrpc/ErrorDataException.java/#L28-L145</td>
    <td align="right">1</td>
    <td align="right">16</td>
    <td align="right">642</td>
  </tr>
  <tr valign="top">
    <td align="right">298</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Deprecated public class TransactionRecord {     // Commit Log Offset     private long offset;     private String producerGroup;      public long getOffset() {         return offset;     }      public void setOffset(long offset) {         this.offset = offset;     }      public String getProducerGroup() {         return producerGroup;     }      public void setProducerGroup(String producerGroup) {         this.producerGroup = producerGroup;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3132</td>
    <td align="left">https://github.com/apache/rocketmq/blob/971fa8ed8b209b39bdfe41c57cd64576d244e6bd/broker/src/main/java/org/apache/rocketmq/broker/transaction/TransactionRecord.java/#L22-L43</td>
    <td align="right">1</td>
    <td align="right">298</td>
    <td align="right">3132</td>
  </tr>
  <tr valign="top">
    <td align="right">2493</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SuppressWarnings(&quot;serial&quot;) public abstract class StaticMethodMatcherPointcutAdvisor extends StaticMethodMatcherPointcut 		implements PointcutAdvisor, Ordered, Serializable {  	private Advice advice = EMPTY_ADVICE;  	private int order = Ordered.LOWEST_PRECEDENCE;   	/** 	 * Create a new StaticMethodMatcherPointcutAdvisor, 	 * expecting bean-style configuration. 	 * @see #setAdvice 	 */ 	public StaticMethodMatcherPointcutAdvisor() { 	}  	/** 	 * Create a new StaticMethodMatcherPointcutAdvisor for the given advice. 	 * @param advice the Advice to use 	 */ 	public StaticMethodMatcherPointcutAdvisor(Advice advice) { 		Assert.notNull(advice, &quot;Advice must not be null&quot;); 		this.advice = advice; 	}   	public void setOrder(int order) { 		this.order = order; 	}  	@Override 	public int getOrder() { 		return this.order; 	}  	public void setAdvice(Advice advice) { 		this.advice = advice; 	}  	@Override 	public Advice getAdvice() { 		return this.advice; 	}  	@Override 	public boolean isPerInstance() { 		return true; 	}  	@Override 	public Pointcut getPointcut() { 		return this; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14624</td>
    <td align="left">https://github.com/spring-projects/spring-framework/blob/3a0f309e2c9fdbbf7fb2d348be861528177f8555/spring-aop/src/main/java/org/springframework/aop/support/StaticMethodMatcherPointcutAdvisor.java/#L35-L90</td>
    <td align="right">1</td>
    <td align="right">2493</td>
    <td align="right">14624</td>
  </tr>
  <tr valign="top">
    <td align="right">1564</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad_smells&quot;: [             &quot;Data Class&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class IgfsHandshakeResponse implements Externalizable {     /** */     private static final long serialVersionUID = 0L;      /** IGFS name. */     private String igfsName;      /** Server block size. */     private long blockSize;      /** Whether to force sampling on client's side. */     private Boolean sampling;      /**      * {@link Externalizable} support.      */     public IgfsHandshakeResponse() {         // No-op.     }      /**      * Constructor.      *      * @param blockSize Server default block size.      */     public IgfsHandshakeResponse(String igfsName, long blockSize, Boolean sampling) {         this.igfsName = igfsName;         this.blockSize = blockSize;         this.sampling = sampling;     }      /**      * @return IGFS name.      */     public String igfsName() {         return igfsName;     }      /**      * @return Server default block size.      */     public long blockSize() {         return blockSize;     }      /**      * @return Sampling flag.      */     public Boolean sampling() {         return sampling;     }      /** {@inheritDoc} */     @Override public void writeExternal(ObjectOutput out) throws IOException {         U.writeString(out, igfsName);          out.writeLong(blockSize);          if (sampling != null) {             out.writeBoolean(true);             out.writeBoolean(sampling);         }         else             out.writeBoolean(false);     }      /** {@inheritDoc} */     @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {         igfsName = U.readString(in);          blockSize = in.readLong();          if (in.readBoolean())             sampling = in.readBoolean();     } }</td>
    <td align="left">data class</td>
    <td align="left">Data Class, Long Method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11320</td>
    <td align="left">https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/core/src/main/java/org/apache/ignite/internal/processors/igfs/IgfsHandshakeResponse.java/#L29-L104</td>
    <td align="right">1</td>
    <td align="right">1564</td>
    <td align="right">11320</td>
  </tr>
  <tr valign="top">
    <td align="right">2965</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class OptionSet implements UaStructure {      public static final NodeId TypeId = Identifiers.OptionSet;     public static final NodeId BinaryEncodingId = Identifiers.OptionSet_Encoding_DefaultBinary;     public static final NodeId XmlEncodingId = Identifiers.OptionSet_Encoding_DefaultXml;      protected final ByteString value;     protected final ByteString validBits;      public OptionSet() {         this.value = null;         this.validBits = null;     }      public OptionSet(ByteString value, ByteString validBits) {         this.value = value;         this.validBits = validBits;     }      public ByteString getValue() { return value; }      public ByteString getValidBits() { return validBits; }      @Override     public NodeId getTypeId() { return TypeId; }      @Override     public NodeId getBinaryEncodingId() { return BinaryEncodingId; }      @Override     public NodeId getXmlEncodingId() { return XmlEncodingId; }      @Override     public String toString() {         return MoreObjects.toStringHelper(this)             .add(&quot;Value&quot;, value)             .add(&quot;ValidBits&quot;, validBits)             .toString();     }      public static class Codec extends BuiltinDataTypeCodec {          @Override         public Class getType() {             return OptionSet.class;         }          @Override         public OptionSet decode(UaDecoder decoder) throws UaSerializationException {             ByteString value = decoder.readByteString(&quot;Value&quot;);             ByteString validBits = decoder.readByteString(&quot;ValidBits&quot;);              return new OptionSet(value, validBits);         }          @Override         public void encode(OptionSet value, UaEncoder encoder) throws UaSerializationException {             encoder.writeByteString(&quot;Value&quot;, value.value);             encoder.writeByteString(&quot;ValidBits&quot;, value.validBits);         }     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2728</td>
    <td align="left">https://github.com/eclipse/milo/blob/e752e540d31eb3c226e6e79dd197c54d7d254685/opc-ua-stack/stack-core/src/main/java/org/eclipse/milo/opcua/stack/core/types/structured/OptionSet.java/#L23-L85</td>
    <td align="right">1</td>
    <td align="right">2965</td>
    <td align="right">2728</td>
  </tr>
  <tr valign="top">
    <td align="right">122</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are:&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	@Data 	static class VaultInitializationResponseImpl implements VaultInitializationResponse {  		private List keys = new ArrayList&lt;&gt;();  		@JsonProperty(&quot;root_token&quot;) 		private String rootToken = &quot;&quot;;  		public VaultToken getRootToken() { 			return VaultToken.of(rootToken); 		} 	}</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1535</td>
    <td align="left">https://github.com/spring-projects/spring-vault/blob/6e36eb10b02c6931c3b565c5d9d76f5e217bf309/spring-vault-core/src/main/java/org/springframework/vault/core/VaultSysTemplate.java/#L414-L425</td>
    <td align="right">1</td>
    <td align="right">122</td>
    <td align="right">1535</td>
  </tr>
  <tr valign="top">
    <td align="right">24</td>
    <td align="left">&nbsp;{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: &quot;3. Blob, 4. Data Class&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Ipam {   private String driver;   private List config;   private Map options;    public String getDriver() {     return driver;   }    public void setDriver(String driver) {     this.driver = driver;   }    public Ipam withDriver(String driver) {     this.driver = driver;     return this;   }    public List getConfig() {     return config;   }    public void setConfig(List config) {     this.config = config;   }    public Ipam withConfig(List config) {     this.config = config;     return this;   }    public Map getOptions() {     return options;   }    public void setOptions(Map options) {     this.options = options;   }    public Ipam withOptions(Map options) {     this.options = options;     return this;   }    @Override   public boolean equals(Object obj) {     if (this == obj) {       return true;     }     if (!(obj instanceof Ipam)) {       return false;     }     final Ipam that = (Ipam) obj;     return Objects.equals(driver, that.driver)         &amp;&amp; getConfig().equals(that.getConfig())         &amp;&amp; getOptions().equals(that.getOptions());   }    @Override   public int hashCode() {     int hash = 7;     hash = 31 * hash + Objects.hashCode(driver);     hash = 31 * hash + getConfig().hashCode();     hash = 31 * hash + getOptions().hashCode();     return hash;   }    @Override   public String toString() {     return &quot;Ipam{&quot;         + &quot;driver='&quot;         + driver         + '\''         + &quot;, config=&quot;         + config         + &quot;, options=&quot;         + options         + '}';   } }</td>
    <td align="left">data class</td>
    <td align="left">3. blob, 4. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">3. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">691</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/infrastructures/docker/docker-client/src/main/java/org/eclipse/che/infrastructure/docker/client/json/network/Ipam.java/#L19-L98</td>
    <td align="right">1</td>
    <td align="right">24</td>
    <td align="right">691</td>
  </tr>
  <tr valign="top">
    <td align="right">1711</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;response&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ObjectInFolderListImpl extends AbstractExtensionData implements ObjectInFolderList {      private static final long serialVersionUID = 1L;      private List objects;     private Boolean hasMoreItems = Boolean.FALSE;     private BigInteger numItems;      @Override     public List getObjects() {         if (objects == null) {             objects = new ArrayList(0);         }          return objects;     }      public void setObjects(List objects) {         this.objects = objects;     }      @Override     public Boolean hasMoreItems() {         return hasMoreItems;     }      public void setHasMoreItems(Boolean hasMoreItems) {         this.hasMoreItems = hasMoreItems;     }      @Override     public BigInteger getNumItems() {         return numItems;     }      public void setNumItems(BigInteger numItems) {         this.numItems = numItems;     }      @Override     public String toString() {         return &quot;ObjectInFolder List [objects=&quot; + objects + &quot;, has more items=&quot; + hasMoreItems + &quot;, num items=&quot;                 + numItems + &quot;]&quot; + super.toString();     } }</td>
    <td align="left">data class</td>
    <td align="left">Data Class, Long Method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11768</td>
    <td align="left">https://github.com/apache/chemistry-opencmis/blob/ef8513d708e5e21710afe5cafb8b32a62a0ae532/chemistry-opencmis-commons/chemistry-opencmis-commons-impl/src/main/java/org/apache/chemistry/opencmis/commons/impl/dataobjects/ObjectInFolderListImpl.java/#L31-L75</td>
    <td align="right">1</td>
    <td align="right">1711</td>
    <td align="right">11768</td>
  </tr>
  <tr valign="top">
    <td align="right">986</td>
    <td align="left">&nbsp;	{ 		&quot;message&quot;: &quot;YES I found bad smells&quot;, 		&quot;bad smells are&quot;: [ 			&quot;Data Class&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class _LocationWebServiceSoap_Connect     implements ElementSerializable {     // No attributes          // Elements     protected int connectOptions;     protected int lastChangeId;     protected int features;      public _LocationWebServiceSoap_Connect()     {         super();     }      public _LocationWebServiceSoap_Connect(         final int connectOptions,         final int lastChangeId,         final int features)     {         // TODO : Call super() instead of setting all fields directly?         setConnectOptions(connectOptions);         setLastChangeId(lastChangeId);         setFeatures(features);     }      public int getConnectOptions()     {         return this.connectOptions;     }      public void setConnectOptions(int value)     {         this.connectOptions = value;     }      public int getLastChangeId()     {         return this.lastChangeId;     }      public void setLastChangeId(int value)     {         this.lastChangeId = value;     }      public int getFeatures()     {         return this.features;     }      public void setFeatures(int value)     {         this.features = value;     }      public void writeAsElement(         final XMLStreamWriter writer,         final String name)         throws XMLStreamException     {         writer.writeStartElement(name);          // Elements         XMLStreamWriterHelper.writeElement(             writer,             &quot;connectOptions&quot;,             this.connectOptions);         XMLStreamWriterHelper.writeElement(             writer,             &quot;lastChangeId&quot;,             this.lastChangeId);         XMLStreamWriterHelper.writeElement(             writer,             &quot;features&quot;,             this.features);          writer.writeEndElement();     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8880</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core.ws/generated-src/ms/ws/_LocationWebServiceSoap_Connect.java/#L29-L108</td>
    <td align="right">1</td>
    <td align="right">986</td>
    <td align="right">8880</td>
  </tr>
  <tr valign="top">
    <td align="right">2612</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ErrorDataException extends Exception {      /** serialVersionUID. */     private static final long serialVersionUID = -9052741930614009382L;          /** The rpc data package. */     private RpcDataPackage rpcDataPackage;          /** The error code. */     private int errorCode;          /**      * Gets the error code.      *      * @return the error code      */     public int getErrorCode() {         return errorCode;     }      /**      * Sets the error code.      *      * @param errorCode the new error code      */     public void setErrorCode(int errorCode) {         this.errorCode = errorCode;     }      /**      * Gets the rpc data package.      *      * @return the rpc data package      */     public RpcDataPackage getRpcDataPackage() {         return rpcDataPackage;     }      /**      * Sets the rpc data package.      *      * @param rpcDataPackage the new rpc data package      */     public void setRpcDataPackage(RpcDataPackage rpcDataPackage) {         this.rpcDataPackage = rpcDataPackage;     }      /**      * Instantiates a new error data exception.      */     public ErrorDataException() {         super();     }      /**      * Instantiates a new error data exception.      *      * @param message the message      * @param cause the cause      */     public ErrorDataException(String message, Throwable cause) {         super(message, cause);     }          /**      * Instantiates a new error data exception.      *      * @param message the message      * @param cause the cause      * @param errorCode the error code      */     public ErrorDataException(String message, Throwable cause, int errorCode) {         super(message, cause);         this.errorCode = errorCode;     }      /**      * Instantiates a new error data exception.      *      * @param message the message      */     public ErrorDataException(String message) {         super(message);     }      /**      * Instantiates a new error data exception.      *      * @param message the message      * @param errorCode the error code      */     public ErrorDataException(String message, int errorCode) {         super(message);         this.errorCode = errorCode;     }          /**      * Instantiates a new error data exception.      *      * @param cause the cause      */     public ErrorDataException(Throwable cause) {         super(cause);     }          /**      * Instantiates a new error data exception.      *      * @param cause the cause      * @param errorCode the error code      */     public ErrorDataException(Throwable cause, int errorCode) {         super(cause);         this.errorCode = errorCode;     }       }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15042</td>
    <td align="left">https://github.com/baidu/Jprotobuf-rpc-socket/blob/4422e24c725eaf1f76646f674718bcc8750a4e1d/jprotobuf-rpc-core/src/main/java/com/baidu/jprotobuf/pbrpc/ErrorDataException.java/#L28-L145</td>
    <td align="right">1</td>
    <td align="right">2612</td>
    <td align="right">15042</td>
  </tr>
  <tr valign="top">
    <td align="right">2414</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Blob&quot;,         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Subchannel extends Pipe { 	/** 	 *  	 * Number of fuel rods contained within. 	 *  	 *  	 */ 	private int numRods;  	/** 	 *  	 * Diameter of the subchannel fuel rods (this assumes uniform rod sizes). 	 *  	 *  	 */ 	private double rodDiameter;  	/** 	 *  	 * Pitch of the fuel rod bundle (distance between adjacent rod centers). 	 *  	 *  	 */ 	private double pitch;  	/** 	 *  	 * Nullary constructor. 	 *  	 *  	 */ 	public Subchannel() {  		// Set the name, description and ID. 		setName(&quot;Subchannel 1&quot;); 		setDescription(&quot;A subchannel plant component for reactors&quot;); 		setId(1);  		// Set the default number of rods, rod diameter and pitch. 		setNumRods(1); 		setRodDiameter(1.0); 		setPitch(1.5); 		// Note: Pitch must always be set after diameter, as setPitch method 		// checks that pitch &gt;= rodDiameter.  		return; 	}  	/** 	 *  	 * Parameterized constructor. 	 *  	 *  	 * @param numRods 	 *             	 *            Number of rods contained. 	 *             	 * @param rodDiameter 	 *             	 *            Diameter of the (uniformly-sized) fuel rods. 	 *             	 * @param pitch 	 *             	 *            Pitch of the fuel rods. 	 *             	 */ 	public Subchannel(int numRods, double rodDiameter, double pitch) {  		// Set the name, description and ID. 		setName(&quot;Subchannel 1&quot;); 		setDescription(&quot;A subchannel plant component for reactors&quot;); 		setId(1);  		// Set the default number of rods, rod diameter and pitch. 		setNumRods(numRods); 		setRodDiameter(rodDiameter); 		setPitch(pitch);  		return; 	}  	/** 	 * @return the numRods 	 */ 	public int getNumRods() { 		return numRods; 	}  	/** 	 * @param numRods 	 *            the numRods to set 	 */ 	public void setNumRods(int numRods) {  		// Check the input is valid. 		if (numRods &gt;= 1) { 			this.numRods = numRods; 		} else { 			throw new InvalidParameterException(&quot;Subchannel error: The number &quot; 					+ &quot;of rods must greater than or equal to 1.&quot;); 		} 		return; 	}  	/** 	 * @return the rodDiameter 	 */ 	public double getRodDiameter() { 		return rodDiameter; 	}  	/** 	 * @param rodDiameter 	 *            the rodDiameter to set 	 */ 	public void setRodDiameter(double rodDiameter) {  		// Check the input is valid. 		if (rodDiameter &gt; 0) { 			this.rodDiameter = rodDiameter; 		} else { 			throw new InvalidParameterException(&quot;Subchannel error: The rod &quot; 					+ &quot;diameter must be non-negative.&quot;); 		} 		return; 	}  	/** 	 * @return the pitch 	 */ 	public double getPitch() { 		return pitch; 	}  	/** 	 * @param pitch 	 *            the pitch to set 	 */ 	public void setPitch(double pitch) {  		// Check that the input is valid. 		if (pitch &gt;= rodDiameter) { 			this.pitch = pitch; 		} else { 			throw new InvalidParameterException(&quot;Subchannel error: The rod &quot; 					+ &quot;pitch cannot be smaller than the rod diameter.&quot;); 		} 	}  	/** 	 *  	 * Performs an equality check between two Objects. 	 *  	 *  	 * @param otherObject 	 *             	 *            The other Object to compare against. 	 *             	 * @return  	 *         Returns true if the two objects are equal, otherwise false. 	 *          	 */ 	@Override 	public boolean equals(Object otherObject) {  		// By default, the objects are not equivalent. 		boolean equals = false;  		// Check the reference. 		if (this == otherObject) { 			equals = true; 		} 		// Check the information stored in the other object. 		else if (otherObject != null &amp;&amp; otherObject instanceof Subchannel) {  			// Cast the other object. 			Subchannel component = (Subchannel) otherObject;  			// Compare all the variables. (Save the biggest for last; Java 			// should 			// short-circuit the logical operators as soon as a mismatch is 			// found) 			equals = (super.equals(component) &amp;&amp; numRods == component.numRods 					&amp;&amp; rodDiameter == component.rodDiameter &amp;&amp; pitch == component.pitch); 		}  		return equals; 	}  	/** 	 *  	 * Performs a deep copy and returns a newly instantiated Object. 	 *  	 *  	 * @return  	 *         The newly instantiated Object. 	 *          	 */ 	@Override 	public Object clone() {  		// Initialize a new object. 		Subchannel object = new Subchannel();  		// Copy the contents from this one. 		object.copy(this);  		// Return the newly instantiated object. 		return object; 	}  	/** 	 *  	 * Deep copies the contents of otherObject. 	 *  	 *  	 * @param otherObject 	 *             	 *            The other object to copy the contents from. 	 *             	 */ 	public void copy(Subchannel otherObject) {  		// Check the otherObject is valid. 		if (otherObject == null) { 			return; 		} 		// Copy the other object. 		super.copy(otherObject); 		numRods = otherObject.numRods; 		rodDiameter = otherObject.rodDiameter; 		pitch = otherObject.pitch;  		return; 	}  	/** 	 *  	 * Returns the hashCode of the object. 	 *  	 *  	 * @return  	 *         The hashCode of the Object. 	 *          	 */ 	@Override 	public int hashCode() {  		// Call the super's hashCode. 		int hash = super.hashCode();  		// Add local hashes. 		hash = 31 * hash + numRods; 		hash = 31 * hash + new Double(rodDiameter).hashCode(); 		hash = 31 * hash + new Double(pitch).hashCode();  		return hash; 	}  	/** 	 *  	 * Accepts PlantComponentVisitors to reveal the type of a PlantComponent. 	 *  	 *  	 * @param visitor 	 *             	 *            The PlantComponent's visitor. 	 *             	 */ 	@Override 	public void accept(IPlantComponentVisitor visitor) {  		// Only accept valid visitors. 		if (visitor != null) { 			visitor.visit(this); 		} 		return; 	} }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14415</td>
    <td align="left">https://github.com/eclipse/ice/blob/3f6e0265f5b476ff90a660397ce83992944142c4/org.eclipse.ice.reactor.plant/src/org/eclipse/ice/reactor/plant/Subchannel.java/#L25-L303</td>
    <td align="right">1</td>
    <td align="right">2414</td>
    <td align="right">14415</td>
  </tr>
  <tr valign="top">
    <td align="right">1576</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;output&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MultiResponse200 {   private String message;    private int code;    private long t200;    public String getMessage() {     return message;   }    public void setMessage(String message) {     this.message = message;   }    public int getCode() {     return code;   }    public void setCode(int code) {     this.code = code;   }    public long getT200() {     return t200;   }    public void setT200(long t200) {     this.t200 = t200;   } }</td>
    <td align="left">data class</td>
    <td align="left">Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11350</td>
    <td align="left">https://github.com/apache/servicecomb-java-chassis/blob/72cd0e137c4a0c3b899adfa6e19e2fd590743014/demo/demo-schema/src/main/java/org/apache/servicecomb/demo/multiErrorCode/MultiResponse200.java/#L20-L50</td>
    <td align="right">1</td>
    <td align="right">1576</td>
    <td align="right">11350</td>
  </tr>
  <tr valign="top">
    <td align="right">2034</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;output&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
      @AutoValue       public abstract static class CreatePayload {           public abstract String name();           public abstract Location location();        }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12827</td>
    <td align="left">https://github.com/apache/jclouds/blob/c2670079fabe74f163f43fbade0866469f7a84ec/providers/profitbricks/src/main/java/org/jclouds/profitbricks/domain/DataCenter.java/#L103-L110</td>
    <td align="right">1</td>
    <td align="right">2034</td>
    <td align="right">12827</td>
  </tr>
  <tr valign="top">
    <td align="right">821</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells are&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LimitedSizeDataCollection implements SWCollection {      private final HashMap&gt; data;     private final int limitedSize;     private volatile boolean writing;     private volatile boolean reading;      LimitedSizeDataCollection(int limitedSize) {         this.data = new HashMap&lt;&gt;();         this.writing = false;         this.reading = false;         this.limitedSize = limitedSize;     }      public void finishWriting() {         writing = false;     }      @Override public void writing() {         writing = true;     }      @Override public boolean isWriting() {         return writing;     }      @Override public void finishReading() {         reading = false;     }      @Override public void reading() {         reading = true;     }      @Override public boolean isReading() {         return reading;     }      @Override public int size() {         return data.size();     }      @Override public void clear() {         data.clear();     }      @Override public boolean containsKey(STORAGE_DATA key) {         throw new UnsupportedOperationException(&quot;Limited size data collection doesn't support containsKey operation.&quot;);     }      @Override public STORAGE_DATA get(STORAGE_DATA key) {         throw new UnsupportedOperationException(&quot;Limited size data collection doesn't support get operation.&quot;);     }      @Override public void put(STORAGE_DATA value) {         LinkedList storageDataList = this.data.get(value);         if (storageDataList == null) {             storageDataList = new LinkedList&lt;&gt;();             data.put(value, storageDataList);         }          if (storageDataList.size() &lt; limitedSize) {             storageDataList.add(value);             return;         }          for (int i = 0; i &lt; storageDataList.size(); i++) {             STORAGE_DATA storageData = storageDataList.get(i);             if (value.compareTo(storageData) &lt;= 0) {                 if (i == 0) {                     // input value is less than the smallest in top N list, ignore                 } else {                     // Remove the smallest in top N list                     // add the current value into the right position                     storageDataList.add(i, value);                     storageDataList.removeFirst();                 }                 return;             }         }          // Add the value as biggest in top N list         storageDataList.addLast(value);         storageDataList.removeFirst();     }      @Override public Collection collection() {         List collection = new ArrayList&lt;&gt;();         data.values().forEach(e -&gt; e.forEach(collection::add));         return collection;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7686</td>
    <td align="left">https://github.com/apache/incubator-skywalking/blob/32c4bced8a7e055003d6e4bea0fd8f8361bec8e5/oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/data/LimitedSizeDataCollection.java/#L24-L115</td>
    <td align="right">1</td>
    <td align="right">821</td>
    <td align="right">7686</td>
  </tr>
  <tr valign="top">
    <td align="right">2212</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class FilterParams {      private final Collection filterByStatus;     private final Boolean overdueState;     private final String filterBySearchText;     private final Boolean selectTargetWithNoTag;     private final String[] filterByTagNames;     private final Long filterByDistributionId;      /**      * Constructor.      *      * @param filterByInstalledOrAssignedDistributionSetId      *            if set, a filter is added for the given      *            {@link DistributionSet#getId()}      * @param filterByStatus      *            if set, a filter is added for target states included by the      *            collection      * @param overdueState      *            if set, a filter is added for overdued devices      * @param filterBySearchText      *            if set, a filter is added for the given search text      * @param selectTargetWithNoTag      *            if set, tag-filtering is enabled      * @param filterByTagNames      *            if tag-filtering is enabled, a filter is added for the given      *            tag-names      */     public FilterParams(final Collection filterByStatus, final Boolean overdueState,             final String filterBySearchText, final Long filterByInstalledOrAssignedDistributionSetId,             final Boolean selectTargetWithNoTag, final String... filterByTagNames) {         this.filterByStatus = filterByStatus;         this.overdueState = overdueState;         this.filterBySearchText = filterBySearchText;         this.filterByDistributionId = filterByInstalledOrAssignedDistributionSetId;         this.selectTargetWithNoTag = selectTargetWithNoTag;         this.filterByTagNames = filterByTagNames;     }      /**      * Gets {@link DistributionSet#getId()} to filter the result.       * If set to null this filter is disabled.      *      * @return {@link DistributionSet#getId()} to filter the result      */     public Long getFilterByDistributionId() {         return filterByDistributionId;     }      /**      * Gets a collection of target states to filter for.       * If set to null this filter is disabled.      *      * @return collection of target states to filter for      */     public Collection getFilterByStatus() {         return filterByStatus;     }      /**      * Gets the flag for overdue filter; if set to true, the      * overdue filter is activated. Overdued targets a targets that did not      * respond during the configured intervals: poll_itvl + overdue_itvl.       * If set to null this filter is disabled.      *      * @return flag for overdue filter activation      */     public Boolean getOverdueState() {         return overdueState;     }      /**      * Gets the search text to filter for. This is used to find targets having      * the text anywhere in name or description       * If set to null this filter is disabled.      *      * @return the search text to filter for      */     public String getFilterBySearchText() {         return filterBySearchText;     }      /**      * Gets the flag indicating if tagging filter is used.       * If set to null this filter is disabled.      *      * @return the flag indicating if tagging filter is used      */     public Boolean getSelectTargetWithNoTag() {         return selectTargetWithNoTag;     }      /**      * Gets the tags that are used to filter for. The activation of this filter      * is done by {@link #setSelectTargetWithNoTag(Boolean)}.      *      * @return the tags that are used to filter for      */     public String[] getFilterByTagNames() {         return filterByTagNames;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13524</td>
    <td align="left">https://github.com/eclipse/hawkbit/blob/51be28147f6f575b6c1ab4a5ef84ffd9174f1209/hawkbit-repository/hawkbit-repository-api/src/main/java/org/eclipse/hawkbit/repository/FilterParams.java/#L22-L123</td>
    <td align="right">1</td>
    <td align="right">2212</td>
    <td align="right">13524</td>
  </tr>
  <tr valign="top">
    <td align="right">1354</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class NewItemFinishEvent extends NewItemEvent {          private static final String EVENT_DESCRIPTION = &quot;finish&quot;;          private Serializable result;          public NewItemFinishEvent(final T item, final AjaxRequestTarget target) {             super(item, target);         }          @Override         public String getEventDescription() {             return NewItemFinishEvent.EVENT_DESCRIPTION;         }          public NewItemFinishEvent setResult(final Serializable result) {             this.result = result;             return this;         }          public Serializable getResult() {             return result;         }     }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10763</td>
    <td align="left">https://github.com/apache/syncope/blob/114c412afbfba24ffb4fbc804e5308a823a16a78/client/idrepo/ui/src/main/java/org/apache/syncope/client/ui/commons/wizards/AjaxWizard.java/#L344-L367</td>
    <td align="right">1</td>
    <td align="right">1354</td>
    <td align="right">10763</td>
  </tr>
  <tr valign="top">
    <td align="right">2572</td>
    <td align="left">&nbsp;{    &quot;response&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;Long Method&quot;,     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    class ColumnFamilyRegionInfo {         private RegionInfo regionInfo;         private Set familySet;          public ColumnFamilyRegionInfo(RegionInfo regionInfo, Set familySet) {             this.regionInfo = regionInfo;             this.familySet = familySet;         }          public RegionInfo getRegionInfo() {             return regionInfo;         }          public Set getFamilySet() {             return familySet;         }          @Override         public boolean equals(Object obj) {             if (obj == this) { return true; }             if (!(obj instanceof ColumnFamilyRegionInfo)) { return false; }              ColumnFamilyRegionInfo c = (ColumnFamilyRegionInfo)obj;             return c.getRegionInfo().equals(this.regionInfo) &amp;&amp; ByteUtil.match(this.familySet, c.getFamilySet());         }          @Override         public int hashCode() {             return this.getRegionInfo().hashCode();         }     }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14907</td>
    <td align="left">https://github.com/apache/phoenix/blob/69e5bb0b304a53967cef40b2a4cfc66e69ecaa51/phoenix-core/src/main/java/org/apache/phoenix/schema/stats/StatisticsCollectionRunTracker.java/#L129-L159</td>
    <td align="right">1</td>
    <td align="right">2572</td>
    <td align="right">14907</td>
  </tr>
  <tr valign="top">
    <td align="right">1019</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;&quot;, propOrder = {     &quot;content&quot; }) @XmlRootElement(name = &quot;cache-policy-conf-other&quot;) public class CachePolicyConfOther {      @XmlMixed     @XmlAnyElement     protected List content;      /**      * Gets the value of the content property.      *       *       * This accessor method returns a reference to the live list,      * not a snapshot. Therefore any modification you make to the      * returned list will be present inside the JAXB object.      * This is why there is not a set method for the content property.      *       *       * For example, to add a new item, do as follows:      *       *    getContent().add(newItem);      *       *       *       *       * Objects of the following type(s) are allowed in the list      * {@link Element }      * {@link String }      */     public List getContent() {         if (content == null) {             content = new ArrayList();         }         return this.content;     }  }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9341</td>
    <td align="left">https://github.com/apache/tomee/blob/d21933b313aff812fe5188b57bf572a9ad649148/container/openejb-jee/src/main/java/org/apache/openejb/jee/jba/CachePolicyConfOther.java/#L32-L71</td>
    <td align="right">1</td>
    <td align="right">1019</td>
    <td align="right">9341</td>
  </tr>
  <tr valign="top">
    <td align="right">972</td>
    <td align="left">&nbsp;YES, I found bad smells the bad smells are: 1. Dead Code: The implementation of the IConvertible interface is empty and does not provide any functionality. 2. Accessor Mutator Pair: The get and set methods have been generated for all fields, which may be unnecessary. 3. Indecent Exposure: The fields are not declared as private, making them accessible to other classes. 4. Feature envy: The Capability class seems to be more interested in the fields of the IConvertible interface and functions only as a data class without providing any additional functionality.</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class Capability implements IConvertible {     private String virtualCores;      private String memorySize;      private String memory;      public String getVirtualCores() {         return virtualCores;     }      public void setVirtualCores(String virtualCores) {         this.virtualCores = virtualCores;     }      public String getMemorySize() {         return memorySize;     }      public void setMemorySize(String memorySize) {         this.memorySize = memorySize;     }      public String getMemory() {         return memory;     }      public void setMemory(String memory) {         this.memory = memory;     } }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Dead Code: The implementation of the IConvertible interface is empty and does not provide any functionality2 Accessor Mutator Pair: The get and set methods have been generated for all fields, which may be unnecessary3 Indecent Exposure: The fields are not declared as private, making them accessible to other classes4 Feature envy: The Capability class seems to be more interested in the fields of the IConvertible interface and functions only as a data class without providing any additional functionality</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">. Dead Code: The implementation of the IConvertible interface is empty and does not provide any functionality.2. Accessor Mutator Pair: The get and set methods have been generated for all fields,  which may be unnecessary.3. Indecent Exposure: The fields are not declared as private</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8715</td>
    <td align="left">https://github.com/Microsoft/azure-tools-for-java/blob/d121e8ac9cc3ab400e5b49c8b372280ae332f3fb/Utils/hdinsight-node-common/src/com/microsoft/azure/hdinsight/sdk/rest/yarn/rm/Capability.java/#L26-L56</td>
    <td align="right">2</td>
    <td align="right">972</td>
    <td align="right">8715</td>
  </tr>
  <tr valign="top">
    <td align="right">225</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES, I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TwitterPullRecordReader implements IRecordReader {      private Query query;     private Twitter twitter;     private int requestInterval = 5; // seconds     private QueryResult result;     private int nextTweetIndex = 0;     private long lastTweetIdReceived = 0;     private CharArrayRecord record;     private boolean stopped = false;      public TwitterPullRecordReader(Twitter twitter, String keywords, int requestInterval) {         this.twitter = twitter;         this.requestInterval = requestInterval;         this.query = new Query(keywords);         this.query.setCount(100);         this.record = new CharArrayRecord();     }      @Override     public void close() throws IOException {         // do nothing     }      @Override     public boolean hasNext() throws Exception {         return !stopped;     }      @Override     public IRawRecord next() throws IOException, InterruptedException {         if (result == null || nextTweetIndex &gt;= result.getTweets().size()) {             Thread.sleep(1000 * requestInterval);             query.setSinceId(lastTweetIdReceived);             try {                 result = twitter.search(query);             } catch (TwitterException e) {                 throw HyracksDataException.create(e);             }             nextTweetIndex = 0;         }         if (result != null &amp;&amp; !result.getTweets().isEmpty()) {             List tw = result.getTweets();             Status tweet = tw.get(nextTweetIndex++);             if (lastTweetIdReceived &lt; tweet.getId()) {                 lastTweetIdReceived = tweet.getId();             }             String jsonTweet = TwitterObjectFactory.getRawJSON(tweet); // transform tweet obj to json             record.set(jsonTweet);             return record;         } else {             return null;         }     }      @Override     public boolean stop() {         stopped = true;         return true;     }      @Override     public void setFeedLogManager(FeedLogManager feedLogManager) {         // do nothing     }      @Override     public void setController(AbstractFeedDataFlowController controller) {         // do nothing     }      @Override     public boolean handleException(Throwable th) {         return false;     } }</td>
    <td align="left">data class</td>
    <td align="left">long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2434</td>
    <td align="left">https://github.com/apache/asterixdb/blob/223d13a06c4a4a58408aeac19674ac1f36f5ff35/asterixdb/asterix-external-data/src/main/java/org/apache/asterix/external/input/record/reader/twitter/TwitterPullRecordReader.java/#L38-L113</td>
    <td align="right">1</td>
    <td align="right">225</td>
    <td align="right">2434</td>
  </tr>
  <tr valign="top">
    <td align="right">83</td>
    <td align="left">&nbsp;	{ 		&quot;message&quot;: &quot;YES I found bad smells&quot;, 		&quot;detected_bad_smells&quot;: [ 			&quot;Data Class&quot;, 			&quot;Long Method&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface CompilationIdentifier {      enum Verbosity {         /**          * Only the unique identifier of the compilation.          */         ID,         /**          * Only the name of the compilation unit.          */         NAME,         /**          * {@link #ID} + a readable description.          */         DETAILED     }      CompilationRequestIdentifier INVALID_COMPILATION_ID = new CompilationRequestIdentifier() {          @Override         public String toString() {             return toString(Verbosity.DETAILED);         }          @Override         public String toString(Verbosity verbosity) {             return &quot;InvalidCompilationID&quot;;         }          @Override         public CompilationRequest getRequest() {             return null;         }      };      /**      * This method is a shortcut for {@link #toString(Verbosity)} with {@link Verbosity#DETAILED}.      */     @Override     String toString();      /**      * Creates a String representation for this compilation identifier with a given      * {@link Verbosity}.      */     String toString(Verbosity verbosity); }</td>
    <td align="left">data class</td>
    <td align="left">data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1197</td>
    <td align="left">https://github.com/oracle/graal/blob/4deb681aaaa79c248115037fc8e399c9876619fd/compiler/src/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/CompilationIdentifier.java/#L33-L80</td>
    <td align="right">1</td>
    <td align="right">83</td>
    <td align="right">1197</td>
  </tr>
  <tr valign="top">
    <td align="right">563</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES, I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class OdaDimensionState extends ReportElementState {  	/** 	 * The dimension being created. 	 */  	protected Dimension element = null;  	/** 	 * Constructs dimension state with the design parser handler, the container 	 * element and the container property name of the report element. 	 *  	 * @param handler 	 *            the design file parser handler 	 * @param theContainer 	 *            the element that contains this one 	 * @param prop 	 *            the slot in which this element appears 	 */  	public OdaDimensionState( ModuleParserHandler handler, 			DesignElement theContainer, String prop ) 	{ 		super( handler, theContainer, prop ); 	}  	/* 	 * (non-Javadoc) 	 *  	 * @see org.eclipse.birt.report.model.parser.ReportElementState#getElement() 	 */  	public DesignElement getElement( ) 	{ 		return element; 	}  	/* 	 * (non-Javadoc) 	 *  	 * @see org.eclipse.birt.report.model.util.AbstractParseState#parseAttrs(org.xml.sax.Attributes) 	 */  	public void parseAttrs( Attributes attrs ) throws XMLParserException 	{ 		element = new OdaDimension( ); 		initElement( attrs, true ); 	} }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5681</td>
    <td align="left">https://github.com/eclipse/birt/blob/f89264810347de98702db45386a822aabc0fadbf/model/org.eclipse.birt.report.model/src/org/eclipse/birt/report/model/parser/OdaDimensionState.java/#L25-L74</td>
    <td align="right">1</td>
    <td align="right">563</td>
    <td align="right">5681</td>
  </tr>
  <tr valign="top">
    <td align="right">2245</td>
    <td align="left">&nbsp;	{ 		&quot;message&quot;: &quot;YES, I found bad smells&quot;, 		&quot;bad smells are&quot;: [ 			&quot;Data Class&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TransportConnectionState extends org.apache.activemq.state.ConnectionState {      private ConnectionContext context;     private TransportConnection connection;     private AtomicInteger referenceCounter = new AtomicInteger();     private final Object connectionMutex = new Object();      public TransportConnectionState(ConnectionInfo info, TransportConnection transportConnection) {         super(info);         connection = transportConnection;     }      public ConnectionContext getContext() {         return context;     }      public TransportConnection getConnection() {         return connection;     }      public void setContext(ConnectionContext context) {         this.context = context;     }      public void setConnection(TransportConnection connection) {         this.connection = connection;     }      public int incrementReference() {         return referenceCounter.incrementAndGet();     }      public int decrementReference() {         return referenceCounter.decrementAndGet();     }  	public AtomicInteger getReferenceCounter() { 		return referenceCounter; 	}  	public void setReferenceCounter(AtomicInteger referenceCounter) { 		this.referenceCounter = referenceCounter; 	}  	public Object getConnectionMutex() { 		return connectionMutex; 	} }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13647</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-broker/src/main/java/org/apache/activemq/broker/TransportConnectionState.java/#L27-L74</td>
    <td align="right">1</td>
    <td align="right">2245</td>
    <td align="right">13647</td>
  </tr>
  <tr valign="top">
    <td align="right">1138</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ShuffleWriteMetrics {     private long bytesWritten;      private long recordsWritten;      private long writeTime;      public long getBytesWritten ()     {         return bytesWritten;     }      public void setBytesWritten (long bytesWritten)     {         this.bytesWritten = bytesWritten;     }      public long getRecordsWritten ()     {         return recordsWritten;     }      public void setRecordsWritten (long recordsWritten)     {         this.recordsWritten = recordsWritten;     }      public long getWriteTime ()     {         return writeTime;     }      public void setWriteTime (long writeTime)     {         this.writeTime = writeTime;     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10070</td>
    <td align="left">https://github.com/Microsoft/azure-tools-for-java/blob/d121e8ac9cc3ab400e5b49c8b372280ae332f3fb/Utils/hdinsight-node-common/src/com/microsoft/azure/hdinsight/sdk/rest/spark/task/ShuffleWriteMetrics.java/#L24-L60</td>
    <td align="right">1</td>
    <td align="right">1138</td>
    <td align="right">10070</td>
  </tr>
  <tr valign="top">
    <td align="right">871</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES, I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Status {     public String getAction() {         return action;     }      public Result getResult() {         return result;     }      public String getDetails() {         return details;     }      private String action;     private Result result;     private String details;      public Status(String action, Result result, String details) {         this.action = action;         this.result = result;         this.details = details;     }     public static enum Result {         SUCCESSFUL,         FAILED,     }      @Override     public String toString() {         return String.format(&quot;%s\t%s\t%s&quot;, action, result, details);     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7972</td>
    <td align="left">https://github.com/Microsoft/azure-tools-for-java/blob/d121e8ac9cc3ab400e5b49c8b372280ae332f3fb/Utils/azuretools-core/src/com/microsoft/azuretools/authmanage/srvpri/step/Status.java/#L28-L59</td>
    <td align="right">1</td>
    <td align="right">871</td>
    <td align="right">7972</td>
  </tr>
  <tr valign="top">
    <td align="right">652</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells. the bad smells are: 2. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ConsoleProxyClientParam {     private String clientHostAddress;     private int clientHostPort;     private String clientHostPassword;     private String clientTag;     private String ticket;     private String locale;     private String clientTunnelUrl;     private String clientTunnelSession;      private String hypervHost;      private String ajaxSessionId;     private String username;     private String password;      public ConsoleProxyClientParam() {         clientHostPort = 0;     }      public String getClientHostAddress() {         return clientHostAddress;     }      public void setClientHostAddress(String clientHostAddress) {         this.clientHostAddress = clientHostAddress;     }      public int getClientHostPort() {         return clientHostPort;     }      public void setClientHostPort(int clientHostPort) {         this.clientHostPort = clientHostPort;     }      public String getClientHostPassword() {         return clientHostPassword;     }      public void setClientHostPassword(String clientHostPassword) {         this.clientHostPassword = clientHostPassword;     }      public String getClientTag() {         return clientTag;     }      public void setClientTag(String clientTag) {         this.clientTag = clientTag;     }      public String getTicket() {         return ticket;     }      public void setTicket(String ticket) {         this.ticket = ticket;     }      public String getClientTunnelUrl() {         return clientTunnelUrl;     }      public void setClientTunnelUrl(String clientTunnelUrl) {         this.clientTunnelUrl = clientTunnelUrl;     }      public String getClientTunnelSession() {         return clientTunnelSession;     }      public void setClientTunnelSession(String clientTunnelSession) {         this.clientTunnelSession = clientTunnelSession;     }      public String getAjaxSessionId() {         return ajaxSessionId;     }      public void setAjaxSessionId(String ajaxSessionId) {         this.ajaxSessionId = ajaxSessionId;     }      public String getLocale() {         return locale;     }      public void setLocale(String locale) {         this.locale = locale;     }      public String getClientMapKey() {         if (clientTag != null &amp;&amp; !clientTag.isEmpty())             return clientTag;          return clientHostAddress + &quot;:&quot; + clientHostPort;     }      public void setHypervHost(String host) {         hypervHost = host;     }      public String getHypervHost() {         return hypervHost;     }      public void setUsername(String username) {         this.username = username;      }      public String getUsername() {         return username;     }      public void setPassword(String password) {         this.password = password;     }      public String getPassword() {         return password;     } }</td>
    <td align="left">data class</td>
    <td align="left">2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6386</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/server/src/main/java/com/cloud/servlet/ConsoleProxyClientParam.java/#L20-L143</td>
    <td align="right">1</td>
    <td align="right">652</td>
    <td align="right">6386</td>
  </tr>
  <tr valign="top">
    <td align="right">460</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Customer1131 {  	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id; 	private String firstName; 	private String lastName;  	protected Customer1131() {}  	public Customer1131(String firstName, String lastName) { 		this.firstName = firstName; 		this.lastName = lastName; 	}  	@Override 	public String toString() { 		return String.format(&quot;Customer1131[id=%d, firstName='%s', lastName='%s']&quot;, id, firstName, lastName); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4462</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer1131.java/#L8-L27</td>
    <td align="right">1</td>
    <td align="right">460</td>
    <td align="right">4462</td>
  </tr>
  <tr valign="top">
    <td align="right">3925</td>
    <td align="left">&nbsp;YES I found bad smells the bad smells are:  1. Long method  2. Feature envy  3. Primitive obsession  4. Inappropriate intimacy  5. Message chain  6. Duplicated code  7. Magic numbers  8. Data class  9. Lazy class</td>
    <td align="left">I need to check if the Java code below contains code smells (aka bad smells). Could you please <br />
identify which smells occur in the following code? However, do not describe the smells, just list them. Please start <br />
your answer with &quot;YES I found bad smells&quot; when you find any bad smell. Otherwise, start your answer with &quot;NO, <br />
I did not find any bad smell&quot;.<br />
When you start to list the detected bad smells, always put in your answer &quot;the bad smells are:&quot; amongst the text your <br />
answer and always separate it in this format: 1.Long method, 2.Feature envy:<br />
public class FileSinkOptionsMetadata implements ProfileNamesProvider {  	private static final String USE_SPEL_PROFILE = &quot;use-expression&quot;;  	private static final String USE_LITERAL_STRING_PROFILE = &quot;use-string&quot;;  	private boolean binary = false;  	private String charset = &quot;UTF-8&quot;;  	private String dir = &quot;/tmp/xd/output/&quot;;  	private String name = XD_STREAM_NAME;  	private String suffix = &quot;out&quot;;  	private Mode mode = APPEND;  	private String nameExpression;  	private String dirExpression;  	@NotNull 	public Mode getMode() { 		return mode; 	}  	@ModuleOption(&quot;what to do if the file already exists&quot;) 	public void setMode(Mode mode) { 		this.mode = mode; 	}  	/** 	 * Return dot + suffix if suffix is set, or the empty string otherwise. 	 */ 	public String getExtensionWithDot() { 		return StringUtils.hasText(suffix) ? &quot;.&quot; + suffix.trim() : &quot;&quot;; 	}   	@ModuleOption(&quot;filename extension to use&quot;) 	public void setSuffix(String suffix) { 		this.suffix = suffix; 	}  	public String getName() { 		return name; 	}  	@ModuleOption(&quot;filename pattern to use&quot;) 	public void setName(String name) { 		this.name = name; 	}  	@NotBlank 	public String getDir() { 		return dir; 	}  	@ModuleOption(&quot;the directory in which files will be created&quot;) 	public void setDir(String dir) { 		this.dir = dir; 	}  	public boolean isBinary() { 		return binary; 	}  	@ModuleOption(&quot;if false, will append a newline character at the end of each line&quot;) 	public void setBinary(boolean binary) { 		this.binary = binary; 	}  	@ModuleOption(&quot;the charset to use when writing a String payload&quot;) 	public void setCharset(String charset) { 		this.charset = charset; 	}  	@NotBlank 	public String getCharset() { 		return charset; 	}   	public String getNameExpression() { 		return nameExpression; 	}  	@ModuleOption(&quot;spring expression used to define filename&quot;) 	public void setNameExpression(String nameExpression) { 		this.nameExpression = nameExpression; 	}  	public String getDirExpression() { 		return dirExpression; 	}  	@ModuleOption(&quot;spring expression used to define directory name&quot;) 	public void setDirExpression(String dirExpression) { 		this.dirExpression = dirExpression; 	}  	public static enum Mode { 		APPEND, REPLACE, FAIL, IGNORE; 	}  	@Override 	public String[] profilesToActivate() { 		return (nameExpression != null || dirExpression != null) ? new String[] { USE_SPEL_PROFILE } 				: new String[] { USE_LITERAL_STRING_PROFILE }; 	} }</td>
    <td align="left">data class</td>
    <td align="left">&nbsp;Long method 2 Feature envy 3 Primitive obsession 4 Inappropriate intimacy 5 Message chain 6 Duplicated code 7 Magic numbers 8 Data class 9 Lazy class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10274</td>
    <td align="left">https://github.com/spring-projects/spring-xd/blob/ec106725c51d245109b2e5055d9f65e43228ecc1/spring-xd-dirt/src/main/java/org/springframework/xd/dirt/modules/metadata/FileSinkOptionsMetadata.java/#L37-L148</td>
    <td align="right">2</td>
    <td align="right">3925</td>
    <td align="right">10274</td>
  </tr>
  <tr valign="top">
    <td align="right">1568</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells\nthe bad smells are: 1. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class DCSerialField extends DCBlockTag implements SerialFieldTree {         public final DCIdentifier name;         public final DCReference type;         public final List description;          DCSerialField(DCIdentifier name, DCReference type, List description) {             this.description = description;             this.name = name;             this.type = type;         }          @Override @DefinedBy(Api.COMPILER_TREE)         public Kind getKind() {             return Kind.SERIAL_FIELD;         }          @Override @DefinedBy(Api.COMPILER_TREE)         public  R accept(DocTreeVisitor v, D d) {             return v.visitSerialField(this, d);         }          @Override @DefinedBy(Api.COMPILER_TREE)         public List getDescription() {             return description;         }          @Override @DefinedBy(Api.COMPILER_TREE)         public IdentifierTree getName() {             return name;         }          @Override @DefinedBy(Api.COMPILER_TREE)         public ReferenceTree getType() {             return type;         }     }</td>
    <td align="left">data class</td>
    <td align="left">1. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11331</td>
    <td align="left">https://github.com/google/error-prone-javac/blob/a53d069bbdb2c60232ed3811c19b65e41c3e60e0/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/DCTree.java/#L732-L767</td>
    <td align="right">1</td>
    <td align="right">1568</td>
    <td align="right">11331</td>
  </tr>
  <tr valign="top">
    <td align="right">2675</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class IntermediateModel {     private final Metadata metadata;      private final Map operations;      private final Map shapes;      private final CustomizationConfig customizationConfig;      private final ServiceExamples examples;      private final Map customAuthorizers;      @JsonIgnore     private final Optional endpointOperation;      @JsonIgnore     private final Map paginators;      @JsonIgnore     private final NamingStrategy namingStrategy;      @JsonCreator     public IntermediateModel(         @JsonProperty(&quot;metadata&quot;) Metadata metadata,         @JsonProperty(&quot;operations&quot;) Map operations,         @JsonProperty(&quot;shapes&quot;) Map shapes,         @JsonProperty(&quot;customizationConfig&quot;) CustomizationConfig customizationConfig,         @JsonProperty(&quot;serviceExamples&quot;) ServiceExamples examples) {          this(metadata, operations, shapes, customizationConfig, examples, null,              Collections.emptyMap(), Collections.emptyMap(), null);     }      public IntermediateModel(         Metadata metadata,         Map operations,         Map shapes,         CustomizationConfig customizationConfig,         ServiceExamples examples,         OperationModel endpointOperation,         Map customAuthorizers,         Map paginators,         NamingStrategy namingStrategy) {         this.metadata = metadata;         this.operations = operations;         this.shapes = shapes;         this.customizationConfig = customizationConfig;         this.examples = examples;         this.endpointOperation = Optional.ofNullable(endpointOperation);         this.customAuthorizers = customAuthorizers;         this.paginators = paginators;         this.namingStrategy = namingStrategy;     }      public Metadata getMetadata() {         return metadata;     }      public Map getOperations() {         return operations;     }      public OperationModel getOperation(String operationName) {         return getOperations().get(operationName);     }      public Map getShapes() {         return shapes;     }      public ShapeModel getShapeByC2jName(String c2jName) {         return Utils.findShapeModelByC2jName(this, c2jName);     }      public CustomizationConfig getCustomizationConfig() {         return customizationConfig;     }      public ServiceExamples getExamples() {         return examples;     }      public Map getPaginators() {         return paginators;     }      public NamingStrategy getNamingStrategy() {         return namingStrategy;     }      public String getCustomRetryPolicy() {         return customizationConfig.getCustomRetryPolicy();     }      public String getSdkModeledExceptionBaseFqcn() {         return String.format(&quot;%s.%s&quot;,                              metadata.getFullModelPackageName(),                              getSdkModeledExceptionBaseClassName());     }      public String getSdkModeledExceptionBaseClassName() {         if (customizationConfig.getSdkModeledExceptionBaseClassName() != null) {             return customizationConfig.getSdkModeledExceptionBaseClassName();         } else {             return metadata.getBaseExceptionName();         }     }      public String getSdkRequestBaseClassName() {         if (customizationConfig.getSdkRequestBaseClassName() != null) {             return customizationConfig.getSdkRequestBaseClassName();         } else {             return metadata.getBaseRequestName();         }     }      public String getSdkResponseBaseClassName() {         if (customizationConfig.getSdkResponseBaseClassName() != null) {             return customizationConfig.getSdkResponseBaseClassName();         } else {             return metadata.getBaseResponseName();         }     }      public String getFileHeader() throws IOException {         return loadDefaultFileHeader();     }      private String loadDefaultFileHeader() throws IOException {         try (InputStream inputStream = getClass()             .getResourceAsStream(&quot;/software/amazon/awssdk/codegen/DefaultFileHeader.txt&quot;)) {             return IoUtils.toUtf8String(inputStream)                           .replaceFirst(&quot;%COPYRIGHT_DATE_RANGE%&quot;, getCopyrightDateRange());         }     }      private String getCopyrightDateRange() {         int currentYear = ZonedDateTime.now().getYear();         int copyrightStartYear = currentYear - 5;         return String.format(&quot;%d-%d&quot;, copyrightStartYear, currentYear);     }      public String getSdkBaseResponseFqcn() {         if (metadata.getProtocol() == Protocol.API_GATEWAY) {             return &quot;software.amazon.awssdk.opensdk.BaseResult&quot;;         } else {             return String.format(&quot;%s&lt;%s&gt;&quot;,                                  AwsResponse.class.getName(),                                  getResponseMetadataClassName());         }     }      private String getResponseMetadataClassName() {         return AwsResponseMetadata.class.getName();     }      @JsonIgnore     public List simpleMethodsRequiringTesting() {         return getOperations().values().stream()                               .filter(v -&gt; v.getInputShape().isSimpleMethod())                               .collect(Collectors.toList());     }      public Map getCustomAuthorizers() {         return customAuthorizers;     }      public Optional getEndpointOperation() {         return endpointOperation;     }      public boolean hasPaginators() {         return paginators.size() &gt; 0;     }      public boolean containsRequestSigners() {         return getShapes().values().stream()                           .filter(ShapeModel::isRequestSignerAware)                           .findAny()                           .isPresent();     }      public boolean containsRequestEventStreams() {         return getOperations().values().stream()                               .filter(opModel -&gt; opModel.hasEventStreamInput())                               .findAny()                               .isPresent();     } }</td>
    <td align="left">data class</td>
    <td align="left">data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15229</td>
    <td align="left">https://github.com/aws/aws-sdk-java-v2/blob/1d5d11e8087c93ab1a3a2d35193052e526fd123c/codegen/src/main/java/software/amazon/awssdk/codegen/model/intermediate/IntermediateModel.java/#L37-L226</td>
    <td align="right">1</td>
    <td align="right">2675</td>
    <td align="right">15229</td>
  </tr>
</table>
<p>(674 rows)<br />
</p>
