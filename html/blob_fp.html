<table border="1">
  <tr>
    <th align="center">id</th>
    <th align="center">chat_gpt_response</th>
    <th align="center">question</th>
    <th align="center">badsmell_base</th>
    <th align="center">bad_smell_gpt</th>
    <th align="center">found_any</th>
    <th align="center">valid_bad_smell</th>
    <th align="center">bad_smell_in_base</th>
    <th align="center">bad_smell_not_in_the_base</th>
    <th align="center">bad_smell_not_found</th>
    <th align="center">index</th>
    <th align="center">index_base</th>
    <th align="center">url_github</th>
    <th align="center">nr_question</th>
    <th align="center">id_source_code</th>
    <th align="center">id_base</th>
  </tr>
  <tr valign="top">
    <td align="right">24</td>
    <td align="left">&nbsp;{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: &quot;3. Blob, 4. Data Class&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Ipam {   private String driver;   private List config;   private Map options;    public String getDriver() {     return driver;   }    public void setDriver(String driver) {     this.driver = driver;   }    public Ipam withDriver(String driver) {     this.driver = driver;     return this;   }    public List getConfig() {     return config;   }    public void setConfig(List config) {     this.config = config;   }    public Ipam withConfig(List config) {     this.config = config;     return this;   }    public Map getOptions() {     return options;   }    public void setOptions(Map options) {     this.options = options;   }    public Ipam withOptions(Map options) {     this.options = options;     return this;   }    @Override   public boolean equals(Object obj) {     if (this == obj) {       return true;     }     if (!(obj instanceof Ipam)) {       return false;     }     final Ipam that = (Ipam) obj;     return Objects.equals(driver, that.driver)         &amp;&amp; getConfig().equals(that.getConfig())         &amp;&amp; getOptions().equals(that.getOptions());   }    @Override   public int hashCode() {     int hash = 7;     hash = 31 * hash + Objects.hashCode(driver);     hash = 31 * hash + getConfig().hashCode();     hash = 31 * hash + getOptions().hashCode();     return hash;   }    @Override   public String toString() {     return &quot;Ipam{&quot;         + &quot;driver='&quot;         + driver         + '\''         + &quot;, config=&quot;         + config         + &quot;, options=&quot;         + options         + '}';   } }</td>
    <td align="left">data class</td>
    <td align="left">3. blob, 4. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">3. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">691</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/infrastructures/docker/docker-client/src/main/java/org/eclipse/che/infrastructure/docker/client/json/network/Ipam.java/#L19-L98</td>
    <td align="right">1</td>
    <td align="right">24</td>
    <td align="right">691</td>
  </tr>
  <tr valign="top">
    <td align="right">46</td>
    <td align="left">{&quot;response&quot;: &quot;YES, I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public UDATA add(UDATA parameter) { 		return new UDATA(this).add(parameter); 	}</td>
    <td align="left">feature envy</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">835</td>
    <td align="left">https://github.com/eclipse/openj9/blob/4911084853eb75b20e037c434ad4521b7317ebfb/debugtools/DDR_VM/src/com/ibm/j9ddr/vm29/types/U32.java/#L70-L72</td>
    <td align="right">1</td>
    <td align="right">46</td>
    <td align="right">835</td>
  </tr>
  <tr valign="top">
    <td align="right">58</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Long Method&quot;,     &quot;Blob&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@AutoValue abstract class UOfKind extends UExpression {   public static UOfKind create(UExpression expression, Set allowed) {     return new AutoValue_UOfKind(expression, allowed);   }    abstract UExpression expression();    abstract Set allowed();    @Override   public JCExpression inline(Inliner inliner) throws CouldNotResolveImportException {     return expression().inline(inliner);   }    @Override   public  R accept(TreeVisitor visitor, D data) {     return expression().accept(visitor, data);   }    @Override   public Kind getKind() {     return expression().getKind();   }    @Override   @Nullable   protected Choice defaultAction(Tree tree, @Nullable Unifier unifier) {     return Choice.condition(allowed().contains(tree.getKind()), unifier)         .thenChoose(unifications(expression(), tree));   } }</td>
    <td align="left">data class</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method,  blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">988</td>
    <td align="left">https://github.com/google/error-prone/blob/61cb540c08ec63faa56dccce00049cff1f8b41ea/core/src/main/java/com/google/errorprone/refaster/UOfKind.java/#L33-L64</td>
    <td align="right">1</td>
    <td align="right">58</td>
    <td align="right">988</td>
  </tr>
  <tr valign="top">
    <td align="right">59</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SysInfo implements Serializable {      static final long serialVersionUID = -3096346807579L;      public int numCores;     public long maxMemory;      public SysInfo(int nc, long mm) {         numCores = nc;         maxMemory = mm;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1004</td>
    <td align="left">https://github.com/google/error-prone-javac/blob/a53d069bbdb2c60232ed3811c19b65e41c3e60e0/src/jdk.compiler/share/classes/com/sun/tools/sjavac/server/SysInfo.java/#L45-L56</td>
    <td align="right">1</td>
    <td align="right">59</td>
    <td align="right">1004</td>
  </tr>
  <tr valign="top">
    <td align="right">62</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Long Method&quot;,             &quot;Blob&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  @AutoValue.Builder   public abstract static class Builder {     public abstract Builder setCompileTimeConstant(boolean compileTimeConstant);      public abstract Builder setStatic(boolean isStatic);      public abstract Builder setFinal(boolean isFinal);      public abstract Builder setVariableCapture(boolean isVariableCapture);      public abstract Builder setEnclosingInstanceCapture(boolean isEnclosingInstanceCapture);      public abstract Builder setEnclosingTypeDescriptor(         DeclaredTypeDescriptor enclosingTypeDescriptor);      public abstract Builder setName(String name);      public abstract Builder setEnumConstant(boolean isEnumConstant);      public abstract Builder setSynthetic(boolean isSynthetic);      public abstract Builder setTypeDescriptor(TypeDescriptor typeDescriptor);      public abstract Builder setVisibility(Visibility visibility);      public abstract Builder setJsInfo(JsInfo jsInfo);      public abstract Builder setUnusableByJsSuppressed(boolean isUnusableByJsSuppressed);      public abstract Builder setDeprecated(boolean isDeprecated);      public abstract Builder setOrigin(FieldOrigin fieldOrigin);      public Builder setDeclarationFieldDescriptor(FieldDescriptor declarationFieldDescriptor) {       return setDeclarationFieldDescriptorOrNullIfSelf(declarationFieldDescriptor);     }      // Accessors to support validation, default construction and custom setters.     abstract Builder setDeclarationFieldDescriptorOrNullIfSelf(         FieldDescriptor declarationFieldDescriptor);      abstract Optional getName();      abstract FieldDescriptor autoBuild();      public FieldDescriptor build() {       checkState(getName().isPresent());       FieldDescriptor fieldDescriptor = autoBuild();        checkState(           !fieldDescriptor.isVariableCapture() || !fieldDescriptor.isEnclosingInstanceCapture());        return interner.intern(fieldDescriptor);     }      public static Builder from(FieldDescriptor fieldDescriptor) {       return fieldDescriptor.toBuilder();     }      private static final ThreadLocalInterner interner =         new ThreadLocalInterner&lt;&gt;();   }</td>
    <td align="left">data class</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method,  blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">1048</td>
    <td align="left">https://github.com/google/j2cl/blob/f233ebf547cce390cf87ce346ed82e0512f4fbe1/transpiler/java/com/google/j2cl/ast/FieldDescriptor.java/#L194-L255</td>
    <td align="right">1</td>
    <td align="right">62</td>
    <td align="right">1048</td>
  </tr>
  <tr valign="top">
    <td align="right">80</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  abstract static class RequestParamsBuilder {     T body;      public RequestParamsBuilder(T body) {       this.body = body;     }      abstract RequestParams buildRequestParams();      void setBody(T body) {       this.body = body;     }   }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1185</td>
    <td align="left">https://github.com/oracle/weblogic-kubernetes-operator/blob/1fb059d7e32b9b3514617d54e4dda41ab68e71ea/operator/src/main/java/oracle/kubernetes/operator/helpers/CallBuilder.java/#L179-L191</td>
    <td align="right">1</td>
    <td align="right">80</td>
    <td align="right">1185</td>
  </tr>
  <tr valign="top">
    <td align="right">88</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells_found&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  static class DynamicPackageEntry {      // public:     //     // DynamicPackageEntry() =default;      DynamicPackageEntry(String package_name, int package_id) {       this.package_name = package_name;       this.package_id = package_id;     }      String package_name;     int package_id = 0;   }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1229</td>
    <td align="left">https://github.com/robolectric/robolectric/blob/525bfcfc0e0ed1653ad57341b564c6857e11dc50/resources/src/main/java/org/robolectric/res/android/LoadedArsc.java/#L62-L75</td>
    <td align="right">1</td>
    <td align="right">88</td>
    <td align="right">1229</td>
  </tr>
  <tr valign="top">
    <td align="right">90</td>
    <td align="left">{&quot;response&quot;: &quot;YES, I found bad smells the bad smells are: 1. Blob&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class TestConfiguration {  	private String downloadUrl;  	private final String description;  	private TestSuite suite;  	public TestConfiguration(String description) { 		this.description = description; 	}  	public String getDownloadUrl() { 		return downloadUrl; 	}  	public void setDownloadUrl(String downloadUrl) { 		this.downloadUrl = downloadUrl; 	}  	public String getDescription() { 		return description; 	}  	@Override 	public String toString() { 		return getClass().getSimpleName() + &quot; [&quot; + description + &quot;]&quot;; 	}  	public TestSuite createSuite(TestSuite parentSuite) { 		suite = new TestSuite(&quot;Testing on &quot; + getDescription()); 		parentSuite.addTest(suite); 		suite.addTest(new Activation(&quot;TestSuite: &quot; + getDescription(), true)); 		return suite; 	}  	public void add(Class clazz) { 		Assert.isNotNull(suite, &quot;Invoke createSuite() first&quot;); 		suite.addTestSuite(clazz); 	}  	public void done() { 		Assert.isNotNull(suite, &quot;Invoke createSuite() first&quot;); 		suite.addTest(new Activation(&quot;done&quot;, false)); 		suite = null; 	}  	private final class Activation extends TestCase {  		private final boolean activate;  		private Activation(String name, boolean activate) { 			super(name); 			this.activate = activate; 		}  		@Override 		protected void runTest() throws Throwable { 			if (activate) { 				activate(); 			} 			else { 				getDefault().activate(); 			} 		}  	}  	protected abstract TestConfiguration getDefault();  	public abstract void activate();  	public abstract TestHarness createHarness();  }</td>
    <td align="left">data class</td>
    <td align="left">1. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">1240</td>
    <td align="left">https://github.com/spring-projects/eclipse-integration-tcserver/blob/5b381256cb35cfe2aa21f5093558f7ca927c289f/com.vmware.vfabric.ide.eclipse.tcserver.tests/src/com/vmware/vfabric/ide/eclipse/tcserver/tests/support/TestConfiguration.java/#L21-L95</td>
    <td align="right">1</td>
    <td align="right">90</td>
    <td align="right">1240</td>
  </tr>
  <tr valign="top">
    <td align="right">93</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells the bad smells are: 1. Blob&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DefaultResourceService implements ResourceService {  	private String servletPath = &quot;&quot;; 	 	/** 	 * @param servletPath the servletPath to set 	 */ 	public void setServletPath(String servletPath) { 		this.servletPath = servletPath; 	}  	public String getServletPath() { 		return servletPath; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">1. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">1252</td>
    <td align="left">https://github.com/spring-projects/spring-batch-admin/blob/9e3ad8bff99b8fad8da62426aa7d2959eb841bcf/spring-batch-admin-resources/src/main/java/org/springframework/batch/admin/web/resources/DefaultResourceService.java/#L23-L38</td>
    <td align="right">1</td>
    <td align="right">93</td>
    <td align="right">1252</td>
  </tr>
  <tr valign="top">
    <td align="right">94</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;,  &quot;bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface ServletConstants {     String PAGE_HEADER           = &quot;\n&quot; +             &quot;\n&quot; +             &quot;\n&quot; +             &quot;    \n&quot; +             &quot;    Weblogic Monitoring Exporter\n&quot; +             &quot;\n&quot; +             &quot;&quot;;      // The locations of the servlets relative to the web app     String MAIN_PAGE = &quot;&quot;;     String METRICS_PAGE = &quot;metrics&quot;;     String CONFIGURATION_PAGE = &quot;configure&quot;;      /** The header used by a web client to send its authentication credentials. **/     String AUTHENTICATION_HEADER = &quot;Authorization&quot;;      /** The header used by a web client to send cookies as part of a request. */     String COOKIE_HEADER = &quot;Cookie&quot;;      // The field which defines the configuration update action     String EFFECT_OPTION = &quot;effect&quot;;      // The possible values for the effect     String DEFAULT_ACTION = ServletConstants.REPLACE_ACTION;     String REPLACE_ACTION = &quot;replace&quot;;     String APPEND_ACTION = &quot;append&quot;; }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1261</td>
    <td align="left">https://github.com/oracle/weblogic-monitoring-exporter/blob/05f1d3c4cc797577801df0ceceb9d92fc31718e8/src/main/java/io/prometheus/wls/rest/ServletConstants.java/#L13-L41</td>
    <td align="right">1</td>
    <td align="right">94</td>
    <td align="right">1261</td>
  </tr>
  <tr valign="top">
    <td align="right">97</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public static class Undertow {  		/** 		 * Maximum size of the HTTP post content. When the value is -1, the default, the 		 * size is unlimited. 		 */ 		private DataSize maxHttpPostSize = DataSize.ofBytes(-1);  		/** 		 * Size of each buffer. The default is derived from the maximum amount of memory 		 * that is available to the JVM. 		 */ 		private DataSize bufferSize;  		/** 		 * Number of I/O threads to create for the worker. The default is derived from the 		 * number of available processors. 		 */ 		private Integer ioThreads;  		/** 		 * Number of worker threads. The default is 8 times the number of I/O threads. 		 */ 		private Integer workerThreads;  		/** 		 * Whether to allocate buffers outside the Java heap. The default is derived from 		 * the maximum amount of memory that is available to the JVM. 		 */ 		private Boolean directBuffers;  		/** 		 * Whether servlet filters should be initialized on startup. 		 */ 		private boolean eagerFilterInit = true;  		private final Accesslog accesslog = new Accesslog();  		public DataSize getMaxHttpPostSize() { 			return this.maxHttpPostSize; 		}  		public void setMaxHttpPostSize(DataSize maxHttpPostSize) { 			this.maxHttpPostSize = maxHttpPostSize; 		}  		public DataSize getBufferSize() { 			return this.bufferSize; 		}  		public void setBufferSize(DataSize bufferSize) { 			this.bufferSize = bufferSize; 		}  		public Integer getIoThreads() { 			return this.ioThreads; 		}  		public void setIoThreads(Integer ioThreads) { 			this.ioThreads = ioThreads; 		}  		public Integer getWorkerThreads() { 			return this.workerThreads; 		}  		public void setWorkerThreads(Integer workerThreads) { 			this.workerThreads = workerThreads; 		}  		public Boolean getDirectBuffers() { 			return this.directBuffers; 		}  		public void setDirectBuffers(Boolean directBuffers) { 			this.directBuffers = directBuffers; 		}  		public boolean isEagerFilterInit() { 			return this.eagerFilterInit; 		}  		public void setEagerFilterInit(boolean eagerFilterInit) { 			this.eagerFilterInit = eagerFilterInit; 		}  		public Accesslog getAccesslog() { 			return this.accesslog; 		}  		/** 		 * Undertow access log properties. 		 */ 		public static class Accesslog {  			/** 			 * Whether to enable the access log. 			 */ 			private boolean enabled = false;  			/** 			 * Format pattern for access logs. 			 */ 			private String pattern = &quot;common&quot;;  			/** 			 * Log file name prefix. 			 */ 			protected String prefix = &quot;access_log.&quot;;  			/** 			 * Log file name suffix. 			 */ 			private String suffix = &quot;log&quot;;  			/** 			 * Undertow access log directory. 			 */ 			private File dir = new File(&quot;logs&quot;);  			/** 			 * Whether to enable access log rotation. 			 */ 			private boolean rotate = true;  			public boolean isEnabled() { 				return this.enabled; 			}  			public void setEnabled(boolean enabled) { 				this.enabled = enabled; 			}  			public String getPattern() { 				return this.pattern; 			}  			public void setPattern(String pattern) { 				this.pattern = pattern; 			}  			public String getPrefix() { 				return this.prefix; 			}  			public void setPrefix(String prefix) { 				this.prefix = prefix; 			}  			public String getSuffix() { 				return this.suffix; 			}  			public void setSuffix(String suffix) { 				this.suffix = suffix; 			}  			public File getDir() { 				return this.dir; 			}  			public void setDir(File dir) { 				this.dir = dir; 			}  			public boolean isRotate() { 				return this.rotate; 			}  			public void setRotate(boolean rotate) { 				this.rotate = rotate; 			}  		}  	}</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1279</td>
    <td align="left">https://github.com/spring-projects/spring-boot/blob/2225b362991f225e3a93f00e160526d2b8abdfb2/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java/#L949-L1124</td>
    <td align="right">1</td>
    <td align="right">97</td>
    <td align="right">1279</td>
  </tr>
  <tr valign="top">
    <td align="right">107</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;1. Blob&quot;,       &quot;2. Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface Customer583Repository extends CrudRepository {  	List findByLastName(String lastName); }</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. blob,  2. long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">1412</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/repo/Customer583Repository.java/#L9-L12</td>
    <td align="right">1</td>
    <td align="right">107</td>
    <td align="right">1412</td>
  </tr>
  <tr valign="top">
    <td align="right">117</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ThymeleafAnnotationValues extends AbstractAnnotationValues {    @AutoPopulate   private String[] excludeMethods;    @AutoPopulate   private String[] excludeViews;    /**    * Constructor    *    * @param governorPhysicalTypeMetadata    */   public ThymeleafAnnotationValues(final PhysicalTypeMetadata governorPhysicalTypeMetadata) {     super(governorPhysicalTypeMetadata, ROO_THYMELEAF);     AutoPopulationUtils.populate(this, annotationMetadata);   }     public String[] getExcludeMethods() {     return excludeMethods;   }    public String[] getExcludeViews() {     return excludeViews;   }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1507</td>
    <td align="left">https://github.com/spring-projects/spring-roo/blob/4a2e9f1eb17d4e49ad947503a63afef7d5a37842/addon-web-mvc-thymeleaf/addon/src/main/java/org/springframework/roo/addon/web/mvc/thymeleaf/addon/ThymeleafAnnotationValues.java/#L17-L44</td>
    <td align="right">1</td>
    <td align="right">117</td>
    <td align="right">1507</td>
  </tr>
  <tr valign="top">
    <td align="right">121</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;1. Blob&quot;, &quot;2. Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	private void formatElement(IProgressMonitor monitor) { 		FormatProcessorXML formatProcessor = new FormatProcessorXML(); 		formatProcessor.setProgressMonitor(monitor); 		formatProcessor.getFormatPreferences().setClearAllBlankLines(true); 		formatProcessor.formatModel(model);  		CleanupProcessorXML bla = new CleanupProcessorXML(); 		bla.getCleanupPreferences().setCompressEmptyElementTags(true); 		bla.cleanupModel(model); 	}</td>
    <td align="left">feature envy</td>
    <td align="left">1. blob, 2. long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. blob,  2. long method</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">1534</td>
    <td align="left">https://github.com/spring-projects/spring-ide/blob/915fe9bffd50db45ee0b8fb993416e45dee68179/plugins/org.springframework.ide.eclipse.webflow.ui.graph/src/org/springframework/ide/eclipse/webflow/ui/graph/WebflowEditor.java/#L578-L587</td>
    <td align="right">1</td>
    <td align="right">121</td>
    <td align="right">1534</td>
  </tr>
  <tr valign="top">
    <td align="right">133</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class AnnotPage extends ContactsDisplayPage { 	@SpringBean 	private ContactDao dao;  	@Override 	protected ContactDataProvider getDataProvider() 	{ 		return new ProxyDataProvider(dao); 	} }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">1634</td>
    <td align="left">https://github.com/apache/wicket/blob/c2d344219ef8046508ca40653c9de485b3cbd4c4/wicket-examples/src/main/java/org/apache/wicket/examples/spring/annot/web/AnnotPage.java/#L27-L37</td>
    <td align="right">1</td>
    <td align="right">133</td>
    <td align="right">1634</td>
  </tr>
  <tr valign="top">
    <td align="right">137</td>
    <td align="left">&nbsp;{   &quot;message&quot;: &quot;YES, I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;1. Blob&quot;,     &quot;2. Data Class&quot;,     &quot;3. Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LoopedModelImpl extends MinimalEObjectImpl.Container implements LoopedModel {   /**    * The cached value of the '{@link #getVisibility() Visibility}' attribute list.    *     *     * @see #getVisibility()    * @generated    * @ordered    */   protected EList visibility;    /**    * The cached value of the '{@link #getStatic() Static}' attribute list.    *     *     * @see #getStatic()    * @generated    * @ordered    */   protected EList static_;    /**    * The cached value of the '{@link #getSynchronized() Synchronized}' attribute list.    *     *     * @see #getSynchronized()    * @generated    * @ordered    */   protected EList synchronized_;    /**    * The cached value of the '{@link #getAbstract() Abstract}' attribute list.    *     *     * @see #getAbstract()    * @generated    * @ordered    */   protected EList abstract_;    /**    * The cached value of the '{@link #getFinal() Final}' attribute list.    *     *     * @see #getFinal()    * @generated    * @ordered    */   protected EList final_;    /**    * The default value of the '{@link #getName() Name}' attribute.    *     *     * @see #getName()    * @generated    * @ordered    */   protected static final String NAME_EDEFAULT = null;    /**    * The cached value of the '{@link #getName() Name}' attribute.    *     *     * @see #getName()    * @generated    * @ordered    */   protected String name = NAME_EDEFAULT;    /**    *     *     * @generated    */   protected LoopedModelImpl()   {     super();   }    /**    *     *     * @generated    */   @Override   protected EClass eStaticClass()   {     return UnorderedGroupsTestPackage.Literals.LOOPED_MODEL;   }    /**    *     *     * @generated    */   public EList getVisibility()   {     if (visibility == null)     {       visibility = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY);     }     return visibility;   }    /**    *     *     * @generated    */   public EList getStatic()   {     if (static_ == null)     {       static_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC);     }     return static_;   }    /**    *     *     * @generated    */   public EList getSynchronized()   {     if (synchronized_ == null)     {       synchronized_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED);     }     return synchronized_;   }    /**    *     *     * @generated    */   public EList getAbstract()   {     if (abstract_ == null)     {       abstract_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT);     }     return abstract_;   }    /**    *     *     * @generated    */   public EList getFinal()   {     if (final_ == null)     {       final_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL);     }     return final_;   }    /**    *     *     * @generated    */   public String getName()   {     return name;   }    /**    *     *     * @generated    */   public void setName(String newName)   {     String oldName = name;     name = newName;     if (eNotificationRequired())       eNotify(new ENotificationImpl(this, Notification.SET, UnorderedGroupsTestPackage.LOOPED_MODEL__NAME, oldName, name));   }    /**    *     *     * @generated    */   @Override   public Object eGet(int featureID, boolean resolve, boolean coreType)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         return getVisibility();       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         return getStatic();       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         return getSynchronized();       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         return getAbstract();       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         return getFinal();       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         return getName();     }     return super.eGet(featureID, resolve, coreType);   }    /**    *     *     * @generated    */   @SuppressWarnings(&quot;unchecked&quot;)   @Override   public void eSet(int featureID, Object newValue)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         getVisibility().clear();         getVisibility().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         getStatic().clear();         getStatic().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         getSynchronized().clear();         getSynchronized().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         getAbstract().clear();         getAbstract().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         getFinal().clear();         getFinal().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         setName((String)newValue);         return;     }     super.eSet(featureID, newValue);   }    /**    *     *     * @generated    */   @Override   public void eUnset(int featureID)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         getVisibility().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         getStatic().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         getSynchronized().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         getAbstract().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         getFinal().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         setName(NAME_EDEFAULT);         return;     }     super.eUnset(featureID);   }    /**    *     *     * @generated    */   @Override   public boolean eIsSet(int featureID)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         return visibility != null &amp;&amp; !visibility.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         return static_ != null &amp;&amp; !static_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         return synchronized_ != null &amp;&amp; !synchronized_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         return abstract_ != null &amp;&amp; !abstract_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         return final_ != null &amp;&amp; !final_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         return NAME_EDEFAULT == null ? name != null : !NAME_EDEFAULT.equals(name);     }     return super.eIsSet(featureID);   }    /**    *     *     * @generated    */   @Override   public String toString()   {     if (eIsProxy()) return super.toString();      StringBuffer result = new StringBuffer(super.toString());     result.append(&quot; (visibility: &quot;);     result.append(visibility);     result.append(&quot;, static: &quot;);     result.append(static_);     result.append(&quot;, synchronized: &quot;);     result.append(synchronized_);     result.append(&quot;, abstract: &quot;);     result.append(abstract_);     result.append(&quot;, final: &quot;);     result.append(final_);     result.append(&quot;, name: &quot;);     result.append(name);     result.append(')');     return result.toString();   }  } //LoopedModelImpl</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. data class, 3. long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. blob,  3. long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">1730</td>
    <td align="left">https://github.com/eclipse/xtext-eclipse/blob/0c7546b6aaf3644a77fc68eef9f3da368cbbeabd/org.eclipse.xtext.ui.tests/src-gen/org/eclipse/xtext/ui/tests/editor/contentassist/unorderedGroupsTest/impl/LoopedModelImpl.java/#L40-L375</td>
    <td align="right">1</td>
    <td align="right">137</td>
    <td align="right">1730</td>
  </tr>
  <tr valign="top">
    <td align="right">151</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Blob&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MultiDexConfig {      private String name;      public MultiDexConfig(String name) {         this.name = name;     }      @Config(title = &quot;Whether to enable fast&quot;, message = &quot;Enable atlas , true/false&quot;, order = 0, group = &quot;atlas&quot;)     private boolean fastMultiDex = false;      @Config(title = &quot;The extra first dex class list&quot;, message = &quot;The custom needs to be placed in the entry class in the first dex&quot;, order = 3, group = &quot;atlas&quot;)     private Set firstDexClasses = Sets.newHashSet();     /**      * dex The number of subcontracting, 0 No restrictions, no two merges      */     @Config(title = &quot;dexThe number of&quot;, message = &quot;0unlimited&quot;, order = 1, group = &quot;atlas&quot;)     private int dexCount;      public int getMainDexListCount() {         return mainDexListCount;     }      public void setMainDexListCount(int mainDexListCount) {         this.mainDexListCount = mainDexListCount;     }      private int mainDexListCount;      @Config(title = &quot;dexSeparated rules&quot;, message = &quot;a,b;c,d&quot;, order = 2, group = &quot;atlas&quot;)     private String dexSplitRules;      @Config(title = &quot;Does not enter the list of the first dex's blacklist&quot;, message = &quot;a&quot;, order = 2, group = &quot;atlas&quot;)     private Set mainDexBlackList = Sets.newHashSet();      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public boolean isFastMultiDex() {         return fastMultiDex;     }      public void setFastMultiDex(boolean fastMultiDex) {         this.fastMultiDex = fastMultiDex;     }      public Set getMainDexBlackList() {         return mainDexBlackList;     }      public void setMainDexBlackList(Set mainDexBlackList) {         this.mainDexBlackList = mainDexBlackList;     }      public Set getFirstDexClasses() {         return firstDexClasses;     }      public void setFirstDexClasses(Set firstDexClasses) {         this.firstDexClasses = firstDexClasses;     }      public int getDexCount() {         return dexCount;     }      public void setDexCount(int dexCount) {         this.dexCount = dexCount;     }      public String getDexSplitRules() {         return dexSplitRules;     }      public void setDexSplitRules(String dexSplitRules) {         this.dexSplitRules = dexSplitRules;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">1911</td>
    <td align="left">https://github.com/alibaba/atlas/blob/e8c7b3f1ff14b2a1df64321c6992b796cae7d732/atlas-gradle-plugin/atlas-plugin/src/main/java/com/taobao/android/builder/extension/MultiDexConfig.java/#L220-L302</td>
    <td align="right">1</td>
    <td align="right">151</td>
    <td align="right">1911</td>
  </tr>
  <tr valign="top">
    <td align="right">167</td>
    <td align="left">{       &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: &quot;1. Blob&quot;,     &quot;code smells&quot;: [           &quot;Blob&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class AtlasPerfTracer {     protected final Logger logger;     protected final String tag;     private   final long   startTimeMs;      private static long reportingThresholdMs = 0L;      public static Logger getPerfLogger(String name) {         return LoggerFactory.getLogger(&quot;org.apache.atlas.perf.&quot; + name);     }      public static Logger getPerfLogger(Class cls) {         return AtlasPerfTracer.getPerfLogger(cls.getName());     }      public static boolean isPerfTraceEnabled(Logger logger) {         return logger.isDebugEnabled();     }      public static AtlasPerfTracer getPerfTracer(Logger logger, String tag) {         return new AtlasPerfTracer(logger, tag);     }      public static void log(AtlasPerfTracer tracer) {         if (tracer != null) {             tracer.log();         }     }      private AtlasPerfTracer(Logger logger, String tag) {         this.logger = logger;         this.tag    = tag;         startTimeMs = System.currentTimeMillis();     }      public String getTag() {         return tag;     }      public long getStartTime() {         return startTimeMs;     }      public long getElapsedTime() {         return System.currentTimeMillis() - startTimeMs;     }      public void log() {         long elapsedTime = getElapsedTime();         if (elapsedTime &gt; reportingThresholdMs) {             logger.debug(&quot;PERF|{}|{}&quot;, tag, elapsedTime);         }     } }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">2023</td>
    <td align="left">https://github.com/apache/atlas/blob/af1719a3472d1d436d0fc685fe9f88d8a754ef94/common/src/main/java/org/apache/atlas/utils/AtlasPerfTracer.java/#L27-L80</td>
    <td align="right">1</td>
    <td align="right">167</td>
    <td align="right">2023</td>
  </tr>
  <tr valign="top">
    <td align="right">170</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@APICommand(name = RevokeCertificateCmd.APINAME,         description = &quot;Revokes certificate using configured CA plugin&quot;,         responseObject = SuccessResponse.class,         requestHasSensitiveInfo = true,         responseHasSensitiveInfo = false,         since = &quot;4.11.0&quot;,         authorized = {RoleType.Admin}) public class RevokeCertificateCmd extends BaseAsyncCmd {      public static final String APINAME = &quot;revokeCertificate&quot;;      @Inject     private CAManager caManager;      /////////////////////////////////////////////////////     //////////////// API parameters /////////////////////     /////////////////////////////////////////////////////      @Parameter(name = ApiConstants.SERIAL, type = BaseCmd.CommandType.STRING, required = true, description = &quot;The certificate serial number, as a hex value&quot;)     private String serial;      @Parameter(name = ApiConstants.CN, type = BaseCmd.CommandType.STRING, description = &quot;The certificate CN&quot;)     private String cn;      @Parameter(name = ApiConstants.PROVIDER, type = BaseCmd.CommandType.STRING, description = &quot;Name of the CA service provider, otherwise the default configured provider plugin will be used&quot;)     private String provider;      /////////////////////////////////////////////////////     /////////////////// Accessors ///////////////////////     /////////////////////////////////////////////////////      public BigInteger getSerialBigInteger() {         if (Strings.isNullOrEmpty(serial)) {             throw new ServerApiException(ApiErrorCode.PARAM_ERROR, &quot;Certificate serial cannot be empty&quot;);         }         return new BigInteger(serial, 16);     }      public String getCn() {         return cn;     }      public String getProvider() {         return provider;     }      /////////////////////////////////////////////////////     /////////////// API Implementation///////////////////     /////////////////////////////////////////////////////      @Override     public void execute() {         boolean result = caManager.revokeCertificate(getSerialBigInteger(), getCn(), getProvider());         SuccessResponse response = new SuccessResponse(getCommandName());         response.setSuccess(result);         setResponseObject(response);     }      @Override     public String getCommandName() {         return APINAME.toLowerCase() + BaseCmd.RESPONSE_SUFFIX;     }      @Override     public long getEntityOwnerId() {         return CallContext.current().getCallingAccount().getId();     }      @Override     public String getEventType() {         return EventTypes.EVENT_CA_CERTIFICATE_REVOKE;     }      @Override     public String getEventDescription() {         return &quot;revoking certificate with serial id=&quot; + serial + &quot;, cn=&quot; + cn;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">2035</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/api/src/main/java/org/apache/cloudstack/api/command/admin/ca/RevokeCertificateCmd.java/#L39-L116</td>
    <td align="right">1</td>
    <td align="right">170</td>
    <td align="right">2035</td>
  </tr>
  <tr valign="top">
    <td align="right">193</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
class FloatFilterFunction extends AbstractFloatValue {   private final FloatValue baseExpr;   private final BooleanValue filterExpr;   public static final String name = FilterFunction.name;   private final String exprStr;   private final ExpressionType funcType;      public FloatFilterFunction(FloatValue baseExpr, BooleanValue filterExpr) throws SolrException {     this.baseExpr = baseExpr;     this.filterExpr = filterExpr;     this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);     this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);   }      boolean exists = false;    @Override   public float getFloat() {     float value = baseExpr.getFloat();     exists = baseExpr.exists() &amp;&amp; filterExpr.getBoolean() &amp;&amp; filterExpr.exists();     return value;   }   @Override   public boolean exists() {     return exists;   }      @Override   public String getName() {     return name;   }   @Override   public String getExpressionStr() {     return exprStr;   }   @Override   public ExpressionType getExpressionType() {     return funcType;   } }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">2220</td>
    <td align="left">https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/FilterFunction.java/#L462-L501</td>
    <td align="right">1</td>
    <td align="right">193</td>
    <td align="right">2220</td>
  </tr>
  <tr valign="top">
    <td align="right">205</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;badsmells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class StableValue {      private final T value;     private final Assumption assumption;      public StableValue(T value, String name) {         this.value = value;         this.assumption = Truffle.getRuntime().createAssumption(name);     }      public T getValue() {         return value;     }      public Assumption getAssumption() {         return assumption;     }      @Override     public String toString() {         return &quot;[&quot; + value + &quot;, &quot; + assumption + &quot;]&quot;;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">2299</td>
    <td align="left">https://github.com/oracle/fastr/blob/a1ee49060317621c0c9eceea8ec60040aca59b2d/com.oracle.truffle.r.runtime/src/com/oracle/truffle/r/runtime/StableValue.java/#L28-L50</td>
    <td align="right">1</td>
    <td align="right">205</td>
    <td align="right">2299</td>
  </tr>
  <tr valign="top">
    <td align="right">211</td>
    <td align="left">&nbsp;{&quot;answer&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TextAndButtonSection extends Section {  	public TextAndButtonSection( String labelText, Composite parent, 			boolean isFormStyle ) 	{ 		super( labelText, parent, isFormStyle ); 	}  	protected int width = -1;  	protected boolean fillText = false;  	protected TextPropertyDescriptor textField;  	public void createSection( ) 	{ 		if ( selectList == null ) 			selectList = new ArrayList( ); 		getLabelControl( parent ); 		getTextControl( parent ); 		getButtonControl( parent ); 		getGridPlaceholder( parent ); 	}  	public void layout( ) 	{ 		GridData gd = (GridData) textField.getControl( ).getLayoutData( ); 		if ( getLayoutNum( ) &gt; 0 ) 			gd.horizontalSpan = getLayoutNum( ) - 2 - placeholder; 		else 			gd.horizontalSpan = ( (GridLayout) parent.getLayout( ) ).numColumns 					- 2 					- placeholder; 		if ( width &gt; -1 ) 		{ 			gd.widthHint = width; 			gd.grabExcessHorizontalSpace = false; 		} 		else 			gd.grabExcessHorizontalSpace = fillText;  		gd = (GridData) button.getLayoutData( );  		if ( buttonWidth &gt; -1 ) 		{ 			if ( !isComputeSize ) 				gd.widthHint = Math.max( button.computeSize( -1, -1 ).x, 						buttonWidth ); 			else 				gd.widthHint = button.computeSize( -1, -1 ).x; 		} 	}  	public TextPropertyDescriptor getTextControl( ) 	{ 		return textField; 	}  	protected TextPropertyDescriptor getTextControl( Composite parent ) 	{ 		if ( textField == null ) 		{ 			textField = DescriptorToolkit.createTextPropertyDescriptor( true ); 			if ( getProvider( ) != null ) 				textField.setDescriptorProvider( getProvider( ) ); 			textField.createControl( parent ); 			textField.getControl( ).setLayoutData( new GridData( ) ); 			textField.getControl( ).addDisposeListener( new DisposeListener( ) {  				public void widgetDisposed( DisposeEvent event ) 				{ 					textField = null; 				} 			} ); 		} 		else 		{ 			checkParent( textField.getControl( ), parent ); 		} 		return textField; 	}  	protected Button button;  	public Button getButtonControl( ) 	{ 		return button; 	}  	protected Button getButtonControl( Composite parent ) 	{ 		if ( button == null ) 		{ 			button = FormWidgetFactory.getInstance( ).createButton( parent, 					SWT.PUSH, 					isFormStyle ); 			button.setFont( parent.getFont( ) );  			button.setLayoutData( new GridData( ) ); 			String text = getButtonText( ); 			if ( text != null ) 			{ 				button.setText( text ); 			}  			text = getButtonTooltipText( ); 			if ( text != null ) 			{ 				button.setToolTipText( text ); 			}  			button.addDisposeListener( new DisposeListener( ) {  				public void widgetDisposed( DisposeEvent event ) 				{ 					button = null; 				} 			} );  			if ( !selectList.isEmpty( ) ) 				button.addSelectionListener( (SelectionListener) selectList.get( 0 ) ); 			else 			{ 				SelectionListener listener = new SelectionAdapter( ) {  					public void widgetSelected( SelectionEvent e ) 					{ 						onClickButton( ); 					} 				}; 				selectList.add( listener ); 			}  		} 		else 		{ 			checkParent( button, parent ); 		} 		return button; 	}  	private String buttonText;  	IDescriptorProvider provider;  	public IDescriptorProvider getProvider( ) 	{ 		return provider; 	}  	public void setProvider( IDescriptorProvider provider ) 	{ 		this.provider = provider; 		if ( textField != null ) 			textField.setDescriptorProvider( provider ); 	}  	protected List selectList = new ArrayList( );  	/** 	 * if use this method , you couldn't use the onClickButton method. 	 */ 	public void addSelectionListener( SelectionListener listener ) 	{ 		if ( !selectList.contains( listener ) ) 		{ 			if ( !selectList.isEmpty( ) ) 				removeSelectionListener( (SelectionListener) selectList.get( 0 ) ); 			selectList.add( listener ); 			if ( button != null ) 				button.addSelectionListener( listener ); 		} 	}  	public void removeSelectionListener( SelectionListener listener ) 	{ 		if ( selectList.contains( listener ) ) 		{ 			selectList.remove( listener ); 			if ( button != null ) 				button.removeSelectionListener( listener ); 		} 	}  	protected void onClickButton( ) 	{ 	};  	public void forceFocus( ) 	{ 		textField.getControl( ).forceFocus( ); 	}  	public void setInput( Object input ) 	{ 		textField.setInput( input ); 	}  	public void load( ) 	{ 		if ( textField != null &amp;&amp; !textField.getControl( ).isDisposed( ) ) 			textField.load( ); 		if ( button != null &amp;&amp; !button.isDisposed( ) ) 			button.setEnabled( !isReadOnly( ) ); 	}  	protected int buttonWidth = 60;  	public void setButtonWidth( int buttonWidth ) 	{ 		this.buttonWidth = buttonWidth; 		if ( button != null ) 		{ 			GridData data = new GridData( ); 			data.widthHint = Math.max( button.computeSize( -1, -1 ).x, 					buttonWidth );; 			data.grabExcessHorizontalSpace = false; 			button.setLayoutData( data ); 		} 	}  	protected boolean isComputeSize = false;  	public int getWidth( ) 	{ 		return width; 	}  	public void setWidth( int width ) 	{ 		this.width = width; 	}  	public int getButtonWidth( ) 	{ 		return buttonWidth; 	}  	private String oldValue;  	public void setStringValue( String value ) 	{ 		if ( textField != null ) 		{ 			if ( value == null ) 			{ 				value = &quot;&quot;;//$NON-NLS-1$ 			} 			oldValue = textField.getText( ); 			if ( !oldValue.equals( value ) ) 			{ 				textField.setText( value ); 			} 		} 	}  	public boolean isFillText( ) 	{ 		return fillText; 	}  	public void setFillText( boolean fillText ) 	{ 		this.fillText = fillText; 	}  	public void setHidden( boolean isHidden ) 	{ 		if ( displayLabel != null ) 			WidgetUtil.setExcludeGridData( displayLabel, isHidden ); 		if ( textField != null ) 			textField.setHidden( isHidden ); 		if ( button != null ) 			WidgetUtil.setExcludeGridData( button, isHidden ); 		if ( placeholderLabel != null ) 			WidgetUtil.setExcludeGridData( placeholderLabel, isHidden ); 	}  	public void setVisible( boolean isVisible ) 	{ 		if ( displayLabel != null ) 			displayLabel.setVisible( isVisible ); 		if ( textField != null ) 			textField.setVisible( isVisible ); 		if ( button != null ) 			button.setVisible( isVisible ); 		if ( placeholderLabel != null ) 			placeholderLabel.setVisible( isVisible ); 	}  	private String buttonTooltipText;  	public void setButtonTooltipText( String string ) 	{ 		this.buttonTooltipText = string; 		if ( button != null ) 			button.setText( buttonTooltipText );  	}  	public String getButtonText( ) 	{ 		return buttonText; 	}  	public void setButtonText( String buttonText ) 	{ 		this.buttonText = buttonText; 		if ( button != null ) 			button.setText( buttonText ); 	}  	public String getButtonTooltipText( ) 	{ 		return buttonTooltipText; 	}  	public boolean buttonIsComputeSize( ) 	{ 		return isComputeSize; 	}  	public void setButtonIsComputeSize( boolean isComputeSize ) 	{ 		this.isComputeSize = isComputeSize; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">2314</td>
    <td align="left">https://github.com/eclipse/birt/blob/f89264810347de98702db45386a822aabc0fadbf/UI/org.eclipse.birt.report.designer.ui.views/src/org/eclipse/birt/report/designer/internal/ui/views/attributes/section/TextAndButtonSection.java/#L23-L351</td>
    <td align="right">1</td>
    <td align="right">211</td>
    <td align="right">2314</td>
  </tr>
  <tr valign="top">
    <td align="right">241</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class GangliaServer implements MonitorService {   /*    * The Ganglia protocol specific stuff: the xdr_* methods    * and the sendToGanglia* methods have been shamelessly ripped off    * from Hadoop. All hail the yellow elephant!    */    private static final Logger logger =           LoggerFactory.getLogger(GangliaServer.class);   public static final int BUFFER_SIZE = 1500; // as per libgmond.c   protected byte[] buffer = new byte[BUFFER_SIZE];   protected int offset;   private final List addresses = new ArrayList();   private DatagramSocket socket = null;   private ScheduledExecutorService service =           Executors.newSingleThreadScheduledExecutor();   private List hosts;   protected final GangliaCollector collectorRunnable;   private int pollFrequency = 60;   public static final String DEFAULT_UNITS = &quot;&quot;;   public static final int DEFAULT_TMAX = 60;   public static final int DEFAULT_DMAX = 0;   public static final int DEFAULT_SLOPE = 3;   public static final String GANGLIA_DOUBLE_TYPE = &quot;double&quot;;   private volatile boolean isGanglia3 = false;   private String hostname;   public final String CONF_POLL_FREQUENCY = &quot;pollFrequency&quot;;   public final int DEFAULT_POLL_FREQUENCY = 60;   public final String CONF_HOSTS = &quot;hosts&quot;;   public final String CONF_ISGANGLIA3 = &quot;isGanglia3&quot;;   private static final String GANGLIA_CONTEXT = &quot;flume.&quot;;    public GangliaServer() throws FlumeException {     collectorRunnable = new GangliaCollector();   }    /**    * Puts a string into the buffer by first writing the size of the string as an    * int, followed by the bytes of the string, padded if necessary to a multiple    * of 4.    *    * @param s the string to be written to buffer at offset location    */   protected void xdr_string(String s) {     byte[] bytes = s.getBytes();     int len = bytes.length;     xdr_int(len);     System.arraycopy(bytes, 0, buffer, offset, len);     offset += len;     pad();   }    /**    * Pads the buffer with zero bytes up to the nearest multiple of 4.    */   private void pad() {     int newOffset = ((offset + 3) / 4) * 4;     while (offset &lt; newOffset) {       buffer[offset++] = 0;     }   }    /**    * Puts an integer into the buffer as 4 bytes, big-endian.    */   protected void xdr_int(int i) {     buffer[offset++] = (byte) ((i &gt;&gt; 24) &amp; 0xff);     buffer[offset++] = (byte) ((i &gt;&gt; 16) &amp; 0xff);     buffer[offset++] = (byte) ((i &gt;&gt; 8) &amp; 0xff);     buffer[offset++] = (byte) (i &amp; 0xff);   }    public synchronized void sendToGangliaNodes() {     DatagramPacket packet;     for (SocketAddress addr : addresses) {       try {         packet = new DatagramPacket(buffer, offset, addr);         socket.send(packet);       } catch (Exception ex) {         logger.warn(&quot;Could not send metrics to metrics server: &quot;                 + addr.toString(), ex);       }     }     offset = 0;   }    /**    * Start this server, causing it to poll JMX at the configured frequency.    */   @Override   public void start() {     try {       socket = new DatagramSocket();       hostname = InetAddress.getLocalHost().getHostName();     } catch (SocketException ex) {       logger.error(&quot;Could not create socket for metrics collection.&quot;);       throw new FlumeException(               &quot;Could not create socket for metrics collection.&quot;, ex);     } catch (Exception ex2) {       logger.warn(&quot;Unknown error occured&quot;, ex2);     }     for (HostInfo host : hosts) {       addresses.add(new InetSocketAddress(               host.getHostName(), host.getPortNumber()));     }     collectorRunnable.server = this;     if (service.isShutdown() || service.isTerminated()) {       service = Executors.newSingleThreadScheduledExecutor();     }     service.scheduleWithFixedDelay(collectorRunnable, 0,             pollFrequency, TimeUnit.SECONDS);   }    /**    * Stop this server.    */   @Override   public void stop() {     service.shutdown();      while (!service.isTerminated()) {       try {         logger.warn(&quot;Waiting for ganglia service to stop&quot;);         service.awaitTermination(500, TimeUnit.MILLISECONDS);       } catch (InterruptedException ex) {         logger.warn(&quot;Interrupted while waiting&quot;                 + &quot; for ganglia monitor to shutdown&quot;, ex);         service.shutdownNow();       }     }     addresses.clear();   }    /**    *    * @param pollFrequency Seconds between consecutive JMX polls.    */   public void setPollFrequency(int pollFrequency) {     this.pollFrequency = pollFrequency;   }    /**    *    * @return Seconds between consecutive JMX polls    */   public int getPollFrequency() {     return pollFrequency;   }    /**    *    * @param isGanglia3 When true, ganglia 3 messages will be sent, else Ganglia    * 3.1 formatted messages are sent.    */   public void setIsGanglia3(boolean isGanglia3) {     this.isGanglia3 = isGanglia3;   }    /**    *    * @return True if the server is currently sending ganglia 3 formatted msgs.    * False if the server returns Ganglia 3.1    */   public boolean isGanglia3() {     return this.isGanglia3;   }    protected void createGangliaMessage(String name, String value) {     logger.debug(&quot;Sending ganglia3 formatted message.&quot;             + name + &quot;: &quot; + value);     name = hostname + &quot;.&quot; + name;     xdr_int(0);     String type = &quot;string&quot;;     try {       Float.parseFloat(value);       type = &quot;float&quot;;     } catch (NumberFormatException ex) {       // The param is a string, and so leave the type as is.     }     xdr_string(type); // metric type     xdr_string(name);     xdr_string(value);     xdr_string(DEFAULT_UNITS);     xdr_int(DEFAULT_SLOPE);     xdr_int(DEFAULT_TMAX);     xdr_int(DEFAULT_DMAX);   }    protected void createGangliaMessage31(String name, String value) {     logger.debug(&quot;Sending ganglia 3.1 formatted message: &quot;             + name + &quot;: &quot; + value);     xdr_int(128); // metric_id = metadata_msg     xdr_string(hostname); // hostname     xdr_string(name); // metric name     xdr_int(0); // spoof = False     String type = &quot;string&quot;;     try {       Float.parseFloat(value);       type = &quot;float&quot;;     } catch (NumberFormatException ex) {       // The param is a string, and so leave the type as is.     }     xdr_string(type); // metric type     xdr_string(name); // metric name     xdr_string(DEFAULT_UNITS); // units     xdr_int(DEFAULT_SLOPE); // slope     xdr_int(DEFAULT_TMAX); // tmax, the maximum time between metrics     xdr_int(DEFAULT_DMAX); // dmax, the maximum data value     xdr_int(1); /*Num of the entries in extra_value field for Ganglia 3.1.x*/     xdr_string(&quot;GROUP&quot;); /*Group attribute*/     xdr_string(&quot;flume&quot;); /*Group value*/      this.sendToGangliaNodes();      // Now we send out a message with the actual value.     // Technically, we only need to send out the metadata message once for     // each metric, but I don't want to have to record which metrics we did and     // did not send.     xdr_int(133); // we are sending a string value     xdr_string(hostname); // hostName     xdr_string(name); // metric name     xdr_int(0); // spoof = False     xdr_string(&quot;%s&quot;); // format field     xdr_string(value); // metric value   }    @Override   public void configure(Context context) {     this.pollFrequency = context.getInteger(this.CONF_POLL_FREQUENCY, 60);     String localHosts = context.getString(this.CONF_HOSTS);     if (localHosts == null || localHosts.isEmpty()) {       throw new ConfigurationException(&quot;Hosts list cannot be empty.&quot;);     }     this.hosts = this.getHostsFromString(localHosts);     this.isGanglia3 = context.getBoolean(this.CONF_ISGANGLIA3, false);   }    private List getHostsFromString(String hosts)           throws FlumeException {     List hostInfoList = new ArrayList();     String[] hostsAndPorts = hosts.split(&quot;,&quot;);     int i = 0;     for (String host : hostsAndPorts) {       String[] hostAndPort = host.split(&quot;:&quot;);       if (hostAndPort.length &lt; 2) {         logger.warn(&quot;Invalid ganglia host: &quot;, host);         continue;       }       try {         hostInfoList.add(new HostInfo(&quot;ganglia_host-&quot; + String.valueOf(i),                 hostAndPort[0], Integer.parseInt(hostAndPort[1])));       } catch (Exception e) {         logger.warn(&quot;Invalid ganglia host: &quot; + host, e);         continue;       }     }     if (hostInfoList.isEmpty()) {       throw new FlumeException(&quot;No valid ganglia hosts defined!&quot;);     }     return hostInfoList;   }    /**    * Worker which polls JMX for all mbeans with    * {@link javax.management.ObjectName} within the flume namespace:    * org.apache.flume. All attributes of such beans are sent to the all hosts    * specified by the server that owns it's instance.    *    */   protected class GangliaCollector implements Runnable {      private GangliaServer server;      @Override     public void run() {       try {         Map&gt; metricsMap =                 JMXPollUtil.getAllMBeans();         for (String component : metricsMap.keySet()) {           Map attributeMap = metricsMap.get(component);           for (String attribute : attributeMap.keySet()) {             if (isGanglia3) {               server.createGangliaMessage(GANGLIA_CONTEXT + component + &quot;.&quot;                       + attribute,                       attributeMap.get(attribute));             } else {               server.createGangliaMessage31(GANGLIA_CONTEXT + component + &quot;.&quot;                       + attribute,                       attributeMap.get(attribute));             }             server.sendToGangliaNodes();           }         }       } catch (Throwable t) {         logger.error(&quot;Unexpected error&quot;, t);       }     }   } }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">2643</td>
    <td align="left">https://github.com/apache/flume/blob/7d3396f26dc1541e9d2a540d50d15a15c38acb74/flume-ng-core/src/main/java/org/apache/flume/instrumentation/GangliaServer.java/#L56-L354</td>
    <td align="right">1</td>
    <td align="right">241</td>
    <td align="right">2643</td>
  </tr>
  <tr valign="top">
    <td align="right">243</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class ScanOptions extends CommonOpts {      @Parameter(names = &quot;-s&quot;, description = &quot;Start row (inclusive) of scan&quot;)     private String startRow;      @Parameter(names = &quot;-e&quot;, description = &quot;End row (inclusive) of scan&quot;)     private String endRow;      @Parameter(names = &quot;-c&quot;, description = &quot;Columns of scan in comma separated format: &quot;         + &quot;&lt;[:]{,[:]}&gt; &quot;)     private List columns;      @Parameter(names = &quot;-r&quot;, description = &quot;Exact row to scan&quot;)     private String exactRow;      @Parameter(names = &quot;-p&quot;, description = &quot;Row prefix to scan&quot;)     private String rowPrefix;      @Parameter(names = {&quot;-esc&quot;, &quot;--escape-non-ascii&quot;}, help = true,         description = &quot;Hex encode non ascii bytes&quot;, arity = 1)     public boolean hexEncNonAscii = true;      @Parameter(names = &quot;--raw&quot;, help = true,         description = &quot;Show underlying key/values stored in Accumulo. Interprets the data using Fluo &quot;             + &quot;internal schema, making it easier to comprehend.&quot;)     public boolean scanAccumuloTable = false;      @Parameter(names = &quot;--json&quot;, help = true,         description = &quot;Export key/values stored in Accumulo as JSON file.&quot;)     public boolean exportAsJson = false;      @Parameter(names = &quot;--ntfy&quot;, help = true, description = &quot;Scan active notifications&quot;)     public boolean scanNtfy = false;      public String getStartRow() {       return startRow;     }      public String getEndRow() {       return endRow;     }      public String getExactRow() {       return exactRow;     }      public String getRowPrefix() {       return rowPrefix;     }      public List getColumns() {       if (columns == null) {         return Collections.emptyList();       }       return columns;     }      /**      * Check if the parameters informed can be used together.      */     private void checkScanOptions() {       if (this.scanAccumuloTable &amp;&amp; this.exportAsJson) {         throw new IllegalArgumentException(             &quot;Both \&quot;--raw\&quot; and \&quot;--json\&quot; can not be set together.&quot;);       }        if (this.scanAccumuloTable &amp;&amp; this.scanNtfy) {         throw new IllegalArgumentException(             &quot;Both \&quot;--raw\&quot; and \&quot;--ntfy\&quot; can not be set together.&quot;);       }     }      public ScanUtil.ScanOpts getScanOpts() {       EnumSet flags = EnumSet.noneOf(ScanFlags.class);        ScanUtil.setFlag(flags, help, ScanFlags.HELP);       ScanUtil.setFlag(flags, hexEncNonAscii, ScanFlags.HEX);       ScanUtil.setFlag(flags, scanAccumuloTable, ScanFlags.ACCUMULO);       ScanUtil.setFlag(flags, exportAsJson, ScanFlags.JSON);       ScanUtil.setFlag(flags, scanNtfy, ScanFlags.NTFY);        return new ScanUtil.ScanOpts(startRow, endRow, columns, exactRow, rowPrefix, flags);     }      public static ScanOptions parse(String[] args) {       ScanOptions opts = new ScanOptions();       parse(&quot;fluo scan&quot;, opts, args);       return opts;     }   }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">2648</td>
    <td align="left">https://github.com/apache/fluo/blob/8e06204d4167651e2d3b5219b8c1397644e6ba6e/modules/command/src/main/java/org/apache/fluo/command/FluoScan.java/#L33-L122</td>
    <td align="right">1</td>
    <td align="right">243</td>
    <td align="right">2648</td>
  </tr>
  <tr valign="top">
    <td align="right">284</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@ManagedAttributeValueType public interface AclRule extends ManagedAttributeValue {     String getIdentity();     ObjectType getObjectType();     LegacyOperation getOperation();     Map getAttributes();     RuleOutcome getOutcome(); }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3039</td>
    <td align="left">https://github.com/apache/qpid-broker-j/blob/4c4400b98a5a8493cfb9e5dbb21c97175f433a62/broker-plugins/access-control/src/main/java/org/apache/qpid/server/security/access/plugins/AclRule.java/#L31-L39</td>
    <td align="right">1</td>
    <td align="right">284</td>
    <td align="right">3039</td>
  </tr>
  <tr valign="top">
    <td align="right">304</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement public class Book {      private int id;     private String name;      public Book() {}      public Book(int bookId, String name) {         this.id = bookId;         this.name = name;     }      public int getId() {         return id;     }      public void setId(int id) {         this.id = id;     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3183</td>
    <td align="left">https://github.com/apache/tomee/blob/d21933b313aff812fe5188b57bf572a9ad649148/examples/mp-rest-client/src/main/java/org/superbiz/rest/Book.java/#L22-L50</td>
    <td align="right">1</td>
    <td align="right">304</td>
    <td align="right">3183</td>
  </tr>
  <tr valign="top">
    <td align="right">305</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are:&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public class TypeRefWithoutModifiersElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.n4js.ts.TypeExpressions.TypeRefWithoutModifiers&quot;); 		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1); 		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0); 		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0); 		private final RuleCall cParameterizedTypeRefParserRuleCall_0_0_0 = (RuleCall)cAlternatives_0_0.eContents().get(0); 		private final RuleCall cThisTypeRefParserRuleCall_0_0_1 = (RuleCall)cAlternatives_0_0.eContents().get(1); 		private final Assignment cDynamicAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1); 		private final Keyword cDynamicPlusSignKeyword_0_1_0 = (Keyword)cDynamicAssignment_0_1.eContents().get(0); 		private final RuleCall cTypeTypeRefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1); 		private final RuleCall cFunctionTypeExpressionOLDParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2); 		private final RuleCall cUnionTypeExpressionOLDParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3); 		private final RuleCall cIntersectionTypeExpressionOLDParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4); 		 		//TypeRefWithoutModifiers StaticBaseTypeRef: 		//	(ParameterizedTypeRef | ThisTypeRef) =&gt; dynamic?='+'? | TypeTypeRef 		//	| FunctionTypeExpressionOLD 		//	| UnionTypeExpressionOLD 		//	| IntersectionTypeExpressionOLD; 		@Override public ParserRule getRule() { return rule; } 		 		//(ParameterizedTypeRef | ThisTypeRef) =&gt; dynamic?='+'? | TypeTypeRef | FunctionTypeExpressionOLD | UnionTypeExpressionOLD 		//| IntersectionTypeExpressionOLD 		public Alternatives getAlternatives() { return cAlternatives; } 		 		//(ParameterizedTypeRef | ThisTypeRef) =&gt; dynamic?='+'? 		public Group getGroup_0() { return cGroup_0; } 		 		//ParameterizedTypeRef | ThisTypeRef 		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; } 		 		//ParameterizedTypeRef 		public RuleCall getParameterizedTypeRefParserRuleCall_0_0_0() { return cParameterizedTypeRefParserRuleCall_0_0_0; } 		 		//ThisTypeRef 		public RuleCall getThisTypeRefParserRuleCall_0_0_1() { return cThisTypeRefParserRuleCall_0_0_1; } 		 		//=&gt; dynamic?='+'? 		public Assignment getDynamicAssignment_0_1() { return cDynamicAssignment_0_1; } 		 		//'+' 		public Keyword getDynamicPlusSignKeyword_0_1_0() { return cDynamicPlusSignKeyword_0_1_0; } 		 		//TypeTypeRef 		public RuleCall getTypeTypeRefParserRuleCall_1() { return cTypeTypeRefParserRuleCall_1; } 		 		//FunctionTypeExpressionOLD 		public RuleCall getFunctionTypeExpressionOLDParserRuleCall_2() { return cFunctionTypeExpressionOLDParserRuleCall_2; } 		 		//UnionTypeExpressionOLD 		public RuleCall getUnionTypeExpressionOLDParserRuleCall_3() { return cUnionTypeExpressionOLDParserRuleCall_3; } 		 		//IntersectionTypeExpressionOLD 		public RuleCall getIntersectionTypeExpressionOLDParserRuleCall_4() { return cIntersectionTypeExpressionOLDParserRuleCall_4; } 	}</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">3185</td>
    <td align="left">https://github.com/eclipse/n4js/blob/f715912fce0352ab574ff878086f77d17a78c908/plugins/org.eclipse.n4js.ts/src-gen/org/eclipse/n4js/ts/services/TypeExpressionsGrammarAccess.java/#L201-L255</td>
    <td align="right">1</td>
    <td align="right">305</td>
    <td align="right">3185</td>
  </tr>
  <tr valign="top">
    <td align="right">309</td>
    <td align="left">{&quot;message&quot;: &quot;YES, I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static void m() {     C c = new C();     E1 e1 = new E1();     E2 e2 = new E2();     c.foo(e1,e2.getClass());   }</td>
    <td align="left">long method</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3204</td>
    <td align="left">https://github.com/eclipse/org.aspectj/blob/370f291c359cd159c5f3f0abd6e9e53e81234a07/tests/bugs1611/pr336880/Second.java/#L4-L9</td>
    <td align="right">1</td>
    <td align="right">309</td>
    <td align="right">3204</td>
  </tr>
  <tr valign="top">
    <td align="right">311</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Blob&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public List getTraceback() {     return traceback;   }</td>
    <td align="left">feature envy</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">3207</td>
    <td align="left">https://github.com/apache/zeppelin/blob/4219d552349f8f7f3e6de34505b8a8ae9835f98b/zeppelin-jupyter/src/main/java/org/apache/zeppelin/jupyter/nbformat/Error.java/#L48-L50</td>
    <td align="right">1</td>
    <td align="right">311</td>
    <td align="right">3207</td>
  </tr>
  <tr valign="top">
    <td align="right">328</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;1. Blob&quot;, &quot;2. Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Config {      public String mysqlAddr;     public Integer mysqlPort;     public String mysqlUsername;     public String mysqlPassword;      public String mqNamesrvAddr;     public String mqTopic;      public String startType = &quot;DEFAULT&quot;;     public String binlogFilename;     public Long nextPosition;     public Integer maxTransactionRows = 100;      public void load() throws IOException {          InputStream in = Config.class.getClassLoader().getResourceAsStream(&quot;rocketmq_mysql.conf&quot;);         Properties properties = new Properties();         properties.load(in);          properties2Object(properties, this);      }      private void properties2Object(final Properties p, final Object object) {         Method[] methods = object.getClass().getMethods();         for (Method method : methods) {             String mn = method.getName();             if (mn.startsWith(&quot;set&quot;)) {                 try {                     String tmp = mn.substring(4);                     String first = mn.substring(3, 4);                      String key = first.toLowerCase() + tmp;                     String property = p.getProperty(key);                     if (property != null) {                         Class[] pt = method.getParameterTypes();                         if (pt != null &amp;&amp; pt.length &gt; 0) {                             String cn = pt[0].getSimpleName();                             Object arg;                             if (cn.equals(&quot;int&quot;) || cn.equals(&quot;Integer&quot;)) {                                 arg = Integer.parseInt(property);                             } else if (cn.equals(&quot;long&quot;) || cn.equals(&quot;Long&quot;)) {                                 arg = Long.parseLong(property);                             } else if (cn.equals(&quot;double&quot;) || cn.equals(&quot;Double&quot;)) {                                 arg = Double.parseDouble(property);                             } else if (cn.equals(&quot;boolean&quot;) || cn.equals(&quot;Boolean&quot;)) {                                 arg = Boolean.parseBoolean(property);                             } else if (cn.equals(&quot;float&quot;) || cn.equals(&quot;Float&quot;)) {                                 arg = Float.parseFloat(property);                             } else if (cn.equals(&quot;String&quot;)) {                                 arg = property;                             } else {                                 continue;                             }                             method.invoke(object, arg);                         }                     }                 } catch (Throwable ignored) {                 }             }         }     }      public void setMysqlAddr(String mysqlAddr) {         this.mysqlAddr = mysqlAddr;     }      public void setMysqlPort(Integer mysqlPort) {         this.mysqlPort = mysqlPort;     }      public void setMysqlUsername(String mysqlUsername) {         this.mysqlUsername = mysqlUsername;     }      public void setMysqlPassword(String mysqlPassword) {         this.mysqlPassword = mysqlPassword;     }      public void setBinlogFilename(String binlogFilename) {         this.binlogFilename = binlogFilename;     }      public void setNextPosition(Long nextPosition) {         this.nextPosition = nextPosition;     }      public void setMaxTransactionRows(Integer maxTransactionRows) {         this.maxTransactionRows = maxTransactionRows;     }      public void setMqNamesrvAddr(String mqNamesrvAddr) {         this.mqNamesrvAddr = mqNamesrvAddr;     }      public void setMqTopic(String mqTopic) {         this.mqTopic = mqTopic;     }      public void setStartType(String startType) {         this.startType = startType;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">3385</td>
    <td align="left">https://github.com/apache/rocketmq-externals/blob/dba6eb0c997d5c325f26b3d1da9d739d927228dc/rocketmq-mysql/src/main/java/org/apache/rocketmq/mysql/Config.java/#L26-L130</td>
    <td align="right">1</td>
    <td align="right">328</td>
    <td align="right">3385</td>
  </tr>
  <tr valign="top">
    <td align="right">338</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class BasicBundleInfo {      private String pkgName;      /**      * The main dex depends on + the md5 that is currently dependent      */     private String unique_tag;      private String applicationName;      private String version;       public Boolean getIsMBundle() {         return isMBundle;     }      public void setIsMBundle(boolean mainBundle) {         isMBundle = mainBundle;     }      private Boolean isMBundle = false;      private List dependency = Lists.newArrayList();      private List activities = Lists.newArrayList();      private List services = Lists.newArrayList();      private List receivers = Lists.newArrayList();      private List contentProviders = Lists.newArrayList();      private HashMap remoteFragments= new HashMap();      private HashMap remoteViews = new HashMap();      private HashMap remoteTransactors = new HashMap();      private Boolean isInternal = true;      public HashMap getRemoteViews() {         return remoteViews;     }      public void setRemoteViews(HashMap remoteViews) {         this.remoteViews = remoteViews;     }      public HashMap getRemoteTransactors() {         return remoteTransactors;     }      public void setRemoteTransactors(HashMap remoteTransactors) {         this.remoteTransactors = remoteTransactors;     }      public HashMap getRemoteFragments() {         return remoteFragments;     }      public void setRemoteFragments(HashMap remoteFragments) {         this.remoteFragments = remoteFragments;     }      public String getPkgName() {         return pkgName;     }      public void setPkgName(String pkgName) {         this.pkgName = pkgName;     }      public String getApplicationName() {         return applicationName;     }      public void setApplicationName(String applicationName) {         this.applicationName = applicationName;     }      public String getVersion() {         return version;     }      public void setVersion(String version) {         this.version = version;     }      public List getDependency() {         return dependency;     }      public void setDependency(List dependency) {         this.dependency = dependency;     }      public List getActivities() {         return activities;     }      public void setActivities(List activities) {         this.activities = activities;     }      public List getServices() {         return services;     }      public void setServices(List services) {         this.services = services;     }      public List getReceivers() {         return receivers;     }      public void setReceivers(List receivers) {         this.receivers = receivers;     }      public List getContentProviders() {         return contentProviders;     }      public void setContentProviders(List contentProviders) {         this.contentProviders = contentProviders;     }      public boolean getIsInternal() {         return isInternal;     }      public void setIsInternal(boolean internal) {         isInternal = internal;     }      public String getUnique_tag() {         return unique_tag;     }      public void setUnique_tag(String unique_tag) {         this.unique_tag = unique_tag;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">3483</td>
    <td align="left">https://github.com/alibaba/atlas/blob/e8c7b3f1ff14b2a1df64321c6992b796cae7d732/atlas-gradle-plugin/atlas-plugin/src/main/java/com/taobao/android/builder/tools/bundleinfo/model/BasicBundleInfo.java/#L220-L365</td>
    <td align="right">1</td>
    <td align="right">338</td>
    <td align="right">3483</td>
  </tr>
  <tr valign="top">
    <td align="right">343</td>
    <td align="left">{      &quot;output&quot;: &quot;YES I found bad smells the bad smells are: 1. Blob&quot;  }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class NamespaceFilter extends XMLFilterImpl {         private static final InputSource EMPTY_INPUT_SOURCE = new InputSource(new ByteArrayInputStream(new byte[0]));          public NamespaceFilter(XMLReader xmlReader) {             super(xmlReader);         }          public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {             return EMPTY_INPUT_SOURCE;         }     }</td>
    <td align="left">data class</td>
    <td align="left">1. blob  </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. blob  </td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">3503</td>
    <td align="left">https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/container/openejb-jee/src/main/java/org/apache/openejb/jee/sun/JaxbSun.java/#L96-L106</td>
    <td align="right">1</td>
    <td align="right">343</td>
    <td align="right">3503</td>
  </tr>
  <tr valign="top">
    <td align="right">347</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES, I found bad smells&quot;,  &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
   private static byte[] encodeBase64(byte[] binaryData, boolean isChunked)    {       int lengthDataBits = binaryData.length * EIGHTBIT;       int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;       int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP;       byte encodedData[] = null;       int encodedDataLength = 0;       int nbrChunks = 0;        if (fewerThan24bits != 0)       {          //data not divisible by 24 bit          encodedDataLength = (numberTriplets + 1) * 4;       }       else       {          // 16 or 8 bit          encodedDataLength = numberTriplets * 4;       }        // If the output is to be &quot;chunked&quot; into 76 character sections,       // for compliance with RFC 2045 MIME, then it is important to       // allow for extra length to account for the separator(s)       if (isChunked)       {           nbrChunks =                  (CHUNK_SEPARATOR.length == 0                  ? 0                  : (int)Math.ceil((float)encodedDataLength / CHUNK_SIZE));          encodedDataLength += nbrChunks * CHUNK_SEPARATOR.length;       }        encodedData = new byte[encodedDataLength];        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;        int encodedIndex = 0;       int dataIndex = 0;       int i = 0;       int nextSeparatorIndex = CHUNK_SIZE;       int chunksSoFar = 0;        //log.debug(&quot;number of triplets = &quot; + numberTriplets);       for (i = 0; i &lt; numberTriplets; i++)       {          dataIndex = i * 3;          b1 = binaryData[dataIndex];          b2 = binaryData[dataIndex + 1];          b3 = binaryData[dataIndex + 2];           //log.debug(&quot;b1= &quot; + b1 +&quot;, b2= &quot; + b2 + &quot;, b3= &quot; + b3);           l = (byte)(b2 &amp; 0x0f);          k = (byte)(b1 &amp; 0x03);           byte val1 =                  ((b1 &amp; SIGN) == 0)                  ? (byte)(b1 &gt;&gt; 2)                  : (byte)((b1) &gt;&gt; 2 ^ 0xc0);          byte val2 =                  ((b2 &amp; SIGN) == 0)                  ? (byte)(b2 &gt;&gt; 4)                  : (byte)((b2) &gt;&gt; 4 ^ 0xf0);          byte val3 =                  ((b3 &amp; SIGN) == 0)                  ? (byte)(b3 &gt;&gt; 6)                  : (byte)((b3) &gt;&gt; 6 ^ 0xfc);           encodedData[encodedIndex] = lookUpBase64Alphabet[val1];          //log.debug( &quot;val2 = &quot; + val2 );          //log.debug( &quot;k4   = &quot; + (k&lt;&lt;4) );          //log.debug(  &quot;vak  = &quot; + (val2 | (k&lt;&lt;4)) );          encodedData[encodedIndex + 1] =                  lookUpBase64Alphabet[val2 | (k &lt;&lt; 4)];          encodedData[encodedIndex + 2] =                  lookUpBase64Alphabet[(l &lt;&lt; 2) | val3];          encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 &amp; 0x3f];           encodedIndex += 4;           // If we are chunking, let's put a chunk separator down.          if (isChunked)          {             // this assumes that CHUNK_SIZE % 4 == 0             if (encodedIndex == nextSeparatorIndex)             {                System.arraycopy(                        CHUNK_SEPARATOR,                        0,                        encodedData,                        encodedIndex,                        CHUNK_SEPARATOR.length);                chunksSoFar++;                nextSeparatorIndex =                        (CHUNK_SIZE * (chunksSoFar + 1))                        + (chunksSoFar * CHUNK_SEPARATOR.length);                encodedIndex += CHUNK_SEPARATOR.length;             }          }       }        // form integral number of 6-bit groups       dataIndex = i * 3;        if (fewerThan24bits == EIGHTBIT)       {          b1 = binaryData[dataIndex];          k = (byte)(b1 &amp; 0x03);          //log.debug(&quot;b1=&quot; + b1);          //log.debug(&quot;b1&lt;&lt;2 = &quot; + (b1&gt;&gt;2) );          byte val1 =                  ((b1 &amp; SIGN) == 0)                  ? (byte)(b1 &gt;&gt; 2)                  : (byte)((b1) &gt;&gt; 2 ^ 0xc0);          encodedData[encodedIndex] = lookUpBase64Alphabet[val1];          encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k &lt;&lt; 4];          encodedData[encodedIndex + 2] = PAD;          encodedData[encodedIndex + 3] = PAD;       }       else if (fewerThan24bits == SIXTEENBIT)       {           b1 = binaryData[dataIndex];          b2 = binaryData[dataIndex + 1];          l = (byte)(b2 &amp; 0x0f);          k = (byte)(b1 &amp; 0x03);           byte val1 =                  ((b1 &amp; SIGN) == 0)                  ? (byte)(b1 &gt;&gt; 2)                  : (byte)((b1) &gt;&gt; 2 ^ 0xc0);          byte val2 =                  ((b2 &amp; SIGN) == 0)                  ? (byte)(b2 &gt;&gt; 4)                  : (byte)((b2) &gt;&gt; 4 ^ 0xf0);           encodedData[encodedIndex] = lookUpBase64Alphabet[val1];          encodedData[encodedIndex + 1] =                  lookUpBase64Alphabet[val2 | (k &lt;&lt; 4)];          encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l &lt;&lt; 2];          encodedData[encodedIndex + 3] = PAD;       }        if (isChunked)       {          // we also add a separator to the end of the final chunk.          if (chunksSoFar &lt; nbrChunks)          {             System.arraycopy(                     CHUNK_SEPARATOR,                     0,                     encodedData,                     encodedDataLength - CHUNK_SEPARATOR.length,                     CHUNK_SEPARATOR.length);          }       }        return encodedData;    }</td>
    <td align="left">long method</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">long method</td>
    <td align="right">0</td>
    <td align="right">3549</td>
    <td align="left">https://github.com/apache/felix/blob/a132994b250751d4ba3b115ee070ba397d9840ca/mosgi/jmx.agent/src/main/java/org/apache/felix/mosgi/jmx/agent/mx4j/util/Base64Codec.java/#L218-L377</td>
    <td align="right">1</td>
    <td align="right">347</td>
    <td align="right">3549</td>
  </tr>
  <tr valign="top">
    <td align="right">350</td>
    <td align="left">&nbsp;	{ 		&quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [ 			&quot;Blob&quot;,  			&quot;Data Class&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface ClusterServiceArtifactResponse {    @ApiModelProperty(name = ArtifactResourceProvider.RESPONSE_KEY)   @SuppressWarnings(&quot;unused&quot;)   ClusterServiceArtifactResponseInfo getClusterServiceArtifactResponseInfo();    @ApiModelProperty(name = ArtifactResourceProvider.ARTIFACT_DATA_PROPERTY)   Map getArtifactData();    interface ClusterServiceArtifactResponseInfo {     @ApiModelProperty(name = ArtifactResourceProvider.ARTIFACT_NAME)     String getArtifactName();      @ApiModelProperty(name = ArtifactResourceProvider.CLUSTER_NAME)     String getClusterName();      @ApiModelProperty(name = ArtifactResourceProvider.SERVICE_NAME)     String getServiceName();   }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3597</td>
    <td align="left">https://github.com/apache/ambari/blob/2bc4779a1e6aabe638101fc8b0e28cd1963d6b13/ambari-server/src/main/java/org/apache/ambari/server/controller/ClusterServiceArtifactResponse.java/#L32-L52</td>
    <td align="right">1</td>
    <td align="right">350</td>
    <td align="right">3597</td>
  </tr>
  <tr valign="top">
    <td align="right">356</td>
    <td align="left">{   &quot;response&quot;: &quot;YES, I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;Blob&quot;,     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Value public class Release {  	private final String id; 	private final ProjectKey projectKey; 	private final String name; 	private final String description; 	private final LocalDate date; }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3676</td>
    <td align="left">https://github.com/spring-projects/spring-data-dev-tools/blob/a25ff3ae28026f132871f7172c6ba5c3b64e1671/release-tools/src/main/java/org/springframework/data/release/model/Release.java/#L25-L33</td>
    <td align="right">1</td>
    <td align="right">356</td>
    <td align="right">3676</td>
  </tr>
  <tr valign="top">
    <td align="right">367</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class RequireCapability     {         private final String namespace;          private final String filter;          private final String effective;          public RequireCapability ( final String namespace, final String filter, final String effective )         {             this.namespace = namespace;             this.filter = filter;             this.effective = effective;         }          public String getNamespace ()         {             return this.namespace;         }          public String getFilter ()         {             return this.filter;         }          public String getEffective ()         {             return this.effective;         }     }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">3757</td>
    <td align="left">https://github.com/eclipse/packagedrone/blob/3869c1643cdc6f7cb8b26097a7b6994683b13d7e/bundles/org.eclipse.packagedrone.repo.utils.osgi/src/org/eclipse/packagedrone/repo/utils/osgi/bundle/BundleInformation.java/#L377-L406</td>
    <td align="right">1</td>
    <td align="right">367</td>
    <td align="right">3757</td>
  </tr>
  <tr valign="top">
    <td align="right">377</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;,  &quot;bad_smells&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
final class JsonObjects {      private static final Jsonb JSON = JsonbBuilder.create();      private JsonObjects() {     }      static List getColumns(JsonObject jsonObject) {         Map map = JSON.fromJson(jsonObject.toString(), Map.class);         return Columns.of(map);     }  }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">3896</td>
    <td align="left">https://github.com/eclipse/jnosql/blob/9f03fa6ffe2dd4b538f7dbce424649aa4e484657/communication/diana-column/src/main/java/org/jnosql/diana/api/column/query/JsonObjects.java/#L28-L40</td>
    <td align="right">1</td>
    <td align="right">377</td>
    <td align="right">3896</td>
  </tr>
  <tr valign="top">
    <td align="right">411</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{      &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;bad_smells&quot;: [       &quot;Blob&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public ParserRule getCollectionTypeIdentifierRule() { 		return getCollectionTypeIdentifierAccess().getRule(); 	}</td>
    <td align="left">feature envy</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">4212</td>
    <td align="left">https://github.com/eclipse/xtext-eclipse/blob/0c7546b6aaf3644a77fc68eef9f3da368cbbeabd/org.eclipse.xtext.ui.tests/src-gen/org/eclipse/xtext/ui/tests/editor/contentassist/services/BacktrackingContentAssistTestLanguageGrammarAccess.java/#L3702-L3704</td>
    <td align="right">1</td>
    <td align="right">411</td>
    <td align="right">4212</td>
  </tr>
  <tr valign="top">
    <td align="right">432</td>
    <td align="left">&nbsp;{ &quot;answer&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;1. Blob&quot;] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SuppressWarnings(&quot;serial&quot;) public class InvalidStateTransitionException extends Exception {    private Enum currentState;   private Enum event;    public InvalidStateTransitionException(Enum currentState, Enum event) {     super(&quot;Invalid event: &quot; + event + &quot; at &quot; + currentState);     this.currentState = currentState;     this.event = event;   }    public Enum getCurrentState() {     return currentState;   }    public Enum getEvent() {     return event;   }  }</td>
    <td align="left">data class</td>
    <td align="left">1. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">4281</td>
    <td align="left">https://github.com/apache/incubator-ambari/blob/bf747346312170834c6beb89a60c8624b47aa288/ambari-server/src/main/java/org/apache/ambari/server/state/fsm/InvalidStateTransitionException.java/#L25-L45</td>
    <td align="right">1</td>
    <td align="right">432</td>
    <td align="right">4281</td>
  </tr>
  <tr valign="top">
    <td align="right">446</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class Attributes implements AttributeList {     private int _element;     private DOM _document;      public Attributes(DOM document, int element) { 	_element = element; 	_document = document;     }      public int getLength() { 	return 0;     }      public String getName(int i) { 	return null;     }      public String getType(int i) { 	return null;     }      public String getType(String name) { 	return null;     }      public String getValue(int i) { 	return null;     }      public String getValue(String name) { 	return null;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">4357</td>
    <td align="left">https://github.com/apache/xalan-j/blob/cba6d7fe7e93defecb98d155e2a780f8a3f1fbaa/src/org/apache/xalan/xsltc/runtime/Attributes.java/#L31-L63</td>
    <td align="right">1</td>
    <td align="right">446</td>
    <td align="right">4357</td>
  </tr>
  <tr valign="top">
    <td align="right">457</td>
    <td align="left">{&quot;response&quot;: &quot;YES, I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SSLConfigClient extends SSLConfig {    private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(SSLConfigClient.class);    private final Properties properties;   private final boolean userSslEnabled;   private final String trustStoreType;   private final String trustStorePath;   private final String trustStorePassword;   private final boolean disableHostVerification;   private final boolean disableCertificateVerification;   private final boolean useSystemTrustStore;   private final String protocol;   private final int handshakeTimeout;   private final String provider;    private final String emptyString = new String();    public SSLConfigClient(Properties properties) throws DrillException {     this.properties = properties;     userSslEnabled = getBooleanProperty(DrillProperties.ENABLE_TLS);     trustStoreType = getStringProperty(DrillProperties.TRUSTSTORE_TYPE, &quot;JKS&quot;);     trustStorePath = getStringProperty(DrillProperties.TRUSTSTORE_PATH, &quot;&quot;);     trustStorePassword = getStringProperty(DrillProperties.TRUSTSTORE_PASSWORD, &quot;&quot;);     disableHostVerification = getBooleanProperty(DrillProperties.DISABLE_HOST_VERIFICATION);     disableCertificateVerification = getBooleanProperty(DrillProperties.DISABLE_CERT_VERIFICATION);     useSystemTrustStore = getBooleanProperty(DrillProperties.USE_SYSTEM_TRUSTSTORE);     protocol = getStringProperty(DrillProperties.TLS_PROTOCOL, DEFAULT_SSL_PROTOCOL);     int hsTimeout = getIntProperty(DrillProperties.TLS_HANDSHAKE_TIMEOUT, DEFAULT_SSL_HANDSHAKE_TIMEOUT_MS);     if (hsTimeout &lt;= 0) {       hsTimeout = DEFAULT_SSL_HANDSHAKE_TIMEOUT_MS;     }     handshakeTimeout = hsTimeout;     // If provider is OPENSSL then to debug or run this code in an IDE, you will need to enable     // the dependency on netty-tcnative with the correct classifier for the platform you use.     // This can be done by enabling the openssl profile.     // If the IDE is Eclipse, it requires you to install an additional Eclipse plugin available here:     // http://repo1.maven.org/maven2/kr/motd/maven/os-maven-plugin/1.6.1/os-maven-plugin-1.6.1.jar     // or from your local maven repository:     // ~/.m2/repository/kr/motd/maven/os-maven-plugin/1.6.1/os-maven-plugin-1.6.1.jar     // Note that installing this plugin may require you to start with a new workspace     provider = getStringProperty(DrillProperties.TLS_PROVIDER, DEFAULT_SSL_PROVIDER);   }    private boolean getBooleanProperty(String propName) {     return (properties != null) &amp;&amp; (properties.containsKey(propName))         &amp;&amp; (properties.getProperty(propName).compareToIgnoreCase(&quot;true&quot;) == 0);   }    private String getStringProperty(String name, String defaultValue) {     String value = &quot;&quot;;     if ( (properties != null) &amp;&amp; (properties.containsKey(name))) {       value = properties.getProperty(name);     }     if (value.isEmpty()) {       value = defaultValue;     }     value = value.trim();     return value;   }    private int getIntProperty(String name, int defaultValue) {     int value = defaultValue;     if (properties != null) {       String property = properties.getProperty(name);       if (property != null &amp;&amp; property.length() &gt; 0) {         value = Integer.decode(property);       }     }     return value;   }    public void validateKeyStore() throws DrillException {    }    @Override   public SslContext initNettySslContext() throws DrillException {     final SslContext sslCtx;      if (!userSslEnabled) {       return null;     }      TrustManagerFactory tmf;     try {       tmf = initializeTrustManagerFactory();       sslCtx = SslContextBuilder.forClient()           .sslProvider(getProvider())           .trustManager(tmf)           .protocols(protocol)           .build();     } catch (Exception e) {       // Catch any SSL initialization Exceptions here and abort.       throw new DrillException(new StringBuilder()           .append(&quot;SSL is enabled but cannot be initialized due to the following exception: &quot;)           .append(&quot;[ &quot;)           .append(e.getMessage())           .append(&quot;]. &quot;)           .toString());     }     this.nettySslContext = sslCtx;     return sslCtx;   }    @Override   public SSLContext initJDKSSLContext() throws DrillException {     final SSLContext sslCtx;      if (!userSslEnabled) {       return null;     }      TrustManagerFactory tmf;     try {       tmf = initializeTrustManagerFactory();       sslCtx = SSLContext.getInstance(protocol);       sslCtx.init(null, tmf.getTrustManagers(), null);     } catch (Exception e) {       // Catch any SSL initialization Exceptions here and abort.       throw new DrillException(new StringBuilder()           .append(&quot;SSL is enabled but cannot be initialized due to the following exception: &quot;)           .append(&quot;[ &quot;)           .append(e.getMessage())           .append(&quot;]. &quot;)           .toString());     }     this.jdkSSlContext = sslCtx;     return sslCtx;   }    @Override   public SSLEngine createSSLEngine(BufferAllocator allocator, String peerHost, int peerPort) {     SSLEngine engine = super.createSSLEngine(allocator, peerHost, peerPort);      if (!this.disableHostVerification()) {       SSLParameters sslParameters = engine.getSSLParameters();       // only available since Java 7       sslParameters.setEndpointIdentificationAlgorithm(&quot;HTTPS&quot;);       engine.setSSLParameters(sslParameters);     }      engine.setUseClientMode(true);      try {       engine.setEnableSessionCreation(true);     } catch (Exception e) {       // Openssl implementation may throw this.       logger.debug(&quot;Session creation not enabled. Exception: {}&quot;, e.getMessage());     }      return engine;   }    @Override   public boolean isUserSslEnabled() {     return userSslEnabled;   }    @Override   public boolean isHttpsEnabled() {     return false;   }    @Override   public String getKeyStoreType() {     return emptyString;   }    @Override   public String getKeyStorePath() {     return emptyString;   }    @Override   public String getKeyStorePassword() {     return emptyString;   }    @Override   public String getKeyPassword() {     return emptyString;   }    @Override   public String getTrustStoreType() {     return trustStoreType;   }    @Override   public boolean hasTrustStorePath() {     return !trustStorePath.isEmpty();   }    @Override   public String getTrustStorePath() {     return trustStorePath;   }    @Override   public boolean hasTrustStorePassword() {     return !trustStorePassword.isEmpty();   }    @Override   public String getTrustStorePassword() {     return trustStorePassword;   }    @Override   public String getProtocol() {     return protocol;   }    @Override   public SslProvider getProvider() {     return provider.equalsIgnoreCase(&quot;JDK&quot;) ? SslProvider.JDK : SslProvider.OPENSSL;   }    @Override   public int getHandshakeTimeout() {     return handshakeTimeout;   }    @Override   public Mode getMode() {     return Mode.CLIENT;   }    @Override   public boolean disableHostVerification() {     return disableHostVerification;   }    @Override   public boolean disableCertificateVerification() {     return disableCertificateVerification;   }    @Override   public boolean useSystemTrustStore() {     return useSystemTrustStore;   }    public boolean isSslValid() {     return true;   }  }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">4454</td>
    <td align="left">https://github.com/apache/drill/blob/5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3/exec/java-exec/src/main/java/org/apache/drill/exec/ssl/SSLConfigClient.java/#L33-L281</td>
    <td align="right">1</td>
    <td align="right">457</td>
    <td align="right">4454</td>
  </tr>
  <tr valign="top">
    <td align="right">463</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Feature Envy&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class PKWareExtraHeader implements ZipExtraField {      private final ZipShort headerId;     /**      * Extra field data in local file data - without Header-ID or length      * specifier.      */     private byte[] localData;     /**      * Extra field data in central directory - without Header-ID or length      * specifier.      */     private byte[] centralData;      protected PKWareExtraHeader(final ZipShort headerId) {         this.headerId = headerId;     }      /**      * Get the header id.      *      * @return the header id      */     @Override     public ZipShort getHeaderId() {         return headerId;     }      /**      * Set the extra field data in the local file data - without Header-ID or      * length specifier.      *      * @param data      *            the field data to use      */     public void setLocalFileDataData(final byte[] data) {         localData = ZipUtil.copy(data);     }      /**      * Get the length of the local data.      *      * @return the length of the local data      */     @Override     public ZipShort getLocalFileDataLength() {         return new ZipShort(localData != null ? localData.length : 0);     }      /**      * Get the local data.      *      * @return the local data      */     @Override     public byte[] getLocalFileDataData() {         return ZipUtil.copy(localData);     }      /**      * Set the extra field data in central directory.      *      * @param data      *            the data to use      */     public void setCentralDirectoryData(final byte[] data) {         centralData = ZipUtil.copy(data);     }      /**      * Get the central data length. If there is no central data, get the local      * file data length.      *      * @return the central data length      */     @Override     public ZipShort getCentralDirectoryLength() {         if (centralData != null) {             return new ZipShort(centralData.length);         }         return getLocalFileDataLength();     }      /**      * Get the central data.      *      * @return the central data if present, else return the local file data      */     @Override     public byte[] getCentralDirectoryData() {         if (centralData != null) {             return ZipUtil.copy(centralData);         }         return getLocalFileDataData();     }      /**      * @param data      *            the array of bytes.      * @param offset      *            the source location in the data array.      * @param length      *            the number of bytes to use in the data array.      * @see ZipExtraField#parseFromLocalFileData(byte[], int, int)      */     @Override     public void parseFromLocalFileData(final byte[] data, final int offset, final int length) {         final byte[] tmp = new byte[length];         System.arraycopy(data, offset, tmp, 0, length);         setLocalFileDataData(tmp);     }      /**      * @param data      *            the array of bytes.      * @param offset      *            the source location in the data array.      * @param length      *            the number of bytes to use in the data array.      * @see ZipExtraField#parseFromCentralDirectoryData(byte[], int, int)      */     @Override     public void parseFromCentralDirectoryData(final byte[] data, final int offset, final int length) {         final byte[] tmp = new byte[length];         System.arraycopy(data, offset, tmp, 0, length);         setCentralDirectoryData(tmp);         if (localData == null) {             setLocalFileDataData(tmp);         }     }      /**      * Encryption algorithm.      *      * @since 1.11      */     public enum EncryptionAlgorithm {         DES(0x6601),         RC2pre52(0x6602),         TripleDES168(0x6603),         TripleDES192(0x6609),         AES128(0x660E),         AES192(0x660F),         AES256(0x6610),         RC2(0x6702),         RC4(0x6801),         UNKNOWN(0xFFFF);          private final int code;          private static final Map codeToEnum;          static {             final Map cte = new HashMap&lt;&gt;();             for (final EncryptionAlgorithm method : values()) {                 cte.put(method.getCode(), method);             }             codeToEnum = Collections.unmodifiableMap(cte);         }          /**          * private constructor for enum style class.          */         EncryptionAlgorithm(final int code) {             this.code = code;         }          /**          * the algorithm id.          *          * @return the PKWare AlgorithmId          */         public int getCode() {             return code;         }          /**          * Returns the EncryptionAlgorithm for the given code or null if the          * method is not known.          * @param code the code of the algorithm          * @return the EncryptionAlgorithm for the given code or null          * if the method is not known          */         public static EncryptionAlgorithm getAlgorithmByCode(final int code) {             return codeToEnum.get(code);         }     }      /**      * Hash Algorithm      *      * @since 1.11      */     public enum HashAlgorithm {         NONE(0),         CRC32(1),         MD5(0x8003),         SHA1(0x8004),         RIPEND160(0x8007),         SHA256(0x800C),         SHA384(0x800D),         SHA512(0x800E);          private final int code;          private static final Map codeToEnum;          static {             final Map cte = new HashMap&lt;&gt;();             for (final HashAlgorithm method : values()) {                 cte.put(method.getCode(), method);             }             codeToEnum = Collections.unmodifiableMap(cte);         }          /**          * private constructor for enum style class.          */         HashAlgorithm(final int code) {             this.code = code;         }          /**          * the hash algorithm ID.          *          * @return the PKWare hashAlg          */         public int getCode() {             return code;         }          /**          * Returns the HashAlgorithm for the given code or null if the method is          * not known.          * @param code the code of the algorithm          * @return the HashAlgorithm for the given code or null          * if the method is not known          */         public static HashAlgorithm getAlgorithmByCode(final int code) {             return codeToEnum.get(code);         }     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, feature envy</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  feature envy</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">4487</td>
    <td align="left">https://github.com/apache/commons-compress/blob/1881a202fbec4466f3766eaa0057370d7007401b/src/main/java/org/apache/commons/compress/archivers/zip/PKWareExtraHeader.java/#L66-L308</td>
    <td align="right">1</td>
    <td align="right">463</td>
    <td align="right">4487</td>
  </tr>
  <tr valign="top">
    <td align="right">475</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Blob&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    class LastAck {         long lastAckedSequence;         byte priority;          public LastAck(LastAck source) {             this.lastAckedSequence = source.lastAckedSequence;             this.priority = source.priority;         }          public LastAck() {             this.priority = MessageOrderIndex.HI;         }          public LastAck(long ackLocation) {             this.lastAckedSequence = ackLocation;             this.priority = MessageOrderIndex.LO;         }          public LastAck(long ackLocation, byte priority) {             this.lastAckedSequence = ackLocation;             this.priority = priority;         }          @Override         public String toString() {             return &quot;[&quot; + lastAckedSequence + &quot;:&quot; + priority + &quot;]&quot;;         }     }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">4581</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-kahadb-store/src/main/java/org/apache/activemq/store/kahadb/MessageDatabase.java/#L2313-L2340</td>
    <td align="right">1</td>
    <td align="right">475</td>
    <td align="right">4581</td>
  </tr>
  <tr valign="top">
    <td align="right">480</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES, I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             &quot;Long Method&quot;,             &quot;Blob&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    static void registerConfigOptions(IConfigManager configManager) {         AsterixProperties.registerConfigOptions(configManager);         ControllerConfig.Option.DEFAULT_DIR                 .setDefaultValue(FileUtil.joinPath(System.getProperty(ConfigurationUtil.JAVA_IO_TMPDIR), &quot;asterixdb&quot;));         NCConfig.Option.APP_CLASS.setDefaultValue(NCApplication.class.getName());         CCConfig.Option.APP_CLASS.setDefaultValue(CCApplication.class.getName());         try {             InputStream propertyStream =                     ApplicationConfigurator.class.getClassLoader().getResourceAsStream(&quot;git.properties&quot;);             if (propertyStream != null) {                 Properties gitProperties = new Properties();                 gitProperties.load(propertyStream);                 StringWriter sw = new StringWriter();                 gitProperties.store(sw, null);                 configManager.setVersionString(sw.toString());             }         } catch (IOException e) {             throw new IllegalStateException(e);         }      }</td>
    <td align="left">feature envy</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method,  blob</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">4632</td>
    <td align="left">https://github.com/apache/asterixdb/blob/223d13a06c4a4a58408aeac19674ac1f36f5ff35/asterixdb/asterix-app/src/main/java/org/apache/asterix/hyracks/bootstrap/ApplicationConfigurator.java/#L45-L65</td>
    <td align="right">1</td>
    <td align="right">480</td>
    <td align="right">4632</td>
  </tr>
  <tr valign="top">
    <td align="right">489</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Long Method&quot;,             &quot;Blob&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private void appendXmlComparison1(SQLBuffer buf, String op,             FilterValue lhs, FilterValue rhs) {         boolean castrhs = false;         Class rc = Filters.wrap(rhs.getType());         int type = 0;         if (rhs.isConstant()) {             type = getJDBCType(JavaTypes.getTypeCode(rc), false);             castrhs = true;         }          appendXmlExists(buf, lhs);          buf.append(&quot; &quot;).append(op).append(&quot; &quot;);          buf.append(&quot;$&quot;);         if (castrhs)             buf.append(&quot;Parm&quot;);         else             rhs.appendTo(buf);          buf.append(&quot;]' PASSING &quot;);         appendXmlVar(buf, lhs);         buf.append(&quot;, &quot;);          if (castrhs)             appendCast(buf, rhs, type);         else             rhs.appendTo(buf);          buf.append(&quot; AS \&quot;&quot;);         if (castrhs)             buf.append(&quot;Parm&quot;);         else             rhs.appendTo(buf);         buf.append(&quot;\&quot;)&quot;);     }</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">4865</td>
    <td align="left">https://github.com/apache/openjpa/blob/8c0b843f6e6e0dd86a31e485928e61f2ba4c8f29/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java/#L682-L717</td>
    <td align="right">1</td>
    <td align="right">489</td>
    <td align="right">4865</td>
  </tr>
  <tr valign="top">
    <td align="right">508</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@InterfaceAudience.Private @InterfaceStability.Evolving public class BlockMissingException extends IOException {    private static final long serialVersionUID = 1L;    private String filename;   private long   offset;    /**    * An exception that indicates that file was corrupted.    * @param filename name of corrupted file    * @param description a description of the corruption details    */   public BlockMissingException(String filename, String description, long offset) {     super(description);     this.filename = filename;     this.offset = offset;   }    /**    * Returns the name of the corrupted file.    * @return name of corrupted file    */   public String getFile() {     return filename;   }    /**    * Returns the offset at which this file is corrupted    * @return offset of corrupted file    */   public long getOffset() {     return offset;   } }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">5157</td>
    <td align="left">https://github.com/apache/hadoop-hdfs/blob/b2d2a3262c587638db04c2991d48656b3d06275c/src/java/org/apache/hadoop/hdfs/BlockMissingException.java/#L30-L65</td>
    <td align="right">1</td>
    <td align="right">508</td>
    <td align="right">5157</td>
  </tr>
  <tr valign="top">
    <td align="right">566</td>
    <td align="left">&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Blob&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private static class ProxiedNiFiClient implements NiFiClient {          private final String proxiedEntity;         private final NiFiClient wrappedClient;          public ProxiedNiFiClient(final NiFiClient wrappedClient, final String proxiedEntity) {             this.proxiedEntity = proxiedEntity;             this.wrappedClient = wrappedClient;         }          @Override         public ControllerClient getControllerClient() {             return wrappedClient.getControllerClientForProxiedEntities(proxiedEntity);         }          @Override         public ControllerClient getControllerClientForProxiedEntities(String... proxiedEntity) {             return wrappedClient.getControllerClientForProxiedEntities(proxiedEntity);         }          @Override         public ControllerClient getControllerClientForToken(String token) {             return wrappedClient.getControllerClientForToken(token);         }          @Override         public FlowClient getFlowClient() {             return wrappedClient.getFlowClientForProxiedEntities(proxiedEntity);         }          @Override         public FlowClient getFlowClientForProxiedEntities(String... proxiedEntity) {             return wrappedClient.getFlowClientForProxiedEntities(proxiedEntity);         }          @Override         public FlowClient getFlowClientForToken(String token) {             return wrappedClient.getFlowClientForToken(token);         }          @Override         public ProcessGroupClient getProcessGroupClient() {             return wrappedClient.getProcessGroupClientForProxiedEntities(proxiedEntity);         }          @Override         public ProcessGroupClient getProcessGroupClientForProxiedEntities(String... proxiedEntity) {             return wrappedClient.getProcessGroupClientForProxiedEntities(proxiedEntity);         }          @Override         public ProcessGroupClient getProcessGroupClientForToken(String token) {             return wrappedClient.getProcessGroupClientForToken(token);         }          @Override         public VersionsClient getVersionsClient() {             return wrappedClient.getVersionsClientForProxiedEntities(proxiedEntity);         }          @Override         public VersionsClient getVersionsClientForProxiedEntities(String... proxiedEntity) {             return wrappedClient.getVersionsClientForProxiedEntities(proxiedEntity);         }          @Override         public VersionsClient getVersionsClientForToken(String token) {             return wrappedClient.getVersionsClientForToken(token);         }          @Override         public void close() throws IOException {             wrappedClient.close();         }     }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">5719</td>
    <td align="left">https://github.com/apache/nifi/blob/c8eff590efa3babcda0b755009224dcac168708b/nifi-toolkit/nifi-toolkit-cli/src/main/java/org/apache/nifi/toolkit/cli/impl/client/NiFiClientFactory.java/#L113-L187</td>
    <td align="right">1</td>
    <td align="right">566</td>
    <td align="right">5719</td>
  </tr>
  <tr valign="top">
    <td align="right">577</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES, I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Blob&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
        private Action createAction(final ProjectInfo project, final TeamConfiguration team) {             Check.notNull(project, &quot;project&quot;); //$NON-NLS-1$             Check.notNull(team, &quot;team&quot;); //$NON-NLS-1$              final String projectGUID = project.getGUID();              // Omit the team name for the default team             final String actionName = team.isDefaultTeam() ? project.getName()                 : MessageFormat.format(                     Messages.getString(&quot;TeamExplorerControl.ProjectSlashTeamFormat&quot;), //$NON-NLS-1$                     project.getName(),                     team.getTeamName());              final Action action = new Action(actionName) {                 @Override                 public void run() {                     final String beforeChangeProjectGUID = context.getCurrentProjectInfo().getGUID();                     if (!projectGUID.equals(beforeChangeProjectGUID) || !team.equals(context.getCurrentTeam())) {                         context.setCurrentProject(projectGUID);                         context.setCurrentTeam(team);                          TFSCommonUIClientPlugin.getDefault().projectOrTeamChanged();                          // Only invoke this listener if team project changed                         if (!projectGUID.equals(beforeChangeProjectGUID)) {                             final boolean tfvc =                                 context.getCurrentProjectInfo().getSourceControlCapabilityFlags().contains(                                     SourceControlCapabilityFlags.TFS);                             TFSCommonUIClientPlugin.getDefault().sourceControlChanged(tfvc);                         }                     }                 }             };              if (projectGUID.equals(context.getCurrentProjectInfo().getGUID())                 &amp;&amp; team.equals(context.getCurrentTeam())) {                 action.setChecked(true);             }              return action;         }</td>
    <td align="left">long method</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5782</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.client.common.ui/src/com/microsoft/tfs/client/common/ui/controls/teamexplorer/TeamExplorerControl.java/#L607-L647</td>
    <td align="right">1</td>
    <td align="right">577</td>
    <td align="right">5782</td>
  </tr>
  <tr valign="top">
    <td align="right">592</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             &quot;Blob&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public float computeTableUnit(PercentBaseContext percentBaseContext, int contentAreaIPD) {          int sumCols = 0;         float factors = 0;         float unit = 0;          /* calculate the total width (specified absolute/percentages),          * and work out the total number of factors to use to distribute          * the remaining space (if any)          */         for (Object colWidth1 : colWidths) {             Length colWidth = (Length) colWidth1;             if (colWidth != null) {                 sumCols += colWidth.getValue(percentBaseContext);                 if (colWidth instanceof RelativeNumericProperty) {                     factors += ((RelativeNumericProperty) colWidth).getTableUnits();                 } else if (colWidth instanceof TableColLength) {                     factors += ((TableColLength) colWidth).getTableUnits();                 }             }         }          /* distribute the remaining space over the accumulated          * factors (if any)          */         if (factors &gt; 0) {             if (sumCols &lt; contentAreaIPD) {                 unit = (contentAreaIPD - sumCols) / factors;             } else {                 log.warn(&quot;No space remaining to distribute over columns.&quot;);             }         }          return unit;     }</td>
    <td align="left">long method</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">5902</td>
    <td align="left">https://github.com/apache/fop/blob/caced35327f6b6d6eeac2a13543f3c458e902101/fop-core/src/main/java/org/apache/fop/layoutmgr/table/ColumnSetup.java/#L201-L235</td>
    <td align="right">1</td>
    <td align="right">592</td>
    <td align="right">5902</td>
  </tr>
  <tr valign="top">
    <td align="right">611</td>
    <td align="left">&nbsp;{    &quot;response&quot;: &quot;YES I found bad smells&quot;,    &quot;bad smells&quot;: [     &quot;1. Blob&quot;,     &quot;2. Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class ObjectLruCache extends AbstractLruCache {      /** The array of values */     Object[] values = new Object[INITIAL_SIZE];      /**      * Create a new ObjectLruCache.      * @param maxSize the maximum size the cache can grow to      */     public ObjectLruCache(int maxSize) {         super(maxSize);     }      /**      * Overridden method to return values array.      */     Object getValuesArray() {         return values;     }      /**      * Overridden method to allocate new values array.      */     void allocNewValuesArray(int newSize) {         super.allocNewValuesArray(newSize);         values = new Object[newSize];     }      /**      * Overridden method to repopulate with key plus value at given offset.      */     void put(long key, Object oldvalues, int offset) {         Object[] v = (Object[])oldvalues;         put(key, v[offset]);     }      /**      * Returns the value mapped by the given key. Also promotes this key to the most      * recently used.      * @return the value or null if it cannot be found      */     public Object get(long key) {         int index = getIndexAndPromote(key) ;         if (index != -1) {             return values[index];         }         return null;     }      /**      * Add the key/value pair to the map.      */     public void put(long key, Object value) {         int index = putIndexAndPromote(key) ;         values[index] = value;         checkRehash();     } }</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. blob,  2. long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">6133</td>
    <td align="left">https://github.com/eclipse/openj9/blob/4911084853eb75b20e037c434ad4521b7317ebfb/jcl/src/openj9.dtfj/share/classes/com/ibm/dtfj/corereaders/zos/util/ObjectLruCache.java/#L32-L89</td>
    <td align="right">1</td>
    <td align="right">611</td>
    <td align="right">6133</td>
  </tr>
  <tr valign="top">
    <td align="right">612</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Long Method&quot;,       &quot;Blob&quot;     ]   } </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @Override     public void serialize(AGeometry instance, DataOutput out) throws HyracksDataException {         try {             OGCGeometry geometry = instance.getGeometry();             byte[] buffer = geometry.asBinary().array();             // For efficiency, we store the size of the geometry in bytes in the first 32 bits             // This allows AsterixDB to skip over this attribute if needed.             out.writeInt(buffer.length);             out.write(buffer);         } catch (IOException e) {             throw HyracksDataException.create(e);         }     }</td>
    <td align="left">feature envy</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method,  blob</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">6154</td>
    <td align="left">https://github.com/apache/asterixdb/blob/223d13a06c4a4a58408aeac19674ac1f36f5ff35/asterixdb/asterix-om/src/main/java/org/apache/asterix/dataflow/data/nontagged/serde/AGeometrySerializerDeserializer.java/#L63-L75</td>
    <td align="right">1</td>
    <td align="right">612</td>
    <td align="right">6154</td>
  </tr>
  <tr valign="top">
    <td align="right">645</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class JodaDateValidator {    public enum PostgresDateTimeConstant {      // patterns for replacing     POSTGRES_FULL_NAME_OF_DAY(true, &quot;day&quot;),     POSTGRES_DAY_OF_YEAR(false, &quot;ddd&quot;),     POSTGRES_DAY_OF_MONTH(false, &quot;dd&quot;),     POSTGRES_DAY_OF_WEEK(false, &quot;d&quot;),     POSTGRES_NAME_OF_MONTH(true, &quot;month&quot;),     POSTGRES_ABR_NAME_OF_MONTH(true, &quot;mon&quot;),     POSTGRES_YEAR(false, &quot;y&quot;),     POSTGRES_ISO_4YEAR(false, &quot;iyyy&quot;),     POSTGRES_ISO_3YEAR(false, &quot;iyy&quot;),     POSTGRES_ISO_2YEAR(false, &quot;iy&quot;),     POSTGRES_ISO_1YEAR(false, &quot;i&quot;),     POSTGRES_FULL_ERA_NAME(false, &quot;ee&quot;),     POSTGRES_NAME_OF_DAY(true, &quot;dy&quot;),     POSTGRES_HOUR_12_NAME(false, &quot;hh&quot;),     POSTGRES_HOUR_12_OTHER_NAME(false, &quot;hh12&quot;),     POSTGRES_HOUR_24_NAME(false, &quot;hh24&quot;),     POSTGRES_MINUTE_OF_HOUR_NAME(false, &quot;mi&quot;),     POSTGRES_SECOND_OF_MINUTE_NAME(false, &quot;ss&quot;),     POSTGRES_MILLISECOND_OF_MINUTE_NAME(false, &quot;ms&quot;),     POSTGRES_WEEK_OF_YEAR(false, &quot;ww&quot;),     POSTGRES_ISO_WEEK_OF_YEAR(false, &quot;iw&quot;),     POSTGRES_MONTH(false, &quot;mm&quot;),     POSTGRES_HALFDAY_AM(false, &quot;am&quot;),     POSTGRES_HALFDAY_PM(false, &quot;pm&quot;),      // pattern modifiers for deleting     PREFIX_FM(false, &quot;fm&quot;),     PREFIX_FX(false, &quot;fx&quot;),     PREFIX_TM(false, &quot;tm&quot;);      private final boolean hasCamelCasing;     private final String name;      PostgresDateTimeConstant(boolean hasCamelCasing, String name) {       this.hasCamelCasing = hasCamelCasing;       this.name = name;     }      public boolean hasCamelCasing() {       return hasCamelCasing;     }      public String getName() {       return name;     }   }    private static final Map postgresToJodaMap = Maps.newTreeMap(new LengthDescComparator());    public static final String POSTGRES_ESCAPE_CHARACTER = &quot;\&quot;&quot;;    // jodaTime patterns   public static final String JODA_FULL_NAME_OF_DAY = &quot;EEEE&quot;;   public static final String JODA_DAY_OF_YEAR = &quot;D&quot;;   public static final String JODA_DAY_OF_MONTH = &quot;d&quot;;   public static final String JODA_DAY_OF_WEEK = &quot;e&quot;;   public static final String JODA_NAME_OF_MONTH = &quot;MMMM&quot;;   public static final String JODA_ABR_NAME_OF_MONTH = &quot;MMM&quot;;   public static final String JODA_YEAR = &quot;y&quot;;   public static final String JODA_ISO_4YEAR = &quot;xxxx&quot;;   public static final String JODA_ISO_3YEAR = &quot;xxx&quot;;   public static final String JODA_ISO_2YEAR = &quot;xx&quot;;   public static final String JODA_ISO_1YEAR = &quot;x&quot;;   public static final String JODA_FULL_ERA_NAME = &quot;G&quot;;   public static final String JODA_NAME_OF_DAY = &quot;E&quot;;   public static final String JODA_HOUR_12_NAME = &quot;h&quot;;   public static final String JODA_HOUR_24_NAME = &quot;H&quot;;   public static final String JODA_MINUTE_OF_HOUR_NAME = &quot;m&quot;;   public static final String JODA_SECOND_OF_MINUTE_NAME = &quot;ss&quot;;   public static final String JODA_MILLISECOND_OF_MINUTE_NAME = &quot;SSS&quot;;   public static final String JODA_WEEK_OF_YEAR = &quot;w&quot;;   public static final String JODA_MONTH = &quot;MM&quot;;   public static final String JODA_HALFDAY = &quot;aa&quot;;   public static final String JODA_ESCAPE_CHARACTER = &quot;'&quot;;   public static final String EMPTY_STRING = &quot;&quot;;    static {     postgresToJodaMap.put(POSTGRES_FULL_NAME_OF_DAY, JODA_FULL_NAME_OF_DAY);     postgresToJodaMap.put(POSTGRES_DAY_OF_YEAR, JODA_DAY_OF_YEAR);     postgresToJodaMap.put(POSTGRES_DAY_OF_MONTH, JODA_DAY_OF_MONTH);     postgresToJodaMap.put(POSTGRES_DAY_OF_WEEK, JODA_DAY_OF_WEEK);     postgresToJodaMap.put(POSTGRES_NAME_OF_MONTH, JODA_NAME_OF_MONTH);     postgresToJodaMap.put(POSTGRES_ABR_NAME_OF_MONTH, JODA_ABR_NAME_OF_MONTH);     postgresToJodaMap.put(POSTGRES_FULL_ERA_NAME, JODA_FULL_ERA_NAME);     postgresToJodaMap.put(POSTGRES_NAME_OF_DAY, JODA_NAME_OF_DAY);     postgresToJodaMap.put(POSTGRES_HOUR_12_NAME, JODA_HOUR_12_NAME);     postgresToJodaMap.put(POSTGRES_HOUR_12_OTHER_NAME, JODA_HOUR_12_NAME);     postgresToJodaMap.put(POSTGRES_HOUR_24_NAME, JODA_HOUR_24_NAME);     postgresToJodaMap.put(POSTGRES_MINUTE_OF_HOUR_NAME, JODA_MINUTE_OF_HOUR_NAME);     postgresToJodaMap.put(POSTGRES_SECOND_OF_MINUTE_NAME, JODA_SECOND_OF_MINUTE_NAME);     postgresToJodaMap.put(POSTGRES_MILLISECOND_OF_MINUTE_NAME, JODA_MILLISECOND_OF_MINUTE_NAME);     postgresToJodaMap.put(POSTGRES_WEEK_OF_YEAR, JODA_WEEK_OF_YEAR);     postgresToJodaMap.put(POSTGRES_MONTH, JODA_MONTH);     postgresToJodaMap.put(POSTGRES_HALFDAY_AM, JODA_HALFDAY);     postgresToJodaMap.put(POSTGRES_HALFDAY_PM, JODA_HALFDAY);     postgresToJodaMap.put(POSTGRES_ISO_WEEK_OF_YEAR, JODA_WEEK_OF_YEAR);     postgresToJodaMap.put(POSTGRES_YEAR, JODA_YEAR);     postgresToJodaMap.put(POSTGRES_ISO_1YEAR, JODA_ISO_1YEAR);     postgresToJodaMap.put(POSTGRES_ISO_2YEAR, JODA_ISO_2YEAR);     postgresToJodaMap.put(POSTGRES_ISO_3YEAR, JODA_ISO_3YEAR);     postgresToJodaMap.put(POSTGRES_ISO_4YEAR, JODA_ISO_4YEAR);     postgresToJodaMap.put(PREFIX_FM, EMPTY_STRING);     postgresToJodaMap.put(PREFIX_FX, EMPTY_STRING);     postgresToJodaMap.put(PREFIX_TM, EMPTY_STRING);   }    /**    * Replaces all postgres patterns from {@param pattern},    * available in postgresToJodaMap keys to jodaTime equivalents.    *    * @param pattern date pattern in postgres format    * @return date pattern with replaced patterns in joda format    */   public static String toJodaFormat(String pattern) {     // replaces escape character for text delimiter     StringBuilder builder = new StringBuilder(pattern.replaceAll(POSTGRES_ESCAPE_CHARACTER, JODA_ESCAPE_CHARACTER));      int start = 0;    // every time search of postgres token in pattern will start from this index.     int minPos;       // min position of the longest postgres token     do {       // finds first value with max length       minPos = builder.length();       PostgresDateTimeConstant firstMatch = null;       for (PostgresDateTimeConstant postgresPattern : postgresToJodaMap.keySet()) {         // keys sorted in length decreasing         // at first search longer tokens to consider situation where some tokens are the parts of large tokens         // example: if pattern contains a token &quot;DDD&quot;, token &quot;DD&quot; would be skipped, as a part of &quot;DDD&quot;.         int pos;         // some tokens can't be in upper camel casing, so we ignore them here.         // example: DD, DDD, MM, etc.         if (postgresPattern.hasCamelCasing()) {           // finds postgres tokens in upper camel casing           // example: Month, Mon, Day, Dy, etc.           pos = builder.indexOf(StringUtils.capitalize(postgresPattern.getName()), start);           if (pos &gt;= 0 &amp;&amp; pos &lt; minPos) {             firstMatch = postgresPattern;             minPos = pos;             if (minPos == start) {               break;             }           }         }         // finds postgres tokens in lower casing         pos = builder.indexOf(postgresPattern.getName().toLowerCase(), start);         if (pos &gt;= 0 &amp;&amp; pos &lt; minPos) {           firstMatch = postgresPattern;           minPos = pos;           if (minPos == start) {             break;           }         }         // finds postgres tokens in upper casing         pos = builder.indexOf(postgresPattern.getName().toUpperCase(), start);         if (pos &gt;= 0 &amp;&amp; pos &lt; minPos) {           firstMatch = postgresPattern;           minPos = pos;           if (minPos == start) {             break;           }         }       }       // replaces postgres token, if found and it does not escape character       if (minPos &lt; builder.length() &amp;&amp; firstMatch != null) {         String jodaToken = postgresToJodaMap.get(firstMatch);         // checks that token is not a part of escape sequence         if (StringUtils.countMatches(builder.subSequence(0, minPos), JODA_ESCAPE_CHARACTER) % 2 == 0) {           int offset = minPos + firstMatch.getName().length();           builder.replace(minPos, offset, jodaToken);           start = minPos + jodaToken.length();         } else {           int endEscapeCharacter = builder.indexOf(JODA_ESCAPE_CHARACTER, minPos);           if (endEscapeCharacter &gt;= 0) {             start = endEscapeCharacter;           } else {             break;           }         }       }     } while (minPos &lt; builder.length());     return builder.toString();   }    /**    * Length decreasing comparator.    * Compares PostgresDateTimeConstant names by length, if they have the same length, compares them lexicographically.    */   private static class LengthDescComparator implements Comparator {      public int compare(PostgresDateTimeConstant o1, PostgresDateTimeConstant o2) {       int result = o2.getName().length() - o1.getName().length();       if (result == 0) {         return o1.getName().compareTo(o2.getName());       }       return result;     }   }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">6363</td>
    <td align="left">https://github.com/apache/drill/blob/5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3/logical/src/main/java/org/apache/drill/common/expression/fn/JodaDateValidator.java/#L54-L256</td>
    <td align="right">1</td>
    <td align="right">645</td>
    <td align="right">6363</td>
  </tr>
  <tr valign="top">
    <td align="right">654</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Long Method&quot;,       &quot;Blob&quot;     ]   }   </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public void run( IAction action ) 	{ 		if ( !preGenerate( ) ) 		{ 			return; 		}  		IFile file = getSelectedFile( ); 		if ( file != null ) 		{ 			String url = file.getLocation( ).toOSString( );  			Map options = new HashMap( ); 			options.put( WebViewer.RESOURCE_FOLDER_KEY, 					ReportPlugin.getDefault( ) 							.getResourceFolder( file.getProject( ) ) ); 			options.put( WebViewer.SERVLET_NAME_KEY, WebViewer.VIEWER_DOCUMENT );  			Object adapter = ElementAdapterManager.getAdapter( action, 					IPreviewAction.class );  			if ( adapter instanceof IPreviewAction ) 			{ 				IPreviewAction delegate = (IPreviewAction) adapter;  				delegate.setProperty( IPreviewConstants.REPORT_PREVIEW_OPTIONS, 						options ); 				delegate.setProperty( IPreviewConstants.REPORT_FILE_PATH, url );  				delegate.run( );  				return; 			}  			try 			{ 				WebViewer.display( url, options ); 			} 			catch ( Exception e ) 			{ 				ExceptionUtil.handle( e ); 				return; 			} 		} 		else 		{ 			action.setEnabled( false ); 		} 	}</td>
    <td align="left">feature envy</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method,  blob</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">6390</td>
    <td align="left">https://github.com/eclipse/birt/blob/f89264810347de98702db45386a822aabc0fadbf/UI/org.eclipse.birt.report.designer.ui.preview.web/src/org/eclipse/birt/report/designer/ui/ide/navigator/GenerateDocumentAction.java/#L39-L87</td>
    <td align="right">1</td>
    <td align="right">654</td>
    <td align="right">6390</td>
  </tr>
  <tr valign="top">
    <td align="right">659</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DefaultJobMasterServiceFactory implements JobMasterServiceFactory {  	private final JobMasterConfiguration jobMasterConfiguration;  	private final SlotPoolFactory slotPoolFactory;  	private final SchedulerFactory schedulerFactory;  	private final RpcService rpcService;  	private final HighAvailabilityServices haServices;  	private final JobManagerSharedServices jobManagerSharedServices;  	private final HeartbeatServices heartbeatServices;  	private final JobManagerJobMetricGroupFactory jobManagerJobMetricGroupFactory;  	private final FatalErrorHandler fatalErrorHandler;  	public DefaultJobMasterServiceFactory( 			JobMasterConfiguration jobMasterConfiguration, 			SlotPoolFactory slotPoolFactory, 			SchedulerFactory schedulerFactory, 			RpcService rpcService, 			HighAvailabilityServices haServices, 			JobManagerSharedServices jobManagerSharedServices, 			HeartbeatServices heartbeatServices, 			JobManagerJobMetricGroupFactory jobManagerJobMetricGroupFactory, 			FatalErrorHandler fatalErrorHandler) { 		this.jobMasterConfiguration = jobMasterConfiguration; 		this.slotPoolFactory = slotPoolFactory; 		this.schedulerFactory = schedulerFactory; 		this.rpcService = rpcService; 		this.haServices = haServices; 		this.jobManagerSharedServices = jobManagerSharedServices; 		this.heartbeatServices = heartbeatServices; 		this.jobManagerJobMetricGroupFactory = jobManagerJobMetricGroupFactory; 		this.fatalErrorHandler = fatalErrorHandler; 	}  	@Override 	public JobMaster createJobMasterService(JobGraph jobGraph, OnCompletionActions jobCompletionActions, ClassLoader userCodeClassloader) throws Exception { 		return new JobMaster( 			rpcService, 			jobMasterConfiguration, 			ResourceID.generate(), 			jobGraph, 			haServices, 			slotPoolFactory, 			schedulerFactory, 			jobManagerSharedServices, 			heartbeatServices, 			jobManagerJobMetricGroupFactory, 			jobCompletionActions, 			fatalErrorHandler, 			userCodeClassloader); 	} }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6424</td>
    <td align="left">https://github.com/apache/flink/blob/8068c8775ad067d75828e6360e7e0994348da9b9/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/factories/DefaultJobMasterServiceFactory.java/#L37-L95</td>
    <td align="right">1</td>
    <td align="right">659</td>
    <td align="right">6424</td>
  </tr>
  <tr valign="top">
    <td align="right">671</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;output&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Blob&quot;]     }     </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    NativeKeyHolder(P11Key p11Key, long keyID, Session keySession,             boolean extractKeyInfo, boolean isTokenObject) {         this.p11Key = p11Key;         this.keyID = keyID;         this.refCount = -1;         byte[] ki = null;         if (isTokenObject) {             this.ref = null;         } else {             this.ref = new SessionKeyRef(p11Key, keyID, keySession);              // Try extracting key info, if any error, disable it             Token token = p11Key.token;             if (extractKeyInfo) {                 try {                     if (p11Key.sensitive &amp;&amp; nativeKeyWrapperKeyID == 0) {                         synchronized(NativeKeyHolder.class) {                             // Create a global wrapping/unwrapping key                             CK_ATTRIBUTE[] wrappingAttributes = token.getAttributes                                 (O_GENERATE, CKO_SECRET_KEY, CKK_AES, new CK_ATTRIBUTE[] {                                     new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),                                     new CK_ATTRIBUTE(CKA_VALUE_LEN, 256 &gt;&gt; 3),                                 });                             Session wrappingSession = null;                             try {                                 wrappingSession = token.getObjSession();                                 nativeKeyWrapperKeyID = token.p11.C_GenerateKey                                     (wrappingSession.id(),                                     new CK_MECHANISM(CKM_AES_KEY_GEN),                                     wrappingAttributes);                                 byte[] iv = new byte[16];                                 JCAUtil.getSecureRandom().nextBytes(iv);                                 nativeKeyWrapperMechanism = new CK_MECHANISM                                     (CKM_AES_CBC_PAD, iv);                             } catch (PKCS11Exception e) {                                 // best effort                             } finally {                                 token.releaseSession(wrappingSession);                             }                         }                     }                     Session opSession = null;                     try {                         opSession = token.getOpSession();                         ki = p11Key.token.p11.getNativeKeyInfo(opSession.id(),                             keyID, nativeKeyWrapperKeyID, nativeKeyWrapperMechanism);                     } catch (PKCS11Exception e) {                         // best effort                     } finally {                         token.releaseSession(opSession);                     }                 } catch (PKCS11Exception e) {                     // best effort                 }             }         }         this.nativeKeyInfo = ((ki == null || ki.length == 0)? null : ki);     }</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6554</td>
    <td align="left">https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/jdk.crypto.cryptoki/share/classes/sun/security/pkcs11/P11Key.java/#L1154-L1211</td>
    <td align="right">1</td>
    <td align="right">671</td>
    <td align="right">6554</td>
  </tr>
  <tr valign="top">
    <td align="right">676</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;response&quot;: &quot;YES I found bad smells&quot;,         &quot;the bad smells are&quot;: [             &quot;Blob&quot;,             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SchemaAndValue {     private final Schema schema;     private final Object value;      public static final SchemaAndValue NULL = new SchemaAndValue(null, null);      public SchemaAndValue(Schema schema, Object value) {         this.value = value;         this.schema = schema;     }      public Schema schema() {         return schema;     }      public Object value() {         return value;     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (o == null || getClass() != o.getClass()) return false;         SchemaAndValue that = (SchemaAndValue) o;         return Objects.equals(schema, that.schema) &amp;&amp;                 Objects.equals(value, that.value);     }      @Override     public int hashCode() {         return Objects.hash(schema, value);     }      @Override     public String toString() {         return &quot;SchemaAndValue{&quot; +                 &quot;schema=&quot; + schema +                 &quot;, value=&quot; + value +                 '}';     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6576</td>
    <td align="left">https://github.com/apache/kafka/blob/c74acb24eb1da5d16cc2721a63931cd87f79ec66/connect/api/src/main/java/org/apache/kafka/connect/data/SchemaAndValue.java/#L21-L61</td>
    <td align="right">1</td>
    <td align="right">676</td>
    <td align="right">6576</td>
  </tr>
  <tr valign="top">
    <td align="right">685</td>
    <td align="left">&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;1. Blob&quot;,         &quot;2. Long Method&quot;     ] }  </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@UnknownActivationContextCheck(false) @WhitelistAccessOnly @ContentType(&quot;text/html&quot;) @Import(stylesheet = &quot;dashboard.css&quot;) public class T5Dashboard extends AbstractInternalPage {     @Inject     @Symbol(SymbolConstants.TAPESTRY_VERSION)     @Property     private String frameworkVersion;      @Property     @Inject     @Symbol(SymbolConstants.PRODUCTION_MODE)     private boolean productionMode;      @Inject     @Property     private DashboardManager dashboardManager;      @Property     private String tabName;      private String activeTab;      public String getTabClass()     {         return tabName.equalsIgnoreCase(activeTab) ? &quot;active&quot; : null;     }      public Block getContent()     {         return dashboardManager.getTabContent(activeTab);     }      void onActivate()     {         activeTab = dashboardManager.getTabNames().get(0);     }      boolean onActivate(String tabName)     {         activeTab = tabName;          return true;     }      String onPassivate()     {         return activeTab;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. blob,  2. long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">6616</td>
    <td align="left">https://github.com/apache/tapestry-5/blob/542950fc0266e8f9be1aacb5d6ba92146ae20f1b/tapestry-core/src/main/java/org/apache/tapestry5/corelib/pages/T5Dashboard.java/#L27-L78</td>
    <td align="right">1</td>
    <td align="right">685</td>
    <td align="right">6616</td>
  </tr>
  <tr valign="top">
    <td align="right">701</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
            if (!experimentCatalog.isExist(ExperimentCatalogModelType.EXPERIMENT, airavataExperimentId)) {                 logger.error(airavataExperimentId, &quot;Update request failed, Experiment {} doesn't exist.&quot;, airavataExperimentId);                 throw new RegistryServiceException(&quot;Requested experiment id &quot; + airavataExperimentId + &quot; does not exist in the system..&quot;);             }              ExperimentStatus experimentStatus = getExperimentStatusInternal(airavataExperimentId);             if (experimentStatus != null){                 ExperimentState experimentState = experimentStatus.getState();                 switch (experimentState){                     case CREATED: case VALIDATED:                         if(experiment.getUserConfigurationData() != null &amp;&amp; experiment.getUserConfigurationData()                                 .getComputationalResourceScheduling() != null){                             String compResourceId = experiment.getUserConfigurationData()                                     .getComputationalResourceScheduling().getResourceHostId();                             ComputeResourceDescription computeResourceDescription = appCatalog.getComputeResource()                                     .getComputeResource(compResourceId);                             if(!computeResourceDescription.isEnabled()){                                 logger.error(&quot;Compute Resource is not enabled by the Admin!&quot;);                                 AiravataSystemException exception = new AiravataSystemException();                                 exception.setAiravataErrorType(AiravataErrorType.INTERNAL_ERROR);                                 exception.setMessage(&quot;Compute Resource is not enabled by the Admin!&quot;);                                 throw exception;                             }                         }                         experimentCatalog.update(ExperimentCatalogModelType.EXPERIMENT, experiment, airavataExperimentId);                         logger.debug(airavataExperimentId, &quot;Successfully updated experiment {} &quot;, experiment.getExperimentName());                         break;                     default:                         logger.error(airavataExperimentId, &quot;Error while updating experiment. Update experiment is only valid for experiments &quot; +                                 &quot;with status CREATED, VALIDATED, CANCELLED, FAILED and UNKNOWN. Make sure the given &quot; +                                 &quot;experiment is in one of above statuses... &quot;);                         AiravataSystemException exception = new AiravataSystemException();                         exception.setAiravataErrorType(AiravataErrorType.INTERNAL_ERROR);                         exception.setMessage(&quot;Error while updating experiment. Update experiment is only valid for experiments &quot; +                                 &quot;with status CREATED, VALIDATED, CANCELLED, FAILED and UNKNOWN. Make sure the given &quot; +                                 &quot;experiment is in one of above statuses... &quot;);                         throw exception;                 }             }         } catch (RegistryException e) {             logger.error(airavataExperimentId, &quot;Error while updating experiment&quot;, e);             RegistryServiceException exception = new RegistryServiceException();             exception.setMessage(&quot;Error while updating experiment. More info : &quot; + e.getMessage());             throw exception;         } catch (AppCatalogException e) {             logger.error(airavataExperimentId, &quot;Error while updating experiment&quot;, e);             RegistryServiceException exception = new RegistryServiceException();             exception.setMessage(&quot;Error while updating experiment. More info : &quot; + e.getMessage());             throw exception;         }     }      /**      * *      * * Create New Experiment</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6688</td>
    <td align="left">https://github.com/apache/airavata/blob/391843a00eefa7b6213e845f2f044b4e042894d5/modules/registry/registry-server/registry-api-service/src/main/java/org/apache/airavata/registry/api/service/handler/RegistryServerHandler.java/#L3124-L3178</td>
    <td align="right">1</td>
    <td align="right">701</td>
    <td align="right">6688</td>
  </tr>
  <tr valign="top">
    <td align="right">702</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlType(name = &quot;remoteProcessGroup&quot;) public class RemoteProcessGroupDTO extends ComponentDTO {      private String targetUri;     private String targetUris;     private Boolean targetSecure;      private String name;     private String comments;     private String communicationsTimeout;     private String yieldDuration;     private String transportProtocol;     private String localNetworkInterface;     private String proxyHost;     private Integer proxyPort;     private String proxyUser;     private String proxyPassword;      private Collection authorizationIssues;     private Collection validationErrors;     private Boolean transmitting;      private Integer inputPortCount;     private Integer outputPortCount;      private Integer activeRemoteInputPortCount;     private Integer inactiveRemoteInputPortCount;     private Integer activeRemoteOutputPortCount;     private Integer inactiveRemoteOutputPortCount;      private Date flowRefreshed;      private RemoteProcessGroupContentsDTO contents;      public RemoteProcessGroupDTO() {         super();     }      public RemoteProcessGroupDTO(final RemoteProcessGroupDTO toCopy) {         setId(toCopy.getId());         setPosition(toCopy.getPosition());         targetUri = toCopy.getTargetUri();         name = toCopy.getName();     }      public void setTargetUri(final String targetUri) {         this.targetUri = targetUri;     }      /**      * @return target uri of this remote process group.      * If target uri is not set, but uris are set, then returns the first url in the urls.      * If neither target uri nor uris are set, then returns null.      */     @ApiModelProperty(             value = &quot;The target URI of the remote process group.&quot; +                     &quot; If target uri is not set, but uris are set, then returns the first url in the urls.&quot; +                     &quot; If neither target uri nor uris are set, then returns null.&quot;     )     public String getTargetUri() {         if (targetUri == null || targetUri.length() == 0) {             synchronized (this) {                 if (targetUri == null || targetUri.length() == 0) {                     if (targetUris != null &amp;&amp; targetUris.length() &gt; 0) {                         if (targetUris.indexOf(',') &gt; -1) {                             targetUri = targetUris.substring(0, targetUris.indexOf(','));                         } else {                             targetUri = targetUris;                         }                     }                 }             }         }          return this.targetUri;     }      public void setTargetUris(String targetUris) {         this.targetUris = targetUris;     }      /**      * @return target uris of this remote process group      * If targetUris was not set but target uri was set, then returns a collection containing the single uri.      * If neither target uris nor uri were set, then returns null.      */     @ApiModelProperty(             value = &quot;The target URI of the remote process group.&quot; +                     &quot; If target uris is not set but target uri is set,&quot; +                     &quot; then returns a collection containing the single target uri.&quot; +                     &quot; If neither target uris nor uris are set, then returns null.&quot;     )     public String getTargetUris() {         if (targetUris == null || targetUris.length() == 0) {             synchronized (this) {                 if (targetUris == null || targetUris.length() == 0) {                     targetUris = targetUri;                 }             }         }          return this.targetUris;     }      /**      * @param name of this remote process group      */     @ApiModelProperty(             value = &quot;The name of the remote process group.&quot;     )     public void setName(final String name) {         this.name = name;     }      public String getName() {         return this.name;     }      /**      * @return Comments for this remote process group      */     @ApiModelProperty(             value = &quot;The comments for the remote process group.&quot;     )     public String getComments() {         return comments;     }      public void setComments(String comments) {         this.comments = comments;     }      /**      * @return any remote authorization issues for this remote process group      */     @ApiModelProperty(             value = &quot;Any remote authorization issues for the remote process group.&quot;     )     public Collection getAuthorizationIssues() {         return authorizationIssues;     }      public void setAuthorizationIssues(Collection authorizationIssues) {         this.authorizationIssues = authorizationIssues;     }      /**      * @return whether or not this remote process group is actively transmitting      */     @ApiModelProperty(             value = &quot;Whether the remote process group is actively transmitting.&quot;     )     public Boolean isTransmitting() {         return transmitting;     }      public void setTransmitting(Boolean transmitting) {         this.transmitting = transmitting;     }      /**      * @return whether or not the target is running securely      */     @ApiModelProperty(             value = &quot;Whether the target is running securely.&quot;     )     public Boolean isTargetSecure() {         return targetSecure;     }      public void setTargetSecure(Boolean targetSecure) {         this.targetSecure = targetSecure;     }      /**      * @return the time period used for the timeout when communicating with this RemoteProcessGroup      */     @ApiModelProperty(             value = &quot;The time period used for the timeout when communicating with the target.&quot;     )     public String getCommunicationsTimeout() {         return communicationsTimeout;     }      public void setCommunicationsTimeout(String communicationsTimeout) {         this.communicationsTimeout = communicationsTimeout;     }      /**      * @return when yielding, this amount of time must elapse before this remote process group is scheduled again      */     @ApiModelProperty(             value = &quot;When yielding, this amount of time must elapse before the remote process group is scheduled again.&quot;     )     public String getYieldDuration() {         return yieldDuration;     }      public void setYieldDuration(String yieldDuration) {         this.yieldDuration = yieldDuration;     }      /**      * @return number of active remote input ports      */     @ApiModelProperty(             value = &quot;The number of active remote input ports.&quot;     )     public Integer getActiveRemoteInputPortCount() {         return activeRemoteInputPortCount;     }      public void setActiveRemoteInputPortCount(Integer activeRemoteInputPortCount) {         this.activeRemoteInputPortCount = activeRemoteInputPortCount;     }      /**      * @return number of inactive remote input ports      */     @ApiModelProperty(             value = &quot;The number of inactive remote input ports.&quot;     )     public Integer getInactiveRemoteInputPortCount() {         return inactiveRemoteInputPortCount;     }      public void setInactiveRemoteInputPortCount(Integer inactiveRemoteInputPortCount) {         this.inactiveRemoteInputPortCount = inactiveRemoteInputPortCount;     }      /**      * @return number of active remote output ports      */     @ApiModelProperty(             value = &quot;The number of active remote output ports.&quot;     )     public Integer getActiveRemoteOutputPortCount() {         return activeRemoteOutputPortCount;     }      public void setActiveRemoteOutputPortCount(Integer activeRemoteOutputPortCount) {         this.activeRemoteOutputPortCount = activeRemoteOutputPortCount;     }      /**      * @return number of inactive remote output ports      */     @ApiModelProperty(             value = &quot;The number of inactive remote output ports.&quot;     )     public Integer getInactiveRemoteOutputPortCount() {         return inactiveRemoteOutputPortCount;     }      public void setInactiveRemoteOutputPortCount(Integer inactiveRemoteOutputPortCount) {         this.inactiveRemoteOutputPortCount = inactiveRemoteOutputPortCount;     }      /**      * @return number of Remote Input Ports currently available in the remote NiFi instance      */     @ApiModelProperty(             value = &quot;The number of remote input ports currently available on the target.&quot;     )     public Integer getInputPortCount() {         return inputPortCount;     }      public void setInputPortCount(Integer inputPortCount) {         this.inputPortCount = inputPortCount;     }      /**      * @return number of Remote Output Ports currently available in the remote NiFi instance      */     @ApiModelProperty(             value = &quot;The number of remote output ports currently available on the target.&quot;     )     public Integer getOutputPortCount() {         return outputPortCount;     }      public void setOutputPortCount(Integer outputPortCount) {         this.outputPortCount = outputPortCount;     }      /**      * @return contents of this remote process group. Will contain available input/output ports      */     @ApiModelProperty(             value = &quot;The contents of the remote process group. Will contain available input/output ports.&quot;     )     public RemoteProcessGroupContentsDTO getContents() {         return contents;     }      public void setContents(RemoteProcessGroupContentsDTO contents) {         this.contents = contents;     }      /**      * @return the flow for this remote group was last refreshed      */     @XmlJavaTypeAdapter(DateTimeAdapter.class)     @ApiModelProperty(             value = &quot;The timestamp when this remote process group was last refreshed.&quot;,             dataType = &quot;string&quot;     )     public Date getFlowRefreshed() {         return flowRefreshed;     }      public void setFlowRefreshed(Date flowRefreshed) {         this.flowRefreshed = flowRefreshed;     }      public String getTransportProtocol() {         return transportProtocol;     }      public void setTransportProtocol(String transportProtocol) {         this.transportProtocol = transportProtocol;     }      @ApiModelProperty(&quot;The local network interface to send/receive data. If not specified, any local address is used. If clustered, all nodes must have an interface with this identifier.&quot;)     public String getLocalNetworkInterface() {         return localNetworkInterface;     }      public void setLocalNetworkInterface(String localNetworkInterface) {         this.localNetworkInterface = localNetworkInterface;     }      @ApiModelProperty(             &quot;The validation errors for the remote process group. These validation errors represent the problems with the remote process group that must be resolved before it can transmit.&quot;     )     public Collection getValidationErrors() {         return validationErrors;     }      public void setValidationErrors(Collection validationErrors) {         this.validationErrors = validationErrors;     }      public String getProxyHost() {         return proxyHost;     }      public void setProxyHost(String proxyHost) {         this.proxyHost = proxyHost;     }      public Integer getProxyPort() {         return proxyPort;     }      public void setProxyPort(Integer proxyPort) {         this.proxyPort = proxyPort;     }      public String getProxyUser() {         return proxyUser;     }      public void setProxyUser(String proxyUser) {         this.proxyUser = proxyUser;     }      public String getProxyPassword() {         return proxyPassword;     }      public void setProxyPassword(String proxyPassword) {         this.proxyPassword = proxyPassword;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6697</td>
    <td align="left">https://github.com/apache/nifi/blob/c8eff590efa3babcda0b755009224dcac168708b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/RemoteProcessGroupDTO.java/#L30-L405</td>
    <td align="right">1</td>
    <td align="right">702</td>
    <td align="right">6697</td>
  </tr>
  <tr valign="top">
    <td align="right">749</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;answer&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: &quot;the bad smells are: 1. Blob, 2. Data Class&quot;     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;}) public final class None extends Option {     private static final None INSTANCE = new None&lt;&gt;();      /**      * Get the static instance.      * @param  The type of this no-value object.      * @return the static instance      */     public static final  None getInstance() {         return INSTANCE;     }      /**      * Default constructor, does nothing.      */     public None() {         // super(null);         // no-op     }      @Override     public boolean hasValue() {         return false;     }      @Override     public T getValue() {         throw new NoSuchElementException(&quot;None does not contain a value&quot;);     }      @Override     public String toString() {         return &quot;None()&quot;;     }      @Override     public boolean equals(Object other) {         return (other == null || other.getClass() != None.class) ? false : true;     }      @Override     public int hashCode() {         return -31;     }  }</td>
    <td align="left">data class</td>
    <td align="left">the bad smells are: 1. blob, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">the bad smells are: 1. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7022</td>
    <td align="left">https://github.com/apache/pivot/blob/568543f3396648a646341fe077a714eb06d556c0/core/src/org/apache/pivot/functional/monad/None.java/#L24-L70</td>
    <td align="right">1</td>
    <td align="right">749</td>
    <td align="right">7022</td>
  </tr>
  <tr valign="top">
    <td align="right">751</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class JavaTimeSupplementary_es_AR extends OpenListResourceBundle {     @Override     protected final Object[][] getContents() {         final String[] sharedAmPmMarkers = {             &quot;a.m.&quot;,             &quot;p.m.&quot;,         };          final String[] sharedDatePatterns = {             &quot;GGGG y MMMM d, EEEE&quot;,             &quot;GGGG y MMMM d&quot;,             &quot;GGGG y MMM d&quot;,             &quot;dd/MM/yy G&quot;,         };          final String[] sharedDayNarrows = {             &quot;d&quot;,             &quot;l&quot;,             &quot;m&quot;,             &quot;m&quot;,             &quot;j&quot;,             &quot;v&quot;,             &quot;s&quot;,         };          final String[] sharedTimePatterns = {             &quot;HH:mm:ss zzzz&quot;,             &quot;HH:mm:ss z&quot;,             &quot;HH:mm:ss&quot;,             &quot;HH:mm&quot;,         };          final String[] sharedJavaTimeDatePatterns = {             &quot;G y MMMM d, EEEE&quot;,             &quot;G y MMMM d&quot;,             &quot;G y MMM d&quot;,             &quot;dd/MM/yy GGGGG&quot;,         };          return new Object[][] {             { &quot;field.dayperiod&quot;,                 &quot;a.m./p.m.&quot; },             { &quot;islamic.AmPmMarkers&quot;,                 sharedAmPmMarkers },             { &quot;islamic.DatePatterns&quot;,                 sharedDatePatterns },             { &quot;islamic.DayNarrows&quot;,                 sharedDayNarrows },             { &quot;islamic.TimePatterns&quot;,                 sharedTimePatterns },             { &quot;islamic.abbreviated.AmPmMarkers&quot;,                 sharedAmPmMarkers },             { &quot;islamic.narrow.AmPmMarkers&quot;,                 sharedAmPmMarkers },             { &quot;java.time.buddhist.DatePatterns&quot;,                 sharedJavaTimeDatePatterns },             { &quot;java.time.islamic.DatePatterns&quot;,                 sharedJavaTimeDatePatterns },             { &quot;java.time.roc.DatePatterns&quot;,                 sharedJavaTimeDatePatterns },             { &quot;roc.AmPmMarkers&quot;,                 sharedAmPmMarkers },             { &quot;roc.DatePatterns&quot;,                 sharedDatePatterns },             { &quot;roc.DayNarrows&quot;,                 sharedDayNarrows },             { &quot;roc.MonthAbbreviations&quot;,                 new String[] {                     &quot;ene.&quot;,                     &quot;feb.&quot;,                     &quot;mar.&quot;,                     &quot;abr.&quot;,                     &quot;may.&quot;,                     &quot;jun.&quot;,                     &quot;jul.&quot;,                     &quot;ago.&quot;,                     &quot;sep.&quot;,                     &quot;oct.&quot;,                     &quot;nov.&quot;,                     &quot;dic.&quot;,                     &quot;&quot;,                 }             },             { &quot;roc.MonthNarrows&quot;,                 new String[] {                     &quot;e&quot;,                     &quot;f&quot;,                     &quot;m&quot;,                     &quot;a&quot;,                     &quot;m&quot;,                     &quot;j&quot;,                     &quot;j&quot;,                     &quot;a&quot;,                     &quot;s&quot;,                     &quot;o&quot;,                     &quot;n&quot;,                     &quot;d&quot;,                     &quot;&quot;,                 }             },             { &quot;roc.TimePatterns&quot;,                 sharedTimePatterns },             { &quot;roc.abbreviated.AmPmMarkers&quot;,                 sharedAmPmMarkers },             { &quot;roc.narrow.AmPmMarkers&quot;,                 sharedAmPmMarkers },         };     } }</td>
    <td align="left">data class</td>
    <td align="left">long method, blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">long method,  blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7030</td>
    <td align="left">https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/jdk.localedata/share/classes/sun/text/resources/ext/JavaTimeSupplementary_es_AR.java/#L72-L180</td>
    <td align="right">1</td>
    <td align="right">751</td>
    <td align="right">7030</td>
  </tr>
  <tr valign="top">
    <td align="right">755</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Blob&quot;,       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	protected MqttDeliveryToken restoreToken(MqttPublish message) { 		final String methodName = &quot;restoreToken&quot;; 		MqttDeliveryToken token; 		synchronized(tokens) { 			String key = Integer.toString(message.getMessageId()); 			if (this.tokens.containsKey(key)) { 				token = (MqttDeliveryToken)this.tokens.get(key); 				//@TRACE 302=existing key={0} message={1} token={2} 				log.fine(CLASS_NAME,methodName, &quot;302&quot;,new Object[]{key, message,token}); 			} else { 				token = new MqttDeliveryToken(logContext); 				token.internalTok.setKey(key); 				this.tokens.put(key, token); 				//@TRACE 303=creating new token key={0} message={1} token={2} 				log.fine(CLASS_NAME,methodName,&quot;303&quot;,new Object[]{key, message, token}); 			} 		} 		return token; 	}</td>
    <td align="left">long method</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  data class</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7047</td>
    <td align="left">https://github.com/eclipse/paho.mqtt.java/blob/5af7b53499e7dbe45b7227b3d41fc870089c0033/org.eclipse.paho.client.mqttv3/src/main/java/org/eclipse/paho/client/mqttv3/internal/CommsTokenStore.java/#L108-L126</td>
    <td align="right">1</td>
    <td align="right">755</td>
    <td align="right">7047</td>
  </tr>
  <tr valign="top">
    <td align="right">756</td>
    <td align="left">{       &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: &quot;1. Long Method, 2. Data Class, 3. Blob&quot; }  </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @Override     public String getVMPassword(final GetVMPasswordCmd cmd) {         final Account caller = getCaller();          final UserVmVO vm = _userVmDao.findById(cmd.getId());         if (vm == null) {             final InvalidParameterValueException ex = new InvalidParameterValueException(&quot;No VM with specified id found.&quot;);             ex.addProxyObject(cmd.getId().toString(), &quot;vmId&quot;);             throw ex;         }          // make permission check         _accountMgr.checkAccess(caller, null, true, vm);          _userVmDao.loadDetails(vm);         final String password = vm.getDetail(&quot;Encrypted.Password&quot;);         if (password == null || password.equals(&quot;&quot;)) {             final InvalidParameterValueException ex = new InvalidParameterValueException(                     &quot;No password for VM with specified id found. &quot; + &quot;If VM is created from password enabled template and SSH keypair is assigned to VM then only password can be retrieved.&quot;);             ex.addProxyObject(vm.getUuid(), &quot;vmId&quot;);             throw ex;         }          return password;     }</td>
    <td align="left">long method</td>
    <td align="left">1. long method, 2. data class, 3. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;2. data class,  3. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7049</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/server/src/main/java/com/cloud/server/ManagementServerImpl.java/#L3807-L3831</td>
    <td align="right">1</td>
    <td align="right">756</td>
    <td align="right">7049</td>
  </tr>
  <tr valign="top">
    <td align="right">773</td>
    <td align="left">{   &quot;answer&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Blob&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;faces-config-propertyType&quot;, propOrder = {     &quot;descriptions&quot;,     &quot;displayNames&quot;,     &quot;icon&quot;,     &quot;propertyName&quot;,     &quot;propertyClass&quot;,     &quot;defaultValue&quot;,     &quot;suggestedValue&quot;,     &quot;propertyExtension&quot; }) public class FacesProperty {      @XmlTransient     protected TextMap description = new TextMap();     @XmlTransient     protected TextMap displayName = new TextMap();     @XmlElement(name = &quot;icon&quot;, required = true)     protected LocalCollection icon = new LocalCollection();     @XmlElement(name = &quot;property-name&quot;, required = true)     protected java.lang.String propertyName;     @XmlElement(name = &quot;property-class&quot;, required = true)     protected java.lang.String propertyClass;     @XmlElement(name = &quot;default-value&quot;)     protected java.lang.String defaultValue;     @XmlElement(name = &quot;suggested-value&quot;)     protected java.lang.String suggestedValue;     @XmlElement(name = &quot;property-extension&quot;)     protected List propertyExtension;     @XmlAttribute     @XmlJavaTypeAdapter(CollapsedStringAdapter.class)     @XmlID     @XmlSchemaType(name = &quot;ID&quot;)     protected java.lang.String id;      @XmlElement(name = &quot;description&quot;, required = true)     public Text[] getDescriptions() {         return description.toArray();     }      public void setDescriptions(Text[] text) {         description.set(text);     }      public String getDescription() {         return description.get();     }      @XmlElement(name = &quot;display-name&quot;, required = true)     public Text[] getDisplayNames() {         return displayName.toArray();     }      public void setDisplayNames(Text[] text) {         displayName.set(text);     }      public String getDisplayName() {         return displayName.get();     }      public Collection getIcons() {         if (icon == null) {             icon = new LocalCollection();         }         return icon;     }      public Map getIconMap() {         if (icon == null) {             icon = new LocalCollection();         }         return icon.toMap();     }      public Icon getIcon() {         return icon.getLocal();     }      /**      * Gets the value of the propertyName property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getPropertyName() {         return propertyName;     }      /**      * Sets the value of the propertyName property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setPropertyName(java.lang.String value) {         this.propertyName = value;     }      /**      * Gets the value of the propertyClass property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getPropertyClass() {         return propertyClass;     }      /**      * Sets the value of the propertyClass property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setPropertyClass(java.lang.String value) {         this.propertyClass = value;     }      /**      * Gets the value of the defaultValue property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getDefaultValue() {         return defaultValue;     }      /**      * Sets the value of the defaultValue property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setDefaultValue(java.lang.String value) {         this.defaultValue = value;     }      /**      * Gets the value of the suggestedValue property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getSuggestedValue() {         return suggestedValue;     }      /**      * Sets the value of the suggestedValue property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setSuggestedValue(java.lang.String value) {         this.suggestedValue = value;     }      /**      * Gets the value of the propertyExtension property.      *       *       * This accessor method returns a reference to the live list,      * not a snapshot. Therefore any modification you make to the      * returned list will be present inside the JAXB object.      * This is why there is not a set method for the propertyExtension property.      *       *       * For example, to add a new item, do as follows:      *       *    getPropertyExtension().add(newItem);      *       *       *       *       * Objects of the following type(s) are allowed in the list      * {@link FacesPropertyExtension }      *       *       */     public List getPropertyExtension() {         if (propertyExtension == null) {             propertyExtension = new ArrayList();         }         return this.propertyExtension;     }      /**      * Gets the value of the id property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getId() {         return id;     }      /**      * Sets the value of the id property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setId(java.lang.String value) {         this.id = value;     }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">7288</td>
    <td align="left">https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/container/openejb-jee/src/main/java/org/apache/openejb/jee/FacesProperty.java/#L70-L298</td>
    <td align="right">1</td>
    <td align="right">773</td>
    <td align="right">7288</td>
  </tr>
  <tr valign="top">
    <td align="right">780</td>
    <td align="left">&nbsp;	{ 	    &quot;message&quot;: &quot;YES I found bad smells&quot;, 	    &quot;detected_bad_smells&quot;: [ 	        &quot;Long Method&quot;, 	        &quot;Blob&quot; 	    ] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public ClientListenerResponse doHandle(OdbcRequest req) {         if (!busyLock.enterBusy())             return new OdbcResponse(IgniteQueryErrorCode.UNKNOWN,                 &quot;Failed to handle ODBC request because node is stopping: &quot; + req);          if (actx != null)             AuthorizationContext.context(actx);          try {             switch (req.command()) {                 case QRY_EXEC:                     return executeQuery((OdbcQueryExecuteRequest)req);                  case QRY_EXEC_BATCH:                     return executeBatchQuery((OdbcQueryExecuteBatchRequest)req);                  case STREAMING_BATCH:                     return dispatchBatchOrdered((OdbcStreamingBatchRequest)req);                  case QRY_FETCH:                     return fetchQuery((OdbcQueryFetchRequest)req);                  case QRY_CLOSE:                     return closeQuery((OdbcQueryCloseRequest)req);                  case META_COLS:                     return getColumnsMeta((OdbcQueryGetColumnsMetaRequest)req);                  case META_TBLS:                     return getTablesMeta((OdbcQueryGetTablesMetaRequest)req);                  case META_PARAMS:                     return getParamsMeta((OdbcQueryGetParamsMetaRequest)req);                  case MORE_RESULTS:                     return moreResults((OdbcQueryMoreResultsRequest)req);             }              return new OdbcResponse(IgniteQueryErrorCode.UNKNOWN, &quot;Unsupported ODBC request: &quot; + req);         }         finally {             AuthorizationContext.clear();              busyLock.leaveBusy();         }     }</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7455</td>
    <td align="left">https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/core/src/main/java/org/apache/ignite/internal/processors/odbc/odbc/OdbcRequestHandler.java/#L221-L266</td>
    <td align="right">1</td>
    <td align="right">780</td>
    <td align="right">7455</td>
  </tr>
  <tr valign="top">
    <td align="right">788</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;1. Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@DeferredContextBinding public class RoutesHealthCheckRepository implements CamelContextAware, HealthCheckRepository {     private final ConcurrentMap checks;     private Set blacklist;     private List&gt; evaluators;     private ConcurrentMap&gt;&gt; evaluatorMap;     private volatile CamelContext context;      public RoutesHealthCheckRepository() {         this.checks = new ConcurrentHashMap&lt;&gt;();     }      @Override     public void setCamelContext(CamelContext camelContext) {         this.context = camelContext;     }      @Override     public CamelContext getCamelContext() {         return context;     }      public void setBlacklistedRoutes(Collection blacklistedRoutes) {         blacklistedRoutes.forEach(this::addBlacklistedRoute);     }      public void addBlacklistedRoute(String routeId) {         if (this.blacklist == null) {             this.blacklist = new HashSet&lt;&gt;();         }          this.blacklist.add(routeId);     }      public void setEvaluators(Collection&gt; evaluators) {         evaluators.forEach(this::addEvaluator);     }      public void addEvaluator(PerformanceCounterEvaluator evaluator) {         if (this.evaluators == null) {             this.evaluators = new CopyOnWriteArrayList&lt;&gt;();         }          this.evaluators.add(evaluator);     }      public void setRoutesEvaluators(Map&gt;&gt; evaluators) {         evaluators.forEach(this::setRouteEvaluators);     }      public void setRouteEvaluators(String routeId, Collection&gt; evaluators) {         evaluators.forEach(evaluator -&gt; addRouteEvaluator(routeId, evaluator));     }      public void addRouteEvaluator(String routeId, PerformanceCounterEvaluator evaluator) {         if (this.evaluatorMap == null) {             this.evaluatorMap = new ConcurrentHashMap&lt;&gt;();         }          this.evaluatorMap.computeIfAbsent(routeId, id -&gt; new CopyOnWriteArrayList&lt;&gt;()).add(evaluator);     }      public Stream&gt; evaluators() {         return this.evaluators != null             ? this.evaluators.stream()             : Stream.empty();     }      public Stream&gt; evaluators(String routeId) {         return this.evaluatorMap != null             ? evaluatorMap.getOrDefault(routeId, Collections.emptyList()).stream()             : Stream.empty();     }      @Override     public Stream stream() {         // This is not really efficient as getRoutes() creates a copy of the routes         // array for each invocation. It would be nice to have more stream oriented         // operation on CamelContext i.e.         //         // interface CamelContext {         //         //     Stream routes();         //         //     void forEachRoute(Consumer consumer);         // }         //         return this.context != null             ? this.context.getRoutes()                 .stream()                 .filter(route -&gt; route.getId() != null)                 .filter(route -&gt; isNotBlacklisted(route))                 .map(this::toRouteHealthCheck)             : Stream.empty();     }      // *****************************     // Helpers     // *****************************      private boolean isNotBlacklisted(Route route) {         return this.blacklist != null             ? !this.blacklist.contains(route.getId())             : true;     }      private HealthCheck toRouteHealthCheck(Route route) {         return checks.computeIfAbsent(             route,             r -&gt; {                 HealthCheck check = new RouteHealthCheck(                     route,                     evaluatorMap != null                         ? evaluatorMap.getOrDefault(r.getId(), evaluators)                         : evaluators                 );                  check.getConfiguration().setEnabled(true);                  return check;             }         );     } }</td>
    <td align="left">data class</td>
    <td align="left">1. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">7512</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/core/camel-base/src/main/java/org/apache/camel/impl/health/RoutesHealthCheckRepository.java/#L38-L161</td>
    <td align="right">1</td>
    <td align="right">788</td>
    <td align="right">7512</td>
  </tr>
  <tr valign="top">
    <td align="right">789</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES, I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;1. Blob&quot;,       &quot;2. Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class DAOAttachment {         private final AttachmentId attachmentId;         private final BlobId blobId;         private final String type;         private final long size;          private DAOAttachment(AttachmentId attachmentId, BlobId blobId, String type, long size) {             this.attachmentId = attachmentId;             this.blobId = blobId;             this.type = type;             this.size = size;         }          public AttachmentId getAttachmentId() {             return attachmentId;         }          public BlobId getBlobId() {             return blobId;         }          public String getType() {             return type;         }          public long getSize() {             return size;         }          public Attachment toAttachment(byte[] data) {             return Attachment.builder()                 .attachmentId(attachmentId)                 .type(type)                 .bytes(data)                 .build();         }          @Override         public final boolean equals(Object o) {             if (o instanceof DAOAttachment) {                 DAOAttachment that = (DAOAttachment) o;                  return Objects.equals(this.size, that.size)                     &amp;&amp; Objects.equals(this.attachmentId, that.attachmentId)                     &amp;&amp; Objects.equals(this.blobId, that.blobId)                     &amp;&amp; Objects.equals(this.type, that.type);             }             return false;         }          @Override         public final int hashCode() {             return Objects.hash(attachmentId, blobId, type, size);         }     }</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7520</td>
    <td align="left">https://github.com/apache/james-project/blob/fa24a096a5853459c3769a34ccc68feb91626bfa/mailbox/cassandra/src/main/java/org/apache/james/mailbox/cassandra/mail/CassandraAttachmentDAOV2.java/#L50-L104</td>
    <td align="right">1</td>
    <td align="right">789</td>
    <td align="right">7520</td>
  </tr>
  <tr valign="top">
    <td align="right">797</td>
    <td align="left">{   &quot;input&quot;: {     &quot;codeSmells&quot;: [       &quot;Blob&quot;,       &quot;Data Class&quot;,       &quot;Feature Envy&quot;,       &quot;Long Method&quot;     ],     &quot;javaCode&quot;: &quot;// Java code goes here&quot;   },   &quot;output&quot;: {     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detectedCodeSmells&quot;: [       {         &quot;blob&quot;: false,         &quot;dataClass&quot;: false,         &quot;featureEnvy&quot;: true,         &quot;longMethod&quot;: true       }     ]   } }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
</td>
    <td align="left">long method</td>
    <td align="left">message: yes i found bad smells, detectedcodesmells: blob: false, dataclass: false, featureenvy: true, longmethod: true</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">message: yes i found bad smells,  detectedcodesmells: blob: false,  dataclass: false,  featureenvy: true,  longmethod: true</td>
    <td align="left">long method</td>
    <td align="right">0</td>
    <td align="right">7568</td>
    <td align="left">https://github.com/apache/kylin/blob/6ee0212af9d5b50096850c9cb76031b7cdd67402/core-common/src/main/java/org/apache/kylin/common/persistence/JDBCResourceStore.java/#L566-L591</td>
    <td align="right">1</td>
    <td align="right">797</td>
    <td align="right">7568</td>
  </tr>
  <tr valign="top">
    <td align="right">809</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface IContentEmitter {  	String getOutputFormat( );  	void initialize( IEmitterServices service ) throws BirtException;  	void start( IReportContent report ) throws BirtException;  	void end( IReportContent report ) throws BirtException;  	/** 	 * start a page 	 *  	 * @param page 	 */ 	void startPage( IPageContent page ) throws BirtException; 	 	/** 	 * page end 	 *  	 * @param page 	 */ 	void endPage( IPageContent page ) throws BirtException;  	/** 	 * table started 	 *  	 * @param table 	 */ 	void startTable( ITableContent table ) throws BirtException;  	/** 	 * table end 	 */ 	void endTable( ITableContent table ) throws BirtException;  	void startTableBand( ITableBandContent band ) throws BirtException;  	void endTableBand( ITableBandContent band ) throws BirtException;  	void startRow( IRowContent row ) throws BirtException;  	void endRow( IRowContent row ) throws BirtException;  	void startCell( ICellContent cell ) throws BirtException;  	void endCell( ICellContent cell ) throws BirtException; 	 	void startList( IListContent list ) throws BirtException;  	void endList( IListContent list ) throws BirtException;  	void startListBand( IListBandContent listBand ) throws BirtException;  	void endListBand( IListBandContent listBand ) throws BirtException;  	void startContainer( IContainerContent container ) throws BirtException;  	void endContainer( IContainerContent container ) throws BirtException;  	void startText( ITextContent text ) throws BirtException;  	void startData( IDataContent data ) throws BirtException;  	void startLabel( ILabelContent label ) throws BirtException; 	 	void startAutoText ( IAutoTextContent autoText ) throws BirtException;  	void startForeign( IForeignContent foreign ) throws BirtException;  	void startImage( IImageContent image ) throws BirtException;  	void startContent( IContent content ) throws BirtException; 	void endContent( IContent content) throws BirtException; 	 	void startGroup( IGroupContent group ) throws BirtException;  	void endGroup( IGroupContent group ) throws BirtException;  	void startTableGroup( ITableGroupContent group ) throws BirtException;  	void endTableGroup( ITableGroupContent group ) throws BirtException;  	void startListGroup( IListGroupContent group ) throws BirtException;  	void endListGroup( IListGroupContent group ) throws BirtException; }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7647</td>
    <td align="left">https://github.com/eclipse/birt/blob/f89264810347de98702db45386a822aabc0fadbf/engine/org.eclipse.birt.report.engine/src/org/eclipse/birt/report/engine/emitter/IContentEmitter.java/#L39-L126</td>
    <td align="right">1</td>
    <td align="right">809</td>
    <td align="right">7647</td>
  </tr>
  <tr valign="top">
    <td align="right">839</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Long Method&quot;,             &quot;Blob&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @Override     public Object getValue(final String columnLabel, final Class type) throws SQLException {         Object result;         if (Object.class == type) {             result = decrypt(columnLabel, resultSet.getObject(columnLabel));         } else if (boolean.class == type) {             result = decrypt(columnLabel, resultSet.getBoolean(columnLabel));         } else if (byte.class == type) {             result = decrypt(columnLabel, resultSet.getByte(columnLabel));         } else if (short.class == type) {             result = decrypt(columnLabel, resultSet.getShort(columnLabel));         } else if (int.class == type) {             result = decrypt(columnLabel, resultSet.getInt(columnLabel));         } else if (long.class == type) {             result = decrypt(columnLabel, resultSet.getLong(columnLabel));         } else if (float.class == type) {             result = decrypt(columnLabel, resultSet.getFloat(columnLabel));         } else if (double.class == type) {             result = decrypt(columnLabel, resultSet.getDouble(columnLabel));         } else if (String.class == type) {             result = decrypt(columnLabel, resultSet.getString(columnLabel));         } else if (BigDecimal.class == type) {             result = decrypt(columnLabel, resultSet.getBigDecimal(columnLabel));         } else if (byte[].class == type) {             result = resultSet.getBytes(columnLabel);         } else if (Date.class == type) {             result = resultSet.getDate(columnLabel);         } else if (Time.class == type) {             result = resultSet.getTime(columnLabel);         } else if (Timestamp.class == type) {             result = resultSet.getTimestamp(columnLabel);         } else if (URL.class == type) {             result = resultSet.getURL(columnLabel);         } else if (Blob.class == type) {             result = resultSet.getBlob(columnLabel);         } else if (Clob.class == type) {             result = resultSet.getClob(columnLabel);         } else if (SQLXML.class == type) {             result = resultSet.getSQLXML(columnLabel);         } else if (Reader.class == type) {             result = resultSet.getCharacterStream(columnLabel);         } else {             result = decrypt(columnLabel, resultSet.getObject(columnLabel));         }         return result;     }</td>
    <td align="left">feature envy</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method,  blob</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">7778</td>
    <td align="left">https://github.com/apache/incubator-shardingsphere/blob/c5cf1d15b02f3a0fb3bda4f15d5f0b3779eac7ba/sharding-core/sharding-core-execute/src/main/java/org/apache/shardingsphere/core/execute/sql/execute/result/StreamQueryResult.java/#L117-L162</td>
    <td align="right">1</td>
    <td align="right">839</td>
    <td align="right">7778</td>
  </tr>
  <tr valign="top">
    <td align="right">842</td>
    <td align="left">{&quot;answer&quot;:&quot;YES I found bad smells&quot;,&quot;bad smells are&quot;:[&quot;Blob&quot;,&quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class PasswordPolicyDetailsPage implements IDetailsPage {     /** The associated Master Details Block */     private PasswordPoliciesMasterDetailsBlock masterDetailsBlock;      /** The Managed Form */     private IManagedForm mform;      /** The input password policy */     private PasswordPolicyBean passwordPolicy;      // UI Widgets     private Button enabledCheckbox;     private Text idText;     private Text descriptionText;     private ComboViewer checkQualityComboViewer;     private Text validatorText;     private Button minimumLengthCheckbox;     private Text minimumLengthText;     private Button maximumLengthCheckbox;     private Text maximumLengthText;     private Text minimumAgeText;     private Text maximumAgeText;     private Button expireWarningCheckbox;     private Text expireWarningText;     private Button graceAuthenticationLimitCheckbox;     private Text graceAuthenticationLimitText;     private Button graceExpireCheckbox;     private Text graceExpireText;     private Button mustChangeCheckbox;     private Button allowUserChangeCheckbox;     private Button safeModifyCheckbox;     private Button lockoutCheckbox;     private Text lockoutDurationText;     private Text maxFailureText;     private Text failureCountIntervalText;     private Button inHistoryCheckbox;     private Text inHistoryText;     private Button maxIdleCheckbox;     private Text maxIdleText;     private Text minimumDelayText;     private Text maximumDelayText;      // Listeners     /** The Text Modify Listener */     private ModifyListener textModifyListener = new ModifyListener()     {         public void modifyText( ModifyEvent e )         {             commit( true );             masterDetailsBlock.setEditorDirty();         }     };      /** The button Selection Listener */     private SelectionListener buttonSelectionListener = new SelectionAdapter()     {         public void widgetSelected( SelectionEvent e )         {             commit( true );             masterDetailsBlock.setEditorDirty();         }     };      /** The viewer Selection Changed Listener */     private ISelectionChangedListener viewerSelectionChangedListener = new ISelectionChangedListener()     {         public void selectionChanged( SelectionChangedEvent event )         {             commit( true );             masterDetailsBlock.setEditorDirty();         }     };      private VerifyListener integerVerifyListener = new VerifyListener()     {         public void verifyText( VerifyEvent e )         {             if ( !e.text.matches( &quot;[0-9]*&quot; ) ) //$NON-NLS-1$             {                 e.doit = false;             }         }     };      private ISelectionChangedListener checkQualityComboViewerSelectionChangedListener = new ISelectionChangedListener()     {         public void selectionChanged( SelectionChangedEvent event )         {             StructuredSelection selection = ( StructuredSelection ) checkQualityComboViewer.getSelection();              if ( !selection.isEmpty() )             {                 CheckQuality checkQuality = ( CheckQuality ) selection.getFirstElement();                  if ( checkQuality == CheckQuality.DISABLED )                 {                     minimumLengthCheckbox.setEnabled( false );                     minimumLengthText.setEnabled( false );                     maximumLengthCheckbox.setEnabled( false );                     maximumLengthText.setEnabled( false );                 }                 else                 {                     int minimumLength = 0;                     int maximumLength = 0;                      try                     {                         minimumLength = Integer.parseInt( minimumLengthText.getText() );                     }                     catch ( NumberFormatException e )                     {                         // Nothing to do.                     }                      try                     {                         maximumLength = Integer.parseInt( maximumLengthText.getText() );                     }                     catch ( NumberFormatException e )                     {                         // Nothing to do.                     }                      minimumLengthCheckbox.setEnabled( true );                     minimumLengthText.setEnabled( minimumLength != 0 );                     maximumLengthCheckbox.setEnabled( true );                     maximumLengthText.setEnabled( maximumLength != 0 );                 }             }         }     };      private SelectionListener minimumLengthCheckboxSelectionListener = new SelectionAdapter()     {         public void widgetSelected( SelectionEvent e )         {             minimumLengthText.setEnabled( minimumLengthCheckbox.getSelection() );         }     };      private SelectionListener maximumLengthCheckboxSelectionListener = new SelectionAdapter()     {         public void widgetSelected( SelectionEvent e )         {             maximumLengthText.setEnabled( maximumLengthCheckbox.getSelection() );         }     };      private SelectionListener expireWarningCheckboxSelectionListener = new SelectionAdapter()     {         public void widgetSelected( SelectionEvent e )         {             expireWarningText.setEnabled( expireWarningCheckbox.getSelection() );         }     };      private SelectionListener graceAuthenticationLimitCheckboxSelectionListener = new SelectionAdapter()     {         public void widgetSelected( SelectionEvent e )         {             graceAuthenticationLimitText.setEnabled( graceAuthenticationLimitCheckbox.getSelection() );         }     };      private SelectionListener graceExpireCheckboxSelectionListener = new SelectionAdapter()     {         public void widgetSelected( SelectionEvent e )         {             graceExpireText.setEnabled( graceExpireCheckbox.getSelection() );         }     };      private SelectionListener maxIdleCheckboxSelectionListener = new SelectionAdapter()     {         public void widgetSelected( SelectionEvent e )         {             maxIdleText.setEnabled( maxIdleCheckbox.getSelection() );         }     };      private SelectionListener inHistoryCheckboxSelectionListener = new SelectionAdapter()     {         public void widgetSelected( SelectionEvent e )         {             inHistoryText.setEnabled( inHistoryCheckbox.getSelection() );         }     };       /**      * Creates a new instance of PartitionDetailsPage.      *      * @param pmdb      *      the associated Master Details Block      */     public PasswordPolicyDetailsPage( PasswordPoliciesMasterDetailsBlock pmdb )     {         masterDetailsBlock = pmdb;     }       /**      * {@inheritDoc}      */     public void createContents( Composite parent )     {         FormToolkit toolkit = mform.getToolkit();         TableWrapLayout layout = new TableWrapLayout();         layout.topMargin = 5;         layout.leftMargin = 5;         layout.rightMargin = 2;         layout.bottomMargin = 2;         parent.setLayout( layout );          // Depending on if the PP is enabled or disabled, we will         // expose the configuration                  createDetailsSection( toolkit, parent );         createQualitySection( toolkit, parent );         createExpirationSection( toolkit, parent );         createOptionsSection( toolkit, parent );         createLockoutSection( toolkit, parent );     }       /**      * Creates the Details Section      *      * @param parent      *      the parent composite      * @param toolkit      *      the toolkit to use      */     private void createDetailsSection( FormToolkit toolkit, Composite parent )     {         // Creation of the section         Section section = toolkit.createSection( parent, Section.DESCRIPTION | Section.TITLE_BAR );         section.marginWidth = 10;         section.setText( &quot;Password Policy Details&quot; );         section.setDescription( &quot;Set the properties of the password policy.&quot; );         TableWrapData td = new TableWrapData( TableWrapData.FILL, TableWrapData.TOP );         td.grabHorizontal = true;         section.setLayoutData( td );         Composite client = toolkit.createComposite( section );         toolkit.paintBordersFor( client );                  GridLayout glayout = new GridLayout( 2, false );         client.setLayout( glayout );         section.setClient( client );          // Enabled Checkbox         enabledCheckbox = toolkit.createButton( client, &quot;Enabled&quot;, SWT.CHECK );         enabledCheckbox.setLayoutData( new GridData( SWT.FILL, SWT.NONE, true, false, 2, 1 ) );          // ID Text         toolkit.createLabel( client, &quot;ID:&quot; );         idText = toolkit.createText( client, &quot;&quot; );         idText.setLayoutData( new GridData( SWT.FILL, SWT.NONE, true, false ) );          // Description Text         toolkit.createLabel( client, &quot;Description:&quot; );         descriptionText = toolkit.createText( client, &quot;&quot; );         descriptionText.setLayoutData( new GridData( SWT.FILL, SWT.NONE, true, false ) );     }       /**      * Creates the Quality section.      *      * @param toolkit the toolkit to use      * @param parent the parent composite      */     private void createQualitySection( FormToolkit toolkit, Composite parent )     {         // Creation of the section         Section section = toolkit.createSection( parent, Section.TITLE_BAR );         section.marginWidth = 10;         section.setText( &quot;Quality&quot; );         TableWrapData td = new TableWrapData( TableWrapData.FILL, TableWrapData.TOP );         td.grabHorizontal = true;         section.setLayoutData( td );         Composite composite = toolkit.createComposite( section );         toolkit.paintBordersFor( composite );         GridLayout gridLayout = new GridLayout( 2, false );         gridLayout.marginHeight = gridLayout.marginWidth = 0;         composite.setLayout( gridLayout );         section.setClient( composite );          // Check Quality (pwdCheckQuality)         toolkit.createLabel( composite, &quot;Check Quality:&quot; );         checkQualityComboViewer = new ComboViewer( composite );         checkQualityComboViewer.setContentProvider( new ArrayContentProvider() );         checkQualityComboViewer.setInput( new CheckQuality[]             { CheckQuality.DISABLED, CheckQuality.RELAXED, CheckQuality.STRICT } );         checkQualityComboViewer.getControl().setLayoutData(             new GridData( SWT.FILL, SWT.CENTER, true, false ) );          // Validator         toolkit.createLabel( composite, &quot;Validator:&quot; );         validatorText = toolkit.createText( composite, &quot;&quot; );         validatorText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );          // Minimum Length (pwdMinLength)         minimumLengthCheckbox = toolkit.createButton( composite, &quot;Enable Mimimum Length&quot;, SWT.CHECK );         minimumLengthCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 2, 1 ) );         Composite mimimumLengthRadioIndentComposite = createRadioIndentComposite( toolkit, composite,             &quot;Number of characters:&quot; );         minimumLengthText = toolkit.createText( mimimumLengthRadioIndentComposite, &quot;&quot; );         minimumLengthText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );          // Maximum Length (pwdMaxLength)         maximumLengthCheckbox = toolkit.createButton( composite, &quot;Enable Maximum Length&quot;, SWT.CHECK );         maximumLengthCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 2, 1 ) );         Composite maximumLengthRadioIndentComposite = createRadioIndentComposite( toolkit, composite,             &quot;Number of characters:&quot; );         maximumLengthText = toolkit.createText( maximumLengthRadioIndentComposite, &quot;&quot; );         maximumLengthText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );     }       /**      * Creates the Expiration section.      *      * @param toolkit the toolkit to use      * @param parent the parent composite      */     private void createExpirationSection( FormToolkit toolkit, Composite parent )     {         // Creation of the section         Section section = toolkit.createSection( parent, Section.TITLE_BAR );         section.marginWidth = 10;         section.setText( &quot;Expiration&quot; );         TableWrapData td = new TableWrapData( TableWrapData.FILL, TableWrapData.TOP );         td.grabHorizontal = true;         section.setLayoutData( td );         Composite composite = toolkit.createComposite( section );         toolkit.paintBordersFor( composite );         GridLayout gridLayout = new GridLayout( 2, false );         gridLayout.marginHeight = gridLayout.marginWidth = 0;         composite.setLayout( gridLayout );         section.setClient( composite );          // Minimum Age (pwdMinAge)         toolkit.createLabel( composite, &quot;Mimimum Age (seconds):&quot; );         minimumAgeText = toolkit.createText( composite, &quot;&quot; );         minimumAgeText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );          // Maximum Age (pwdMaxAge)         toolkit.createLabel( composite, &quot;Maximum Age (seconds):&quot; );         maximumAgeText = toolkit.createText( composite, &quot;&quot; );         maximumAgeText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );          // Expire Warning (pwdExpireWarning)         expireWarningCheckbox = toolkit.createButton( composite, &quot;Enable Expire Warning&quot;, SWT.CHECK );         expireWarningCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 3, 1 ) );         Composite expireWarningRadioIndentComposite = createRadioIndentComposite( toolkit, composite,             &quot;Number of seconds:&quot; );         expireWarningText = toolkit.createText( expireWarningRadioIndentComposite, &quot;&quot; );         expireWarningText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );          // Grace Authentication Limit (pwdGraceAuthNLimit)         graceAuthenticationLimitCheckbox = toolkit.createButton( composite, &quot;Enable Grace Authentication Limit&quot;,             SWT.CHECK );         graceAuthenticationLimitCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 3, 1 ) );         Composite graceAuthenticationLimitRadioIndentComposite = createRadioIndentComposite( toolkit, composite,             &quot;Number of times:&quot; );         graceAuthenticationLimitText = toolkit.createText( graceAuthenticationLimitRadioIndentComposite, &quot;&quot; );         graceAuthenticationLimitText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );          // Grace Expire (pwdGraceExpire)         graceExpireCheckbox = toolkit.createButton( composite, &quot;Enable Grace Expire&quot;, SWT.CHECK );         graceExpireCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 3, 1 ) );         Composite graceExpireRadioIndentComposite = createRadioIndentComposite( toolkit, composite,             &quot;Interval (seconds):&quot; );         graceExpireText = toolkit.createText( graceExpireRadioIndentComposite, &quot;&quot; );         graceExpireText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );     }       /**      * Creates the Options section.      *      * @param toolkit the toolkit to use      * @param parent the parent composite      */     private void createOptionsSection( FormToolkit toolkit, Composite parent )     {         // Creation of the section         Section section = toolkit.createSection( parent, Section.TITLE_BAR );         section.marginWidth = 10;         section.setText( &quot;Options&quot; );         TableWrapData td = new TableWrapData( TableWrapData.FILL, TableWrapData.TOP );         td.grabHorizontal = true;         section.setLayoutData( td );         Composite composite = toolkit.createComposite( section );         toolkit.paintBordersFor( composite );         GridLayout gridLayout = new GridLayout( 2, false );         gridLayout.marginHeight = gridLayout.marginWidth = 0;         composite.setLayout( gridLayout );         section.setClient( composite );          // Must Change (pwdMustChange)         mustChangeCheckbox = toolkit.createButton( composite, &quot;Enable Must Change&quot;, SWT.CHECK );         mustChangeCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 2, 1 ) );          // Allow User Change (pwdAllowUserChange)         allowUserChangeCheckbox = toolkit.createButton( composite, &quot;Enable Allow User Change&quot;, SWT.CHECK );         allowUserChangeCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 2, 1 ) );          // Safe Modify (pwdSafeModify)         safeModifyCheckbox = toolkit.createButton( composite, &quot;Enable Safe Modify&quot;, SWT.CHECK );         safeModifyCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 2, 1 ) );     }       /**      * Creates the Lockout section.      *      * @param toolkit the toolkit to use      * @param parent the parent composite      */     private void createLockoutSection( FormToolkit toolkit, Composite parent )     {         // Creation of the section         Section section = toolkit.createSection( parent, Section.TITLE_BAR );         section.marginWidth = 10;         section.setText( &quot;Lockout&quot; );         TableWrapData td = new TableWrapData( TableWrapData.FILL, TableWrapData.TOP );         td.grabHorizontal = true;         section.setLayoutData( td );         Composite composite = toolkit.createComposite( section );         toolkit.paintBordersFor( composite );         GridLayout gridLayout = new GridLayout( 2, false );         gridLayout.marginHeight = gridLayout.marginWidth = 0;         composite.setLayout( gridLayout );         section.setClient( composite );          // Lockout (pwdLockout)         lockoutCheckbox = toolkit.createButton( composite, &quot;Enable Lockout&quot;, SWT.CHECK );         lockoutCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 2, 1 ) );          // Lockout Duration (pwdLockoutDuration)         toolkit.createLabel( composite, &quot;Lockout Duration (seconds):&quot; );         lockoutDurationText = toolkit.createText( composite, &quot;&quot; );         lockoutDurationText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );          // Max Failure (pwdMaxFailure)         toolkit.createLabel( composite, &quot;Maximum Consecutive Failures (count):&quot; );         maxFailureText = toolkit.createText( composite, &quot;&quot; );         maxFailureText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );          // Failure Count Interval (pwdFailureCountInterval)         toolkit.createLabel( composite, &quot;Failure Count Interval (seconds):&quot; );         failureCountIntervalText = toolkit.createText( composite, &quot;&quot; );         failureCountIntervalText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );          // Max Idle (pwdMaxIdle)         maxIdleCheckbox = toolkit.createButton( composite, &quot;Enable Maximum Idle&quot;, SWT.CHECK );         maxIdleCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 3, 1 ) );         Composite maxIdleCheckboxRadioIndentComposite = createRadioIndentComposite( toolkit, composite,             &quot;Interval (seconds):&quot; );         maxIdleText = toolkit.createText( maxIdleCheckboxRadioIndentComposite, &quot;&quot; );         maxIdleText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );          // In History (pwdInHistory)         inHistoryCheckbox = toolkit.createButton( composite, &quot;Enable In History&quot;, SWT.CHECK );         inHistoryCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 2, 1 ) );         Composite inHistoryRadioIndentComposite = createRadioIndentComposite( toolkit, composite,             &quot;Used passwords stored in history:&quot; );         inHistoryText = toolkit.createText( inHistoryRadioIndentComposite, &quot;&quot; );         inHistoryText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );                  // Minimum delay (pwdMinDelay)         toolkit.createLabel( composite, &quot;Mimimum Delay (seconds):&quot; );         minimumDelayText = toolkit.createText( composite, &quot;&quot; );         minimumDelayText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );          // Maximum Delay (pwdMaxDelay)         toolkit.createLabel( composite, &quot;Maximum Delay (seconds):&quot; );         maximumDelayText = toolkit.createText( composite, &quot;&quot; );         maximumDelayText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );     }       /**      * Creates a radio indented composite.      *      * @param toolkit the toolkit      * @param parent the parent composite      * @return a radio indented composite      */     private Composite createRadioIndentComposite( FormToolkit toolkit, Composite parent, String text )     {         Composite composite = toolkit.createComposite( parent );         GridLayout gridLayout = new GridLayout( 3, false );         gridLayout.marginHeight = gridLayout.marginWidth = 0;         composite.setLayout( gridLayout );         composite.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false, 2, 1 ) );          toolkit.createLabel( composite, &quot;   &quot; );         toolkit.createLabel( composite, text );          return composite;     }       /**      * Adds listeners to UI fields.      */     private void addListeners()     {         enabledCheckbox.addSelectionListener( buttonSelectionListener );         idText.addModifyListener( textModifyListener );         descriptionText.addModifyListener( textModifyListener );         checkQualityComboViewer.addSelectionChangedListener( viewerSelectionChangedListener );         checkQualityComboViewer.addSelectionChangedListener( checkQualityComboViewerSelectionChangedListener );         validatorText.addModifyListener( textModifyListener );         minimumLengthCheckbox.addSelectionListener( buttonSelectionListener );         minimumLengthCheckbox.addSelectionListener( minimumLengthCheckboxSelectionListener );         minimumLengthText.addModifyListener( textModifyListener );         minimumLengthText.addVerifyListener( integerVerifyListener );         maximumLengthCheckbox.addSelectionListener( buttonSelectionListener );         maximumLengthCheckbox.addSelectionListener( maximumLengthCheckboxSelectionListener );         maximumLengthText.addModifyListener( textModifyListener );         maximumLengthText.addVerifyListener( integerVerifyListener );         minimumAgeText.addModifyListener( textModifyListener );         minimumAgeText.addVerifyListener( integerVerifyListener );         maximumAgeText.addModifyListener( textModifyListener );         maximumAgeText.addVerifyListener( integerVerifyListener );         expireWarningCheckbox.addSelectionListener( buttonSelectionListener );         expireWarningCheckbox.addSelectionListener( expireWarningCheckboxSelectionListener );         expireWarningText.addModifyListener( textModifyListener );         expireWarningText.addVerifyListener( integerVerifyListener );         graceAuthenticationLimitCheckbox.addSelectionListener( buttonSelectionListener );         graceAuthenticationLimitCheckbox.addSelectionListener( graceAuthenticationLimitCheckboxSelectionListener );         graceAuthenticationLimitText.addModifyListener( textModifyListener );         graceAuthenticationLimitText.addVerifyListener( integerVerifyListener );         graceExpireCheckbox.addSelectionListener( buttonSelectionListener );         graceExpireCheckbox.addSelectionListener( graceExpireCheckboxSelectionListener );         graceExpireText.addModifyListener( textModifyListener );         graceExpireText.addVerifyListener( integerVerifyListener );         mustChangeCheckbox.addSelectionListener( buttonSelectionListener );         allowUserChangeCheckbox.addSelectionListener( buttonSelectionListener );         safeModifyCheckbox.addSelectionListener( buttonSelectionListener );         lockoutCheckbox.addSelectionListener( buttonSelectionListener );         lockoutDurationText.addModifyListener( textModifyListener );         lockoutDurationText.addVerifyListener( integerVerifyListener );         maxFailureText.addModifyListener( textModifyListener );         maxFailureText.addVerifyListener( integerVerifyListener );         failureCountIntervalText.addModifyListener( textModifyListener );         failureCountIntervalText.addVerifyListener( integerVerifyListener );         maxIdleCheckbox.addSelectionListener( buttonSelectionListener );         maxIdleCheckbox.addSelectionListener( maxIdleCheckboxSelectionListener );         maxIdleText.addModifyListener( textModifyListener );         maxIdleText.addVerifyListener( integerVerifyListener );         inHistoryCheckbox.addSelectionListener( buttonSelectionListener );         inHistoryCheckbox.addSelectionListener( inHistoryCheckboxSelectionListener );         inHistoryText.addModifyListener( textModifyListener );         inHistoryText.addVerifyListener( integerVerifyListener );         minimumDelayText.addModifyListener( textModifyListener );         minimumDelayText.addVerifyListener( integerVerifyListener );         maximumDelayText.addModifyListener( textModifyListener );         maximumDelayText.addVerifyListener( integerVerifyListener );     }       /**      * Removes listeners to UI fields.      */     private void removeListeners()     {         enabledCheckbox.removeSelectionListener( buttonSelectionListener );         idText.removeModifyListener( textModifyListener );         descriptionText.removeModifyListener( textModifyListener );         checkQualityComboViewer.removeSelectionChangedListener( viewerSelectionChangedListener );         checkQualityComboViewer.removeSelectionChangedListener( checkQualityComboViewerSelectionChangedListener );         validatorText.removeModifyListener( textModifyListener );         minimumLengthCheckbox.removeSelectionListener( buttonSelectionListener );         minimumLengthCheckbox.removeSelectionListener( minimumLengthCheckboxSelectionListener );         minimumLengthText.removeModifyListener( textModifyListener );         minimumLengthText.removeVerifyListener( integerVerifyListener );         maximumLengthCheckbox.removeSelectionListener( buttonSelectionListener );         maximumLengthCheckbox.removeSelectionListener( maximumLengthCheckboxSelectionListener );         maximumLengthText.removeModifyListener( textModifyListener );         maximumLengthText.removeVerifyListener( integerVerifyListener );         minimumAgeText.removeModifyListener( textModifyListener );         minimumAgeText.removeVerifyListener( integerVerifyListener );         maximumAgeText.removeModifyListener( textModifyListener );         maximumAgeText.removeVerifyListener( integerVerifyListener );         expireWarningCheckbox.removeSelectionListener( buttonSelectionListener );         expireWarningCheckbox.removeSelectionListener( expireWarningCheckboxSelectionListener );         expireWarningText.removeModifyListener( textModifyListener );         expireWarningText.removeVerifyListener( integerVerifyListener );         graceAuthenticationLimitCheckbox.removeSelectionListener( buttonSelectionListener );         graceAuthenticationLimitCheckbox.removeSelectionListener( graceAuthenticationLimitCheckboxSelectionListener );         graceAuthenticationLimitText.removeModifyListener( textModifyListener );         graceAuthenticationLimitText.removeVerifyListener( integerVerifyListener );         graceExpireCheckbox.removeSelectionListener( buttonSelectionListener );         graceExpireCheckbox.removeSelectionListener( graceExpireCheckboxSelectionListener );         graceExpireText.removeModifyListener( textModifyListener );         graceExpireText.removeVerifyListener( integerVerifyListener );         mustChangeCheckbox.removeSelectionListener( buttonSelectionListener );         allowUserChangeCheckbox.removeSelectionListener( buttonSelectionListener );         safeModifyCheckbox.removeSelectionListener( buttonSelectionListener );         lockoutCheckbox.removeSelectionListener( buttonSelectionListener );         lockoutDurationText.removeModifyListener( textModifyListener );         lockoutDurationText.removeVerifyListener( integerVerifyListener );         maxFailureText.removeModifyListener( textModifyListener );         maxFailureText.removeVerifyListener( integerVerifyListener );         failureCountIntervalText.removeModifyListener( textModifyListener );         failureCountIntervalText.removeVerifyListener( integerVerifyListener );         maxIdleCheckbox.removeSelectionListener( buttonSelectionListener );         maxIdleCheckbox.removeSelectionListener( maxIdleCheckboxSelectionListener );         maxIdleText.removeModifyListener( textModifyListener );         maxIdleText.removeVerifyListener( integerVerifyListener );         inHistoryCheckbox.removeSelectionListener( buttonSelectionListener );         inHistoryCheckbox.removeSelectionListener( inHistoryCheckboxSelectionListener );         inHistoryText.removeModifyListener( textModifyListener );         inHistoryText.removeVerifyListener( integerVerifyListener );         minimumDelayText.removeModifyListener( textModifyListener );         minimumDelayText.removeVerifyListener( integerVerifyListener );         maximumDelayText.removeModifyListener( textModifyListener );         maximumDelayText.removeVerifyListener( integerVerifyListener );     }       /**      * {@inheritDoc}      */     public void selectionChanged( IFormPart part, ISelection selection )     {         IStructuredSelection ssel = ( IStructuredSelection ) selection;         if ( ssel.size() == 1 )         {             passwordPolicy = ( PasswordPolicyBean ) ssel.getFirstElement();         }         else         {             passwordPolicy = null;         }         refresh();     }       /**      * {@inheritDoc}      */     public void commit( boolean onSave )     {         if ( passwordPolicy != null )         {             // Enabled             passwordPolicy.setEnabled( enabledCheckbox.getSelection() );              // ID             passwordPolicy.setPwdId( ServerConfigurationEditorUtils.checkEmptyString( idText.getText() ) );              // Description             passwordPolicy                 .setDescription( ServerConfigurationEditorUtils.checkEmptyString( descriptionText.getText() ) );              // Check Quality             passwordPolicy.setPwdCheckQuality( getPwdCheckQuality() );              // Validator             passwordPolicy                 .setPwdValidator( ServerConfigurationEditorUtils.checkEmptyString( validatorText.getText() ) );              // Miminum Length             if ( minimumLengthCheckbox.getSelection() )             {                 try                 {                     passwordPolicy.setPwdMinLength( Integer.parseInt( minimumLengthText.getText() ) );                 }                 catch ( NumberFormatException e )                 {                     passwordPolicy.setPwdMinLength( 0 );                 }             }             else             {                 passwordPolicy.setPwdMinLength( 0 );             }              // Maximum Length             if ( maximumLengthCheckbox.getSelection() )             {                 try                 {                     passwordPolicy.setPwdMaxLength( Integer.parseInt( maximumLengthText.getText() ) );                 }                 catch ( NumberFormatException e )                 {                     passwordPolicy.setPwdMaxLength( 0 );                 }             }             else             {                 passwordPolicy.setPwdMaxLength( 0 );             }              // Minimum Age             try             {                 passwordPolicy.setPwdMinAge( Integer.parseInt( minimumAgeText.getText() ) );             }             catch ( NumberFormatException e )             {                 passwordPolicy.setPwdMinAge( 0 );             }              // Maximum Age             try             {                 passwordPolicy.setPwdMaxAge( Integer.parseInt( maximumAgeText.getText() ) );             }             catch ( NumberFormatException e )             {                 passwordPolicy.setPwdMaxAge( 0 );             }              // Expire Warning             if ( expireWarningCheckbox.getSelection() )             {                 try                 {                     passwordPolicy.setPwdExpireWarning( Integer.parseInt( expireWarningText.getText() ) );                 }                 catch ( NumberFormatException e )                 {                     passwordPolicy.setPwdExpireWarning( 0 );                 }             }             else             {                 passwordPolicy.setPwdExpireWarning( 0 );             }              // Grace Authentication Limit             if ( graceAuthenticationLimitCheckbox.getSelection() )             {                 try                 {                     passwordPolicy.setPwdGraceAuthNLimit( Integer.parseInt( graceAuthenticationLimitText.getText() ) );                 }                 catch ( NumberFormatException e )                 {                     passwordPolicy.setPwdGraceAuthNLimit( 0 );                 }             }             else             {                 passwordPolicy.setPwdGraceAuthNLimit( 0 );             }              // Grace Expire             if ( graceExpireCheckbox.getSelection() )             {                 try                 {                     passwordPolicy.setPwdGraceExpire( Integer.parseInt( graceExpireText.getText() ) );                 }                 catch ( NumberFormatException e )                 {                     passwordPolicy.setPwdGraceExpire( 0 );                 }             }             else             {                 passwordPolicy.setPwdGraceExpire( 0 );             }              // Must Change             passwordPolicy.setPwdMustChange( mustChangeCheckbox.getSelection() );              // Allow User Change             passwordPolicy.setPwdAllowUserChange( allowUserChangeCheckbox.getSelection() );              // Safe Modify             passwordPolicy.setPwdSafeModify( safeModifyCheckbox.getSelection() );              // Lockout             passwordPolicy.setPwdLockout( lockoutCheckbox.getSelection() );              // Lockout Duration             try             {                 passwordPolicy.setPwdLockoutDuration( Integer.parseInt( lockoutDurationText.getText() ) );             }             catch ( NumberFormatException e )             {                 passwordPolicy.setPwdLockoutDuration( 0 );             }              // Max Failure             try             {                 passwordPolicy.setPwdMaxFailure( Integer.parseInt( maxFailureText.getText() ) );             }             catch ( NumberFormatException e )             {                 passwordPolicy.setPwdMaxFailure( 0 );             }              // Failure Count Interval             try             {                 passwordPolicy.setPwdFailureCountInterval( Integer.parseInt( failureCountIntervalText.getText() ) );             }             catch ( NumberFormatException e )             {                 passwordPolicy.setPwdFailureCountInterval( 0 );             }              // Max Idle             if ( maxIdleCheckbox.getSelection() )             {                 try                 {                     passwordPolicy.setPwdMaxIdle( Integer.parseInt( maxIdleText.getText() ) );                 }                 catch ( NumberFormatException e )                 {                     passwordPolicy.setPwdMaxIdle( 0 );                 }             }             else             {                 passwordPolicy.setPwdMaxIdle( 0 );             }              // In History             if ( inHistoryCheckbox.getSelection() )             {                 try                 {                     passwordPolicy.setPwdInHistory( Integer.parseInt( inHistoryText.getText() ) );                 }                 catch ( NumberFormatException e )                 {                     passwordPolicy.setPwdInHistory( 0 );                 }             }             else             {                 passwordPolicy.setPwdInHistory( 0 );             }              // Minimum Delay             try             {                 passwordPolicy.setPwdMinDelay( Integer.parseInt( minimumDelayText.getText() ) );             }             catch ( NumberFormatException e )             {                 passwordPolicy.setPwdMinDelay( 0 );             }              // Maximum Delay             try             {                 passwordPolicy.setPwdMaxDelay( Integer.parseInt( maximumDelayText.getText() ) );             }             catch ( NumberFormatException e )             {                 passwordPolicy.setPwdMaxDelay( 0 );             }         }     }       /**      * Gets the password policy check quality.      *      * @return the password policy check quality      */     private int getPwdCheckQuality()     {         IStructuredSelection selection = ( StructuredSelection ) checkQualityComboViewer.getSelection();          if ( !selection.isEmpty() )         {             CheckQuality checkQuality = ( CheckQuality ) selection.getFirstElement();              return checkQuality.getValue();         }          return CheckQuality.DISABLED.getValue();     }       /**      * {@inheritDoc}      */     public void dispose()     {     }       /**      * {@inheritDoc}      */     public void initialize( IManagedForm form )     {         this.mform = form;     }       /**      * {@inheritDoc}      */     public boolean isDirty()     {         return false;     }       /**      * {@inheritDoc}      */     public boolean isStale()     {         return false;     }       /**      * {@inheritDoc}      */     public void refresh()     {         removeListeners();          if ( passwordPolicy != null )         {             // Checking if this is the default password policy             boolean isDefaultPasswordPolicy = PasswordPoliciesPage.isDefaultPasswordPolicy( passwordPolicy );              // Enabled             enabledCheckbox.setSelection( passwordPolicy.isEnabled() );              // ID             idText.setText( ServerConfigurationEditorUtils.checkNull( passwordPolicy.getPwdId() ) );             idText.setEnabled( !isDefaultPasswordPolicy );              // Description             descriptionText.setText( ServerConfigurationEditorUtils.checkNull( passwordPolicy.getDescription() ) );             descriptionText.setEnabled( !isDefaultPasswordPolicy );              // Check Quality             checkQualityComboViewer.setSelection( new StructuredSelection( CheckQuality.valueOf( passwordPolicy                 .getPwdCheckQuality() ) ) );              // Validator             validatorText.setText( ServerConfigurationEditorUtils.checkNull( passwordPolicy.getPwdValidator() ) );              // Miminum Length             int minimumLength = passwordPolicy.getPwdMinLength();             minimumLengthCheckbox.setSelection( minimumLength != 0 );             minimumLengthText.setText( &quot;&quot; + minimumLength );              // Maximum Length             int maximumLength = passwordPolicy.getPwdMaxLength();             maximumLengthCheckbox.setSelection( maximumLength != 0 );             maximumLengthText.setText( &quot;&quot; + maximumLength );              if ( getPwdCheckQuality() == 0 )             {                 minimumLengthCheckbox.setEnabled( false );                 minimumLengthText.setEnabled( false );                 maximumLengthCheckbox.setEnabled( false );                 maximumLengthText.setEnabled( false );             }             else             {                 minimumLengthCheckbox.setEnabled( true );                 minimumLengthText.setEnabled( minimumLength != 0 );                 maximumLengthCheckbox.setEnabled( true );                 maximumLengthText.setEnabled( maximumLength != 0 );             }              // Minimum Age             minimumAgeText.setText( &quot;&quot; + passwordPolicy.getPwdMinAge() );              // Maximum Age             maximumAgeText.setText( &quot;&quot; + passwordPolicy.getPwdMaxAge() );              // Expire Warning             int expireWarning = passwordPolicy.getPwdExpireWarning();             expireWarningCheckbox.setSelection( expireWarning != 0 );             expireWarningText.setText( &quot;&quot; + expireWarning );             expireWarningText.setEnabled( expireWarning != 0 );              // Grace Authentication Limit             int graceAuthenticationLimit = passwordPolicy.getPwdGraceAuthNLimit();             graceAuthenticationLimitCheckbox.setSelection( graceAuthenticationLimit != 0 );             graceAuthenticationLimitText.setText( &quot;&quot; + graceAuthenticationLimit );             graceAuthenticationLimitText.setEnabled( graceAuthenticationLimit != 0 );              // Grace Expire             int graceExpire = passwordPolicy.getPwdGraceExpire();             graceExpireCheckbox.setSelection( graceExpire != 0 );             graceExpireText.setText( &quot;&quot; + graceExpire );             graceExpireText.setEnabled( graceExpire != 0 );              // Must Change             mustChangeCheckbox.setSelection( passwordPolicy.isPwdMustChange() );              // Allow User Change             allowUserChangeCheckbox.setSelection( passwordPolicy.isPwdAllowUserChange() );              // Safe Modify             safeModifyCheckbox.setSelection( passwordPolicy.isPwdSafeModify() );              // Lockout             lockoutCheckbox.setSelection( passwordPolicy.isPwdLockout() );              // Lockout Duration             lockoutDurationText.setText( &quot;&quot; + passwordPolicy.getPwdLockoutDuration() );              // Max Failure             maxFailureText.setText( &quot;&quot; + passwordPolicy.getPwdMaxFailure() );              // Failure Count Interval             failureCountIntervalText.setText( &quot;&quot; + passwordPolicy.getPwdFailureCountInterval() );              // Max Idle             int maxIdle = passwordPolicy.getPwdMaxIdle();             maxIdleCheckbox.setSelection( maxIdle != 0 );             maxIdleText.setText( &quot;&quot; + maxIdle );             maxIdleText.setEnabled( maxIdle != 0 );              // In History             int inHistory = passwordPolicy.getPwdInHistory();             inHistoryCheckbox.setSelection( inHistory != 0 );             inHistoryText.setText( &quot;&quot; + inHistory );             inHistoryText.setEnabled( inHistory != 0 );              // Minimum Delay             minimumDelayText.setText( &quot;&quot; + passwordPolicy.getPwdMinDelay() );              // Maximum Delay             maximumDelayText.setText( &quot;&quot; + passwordPolicy.getPwdMaxDelay() );         }          addListeners();     }       /**      * {@inheritDoc}      */     public void setFocus()     {         //        idText.setFocus();     }       /**      * {@inheritDoc}      */     public boolean setFormInput( Object input )     {         return false;     }      /**      * This enum is used for the check quality value.      *      * @author Apache Directory Project      */     private enum CheckQuality     {         DISABLED(0),         RELAXED(1),         STRICT(2);          /** The value */         private int value;           /**          * Creates a new instance of CheckQuality.          *          * @param value the value          */         private CheckQuality( int value )         {             this.value = value;         }           /**          * Gets the value.          *          * @return the value          */         public int getValue()         {             return value;         }           public static CheckQuality valueOf( int value )         {             for ( CheckQuality checkQuality : CheckQuality.class.getEnumConstants() )             {                 if ( checkQuality.getValue() == value )                 {                     return checkQuality;                 }             }              throw new IllegalArgumentException( &quot;There is no CheckQuality value for :&quot; + value );         }           /**          * {@inheritDoc}          */         public String toString()         {             switch ( this )             {                 case DISABLED:                     return &quot;Disabled&quot;;                 case RELAXED:                     return &quot;Relaxed&quot;;                 case STRICT:                     return &quot;Strict&quot;;             }              return super.toString();         }     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">7803</td>
    <td align="left">https://github.com/apache/directory-studio/blob/e8f15ea553a3ae7bebc2fe96d6a2864e188f8017/plugins/apacheds.configuration/src/main/java/org/apache/directory/studio/apacheds/configuration/editor/PasswordPolicyDetailsPage.java/#L110-L1248</td>
    <td align="right">1</td>
    <td align="right">842</td>
    <td align="right">7803</td>
  </tr>
  <tr valign="top">
    <td align="right">866</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;1. Long Method&quot;,       &quot;2. Blob&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  private XMLEvent expectTag(String expected, boolean allowEnd)       throws IOException {     XMLEvent ev = null;     while (true) {       try {         ev = events.nextEvent();       } catch (XMLStreamException e) {         throw new IOException(&quot;Expecting &quot; + expected +             &quot;, but got XMLStreamException&quot;, e);       }       switch (ev.getEventType()) {       case XMLEvent.ATTRIBUTE:         throw new IOException(&quot;Got unexpected attribute: &quot; + ev);       case XMLEvent.CHARACTERS:         if (!ev.asCharacters().isWhiteSpace()) {           throw new IOException(&quot;Got unxpected characters while &quot; +               &quot;looking for &quot; + expected + &quot;: &quot; +               ev.asCharacters().getData());         }         break;       case XMLEvent.END_ELEMENT:         if (!allowEnd) {           throw new IOException(&quot;Got unexpected end event &quot; +               &quot;while looking for &quot; + expected);         }         return ev;       case XMLEvent.START_ELEMENT:         if (!expected.startsWith(&quot;[&quot;)) {           if (!ev.asStartElement().getName().getLocalPart().                 equals(expected)) {             throw new IOException(&quot;Failed to find &lt;&quot; + expected + &quot;&gt;; &quot; +                 &quot;got &quot; + ev.asStartElement().getName().getLocalPart() +                 &quot; instead.&quot;);           }         }         return ev;       default:         // Ignore other event types like comment, etc.         if (LOG.isTraceEnabled()) {           LOG.trace(&quot;Skipping XMLEvent of type &quot; +               ev.getEventType() + &quot;(&quot; +  ev + &quot;)&quot;);         }         break;       }     }   }</td>
    <td align="left">long method</td>
    <td align="left">1. long method, 2. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;2. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7932</td>
    <td align="left">https://github.com/apache/hadoop/blob/128dd91e10080bdcbcd7d555fa3c4105e55a6b51/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/OfflineImageReconstructor.java/#L184-L229</td>
    <td align="right">1</td>
    <td align="right">866</td>
    <td align="right">7932</td>
  </tr>
  <tr valign="top">
    <td align="right">871</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES, I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Status {     public String getAction() {         return action;     }      public Result getResult() {         return result;     }      public String getDetails() {         return details;     }      private String action;     private Result result;     private String details;      public Status(String action, Result result, String details) {         this.action = action;         this.result = result;         this.details = details;     }     public static enum Result {         SUCCESSFUL,         FAILED,     }      @Override     public String toString() {         return String.format(&quot;%s\t%s\t%s&quot;, action, result, details);     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7972</td>
    <td align="left">https://github.com/Microsoft/azure-tools-for-java/blob/d121e8ac9cc3ab400e5b49c8b372280ae332f3fb/Utils/azuretools-core/src/com/microsoft/azuretools/authmanage/srvpri/step/Status.java/#L28-L59</td>
    <td align="right">1</td>
    <td align="right">871</td>
    <td align="right">7972</td>
  </tr>
  <tr valign="top">
    <td align="right">880</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Long Method&quot;,       &quot;Blob&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private static void weaveDir(File dir, String consumerHeaderKey, String consumerHeaderValue, String bundleClassPath) throws Exception {         Set wd = ConsumerHeaderProcessor.processHeader(consumerHeaderKey, consumerHeaderValue);          URLClassLoader cl = new URLClassLoader(new URL [] {dir.toURI().toURL()}, Main.class.getClassLoader());         String dirName = dir.getAbsolutePath();          DirTree dt = new DirTree(dir);         for (File f : dt.getFiles()) {             if (!f.getName().endsWith(&quot;.class&quot;))                 continue;              String className = f.getAbsolutePath().substring(dirName.length());             if (className.startsWith(File.separator))                 className = className.substring(1);             className = className.substring(0, className.length() - &quot;.class&quot;.length());             className = className.replace(File.separator, &quot;.&quot;);              InputStream is = new FileInputStream(f);             byte[] b;             try {                 ClassReader cr = new ClassReader(is);                 ClassWriter cw = new StaticToolClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES, cl);                 TCCLSetterVisitor cv = new TCCLSetterVisitor(cw, className, wd);                 cr.accept(cv, ClassReader.SKIP_FRAMES);                 if (cv.isWoven()) {                     b = cw.toByteArray();                 } else {                     // if not woven, store the original bytes                     b = Streams.suck(new FileInputStream(f));                 }             } finally {                 is.close();             }              OutputStream os = new FileOutputStream(f);             try {                 os.write(b);             } finally {                 os.close();             }         }          if (bundleClassPath != null) {             for (String entry : bundleClassPath.split(&quot;,&quot;)) {                 File jarFile = new File(dir, entry.trim());                 if (jarFile.isFile()) {                     weaveBCPJar(jarFile, consumerHeaderKey, consumerHeaderValue);                 }             }         }     }</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8016</td>
    <td align="left">https://github.com/apache/aries/blob/52293d20268de7c98833846ded2b70d6476773de/spi-fly/spi-fly-static-tool/src/main/java/org/apache/aries/spifly/statictool/Main.java/#L173-L223</td>
    <td align="right">1</td>
    <td align="right">880</td>
    <td align="right">8016</td>
  </tr>
  <tr valign="top">
    <td align="right">908</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;answer&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Blob&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @Override     public void onTrigger(final ProcessContext context, final ProcessSession session) {         List flowFiles = session.get(context.getProperty(BATCH_SIZE).evaluateAttributeExpressions().asInteger());         if (flowFiles == null || flowFiles.size() == 0) {             return;         }          Map keysToFlowFileMap = new HashMap&lt;&gt;();          final String table = context.getProperty(TABLE).evaluateAttributeExpressions().getValue();          final String hashKeyName = context.getProperty(HASH_KEY_NAME).evaluateAttributeExpressions().getValue();         final String hashKeyValueType = context.getProperty(HASH_KEY_VALUE_TYPE).getValue();         final String rangeKeyName = context.getProperty(RANGE_KEY_NAME).evaluateAttributeExpressions().getValue();         final String rangeKeyValueType = context.getProperty(RANGE_KEY_VALUE_TYPE).getValue();         final String jsonDocument = context.getProperty(JSON_DOCUMENT).evaluateAttributeExpressions().getValue();         final String charset = context.getProperty(DOCUMENT_CHARSET).evaluateAttributeExpressions().getValue();          TableWriteItems tableWriteItems = new TableWriteItems(table);          for (FlowFile flowFile : flowFiles) {             final Object hashKeyValue = getValue(context, HASH_KEY_VALUE_TYPE, HASH_KEY_VALUE, flowFile);             final Object rangeKeyValue = getValue(context, RANGE_KEY_VALUE_TYPE, RANGE_KEY_VALUE, flowFile);              if (!isHashKeyValueConsistent(hashKeyName, hashKeyValue, session, flowFile)) {                 continue;             }              if (!isRangeKeyValueConsistent(rangeKeyName, rangeKeyValue, session, flowFile)) {                 continue;             }              if (!isDataValid(flowFile, jsonDocument)) {                 flowFile = session.putAttribute(flowFile, AWS_DYNAMO_DB_ITEM_SIZE_ERROR, &quot;Max size of item + attribute should be 400kb but was &quot; + flowFile.getSize() + jsonDocument.length());                 session.transfer(flowFile, REL_FAILURE);                 continue;             }              ByteArrayOutputStream baos = new ByteArrayOutputStream();             session.exportTo(flowFile, baos);              try {                 if (rangeKeyValue == null || StringUtils.isBlank(rangeKeyValue.toString())) {                     tableWriteItems.addItemToPut(new Item().withKeyComponent(hashKeyName, hashKeyValue)                         .withJSON(jsonDocument, IOUtils.toString(baos.toByteArray(), charset)));                 } else {                     tableWriteItems.addItemToPut(new Item().withKeyComponent(hashKeyName, hashKeyValue)                         .withKeyComponent(rangeKeyName, rangeKeyValue)                         .withJSON(jsonDocument, IOUtils.toString(baos.toByteArray(), charset)));                 }             } catch (IOException ioe) {                 getLogger().error(&quot;IOException while creating put item : &quot; + ioe.getMessage());                 flowFile = session.putAttribute(flowFile, DYNAMODB_ITEM_IO_ERROR, ioe.getMessage());                 session.transfer(flowFile, REL_FAILURE);             }             keysToFlowFileMap.put(new ItemKeys(hashKeyValue, rangeKeyValue), flowFile);         }          if (keysToFlowFileMap.isEmpty()) {             return;         }          final DynamoDB dynamoDB = getDynamoDB();          try {             BatchWriteItemOutcome outcome = dynamoDB.batchWriteItem(tableWriteItems);              handleUnprocessedItems(session, keysToFlowFileMap, table, hashKeyName, hashKeyValueType, rangeKeyName,                 rangeKeyValueType, outcome);              // Handle any remaining flowfiles             for (FlowFile flowFile : keysToFlowFileMap.values()) {                 getLogger().debug(&quot;Successful posted items to dynamodb : &quot; + table);                 session.transfer(flowFile, REL_SUCCESS);             }         } catch (AmazonServiceException exception) {             getLogger().error(&quot;Could not process flowFiles due to service exception : &quot; + exception.getMessage());             List failedFlowFiles = processServiceException(session, flowFiles, exception);             session.transfer(failedFlowFiles, REL_FAILURE);         } catch (AmazonClientException exception) {             getLogger().error(&quot;Could not process flowFiles due to client exception : &quot; + exception.getMessage());             List failedFlowFiles = processClientException(session, flowFiles, exception);             session.transfer(failedFlowFiles, REL_FAILURE);         } catch (Exception exception) {             getLogger().error(&quot;Could not process flowFiles due to exception : &quot; + exception.getMessage());             List failedFlowFiles = processException(session, flowFiles, exception);             session.transfer(failedFlowFiles, REL_FAILURE);         }     }</td>
    <td align="left">long method</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8202</td>
    <td align="left">https://github.com/apache/nifi/blob/c8eff590efa3babcda0b755009224dcac168708b/nifi-nar-bundles/nifi-aws-bundle/nifi-aws-processors/src/main/java/org/apache/nifi/processors/aws/dynamodb/PutDynamoDB.java/#L100-L188</td>
    <td align="right">1</td>
    <td align="right">908</td>
    <td align="right">8202</td>
  </tr>
  <tr valign="top">
    <td align="right">936</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TfsGitTreeEntriesJson {     private final String objectId;     private final List treeEntries;     private final int size;      @JsonCreator     public TfsGitTreeEntriesJson(         @JsonProperty(&quot;objectId&quot;) final String objectId,         @JsonProperty(&quot;treeEntries&quot;) final List treeEntries,         @JsonProperty(&quot;size&quot;) final int size) throws JsonProcessingException {         this.objectId = objectId;         this.treeEntries = treeEntries;         this.size = size;     }      public String getObjectId() {         return objectId;     }      public List getTreeEntries() {         return treeEntries;     }      public int getSize() {         return size;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8410</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.client.common/src/com/microsoft/tfs/client/common/git/json/TfsGitTreeEntriesJson.java/#L12-L38</td>
    <td align="right">1</td>
    <td align="right">936</td>
    <td align="right">8410</td>
  </tr>
  <tr valign="top">
    <td align="right">938</td>
    <td align="left">&nbsp;{   &quot;response&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;Long Method&quot;,     &quot;Blob&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	private ICompletionProposal[] getRelevantProposals( ITextViewer viewer, 			int offset ) throws BadLocationException 	{ 		if ( lastProposals != null ) 		{ 			ArrayList relevantProposals = new ArrayList( 10 );  			String word = ( findWord( viewer, offset - 1 ) ).toLowerCase( ); 			//Search for this word in the list  			for ( int n = 0; n &lt; lastProposals.length; n++ ) 			{ 				if ( stripQuotes( lastProposals[n].getDisplayString( ) 						.toLowerCase( ) ).startsWith( word ) ) 				{ 					CompletionProposal proposal = new CompletionProposal( lastProposals[n].getDisplayString( ), 							offset - word.length( ), 							word.length( ), 							lastProposals[n].getDisplayString( ).length( ) ); 					relevantProposals.add( proposal ); 				} 			}  			if ( relevantProposals.size( ) &gt; 0 ) 			{ 				return (ICompletionProposal[]) relevantProposals.toArray( new ICompletionProposal[]{} ); 			} 		}  		return null; 	}</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8427</td>
    <td align="left">https://github.com/eclipse/birt/blob/f89264810347de98702db45386a822aabc0fadbf/data/org.eclipse.birt.report.data.oda.jdbc.ui/src/org/eclipse/birt/report/data/oda/jdbc/ui/editors/JdbcSQLContentAssistProcessor.java/#L278-L308</td>
    <td align="right">1</td>
    <td align="right">938</td>
    <td align="right">8427</td>
  </tr>
  <tr valign="top">
    <td align="right">939</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Long Method&quot;,             &quot;Blob&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class CounterMark     {         private final Row row;         private final ColumnMetadata column;         private final CellPath path;          private CounterMark(Row row, ColumnMetadata column, CellPath path)         {             this.row = row;             this.column = column;             this.path = path;         }          public Clustering clustering()         {             return row.clustering();         }          public ColumnMetadata column()         {             return column;         }          public CellPath path()         {             return path;         }          public ByteBuffer value()         {             return path == null                  ? row.getCell(column).value()                  : row.getCell(column, path).value();         }          public void setValue(ByteBuffer value)         {             // This is a bit of a giant hack as this is the only place where we mutate a Row object. This makes it more efficient             // for counters however and this won't be needed post-#6506 so that's probably fine.             assert row instanceof BTreeRow;             ((BTreeRow)row).setValue(column, path, value);         }     }</td>
    <td align="left">data class</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method,  blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">8450</td>
    <td align="left">https://github.com/apache/cassandra/blob/e191aff385053bdb5325f15bc6d16d2dc0ee0589/src/java/org/apache/cassandra/db/partitions/PartitionUpdate.java/#L661-L703</td>
    <td align="right">1</td>
    <td align="right">939</td>
    <td align="right">8450</td>
  </tr>
  <tr valign="top">
    <td align="right">944</td>
    <td align="left">	{ 		&quot;response&quot;: &quot;YES I found bad smells&quot;, 		&quot;bad smells&quot;: [ 			&quot;Blob&quot;, 			&quot;Long Method&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SimpleMessage implements Message {      private final MessageId messageId;     private final String subType;     private final String mediaType;     private final SharedInputStream content;     private final int bodyStartOctet;     private final Date internalDate;     private final long size;     private final Long textualLineCount;     private final List properties;     private final List attachments;      public SimpleMessage(MessageId messageId, SharedInputStream content, long size, Date internalDate, String subType, String mediaType, int bodyStartOctet, Long textualLineCount, List properties, List attachments) {         this.messageId = messageId;         this.subType = subType;         this.mediaType = mediaType;         this.content = content;         this.bodyStartOctet = bodyStartOctet;         this.internalDate = internalDate;         this.size = size;         this.textualLineCount = textualLineCount;         this.properties = properties;         this.attachments = attachments;     }      public SimpleMessage(MessageId messageId, SharedInputStream content, long size, Date internalDate, String subType, String mediaType, int bodyStartOctet, Long textualLineCount, List properties) {         this(messageId, content, size, internalDate, subType, mediaType, bodyStartOctet, textualLineCount, properties, ImmutableList.of());     }      @Override     public MessageId getMessageId() {         return messageId;     }      @Override     public Date getInternalDate() {         return internalDate;     }      @Override     public InputStream getBodyContent() throws IOException {         return content.newStream(bodyStartOctet, -1);     }      @Override     public String getMediaType() {         return mediaType;     }      @Override     public String getSubType() {         return subType;     }      @Override     public long getBodyOctets() {         return getFullContentOctets() - bodyStartOctet;     }      @Override     public long getHeaderOctets() {         return bodyStartOctet;     }      @Override     public long getFullContentOctets() {         return size;     }      @Override     public Long getTextualLineCount() {         return textualLineCount;     }      @Override     public InputStream getHeaderContent() throws IOException {         long headerEnd = bodyStartOctet;         if (headerEnd &lt; 0) {             headerEnd = 0;         }         return content.newStream(0, headerEnd);     }      @Override     public InputStream getFullContent() throws IOException {         return content.newStream(0, -1);     }      @Override     public List getProperties() {         return properties;     }      @Override     public List getAttachments() {         return attachments;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">8474</td>
    <td align="left">https://github.com/apache/james-project/blob/fa24a096a5853459c3769a34ccc68feb91626bfa/mailbox/store/src/main/java/org/apache/james/mailbox/store/mail/model/impl/SimpleMessage.java/#L35-L133</td>
    <td align="right">1</td>
    <td align="right">944</td>
    <td align="right">8474</td>
  </tr>
  <tr valign="top">
    <td align="right">949</td>
    <td align="left">&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;badSmells&quot;: [         &quot;Blob&quot;,         &quot;Feature Envy&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @Override     @SuppressWarnings(&quot;unchecked&quot;)     public void processElement(Object untypedElem) throws Exception {       WindowedValue elem = (WindowedValue) untypedElem;        Collection windows =           windowFn.assignWindows(               windowFn.new AssignContext() {                 @Override                 public T element() {                   return elem.getValue();                 }                  @Override                 public Instant timestamp() {                   return elem.getTimestamp();                 }                  @Override                 public BoundedWindow window() {                   return Iterables.getOnlyElement(elem.getWindows());                 }               });        WindowedValue res =           WindowedValue.of(elem.getValue(), elem.getTimestamp(), windows, elem.getPane());       receiver.process(res);     }</td>
    <td align="left">feature envy</td>
    <td align="left">blob, feature envy, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8517</td>
    <td align="left">https://github.com/apache/beam/blob/a956ff77a8448e5f2c12f6695fec608348b5ab60/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/AssignWindowsParDoFnFactory.java/#L93-L120</td>
    <td align="right">1</td>
    <td align="right">949</td>
    <td align="right">8517</td>
  </tr>
  <tr valign="top">
    <td align="right">952</td>
    <td align="left">&nbsp;{     &quot;answer&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells&quot;: [         &quot;Blob&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private ConfigurationInfo(CompositeData cd) {         this.settings = createMap(cd.get(&quot;settings&quot;));         this.name = (String) cd.get(&quot;name&quot;);         this.label = (String) cd.get(&quot;label&quot;);         this.description = (String) cd.get(&quot;description&quot;);         this.provider = (String) cd.get(&quot;provider&quot;);         this.contents = (String) cd.get(&quot;contents&quot;);     }</td>
    <td align="left">feature envy</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">8527</td>
    <td align="left">https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/jdk.management.jfr/share/classes/jdk/management/jfr/ConfigurationInfo.java/#L63-L70</td>
    <td align="right">1</td>
    <td align="right">952</td>
    <td align="right">8527</td>
  </tr>
  <tr valign="top">
    <td align="right">969</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    class Whitespace implements Text {         private String text;         public Whitespace(String text) {             this.text = text;         }         @Override         public String getText() {             return text;         }     }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">8680</td>
    <td align="left">https://github.com/eclipse/ceylon/blob/d3994d6cd120c4df85952cd9432123b413cfd65a/common/src/org/eclipse/ceylon/common/config/ConfigWriter.java/#L395-L404</td>
    <td align="right">1</td>
    <td align="right">969</td>
    <td align="right">8680</td>
  </tr>
  <tr valign="top">
    <td align="right">983</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;, &quot;Data Class&quot;]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class WSS4JInInterceptorFactory {      private Properties properties;      public Properties getProperties() {         return properties;     }      public void setProperties(Properties properties) {         this.properties = properties;     }      public WSS4JInInterceptor create() {         final Map map = new HashMap();         for (Map.Entry entry : properties.entrySet()) {             map.put(entry.getKey().toString(), entry.getValue());         }         properties.clear();         return new WSS4JInInterceptor(map);     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8862</td>
    <td align="left">https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/server/openejb-cxf/src/main/java/org/apache/openejb/server/cxf/config/WSS4JInInterceptorFactory.java/#L28-L48</td>
    <td align="right">1</td>
    <td align="right">983</td>
    <td align="right">8862</td>
  </tr>
  <tr valign="top">
    <td align="right">984</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Long Method&quot;,         &quot;Blob&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    List freevarDefs(int pos, List freevars, Symbol owner,             long additionalFlags) {         long flags = FINAL | SYNTHETIC | additionalFlags;         List defs = List.nil();         Set proxyNames = new HashSet&lt;&gt;();         for (List l = freevars; l.nonEmpty(); l = l.tail) {             VarSymbol v = l.head;             int index = 0;             Name proxyName;             do {                 proxyName = proxyName(v.name, index++);             } while (!proxyNames.add(proxyName));             VarSymbol proxy = new VarSymbol(                 flags, proxyName, v.erasure(types), owner);             proxies.put(v, proxy);             JCVariableDecl vd = make.at(pos).VarDef(proxy, null);             vd.vartype = access(vd.vartype);             defs = defs.prepend(vd);         }         return defs;     }</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8875</td>
    <td align="left">https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Lower.java/#L1457-L1477</td>
    <td align="right">1</td>
    <td align="right">984</td>
    <td align="right">8875</td>
  </tr>
  <tr valign="top">
    <td align="right">990</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private static class MigrationLink {         int source;         int target;         Migration[] migrations;         public MigrationLink(int source, int target, Migration[] migrations) {             this.source = source;             this.target = target;             this.migrations = migrations;         }     }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">9019</td>
    <td align="left">https://github.com/apache/ode/blob/b2ddc6436891f84f716ffcbed8c1cd1e374bd805/bpel-runtime/src/main/java/org/apache/ode/bpel/engine/migration/MigrationHandler.java/#L113-L122</td>
    <td align="right">1</td>
    <td align="right">990</td>
    <td align="right">9019</td>
  </tr>
  <tr valign="top">
    <td align="right">995</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
        public void startElement(String uri, String localName, String qName, Attributes attributes)                     throws SAXException {             if (delegate != null) {                 delegateStack.push(qName);                 delegate.startElement(uri, localName, qName, attributes);             } else if (domImplementation != null) {                 //domImplementation is set so we need to start a new DOM building sub-process                 TransformerHandler handler;                 try {                     handler = tFactory.newTransformerHandler();                 } catch (TransformerConfigurationException e) {                     throw new SAXException(&quot;Error creating a new TransformerHandler&quot;, e);                 }                 Document doc = domImplementation.createDocument(uri, qName, null);                 //It's easier to work with an empty document, so remove the root element                 doc.removeChild(doc.getDocumentElement());                 handler.setResult(new DOMResult(doc));                 Area parent = (Area)areaStack.peek();                 ((ForeignObject)parent).setDocument(doc);                  //activate delegate for nested foreign document                 domImplementation = null; //Not needed anymore now                 this.delegate = handler;                 delegateStack.push(qName);                 delegate.startDocument();                 delegate.startElement(uri, localName, qName, attributes);             } else {                 boolean handled = true;                 if (&quot;&quot;.equals(uri)) {                     if (localName.equals(&quot;structureTree&quot;)) {                          /* The area tree parser no longer supports the structure tree. */                         delegate = new DefaultHandler();                          delegateStack.push(qName);                         delegate.startDocument();                         delegate.startElement(uri, localName, qName, attributes);                     } else {                         handled = startAreaTreeElement(localName, attributes);                     }                 } else {                     ContentHandlerFactoryRegistry registry                             = userAgent.getContentHandlerFactoryRegistry();                     ContentHandlerFactory factory = registry.getFactory(uri);                     if (factory != null) {                         delegate = factory.createContentHandler();                         delegateStack.push(qName);                         delegate.startDocument();                         delegate.startElement(uri, localName, qName, attributes);                     } else {                         handled = false;                     }                 }                 if (!handled) {                     if (uri == null || uri.length() == 0) {                         throw new SAXException(&quot;Unhandled element &quot; + localName                                 + &quot; in namespace: &quot; + uri);                     } else {                         log.warn(&quot;Unhandled element &quot; + localName                                 + &quot; in namespace: &quot; + uri);                     }                 }             }         }</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9092</td>
    <td align="left">https://github.com/apache/fop/blob/caced35327f6b6d6eeac2a13543f3c458e902101/fop-core/src/main/java/org/apache/fop/area/AreaTreeParser.java/#L260-L323</td>
    <td align="right">1</td>
    <td align="right">995</td>
    <td align="right">9092</td>
  </tr>
  <tr valign="top">
    <td align="right">1001</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;badSmells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private static final class Reference {          private final Tree tree;         private final PropertyState property;          private Reference(Tree tree, String propertyName) {             this.tree = tree;             this.property = tree.getProperty(propertyName);         }          private boolean isMultiple() {             return property.isArray();         }          private void setProperty(String newValue) {             PropertyState prop = PropertyStates.createProperty(property.getName(), newValue, property.getType().tag());             tree.setProperty(prop);         }          private void setProperty(Iterable newValues) {             PropertyState prop = PropertyStates.createProperty(property.getName(), newValues, property.getType());             tree.setProperty(prop);         }     }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">9189</td>
    <td align="left">https://github.com/apache/jackrabbit-oak/blob/fa85f54a065e01c0a1cb8c03af74194fdf521ddd/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java/#L548-L571</td>
    <td align="right">1</td>
    <td align="right">1001</td>
    <td align="right">9189</td>
  </tr>
  <tr valign="top">
    <td align="right">1028</td>
    <td align="left">&nbsp;{       &quot;answer&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: &quot;the bad smells are: 1. Long Method, 2. Blob&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public Object doExecute() throws Exception {          Group group = groupManager.findGroupByName(groupName);         if (group == null) {             System.err.println(&quot;Cluster group &quot; + groupName + &quot; doesn't exist&quot;);             return null;         }          CellarSupport support = new CellarSupport();         support.setClusterManager(clusterManager);         support.setGroupManager(groupManager);         support.setConfigurationAdmin(configurationAdmin);          if (!in &amp;&amp; !out) {             in = true;             out = true;         }         if (!whitelist &amp;&amp; !blacklist) {             whitelist = true;             blacklist = true;         }          if (pid == null || pid.isEmpty()) {             // display mode             if (in) {                 System.out.println(&quot;INBOUND:&quot;);                 if (whitelist) {                     System.out.print(&quot;\twhitelist: &quot;);                     Set list = support.getListEntries(Configurations.WHITELIST, groupName, Constants.CATEGORY, EventType.INBOUND);                     System.out.println(list.toString());                 }                 if (blacklist) {                     System.out.print(&quot;\tblacklist: &quot;);                     Set list = support.getListEntries(Configurations.BLACKLIST, groupName, Constants.CATEGORY, EventType.INBOUND);                     System.out.println(list.toString());                 }             }             if (out) {                 System.out.println(&quot;OUTBOUND:&quot;);                 if (whitelist) {                     System.out.print(&quot;\twhitelist: &quot;);                     Set list = support.getListEntries(Configurations.WHITELIST, groupName, Constants.CATEGORY, EventType.OUTBOUND);                     System.out.println(list.toString());                 }                 if (blacklist) {                     System.out.print(&quot;\tblacklist: &quot;);                     Set list = support.getListEntries(Configurations.BLACKLIST, groupName, Constants.CATEGORY, EventType.OUTBOUND);                     System.out.println(list.toString());                 }             }         } else {             // edit mode             System.out.println(&quot;Updating blocking policy for &quot; + pid);             if (in) {                 if (whitelist) {                     System.out.println(&quot;\tinbound whitelist ...&quot;);                     support.switchListEntry(Configurations.WHITELIST, groupName, Constants.CATEGORY, EventType.INBOUND, pid);                 }                 if (blacklist) {                     System.out.println(&quot;\tinbound blacklist ...&quot;);                     support.switchListEntry(Configurations.BLACKLIST, groupName, Constants.CATEGORY, EventType.INBOUND, pid);                 }             }             if (out) {                 if (whitelist) {                     System.out.println(&quot;\toutbound whitelist ...&quot;);                     support.switchListEntry(Configurations.WHITELIST, groupName, Constants.CATEGORY, EventType.OUTBOUND, pid);                 }                 if (blacklist) {                     System.out.println(&quot;\toutbound blacklist ...&quot;);                     support.switchListEntry(Configurations.BLACKLIST, groupName, Constants.CATEGORY, EventType.OUTBOUND, pid);                 }             }         }          return null;     }</td>
    <td align="left">feature envy</td>
    <td align="left">the bad smells are: 1. long method, 2. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">the bad smells are: 1. long method,  2. blob</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">9371</td>
    <td align="left">https://github.com/apache/karaf-cellar/blob/4082b26110e56973dceb2563395f8aed3f294dd1/config/src/main/java/org/apache/karaf/cellar/config/shell/BlockCommand.java/#L56-L132</td>
    <td align="right">1</td>
    <td align="right">1028</td>
    <td align="right">9371</td>
  </tr>
  <tr valign="top">
    <td align="right">1034</td>
    <td align="left">{   &quot;response&quot;: &quot;YES I found bad smells&quot;,   &quot;bad_smells&quot;: [     &quot;Blob&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
None</td>
    <td align="left">long method</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9396</td>
    <td align="left">https://github.com/eclipse/xtext-core/blob/e04964e4c2a3e0338c0079bd8333688835e77c31/org.eclipse.xtext.testlanguages.ide/src-gen/org/eclipse/xtext/testlanguages/backtracking/ide/contentassist/antlr/internal/InternalExBeeLangTestLanguageParser.java/#L7286-L7317</td>
    <td align="right">1</td>
    <td align="right">1034</td>
    <td align="right">9396</td>
  </tr>
  <tr valign="top">
    <td align="right">1046</td>
    <td align="left">&nbsp;&nbsp;{&quot;message&quot;: &quot;YES, I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Long Method&quot;, &quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @Override     public List discoverHosts(final AddHostCmd cmd) throws IllegalArgumentException, DiscoveryException, InvalidParameterValueException {         Long dcId = cmd.getZoneId();         final Long podId = cmd.getPodId();         final Long clusterId = cmd.getClusterId();         String clusterName = cmd.getClusterName();         final String url = cmd.getUrl();         final String username = cmd.getUsername();         final String password = cmd.getPassword();         final List hostTags = cmd.getHostTags();          dcId = _accountMgr.checkAccessAndSpecifyAuthority(CallContext.current().getCallingAccount(), dcId);          // this is for standalone option         if (clusterName == null &amp;&amp; clusterId == null) {             clusterName = &quot;Standalone-&quot; + url;         }          if (clusterId != null) {             final ClusterVO cluster = _clusterDao.findById(clusterId);             if (cluster == null) {                 final InvalidParameterValueException ex = new InvalidParameterValueException(&quot;can not find cluster for specified clusterId&quot;);                 ex.addProxyObject(clusterId.toString(), &quot;clusterId&quot;);                 throw ex;             } else {                 if (cluster.getGuid() == null) {                     final List hosts = listAllHostsInCluster(clusterId);                     if (!hosts.isEmpty()) {                         final CloudRuntimeException ex =                                 new CloudRuntimeException(&quot;Guid is not updated for cluster with specified cluster id; need to wait for hosts in this cluster to come up&quot;);                         ex.addProxyObject(cluster.getUuid(), &quot;clusterId&quot;);                         throw ex;                     }                 }             }         }          return discoverHostsFull(dcId, podId, clusterId, clusterName, url, username, password, cmd.getHypervisor(), hostTags, cmd.getFullUrlParams(), false);     }</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9456</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/server/src/main/java/com/cloud/resource/ResourceManagerImpl.java/#L573-L611</td>
    <td align="right">1</td>
    <td align="right">1046</td>
    <td align="right">9456</td>
  </tr>
  <tr valign="top">
    <td align="right">1076</td>
    <td align="left">&nbsp;	{ 		&quot;output&quot;: &quot;YES I found bad smells&quot;, 		&quot;bad smells are&quot;: [ 			&quot;Blob&quot;, 			&quot;Long Method&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  @Override   public void configure(Context context) {     this.headerName = context.getString(CONFIG_MULTIPLEX_HEADER_NAME,         DEFAULT_MULTIPLEX_HEADER);      Map channelNameMap = getChannelNameMap();      defaultChannels = getChannelListFromNames(         context.getString(CONFIG_DEFAULT_CHANNEL), channelNameMap);      Map mapConfig =         context.getSubProperties(CONFIG_PREFIX_MAPPING);      channelMapping = new HashMap&gt;();      for (String headerValue : mapConfig.keySet()) {       List configuredChannels = getChannelListFromNames(           mapConfig.get(headerValue),           channelNameMap);        //This should not go to default channel(s)       //because this seems to be a bad way to configure.       if (configuredChannels.size() == 0) {         throw new FlumeException(&quot;No channel configured for when &quot;             + &quot;header value is: &quot; + headerValue);       }        if (channelMapping.put(headerValue, configuredChannels) != null) {         throw new FlumeException(&quot;Selector channel configured twice&quot;);       }     }     //If no mapping is configured, it is ok.     //All events will go to the default channel(s).     Map optionalChannelsMapping =         context.getSubProperties(CONFIG_PREFIX_OPTIONAL + &quot;.&quot;);      optionalChannels = new HashMap&gt;();     for (String hdr : optionalChannelsMapping.keySet()) {       List confChannels = getChannelListFromNames(               optionalChannelsMapping.get(hdr), channelNameMap);       if (confChannels.isEmpty()) {         confChannels = EMPTY_LIST;       }       //Remove channels from optional channels, which are already       //configured to be required channels.        List reqdChannels = channelMapping.get(hdr);       //Check if there are required channels, else defaults to default channels       if (reqdChannels == null || reqdChannels.isEmpty()) {         reqdChannels = defaultChannels;       }       for (Channel c : reqdChannels) {         if (confChannels.contains(c)) {           confChannels.remove(c);         }       }        if (optionalChannels.put(hdr, confChannels) != null) {         throw new FlumeException(&quot;Selector channel configured twice&quot;);       }     }    }</td>
    <td align="left">long method</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9643</td>
    <td align="left">https://github.com/apache/flume/blob/7d3396f26dc1541e9d2a540d50d15a15c38acb74/flume-ng-core/src/main/java/org/apache/flume/channel/MultiplexingChannelSelector.java/#L83-L145</td>
    <td align="right">1</td>
    <td align="right">1076</td>
    <td align="right">9643</td>
  </tr>
  <tr valign="top">
    <td align="right">1083</td>
    <td align="left">&nbsp;{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;Blob&quot;,     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;serialization-registration-type&quot;,     namespace = &quot;http://geode.apache.org/schema/cache&quot;,     propOrder = {&quot;serializers&quot;, &quot;instantiators&quot;}) @Experimental public class SerializationRegistrationType {    @XmlElement(name = &quot;serializer&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)   protected List serializers;   @XmlElement(name = &quot;instantiator&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)   protected List instantiators;    /**    * Gets the value of the serializer property.    *    *     * This accessor method returns a reference to the live list,    * not a snapshot. Therefore any modification you make to the    * returned list will be present inside the JAXB object.    * This is why there is not a set method for the serializer property.    *    *     * For example, to add a new item, do as follows:    *    *     * getSerializer().add(newItem);    *     *    *    *     * Objects of the following type(s) are allowed in the list    * {@link SerializationRegistrationType.Serializer }    *    *    */   public List getSerializers() {     if (serializers == null) {       serializers = new ArrayList();     }     return this.serializers;   }    /**    * Gets the value of the instantiator property.    *    *     * This accessor method returns a reference to the live list,    * not a snapshot. Therefore any modification you make to the    * returned list will be present inside the JAXB object.    * This is why there is not a set method for the instantiator property.    *    *     * For example, to add a new item, do as follows:    *    *     * getInstantiator().add(newItem);    *     *    *    *     * Objects of the following type(s) are allowed in the list    * {@link SerializationRegistrationType.Instantiator }    *    *    */   public List getInstantiators() {     if (instantiators == null) {       instantiators = new ArrayList();     }     return this.instantiators;   }     /**    *     * Java class for anonymous complex type.    *    *     * The following schema fragment specifies the expected content contained within this class.    *    *     * &lt;complexType&gt;    *   &lt;complexContent&gt;    *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;    *       &lt;sequence&gt;    *         &lt;element name=&quot;class-name&quot; type=&quot;{http://geode.apache.org/schema/cache}class-name-type&quot;/&gt;    *       &lt;/sequence&gt;    *       &lt;attribute name=&quot;id&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;    *     &lt;/restriction&gt;    *   &lt;/complexContent&gt;    * &lt;/complexType&gt;    *     *    *    */   @XmlAccessorType(XmlAccessType.FIELD)   @XmlType(name = &quot;&quot;, propOrder = {&quot;className&quot;})   public static class Instantiator {      @XmlElement(name = &quot;class-name&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;,         required = true)     protected String className;     @XmlAttribute(name = &quot;id&quot;, required = true)     protected String id;      /**      * Gets the value of the className property.      *      * possible object is      * {@link String }      *      */     public String getClassName() {       return className;     }      /**      * Sets the value of the className property.      *      * allowed object is      * {@link String }      *      */     public void setClassName(String value) {       this.className = value;     }      /**      * Gets the value of the id property.      *      * possible object is      * {@link String }      *      */     public String getId() {       return id;     }      /**      * Sets the value of the id property.      *      * allowed object is      * {@link String }      *      */     public void setId(String value) {       this.id = value;     }    }     /**    *     * Java class for anonymous complex type.    *    *     * The following schema fragment specifies the expected content contained within this class.    *    *     * &lt;complexType&gt;    *   &lt;complexContent&gt;    *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;    *       &lt;sequence&gt;    *         &lt;element name=&quot;class-name&quot; type=&quot;{http://geode.apache.org/schema/cache}class-name-type&quot;/&gt;    *       &lt;/sequence&gt;    *     &lt;/restriction&gt;    *   &lt;/complexContent&gt;    * &lt;/complexType&gt;    *     *    *    */   @XmlAccessorType(XmlAccessType.FIELD)   @XmlType(name = &quot;&quot;, propOrder = {&quot;className&quot;})   public static class Serializer {      @XmlElement(name = &quot;class-name&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;,         required = true)     protected String className;      /**      * Gets the value of the className property.      *      * possible object is      * {@link String }      *      */     public String getClassName() {       return className;     }      /**      * Sets the value of the className property.      *      * allowed object is      * {@link String }      *      */     public void setClassName(String value) {       this.className = value;     }    }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9689</td>
    <td align="left">https://github.com/apache/geode/blob/8fd839e8b73e40bd2dfd14f331b587431bd35a66/geode-management/src/main/java/org/apache/geode/cache/configuration/SerializationRegistrationType.java/#L81-L286</td>
    <td align="right">1</td>
    <td align="right">1083</td>
    <td align="right">9689</td>
  </tr>
  <tr valign="top">
    <td align="right">1097</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES, I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Blob&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ComponentRenderInfo extends BaseRenderInfo {    public static final String LAYOUT_DIFFING_ENABLED = &quot;layout_diffing_enabled&quot;;   public static final String PERSISTENCE_ENABLED = &quot;is_persistence_enabled&quot;;    private final Component mComponent;   @Nullable private final EventHandler mRenderCompleteEventHandler;    public static Builder create() {     return new Builder();   }    private ComponentRenderInfo(Builder builder) {     super(builder);      if (builder.mComponent == null) {       throw new IllegalStateException(&quot;Component must be provided.&quot;);     }      mComponent = builder.mComponent;     mRenderCompleteEventHandler = builder.mRenderCompleteEventEventHandler;   }    /** Create empty {@link ComponentRenderInfo}. */   public static RenderInfo createEmpty() {     return create().component(new EmptyComponent()).build();   }    @Override   public Component getComponent() {     return mComponent;   }    @Override   @Nullable   public EventHandler getRenderCompleteEventHandler() {     return mRenderCompleteEventHandler;   }    @Override   public boolean rendersComponent() {     return true;   }    @Override   public String getName() {     return mComponent.getSimpleName();   }    public static class Builder extends BaseRenderInfo.Builder {     private Component mComponent;     private EventHandler mRenderCompleteEventEventHandler;      /** Specify {@link Component} that will be rendered as an item of the list. */     public Builder component(Component component) {       this.mComponent = component;       return this;     }      public Builder renderCompleteHandler(         EventHandler renderCompleteEventHandler) {       this.mRenderCompleteEventEventHandler = renderCompleteEventHandler;       return this;     }      public Builder component(Component.Builder builder) {       return component(builder.build());     }      public ComponentRenderInfo build() {       return new ComponentRenderInfo(this);     }   }    private static class EmptyComponent extends Component {      protected EmptyComponent() {       super(&quot;EmptyComponent&quot;);     }      @Override     protected Component onCreateLayout(ComponentContext c) {       return Column.create(c).build();     }      @Override     public boolean isEquivalentTo(Component other) {       return EmptyComponent.this == other           || (other != null &amp;&amp; EmptyComponent.this.getClass() == other.getClass());     }   } }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">9800</td>
    <td align="left">https://github.com/facebook/litho/blob/19503b819b97e17d02f584633508dca8c646911a/litho-widget/src/main/java/com/facebook/litho/widget/ComponentRenderInfo.java/#L27-L118</td>
    <td align="right">1</td>
    <td align="right">1097</td>
    <td align="right">9800</td>
  </tr>
  <tr valign="top">
    <td align="right">1098</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class FileSinkOptionsMetadata implements ProfileNamesProvider {  	private static final String USE_SPEL_PROFILE = &quot;use-expression&quot;;  	private static final String USE_LITERAL_STRING_PROFILE = &quot;use-string&quot;;  	private boolean binary = false;  	private String charset = &quot;UTF-8&quot;;  	private String dir = &quot;/tmp/xd/output/&quot;;  	private String name = XD_STREAM_NAME;  	private String suffix = &quot;out&quot;;  	private Mode mode = APPEND;  	private String nameExpression;  	private String dirExpression;  	@NotNull 	public Mode getMode() { 		return mode; 	}  	@ModuleOption(&quot;what to do if the file already exists&quot;) 	public void setMode(Mode mode) { 		this.mode = mode; 	}  	/** 	 * Return dot + suffix if suffix is set, or the empty string otherwise. 	 */ 	public String getExtensionWithDot() { 		return StringUtils.hasText(suffix) ? &quot;.&quot; + suffix.trim() : &quot;&quot;; 	}   	@ModuleOption(&quot;filename extension to use&quot;) 	public void setSuffix(String suffix) { 		this.suffix = suffix; 	}  	public String getName() { 		return name; 	}  	@ModuleOption(&quot;filename pattern to use&quot;) 	public void setName(String name) { 		this.name = name; 	}  	@NotBlank 	public String getDir() { 		return dir; 	}  	@ModuleOption(&quot;the directory in which files will be created&quot;) 	public void setDir(String dir) { 		this.dir = dir; 	}  	public boolean isBinary() { 		return binary; 	}  	@ModuleOption(&quot;if false, will append a newline character at the end of each line&quot;) 	public void setBinary(boolean binary) { 		this.binary = binary; 	}  	@ModuleOption(&quot;the charset to use when writing a String payload&quot;) 	public void setCharset(String charset) { 		this.charset = charset; 	}  	@NotBlank 	public String getCharset() { 		return charset; 	}   	public String getNameExpression() { 		return nameExpression; 	}  	@ModuleOption(&quot;spring expression used to define filename&quot;) 	public void setNameExpression(String nameExpression) { 		this.nameExpression = nameExpression; 	}  	public String getDirExpression() { 		return dirExpression; 	}  	@ModuleOption(&quot;spring expression used to define directory name&quot;) 	public void setDirExpression(String dirExpression) { 		this.dirExpression = dirExpression; 	}  	public static enum Mode { 		APPEND, REPLACE, FAIL, IGNORE; 	}  	@Override 	public String[] profilesToActivate() { 		return (nameExpression != null || dirExpression != null) ? new String[] { USE_SPEL_PROFILE } 				: new String[] { USE_LITERAL_STRING_PROFILE }; 	} }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">9825</td>
    <td align="left">https://github.com/spring-projects/spring-xd/blob/ec106725c51d245109b2e5055d9f65e43228ecc1/spring-xd-dirt/src/main/java/org/springframework/xd/dirt/modules/metadata/FileSinkOptionsMetadata.java/#L37-L148</td>
    <td align="right">1</td>
    <td align="right">1098</td>
    <td align="right">9825</td>
  </tr>
  <tr valign="top">
    <td align="right">1101</td>
    <td align="left">&nbsp;	{     &quot;message&quot;: &quot;YES, I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Blob&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @Override     public void main(List trees) {         // complete the javac AST with a completed ceylon model         timer.startTask(&quot;prepareForTypeChecking&quot;);         prepareForTypeChecking(trees);         timer.endTask();         List javaTrees = List.nil();         List ceylonTrees = List.nil();         // split them in two sets: java and ceylon         for(JCCompilationUnit tree : trees){             if(tree instanceof CeylonCompilationUnit)                 ceylonTrees = ceylonTrees.prepend(tree);             else                 javaTrees = javaTrees.prepend(tree);         }         timer.startTask(&quot;Enter on Java trees&quot;);         boolean needsModelReset = isBootstrap;         // enter java trees first to set up their ClassSymbol objects for ceylon trees to use during type-checking         if(!javaTrees.isEmpty()){             setupImportedPackagesForJavaTrees(javaTrees);             hasJavaAndCeylonSources = true;             needsModelReset = true;         }         // this is false if we're in an APT round where we did not generate the trees         if(!compiler.isAddModuleTrees()){             setupImportedPackagesForJavaTrees(ceylonTrees);         }         if(isBootstrap || hasJavaAndCeylonSources){             super.main(trees);         }         // now we can type-check the Ceylon code         List packageInfo = completeCeylonTrees(trees);         trees = trees.prependList(packageInfo);         ceylonTrees = ceylonTrees.prependList(packageInfo);                  if(compiler.isHadRunTwiceException()){             needsModelReset = true;         }         if(needsModelReset){             // bootstrapping the language module is a bit more complex             resetAndRunEnterAgain(trees);         }else{             timer.startTask(&quot;Enter on Ceylon trees&quot;);             // and complete their new trees             try {                 sourceLanguage.push(Language.CEYLON);                 super.main(ceylonTrees);             } finally {                 sourceLanguage.pop();             }             timer.endTask();         }     }</td>
    <td align="left">long method</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">9839</td>
    <td align="left">https://github.com/eclipse/ceylon/blob/d3994d6cd120c4df85952cd9432123b413cfd65a/compiler-java/src/org/eclipse/ceylon/compiler/java/loader/CeylonEnter.java/#L203-L255</td>
    <td align="right">1</td>
    <td align="right">1101</td>
    <td align="right">9839</td>
  </tr>
  <tr valign="top">
    <td align="right">1111</td>
    <td align="left">&nbsp;{&quot;message&quot;:&quot;YES I found bad smells&quot;,&quot;bad smells are&quot;:[&quot;1. Long method&quot;,&quot;2. Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private IgniteFuture startRemoteListenAsync(BinaryRawReaderEx reader, IgniteMessaging messaging) {         Object nativeFilter = reader.readObjectDetached();          long ptr = reader.readLong();  // interop pointer          Object topic = reader.readObjectDetached();          PlatformMessageFilter filter = platformCtx.createRemoteMessageFilter(nativeFilter, ptr);          return messaging.remoteListenAsync(topic, filter);     }</td>
    <td align="left">feature envy</td>
    <td align="left">1. long method, 2. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. long method,  2. blob</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">9888</td>
    <td align="left">https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/core/src/main/java/org/apache/ignite/internal/processors/platform/messaging/PlatformMessaging.java/#L185-L195</td>
    <td align="right">1</td>
    <td align="right">1111</td>
    <td align="right">9888</td>
  </tr>
  <tr valign="top">
    <td align="right">1140</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             &quot;Blob&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	protected void transform(XtendConstructor source, JvmGenericType container) { 		JvmConstructor constructor = typesFactory.createJvmConstructor(); 		container.getMembers().add(constructor); 		associator.associatePrimary(source, constructor); 		JvmVisibility visibility = source.getVisibility(); 		constructor.setSimpleName(container.getSimpleName()); 		constructor.setVisibility(visibility); 		for (XtendParameter parameter : source.getParameters()) { 			translateParameter(constructor, parameter); 		} 		copyAndFixTypeParameters(source.getTypeParameters(), constructor); 		for (JvmTypeReference exception : source.getExceptions()) { 			constructor.getExceptions().add(jvmTypesBuilder.cloneWithProxies(exception)); 		} 		translateAnnotationsTo(source.getAnnotations(), constructor); 		setBody(constructor, source.getExpression()); 		jvmTypesBuilder.copyDocumentationTo(source, constructor); 	}</td>
    <td align="left">long method</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10089</td>
    <td align="left">https://github.com/eclipse/xtext-xtend/blob/20500a324127e3ee73cb793a13430ee140246fa7/org.eclipse.xtend.core/src/org/eclipse/xtend/core/jvmmodel/XtendJvmModelInferrer.java/#L721-L738</td>
    <td align="right">1</td>
    <td align="right">1140</td>
    <td align="right">10089</td>
  </tr>
  <tr valign="top">
    <td align="right">1169</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Long Method&quot;,             &quot;Blob&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public static Dataset[] generateCoordinates(Dataset angles, final double[] geometricParameters) { 		if (geometricParameters.length != PARAMETERS) 			throw new IllegalArgumentException(&quot;Need &quot; + PARAMETERS + &quot; parameters&quot;);  		Dataset[] coords = new Dataset[2];  		DoubleDataset x = DatasetFactory.zeros(DoubleDataset.class, angles.getShape()); 		DoubleDataset y = DatasetFactory.zeros(DoubleDataset.class, angles.getShape()); 		coords[0] = x; 		coords[1] = y;  		final double ca = Math.cos(geometricParameters[2]); 		final double sa = Math.sin(geometricParameters[2]); 		final IndexIterator it = angles.getIterator();  		int i = 0; 		 		while (it.hasNext()) { 			final double t = angles.getElementDoubleAbs(it.index); 			final double ct = Math.cos(t); 			final double st = Math.sin(t); 			x.setAbs(i, geometricParameters[3] + geometricParameters[0]*ca*ct - geometricParameters[1]*sa*st); 			y.setAbs(i, geometricParameters[4] + geometricParameters[0]*sa*ct + geometricParameters[1]*ca*st); 			i++; 		} 		return coords; 	}</td>
    <td align="left">feature envy</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method,  blob</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">10192</td>
    <td align="left">https://github.com/eclipse/dawnsci/blob/1131d5c65e9e8ea98141eecee1743cf1053544f4/org.eclipse.dawnsci.analysis.dataset/src/org/eclipse/dawnsci/analysis/dataset/roi/fitting/EllipseFitter.java/#L486-L512</td>
    <td align="right">1</td>
    <td align="right">1169</td>
    <td align="right">10192</td>
  </tr>
  <tr valign="top">
    <td align="right">1195</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @Override     public long exportTo(final ContentClaim claim, final Path destination, final boolean append, final long offset, final long length) throws IOException {         if (claim == null) {             if (append) {                 return 0L;             }             Files.createFile(destination);             return 0L;         }          final StandardOpenOption openOption = append ? StandardOpenOption.APPEND : StandardOpenOption.CREATE;         try (final InputStream in = read(claim);                 final OutputStream destinationStream = Files.newOutputStream(destination, openOption)) {              if (offset &gt; 0) {                 StreamUtils.skip(in, offset);             }              StreamUtils.copy(in, destinationStream, length);             return length;         }     }</td>
    <td align="left">feature envy</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method,  blob</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">10266</td>
    <td align="left">https://github.com/apache/nifi/blob/c8eff590efa3babcda0b755009224dcac168708b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/repository/VolatileContentRepository.java/#L397-L418</td>
    <td align="right">1</td>
    <td align="right">1195</td>
    <td align="right">10266</td>
  </tr>
  <tr valign="top">
    <td align="right">1209</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells the bad smells are: 1. Long Method, 2. Blob&quot; }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@UriEndpoint(firstVersion = &quot;2.1.0&quot;, scheme = &quot;quickfix&quot;, title = &quot;QuickFix&quot;, syntax = &quot;quickfix:configurationName&quot;, label = &quot;messaging&quot;) public class QuickfixjEndpoint extends DefaultEndpoint implements QuickfixjEventListener, MultipleConsumersSupport {     public static final String EVENT_CATEGORY_KEY = &quot;EventCategory&quot;;     public static final String SESSION_ID_KEY = &quot;SessionID&quot;;     public static final String MESSAGE_TYPE_KEY = &quot;MessageType&quot;;     public static final String DATA_DICTIONARY_KEY = &quot;DataDictionary&quot;;      private final QuickfixjEngine engine;     private final List consumers = new CopyOnWriteArrayList&lt;&gt;();      @UriPath @Metadata(required = true)     private String configurationName;     @UriParam     private SessionID sessionID;     @UriParam     private boolean lazyCreateEngine;      public QuickfixjEndpoint(QuickfixjEngine engine, String uri, Component component) {         super(uri, component);         this.engine = engine;     }      public SessionID getSessionID() {         return sessionID;     }      /**      * The optional sessionID identifies a specific FIX session. The format of the sessionID is:      * (BeginString):(SenderCompID)[/(SenderSubID)[/(SenderLocationID)]]-&gt;(TargetCompID)[/(TargetSubID)[/(TargetLocationID)]]      */     public void setSessionID(SessionID sessionID) {         this.sessionID = sessionID;     }      public String getConfigurationName() {         return configurationName;     }      /**      * The configFile is the name of the QuickFIX/J configuration to use for the FIX engine (located as a resource found in your classpath).      */     public void setConfigurationName(String configurationName) {         this.configurationName = configurationName;     }      public boolean isLazyCreateEngine() {         return lazyCreateEngine;     }      /**      * This option allows to create QuickFIX/J engine on demand.      * Value true means the engine is started when first message is send or there's consumer configured in route definition.      * When false value is used, the engine is started at the endpoint creation.      * When this parameter is missing, the value of component's property lazyCreateEngines is being used.      */     public void setLazyCreateEngine(boolean lazyCreateEngine) {         this.lazyCreateEngine = lazyCreateEngine;     }      @Override     public Consumer createConsumer(Processor processor) throws Exception {         log.info(&quot;Creating QuickFIX/J consumer: {}, ExchangePattern={}&quot;, sessionID != null ? sessionID : &quot;No Session&quot;, getExchangePattern());         QuickfixjConsumer consumer = new QuickfixjConsumer(this, processor);         configureConsumer(consumer);         consumers.add(consumer);         return consumer;     }      @Override     public Producer createProducer() throws Exception {         log.info(&quot;Creating QuickFIX/J producer: {}&quot;, sessionID != null ? sessionID : &quot;No Session&quot;);         if (isWildcarded()) {             throw new ResolveEndpointFailedException(&quot;Cannot create consumer on wildcarded session identifier: &quot; + sessionID);         }         return new QuickfixjProducer(this);     }      @Override     public boolean isSingleton() {         return true;     }      @Override     public void onEvent(QuickfixjEventCategory eventCategory, SessionID sessionID, Message message) throws Exception {         if (this.sessionID == null || isMatching(sessionID)) {             for (QuickfixjConsumer consumer : consumers) {                 Exchange exchange = QuickfixjConverters.toExchange(this, sessionID, message, eventCategory, getExchangePattern());                 consumer.onExchange(exchange);                 if (exchange.getException() != null) {                     throw exchange.getException();                 }             }         }     }      private boolean isMatching(SessionID sessionID) {         if (this.sessionID.equals(sessionID)) {             return true;         }         return isMatching(this.sessionID.getBeginString(), sessionID.getBeginString())             &amp;&amp; isMatching(this.sessionID.getSenderCompID(), sessionID.getSenderCompID())             &amp;&amp; isMatching(this.sessionID.getSenderSubID(), sessionID.getSenderSubID())             &amp;&amp; isMatching(this.sessionID.getSenderLocationID(), sessionID.getSenderLocationID())             &amp;&amp; isMatching(this.sessionID.getTargetCompID(), sessionID.getTargetCompID())             &amp;&amp; isMatching(this.sessionID.getTargetSubID(), sessionID.getTargetSubID())              &amp;&amp; isMatching(this.sessionID.getTargetLocationID(), sessionID.getTargetLocationID());     }      private boolean isMatching(String s1, String s2) {         return s1.equals(&quot;&quot;) || s1.equals(&quot;*&quot;) || s1.equals(s2);     }      private boolean isWildcarded() {         if (sessionID == null) {             return false;         }         return sessionID.getBeginString().equals(&quot;*&quot;)             || sessionID.getSenderCompID().equals(&quot;*&quot;)             || sessionID.getSenderSubID().equals(&quot;*&quot;)             || sessionID.getSenderLocationID().equals(&quot;*&quot;)             || sessionID.getTargetCompID().equals(&quot;*&quot;)             || sessionID.getTargetSubID().equals(&quot;*&quot;)             || sessionID.getTargetLocationID().equals(&quot;*&quot;);     }      @Override     public boolean isMultipleConsumersSupported() {         return true;     }      /**      * Initializing and starts the engine if it wasn't initialized so far.      */     public void ensureInitialized() throws Exception {         if (!engine.isInitialized()) {             synchronized (engine) {                 if (!engine.isInitialized()) {                     engine.initializeEngine();                     engine.start();                 }             }         }     }      public QuickfixjEngine getEngine() {         return engine;     }          @Override     protected void doStop() throws Exception {         // clear list of consumers         consumers.clear();     } }</td>
    <td align="left">data class</td>
    <td align="left">1. long method, 2. blob </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. long method,  2. blob </td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">10306</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-quickfix/src/main/java/org/apache/camel/component/quickfixj/QuickfixjEndpoint.java/#L41-L194</td>
    <td align="right">1</td>
    <td align="right">1209</td>
    <td align="right">10306</td>
  </tr>
  <tr valign="top">
    <td align="right">1215</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{             &quot;message&quot;: &quot;YES I found bad smells&quot;,             &quot;detected_bad_smells&quot;: [                 &quot;Blob&quot;,                 &quot;Data Class&quot;             ]         }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
        // System.out.println(&quot;        skip rewind!&quot;);         // }       }       assert length == f.prefix;       assert termOrd == f.termOrdOrig;     } else {       f.nextEnt = -1;       f.prefix = length;       f.state.termBlockOrd = 0;       f.termOrdOrig = termOrd;       // System.out.println(&quot;set termOrdOrig=&quot; + termOrd);       f.termOrd = termOrd;       f.fpOrig = f.fp = fp;       f.lastSubFP = -1;       // if (DEBUG) {       //   final int sav = term.length;       //   term.length = length;       //   System.out.println(&quot;      push new frame ord=&quot; + f.ord + &quot; fp=&quot; + f.fp + &quot; hasTerms=&quot; + f.hasTerms + &quot; isFloor=&quot; + f.isFloor + &quot; pref=&quot; + brToString(term));       //   term.length = sav;       // }     }      return f;   }    // asserts only   private boolean clearEOF() {     eof = false;     return true;   }    // asserts only   private boolean setEOF() {     eof = true;     return true;</td>
    <td align="left">long method</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  data class</td>
    <td align="left">long method</td>
    <td align="right">0</td>
    <td align="right">10318</td>
    <td align="left">https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnum.java/#L174-L208</td>
    <td align="right">1</td>
    <td align="right">1215</td>
    <td align="right">10318</td>
  </tr>
  <tr valign="top">
    <td align="right">1239</td>
    <td align="left">{      &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Long Method&quot;,         &quot;Blob&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public boolean equals(TListSentryPrivilegesRequest that) {     if (that == null)       return false;      boolean this_present_protocol_version = true;     boolean that_present_protocol_version = true;     if (this_present_protocol_version || that_present_protocol_version) {       if (!(this_present_protocol_version &amp;&amp; that_present_protocol_version))         return false;       if (this.protocol_version != that.protocol_version)         return false;     }      boolean this_present_requestorUserName = true &amp;&amp; this.isSetRequestorUserName();     boolean that_present_requestorUserName = true &amp;&amp; that.isSetRequestorUserName();     if (this_present_requestorUserName || that_present_requestorUserName) {       if (!(this_present_requestorUserName &amp;&amp; that_present_requestorUserName))         return false;       if (!this.requestorUserName.equals(that.requestorUserName))         return false;     }      boolean this_present_roleName = true &amp;&amp; this.isSetRoleName();     boolean that_present_roleName = true &amp;&amp; that.isSetRoleName();     if (this_present_roleName || that_present_roleName) {       if (!(this_present_roleName &amp;&amp; that_present_roleName))         return false;       if (!this.roleName.equals(that.roleName))         return false;     }      boolean this_present_authorizableHierarchy = true &amp;&amp; this.isSetAuthorizableHierarchy();     boolean that_present_authorizableHierarchy = true &amp;&amp; that.isSetAuthorizableHierarchy();     if (this_present_authorizableHierarchy || that_present_authorizableHierarchy) {       if (!(this_present_authorizableHierarchy &amp;&amp; that_present_authorizableHierarchy))         return false;       if (!this.authorizableHierarchy.equals(that.authorizableHierarchy))         return false;     }      return true;   }</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10404</td>
    <td align="left">https://github.com/apache/incubator-sentry/blob/4643f988a5e0ce2b9749e6365edea3a16482de86/sentry-provider/sentry-provider-db/src/gen/thrift/gen-javabean/org/apache/sentry/provider/db/service/thrift/TListSentryPrivilegesRequest.java/#L360-L401</td>
    <td align="right">1</td>
    <td align="right">1239</td>
    <td align="right">10404</td>
  </tr>
  <tr valign="top">
    <td align="right">1242</td>
    <td align="left">&nbsp;&nbsp;&nbsp;	{   		&quot;message&quot;: &quot;YES, I found bad smells&quot;,   		&quot;detected_bad_smells&quot;: [   			&quot;1. Blob&quot;,   			&quot;2. Data Class&quot;   		]   	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class NexmarkQueryTransform     extends PTransform, PCollection&gt; {    private transient PCollection&gt; sideInput = null;    protected NexmarkQueryTransform(String name) {     super(name);   }    /** Whether this query expects a side input to be populated. Defaults to {@code false}. */   public boolean needsSideInput() {     return false;   }    /**    * Set the side input for the query.    *    * Note that due to the nature of side inputs, this instance of the query is now fixed and can    * only be safely applied in the pipeline where the side input was created.    */   public void setSideInput(PCollection&gt; sideInput) {     this.sideInput = sideInput;   }    /** Get the side input, if any. */   public @Nullable PCollection&gt; getSideInput() {     return sideInput;   } }</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10414</td>
    <td align="left">https://github.com/apache/beam/blob/a956ff77a8448e5f2c12f6695fec608348b5ab60/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/NexmarkQueryTransform.java/#L34-L62</td>
    <td align="right">1</td>
    <td align="right">1242</td>
    <td align="right">10414</td>
  </tr>
  <tr valign="top">
    <td align="right">1245</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Ipam {   private String driver;   private List config;   private Map options;    public String getDriver() {     return driver;   }    public void setDriver(String driver) {     this.driver = driver;   }    public Ipam withDriver(String driver) {     this.driver = driver;     return this;   }    public List getConfig() {     return config;   }    public void setConfig(List config) {     this.config = config;   }    public Ipam withConfig(List config) {     this.config = config;     return this;   }    public Map getOptions() {     return options;   }    public void setOptions(Map options) {     this.options = options;   }    public Ipam withOptions(Map options) {     this.options = options;     return this;   }    @Override   public boolean equals(Object obj) {     if (this == obj) {       return true;     }     if (!(obj instanceof Ipam)) {       return false;     }     final Ipam that = (Ipam) obj;     return Objects.equals(driver, that.driver)         &amp;&amp; getConfig().equals(that.getConfig())         &amp;&amp; getOptions().equals(that.getOptions());   }    @Override   public int hashCode() {     int hash = 7;     hash = 31 * hash + Objects.hashCode(driver);     hash = 31 * hash + getConfig().hashCode();     hash = 31 * hash + getOptions().hashCode();     return hash;   }    @Override   public String toString() {     return &quot;Ipam{&quot;         + &quot;driver='&quot;         + driver         + '\''         + &quot;, config=&quot;         + config         + &quot;, options=&quot;         + options         + '}';   } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10419</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/infrastructures/docker/docker-client/src/main/java/org/eclipse/che/infrastructure/docker/client/json/network/Ipam.java/#L19-L98</td>
    <td align="right">1</td>
    <td align="right">1245</td>
    <td align="right">10419</td>
  </tr>
  <tr valign="top">
    <td align="right">1250</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Blob&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;faces-config-propertyType&quot;, propOrder = {     &quot;descriptions&quot;,     &quot;displayNames&quot;,     &quot;icon&quot;,     &quot;propertyName&quot;,     &quot;propertyClass&quot;,     &quot;defaultValue&quot;,     &quot;suggestedValue&quot;,     &quot;propertyExtension&quot; }) public class FacesProperty {      @XmlTransient     protected TextMap description = new TextMap();     @XmlTransient     protected TextMap displayName = new TextMap();     @XmlElement(name = &quot;icon&quot;, required = true)     protected LocalCollection icon = new LocalCollection();     @XmlElement(name = &quot;property-name&quot;, required = true)     protected java.lang.String propertyName;     @XmlElement(name = &quot;property-class&quot;, required = true)     protected java.lang.String propertyClass;     @XmlElement(name = &quot;default-value&quot;)     protected java.lang.String defaultValue;     @XmlElement(name = &quot;suggested-value&quot;)     protected java.lang.String suggestedValue;     @XmlElement(name = &quot;property-extension&quot;)     protected List propertyExtension;     @XmlAttribute     @XmlJavaTypeAdapter(CollapsedStringAdapter.class)     @XmlID     @XmlSchemaType(name = &quot;ID&quot;)     protected java.lang.String id;      @XmlElement(name = &quot;description&quot;, required = true)     public Text[] getDescriptions() {         return description.toArray();     }      public void setDescriptions(Text[] text) {         description.set(text);     }      public String getDescription() {         return description.get();     }      @XmlElement(name = &quot;display-name&quot;, required = true)     public Text[] getDisplayNames() {         return displayName.toArray();     }      public void setDisplayNames(Text[] text) {         displayName.set(text);     }      public String getDisplayName() {         return displayName.get();     }      public Collection getIcons() {         if (icon == null) {             icon = new LocalCollection();         }         return icon;     }      public Map getIconMap() {         if (icon == null) {             icon = new LocalCollection();         }         return icon.toMap();     }      public Icon getIcon() {         return icon.getLocal();     }      /**      * Gets the value of the propertyName property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getPropertyName() {         return propertyName;     }      /**      * Sets the value of the propertyName property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setPropertyName(java.lang.String value) {         this.propertyName = value;     }      /**      * Gets the value of the propertyClass property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getPropertyClass() {         return propertyClass;     }      /**      * Sets the value of the propertyClass property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setPropertyClass(java.lang.String value) {         this.propertyClass = value;     }      /**      * Gets the value of the defaultValue property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getDefaultValue() {         return defaultValue;     }      /**      * Sets the value of the defaultValue property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setDefaultValue(java.lang.String value) {         this.defaultValue = value;     }      /**      * Gets the value of the suggestedValue property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getSuggestedValue() {         return suggestedValue;     }      /**      * Sets the value of the suggestedValue property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setSuggestedValue(java.lang.String value) {         this.suggestedValue = value;     }      /**      * Gets the value of the propertyExtension property.      *       *       * This accessor method returns a reference to the live list,      * not a snapshot. Therefore any modification you make to the      * returned list will be present inside the JAXB object.      * This is why there is not a set method for the propertyExtension property.      *       *       * For example, to add a new item, do as follows:      *       *    getPropertyExtension().add(newItem);      *       *       *       *       * Objects of the following type(s) are allowed in the list      * {@link FacesPropertyExtension }      *       *       */     public List getPropertyExtension() {         if (propertyExtension == null) {             propertyExtension = new ArrayList();         }         return this.propertyExtension;     }      /**      * Gets the value of the id property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getId() {         return id;     }      /**      * Sets the value of the id property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setId(java.lang.String value) {         this.id = value;     }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10436</td>
    <td align="left">https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/container/openejb-jee/src/main/java/org/apache/openejb/jee/FacesProperty.java/#L70-L298</td>
    <td align="right">1</td>
    <td align="right">1250</td>
    <td align="right">10436</td>
  </tr>
  <tr valign="top">
    <td align="right">1253</td>
    <td align="left">{&quot;response&quot;: &quot;YES, I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;EObject&quot;, propOrder = { &quot;extensions&quot; }) public class EObject {  	@XmlElement(name = &quot;Extension&quot;, namespace = &quot;http://www.omg.org/XMI&quot;) 	protected List extensions; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	@XmlJavaTypeAdapter(CollapsedStringAdapter.class) 	@XmlID 	protected String id; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected QName type; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected String version; 	@XmlAttribute 	protected String href; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	@XmlIDREF 	protected Object idref; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected String label; 	@XmlAttribute(namespace = &quot;http://www.omg.org/XMI&quot;) 	protected String uuid;  	/** 	 * Gets the value of the extensions property. 	 *  	 *  	 * This accessor method returns a reference to the live list, not a 	 * snapshot. Therefore any modification you make to the returned list will 	 * be present inside the JAXB object. This is why there is not a 	 * set method for the extensions property. 	 *  	 *  	 * For example, to add a new item, do as follows: 	 *  	 *  	 * getExtensions().add(newItem); 	 *  	 *  	 *  	 *  	 * Objects of the following type(s) are allowed in the list 	 * {@link Extension } 	 *  	 *  	 */ 	public List getExtensions() { 		if (extensions == null) { 			extensions = new ArrayList(); 		} 		return this.extensions; 	}  	/** 	 * Gets the value of the id property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getId() { 		return id; 	}  	/** 	 * Sets the value of the id property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setId(String value) { 		this.id = value; 	}  	/** 	 * Gets the value of the type property. 	 *  	 * @return possible object is {@link QName } 	 *  	 */ 	public QName getType() { 		return type; 	}  	/** 	 * Sets the value of the type property. 	 *  	 * @param value 	 *            allowed object is {@link QName } 	 *  	 */ 	public void setType(QName value) { 		this.type = value; 	}  	/** 	 * Gets the value of the version property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getVersion() { 		if (version == null) { 			return &quot;2.0&quot;; 		} else { 			return version; 		} 	}  	/** 	 * Sets the value of the version property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setVersion(String value) { 		this.version = value; 	}  	/** 	 * Gets the value of the href property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getHref() { 		return href; 	}  	/** 	 * Sets the value of the href property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setHref(String value) { 		this.href = value; 	}  	/** 	 * Gets the value of the idref property. 	 *  	 * @return possible object is {@link Object } 	 *  	 */ 	public Object getIdref() { 		return idref; 	}  	/** 	 * Sets the value of the idref property. 	 *  	 * @param value 	 *            allowed object is {@link Object } 	 *  	 */ 	public void setIdref(Object value) { 		this.idref = value; 	}  	/** 	 * Gets the value of the label property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getLabel() { 		return label; 	}  	/** 	 * Sets the value of the label property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setLabel(String value) { 		this.label = value; 	}  	/** 	 * Gets the value of the uuid property. 	 *  	 * @return possible object is {@link String } 	 *  	 */ 	public String getUuid() { 		return uuid; 	}  	/** 	 * Sets the value of the uuid property. 	 *  	 * @param value 	 *            allowed object is {@link String } 	 *  	 */ 	public void setUuid(String value) { 		this.uuid = value; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">10456</td>
    <td align="left">https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/container/openejb-jee/src/main/java/org/apache/openejb/jee/was/v6/ecore/EObject.java/#L57-L262</td>
    <td align="right">1</td>
    <td align="right">1253</td>
    <td align="right">10456</td>
  </tr>
  <tr valign="top">
    <td align="right">1257</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Blob&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;faces-config-propertyType&quot;, propOrder = {     &quot;descriptions&quot;,     &quot;displayNames&quot;,     &quot;icon&quot;,     &quot;propertyName&quot;,     &quot;propertyClass&quot;,     &quot;defaultValue&quot;,     &quot;suggestedValue&quot;,     &quot;propertyExtension&quot; }) public class FacesProperty {      @XmlTransient     protected TextMap description = new TextMap();     @XmlTransient     protected TextMap displayName = new TextMap();     @XmlElement(name = &quot;icon&quot;, required = true)     protected LocalCollection icon = new LocalCollection();     @XmlElement(name = &quot;property-name&quot;, required = true)     protected java.lang.String propertyName;     @XmlElement(name = &quot;property-class&quot;, required = true)     protected java.lang.String propertyClass;     @XmlElement(name = &quot;default-value&quot;)     protected java.lang.String defaultValue;     @XmlElement(name = &quot;suggested-value&quot;)     protected java.lang.String suggestedValue;     @XmlElement(name = &quot;property-extension&quot;)     protected List propertyExtension;     @XmlAttribute     @XmlJavaTypeAdapter(CollapsedStringAdapter.class)     @XmlID     @XmlSchemaType(name = &quot;ID&quot;)     protected java.lang.String id;      @XmlElement(name = &quot;description&quot;, required = true)     public Text[] getDescriptions() {         return description.toArray();     }      public void setDescriptions(Text[] text) {         description.set(text);     }      public String getDescription() {         return description.get();     }      @XmlElement(name = &quot;display-name&quot;, required = true)     public Text[] getDisplayNames() {         return displayName.toArray();     }      public void setDisplayNames(Text[] text) {         displayName.set(text);     }      public String getDisplayName() {         return displayName.get();     }      public Collection getIcons() {         if (icon == null) {             icon = new LocalCollection();         }         return icon;     }      public Map getIconMap() {         if (icon == null) {             icon = new LocalCollection();         }         return icon.toMap();     }      public Icon getIcon() {         return icon.getLocal();     }      /**      * Gets the value of the propertyName property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getPropertyName() {         return propertyName;     }      /**      * Sets the value of the propertyName property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setPropertyName(java.lang.String value) {         this.propertyName = value;     }      /**      * Gets the value of the propertyClass property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getPropertyClass() {         return propertyClass;     }      /**      * Sets the value of the propertyClass property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setPropertyClass(java.lang.String value) {         this.propertyClass = value;     }      /**      * Gets the value of the defaultValue property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getDefaultValue() {         return defaultValue;     }      /**      * Sets the value of the defaultValue property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setDefaultValue(java.lang.String value) {         this.defaultValue = value;     }      /**      * Gets the value of the suggestedValue property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getSuggestedValue() {         return suggestedValue;     }      /**      * Sets the value of the suggestedValue property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setSuggestedValue(java.lang.String value) {         this.suggestedValue = value;     }      /**      * Gets the value of the propertyExtension property.      *       *       * This accessor method returns a reference to the live list,      * not a snapshot. Therefore any modification you make to the      * returned list will be present inside the JAXB object.      * This is why there is not a set method for the propertyExtension property.      *       *       * For example, to add a new item, do as follows:      *       *    getPropertyExtension().add(newItem);      *       *       *       *       * Objects of the following type(s) are allowed in the list      * {@link FacesPropertyExtension }      *       *       */     public List getPropertyExtension() {         if (propertyExtension == null) {             propertyExtension = new ArrayList();         }         return this.propertyExtension;     }      /**      * Gets the value of the id property.      *       * @return      *     possible object is      *     {@link java.lang.String }      *           */     public java.lang.String getId() {         return id;     }      /**      * Sets the value of the id property.      *       * @param value      *     allowed object is      *     {@link java.lang.String }      *           */     public void setId(java.lang.String value) {         this.id = value;     }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10498</td>
    <td align="left">https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/container/openejb-jee/src/main/java/org/apache/openejb/jee/FacesProperty.java/#L70-L298</td>
    <td align="right">1</td>
    <td align="right">1257</td>
    <td align="right">10498</td>
  </tr>
  <tr valign="top">
    <td align="right">1260</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Blob&quot;,       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  @XmlAccessorType(XmlAccessType.FIELD)   @XmlType(name = &quot;&quot;, propOrder = {&quot;gateways&quot;})   public static class GatewayHub {      @XmlElement(name = &quot;gateway&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)     protected List gateways;     @XmlAttribute(name = &quot;id&quot;, required = true)     protected String id;     @XmlAttribute(name = &quot;bind-address&quot;)     protected String bindAddress;     @XmlAttribute(name = &quot;maximum-time-between-pings&quot;)     protected String maximumTimeBetweenPings;     @XmlAttribute(name = &quot;port&quot;)     protected String port;     @XmlAttribute(name = &quot;socket-buffer-size&quot;)     protected String socketBufferSize;     @XmlAttribute(name = &quot;startup-policy&quot;)     protected String startupPolicy;     @XmlAttribute(name = &quot;manual-start&quot;)     protected Boolean manualStart;     @XmlAttribute(name = &quot;max-connections&quot;)     protected BigInteger maxConnections;      /**      * Gets the value of the gateway property.      *      *       * This accessor method returns a reference to the live list,      * not a snapshot. Therefore any modification you make to the      * returned list will be present inside the JAXB object.      * This is why there is not a set method for the gateway property.      *      *       * For example, to add a new item, do as follows:      *      *       * getGateway().add(newItem);      *       *      *      *       * Objects of the following type(s) are allowed in the list      * {@link CacheConfig.GatewayHub.Gateway }      *      *      */     public List getGateway() {       if (gateways == null) {         gateways = new ArrayList();       }       return this.gateways;     }      /**      * Gets the value of the id property.      *      * possible object is      * {@link String }      *      */     public String getId() {       return id;     }      /**      * Sets the value of the id property.      *      * allowed object is      * {@link String }      *      */     public void setId(String value) {       this.id = value;     }      /**      * Gets the value of the bindAddress property.      *      * possible object is      * {@link String }      *      */     public String getBindAddress() {       return bindAddress;     }      /**      * Sets the value of the bindAddress property.      *      * allowed object is      * {@link String }      *      */     public void setBindAddress(String value) {       this.bindAddress = value;     }      /**      * Gets the value of the maximumTimeBetweenPings property.      *      * possible object is      * {@link String }      *      */     public String getMaximumTimeBetweenPings() {       return maximumTimeBetweenPings;     }      /**      * Sets the value of the maximumTimeBetweenPings property.      *      * allowed object is      * {@link String }      *      */     public void setMaximumTimeBetweenPings(String value) {       this.maximumTimeBetweenPings = value;     }      /**      * Gets the value of the port property.      *      * possible object is      * {@link String }      *      */     public String getPort() {       return port;     }      /**      * Sets the value of the port property.      *      * allowed object is      * {@link String }      *      */     public void setPort(String value) {       this.port = value;     }      /**      * Gets the value of the socketBufferSize property.      *      * possible object is      * {@link String }      *      */     public String getSocketBufferSize() {       return socketBufferSize;     }      /**      * Sets the value of the socketBufferSize property.      *      * allowed object is      * {@link String }      *      */     public void setSocketBufferSize(String value) {       this.socketBufferSize = value;     }      /**      * Gets the value of the startupPolicy property.      *      * possible object is      * {@link String }      *      */     public String getStartupPolicy() {       return startupPolicy;     }      /**      * Sets the value of the startupPolicy property.      *      * allowed object is      * {@link String }      *      */     public void setStartupPolicy(String value) {       this.startupPolicy = value;     }      /**      * Gets the value of the manualStart property.      *      * possible object is      * {@link Boolean }      *      */     public Boolean isManualStart() {       return manualStart;     }      /**      * Sets the value of the manualStart property.      *      * allowed object is      * {@link Boolean }      *      */     public void setManualStart(Boolean value) {       this.manualStart = value;     }      /**      * Gets the value of the maxConnections property.      *      * possible object is      * {@link BigInteger }      *      */     public BigInteger getMaxConnections() {       return maxConnections;     }      /**      * Sets the value of the maxConnections property.      *      * allowed object is      * {@link BigInteger }      *      */     public void setMaxConnections(BigInteger value) {       this.maxConnections = value;     }       /**      *       * Java class for anonymous complex type.      *      *       * The following schema fragment specifies the expected content contained within this class.      *      *       * &lt;complexType&gt;      *   &lt;complexContent&gt;      *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;      *       &lt;sequence&gt;      *         &lt;choice&gt;      *           &lt;element name=&quot;gateway-endpoint&quot; maxOccurs=&quot;unbounded&quot;&gt;      *             &lt;complexType&gt;      *               &lt;complexContent&gt;      *                 &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;      *                   &lt;attribute name=&quot;host&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                   &lt;attribute name=&quot;id&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                   &lt;attribute name=&quot;port&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;/restriction&gt;      *               &lt;/complexContent&gt;      *             &lt;/complexType&gt;      *           &lt;/element&gt;      *           &lt;element name=&quot;gateway-listener&quot; maxOccurs=&quot;unbounded&quot;&gt;      *             &lt;complexType&gt;      *               &lt;complexContent&gt;      *                 &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;      *                   &lt;sequence&gt;      *                     &lt;element name=&quot;class-name&quot; type=&quot;{http://geode.apache.org/schema/cache}class-name-type&quot;/&gt;      *                     &lt;element name=&quot;parameter&quot; type=&quot;{http://geode.apache.org/schema/cache}parameter-type&quot; maxOccurs=&quot;unbounded&quot; minOccurs=&quot;0&quot;/&gt;      *                   &lt;/sequence&gt;      *                 &lt;/restriction&gt;      *               &lt;/complexContent&gt;      *             &lt;/complexType&gt;      *           &lt;/element&gt;      *         &lt;/choice&gt;      *         &lt;element name=&quot;gateway-queue&quot; minOccurs=&quot;0&quot;&gt;      *           &lt;complexType&gt;      *             &lt;complexContent&gt;      *               &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;      *                 &lt;attribute name=&quot;alert-threshold&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;batch-conflation&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;      *                 &lt;attribute name=&quot;batch-size&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;batch-time-interval&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;enable-persistence&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;      *                 &lt;attribute name=&quot;disk-store-name&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;roll-oplogs&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;      *                 &lt;attribute name=&quot;maximum-queue-memory&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *                 &lt;attribute name=&quot;overflow-directory&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *               &lt;/restriction&gt;      *             &lt;/complexContent&gt;      *           &lt;/complexType&gt;      *         &lt;/element&gt;      *       &lt;/sequence&gt;      *       &lt;attribute name=&quot;early-ack&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;      *       &lt;attribute name=&quot;id&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *       &lt;attribute name=&quot;socket-buffer-size&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *       &lt;attribute name=&quot;socket-read-timeout&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *       &lt;attribute name=&quot;concurrency-level&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *       &lt;attribute name=&quot;order-policy&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;      *     &lt;/restriction&gt;      *   &lt;/complexContent&gt;      * &lt;/complexType&gt;      *       *      *      */     @XmlAccessorType(XmlAccessType.FIELD)     @XmlType(name = &quot;&quot;, propOrder = {&quot;gatewayEndpoints&quot;, &quot;gatewayListeners&quot;, &quot;gatewayQueue&quot;})     public static class Gateway {        @XmlElement(name = &quot;gateway-endpoint&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)       protected List gatewayEndpoints;       @XmlElement(name = &quot;gateway-listener&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)       protected List gatewayListeners;       @XmlElement(name = &quot;gateway-queue&quot;, namespace = &quot;http://geode.apache.org/schema/cache&quot;)       protected CacheConfig.GatewayHub.Gateway.GatewayQueue gatewayQueue;       @XmlAttribute(name = &quot;early-ack&quot;)       protected Boolean earlyAck;       @XmlAttribute(name = &quot;id&quot;, required = true)       protected String id;       @XmlAttribute(name = &quot;socket-buffer-size&quot;)       protected String socketBufferSize;       @XmlAttribute(name = &quot;socket-read-timeout&quot;)       protected String socketReadTimeout;       @XmlAttribute(name = &quot;concurrency-level&quot;)       protected String concurrencyLevel;       @XmlAttribute(name = &quot;order-policy&quot;)       protected String orderPolicy;        /**        * Gets the value of the gatewayEndpoints property.        *        *         * This accessor method returns a reference to the live list,        * not a snapshot. Therefore any modification you make to the        * returned list will be present inside the JAXB object.        * This is why there is not a set method for the gatewayEndpoints property.        *        *         * For example, to add a new item, do as follows:        *        *         * getGatewayEndpoints().add(newItem);        *         *        *        *         * Objects of the following type(s) are allowed in the list        * {@link CacheConfig.GatewayHub.Gateway.GatewayEndpoint }        *        *        */       public List getGatewayEndpoints() {         if (gatewayEndpoints == null) {           gatewayEndpoints = new ArrayList();         }         return this.gatewayEndpoints;       }        /**        * Gets the value of the gatewayListeners property.        *        *         * This accessor method returns a reference to the live list,        * not a snapshot. Therefore any modification you make to the        * returned list will be present inside the JAXB object.        * This is why there is not a set method for the gatewayListeners property.        *        *         * For example, to add a new item, do as follows:        *        *         * getGatewayListeners().add(newItem);        *         *        *        *         * Objects of the following type(s) are allowed in the list        * {@link DeclarableType }        *        *        */       public List getGatewayListeners() {         if (gatewayListeners == null) {           gatewayListeners = new ArrayList();         }         return this.gatewayListeners;       }        /**        * Gets the value of the gatewayQueue property.        *        * possible object is        * {@link CacheConfig.GatewayHub.Gateway.GatewayQueue }        *        */       public CacheConfig.GatewayHub.Gateway.GatewayQueue getGatewayQueue() {         return gatewayQueue;       }        /**        * Sets the value of the gatewayQueue property.        *        * allowed object is        * {@link CacheConfig.GatewayHub.Gateway.GatewayQueue }        *        */       public void setGatewayQueue(CacheConfig.GatewayHub.Gateway.GatewayQueue value) {         this.gatewayQueue = value;       }        /**        * Gets the value of the earlyAck property.        *        * possible object is        * {@link Boolean }        *        */       public Boolean isEarlyAck() {         return earlyAck;       }        /**        * Sets the value of the earlyAck property.        *        * allowed object is        * {@link Boolean }        *        */       public void setEarlyAck(Boolean value) {         this.earlyAck = value;       }        /**        * Gets the value of the id property.        *        * possible object is        * {@link String }        *        */       public String getId() {         return id;       }        /**        * Sets the value of the id property.        *        * allowed object is        * {@link String }        *        */       public void setId(String value) {         this.id = value;       }        /**        * Gets the value of the socketBufferSize property.        *        * possible object is        * {@link String }        *        */       public String getSocketBufferSize() {         return socketBufferSize;       }        /**        * Sets the value of the socketBufferSize property.        *        * allowed object is        * {@link String }        *        */       public void setSocketBufferSize(String value) {         this.socketBufferSize = value;       }        /**        * Gets the value of the socketReadTimeout property.        *        * possible object is        * {@link String }        *        */       public String getSocketReadTimeout() {         return socketReadTimeout;       }        /**        * Sets the value of the socketReadTimeout property.        *        * allowed object is        * {@link String }        *        */       public void setSocketReadTimeout(String value) {         this.socketReadTimeout = value;       }        /**        * Gets the value of the concurrencyLevel property.        *        * possible object is        * {@link String }        *        */       public String getConcurrencyLevel() {         return concurrencyLevel;       }        /**        * Sets the value of the concurrencyLevel property.        *        * allowed object is        * {@link String }        *        */       public void setConcurrencyLevel(String value) {         this.concurrencyLevel = value;       }        /**        * Gets the value of the orderPolicy property.        *        * possible object is        * {@link String }        *        */       public String getOrderPolicy() {         return orderPolicy;       }        /**        * Sets the value of the orderPolicy property.        *        * allowed object is        * {@link String }        *        */       public void setOrderPolicy(String value) {         this.orderPolicy = value;       }         /**        *         * Java class for anonymous complex type.        *        *         * The following schema fragment specifies the expected content contained within this class.        *        *         * &lt;complexType&gt;        *   &lt;complexContent&gt;        *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;        *       &lt;attribute name=&quot;host&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;id&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;port&quot; use=&quot;required&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *     &lt;/restriction&gt;        *   &lt;/complexContent&gt;        * &lt;/complexType&gt;        *         *        *        */       @XmlAccessorType(XmlAccessType.FIELD)       @XmlType(name = &quot;&quot;)       public static class GatewayEndpoint {          @XmlAttribute(name = &quot;host&quot;, required = true)         protected String host;         @XmlAttribute(name = &quot;id&quot;, required = true)         protected String id;         @XmlAttribute(name = &quot;port&quot;, required = true)         protected String port;          /**          * Gets the value of the host property.          *          * possible object is          * {@link String }          *          */         public String getHost() {           return host;         }          /**          * Sets the value of the host property.          *          * allowed object is          * {@link String }          *          */         public void setHost(String value) {           this.host = value;         }          /**          * Gets the value of the id property.          *          * possible object is          * {@link String }          *          */         public String getId() {           return id;         }          /**          * Sets the value of the id property.          *          * allowed object is          * {@link String }          *          */         public void setId(String value) {           this.id = value;         }          /**          * Gets the value of the port property.          *          * possible object is          * {@link String }          *          */         public String getPort() {           return port;         }          /**          * Sets the value of the port property.          *          * allowed object is          * {@link String }          *          */         public void setPort(String value) {           this.port = value;         }        }        /**        *         * Java class for anonymous complex type.        *        *         * The following schema fragment specifies the expected content contained within this class.        *        *         * &lt;complexType&gt;        *   &lt;complexContent&gt;        *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;        *       &lt;attribute name=&quot;alert-threshold&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;batch-conflation&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;        *       &lt;attribute name=&quot;batch-size&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;batch-time-interval&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;enable-persistence&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;        *       &lt;attribute name=&quot;disk-store-name&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;roll-oplogs&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}boolean&quot; /&gt;        *       &lt;attribute name=&quot;maximum-queue-memory&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *       &lt;attribute name=&quot;overflow-directory&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; /&gt;        *     &lt;/restriction&gt;        *   &lt;/complexContent&gt;        * &lt;/complexType&gt;        *         *        *        */       @XmlAccessorType(XmlAccessType.FIELD)       @XmlType(name = &quot;&quot;)       public static class GatewayQueue {          @XmlAttribute(name = &quot;alert-threshold&quot;)         protected String alertThreshold;         @XmlAttribute(name = &quot;batch-conflation&quot;)         protected Boolean batchConflation;         @XmlAttribute(name = &quot;batch-size&quot;)         protected String batchSize;         @XmlAttribute(name = &quot;batch-time-interval&quot;)         protected String batchTimeInterval;         @XmlAttribute(name = &quot;enable-persistence&quot;)         protected Boolean enablePersistence;         @XmlAttribute(name = &quot;disk-store-name&quot;)         protected String diskStoreName;         @XmlAttribute(name = &quot;roll-oplogs&quot;)         protected Boolean rollOplogs;         @XmlAttribute(name = &quot;maximum-queue-memory&quot;)         protected String maximumQueueMemory;         @XmlAttribute(name = &quot;overflow-directory&quot;)         protected String overflowDirectory;          /**          * Gets the value of the alertThreshold property.          *          * possible object is          * {@link String }          *          */         public String getAlertThreshold() {           return alertThreshold;         }          /**          * Sets the value of the alertThreshold property.          *          * allowed object is          * {@link String }          *          */         public void setAlertThreshold(String value) {           this.alertThreshold = value;         }          /**          * Gets the value of the batchConflation property.          *          * possible object is          * {@link Boolean }          *          */         public Boolean isBatchConflation() {           return batchConflation;         }          /**          * Sets the value of the batchConflation property.          *          * allowed object is          * {@link Boolean }          *          */         public void setBatchConflation(Boolean value) {           this.batchConflation = value;         }          /**          * Gets the value of the batchSize property.          *          * possible object is          * {@link String }          *          */         public String getBatchSize() {           return batchSize;         }          /**          * Sets the value of the batchSize property.          *          * allowed object is          * {@link String }          *          */         public void setBatchSize(String value) {           this.batchSize = value;         }          /**          * Gets the value of the batchTimeInterval property.          *          * possible object is          * {@link String }          *          */         public String getBatchTimeInterval() {           return batchTimeInterval;         }          /**          * Sets the value of the batchTimeInterval property.          *          * allowed object is          * {@link String }          *          */         public void setBatchTimeInterval(String value) {           this.batchTimeInterval = value;         }          /**          * Gets the value of the enablePersistence property.          *          * possible object is          * {@link Boolean }          *          */         public Boolean isEnablePersistence() {           return enablePersistence;         }          /**          * Sets the value of the enablePersistence property.          *          * allowed object is          * {@link Boolean }          *          */         public void setEnablePersistence(Boolean value) {           this.enablePersistence = value;         }          /**          * Gets the value of the diskStoreName property.          *          * possible object is          * {@link String }          *          */         public String getDiskStoreName() {           return diskStoreName;         }          /**          * Sets the value of the diskStoreName property.          *          * allowed object is          * {@link String }          *          */         public void setDiskStoreName(String value) {           this.diskStoreName = value;         }          /**          * Gets the value of the rollOplogs property.          *          * possible object is          * {@link Boolean }          *          */         public Boolean isRollOplogs() {           return rollOplogs;         }          /**          * Sets the value of the rollOplogs property.          *          * allowed object is          * {@link Boolean }          *          */         public void setRollOplogs(Boolean value) {           this.rollOplogs = value;         }          /**          * Gets the value of the maximumQueueMemory property.          *          * possible object is          * {@link String }          *          */         public String getMaximumQueueMemory() {           return maximumQueueMemory;         }          /**          * Sets the value of the maximumQueueMemory property.          *          * allowed object is          * {@link String }          *          */         public void setMaximumQueueMemory(String value) {           this.maximumQueueMemory = value;         }          /**          * Gets the value of the overflowDirectory property.          *          * possible object is          * {@link String }          *          */         public String getOverflowDirectory() {           return overflowDirectory;         }          /**          * Sets the value of the overflowDirectory property.          *          * allowed object is          * {@link String }          *          */         public void setOverflowDirectory(String value) {           this.overflowDirectory = value;         }        }      }    }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10504</td>
    <td align="left">https://github.com/apache/geode/blob/8fd839e8b73e40bd2dfd14f331b587431bd35a66/geode-management/src/main/java/org/apache/geode/cache/configuration/CacheConfig.java/#L1636-L2524</td>
    <td align="right">1</td>
    <td align="right">1260</td>
    <td align="right">10504</td>
  </tr>
  <tr valign="top">
    <td align="right">1285</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Blob&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SimpleMessage implements Message {      private final MessageId messageId;     private final String subType;     private final String mediaType;     private final SharedInputStream content;     private final int bodyStartOctet;     private final Date internalDate;     private final long size;     private final Long textualLineCount;     private final List properties;     private final List attachments;      public SimpleMessage(MessageId messageId, SharedInputStream content, long size, Date internalDate, String subType, String mediaType, int bodyStartOctet, Long textualLineCount, List properties, List attachments) {         this.messageId = messageId;         this.subType = subType;         this.mediaType = mediaType;         this.content = content;         this.bodyStartOctet = bodyStartOctet;         this.internalDate = internalDate;         this.size = size;         this.textualLineCount = textualLineCount;         this.properties = properties;         this.attachments = attachments;     }      public SimpleMessage(MessageId messageId, SharedInputStream content, long size, Date internalDate, String subType, String mediaType, int bodyStartOctet, Long textualLineCount, List properties) {         this(messageId, content, size, internalDate, subType, mediaType, bodyStartOctet, textualLineCount, properties, ImmutableList.of());     }      @Override     public MessageId getMessageId() {         return messageId;     }      @Override     public Date getInternalDate() {         return internalDate;     }      @Override     public InputStream getBodyContent() throws IOException {         return content.newStream(bodyStartOctet, -1);     }      @Override     public String getMediaType() {         return mediaType;     }      @Override     public String getSubType() {         return subType;     }      @Override     public long getBodyOctets() {         return getFullContentOctets() - bodyStartOctet;     }      @Override     public long getHeaderOctets() {         return bodyStartOctet;     }      @Override     public long getFullContentOctets() {         return size;     }      @Override     public Long getTextualLineCount() {         return textualLineCount;     }      @Override     public InputStream getHeaderContent() throws IOException {         long headerEnd = bodyStartOctet;         if (headerEnd &lt; 0) {             headerEnd = 0;         }         return content.newStream(0, headerEnd);     }      @Override     public InputStream getFullContent() throws IOException {         return content.newStream(0, -1);     }      @Override     public List getProperties() {         return properties;     }      @Override     public List getAttachments() {         return attachments;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">10608</td>
    <td align="left">https://github.com/apache/james-project/blob/fa24a096a5853459c3769a34ccc68feb91626bfa/mailbox/store/src/main/java/org/apache/james/mailbox/store/mail/model/impl/SimpleMessage.java/#L35-L133</td>
    <td align="right">1</td>
    <td align="right">1285</td>
    <td align="right">10608</td>
  </tr>
  <tr valign="top">
    <td align="right">1286</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Feature Envy&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@APICommand(name = &quot;extractTemplate&quot;, description = &quot;Extracts a template&quot;, responseObject = ExtractResponse.class,         requestHasSensitiveInfo = false, responseHasSensitiveInfo = false) public class ExtractTemplateCmd extends BaseAsyncCmd {     public static final Logger s_logger = Logger.getLogger(ExtractTemplateCmd.class.getName());      private static final String s_name = &quot;extracttemplateresponse&quot;;      /////////////////////////////////////////////////////     //////////////// API parameters /////////////////////     /////////////////////////////////////////////////////      @Parameter(name = ApiConstants.ID, type = CommandType.UUID, entityType = TemplateResponse.class, required = true, description = &quot;the ID of the template&quot;)     private Long id;      @Parameter(name = ApiConstants.URL, type = CommandType.STRING, required = false, length = 2048, description = &quot;the url to which the ISO would be extracted&quot;)     private String url;      @Parameter(name = ApiConstants.ZONE_ID,                type = CommandType.UUID,                entityType = ZoneResponse.class,                required = false,                description = &quot;the ID of the zone where the ISO is originally located&quot;)     private Long zoneId;      @Parameter(name = ApiConstants.MODE, type = CommandType.STRING, required = true, description = &quot;the mode of extraction - HTTP_DOWNLOAD or FTP_UPLOAD&quot;)     private String mode;      /////////////////////////////////////////////////////     /////////////////// Accessors ///////////////////////     /////////////////////////////////////////////////////      public Long getId() {         return id;     }      public String getUrl() {         return url;     }      public Long getZoneId() {         return zoneId;     }      public String getMode() {         return mode;     }      /////////////////////////////////////////////////////     /////////////// API Implementation///////////////////     /////////////////////////////////////////////////////      @Override     public String getCommandName() {         return s_name;     }      public static String getStaticName() {         return s_name;     }      @Override     public long getEntityOwnerId() {         VirtualMachineTemplate template = _entityMgr.findById(VirtualMachineTemplate.class, getId());         if (template != null) {             return template.getAccountId();         }          // invalid id, parent this command to SYSTEM so ERROR events are tracked         return Account.ACCOUNT_ID_SYSTEM;     }      @Override     public String getEventType() {         return EventTypes.EVENT_TEMPLATE_EXTRACT;     }      @Override     public String getEventDescription() {      return &quot;extracting template: &quot; + this._uuidMgr.getUuid(VirtualMachineTemplate.class, getId()) + ((getZoneId() != null) ? &quot; from zone: &quot; + this._uuidMgr.getUuid(DataCenter.class, getZoneId()) : &quot;&quot;);     }      @Override     public ApiCommandJobType getInstanceType() {         return ApiCommandJobType.Template;     }      @Override     public Long getInstanceId() {         return getId();     }      @Override     public void execute() {         try {             CallContext.current().setEventDetails(getEventDescription());             String uploadUrl = _templateService.extract(this);             if (uploadUrl != null) {                 ExtractResponse response = _responseGenerator.createExtractResponse(id, zoneId, getEntityOwnerId(), mode, uploadUrl);                 response.setResponseName(getCommandName());                 this.setResponseObject(response);             } else {                 throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, &quot;Failed to extract template&quot;);             }         } catch (InternalErrorException ex) {             s_logger.warn(&quot;Exception: &quot;, ex);             throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());         }     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, feature envy</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  feature envy</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">10611</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/api/src/main/java/org/apache/cloudstack/api/command/user/template/ExtractTemplateCmd.java/#L39-L147</td>
    <td align="right">1</td>
    <td align="right">1286</td>
    <td align="right">10611</td>
  </tr>
  <tr valign="top">
    <td align="right">1292</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES, I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Data Class&quot;,             &quot;Blob&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    class ColumnFamilyRegionInfo {         private RegionInfo regionInfo;         private Set familySet;          public ColumnFamilyRegionInfo(RegionInfo regionInfo, Set familySet) {             this.regionInfo = regionInfo;             this.familySet = familySet;         }          public RegionInfo getRegionInfo() {             return regionInfo;         }          public Set getFamilySet() {             return familySet;         }          @Override         public boolean equals(Object obj) {             if (obj == this) { return true; }             if (!(obj instanceof ColumnFamilyRegionInfo)) { return false; }              ColumnFamilyRegionInfo c = (ColumnFamilyRegionInfo)obj;             return c.getRegionInfo().equals(this.regionInfo) &amp;&amp; ByteUtil.match(this.familySet, c.getFamilySet());         }          @Override         public int hashCode() {             return this.getRegionInfo().hashCode();         }     }</td>
    <td align="left">data class</td>
    <td align="left">data class, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10621</td>
    <td align="left">https://github.com/apache/phoenix/blob/69e5bb0b304a53967cef40b2a4cfc66e69ecaa51/phoenix-core/src/main/java/org/apache/phoenix/schema/stats/StatisticsCollectionRunTracker.java/#L129-L159</td>
    <td align="right">1</td>
    <td align="right">1292</td>
    <td align="right">10621</td>
  </tr>
  <tr valign="top">
    <td align="right">1298</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES, I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Long Method&quot;,       &quot;Blob&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  private XMLEvent expectTag(String expected, boolean allowEnd)       throws IOException {     XMLEvent ev = null;     while (true) {       try {         ev = events.nextEvent();       } catch (XMLStreamException e) {         throw new IOException(&quot;Expecting &quot; + expected +             &quot;, but got XMLStreamException&quot;, e);       }       switch (ev.getEventType()) {       case XMLEvent.ATTRIBUTE:         throw new IOException(&quot;Got unexpected attribute: &quot; + ev);       case XMLEvent.CHARACTERS:         if (!ev.asCharacters().isWhiteSpace()) {           throw new IOException(&quot;Got unxpected characters while &quot; +               &quot;looking for &quot; + expected + &quot;: &quot; +               ev.asCharacters().getData());         }         break;       case XMLEvent.END_ELEMENT:         if (!allowEnd) {           throw new IOException(&quot;Got unexpected end event &quot; +               &quot;while looking for &quot; + expected);         }         return ev;       case XMLEvent.START_ELEMENT:         if (!expected.startsWith(&quot;[&quot;)) {           if (!ev.asStartElement().getName().getLocalPart().                 equals(expected)) {             throw new IOException(&quot;Failed to find &lt;&quot; + expected + &quot;&gt;; &quot; +                 &quot;got &quot; + ev.asStartElement().getName().getLocalPart() +                 &quot; instead.&quot;);           }         }         return ev;       default:         // Ignore other event types like comment, etc.         if (LOG.isTraceEnabled()) {           LOG.trace(&quot;Skipping XMLEvent of type &quot; +               ev.getEventType() + &quot;(&quot; +  ev + &quot;)&quot;);         }         break;       }     }   }</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10639</td>
    <td align="left">https://github.com/apache/hadoop/blob/128dd91e10080bdcbcd7d555fa3c4105e55a6b51/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/OfflineImageReconstructor.java/#L184-L229</td>
    <td align="right">1</td>
    <td align="right">1298</td>
    <td align="right">10639</td>
  </tr>
  <tr valign="top">
    <td align="right">1343</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;response&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             &quot;1. Long Method&quot;,             &quot;2. Blob&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  private void grantOrRevokeRoleOnGroup(List hivePrincipals, List roles,       HivePrincipal grantorPrinc, boolean isGrant) throws HiveAuthzPluginException,       HiveAccessControlException {     try {       sentryClient = getSentryClient();       // get principals       Set groups = Sets.newHashSet();       for (HivePrincipal principal : hivePrincipals) {         if (principal.getType() != HivePrincipalType.GROUP) {           String msg =               SentryHiveConstants.GRANT_REVOKE_NOT_SUPPORTED_FOR_PRINCIPAL + principal.getType();           throw new HiveAuthzPluginException(msg);         }         groups.add(principal.getName());       }        // grant/revoke role to/from principals       for (String roleName : roles) {         if (isGrant) {           sentryClient.grantRoleToGroups(grantorPrinc.getName(), roleName, groups);         } else {           sentryClient.revokeRoleFromGroups(grantorPrinc.getName(), roleName, groups);         }       }      } catch (SentryAccessDeniedException e) {       HiveOperation hiveOp = isGrant ? HiveOperation.GRANT_ROLE : HiveOperation.REVOKE_ROLE;       executeOnFailureHooks(hiveOp, e);     } catch (SentryUserException e) {       String msg = &quot;Error when sentryClient grant/revoke role:&quot; + e.getMessage();       executeOnErrorHooks(msg, e);     } finally {       if (sentryClient != null) {         sentryClient.close();       }     }   }</td>
    <td align="left">long method</td>
    <td align="left">1. long method, 2. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;2. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10745</td>
    <td align="left">https://github.com/apache/incubator-sentry/blob/4643f988a5e0ce2b9749e6365edea3a16482de86/sentry-binding/sentry-binding-hive-v2/src/main/java/org/apache/sentry/binding/hive/v2/authorizer/DefaultSentryAccessController.java/#L479-L515</td>
    <td align="right">1</td>
    <td align="right">1343</td>
    <td align="right">10745</td>
  </tr>
  <tr valign="top">
    <td align="right">1368</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Blob&quot;,             &quot;Long Method&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class GridNearAtomicSingleUpdateRequest extends GridNearAtomicAbstractSingleUpdateRequest {     /** */     private static final long serialVersionUID = 0L;      /** Key to update. */     @GridToStringInclude     protected KeyCacheObject key;      /** Value to update. */     protected CacheObject val;      /**      * Empty constructor required by {@link Externalizable}.      */     public GridNearAtomicSingleUpdateRequest() {         // No-op.     }      /**      * Constructor.      *      * @param cacheId Cache ID.      * @param nodeId Node ID.      * @param futId Future ID.      * @param topVer Topology version.      * @param syncMode Synchronization mode.      * @param op Cache update operation.      * @param subjId Subject ID.      * @param taskNameHash Task name hash code.      * @param flags Flags.      * @param addDepInfo Deployment info flag.      */     GridNearAtomicSingleUpdateRequest(         int cacheId,         UUID nodeId,         long futId,         @NotNull AffinityTopologyVersion topVer,         CacheWriteSynchronizationMode syncMode,         GridCacheOperation op,         @Nullable UUID subjId,         int taskNameHash,         byte flags,         boolean addDepInfo     ) {         super(cacheId,             nodeId,             futId,             topVer,             syncMode,             op,             subjId,             taskNameHash,             flags,             addDepInfo         );     }      /** {@inheritDoc} */     @Override public int partition() {         assert key != null;          return key.partition();     }      /**      * @param key Key to add.      * @param val Optional update value.      * @param conflictTtl Conflict TTL (optional).      * @param conflictExpireTime Conflict expire time (optional).      * @param conflictVer Conflict version (optional).      */     @Override public void addUpdateEntry(KeyCacheObject key,         @Nullable Object val,         long conflictTtl,         long conflictExpireTime,         @Nullable GridCacheVersion conflictVer) {         assert op != TRANSFORM;         assert val != null || op == DELETE;         assert conflictTtl &lt; 0 : conflictTtl;         assert conflictExpireTime &lt; 0 : conflictExpireTime;         assert conflictVer == null : conflictVer;          this.key = key;          if (val != null) {             assert val instanceof CacheObject : val;              this.val = (CacheObject)val;         }     }      /** {@inheritDoc} */     @Override public int size() {         assert key != null;          return key == null ? 0 : 1;     }      /** {@inheritDoc} */     @Override public List keys() {         return Collections.singletonList(key);     }      /** {@inheritDoc} */     @Override public KeyCacheObject key(int idx) {         assert idx == 0 : idx;          return key;     }      /** {@inheritDoc} */     @Override public List values() {         return Collections.singletonList(val);     }      /** {@inheritDoc} */     @Override public CacheObject value(int idx) {         assert idx == 0 : idx;          return val;     }      /** {@inheritDoc} */     @Override public EntryProcessor entryProcessor(int idx) {         assert idx == 0 : idx;          return null;     }      /** {@inheritDoc} */     @Override public CacheObject writeValue(int idx) {         assert idx == 0 : idx;          return val;     }      /** {@inheritDoc} */     @Nullable @Override public List conflictVersions() {         return null;     }      /** {@inheritDoc} */     @Nullable @Override public GridCacheVersion conflictVersion(int idx) {         assert idx == 0 : idx;          return null;     }      /** {@inheritDoc} */     @Override public long conflictTtl(int idx) {         assert idx == 0 : idx;          return CU.TTL_NOT_CHANGED;     }      /** {@inheritDoc} */     @Override public long conflictExpireTime(int idx) {         assert idx == 0 : idx;          return CU.EXPIRE_TIME_CALCULATE;     }      /** {@inheritDoc} */     @Override public void prepareMarshal(GridCacheSharedContext ctx) throws IgniteCheckedException {         super.prepareMarshal(ctx);          GridCacheContext cctx = ctx.cacheContext(cacheId);          prepareMarshalCacheObject(key, cctx);          if (val != null)             prepareMarshalCacheObject(val, cctx);     }      /** {@inheritDoc} */     @Override public void finishUnmarshal(GridCacheSharedContext ctx, ClassLoader ldr) throws IgniteCheckedException {         super.finishUnmarshal(ctx, ldr);          GridCacheContext cctx = ctx.cacheContext(cacheId);          key.finishUnmarshal(cctx.cacheObjectContext(), ldr);          if (val != null)             val.finishUnmarshal(cctx.cacheObjectContext(), ldr);     }      /** {@inheritDoc} */     @Override public boolean writeTo(ByteBuffer buf, MessageWriter writer) {         writer.setBuffer(buf);          if (!super.writeTo(buf, writer))             return false;          if (!writer.isHeaderWritten()) {             if (!writer.writeHeader(directType(), fieldsCount()))                 return false;              writer.onHeaderWritten();         }          switch (writer.state()) {             case 11:                 if (!writer.writeMessage(&quot;key&quot;, key))                     return false;                  writer.incrementState();              case 12:                 if (!writer.writeMessage(&quot;val&quot;, val))                     return false;                  writer.incrementState();          }          return true;     }      /** {@inheritDoc} */     @Override public boolean readFrom(ByteBuffer buf, MessageReader reader) {         reader.setBuffer(buf);          if (!reader.beforeMessageRead())             return false;          if (!super.readFrom(buf, reader))             return false;          switch (reader.state()) {             case 11:                 key = reader.readMessage(&quot;key&quot;);                  if (!reader.isLastRead())                     return false;                  reader.incrementState();              case 12:                 val = reader.readMessage(&quot;val&quot;);                  if (!reader.isLastRead())                     return false;                  reader.incrementState();          }          return reader.afterMessageRead(GridNearAtomicSingleUpdateRequest.class);     }      /** {@inheritDoc} */     @Override public void cleanup(boolean clearKey) {         val = null;          if (clearKey)             key = null;     }      /** {@inheritDoc} */     @Override public short directType() {         return 125;     }      /** {@inheritDoc} */     @Override public byte fieldsCount() {         return 13;     }      /** {@inheritDoc} */     @Override public String toString() {         return S.toString(GridNearAtomicSingleUpdateRequest.class, this, &quot;parent&quot;, super.toString());     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">10790</td>
    <td align="left">https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/atomic/GridNearAtomicSingleUpdateRequest.java/#L49-L321</td>
    <td align="right">1</td>
    <td align="right">1368</td>
    <td align="right">10790</td>
  </tr>
  <tr valign="top">
    <td align="right">1404</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Blob&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement(name=&quot;mqtt&quot;) @XmlAccessorType(XmlAccessType.FIELD) public class MqttDTO extends ProtocolDTO {      @XmlAttribute(name=&quot;max_message_length&quot;)     public Integer max_message_length;      @XmlElementRef     public List protocol_filters = new ArrayList();      @XmlAttribute(name=&quot;queue_prefix&quot;)     public String queue_prefix;      @XmlAttribute(name=&quot;path_separator&quot;)     public String path_separator;      @XmlAttribute(name=&quot;any_child_wildcard&quot;)     public String any_child_wildcard;      @XmlAttribute(name=&quot;any_descendant_wildcard&quot;)     public String any_descendant_wildcard;      @XmlAttribute(name=&quot;regex_wildcard_start&quot;)     public String regex_wildcard_start;      @XmlAttribute(name=&quot;regex_wildcard_end&quot;)     public String regex_wildcard_end;      @XmlAttribute(name=&quot;part_pattern&quot;)     public String part_pattern;      @XmlAttribute(name=&quot;die_delay&quot;)     public Long die_delay;      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (o == null || getClass() != o.getClass()) return false;         if (!super.equals(o)) return false;          MqttDTO mqttDTO = (MqttDTO) o;          if (any_child_wildcard != null ? !any_child_wildcard.equals(mqttDTO.any_child_wildcard) : mqttDTO.any_child_wildcard != null)             return false;         if (any_descendant_wildcard != null ? !any_descendant_wildcard.equals(mqttDTO.any_descendant_wildcard) : mqttDTO.any_descendant_wildcard != null)             return false;         if (max_message_length != null ? !max_message_length.equals(mqttDTO.max_message_length) : mqttDTO.max_message_length != null)             return false;         if (path_separator != null ? !path_separator.equals(mqttDTO.path_separator) : mqttDTO.path_separator != null)             return false;         if (protocol_filters != null ? !protocol_filters.equals(mqttDTO.protocol_filters) : mqttDTO.protocol_filters != null)             return false;         if (queue_prefix != null ? !queue_prefix.equals(mqttDTO.queue_prefix) : mqttDTO.queue_prefix != null)             return false;         if (regex_wildcard_end != null ? !regex_wildcard_end.equals(mqttDTO.regex_wildcard_end) : mqttDTO.regex_wildcard_end != null)             return false;         if (regex_wildcard_start != null ? !regex_wildcard_start.equals(mqttDTO.regex_wildcard_start) : mqttDTO.regex_wildcard_start != null)             return false;         if (part_pattern != null ? !part_pattern.equals(mqttDTO.part_pattern) : mqttDTO.part_pattern != null)             return false;          return true;     }      @Override     public int hashCode() {         int result = super.hashCode();         result = 31 * result + (max_message_length != null ? max_message_length.hashCode() : 0);         result = 31 * result + (protocol_filters != null ? protocol_filters.hashCode() : 0);         result = 31 * result + (queue_prefix != null ? queue_prefix.hashCode() : 0);         result = 31 * result + (part_pattern != null ? part_pattern.hashCode() : 0);         result = 31 * result + (path_separator != null ? path_separator.hashCode() : 0);         result = 31 * result + (any_child_wildcard != null ? any_child_wildcard.hashCode() : 0);         result = 31 * result + (any_descendant_wildcard != null ? any_descendant_wildcard.hashCode() : 0);         result = 31 * result + (regex_wildcard_start != null ? regex_wildcard_start.hashCode() : 0);         result = 31 * result + (regex_wildcard_end != null ? regex_wildcard_end.hashCode() : 0);         return result;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">10872</td>
    <td align="left">https://github.com/apache/activemq-apollo/blob/8e4b134b2a5d3576aa62cd8df9905a9fe2eba2d0/apollo-mqtt/src/main/java/org/apache/activemq/apollo/mqtt/dto/MqttDTO.java/#L31-L109</td>
    <td align="right">1</td>
    <td align="right">1404</td>
    <td align="right">10872</td>
  </tr>
  <tr valign="top">
    <td align="right">1405</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Value public class Release {  	private final String id; 	private final ProjectKey projectKey; 	private final String name; 	private final String description; 	private final LocalDate date; }</td>
    <td align="left">data class</td>
    <td align="left">Blob, Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">Blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10874</td>
    <td align="left">https://github.com/spring-projects/spring-data-dev-tools/blob/a25ff3ae28026f132871f7172c6ba5c3b64e1671/release-tools/src/main/java/org/springframework/data/release/model/Release.java/#L25-L33</td>
    <td align="right">1</td>
    <td align="right">1405</td>
    <td align="right">10874</td>
  </tr>
  <tr valign="top">
    <td align="right">1412</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;the bad smells are&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity @Table(name=&quot;xa_access_audit&quot;) public class AuthzAuditEventDbObj implements Serializable {  	private static final Log LOG = LogFactory.getLog(AuthzAuditEventDbObj.class);  	private static final long serialVersionUID = 1L;  	static int MaxValueLengthAccessType = 255; 	static int MaxValueLengthAclEnforcer = 255; 	static int MaxValueLengthAgentId = 255; 	static int MaxValueLengthClientIp = 255; 	static int MaxValueLengthClientType = 255; 	static int MaxValueLengthRepoName = 255; 	static int MaxValueLengthResultReason = 255; 	static int MaxValueLengthSessionId = 255; 	static int MaxValueLengthRequestUser = 255; 	static int MaxValueLengthAction = 2000; 	static int MaxValueLengthRequestData = 4000; 	static int MaxValueLengthResourcePath = 4000; 	static int MaxValueLengthResourceType = 255;  	private long   auditId; 	private int    repositoryType; 	private String repositoryName; 	private String user; 	private Date   timeStamp; 	private String accessType; 	private String resourcePath; 	private String resourceType; 	private String action; 	private int    accessResult; 	private String agentId; 	private long   policyId; 	private String resultReason; 	private String aclEnforcer; 	private String sessionId; 	private String clientType; 	private String clientIP; 	private String requestData; 	private long seqNum; 	private long eventCount; 	private long eventDurationMS; 	private String tags;  	public static void init(Properties props) 	{ 		LOG.info(&quot;AuthzAuditEventDbObj.init()&quot;);  		final String AUDIT_DB_MAX_COLUMN_VALUE = &quot;xasecure.audit.destination.db.max.column.length&quot;; 		MaxValueLengthAccessType = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;access_type&quot;, MaxValueLengthAccessType); 		logMaxColumnValue(&quot;access_type&quot;, MaxValueLengthAccessType);  		MaxValueLengthAclEnforcer = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;acl_enforcer&quot;, MaxValueLengthAclEnforcer); 		logMaxColumnValue(&quot;acl_enforcer&quot;, MaxValueLengthAclEnforcer);  		MaxValueLengthAction = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;action&quot;, MaxValueLengthAction); 		logMaxColumnValue(&quot;action&quot;, MaxValueLengthAction);  		MaxValueLengthAgentId = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;agent_id&quot;, MaxValueLengthAgentId); 		logMaxColumnValue(&quot;agent_id&quot;, MaxValueLengthAgentId);  		MaxValueLengthClientIp = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;client_id&quot;, MaxValueLengthClientIp); 		logMaxColumnValue(&quot;client_id&quot;, MaxValueLengthClientIp);  		MaxValueLengthClientType = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;client_type&quot;, MaxValueLengthClientType); 		logMaxColumnValue(&quot;client_type&quot;, MaxValueLengthClientType);  		MaxValueLengthRepoName = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;repo_name&quot;, MaxValueLengthRepoName); 		logMaxColumnValue(&quot;repo_name&quot;, MaxValueLengthRepoName);  		MaxValueLengthResultReason = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;result_reason&quot;, MaxValueLengthResultReason); 		logMaxColumnValue(&quot;result_reason&quot;, MaxValueLengthResultReason);  		MaxValueLengthSessionId = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;session_id&quot;, MaxValueLengthSessionId); 		logMaxColumnValue(&quot;session_id&quot;, MaxValueLengthSessionId);  		MaxValueLengthRequestUser = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;request_user&quot;, MaxValueLengthRequestUser); 		logMaxColumnValue(&quot;request_user&quot;, MaxValueLengthRequestUser);  		MaxValueLengthRequestData = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;request_data&quot;, MaxValueLengthRequestData); 		logMaxColumnValue(&quot;request_data&quot;, MaxValueLengthRequestData);  		MaxValueLengthResourcePath = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;resource_path&quot;, MaxValueLengthResourcePath); 		logMaxColumnValue(&quot;resource_path&quot;, MaxValueLengthResourcePath);  		MaxValueLengthResourceType = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + &quot;.&quot; + &quot;resource_type&quot;, MaxValueLengthResourceType); 		logMaxColumnValue(&quot;resource_type&quot;, MaxValueLengthResourceType); 	}  	public static void logMaxColumnValue(String columnName, int configuredMaxValueLength) { 		LOG.info(&quot;Setting max column value for column[&quot; + columnName + &quot;] to [&quot; + configuredMaxValueLength + &quot;].&quot;); 		if (configuredMaxValueLength == 0) { 			LOG.info(&quot;Max length of column[&quot; + columnName + &quot;] was 0! Column will NOT be emitted in the audit.&quot;); 		} else if (configuredMaxValueLength &lt; 0) { 			LOG.info(&quot;Max length of column[&quot; + columnName + &quot;] was less than 0! Column value will never be truncated.&quot;); 		} 	}   	public AuthzAuditEventDbObj() { 		super(); 	}  	public AuthzAuditEventDbObj(AuthzAuditEvent event) { 		super(); 		Date utcDate=null; 		if(event.getEventTime()!=null){ 			utcDate=MiscUtil.getUTCDateForLocalDate(event.getEventTime()); 		}else{ 			utcDate=MiscUtil.getUTCDate(); 		} 		this.repositoryType = event.getRepositoryType(); 		this.repositoryName = event.getRepositoryName(); 		this.user           = event.getUser(); 		this.timeStamp      = utcDate; 		this.accessType     = event.getAccessType(); 		this.resourcePath   = event.getResourcePath(); 		this.resourceType   = event.getResourceType(); 		this.action         = event.getAction(); 		this.accessResult   = event.getAccessResult(); 		this.agentId        = event.getAgentId(); 		this.policyId       = event.getPolicyId(); 		this.resultReason   = event.getResultReason(); 		this.aclEnforcer    = event.getAclEnforcer(); 		this.sessionId      = event.getSessionId(); 		this.clientType     = event.getClientType(); 		this.clientIP       = event.getClientIP(); 		this.requestData    = event.getRequestData(); 		this.seqNum         = event.getSeqNum(); 		this.eventCount     = event.getEventCount(); 		this.eventDurationMS= event.getEventDurationMS(); 		this.tags           = StringUtils.join(event.getTags(), &quot;, &quot;); 	}  	@Id 	@SequenceGenerator(name=&quot;XA_ACCESS_AUDIT_SEQ&quot;,sequenceName=&quot;XA_ACCESS_AUDIT_SEQ&quot;,allocationSize=1) 	@GeneratedValue(strategy=GenerationType.AUTO,generator=&quot;XA_ACCESS_AUDIT_SEQ&quot;) 	@Column(name = &quot;id&quot;, unique = true, nullable = false) 	public long getAuditId() { 		return this.auditId; 	}  	public void setAuditId(long auditId) { 		this.auditId = auditId; 	}  	@Column(name = &quot;repo_type&quot;) 	public int getRepositoryType() { 		return this.repositoryType; 	}  	public void setRepositoryType(int repositoryType) { 		this.repositoryType = repositoryType; 	}  	@Column(name = &quot;repo_name&quot;) 	public String getRepositoryName() { 		return truncate(this.repositoryName, MaxValueLengthRepoName, &quot;repo_name&quot;); 	}  	public void setRepositoryName(String repositoryName) { 		this.repositoryName = repositoryName; 	}  	@Column(name = &quot;request_user&quot;) 	public String getUser() { 		return truncate(this.user, MaxValueLengthRequestUser, &quot;request_user&quot;); 	}  	public void setUser(String user) { 		this.user = user; 	}  	@Temporal(TemporalType.TIMESTAMP) 	@Column(name = &quot;event_time&quot;) 	public Date getTimeStamp() { 		return this.timeStamp; 	}  	public void setTimeStamp(Date timeStamp) { 		this.timeStamp = timeStamp; 	}  	@Column(name = &quot;access_type&quot;) 	public String getAccessType() { 		return truncate(this.accessType, MaxValueLengthAccessType, &quot;access_type&quot;); 	}  	public void setAccessType(String accessType) { 		this.accessType = accessType; 	}  	@Column(name = &quot;resource_path&quot;) 	public String getResourcePath() { 		return truncate(this.resourcePath, MaxValueLengthResourcePath, &quot;resource_path&quot;); 	}  	public void setResourcePath(String resourcePath) { 		this.resourcePath = resourcePath; 	}  	@Column(name = &quot;resource_type&quot;) 	public String getResourceType() { 		return truncate(this.resourceType, MaxValueLengthResourceType, &quot;resource_type&quot;); 	}  	public void setResourceType(String resourceType) { 		this.resourceType = resourceType; 	}  	@Column(name = &quot;action&quot;) 	public String getAction() { 		return truncate(this.action, MaxValueLengthAction, &quot;action&quot;); 	}  	public void setAction(String action) { 		this.action = action; 	}  	@Column(name = &quot;access_result&quot;) 	public int getAccessResult() { 		return this.accessResult; 	}  	public void setAccessResult(int accessResult) { 		this.accessResult = accessResult; 	}  	@Column(name = &quot;agent_id&quot;) 	public String getAgentId() { 		return truncate(this.agentId, MaxValueLengthAgentId, &quot;agent_id&quot;); 	}  	public void setAgentId(String agentId) { 		this.agentId = agentId; 	}  	@Column(name = &quot;policy_id&quot;) 	public long getPolicyId() { 		return this.policyId; 	}  	public void setPolicyId(long policyId) { 		this.policyId = policyId; 	}  	@Column(name = &quot;result_reason&quot;) 	public String getResultReason() { 		return truncate(this.resultReason, MaxValueLengthResultReason, &quot;result_reason&quot;); 	}  	public void setResultReason(String resultReason) { 		this.resultReason = resultReason; 	}  	@Column(name = &quot;acl_enforcer&quot;) 	public String getAclEnforcer() { 		return truncate(this.aclEnforcer, MaxValueLengthAclEnforcer, &quot;acl_enforcer&quot;); 	}  	public void setAclEnforcer(String aclEnforcer) { 		this.aclEnforcer = aclEnforcer; 	}  	@Column(name = &quot;session_id&quot;) 	public String getSessionId() { 		return truncate(this.sessionId, MaxValueLengthSessionId, &quot;session_id&quot;); 	}  	public void setSessionId(String sessionId) { 		this.sessionId = sessionId; 	}  	@Column(name = &quot;client_type&quot;) 	public String getClientType() { 		return truncate(this.clientType, MaxValueLengthClientType, &quot;client_type&quot;); 	}  	public void setClientType(String clientType) { 		this.clientType = clientType; 	}  	@Column(name = &quot;client_ip&quot;) 	public String getClientIP() { 		return truncate(this.clientIP, MaxValueLengthClientIp, &quot;client_ip&quot;); 	}  	public void setClientIP(String clientIP) { 		this.clientIP = clientIP; 	}  	@Column(name = &quot;request_data&quot;) 	public String getRequestData() { 		return truncate(this.requestData, MaxValueLengthRequestData, &quot;request_data&quot;); 	}  	public void setRequestData(String requestData) { 		this.requestData = requestData; 	}  	@Column(name = &quot;seq_num&quot;) 	public long getSeqNum() { return this.seqNum; }  	public void setSeqNum(long seqNum) { this.seqNum = seqNum; }  	@Column(name = &quot;event_count&quot;) 	public long getEventCount() { return this.eventCount; }  	public void setEventCount(long eventCount) { this.eventCount = eventCount; }  	@Column(name = &quot;event_dur_ms&quot;) 	public long getEventDurationMS() { return this.eventDurationMS; }  	public void setEventDurationMS(long eventDurationMS) { this.eventDurationMS = eventDurationMS; }  	@Column(name = &quot;tags&quot;) 	public String getTags() { 		return this.tags; 	}  	public void setTags(String tags) { 		this.tags = tags; 	}  	static final String TruncationMarker = &quot;...&quot;; 	static final int TruncationMarkerLength = TruncationMarker.length();  	protected String truncate(String value, int limit, String columnName) { 		if (LOG.isDebugEnabled()) { 			LOG.debug(String.format(&quot;==&gt; getTrunctedValue(%s, %d, %s)&quot;, value, limit, columnName)); 		}  		String result = value; 		if (value != null) { 			if (limit &lt; 0) { 				if (LOG.isDebugEnabled()) { 					LOG.debug(String.format(&quot;Truncation is suppressed for column[%s]: old value [%s], new value[%s]&quot;, columnName, value, result)); 				} 			} else if (limit == 0) { 				if (LOG.isDebugEnabled()) { 					LOG.debug(String.format(&quot;Column[%s] is to be excluded from audit: old value [%s], new value[%s]&quot;, columnName, value, result)); 				} 				result = null; 			} else { 				if (value.length() &gt; limit) { 					if (limit &lt;= TruncationMarkerLength) { 						// NOTE: If value is to be truncated to a size that is less than of equal to the Truncation Marker then we won't put the marker in!! 						result = value.substring(0, limit); 					} else { 						StringBuilder sb = new StringBuilder(value.substring(0, limit - TruncationMarkerLength)); 						sb.append(TruncationMarker); 						result = sb.toString(); 					} 					if (LOG.isDebugEnabled()) { 						LOG.debug(String.format(&quot;Truncating value for column[%s] to [%d] characters: old value [%s], new value[%s]&quot;, columnName, limit, value, result)); 					} 				} 			} 		}  		if (LOG.isDebugEnabled()) { 			LOG.debug(String.format(&quot;&lt;== getTrunctedValue(%s, %d, %s): %s&quot;, value, limit, columnName, result)); 		} 		return result; 	} }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">10903</td>
    <td align="left">https://github.com/apache/ranger/blob/7c52a79a5d0b41bfc94caca9d531e0fefba2bfe7/agents-audit/src/main/java/org/apache/ranger/audit/entity/AuthzAuditEventDbObj.java/#L46-L412</td>
    <td align="right">1</td>
    <td align="right">1412</td>
    <td align="right">10903</td>
  </tr>
  <tr valign="top">
    <td align="right">1414</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: {         &quot;1&quot;: &quot;Blob&quot;,         &quot;2&quot;: &quot;Data Class&quot;     } }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Singleton public class CheProductInfoDataProvider extends ProductInfoDataProviderImpl {    private final LocalizationConstant locale;   private final Resources resources;    @Inject   public CheProductInfoDataProvider(LocalizationConstant locale, Resources resources) {     this.locale = locale;     this.resources = resources;   }    @Override   public String getName() {     return locale.getProductName();   }    @Override   public String getSupportLink() {     return locale.getSupportLink();   }    @Override   public String getDocumentTitle() {     return locale.cheTabTitle();   }    @Override   public String getDocumentTitle(String workspaceName) {     return locale.cheTabTitle(workspaceName);   }    @Override   public SVGResource getLogo() {     return resources.logo();   }    @Override   public SVGResource getWaterMarkLogo() {     return resources.waterMarkLogo();   }    @Override   public String getSupportTitle() {     return locale.supportTitle();   } }</td>
    <td align="left">data class</td>
    <td align="left">1: blob, 2: data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1: blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10909</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/plugins/plugin-product-info/src/main/java/org/eclipse/che/plugin/product/info/client/CheProductInfoDataProvider.java/#L26-L72</td>
    <td align="right">1</td>
    <td align="right">1414</td>
    <td align="right">10909</td>
  </tr>
  <tr valign="top">
    <td align="right">1417</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class JdbVariable implements Variable {   private final LocalVariable jdiVariable;   private final SimpleValue value;    public JdbVariable(StackFrame jdiStackFrame, LocalVariable jdiVariable) {     Value jdiValue = jdiStackFrame.getValue(jdiVariable);      this.jdiVariable = jdiVariable;     this.value = jdiValue == null ? new JdbNullValue() : new JdbValue(jdiValue, getVariablePath());   }    public JdbVariable(SimpleValue value, LocalVariable jdiVariable) {     this.jdiVariable = jdiVariable;     this.value = value;   }    @Override   public String getName() {     return jdiVariable.name();   }    @Override   public boolean isPrimitive() {     return JdbType.isPrimitive(jdiVariable.signature());   }    @Override   public SimpleValue getValue() {     return value;   }    @Override   public String getType() {     return jdiVariable.typeName();   }    @Override   public VariablePath getVariablePath() {     return new VariablePathImpl(getName());   } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10917</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/plugins/plugin-java-debugger/che-plugin-java-debugger-server/src/main/java/org/eclipse/che/plugin/jdb/server/model/JdbVariable.java/#L27-L67</td>
    <td align="right">1</td>
    <td align="right">1417</td>
    <td align="right">10917</td>
  </tr>
  <tr valign="top">
    <td align="right">1422</td>
    <td align="left">&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [         &quot;1. Long Method&quot;,         &quot;2. Blob&quot;,         &quot;3. Data Class&quot;,         &quot;4. Feature Envy&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class AbstractAzureMojo extends AbstractMojo implements TelemetryConfiguration, AuthConfiguration {     public static final String PLUGIN_NAME_KEY = &quot;pluginName&quot;;     public static final String PLUGIN_VERSION_KEY = &quot;pluginVersion&quot;;     public static final String INSTALLATION_ID_KEY = &quot;installationId&quot;;     public static final String SESSION_ID_KEY = &quot;sessionId&quot;;     public static final String SUBSCRIPTION_ID_KEY = &quot;subscriptionId&quot;;     public static final String AUTH_TYPE = &quot;authType&quot;;     public static final String TELEMETRY_NOT_ALLOWED = &quot;TelemetryNotAllowed&quot;;     public static final String INIT_FAILURE = &quot;InitFailure&quot;;     public static final String AZURE_INIT_FAIL = &quot;Failed to authenticate with Azure. Please check your configuration.&quot;;     public static final String FAILURE_REASON = &quot;failureReason&quot;;     private static final String CONFIGURATION_PATH = Paths.get(System.getProperty(&quot;user.home&quot;),         &quot;.azure&quot;, &quot;mavenplugins.properties&quot;).toString();     private static final String FIRST_RUN_KEY = &quot;first.run&quot;;     private static final String PRIVACY_STATEMENT = &quot;\nData/Telemetry\n&quot; +         &quot;---------\n&quot; +         &quot;This project collects usage data and sends it to Microsoft to help improve our products and services.\n&quot; +         &quot;Read Microsoft's privacy statement to learn more: https://privacy.microsoft.com/en-us/privacystatement.&quot; +         &quot;\n\nYou can change your telemetry configuration through 'allowTelemetry' property.\n&quot; +         &quot;For more information, please go to https://aka.ms/azure-maven-config.\n&quot;;      //region Properties      @Parameter(defaultValue = &quot;${project}&quot;, readonly = true, required = true)     protected MavenProject project;      @Parameter(defaultValue = &quot;${session}&quot;, readonly = true, required = true)     protected MavenSession session;      @Parameter(defaultValue = &quot;${project.build.directory}&quot;, readonly = true, required = true)     protected File buildDirectory;      @Parameter(defaultValue = &quot;${plugin}&quot;, readonly = true, required = true)     protected PluginDescriptor plugin;      /**      * The system settings for Maven. This is the instance resulting from      * merging global and user-level settings files.      */     @Parameter(defaultValue = &quot;${settings}&quot;, readonly = true, required = true)     protected Settings settings;      @Component(role = MavenResourcesFiltering.class, hint = &quot;default&quot;)     protected MavenResourcesFiltering mavenResourcesFiltering;      /**      * Authentication setting for Azure Management API.      * Below are the supported sub-elements within {@code }. You can use one of them to authenticate      * with azure      * {@code } specifies the credentials of your Azure service principal, by referencing a server definition      * in Maven's settings.xml      * {@code } specifies the absolute path of your authentication file for Azure.      *      * @since 0.1.0      */     @Parameter     protected AuthenticationSetting authentication;      /**      * Azure subscription Id. You only need to specify it when:      *       * you are using authentication file      * there are more than one subscription in the authentication file      *       *      * @since 0.1.0      */     @Parameter     protected String subscriptionId = &quot;&quot;;      /**      * Boolean flag to turn on/off telemetry within current Maven plugin.      *      * @since 0.1.0      */     @Parameter(property = &quot;allowTelemetry&quot;, defaultValue = &quot;true&quot;)     protected boolean allowTelemetry;      /**      * Boolean flag to control whether throwing exception from current Maven plugin when meeting any error.      * If set to true, the exception from current Maven plugin will fail the current Maven run.      *      * @since 0.1.0      */     @Parameter(property = &quot;failsOnError&quot;, defaultValue = &quot;true&quot;)     protected boolean failsOnError;      /**      * Use a HTTP proxy host for the Azure Auth Client      */     @Parameter(property = &quot;httpProxyHost&quot;, readonly = false, required = false)     protected String httpProxyHost;      /**      * Use a HTTP proxy port for the Azure Auth Client      */     @Parameter(property = &quot;httpProxyPort&quot;, defaultValue = &quot;80&quot;)     protected int httpProxyPort;      private AzureAuthHelper azureAuthHelper = new AzureAuthHelper(this);      private Azure azure;      private TelemetryProxy telemetryProxy;      private String sessionId = UUID.randomUUID().toString();      private String installationId = GetHashMac.getHashMac();      //endregion      //region Getter      public MavenProject getProject() {         return project;     }      public MavenSession getSession() {         return session;     }      public String getBuildDirectoryAbsolutePath() {         return buildDirectory.getAbsolutePath();     }      public MavenResourcesFiltering getMavenResourcesFiltering() {         return mavenResourcesFiltering;     }      public Settings getSettings() {         return settings;     }      public AuthenticationSetting getAuthenticationSetting() {         return authentication;     }      public String getSubscriptionId() {         return subscriptionId;     }      public boolean isTelemetryAllowed() {         return allowTelemetry;     }      public boolean isFailingOnError() {         return failsOnError;     }      public String getSessionId() {         return sessionId;     }      public String getInstallationId() {         return installationId == null ? &quot;&quot; : installationId;     }      public String getPluginName() {         return plugin.getArtifactId();     }      public String getPluginVersion() {         return plugin.getVersion();     }      public String getUserAgent() {         return isTelemetryAllowed() ? String.format(&quot;%s/%s %s:%s %s:%s&quot;, getPluginName(), getPluginVersion(),                         INSTALLATION_ID_KEY, getInstallationId(), SESSION_ID_KEY, getSessionId())                 : String.format(&quot;%s/%s&quot;, getPluginName(), getPluginVersion());     }      public String getHttpProxyHost() {         return httpProxyHost;     }            public int getHttpProxyPort() {         return httpProxyPort;     }       public Azure getAzureClient() throws AzureAuthFailureException {         if (azure == null) {             azure = azureAuthHelper.getAzureClient();             if (azure == null) {                 getTelemetryProxy().trackEvent(INIT_FAILURE);                 throw new AzureAuthFailureException(AZURE_INIT_FAIL);             } else {                 // Repopulate subscriptionId in case it is not configured.                 getTelemetryProxy().addDefaultProperty(SUBSCRIPTION_ID_KEY, azure.subscriptionId());             }         }         return azure;     }      public TelemetryProxy getTelemetryProxy() {         if (telemetryProxy == null) {             initTelemetry();         }         return telemetryProxy;     }      protected void initTelemetry() {         telemetryProxy = new AppInsightsProxy(this);         if (!isTelemetryAllowed()) {             telemetryProxy.trackEvent(TELEMETRY_NOT_ALLOWED);             telemetryProxy.disable();         }     }      //endregion      //region Telemetry Configuration Interface      public Map getTelemetryProperties() {         final Map map = new HashMap&lt;&gt;();         map.put(INSTALLATION_ID_KEY, getInstallationId());         map.put(PLUGIN_NAME_KEY, getPluginName());         map.put(PLUGIN_VERSION_KEY, getPluginVersion());         map.put(SUBSCRIPTION_ID_KEY, getSubscriptionId());         map.put(SESSION_ID_KEY, getSessionId());         map.put(AUTH_TYPE, getAuthType());         return map;     }      // TODO:     // Add AuthType ENUM and move to AzureAuthHelper.     public String getAuthType() {         final AuthenticationSetting authSetting = getAuthenticationSetting();         if (authSetting == null) {             return &quot;AzureCLI&quot;;         }         if (StringUtils.isNotEmpty(authSetting.getServerId())) {             return &quot;ServerId&quot;;         }         if (authSetting.getFile() != null) {             return &quot;AuthFile&quot;;         }         return &quot;Unknown&quot;;     }      //endregion      //region Entry Point      @Override     public void execute() throws MojoExecutionException {         try {             // Work around for Application Insights Java SDK:             // Sometimes, NoClassDefFoundError will be thrown even after Maven build is completed successfully.             // An issue has been filed at https://github.com/Microsoft/ApplicationInsights-Java/issues/416             // Before this issue is fixed, set default uncaught exception handler for all threads as work around.             Thread.setDefaultUncaughtExceptionHandler(new DefaultUncaughtExceptionHandler());              final Properties prop = new Properties();             if (isFirstRun(prop)) {                 infoWithMultipleLines(PRIVACY_STATEMENT);                 updateConfigurationFile(prop);             }              if (isSkipMojo()) {                 info(&quot;Skip execution.&quot;);                 trackMojoSkip();             } else {                 trackMojoStart();                  doExecute();                  trackMojoSuccess();             }         } catch (Exception e) {             handleException(e);         } finally {             // When maven goal executes too quick, The HTTPClient of AI SDK may not fully initialized and will step             // into endless loop when close, we need to call it in main thread.             // Refer here for detail codes: https://github.com/Microsoft/ApplicationInsights-Java/blob/master/core/src             // /main/java/com/microsoft/applicationinsights/internal/channel/common/ApacheSender43.java#L103             ApacheSenderFactory.INSTANCE.create().close();         }     }      /**      * Sub-class can override this method to decide whether skip execution.      *      * @return Boolean to indicate whether skip execution.      */     protected boolean isSkipMojo() {         return false;     }      /**      * Entry point of sub-class. Sub-class should implement this method to do real work.      *      * @throws Exception      */     protected abstract void doExecute() throws Exception;      //endregion      //region Telemetry      protected void trackMojoSkip() {         getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + &quot;.skip&quot;);     }      protected void trackMojoStart() {         getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + &quot;.start&quot;);     }      protected void trackMojoSuccess() {         getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + &quot;.success&quot;);     }      protected void trackMojoFailure(final String message) {         final HashMap failureReason = new HashMap&lt;&gt;();         failureReason.put(FAILURE_REASON, message);         getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + &quot;.failure&quot;, failureReason);     }      //endregion      //region Helper methods      protected void handleException(final Exception exception) throws MojoExecutionException {         String message = exception.getMessage();         if (StringUtils.isEmpty(message)) {             message = exception.toString();         }         trackMojoFailure(message);          if (isFailingOnError()) {             throw new MojoExecutionException(message, exception);         } else {             error(message);         }     }      private boolean isFirstRun(Properties prop) {         try {             final File configurationFile = new File(CONFIGURATION_PATH);             if (configurationFile.exists()) {                 try (InputStream input = new FileInputStream(CONFIGURATION_PATH)) {                     prop.load(input);                     final String firstRunValue = prop.getProperty(FIRST_RUN_KEY);                     if (firstRunValue != null &amp;&amp; !firstRunValue.isEmpty() &amp;&amp; firstRunValue.equalsIgnoreCase(&quot;false&quot;)) {                         return false;                     }                 }             } else {                 configurationFile.getParentFile().mkdirs();                 configurationFile.createNewFile();             }         } catch (Exception e) {             // catch exceptions here to avoid blocking mojo execution.             debug(e.getMessage());         }         return true;     }      private void updateConfigurationFile(Properties prop) {         try (OutputStream output = new FileOutputStream(CONFIGURATION_PATH)) {             prop.setProperty(FIRST_RUN_KEY, &quot;false&quot;);             prop.store(output, &quot;Azure Maven Plugin configurations&quot;);         } catch (Exception e) {             // catch exceptions here to avoid blocking mojo execution.             debug(e.getMessage());         }     }      protected class DefaultUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {         @Override         public void uncaughtException(Thread t, Throwable e) {             debug(&quot;uncaughtException: &quot; + e);         }     }      //endregion      //region Logging      public void debug(final String message) {         getLog().debug(message);     }      public void info(final String message) {         getLog().info(message);     }      public void infoWithMultipleLines(final String messages) {         final String[] messageArray = messages.split(&quot;\\n&quot;);         for (final String line : messageArray) {             getLog().info(line);         }     }      public void warning(final String message) {         getLog().warn(message);     }      public void error(final String message) {         getLog().error(message);     }      //endregion }</td>
    <td align="left">data class</td>
    <td align="left">1 Long Method, 2 Blob, 3 Data Class, 4 Feature Envy</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">1. Long Method,  2. Blob,  4. Feature Envy</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10932</td>
    <td align="left">https://github.com/Microsoft/azure-maven-plugins/blob/d3e0b6fa0e00f38c04b622589a939fb3bae2227e/azure-maven-plugin-lib/src/main/java/com/microsoft/azure/maven/AbstractAzureMojo.java/#L45-L447</td>
    <td align="right">1</td>
    <td align="right">1422</td>
    <td align="right">10932</td>
  </tr>
  <tr valign="top">
    <td align="right">1434</td>
    <td align="left">{&quot;answer&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@javax.annotation.Generated(value = &quot;OracleSDKGenerator&quot;, comments = &quot;API Version: 20180115&quot;) @lombok.AllArgsConstructor(onConstructor = @__({@Deprecated})) @lombok.Value @com.fasterxml.jackson.databind.annotation.JsonDeserialize(     builder = CreateZoneDetails.Builder.class ) @com.fasterxml.jackson.annotation.JsonFilter(com.oracle.bmc.http.internal.ExplicitlySetFilter.NAME) public class CreateZoneDetails {     @com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder(withPrefix = &quot;&quot;)     @lombok.experimental.Accessors(fluent = true)     public static class Builder {         @com.fasterxml.jackson.annotation.JsonProperty(&quot;name&quot;)         private String name;          public Builder name(String name) {             this.name = name;             this.__explicitlySet__.add(&quot;name&quot;);             return this;         }          @com.fasterxml.jackson.annotation.JsonProperty(&quot;zoneType&quot;)         private ZoneType zoneType;          public Builder zoneType(ZoneType zoneType) {             this.zoneType = zoneType;             this.__explicitlySet__.add(&quot;zoneType&quot;);             return this;         }          @com.fasterxml.jackson.annotation.JsonProperty(&quot;compartmentId&quot;)         private String compartmentId;          public Builder compartmentId(String compartmentId) {             this.compartmentId = compartmentId;             this.__explicitlySet__.add(&quot;compartmentId&quot;);             return this;         }          @com.fasterxml.jackson.annotation.JsonProperty(&quot;freeformTags&quot;)         private java.util.Map freeformTags;          public Builder freeformTags(java.util.Map freeformTags) {             this.freeformTags = freeformTags;             this.__explicitlySet__.add(&quot;freeformTags&quot;);             return this;         }          @com.fasterxml.jackson.annotation.JsonProperty(&quot;definedTags&quot;)         private java.util.Map&gt; definedTags;          public Builder definedTags(                 java.util.Map&gt; definedTags) {             this.definedTags = definedTags;             this.__explicitlySet__.add(&quot;definedTags&quot;);             return this;         }          @com.fasterxml.jackson.annotation.JsonProperty(&quot;externalMasters&quot;)         private java.util.List externalMasters;          public Builder externalMasters(java.util.List externalMasters) {             this.externalMasters = externalMasters;             this.__explicitlySet__.add(&quot;externalMasters&quot;);             return this;         }          @com.fasterxml.jackson.annotation.JsonIgnore         private final java.util.Set __explicitlySet__ = new java.util.HashSet();          public CreateZoneDetails build() {             CreateZoneDetails __instance__ =                     new CreateZoneDetails(                             name,                             zoneType,                             compartmentId,                             freeformTags,                             definedTags,                             externalMasters);             __instance__.__explicitlySet__.addAll(__explicitlySet__);             return __instance__;         }          @com.fasterxml.jackson.annotation.JsonIgnore         public Builder copy(CreateZoneDetails o) {             Builder copiedBuilder =                     name(o.getName())                             .zoneType(o.getZoneType())                             .compartmentId(o.getCompartmentId())                             .freeformTags(o.getFreeformTags())                             .definedTags(o.getDefinedTags())                             .externalMasters(o.getExternalMasters());              copiedBuilder.__explicitlySet__.retainAll(o.__explicitlySet__);             return copiedBuilder;         }     }      /**      * Create a new builder.      */     public static Builder builder() {         return new Builder();     }      /**      * The name of the zone.      **/     @com.fasterxml.jackson.annotation.JsonProperty(&quot;name&quot;)     String name;     /**      * The type of the zone. Must be either `PRIMARY` or `SECONDARY`.      *      **/     public enum ZoneType {         Primary(&quot;PRIMARY&quot;),         Secondary(&quot;SECONDARY&quot;),         ;          private final String value;         private static java.util.Map map;          static {             map = new java.util.HashMap&lt;&gt;();             for (ZoneType v : ZoneType.values()) {                 map.put(v.getValue(), v);             }         }          ZoneType(String value) {             this.value = value;         }          @com.fasterxml.jackson.annotation.JsonValue         public String getValue() {             return value;         }          @com.fasterxml.jackson.annotation.JsonCreator         public static ZoneType create(String key) {             if (map.containsKey(key)) {                 return map.get(key);             }             throw new RuntimeException(&quot;Invalid ZoneType: &quot; + key);         }     };     /**      * The type of the zone. Must be either `PRIMARY` or `SECONDARY`.      *      **/     @com.fasterxml.jackson.annotation.JsonProperty(&quot;zoneType&quot;)     ZoneType zoneType;      /**      * The OCID of the compartment containing the zone.      **/     @com.fasterxml.jackson.annotation.JsonProperty(&quot;compartmentId&quot;)     String compartmentId;      /**      * Simple key-value pair that is applied without any predefined name, type, or scope.      * For more information, see [Resource Tags](https://docs.cloud.oracle.com/Content/General/Concepts/resourcetags.htm).      * Example: `{\&quot;bar-key\&quot;: \&quot;value\&quot;}`      *      **/     @com.fasterxml.jackson.annotation.JsonProperty(&quot;freeformTags&quot;)     java.util.Map freeformTags;      /**      * Usage of predefined tag keys. These predefined keys are scoped to a namespace.      * Example: `{\&quot;foo-namespace\&quot;: {\&quot;bar-key\&quot;: \&quot;value\&quot;}}`      *      **/     @com.fasterxml.jackson.annotation.JsonProperty(&quot;definedTags&quot;)     java.util.Map&gt; definedTags;      /**      * External master servers for the zone. `externalMasters` becomes a      * required parameter when the `zoneType` value is `SECONDARY`.      *      **/     @com.fasterxml.jackson.annotation.JsonProperty(&quot;externalMasters&quot;)     java.util.List externalMasters;      @com.fasterxml.jackson.annotation.JsonIgnore     private final java.util.Set __explicitlySet__ = new java.util.HashSet(); }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">10959</td>
    <td align="left">https://github.com/oracle/oci-java-sdk/blob/76e9cecd7b309d9f12e5efe96c74167c66a98872/bmc-dns/src/main/java/com/oracle/bmc/dns/model/CreateZoneDetails.java/#L19-L204</td>
    <td align="right">1</td>
    <td align="right">1434</td>
    <td align="right">10959</td>
  </tr>
  <tr valign="top">
    <td align="right">1446</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public void read(org.apache.thrift.protocol.TProtocol iprot, FetchRuleKeyLogsRequest struct) throws org.apache.thrift.TException {       org.apache.thrift.protocol.TField schemeField;       iprot.readStructBegin();       while (true)       {         schemeField = iprot.readFieldBegin();         if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;         }         switch (schemeField.id) {           case 1: // RULE_KEYS             if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {               {                 org.apache.thrift.protocol.TList _list184 = iprot.readListBegin();                 struct.ruleKeys = new java.util.ArrayList(_list184.size);                 java.lang.String _elem185;                 for (int _i186 = 0; _i186 &lt; _list184.size; ++_i186)                 {                   _elem185 = iprot.readString();                   struct.ruleKeys.add(_elem185);                 }                 iprot.readListEnd();               }               struct.setRuleKeysIsSet(true);             } else {                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);             }             break;           case 2: // REPOSITORY             if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {               struct.repository = iprot.readString();               struct.setRepositoryIsSet(true);             } else {                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);             }             break;           case 3: // SCHEDULE_TYPE             if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {               struct.scheduleType = iprot.readString();               struct.setScheduleTypeIsSet(true);             } else {                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);             }             break;           case 4: // DISTRIBUTED_BUILD_MODE_ENABLED             if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {               struct.distributedBuildModeEnabled = iprot.readBool();               struct.setDistributedBuildModeEnabledIsSet(true);             } else {                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);             }             break;           default:             org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);         }         iprot.readFieldEnd();       }       iprot.readStructEnd();        // check for required fields of primitive type, which can't be checked in the validate method       struct.validate();     }</td>
    <td align="left">long method</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10983</td>
    <td align="left">https://github.com/facebook/buck/blob/1bc8d383ea5cb153ca9bf4f2807e6be498648523/src-gen/com/facebook/buck/distributed/thrift/FetchRuleKeyLogsRequest.java/#L547-L608</td>
    <td align="right">1</td>
    <td align="right">1446</td>
    <td align="right">10983</td>
  </tr>
  <tr valign="top">
    <td align="right">1472</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MultiSpinnerUI extends SpinnerUI {      /**      * The vector containing the real UIs.  This is populated      * in the call to createUI, and can be obtained by calling      * the getUIs method.  The first element is guaranteed to be the real UI      * obtained from the default look and feel.      */     protected Vector uis = new Vector&lt;&gt;();  //////////////////// // Common UI methods ////////////////////      /**      * Returns the list of UIs associated with this multiplexing UI.  This      * allows processing of the UIs by an application aware of multiplexing      * UIs on components.      *      * @return an array of the UI delegates      */     public ComponentUI[] getUIs() {         return MultiLookAndFeel.uisToArray(uis);     }  //////////////////// // SpinnerUI methods ////////////////////  //////////////////// // ComponentUI methods ////////////////////      /**      * Invokes the contains method on each UI handled by this object.      *      * @return the value obtained from the first UI, which is      * the UI obtained from the default LookAndFeel      */     public boolean contains(JComponent a, int b, int c) {         boolean returnValue =             uis.elementAt(0).contains(a,b,c);         for (int i = 1; i &lt; uis.size(); i++) {             uis.elementAt(i).contains(a,b,c);         }         return returnValue;     }      /**      * Invokes the update method on each UI handled by this object.      */     public void update(Graphics a, JComponent b) {         for (int i = 0; i &lt; uis.size(); i++) {             uis.elementAt(i).update(a,b);         }     }      /**      * Returns a multiplexing UI instance if any of the auxiliary      * LookAndFeels supports this UI.  Otherwise, just returns the      * UI object obtained from the default LookAndFeel.      *      * @param  a the component to create the UI for      * @return the UI delegate created      */     public static ComponentUI createUI(JComponent a) {         MultiSpinnerUI mui = new MultiSpinnerUI();         return MultiLookAndFeel.createUIs(mui, mui.uis, a);     }      /**      * Invokes the installUI method on each UI handled by this object.      */     public void installUI(JComponent a) {         for (int i = 0; i &lt; uis.size(); i++) {             uis.elementAt(i).installUI(a);         }     }      /**      * Invokes the uninstallUI method on each UI handled by this object.      */     public void uninstallUI(JComponent a) {         for (int i = 0; i &lt; uis.size(); i++) {             uis.elementAt(i).uninstallUI(a);         }     }      /**      * Invokes the paint method on each UI handled by this object.      */     public void paint(Graphics a, JComponent b) {         for (int i = 0; i &lt; uis.size(); i++) {             uis.elementAt(i).paint(a,b);         }     }      /**      * Invokes the getPreferredSize method on each UI handled by this object.      *      * @return the value obtained from the first UI, which is      * the UI obtained from the default LookAndFeel      */     public Dimension getPreferredSize(JComponent a) {         Dimension returnValue =             uis.elementAt(0).getPreferredSize(a);         for (int i = 1; i &lt; uis.size(); i++) {             uis.elementAt(i).getPreferredSize(a);         }         return returnValue;     }      /**      * Invokes the getMinimumSize method on each UI handled by this object.      *      * @return the value obtained from the first UI, which is      * the UI obtained from the default LookAndFeel      */     public Dimension getMinimumSize(JComponent a) {         Dimension returnValue =             uis.elementAt(0).getMinimumSize(a);         for (int i = 1; i &lt; uis.size(); i++) {             uis.elementAt(i).getMinimumSize(a);         }         return returnValue;     }      /**      * Invokes the getMaximumSize method on each UI handled by this object.      *      * @return the value obtained from the first UI, which is      * the UI obtained from the default LookAndFeel      */     public Dimension getMaximumSize(JComponent a) {         Dimension returnValue =             uis.elementAt(0).getMaximumSize(a);         for (int i = 1; i &lt; uis.size(); i++) {             uis.elementAt(i).getMaximumSize(a);         }         return returnValue;     }      /**      * Invokes the getAccessibleChildrenCount method on each UI handled by this object.      *      * @return the value obtained from the first UI, which is      * the UI obtained from the default LookAndFeel      */     public int getAccessibleChildrenCount(JComponent a) {         int returnValue =             uis.elementAt(0).getAccessibleChildrenCount(a);         for (int i = 1; i &lt; uis.size(); i++) {             uis.elementAt(i).getAccessibleChildrenCount(a);         }         return returnValue;     }      /**      * Invokes the getAccessibleChild method on each UI handled by this object.      *      * @return the value obtained from the first UI, which is      * the UI obtained from the default LookAndFeel      */     public Accessible getAccessibleChild(JComponent a, int b) {         Accessible returnValue =             uis.elementAt(0).getAccessibleChild(a,b);         for (int i = 1; i &lt; uis.size(); i++) {             uis.elementAt(i).getAccessibleChild(a,b);         }         return returnValue;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">11052</td>
    <td align="left">https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/java.desktop/share/classes/javax/swing/plaf/multi/MultiSpinnerUI.java/#L43-L214</td>
    <td align="right">1</td>
    <td align="right">1472</td>
    <td align="right">11052</td>
  </tr>
  <tr valign="top">
    <td align="right">1479</td>
    <td align="left">&nbsp;{   &quot;response&quot;: &quot;YES I found bad smells&quot;,   &quot;the bad smells are&quot;: [     &quot;Blob&quot;,     &quot;Data Class&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlTransient public abstract class PendingActionNotificationResponse     extends ImmutableObject implements ResponseData {    /** The inner name type that contains a name and the result boolean. */   @Embed   static class NameOrId extends ImmutableObject {     @XmlValue     String value;      @XmlAttribute(name = &quot;paResult&quot;)     boolean actionResult;   }    @XmlTransient   NameOrId nameOrId;    @XmlElement(name = &quot;paTRID&quot;)   Trid trid;    @XmlElement(name = &quot;paDate&quot;)   DateTime processedDate;    public String getNameAsString() {     return nameOrId.value;   }    @VisibleForTesting   public Trid getTrid() {     return trid;   }    @VisibleForTesting   public boolean getActionResult() {     return nameOrId.actionResult;   }    protected static  T init(       T response, String nameOrId, boolean actionResult, Trid trid, DateTime processedDate) {     response.nameOrId = new NameOrId();     response.nameOrId.value = nameOrId;     response.nameOrId.actionResult = actionResult;     response.trid = trid;     response.processedDate = processedDate;     return response;   }    /** An adapter to output the XML in response to resolving a pending command on a domain. */   @Embed   @XmlRootElement(name = &quot;panData&quot;, namespace = &quot;urn:ietf:params:xml:ns:domain-1.0&quot;)   @XmlType(       propOrder = {&quot;name&quot;, &quot;trid&quot;, &quot;processedDate&quot;},       namespace = &quot;urn:ietf:params:xml:ns:domain-1.0&quot;)   public static class DomainPendingActionNotificationResponse       extends PendingActionNotificationResponse {      @XmlElement     NameOrId getName() {       return nameOrId;     }      public static DomainPendingActionNotificationResponse create(         String fullyQualifiedDomainName, boolean actionResult, Trid trid, DateTime processedDate) {       return init(           new DomainPendingActionNotificationResponse(),           fullyQualifiedDomainName,           actionResult,           trid,           processedDate);     }   }    /** An adapter to output the XML in response to resolving a pending command on a contact. */   @Embed   @XmlRootElement(name = &quot;panData&quot;, namespace = &quot;urn:ietf:params:xml:ns:contact-1.0&quot;)   @XmlType(       propOrder = {&quot;id&quot;, &quot;trid&quot;, &quot;processedDate&quot;},       namespace = &quot;urn:ietf:params:xml:ns:contact-1.0&quot;)   public static class ContactPendingActionNotificationResponse       extends PendingActionNotificationResponse {      @XmlElement     NameOrId getId() {       return nameOrId;     }      public static ContactPendingActionNotificationResponse create(         String contactId, boolean actionResult, Trid trid, DateTime processedDate) {       return init(           new ContactPendingActionNotificationResponse(),           contactId,           actionResult,           trid,           processedDate);     }   }    /** An adapter to output the XML in response to resolving a pending command on a host. */   @Embed   @XmlRootElement(name = &quot;panData&quot;, namespace = &quot;urn:ietf:params:xml:ns:domain-1.0&quot;)   @XmlType(     propOrder = {&quot;name&quot;, &quot;trid&quot;, &quot;processedDate&quot;},     namespace = &quot;urn:ietf:params:xml:ns:domain-1.0&quot;   )   public static class HostPendingActionNotificationResponse       extends PendingActionNotificationResponse {      @XmlElement     NameOrId getName() {       return nameOrId;     }      public static HostPendingActionNotificationResponse create(         String fullyQualifiedHostName, boolean actionResult, Trid trid, DateTime processedDate) {       return init(           new HostPendingActionNotificationResponse(),           fullyQualifiedHostName,           actionResult,           trid,           processedDate);     }   } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11069</td>
    <td align="left">https://github.com/google/nomulus/blob/2481704d00f10f6b5675dd26f9effaad434ddbea/java/google/registry/model/poll/PendingActionNotificationResponse.java/#L31-L153</td>
    <td align="right">1</td>
    <td align="right">1479</td>
    <td align="right">11069</td>
  </tr>
  <tr valign="top">
    <td align="right">1492</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public class TypeRefWithoutModifiersElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.n4js.ts.TypeExpressions.TypeRefWithoutModifiers&quot;); 		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1); 		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0); 		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0); 		private final RuleCall cParameterizedTypeRefParserRuleCall_0_0_0 = (RuleCall)cAlternatives_0_0.eContents().get(0); 		private final RuleCall cThisTypeRefParserRuleCall_0_0_1 = (RuleCall)cAlternatives_0_0.eContents().get(1); 		private final Assignment cDynamicAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1); 		private final Keyword cDynamicPlusSignKeyword_0_1_0 = (Keyword)cDynamicAssignment_0_1.eContents().get(0); 		private final RuleCall cTypeTypeRefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1); 		private final RuleCall cFunctionTypeExpressionOLDParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2); 		private final RuleCall cUnionTypeExpressionOLDParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3); 		private final RuleCall cIntersectionTypeExpressionOLDParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4); 		 		//TypeRefWithoutModifiers StaticBaseTypeRef: 		//	(ParameterizedTypeRef | ThisTypeRef) =&gt; dynamic?='+'? | TypeTypeRef 		//	| FunctionTypeExpressionOLD 		//	| UnionTypeExpressionOLD 		//	| IntersectionTypeExpressionOLD; 		@Override public ParserRule getRule() { return rule; } 		 		//(ParameterizedTypeRef | ThisTypeRef) =&gt; dynamic?='+'? | TypeTypeRef | FunctionTypeExpressionOLD | UnionTypeExpressionOLD 		//| IntersectionTypeExpressionOLD 		public Alternatives getAlternatives() { return cAlternatives; } 		 		//(ParameterizedTypeRef | ThisTypeRef) =&gt; dynamic?='+'? 		public Group getGroup_0() { return cGroup_0; } 		 		//ParameterizedTypeRef | ThisTypeRef 		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; } 		 		//ParameterizedTypeRef 		public RuleCall getParameterizedTypeRefParserRuleCall_0_0_0() { return cParameterizedTypeRefParserRuleCall_0_0_0; } 		 		//ThisTypeRef 		public RuleCall getThisTypeRefParserRuleCall_0_0_1() { return cThisTypeRefParserRuleCall_0_0_1; } 		 		//=&gt; dynamic?='+'? 		public Assignment getDynamicAssignment_0_1() { return cDynamicAssignment_0_1; } 		 		//'+' 		public Keyword getDynamicPlusSignKeyword_0_1_0() { return cDynamicPlusSignKeyword_0_1_0; } 		 		//TypeTypeRef 		public RuleCall getTypeTypeRefParserRuleCall_1() { return cTypeTypeRefParserRuleCall_1; } 		 		//FunctionTypeExpressionOLD 		public RuleCall getFunctionTypeExpressionOLDParserRuleCall_2() { return cFunctionTypeExpressionOLDParserRuleCall_2; } 		 		//UnionTypeExpressionOLD 		public RuleCall getUnionTypeExpressionOLDParserRuleCall_3() { return cUnionTypeExpressionOLDParserRuleCall_3; } 		 		//IntersectionTypeExpressionOLD 		public RuleCall getIntersectionTypeExpressionOLDParserRuleCall_4() { return cIntersectionTypeExpressionOLDParserRuleCall_4; } 	}</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11118</td>
    <td align="left">https://github.com/eclipse/n4js/blob/f715912fce0352ab574ff878086f77d17a78c908/plugins/org.eclipse.n4js.ts/src-gen/org/eclipse/n4js/ts/services/TypeExpressionsGrammarAccess.java/#L201-L255</td>
    <td align="right">1</td>
    <td align="right">1492</td>
    <td align="right">11118</td>
  </tr>
  <tr valign="top">
    <td align="right">1519</td>
    <td align="left">&nbsp;&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
        @Override         public void startElement(final String uri, final String localName, final String qname, final Attributes attributes) throws SAXException         {             // Verify and initialize the context stack at root element.             if (contextStack.size() == 0)             {                 if (!qname.equals(rootElement))                 {                     throw new SAXConfigurationException(                             new ConfigurationException.IncorrectElement(rootElement, qname, this.source, locator.getLineNumber()),                             locator);                 }                                 String all = attributes.getValue(&quot;includeAllClasses&quot;);                 if (&quot;true&quot;.equals(all))                     allClasses = true;                 contextStack.push(qname);                 return;             }             else             {                 if (qname.equals(&quot;classEntry&quot;))                 {                     String path = attributes.getValue(&quot;path&quot;);                     includedClasses.add(path);                 }                 else if (qname.equals(&quot;namespaceManifestEntry&quot;))                 {                     String manifest = attributes.getValue(&quot;manifest&quot;);                     String namespace = attributes.getValue(&quot;namespace&quot;);                     fbArgs.add(&quot;-namespace&quot;);                     fbArgs.add(namespace);                     String mf = contextPath + &quot;/&quot; + manifest;                     File f = new File(mf);                     if (!f.exists())                     {                         mf = contextPath + &quot;/src/&quot; + manifest;                     }                     fbArgs.add(mf);                     fbArgs.add(&quot;-include-namespaces&quot;);                     fbArgs.add(namespace);                                     }             }         }</td>
    <td align="left">feature envy</td>
    <td align="left">Blob, Long Method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">f</td>
    <td align="left">Blob,  Long Method</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">11171</td>
    <td align="left">https://github.com/apache/royale-compiler/blob/fbd9bc3b9e48c80dbd8c1d32a6f83221e314efdd/compiler-common/src/main/java/org/apache/royale/compiler/internal/config/FlashBuilderConfigurator.java/#L468-L510</td>
    <td align="right">1</td>
    <td align="right">1519</td>
    <td align="right">11171</td>
  </tr>
  <tr valign="top">
    <td align="right">1522</td>
    <td align="left">&nbsp;		{ 			&quot;message&quot;: &quot;YES I found bad smells&quot;, 			&quot;bad smells are&quot;: [ 				&quot;Blob&quot;, 				&quot;Data Class&quot;, 				&quot;Long Method&quot; 			] 		} </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  public static class RowRange {     private Text startRow;     private Text endRow;      public RowRange(KeyExtent ke) {       this.startRow = ke.getPrevEndRow();       this.endRow = ke.getEndRow();     }      public RowRange(TRowRange trr) {       this.startRow = ByteBufferUtil.toText(trr.startRow);       this.endRow = ByteBufferUtil.toText(trr.endRow);     }      public RowRange(Text startRow, Text endRow) {       this.startRow = startRow;       this.endRow = endRow;     }      public Range toRange() {       return new Range(startRow, false, endRow, true);     }      public TRowRange toThrift() {       return new TRowRange(TextUtil.getByteBuffer(startRow), TextUtil.getByteBuffer(endRow));     }      public Text getStartRow() {       return startRow;     }      public Text getEndRow() {       return endRow;     }      @Override     public String toString() {       return startRow + &quot; &quot; + endRow;     }   }</td>
    <td align="left">data class</td>
    <td align="left">Blob, Data Class, Long Method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">Blob,  Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11174</td>
    <td align="left">https://github.com/apache/accumulo/blob/f896c98c2356a52dfa2235d2cc02ae556ab17909/core/src/main/java/org/apache/accumulo/core/summary/Gatherer.java/#L617-L656</td>
    <td align="right">1</td>
    <td align="right">1522</td>
    <td align="right">11174</td>
  </tr>
  <tr valign="top">
    <td align="right">1559</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{       &quot;message&quot;: &quot;YES I found bad smells&quot;,       &quot;bad smells are&quot;: [         &quot;Long Method&quot;,         &quot;Blob&quot;       ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public float computeTableUnit(PercentBaseContext percentBaseContext, int contentAreaIPD) {          int sumCols = 0;         float factors = 0;         float unit = 0;          /* calculate the total width (specified absolute/percentages),          * and work out the total number of factors to use to distribute          * the remaining space (if any)          */         for (Object colWidth1 : colWidths) {             Length colWidth = (Length) colWidth1;             if (colWidth != null) {                 sumCols += colWidth.getValue(percentBaseContext);                 if (colWidth instanceof RelativeNumericProperty) {                     factors += ((RelativeNumericProperty) colWidth).getTableUnits();                 } else if (colWidth instanceof TableColLength) {                     factors += ((TableColLength) colWidth).getTableUnits();                 }             }         }          /* distribute the remaining space over the accumulated          * factors (if any)          */         if (factors &gt; 0) {             if (sumCols &lt; contentAreaIPD) {                 unit = (contentAreaIPD - sumCols) / factors;             } else {                 log.warn(&quot;No space remaining to distribute over columns.&quot;);             }         }          return unit;     }</td>
    <td align="left">long method</td>
    <td align="left">Long Method, Blob</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;Blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11300</td>
    <td align="left">https://github.com/apache/fop/blob/caced35327f6b6d6eeac2a13543f3c458e902101/fop-core/src/main/java/org/apache/fop/layoutmgr/table/ColumnSetup.java/#L201-L235</td>
    <td align="right">1</td>
    <td align="right">1559</td>
    <td align="right">11300</td>
  </tr>
  <tr valign="top">
    <td align="right">1570</td>
    <td align="left">&nbsp;&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;the bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DataBinder implements PropertyEditorRegistry, TypeConverter {  	/** Default object name used for binding: &quot;target&quot;. */ 	public static final String DEFAULT_OBJECT_NAME = &quot;target&quot;;  	/** Default limit for array and collection growing: 256. */ 	public static final int DEFAULT_AUTO_GROW_COLLECTION_LIMIT = 256;   	/** 	 * We'll create a lot of DataBinder instances: Let's use a static logger. 	 */ 	protected static final Log logger = LogFactory.getLog(DataBinder.class);  	@Nullable 	private final Object target;  	private final String objectName;  	@Nullable 	private AbstractPropertyBindingResult bindingResult;  	@Nullable 	private SimpleTypeConverter typeConverter;  	private boolean ignoreUnknownFields = true;  	private boolean ignoreInvalidFields = false;  	private boolean autoGrowNestedPaths = true;  	private int autoGrowCollectionLimit = DEFAULT_AUTO_GROW_COLLECTION_LIMIT;  	@Nullable 	private String[] allowedFields;  	@Nullable 	private String[] disallowedFields;  	@Nullable 	private String[] requiredFields;  	@Nullable 	private ConversionService conversionService;  	@Nullable 	private MessageCodesResolver messageCodesResolver;  	private BindingErrorProcessor bindingErrorProcessor = new DefaultBindingErrorProcessor();  	private final List validators = new ArrayList&lt;&gt;();   	/** 	 * Create a new DataBinder instance, with default object name. 	 * @param target the target object to bind onto (or {@code null} 	 * if the binder is just used to convert a plain parameter value) 	 * @see #DEFAULT_OBJECT_NAME 	 */ 	public DataBinder(@Nullable Object target) { 		this(target, DEFAULT_OBJECT_NAME); 	}  	/** 	 * Create a new DataBinder instance. 	 * @param target the target object to bind onto (or {@code null} 	 * if the binder is just used to convert a plain parameter value) 	 * @param objectName the name of the target object 	 */ 	public DataBinder(@Nullable Object target, String objectName) { 		this.target = ObjectUtils.unwrapOptional(target); 		this.objectName = objectName; 	}   	/** 	 * Return the wrapped target object. 	 */ 	@Nullable 	public Object getTarget() { 		return this.target; 	}  	/** 	 * Return the name of the bound object. 	 */ 	public String getObjectName() { 		return this.objectName; 	}  	/** 	 * Set whether this binder should attempt to &quot;auto-grow&quot; a nested path that contains a null value. 	 * If &quot;true&quot;, a null path location will be populated with a default object value and traversed 	 * instead of resulting in an exception. This flag also enables auto-growth of collection elements 	 * when accessing an out-of-bounds index. 	 * Default is &quot;true&quot; on a standard DataBinder. Note that since Spring 4.1 this feature is supported 	 * for bean property access (DataBinder's default mode) and field access. 	 * @see #initBeanPropertyAccess() 	 * @see org.springframework.beans.BeanWrapper#setAutoGrowNestedPaths 	 */ 	public void setAutoGrowNestedPaths(boolean autoGrowNestedPaths) { 		Assert.state(this.bindingResult == null, 				&quot;DataBinder is already initialized - call setAutoGrowNestedPaths before other configuration methods&quot;); 		this.autoGrowNestedPaths = autoGrowNestedPaths; 	}  	/** 	 * Return whether &quot;auto-growing&quot; of nested paths has been activated. 	 */ 	public boolean isAutoGrowNestedPaths() { 		return this.autoGrowNestedPaths; 	}  	/** 	 * Specify the limit for array and collection auto-growing. 	 * Default is 256, preventing OutOfMemoryErrors in case of large indexes. 	 * Raise this limit if your auto-growing needs are unusually high. 	 * @see #initBeanPropertyAccess() 	 * @see org.springframework.beans.BeanWrapper#setAutoGrowCollectionLimit 	 */ 	public void setAutoGrowCollectionLimit(int autoGrowCollectionLimit) { 		Assert.state(this.bindingResult == null, 				&quot;DataBinder is already initialized - call setAutoGrowCollectionLimit before other configuration methods&quot;); 		this.autoGrowCollectionLimit = autoGrowCollectionLimit; 	}  	/** 	 * Return the current limit for array and collection auto-growing. 	 */ 	public int getAutoGrowCollectionLimit() { 		return this.autoGrowCollectionLimit; 	}  	/** 	 * Initialize standard JavaBean property access for this DataBinder. 	 * This is the default; an explicit call just leads to eager initialization. 	 * @see #initDirectFieldAccess() 	 * @see #createBeanPropertyBindingResult() 	 */ 	public void initBeanPropertyAccess() { 		Assert.state(this.bindingResult == null, 				&quot;DataBinder is already initialized - call initBeanPropertyAccess before other configuration methods&quot;); 		this.bindingResult = createBeanPropertyBindingResult(); 	}  	/** 	 * Create the {@link AbstractPropertyBindingResult} instance using standard 	 * JavaBean property access. 	 * @since 4.2.1 	 */ 	protected AbstractPropertyBindingResult createBeanPropertyBindingResult() { 		BeanPropertyBindingResult result = new BeanPropertyBindingResult(getTarget(), 				getObjectName(), isAutoGrowNestedPaths(), getAutoGrowCollectionLimit());  		if (this.conversionService != null) { 			result.initConversion(this.conversionService); 		} 		if (this.messageCodesResolver != null) { 			result.setMessageCodesResolver(this.messageCodesResolver); 		}  		return result; 	}  	/** 	 * Initialize direct field access for this DataBinder, 	 * as alternative to the default bean property access. 	 * @see #initBeanPropertyAccess() 	 * @see #createDirectFieldBindingResult() 	 */ 	public void initDirectFieldAccess() { 		Assert.state(this.bindingResult == null, 				&quot;DataBinder is already initialized - call initDirectFieldAccess before other configuration methods&quot;); 		this.bindingResult = createDirectFieldBindingResult(); 	}  	/** 	 * Create the {@link AbstractPropertyBindingResult} instance using direct 	 * field access. 	 * @since 4.2.1 	 */ 	protected AbstractPropertyBindingResult createDirectFieldBindingResult() { 		DirectFieldBindingResult result = new DirectFieldBindingResult(getTarget(), 				getObjectName(), isAutoGrowNestedPaths());  		if (this.conversionService != null) { 			result.initConversion(this.conversionService); 		} 		if (this.messageCodesResolver != null) { 			result.setMessageCodesResolver(this.messageCodesResolver); 		}  		return result; 	}  	/** 	 * Return the internal BindingResult held by this DataBinder, 	 * as an AbstractPropertyBindingResult. 	 */ 	protected AbstractPropertyBindingResult getInternalBindingResult() { 		if (this.bindingResult == null) { 			initBeanPropertyAccess(); 		} 		return this.bindingResult; 	}  	/** 	 * Return the underlying PropertyAccessor of this binder's BindingResult. 	 */ 	protected ConfigurablePropertyAccessor getPropertyAccessor() { 		return getInternalBindingResult().getPropertyAccessor(); 	}  	/** 	 * Return this binder's underlying SimpleTypeConverter. 	 */ 	protected SimpleTypeConverter getSimpleTypeConverter() { 		if (this.typeConverter == null) { 			this.typeConverter = new SimpleTypeConverter(); 			if (this.conversionService != null) { 				this.typeConverter.setConversionService(this.conversionService); 			} 		} 		return this.typeConverter; 	}  	/** 	 * Return the underlying TypeConverter of this binder's BindingResult. 	 */ 	protected PropertyEditorRegistry getPropertyEditorRegistry() { 		if (getTarget() != null) { 			return getInternalBindingResult().getPropertyAccessor(); 		} 		else { 			return getSimpleTypeConverter(); 		} 	}  	/** 	 * Return the underlying TypeConverter of this binder's BindingResult. 	 */ 	protected TypeConverter getTypeConverter() { 		if (getTarget() != null) { 			return getInternalBindingResult().getPropertyAccessor(); 		} 		else { 			return getSimpleTypeConverter(); 		} 	}  	/** 	 * Return the BindingResult instance created by this DataBinder. 	 * This allows for convenient access to the binding results after 	 * a bind operation. 	 * @return the BindingResult instance, to be treated as BindingResult 	 * or as Errors instance (Errors is a super-interface of BindingResult) 	 * @see Errors 	 * @see #bind 	 */ 	public BindingResult getBindingResult() { 		return getInternalBindingResult(); 	}   	/** 	 * Set whether to ignore unknown fields, that is, whether to ignore bind 	 * parameters that do not have corresponding fields in the target object. 	 * Default is &quot;true&quot;. Turn this off to enforce that all bind parameters 	 * must have a matching field in the target object. 	 * Note that this setting only applies to binding operations 	 * on this DataBinder, not to retrieving values via its 	 * {@link #getBindingResult() BindingResult}. 	 * @see #bind 	 */ 	public void setIgnoreUnknownFields(boolean ignoreUnknownFields) { 		this.ignoreUnknownFields = ignoreUnknownFields; 	}  	/** 	 * Return whether to ignore unknown fields when binding. 	 */ 	public boolean isIgnoreUnknownFields() { 		return this.ignoreUnknownFields; 	}  	/** 	 * Set whether to ignore invalid fields, that is, whether to ignore bind 	 * parameters that have corresponding fields in the target object which are 	 * not accessible (for example because of null values in the nested path). 	 * Default is &quot;false&quot;. Turn this on to ignore bind parameters for 	 * nested objects in non-existing parts of the target object graph. 	 * Note that this setting only applies to binding operations 	 * on this DataBinder, not to retrieving values via its 	 * {@link #getBindingResult() BindingResult}. 	 * @see #bind 	 */ 	public void setIgnoreInvalidFields(boolean ignoreInvalidFields) { 		this.ignoreInvalidFields = ignoreInvalidFields; 	}  	/** 	 * Return whether to ignore invalid fields when binding. 	 */ 	public boolean isIgnoreInvalidFields() { 		return this.ignoreInvalidFields; 	}  	/** 	 * Register fields that should be allowed for binding. Default is all 	 * fields. Restrict this for example to avoid unwanted modifications 	 * by malicious users when binding HTTP request parameters. 	 * Supports &quot;xxx*&quot;, &quot;*xxx&quot; and &quot;*xxx*&quot; patterns. More sophisticated matching 	 * can be implemented by overriding the {@code isAllowed} method. 	 * Alternatively, specify a list of disallowed fields. 	 * @param allowedFields array of field names 	 * @see #setDisallowedFields 	 * @see #isAllowed(String) 	 */ 	public void setAllowedFields(@Nullable String... allowedFields) { 		this.allowedFields = PropertyAccessorUtils.canonicalPropertyNames(allowedFields); 	}  	/** 	 * Return the fields that should be allowed for binding. 	 * @return array of field names 	 */ 	@Nullable 	public String[] getAllowedFields() { 		return this.allowedFields; 	}  	/** 	 * Register fields that should not be allowed for binding. Default is none. 	 * Mark fields as disallowed for example to avoid unwanted modifications 	 * by malicious users when binding HTTP request parameters. 	 * Supports &quot;xxx*&quot;, &quot;*xxx&quot; and &quot;*xxx*&quot; patterns. More sophisticated matching 	 * can be implemented by overriding the {@code isAllowed} method. 	 * Alternatively, specify a list of allowed fields. 	 * @param disallowedFields array of field names 	 * @see #setAllowedFields 	 * @see #isAllowed(String) 	 */ 	public void setDisallowedFields(@Nullable String... disallowedFields) { 		this.disallowedFields = PropertyAccessorUtils.canonicalPropertyNames(disallowedFields); 	}  	/** 	 * Return the fields that should not be allowed for binding. 	 * @return array of field names 	 */ 	@Nullable 	public String[] getDisallowedFields() { 		return this.disallowedFields; 	}  	/** 	 * Register fields that are required for each binding process. 	 * If one of the specified fields is not contained in the list of 	 * incoming property values, a corresponding &quot;missing field&quot; error 	 * will be created, with error code &quot;required&quot; (by the default 	 * binding error processor). 	 * @param requiredFields array of field names 	 * @see #setBindingErrorProcessor 	 * @see DefaultBindingErrorProcessor#MISSING_FIELD_ERROR_CODE 	 */ 	public void setRequiredFields(@Nullable String... requiredFields) { 		this.requiredFields = PropertyAccessorUtils.canonicalPropertyNames(requiredFields); 		if (logger.isDebugEnabled()) { 			logger.debug(&quot;DataBinder requires binding of required fields [&quot; + 					StringUtils.arrayToCommaDelimitedString(requiredFields) + &quot;]&quot;); 		} 	}  	/** 	 * Return the fields that are required for each binding process. 	 * @return array of field names 	 */ 	@Nullable 	public String[] getRequiredFields() { 		return this.requiredFields; 	}  	/** 	 * Set the strategy to use for resolving errors into message codes. 	 * Applies the given strategy to the underlying errors holder. 	 * Default is a DefaultMessageCodesResolver. 	 * @see BeanPropertyBindingResult#setMessageCodesResolver 	 * @see DefaultMessageCodesResolver 	 */ 	public void setMessageCodesResolver(@Nullable MessageCodesResolver messageCodesResolver) { 		Assert.state(this.messageCodesResolver == null, &quot;DataBinder is already initialized with MessageCodesResolver&quot;); 		this.messageCodesResolver = messageCodesResolver; 		if (this.bindingResult != null &amp;&amp; messageCodesResolver != null) { 			this.bindingResult.setMessageCodesResolver(messageCodesResolver); 		} 	}  	/** 	 * Set the strategy to use for processing binding errors, that is, 	 * required field errors and {@code PropertyAccessException}s. 	 * Default is a DefaultBindingErrorProcessor. 	 * @see DefaultBindingErrorProcessor 	 */ 	public void setBindingErrorProcessor(BindingErrorProcessor bindingErrorProcessor) { 		Assert.notNull(bindingErrorProcessor, &quot;BindingErrorProcessor must not be null&quot;); 		this.bindingErrorProcessor = bindingErrorProcessor; 	}  	/** 	 * Return the strategy for processing binding errors. 	 */ 	public BindingErrorProcessor getBindingErrorProcessor() { 		return this.bindingErrorProcessor; 	}  	/** 	 * Set the Validator to apply after each binding step. 	 * @see #addValidators(Validator...) 	 * @see #replaceValidators(Validator...) 	 */ 	public void setValidator(@Nullable Validator validator) { 		assertValidators(validator); 		this.validators.clear(); 		if (validator != null) { 			this.validators.add(validator); 		} 	}  	private void assertValidators(Validator... validators) { 		Object target = getTarget(); 		for (Validator validator : validators) { 			if (validator != null &amp;&amp; (target != null &amp;&amp; !validator.supports(target.getClass()))) { 				throw new IllegalStateException(&quot;Invalid target for Validator [&quot; + validator + &quot;]: &quot; + target); 			} 		} 	}  	/** 	 * Add Validators to apply after each binding step. 	 * @see #setValidator(Validator) 	 * @see #replaceValidators(Validator...) 	 */ 	public void addValidators(Validator... validators) { 		assertValidators(validators); 		this.validators.addAll(Arrays.asList(validators)); 	}  	/** 	 * Replace the Validators to apply after each binding step. 	 * @see #setValidator(Validator) 	 * @see #addValidators(Validator...) 	 */ 	public void replaceValidators(Validator... validators) { 		assertValidators(validators); 		this.validators.clear(); 		this.validators.addAll(Arrays.asList(validators)); 	}  	/** 	 * Return the primary Validator to apply after each binding step, if any. 	 */ 	@Nullable 	public Validator getValidator() { 		return (!this.validators.isEmpty() ? this.validators.get(0) : null); 	}  	/** 	 * Return the Validators to apply after data binding. 	 */ 	public List getValidators() { 		return Collections.unmodifiableList(this.validators); 	}   	//--------------------------------------------------------------------- 	// Implementation of PropertyEditorRegistry/TypeConverter interface 	//---------------------------------------------------------------------  	/** 	 * Specify a Spring 3.0 ConversionService to use for converting 	 * property values, as an alternative to JavaBeans PropertyEditors. 	 */ 	public void setConversionService(@Nullable ConversionService conversionService) { 		Assert.state(this.conversionService == null, &quot;DataBinder is already initialized with ConversionService&quot;); 		this.conversionService = conversionService; 		if (this.bindingResult != null &amp;&amp; conversionService != null) { 			this.bindingResult.initConversion(conversionService); 		} 	}  	/** 	 * Return the associated ConversionService, if any. 	 */ 	@Nullable 	public ConversionService getConversionService() { 		return this.conversionService; 	}  	/** 	 * Add a custom formatter, applying it to all fields matching the 	 * {@link Formatter}-declared type. 	 * Registers a corresponding {@link PropertyEditor} adapter underneath the covers. 	 * @param formatter the formatter to add, generically declared for a specific type 	 * @since 4.2 	 * @see #registerCustomEditor(Class, PropertyEditor) 	 */ 	public void addCustomFormatter(Formatter formatter) { 		FormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter); 		getPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter); 	}  	/** 	 * Add a custom formatter for the field type specified in {@link Formatter} class, 	 * applying it to the specified fields only, if any, or otherwise to all fields. 	 * Registers a corresponding {@link PropertyEditor} adapter underneath the covers. 	 * @param formatter the formatter to add, generically declared for a specific type 	 * @param fields the fields to apply the formatter to, or none if to be applied to all 	 * @since 4.2 	 * @see #registerCustomEditor(Class, String, PropertyEditor) 	 */ 	public void addCustomFormatter(Formatter formatter, String... fields) { 		FormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter); 		Class fieldType = adapter.getFieldType(); 		if (ObjectUtils.isEmpty(fields)) { 			getPropertyEditorRegistry().registerCustomEditor(fieldType, adapter); 		} 		else { 			for (String field : fields) { 				getPropertyEditorRegistry().registerCustomEditor(fieldType, field, adapter); 			} 		} 	}  	/** 	 * Add a custom formatter, applying it to the specified field types only, if any, 	 * or otherwise to all fields matching the {@link Formatter}-declared type. 	 * Registers a corresponding {@link PropertyEditor} adapter underneath the covers. 	 * @param formatter the formatter to add (does not need to generically declare a 	 * field type if field types are explicitly specified as parameters) 	 * @param fieldTypes the field types to apply the formatter to, or none if to be 	 * derived from the given {@link Formatter} implementation class 	 * @since 4.2 	 * @see #registerCustomEditor(Class, PropertyEditor) 	 */ 	public void addCustomFormatter(Formatter formatter, Class... fieldTypes) { 		FormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter); 		if (ObjectUtils.isEmpty(fieldTypes)) { 			getPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter); 		} 		else { 			for (Class fieldType : fieldTypes) { 				getPropertyEditorRegistry().registerCustomEditor(fieldType, adapter); 			} 		} 	}  	@Override 	public void registerCustomEditor(Class requiredType, PropertyEditor propertyEditor) { 		getPropertyEditorRegistry().registerCustomEditor(requiredType, propertyEditor); 	}  	@Override 	public void registerCustomEditor(@Nullable Class requiredType, @Nullable String field, PropertyEditor propertyEditor) { 		getPropertyEditorRegistry().registerCustomEditor(requiredType, field, propertyEditor); 	}  	@Override 	@Nullable 	public PropertyEditor findCustomEditor(@Nullable Class requiredType, @Nullable String propertyPath) { 		return getPropertyEditorRegistry().findCustomEditor(requiredType, propertyPath); 	}  	@Override 	@Nullable 	public  T convertIfNecessary(@Nullable Object value, @Nullable Class requiredType) throws TypeMismatchException { 		return getTypeConverter().convertIfNecessary(value, requiredType); 	}  	@Override 	@Nullable 	public  T convertIfNecessary(@Nullable Object value, @Nullable Class requiredType, 			@Nullable MethodParameter methodParam) throws TypeMismatchException {  		return getTypeConverter().convertIfNecessary(value, requiredType, methodParam); 	}  	@Override 	@Nullable 	public  T convertIfNecessary(@Nullable Object value, @Nullable Class requiredType, @Nullable Field field) 			throws TypeMismatchException {  		return getTypeConverter().convertIfNecessary(value, requiredType, field); 	}  	@Nullable 	@Override 	public  T convertIfNecessary(@Nullable Object value, @Nullable Class requiredType, 			@Nullable TypeDescriptor typeDescriptor) throws TypeMismatchException {  		return getTypeConverter().convertIfNecessary(value, requiredType, typeDescriptor); 	}   	/** 	 * Bind the given property values to this binder's target. 	 * This call can create field errors, representing basic binding 	 * errors like a required field (code &quot;required&quot;), or type mismatch 	 * between value and bean property (code &quot;typeMismatch&quot;). 	 * Note that the given PropertyValues should be a throwaway instance: 	 * For efficiency, it will be modified to just contain allowed fields if it 	 * implements the MutablePropertyValues interface; else, an internal mutable 	 * copy will be created for this purpose. Pass in a copy of the PropertyValues 	 * if you want your original instance to stay unmodified in any case. 	 * @param pvs property values to bind 	 * @see #doBind(org.springframework.beans.MutablePropertyValues) 	 */ 	public void bind(PropertyValues pvs) { 		MutablePropertyValues mpvs = (pvs instanceof MutablePropertyValues ? 				(MutablePropertyValues) pvs : new MutablePropertyValues(pvs)); 		doBind(mpvs); 	}  	/** 	 * Actual implementation of the binding process, working with the 	 * passed-in MutablePropertyValues instance. 	 * @param mpvs the property values to bind, 	 * as MutablePropertyValues instance 	 * @see #checkAllowedFields 	 * @see #checkRequiredFields 	 * @see #applyPropertyValues 	 */ 	protected void doBind(MutablePropertyValues mpvs) { 		checkAllowedFields(mpvs); 		checkRequiredFields(mpvs); 		applyPropertyValues(mpvs); 	}  	/** 	 * Check the given property values against the allowed fields, 	 * removing values for fields that are not allowed. 	 * @param mpvs the property values to be bound (can be modified) 	 * @see #getAllowedFields 	 * @see #isAllowed(String) 	 */ 	protected void checkAllowedFields(MutablePropertyValues mpvs) { 		PropertyValue[] pvs = mpvs.getPropertyValues(); 		for (PropertyValue pv : pvs) { 			String field = PropertyAccessorUtils.canonicalPropertyName(pv.getName()); 			if (!isAllowed(field)) { 				mpvs.removePropertyValue(pv); 				getBindingResult().recordSuppressedField(field); 				if (logger.isDebugEnabled()) { 					logger.debug(&quot;Field [&quot; + field + &quot;] has been removed from PropertyValues &quot; + 							&quot;and will not be bound, because it has not been found in the list of allowed fields&quot;); 				} 			} 		} 	}  	/** 	 * Return if the given field is allowed for binding. 	 * Invoked for each passed-in property value. 	 * The default implementation checks for &quot;xxx*&quot;, &quot;*xxx&quot; and &quot;*xxx*&quot; matches, 	 * as well as direct equality, in the specified lists of allowed fields and 	 * disallowed fields. A field matching a disallowed pattern will not be accepted 	 * even if it also happens to match a pattern in the allowed list. 	 * Can be overridden in subclasses. 	 * @param field the field to check 	 * @return if the field is allowed 	 * @see #setAllowedFields 	 * @see #setDisallowedFields 	 * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String) 	 */ 	protected boolean isAllowed(String field) { 		String[] allowed = getAllowedFields(); 		String[] disallowed = getDisallowedFields(); 		return ((ObjectUtils.isEmpty(allowed) || PatternMatchUtils.simpleMatch(allowed, field)) &amp;&amp; 				(ObjectUtils.isEmpty(disallowed) || !PatternMatchUtils.simpleMatch(disallowed, field))); 	}  	/** 	 * Check the given property values against the required fields, 	 * generating missing field errors where appropriate. 	 * @param mpvs the property values to be bound (can be modified) 	 * @see #getRequiredFields 	 * @see #getBindingErrorProcessor 	 * @see BindingErrorProcessor#processMissingFieldError 	 */ 	protected void checkRequiredFields(MutablePropertyValues mpvs) { 		String[] requiredFields = getRequiredFields(); 		if (!ObjectUtils.isEmpty(requiredFields)) { 			Map propertyValues = new HashMap&lt;&gt;(); 			PropertyValue[] pvs = mpvs.getPropertyValues(); 			for (PropertyValue pv : pvs) { 				String canonicalName = PropertyAccessorUtils.canonicalPropertyName(pv.getName()); 				propertyValues.put(canonicalName, pv); 			} 			for (String field : requiredFields) { 				PropertyValue pv = propertyValues.get(field); 				boolean empty = (pv == null || pv.getValue() == null); 				if (!empty) { 					if (pv.getValue() instanceof String) { 						empty = !StringUtils.hasText((String) pv.getValue()); 					} 					else if (pv.getValue() instanceof String[]) { 						String[] values = (String[]) pv.getValue(); 						empty = (values.length == 0 || !StringUtils.hasText(values[0])); 					} 				} 				if (empty) { 					// Use bind error processor to create FieldError. 					getBindingErrorProcessor().processMissingFieldError(field, getInternalBindingResult()); 					// Remove property from property values to bind: 					// It has already caused a field error with a rejected value. 					if (pv != null) { 						mpvs.removePropertyValue(pv); 						propertyValues.remove(field); 					} 				} 			} 		} 	}  	/** 	 * Apply given property values to the target object. 	 * Default implementation applies all of the supplied property 	 * values as bean property values. By default, unknown fields will 	 * be ignored. 	 * @param mpvs the property values to be bound (can be modified) 	 * @see #getTarget 	 * @see #getPropertyAccessor 	 * @see #isIgnoreUnknownFields 	 * @see #getBindingErrorProcessor 	 * @see BindingErrorProcessor#processPropertyAccessException 	 */ 	protected void applyPropertyValues(MutablePropertyValues mpvs) { 		try { 			// Bind request parameters onto target object. 			getPropertyAccessor().setPropertyValues(mpvs, isIgnoreUnknownFields(), isIgnoreInvalidFields()); 		} 		catch (PropertyBatchUpdateException ex) { 			// Use bind error processor to create FieldErrors. 			for (PropertyAccessException pae : ex.getPropertyAccessExceptions()) { 				getBindingErrorProcessor().processPropertyAccessException(pae, getInternalBindingResult()); 			} 		} 	}   	/** 	 * Invoke the specified Validators, if any. 	 * @see #setValidator(Validator) 	 * @see #getBindingResult() 	 */ 	public void validate() { 		Object target = getTarget(); 		Assert.state(target != null, &quot;No target to validate&quot;); 		BindingResult bindingResult = getBindingResult(); 		// Call each validator with the same binding result 		for (Validator validator : getValidators()) { 			validator.validate(target, bindingResult); 		} 	}  	/** 	 * Invoke the specified Validators, if any, with the given validation hints. 	 * Note: Validation hints may get ignored by the actual target Validator. 	 * @param validationHints one or more hint objects to be passed to a {@link SmartValidator} 	 * @since 3.1 	 * @see #setValidator(Validator) 	 * @see SmartValidator#validate(Object, Errors, Object...) 	 */ 	public void validate(Object... validationHints) { 		Object target = getTarget(); 		Assert.state(target != null, &quot;No target to validate&quot;); 		BindingResult bindingResult = getBindingResult(); 		// Call each validator with the same binding result 		for (Validator validator : getValidators()) { 			if (!ObjectUtils.isEmpty(validationHints) &amp;&amp; validator instanceof SmartValidator) { 				((SmartValidator) validator).validate(target, bindingResult, validationHints); 			} 			else if (validator != null) { 				validator.validate(target, bindingResult); 			} 		} 	}  	/** 	 * Close this DataBinder, which may result in throwing 	 * a BindException if it encountered any errors. 	 * @return the model Map, containing target object and Errors instance 	 * @throws BindException if there were any errors in the bind operation 	 * @see BindingResult#getModel() 	 */ 	public Map close() throws BindException { 		if (getBindingResult().hasErrors()) { 			throw new BindException(getBindingResult()); 		} 		return getBindingResult().getModel(); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">11335</td>
    <td align="left">https://github.com/spring-projects/spring-framework/blob/3a0f309e2c9fdbbf7fb2d348be861528177f8555/spring-context/src/main/java/org/springframework/validation/DataBinder.java/#L110-L911</td>
    <td align="right">1</td>
    <td align="right">1570</td>
    <td align="right">11335</td>
  </tr>
  <tr valign="top">
    <td align="right">1594</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Blob&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ConsoleProxyClientParam {     private String clientHostAddress;     private int clientHostPort;     private String clientHostPassword;     private String clientTag;     private String ticket;     private String locale;     private String clientTunnelUrl;     private String clientTunnelSession;      private String hypervHost;      private String ajaxSessionId;     private String username;     private String password;      public ConsoleProxyClientParam() {         clientHostPort = 0;     }      public String getClientHostAddress() {         return clientHostAddress;     }      public void setClientHostAddress(String clientHostAddress) {         this.clientHostAddress = clientHostAddress;     }      public int getClientHostPort() {         return clientHostPort;     }      public void setClientHostPort(int clientHostPort) {         this.clientHostPort = clientHostPort;     }      public String getClientHostPassword() {         return clientHostPassword;     }      public void setClientHostPassword(String clientHostPassword) {         this.clientHostPassword = clientHostPassword;     }      public String getClientTag() {         return clientTag;     }      public void setClientTag(String clientTag) {         this.clientTag = clientTag;     }      public String getTicket() {         return ticket;     }      public void setTicket(String ticket) {         this.ticket = ticket;     }      public String getClientTunnelUrl() {         return clientTunnelUrl;     }      public void setClientTunnelUrl(String clientTunnelUrl) {         this.clientTunnelUrl = clientTunnelUrl;     }      public String getClientTunnelSession() {         return clientTunnelSession;     }      public void setClientTunnelSession(String clientTunnelSession) {         this.clientTunnelSession = clientTunnelSession;     }      public String getAjaxSessionId() {         return ajaxSessionId;     }      public void setAjaxSessionId(String ajaxSessionId) {         this.ajaxSessionId = ajaxSessionId;     }      public String getLocale() {         return locale;     }      public void setLocale(String locale) {         this.locale = locale;     }      public String getClientMapKey() {         if (clientTag != null &amp;&amp; !clientTag.isEmpty())             return clientTag;          return clientHostAddress + &quot;:&quot; + clientHostPort;     }      public void setHypervHost(String host) {         hypervHost = host;     }      public String getHypervHost() {         return hypervHost;     }      public void setUsername(String username) {         this.username = username;      }      public String getUsername() {         return username;     }      public void setPassword(String password) {         this.password = password;     }      public String getPassword() {         return password;     } }</td>
    <td align="left">data class</td>
    <td align="left">Blob, Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">Blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11407</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/server/src/main/java/com/cloud/servlet/ConsoleProxyClientParam.java/#L20-L143</td>
    <td align="right">1</td>
    <td align="right">1594</td>
    <td align="right">11407</td>
  </tr>
  <tr valign="top">
    <td align="right">1617</td>
    <td align="left">{&quot;answer&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static final class Builder extends         com.google.protobuf.GeneratedMessage.Builder implements         // @@protoc_insertion_point(builder_implements:com.alibaba.otter.canal.protocol.RowChange)         RowChangeOrBuilder {       public static final com.google.protobuf.Descriptors.Descriptor           getDescriptor() {         return CanalEntry.internal_static_com_alibaba_otter_canal_protocol_RowChange_descriptor;       }        protected FieldAccessorTable           internalGetFieldAccessorTable() {         return CanalEntry.internal_static_com_alibaba_otter_canal_protocol_RowChange_fieldAccessorTable             .ensureFieldAccessorsInitialized(                 RowChange.class, Builder.class);       }        // Construct using com.alibaba.otter.canal.protocol.CanalEntry.RowChange.newBuilder()       private Builder() {         maybeForceBuilderInitialization();       }        private Builder(           BuilderParent parent) {         super(parent);         maybeForceBuilderInitialization();       }       private void maybeForceBuilderInitialization() {         if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {           getRowDatasFieldBuilder();           getPropsFieldBuilder();         }       }       private static Builder create() {         return new Builder();       }        public Builder clear() {         super.clear();         tableId_ = 0L;         bitField0_ = (bitField0_ &amp; ~0x00000001);         eventType_ = EventType.UPDATE;         bitField0_ = (bitField0_ &amp; ~0x00000002);         isDdl_ = false;         bitField0_ = (bitField0_ &amp; ~0x00000004);         sql_ = &quot;&quot;;         bitField0_ = (bitField0_ &amp; ~0x00000008);         if (rowDatasBuilder_ == null) {           rowDatas_ = java.util.Collections.emptyList();           bitField0_ = (bitField0_ &amp; ~0x00000010);         } else {           rowDatasBuilder_.clear();         }         if (propsBuilder_ == null) {           props_ = java.util.Collections.emptyList();           bitField0_ = (bitField0_ &amp; ~0x00000020);         } else {           propsBuilder_.clear();         }         ddlSchemaName_ = &quot;&quot;;         bitField0_ = (bitField0_ &amp; ~0x00000040);         return this;       }        public Builder clone() {         return create().mergeFrom(buildPartial());       }        public com.google.protobuf.Descriptors.Descriptor           getDescriptorForType() {         return CanalEntry.internal_static_com_alibaba_otter_canal_protocol_RowChange_descriptor;       }        public RowChange getDefaultInstanceForType() {         return RowChange.getDefaultInstance();       }        public RowChange build() {         RowChange result = buildPartial();         if (!result.isInitialized()) {           throw newUninitializedMessageException(result);         }         return result;       }        public RowChange buildPartial() {         RowChange result = new RowChange(this);         int from_bitField0_ = bitField0_;         int to_bitField0_ = 0;         if (((from_bitField0_ &amp; 0x00000001) == 0x00000001)) {           to_bitField0_ |= 0x00000001;         }         result.tableId_ = tableId_;         if (((from_bitField0_ &amp; 0x00000002) == 0x00000002)) {           to_bitField0_ |= 0x00000002;         }         result.eventType_ = eventType_;         if (((from_bitField0_ &amp; 0x00000004) == 0x00000004)) {           to_bitField0_ |= 0x00000004;         }         result.isDdl_ = isDdl_;         if (((from_bitField0_ &amp; 0x00000008) == 0x00000008)) {           to_bitField0_ |= 0x00000008;         }         result.sql_ = sql_;         if (rowDatasBuilder_ == null) {           if (((bitField0_ &amp; 0x00000010) == 0x00000010)) {             rowDatas_ = java.util.Collections.unmodifiableList(rowDatas_);             bitField0_ = (bitField0_ &amp; ~0x00000010);           }           result.rowDatas_ = rowDatas_;         } else {           result.rowDatas_ = rowDatasBuilder_.build();         }         if (propsBuilder_ == null) {           if (((bitField0_ &amp; 0x00000020) == 0x00000020)) {             props_ = java.util.Collections.unmodifiableList(props_);             bitField0_ = (bitField0_ &amp; ~0x00000020);           }           result.props_ = props_;         } else {           result.props_ = propsBuilder_.build();         }         if (((from_bitField0_ &amp; 0x00000040) == 0x00000040)) {           to_bitField0_ |= 0x00000010;         }         result.ddlSchemaName_ = ddlSchemaName_;         result.bitField0_ = to_bitField0_;         onBuilt();         return result;       }        public Builder mergeFrom(com.google.protobuf.Message other) {         if (other instanceof RowChange) {           return mergeFrom((RowChange)other);         } else {           super.mergeFrom(other);           return this;         }       }        public Builder mergeFrom(RowChange other) {         if (other == RowChange.getDefaultInstance()) return this;         if (other.hasTableId()) {           setTableId(other.getTableId());         }         if (other.hasEventType()) {           setEventType(other.getEventType());         }         if (other.hasIsDdl()) {           setIsDdl(other.getIsDdl());         }         if (other.hasSql()) {           bitField0_ |= 0x00000008;           sql_ = other.sql_;           onChanged();         }         if (rowDatasBuilder_ == null) {           if (!other.rowDatas_.isEmpty()) {             if (rowDatas_.isEmpty()) {               rowDatas_ = other.rowDatas_;               bitField0_ = (bitField0_ &amp; ~0x00000010);             } else {               ensureRowDatasIsMutable();               rowDatas_.addAll(other.rowDatas_);             }             onChanged();           }         } else {           if (!other.rowDatas_.isEmpty()) {             if (rowDatasBuilder_.isEmpty()) {               rowDatasBuilder_.dispose();               rowDatasBuilder_ = null;               rowDatas_ = other.rowDatas_;               bitField0_ = (bitField0_ &amp; ~0x00000010);               rowDatasBuilder_ =                 com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?                    getRowDatasFieldBuilder() : null;             } else {               rowDatasBuilder_.addAllMessages(other.rowDatas_);             }           }         }         if (propsBuilder_ == null) {           if (!other.props_.isEmpty()) {             if (props_.isEmpty()) {               props_ = other.props_;               bitField0_ = (bitField0_ &amp; ~0x00000020);             } else {               ensurePropsIsMutable();               props_.addAll(other.props_);             }             onChanged();           }         } else {           if (!other.props_.isEmpty()) {             if (propsBuilder_.isEmpty()) {               propsBuilder_.dispose();               propsBuilder_ = null;               props_ = other.props_;               bitField0_ = (bitField0_ &amp; ~0x00000020);               propsBuilder_ =                 com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?                    getPropsFieldBuilder() : null;             } else {               propsBuilder_.addAllMessages(other.props_);             }           }         }         if (other.hasDdlSchemaName()) {           bitField0_ |= 0x00000040;           ddlSchemaName_ = other.ddlSchemaName_;           onChanged();         }         this.mergeUnknownFields(other.getUnknownFields());         return this;       }        public final boolean isInitialized() {         return true;       }        public Builder mergeFrom(           com.google.protobuf.CodedInputStream input,           com.google.protobuf.ExtensionRegistryLite extensionRegistry)           throws java.io.IOException {         RowChange parsedMessage = null;         try {           parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);         } catch (com.google.protobuf.InvalidProtocolBufferException e) {           parsedMessage = (RowChange) e.getUnfinishedMessage();           throw e;         } finally {           if (parsedMessage != null) {             mergeFrom(parsedMessage);           }         }         return this;       }       private int bitField0_;        private long tableId_ ;       /**        * optional int64 tableId = 1;        *        *         **tableId,由数据库产生*        *         */       public boolean hasTableId() {         return ((bitField0_ &amp; 0x00000001) == 0x00000001);       }       /**        * optional int64 tableId = 1;        *        *         **tableId,由数据库产生*        *         */       public long getTableId() {         return tableId_;       }       /**        * optional int64 tableId = 1;        *        *         **tableId,由数据库产生*        *         */       public Builder setTableId(long value) {         bitField0_ |= 0x00000001;         tableId_ = value;         onChanged();         return this;       }       /**        * optional int64 tableId = 1;        *        *         **tableId,由数据库产生*        *         */       public Builder clearTableId() {         bitField0_ = (bitField0_ &amp; ~0x00000001);         tableId_ = 0L;         onChanged();         return this;       }        private EventType eventType_ = EventType.UPDATE;       /**        * optional .com.alibaba.otter.canal.protocol.EventType eventType = 2 [default = UPDATE];        *        *         **数据变更类型*        *         */       public boolean hasEventType() {         return ((bitField0_ &amp; 0x00000002) == 0x00000002);       }       /**        * optional .com.alibaba.otter.canal.protocol.EventType eventType = 2 [default = UPDATE];        *        *         **数据变更类型*        *         */       public EventType getEventType() {         return eventType_;       }       /**        * optional .com.alibaba.otter.canal.protocol.EventType eventType = 2 [default = UPDATE];        *        *         **数据变更类型*        *         */       public Builder setEventType(EventType value) {         if (value == null) {           throw new NullPointerException();         }         bitField0_ |= 0x00000002;         eventType_ = value;         onChanged();         return this;       }       /**        * optional .com.alibaba.otter.canal.protocol.EventType eventType = 2 [default = UPDATE];        *        *         **数据变更类型*        *         */       public Builder clearEventType() {         bitField0_ = (bitField0_ &amp; ~0x00000002);         eventType_ = EventType.UPDATE;         onChanged();         return this;       }        private boolean isDdl_ ;       /**        * optional bool isDdl = 10 [default = false];        *        *         ** 标识是否是ddl语句  *        *         */       public boolean hasIsDdl() {         return ((bitField0_ &amp; 0x00000004) == 0x00000004);       }       /**        * optional bool isDdl = 10 [default = false];        *        *         ** 标识是否是ddl语句  *        *         */       public boolean getIsDdl() {         return isDdl_;       }       /**        * optional bool isDdl = 10 [default = false];        *        *         ** 标识是否是ddl语句  *        *         */       public Builder setIsDdl(boolean value) {         bitField0_ |= 0x00000004;         isDdl_ = value;         onChanged();         return this;       }       /**        * optional bool isDdl = 10 [default = false];        *        *         ** 标识是否是ddl语句  *        *         */       public Builder clearIsDdl() {         bitField0_ = (bitField0_ &amp; ~0x00000004);         isDdl_ = false;         onChanged();         return this;       }        private Object sql_ = &quot;&quot;;       /**        * optional string sql = 11;        *        *         ** ddl/query的sql语句  *        *         */       public boolean hasSql() {         return ((bitField0_ &amp; 0x00000008) == 0x00000008);       }       /**        * optional string sql = 11;        *        *         ** ddl/query的sql语句  *        *         */       public String getSql() {         Object ref = sql_;         if (!(ref instanceof String)) {           com.google.protobuf.ByteString bs =               (com.google.protobuf.ByteString) ref;           String s = bs.toStringUtf8();           if (bs.isValidUtf8()) {             sql_ = s;           }           return s;         } else {           return (String) ref;         }       }       /**        * optional string sql = 11;        *        *         ** ddl/query的sql语句  *        *         */       public com.google.protobuf.ByteString           getSqlBytes() {         Object ref = sql_;         if (ref instanceof String) {           com.google.protobuf.ByteString b =               com.google.protobuf.ByteString.copyFromUtf8(                   (String) ref);           sql_ = b;           return b;         } else {           return (com.google.protobuf.ByteString) ref;         }       }       /**        * optional string sql = 11;        *        *         ** ddl/query的sql语句  *        *         */       public Builder setSql(           String value) {         if (value == null) {     throw new NullPointerException();   }   bitField0_ |= 0x00000008;         sql_ = value;         onChanged();         return this;       }       /**        * optional string sql = 11;        *        *         ** ddl/query的sql语句  *        *         */       public Builder clearSql() {         bitField0_ = (bitField0_ &amp; ~0x00000008);         sql_ = getDefaultInstance().getSql();         onChanged();         return this;       }       /**        * optional string sql = 11;        *        *         ** ddl/query的sql语句  *        *         */       public Builder setSqlBytes(           com.google.protobuf.ByteString value) {         if (value == null) {     throw new NullPointerException();   }   bitField0_ |= 0x00000008;         sql_ = value;         onChanged();         return this;       }        private java.util.List rowDatas_ =         java.util.Collections.emptyList();       private void ensureRowDatasIsMutable() {         if (!((bitField0_ &amp; 0x00000010) == 0x00000010)) {           rowDatas_ = new java.util.ArrayList(rowDatas_);           bitField0_ |= 0x00000010;          }       }        private com.google.protobuf.RepeatedFieldBuilder&lt;           RowData, RowData.Builder, RowDataOrBuilder&gt; rowDatasBuilder_;        /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public java.util.List getRowDatasList() {         if (rowDatasBuilder_ == null) {           return java.util.Collections.unmodifiableList(rowDatas_);         } else {           return rowDatasBuilder_.getMessageList();         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public int getRowDatasCount() {         if (rowDatasBuilder_ == null) {           return rowDatas_.size();         } else {           return rowDatasBuilder_.getCount();         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public RowData getRowDatas(int index) {         if (rowDatasBuilder_ == null) {           return rowDatas_.get(index);         } else {           return rowDatasBuilder_.getMessage(index);         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder setRowDatas(           int index, RowData value) {         if (rowDatasBuilder_ == null) {           if (value == null) {             throw new NullPointerException();           }           ensureRowDatasIsMutable();           rowDatas_.set(index, value);           onChanged();         } else {           rowDatasBuilder_.setMessage(index, value);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder setRowDatas(           int index, RowData.Builder builderForValue) {         if (rowDatasBuilder_ == null) {           ensureRowDatasIsMutable();           rowDatas_.set(index, builderForValue.build());           onChanged();         } else {           rowDatasBuilder_.setMessage(index, builderForValue.build());         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder addRowDatas(RowData value) {         if (rowDatasBuilder_ == null) {           if (value == null) {             throw new NullPointerException();           }           ensureRowDatasIsMutable();           rowDatas_.add(value);           onChanged();         } else {           rowDatasBuilder_.addMessage(value);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder addRowDatas(           int index, RowData value) {         if (rowDatasBuilder_ == null) {           if (value == null) {             throw new NullPointerException();           }           ensureRowDatasIsMutable();           rowDatas_.add(index, value);           onChanged();         } else {           rowDatasBuilder_.addMessage(index, value);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder addRowDatas(           RowData.Builder builderForValue) {         if (rowDatasBuilder_ == null) {           ensureRowDatasIsMutable();           rowDatas_.add(builderForValue.build());           onChanged();         } else {           rowDatasBuilder_.addMessage(builderForValue.build());         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder addRowDatas(           int index, RowData.Builder builderForValue) {         if (rowDatasBuilder_ == null) {           ensureRowDatasIsMutable();           rowDatas_.add(index, builderForValue.build());           onChanged();         } else {           rowDatasBuilder_.addMessage(index, builderForValue.build());         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder addAllRowDatas(           Iterable values) {         if (rowDatasBuilder_ == null) {           ensureRowDatasIsMutable();           com.google.protobuf.AbstractMessageLite.Builder.addAll(               values, rowDatas_);           onChanged();         } else {           rowDatasBuilder_.addAllMessages(values);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder clearRowDatas() {         if (rowDatasBuilder_ == null) {           rowDatas_ = java.util.Collections.emptyList();           bitField0_ = (bitField0_ &amp; ~0x00000010);           onChanged();         } else {           rowDatasBuilder_.clear();         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public Builder removeRowDatas(int index) {         if (rowDatasBuilder_ == null) {           ensureRowDatasIsMutable();           rowDatas_.remove(index);           onChanged();         } else {           rowDatasBuilder_.remove(index);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public RowData.Builder getRowDatasBuilder(           int index) {         return getRowDatasFieldBuilder().getBuilder(index);       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public RowDataOrBuilder getRowDatasOrBuilder(           int index) {         if (rowDatasBuilder_ == null) {           return rowDatas_.get(index);  } else {           return rowDatasBuilder_.getMessageOrBuilder(index);         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public java.util.List            getRowDatasOrBuilderList() {         if (rowDatasBuilder_ != null) {           return rowDatasBuilder_.getMessageOrBuilderList();         } else {           return java.util.Collections.unmodifiableList(rowDatas_);         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public RowData.Builder addRowDatasBuilder() {         return getRowDatasFieldBuilder().addBuilder(             RowData.getDefaultInstance());       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public RowData.Builder addRowDatasBuilder(           int index) {         return getRowDatasFieldBuilder().addBuilder(             index, RowData.getDefaultInstance());       }       /**        * repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;        *        *         ** 一次数据库变更可能存在多行  *        *         */       public java.util.List            getRowDatasBuilderList() {         return getRowDatasFieldBuilder().getBuilderList();       }       private com.google.protobuf.RepeatedFieldBuilder&lt;           RowData, RowData.Builder, RowDataOrBuilder&gt;           getRowDatasFieldBuilder() {         if (rowDatasBuilder_ == null) {           rowDatasBuilder_ = new com.google.protobuf.RepeatedFieldBuilder&lt;               RowData, RowData.Builder, RowDataOrBuilder&gt;(                   rowDatas_,                   ((bitField0_ &amp; 0x00000010) == 0x00000010),                   getParentForChildren(),                   isClean());           rowDatas_ = null;         }         return rowDatasBuilder_;       }        private java.util.List props_ =         java.util.Collections.emptyList();       private void ensurePropsIsMutable() {         if (!((bitField0_ &amp; 0x00000020) == 0x00000020)) {           props_ = new java.util.ArrayList(props_);           bitField0_ |= 0x00000020;          }       }        private com.google.protobuf.RepeatedFieldBuilder&lt;           Pair, Pair.Builder, PairOrBuilder&gt; propsBuilder_;        /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public java.util.List getPropsList() {         if (propsBuilder_ == null) {           return java.util.Collections.unmodifiableList(props_);         } else {           return propsBuilder_.getMessageList();         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public int getPropsCount() {         if (propsBuilder_ == null) {           return props_.size();         } else {           return propsBuilder_.getCount();         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Pair getProps(int index) {         if (propsBuilder_ == null) {           return props_.get(index);         } else {           return propsBuilder_.getMessage(index);         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder setProps(           int index, Pair value) {         if (propsBuilder_ == null) {           if (value == null) {             throw new NullPointerException();           }           ensurePropsIsMutable();           props_.set(index, value);           onChanged();         } else {           propsBuilder_.setMessage(index, value);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder setProps(           int index, Pair.Builder builderForValue) {         if (propsBuilder_ == null) {           ensurePropsIsMutable();           props_.set(index, builderForValue.build());           onChanged();         } else {           propsBuilder_.setMessage(index, builderForValue.build());         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder addProps(Pair value) {         if (propsBuilder_ == null) {           if (value == null) {             throw new NullPointerException();           }           ensurePropsIsMutable();           props_.add(value);           onChanged();         } else {           propsBuilder_.addMessage(value);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder addProps(           int index, Pair value) {         if (propsBuilder_ == null) {           if (value == null) {             throw new NullPointerException();           }           ensurePropsIsMutable();           props_.add(index, value);           onChanged();         } else {           propsBuilder_.addMessage(index, value);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder addProps(           Pair.Builder builderForValue) {         if (propsBuilder_ == null) {           ensurePropsIsMutable();           props_.add(builderForValue.build());           onChanged();         } else {           propsBuilder_.addMessage(builderForValue.build());         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder addProps(           int index, Pair.Builder builderForValue) {         if (propsBuilder_ == null) {           ensurePropsIsMutable();           props_.add(index, builderForValue.build());           onChanged();         } else {           propsBuilder_.addMessage(index, builderForValue.build());         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder addAllProps(           Iterable values) {         if (propsBuilder_ == null) {           ensurePropsIsMutable();           com.google.protobuf.AbstractMessageLite.Builder.addAll(               values, props_);           onChanged();         } else {           propsBuilder_.addAllMessages(values);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder clearProps() {         if (propsBuilder_ == null) {           props_ = java.util.Collections.emptyList();           bitField0_ = (bitField0_ &amp; ~0x00000020);           onChanged();         } else {           propsBuilder_.clear();         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Builder removeProps(int index) {         if (propsBuilder_ == null) {           ensurePropsIsMutable();           props_.remove(index);           onChanged();         } else {           propsBuilder_.remove(index);         }         return this;       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Pair.Builder getPropsBuilder(           int index) {         return getPropsFieldBuilder().getBuilder(index);       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public PairOrBuilder getPropsOrBuilder(           int index) {         if (propsBuilder_ == null) {           return props_.get(index);  } else {           return propsBuilder_.getMessageOrBuilder(index);         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public java.util.List            getPropsOrBuilderList() {         if (propsBuilder_ != null) {           return propsBuilder_.getMessageOrBuilderList();         } else {           return java.util.Collections.unmodifiableList(props_);         }       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Pair.Builder addPropsBuilder() {         return getPropsFieldBuilder().addBuilder(             Pair.getDefaultInstance());       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public Pair.Builder addPropsBuilder(           int index) {         return getPropsFieldBuilder().addBuilder(             index, Pair.getDefaultInstance());       }       /**        * repeated .com.alibaba.otter.canal.protocol.Pair props = 13;        *        *         **预留扩展*        *         */       public java.util.List            getPropsBuilderList() {         return getPropsFieldBuilder().getBuilderList();       }       private com.google.protobuf.RepeatedFieldBuilder&lt;           Pair, Pair.Builder, PairOrBuilder&gt;           getPropsFieldBuilder() {         if (propsBuilder_ == null) {           propsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder&lt;               Pair, Pair.Builder, PairOrBuilder&gt;(                   props_,                   ((bitField0_ &amp; 0x00000020) == 0x00000020),                   getParentForChildren(),                   isClean());           props_ = null;         }         return propsBuilder_;       }        private Object ddlSchemaName_ = &quot;&quot;;       /**        * optional string ddlSchemaName = 14;        *        *         ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *        *         */       public boolean hasDdlSchemaName() {         return ((bitField0_ &amp; 0x00000040) == 0x00000040);       }       /**        * optional string ddlSchemaName = 14;        *        *         ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *        *         */       public String getDdlSchemaName() {         Object ref = ddlSchemaName_;         if (!(ref instanceof String)) {           com.google.protobuf.ByteString bs =               (com.google.protobuf.ByteString) ref;           String s = bs.toStringUtf8();           if (bs.isValidUtf8()) {             ddlSchemaName_ = s;           }           return s;         } else {           return (String) ref;         }       }       /**        * optional string ddlSchemaName = 14;        *        *         ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *        *         */       public com.google.protobuf.ByteString           getDdlSchemaNameBytes() {         Object ref = ddlSchemaName_;         if (ref instanceof String) {           com.google.protobuf.ByteString b =               com.google.protobuf.ByteString.copyFromUtf8(                   (String) ref);           ddlSchemaName_ = b;           return b;         } else {           return (com.google.protobuf.ByteString) ref;         }       }       /**        * optional string ddlSchemaName = 14;        *        *         ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *        *         */       public Builder setDdlSchemaName(           String value) {         if (value == null) {     throw new NullPointerException();   }   bitField0_ |= 0x00000040;         ddlSchemaName_ = value;         onChanged();         return this;       }       /**        * optional string ddlSchemaName = 14;        *        *         ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *        *         */       public Builder clearDdlSchemaName() {         bitField0_ = (bitField0_ &amp; ~0x00000040);         ddlSchemaName_ = getDefaultInstance().getDdlSchemaName();         onChanged();         return this;       }       /**        * optional string ddlSchemaName = 14;        *        *         ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *        *         */       public Builder setDdlSchemaNameBytes(           com.google.protobuf.ByteString value) {         if (value == null) {     throw new NullPointerException();   }   bitField0_ |= 0x00000040;         ddlSchemaName_ = value;         onChanged();         return this;       }        // @@protoc_insertion_point(builder_scope:com.alibaba.otter.canal.protocol.RowChange)     }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">11475</td>
    <td align="left">https://github.com/alibaba/canal/blob/08167c95c767fd3c9879584c0230820a8476a7a7/protocol/src/main/java/com/alibaba/otter/canal/protocol/CanalEntry.java/#L8477-L9689</td>
    <td align="right">1</td>
    <td align="right">1617</td>
    <td align="right">11475</td>
  </tr>
  <tr valign="top">
    <td align="right">1629</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@JacksonXmlRootElement @JsonIgnoreProperties(ignoreUnknown = true) public class User implements Serializable {      private static final long serialVersionUID = 4247427179764560935L;      private Integer id;     private String username;     private String name;     @JsonProperty(&quot;first_name&quot;)     private String firstName;     @JsonProperty(&quot;last_name&quot;)     private String lastName;     private String email;     private String url;     private String description;     private String link;     private String locale;     private String nickname;     private String slug;     @JsonProperty(&quot;registered_date&quot;)     private String registeredDate;     private List roles;     private Map capabilities;     @JsonProperty(&quot;extra_capabilities&quot;)     private Map extraCapabilities;     @JsonProperty(&quot;avatar_urls&quot;)     private Map avatarUrls;     @JsonProperty(&quot;meta&quot;)     private List&gt; meta;      public User() {      }      public Integer getId() {         return id;     }      public void setId(Integer id) {         this.id = id;     }      public String getUsername() {         return username;     }      public void setUsername(String username) {         this.username = username;     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public String getFirstName() {         return firstName;     }      public void setFirstName(String firstName) {         this.firstName = firstName;     }      public String getLastName() {         return lastName;     }      public void setLastName(String lastName) {         this.lastName = lastName;     }      public String getEmail() {         return email;     }      public void setEmail(String email) {         this.email = email;     }      public String getUrl() {         return url;     }      public void setUrl(String url) {         this.url = url;     }      public String getDescription() {         return description;     }      public void setDescription(String description) {         this.description = description;     }      public String getLink() {         return link;     }      public void setLink(String link) {         this.link = link;     }      public String getLocale() {         return locale;     }      public void setLocale(String locale) {         this.locale = locale;     }      public String getNickname() {         return nickname;     }      public void setNickname(String nickname) {         this.nickname = nickname;     }      public String getSlug() {         return slug;     }      public void setSlug(String slug) {         this.slug = slug;     }      public String getRegisteredDate() {         return registeredDate;     }      public void setRegisteredDate(String registeredDate) {         this.registeredDate = registeredDate;     }      public List getRoles() {         return roles;     }      public void setRoles(List roles) {         this.roles = roles;     }      public Map getCapabilities() {         return capabilities;     }      public void setCapabilities(Map capabilities) {         this.capabilities = capabilities;     }      public Map getExtraCapabilities() {         return extraCapabilities;     }      public void setExtraCapabilities(Map extraCapabilities) {         this.extraCapabilities = extraCapabilities;     }      public Map getAvatarUrls() {         return avatarUrls;     }      public void setAvatarUrls(Map avatarUrls) {         this.avatarUrls = avatarUrls;     }      public List&gt; getMeta() {         return meta;     }      public void setMeta(List&gt; meta) {         this.meta = meta;     }      @Override     public String toString() {         return toStringHelper(this).addValue(this.id).addValue(this.username).addValue(this.email).addValue(this.name).toString();     }  }</td>
    <td align="left">data class</td>
    <td align="left">Blob, Long Method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">f</td>
    <td align="left">Blob,  Long Method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">11503</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-wordpress/src/main/java/org/apache/camel/component/wordpress/api/model/User.java/#L29-L213</td>
    <td align="right">1</td>
    <td align="right">1629</td>
    <td align="right">11503</td>
  </tr>
  <tr valign="top">
    <td align="right">1637</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Long Method&quot;,       &quot;Blob&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private ClearCacheResponse(         com.google.protobuf.CodedInputStream input,         com.google.protobuf.ExtensionRegistryLite extensionRegistry)         throws com.google.protobuf.InvalidProtocolBufferException {       initFields();       int mutable_bitField0_ = 0;       com.google.protobuf.UnknownFieldSet.Builder unknownFields =           com.google.protobuf.UnknownFieldSet.newBuilder();       try {         boolean done = false;         while (!done) {           int tag = input.readTag();           switch (tag) {             case 0:               done = true;               break;             default: {               if (!parseUnknownField(input, unknownFields,                                      extensionRegistry, tag)) {                 done = true;               }               break;             }             case 8: {               bitField0_ |= 0x00000001;               unfreedBytes_ = input.readInt64();               break;             }           }         }       } catch (com.google.protobuf.InvalidProtocolBufferException e) {         throw e.setUnfinishedMessage(this);       } catch (java.io.IOException e) {         throw new com.google.protobuf.InvalidProtocolBufferException(             e.getMessage()).setUnfinishedMessage(this);       } finally {         this.unknownFields = unknownFields.build();         makeExtensionsImmutable();       }     }</td>
    <td align="left">long method</td>
    <td align="left">Long Method, Blob</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;Blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11527</td>
    <td align="left">https://github.com/apache/phoenix/blob/69e5bb0b304a53967cef40b2a4cfc66e69ecaa51/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/generated/MetaDataProtos.java/#L13962-L14001</td>
    <td align="right">1</td>
    <td align="right">1637</td>
    <td align="right">11527</td>
  </tr>
  <tr valign="top">
    <td align="right">1685</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class MultiDexConfig {      private String name;      public MultiDexConfig(String name) {         this.name = name;     }      @Config(title = &quot;Whether to enable fast&quot;, message = &quot;Enable atlas , true/false&quot;, order = 0, group = &quot;atlas&quot;)     private boolean fastMultiDex = false;      @Config(title = &quot;The extra first dex class list&quot;, message = &quot;The custom needs to be placed in the entry class in the first dex&quot;, order = 3, group = &quot;atlas&quot;)     private Set firstDexClasses = Sets.newHashSet();     /**      * dex The number of subcontracting, 0 No restrictions, no two merges      */     @Config(title = &quot;dexThe number of&quot;, message = &quot;0unlimited&quot;, order = 1, group = &quot;atlas&quot;)     private int dexCount;      public int getMainDexListCount() {         return mainDexListCount;     }      public void setMainDexListCount(int mainDexListCount) {         this.mainDexListCount = mainDexListCount;     }      private int mainDexListCount;      @Config(title = &quot;dexSeparated rules&quot;, message = &quot;a,b;c,d&quot;, order = 2, group = &quot;atlas&quot;)     private String dexSplitRules;      @Config(title = &quot;Does not enter the list of the first dex's blacklist&quot;, message = &quot;a&quot;, order = 2, group = &quot;atlas&quot;)     private Set mainDexBlackList = Sets.newHashSet();      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public boolean isFastMultiDex() {         return fastMultiDex;     }      public void setFastMultiDex(boolean fastMultiDex) {         this.fastMultiDex = fastMultiDex;     }      public Set getMainDexBlackList() {         return mainDexBlackList;     }      public void setMainDexBlackList(Set mainDexBlackList) {         this.mainDexBlackList = mainDexBlackList;     }      public Set getFirstDexClasses() {         return firstDexClasses;     }      public void setFirstDexClasses(Set firstDexClasses) {         this.firstDexClasses = firstDexClasses;     }      public int getDexCount() {         return dexCount;     }      public void setDexCount(int dexCount) {         this.dexCount = dexCount;     }      public String getDexSplitRules() {         return dexSplitRules;     }      public void setDexSplitRules(String dexSplitRules) {         this.dexSplitRules = dexSplitRules;     } }</td>
    <td align="left">data class</td>
    <td align="left">Blob, Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">Blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11686</td>
    <td align="left">https://github.com/alibaba/atlas/blob/e8c7b3f1ff14b2a1df64321c6992b796cae7d732/atlas-gradle-plugin/atlas-plugin/src/main/java/com/taobao/android/builder/extension/MultiDexConfig.java/#L220-L302</td>
    <td align="right">1</td>
    <td align="right">1685</td>
    <td align="right">11686</td>
  </tr>
  <tr valign="top">
    <td align="right">1724</td>
    <td align="left">&nbsp;{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Long Method&quot;,     &quot;Blob&quot;,     &quot;Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class BinaryExpression implements Expression {     protected Expression left;     protected Expression right;      public BinaryExpression(Expression left, Expression right) {         this.left = left;         this.right = right;     }      public Expression getLeft() {         return left;     }      public Expression getRight() {         return right;     }       /**      * @see java.lang.Object#toString()      */     public String toString() {         return &quot;(&quot; + left.toString() + &quot; &quot; + getExpressionSymbol() + &quot; &quot; + right.toString() + &quot;)&quot;;     }      /**      * TODO: more efficient hashCode()      *      * @see java.lang.Object#hashCode()      */     public int hashCode() {         return toString().hashCode();     }      /**      * TODO: more efficient hashCode()      *      * @see java.lang.Object#equals(java.lang.Object)      */     public boolean equals(Object o) {          if (o == null || !this.getClass().equals(o.getClass())) {             return false;         }         return toString().equals(o.toString());      }      /**      * Returns the symbol that represents this binary expression.  For example, addition is      * represented by &quot;+&quot;      *      * @return      */     public abstract String getExpressionSymbol();      /**      * @param expression      */     public void setRight(Expression expression) {         right = expression;     }      /**      * @param expression      */     public void setLeft(Expression expression) {         left = expression;     }      }</td>
    <td align="left">data class</td>
    <td align="left">Long Method, Blob, Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">Long Method,  Blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11803</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-client/src/main/java/org/apache/activemq/filter/BinaryExpression.java/#L26-L96</td>
    <td align="right">1</td>
    <td align="right">1724</td>
    <td align="right">11803</td>
  </tr>
  <tr valign="top">
    <td align="right">1742</td>
    <td align="left">&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Blob&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface ReplicatedLevelDBStoreViewMBean {      @MBeanInfo(&quot;The address of the ZooKeeper server.&quot;)     String getZkAddress();     @MBeanInfo(&quot;The path in ZooKeeper to hold master elections.&quot;)     String getZkPath();     @MBeanInfo(&quot;The ZooKeeper session timeout.&quot;)     String getZkSessionTimeout();     @MBeanInfo(&quot;The address and port the master will bind for the replication protocol.&quot;)     String getBind();     @MBeanInfo(&quot;The number of replication nodes that will be part of the replication cluster.&quot;)     int getReplicas();      @MBeanInfo(&quot;The role of this node in the replication cluster.&quot;)     String getNodeRole();      @MBeanInfo(&quot;The replication status.&quot;)     String getStatus();      @MBeanInfo(&quot;The status of the connected slaves.&quot;)     CompositeData[] getSlaves();      @MBeanInfo(&quot;The current position of the replication log.&quot;)     Long getPosition();      @MBeanInfo(&quot;When the last entry was added to the replication log.&quot;)     Long getPositionDate();      @MBeanInfo(&quot;The directory holding the data.&quot;)     String getDirectory();      @MBeanInfo(&quot;The sync strategy to use.&quot;)     String getSync();      @MBeanInfo(&quot;The node id of this replication node.&quot;)     String getNodeId(); }</td>
    <td align="left">data class</td>
    <td align="left">Blob, Long Method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">f</td>
    <td align="left">Blob,  Long Method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">11845</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-leveldb-store/src/main/java/org/apache/activemq/leveldb/replicated/ReplicatedLevelDBStoreViewMBean.java/#L30-L66</td>
    <td align="right">1</td>
    <td align="right">1742</td>
    <td align="right">11845</td>
  </tr>
  <tr valign="top">
    <td align="right">1749</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Blob&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public interface UpgradeRequest {     /**      * Add WebSocket Extension Configuration(s) to Upgrade Request.      *       * This is merely the list of requested Extensions to use, see {@link UpgradeResponse#getExtensions()} for what was      * negotiated      *      * @param configs the configuration(s) to add      */     void addExtensions(ExtensionConfig... configs);      /**      * Add WebSocket Extension Configuration(s) to request      *       * This is merely the list of requested Extensions to use, see {@link UpgradeResponse#getExtensions()} for what was      * negotiated      *      * @param configs the configuration(s) to add      */     void addExtensions(String... configs);      /**      * Remove all headers from request.      * @deprecated (no longer supported, as this can undo the required upgrade request headers)      */     @Deprecated     void clearHeaders();      /**      * Get the list of Cookies on the Upgrade request      *      * @return the list of Cookies      */     List getCookies();      /**      * Get the list of WebSocket Extension Configurations for this Upgrade Request.      *       * This is merely the list of requested Extensions to use, see {@link UpgradeResponse#getExtensions()} for what was      * negotiated      *      * @return the list of Extension configurations (in the order they were specified)      */     List getExtensions();      /**      * Get a specific Header value from Upgrade Request      *      * @param name the name of the header      * @return the value of the header (null if header does not exist)      */     String getHeader(String name);      /**      * Get the specific Header value, as an int, from the Upgrade Request.      *      * @param name the name of the header      * @return the value of the header as an int (-1 if header does not exist)      * @throws NumberFormatException if unable to parse value as an int.      */     int getHeaderInt(String name);      /**      * Get the headers as a Map of keys to value lists.      *      * @return the headers      */     Map&gt; getHeaders();      /**      * Get the specific header values (for multi-value headers)      *      * @param name the header name      * @return the value list (null if no header exists)      */     List getHeaders(String name);      /**      * The host of the Upgrade Request URI      *      * @return host of the request URI      */     String getHost();      /**      * The HTTP version used for this Upgrade Request      *       * As of RFC6455 (December 2011) this is always      * HTTP/1.1      *      * @return the HTTP Version used      */     String getHttpVersion();      /**      * The HTTP method for this Upgrade Request.      *       * As of RFC6455 (December 2011) this is always GET      *      * @return the HTTP method used      */     String getMethod();      /**      * The WebSocket Origin of this Upgrade Request      *       * See RFC6455: Section 10.2 for details.      *       * Equivalent to {@link #getHeader(String)} passed the &quot;Origin&quot; header.      *      * @return the Origin header      */     String getOrigin();      /**      * Returns a map of the query parameters of the request.      *      * @return a unmodifiable map of query parameters of the request.      */     Map&gt; getParameterMap();      /**      * Get the WebSocket Protocol Version      *       * As of RFC6455, Jetty only supports version      * 13      *      * @return the WebSocket protocol version      */     String getProtocolVersion();      /**      * Get the Query String of the request URI.      *      * @return the request uri query string      */     String getQueryString();      /**      * Get the Request URI      *      * @return the request URI      */     URI getRequestURI();      /**      * Access the Servlet HTTP Session (if present)      *       * Note: Never present on a Client UpgradeRequest.      *      * @return the Servlet HTTPSession on server side UpgradeRequests      */     Object getSession();      /**      * Get the list of offered WebSocket sub-protocols.      *      * @return the list of offered sub-protocols      */     List getSubProtocols();      /**      * Get the User Principal for this request.      *       * Only applicable when using UpgradeRequest from server side.      *      * @return the user principal      */     Principal getUserPrincipal();      /**      * Test if a specific sub-protocol is offered      *      * @param test the sub-protocol to test for      * @return true if sub-protocol exists on request      */     boolean hasSubProtocol(String test);      /**      * Test if supplied Origin is the same as the Request      *      * @param test the supplied origin      * @return true if the supplied origin matches the request origin      */     boolean isOrigin(String test);      /**      * Test if connection is secure.      *      * @return true if connection is secure.      */     boolean isSecure();      /**      * Set the list of Cookies on the request      *      * @param cookies the cookies to use      */     void setCookies(List cookies);      /**      * Set the list of WebSocket Extension configurations on the request.      * @param configs the list of extension configurations      */     void setExtensions(List configs);      /**      * Set a specific header with multi-value field      *       * Overrides any previous value for this named header      *      * @param name the name of the header      * @param values the multi-value field      */     void setHeader(String name, List values);      /**      * Set a specific header value      *       * Overrides any previous value for this named header      *      * @param name the header to set      * @param value the value to set it to      */     void setHeader(String name, String value);      /**      * Sets multiple headers on the request.      *       * Only sets those headers provided, does not remove      * headers that exist on request and are not provided in the      * parameter for this method.      *       * Convenience method vs calling {@link #setHeader(String, List)} multiple times.      *      * @param headers the headers to set      */     void setHeaders(Map&gt; headers);      /**      * Set the HTTP Version to use.      *       * As of RFC6455 (December 2011) this should always be      * HTTP/1.1      *      * @param httpVersion the HTTP version to use.      */     void setHttpVersion(String httpVersion);      /**      * Set the HTTP method to use.      *       * As of RFC6455 (December 2011) this is always GET      *      * @param method the HTTP method to use.      */     void setMethod(String method);      /**      * Set the Request URI to use for this request.      *       * Must be an absolute URI with scheme 'ws' or 'wss'      *      * @param uri the Request URI      */     void setRequestURI(URI uri);      /**      * Set the Session associated with this request.      *       * Typically used to associate the Servlet HttpSession object.      *      * @param session the session object to associate with this request      */     void setSession(Object session);      /**      * Set the offered WebSocket Sub-Protocol list.      *      * @param protocols the offered sub-protocol list      */     void setSubProtocols(List protocols);      /**      * Set the offered WebSocket Sub-Protocol list.      *      * @param protocols the offered sub-protocol list      */     void setSubProtocols(String... protocols);  }</td>
    <td align="left">data class</td>
    <td align="left">Blob, Long Method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">f</td>
    <td align="left">Blob,  Long Method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">11857</td>
    <td align="left">https://github.com/eclipse/jetty.project/blob/65528f76c5ef6ddca11385f9721c8f0bc5f2eed7/jetty-websocket/websocket-api/src/main/java/org/eclipse/jetty/websocket/api/UpgradeRequest.java/#L32-L323</td>
    <td align="right">1</td>
    <td align="right">1749</td>
    <td align="right">11857</td>
  </tr>
  <tr valign="top">
    <td align="right">1779</td>
    <td align="left">&nbsp;{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Blob&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DataSourceLoginService extends AbstractLoginService {     private static final Logger LOG = Log.getLogger(DataSourceLoginService.class);      private String _jndiName = &quot;javax.sql.DataSource/default&quot;;     private DataSource _datasource;     private Server _server;     private String _userTableName = &quot;users&quot;;     private String _userTableKey = &quot;id&quot;;     private String _userTableUserField = &quot;username&quot;;     private String _userTablePasswordField = &quot;pwd&quot;;     private String _roleTableName = &quot;roles&quot;;     private String _roleTableKey = &quot;id&quot;;     private String _roleTableRoleField = &quot;role&quot;;     private String _userRoleTableName = &quot;user_roles&quot;;     private String _userRoleTableUserKey = &quot;user_id&quot;;     private String _userRoleTableRoleKey = &quot;role_id&quot;;     private String _userSql;     private String _roleSql;     private boolean _createTables = false;               /**      * DBUser      */     public class DBUserPrincipal extends UserPrincipal     {         private int _key;                  public DBUserPrincipal(String name, Credential credential, int key)         {             super(name, credential);             _key = key;         }                  public int getKey ()         {             return _key;         }              }      /* ------------------------------------------------------------ */     public DataSourceLoginService()     {     }      /* ------------------------------------------------------------ */     public DataSourceLoginService(String name)     {         setName(name);     }      /* ------------------------------------------------------------ */     public DataSourceLoginService(String name, IdentityService identityService)     {         setName(name);         setIdentityService(identityService);     }      /* ------------------------------------------------------------ */     public void setJndiName (String jndi)     {         _jndiName = jndi;     }      /* ------------------------------------------------------------ */     public String getJndiName ()     {         return _jndiName;     }      /* ------------------------------------------------------------ */     public void setServer (Server server)     {         _server=server;     }      /* ------------------------------------------------------------ */     public Server getServer()     {         return _server;     }      /* ------------------------------------------------------------ */     public void setCreateTables(boolean createTables)     {         _createTables = createTables;     }      /* ------------------------------------------------------------ */     public boolean getCreateTables()     {         return _createTables;     }      /* ------------------------------------------------------------ */     public void setUserTableName (String name)     {         _userTableName=name;     }      /* ------------------------------------------------------------ */     public String getUserTableName()     {         return _userTableName;     }      /* ------------------------------------------------------------ */     public String getUserTableKey()     {         return _userTableKey;     }       /* ------------------------------------------------------------ */     public void setUserTableKey(String tableKey)     {         _userTableKey = tableKey;     }       /* ------------------------------------------------------------ */     public String getUserTableUserField()     {         return _userTableUserField;     }       /* ------------------------------------------------------------ */     public void setUserTableUserField(String tableUserField)     {         _userTableUserField = tableUserField;     }       /* ------------------------------------------------------------ */     public String getUserTablePasswordField()     {         return _userTablePasswordField;     }       /* ------------------------------------------------------------ */     public void setUserTablePasswordField(String tablePasswordField)     {         _userTablePasswordField = tablePasswordField;     }       /* ------------------------------------------------------------ */     public String getRoleTableName()     {         return _roleTableName;     }       /* ------------------------------------------------------------ */     public void setRoleTableName(String tableName)     {         _roleTableName = tableName;     }       /* ------------------------------------------------------------ */     public String getRoleTableKey()     {         return _roleTableKey;     }       /* ------------------------------------------------------------ */     public void setRoleTableKey(String tableKey)     {         _roleTableKey = tableKey;     }       /* ------------------------------------------------------------ */     public String getRoleTableRoleField()     {         return _roleTableRoleField;     }       /* ------------------------------------------------------------ */     public void setRoleTableRoleField(String tableRoleField)     {         _roleTableRoleField = tableRoleField;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableName()     {         return _userRoleTableName;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableName(String roleTableName)     {         _userRoleTableName = roleTableName;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableUserKey()     {         return _userRoleTableUserKey;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableUserKey(String roleTableUserKey)     {         _userRoleTableUserKey = roleTableUserKey;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableRoleKey()     {         return _userRoleTableRoleKey;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableRoleKey(String roleTableRoleKey)     {         _userRoleTableRoleKey = roleTableRoleKey;     }              /* ------------------------------------------------------------ */     @Override     public UserPrincipal loadUserInfo (String username)     {         try         {             try (Connection connection = getConnection();                     PreparedStatement statement1 = connection.prepareStatement(_userSql))             {                 statement1.setObject(1, username);                 try (ResultSet rs1 = statement1.executeQuery())                 {                     if (rs1.next())                     {                         int key = rs1.getInt(_userTableKey);                         String credentials = rs1.getString(_userTablePasswordField);                                                  return new DBUserPrincipal(username, Credential.getCredential(credentials), key);                     }                 }             }         }         catch (NamingException e)         {             LOG.warn(&quot;No datasource for &quot;+_jndiName, e);         }         catch (SQLException e)         {             LOG.warn(&quot;Problem loading user info for &quot;+username, e);         }         return null;     }               /* ------------------------------------------------------------ */     @Override     public String[] loadRoleInfo (UserPrincipal user)     {         DBUserPrincipal dbuser = (DBUserPrincipal)user;          try         {             try (Connection connection = getConnection();                     PreparedStatement statement2 = connection.prepareStatement(_roleSql))             {                  List roles = new ArrayList();                  statement2.setInt(1, dbuser.getKey());                 try (ResultSet rs2 = statement2.executeQuery())                 {                     while (rs2.next())                     {                         roles.add(rs2.getString(_roleTableRoleField));                     }                                          return roles.toArray(new String[roles.size()]);                 }             }         }         catch (NamingException e)         {             LOG.warn(&quot;No datasource for &quot;+_jndiName, e);         }         catch (SQLException e)         {             LOG.warn(&quot;Problem loading user info for &quot;+user.getName(), e);         }         return null;     }             /* ------------------------------------------------------------ */     /**      * Lookup the datasource for the jndiName and formulate the      * necessary sql query strings based on the configured table      * and column names.      *      * @throws NamingException if unable to init jndi      * @throws SQLException if unable to init database      */     public void initDb() throws NamingException, SQLException     {         if (_datasource != null)             return;          @SuppressWarnings(&quot;unused&quot;)         InitialContext ic = new InitialContext();         assert ic!=null;          // TODO Should we try webapp scope too?          // try finding the datasource in the Server scope         if (_server != null)         {             try             {                 _datasource = (DataSource)NamingEntryUtil.lookup(_server, _jndiName);             }             catch (NameNotFoundException e)             {                 //next try the jvm scope             }         }           //try finding the datasource in the jvm scope         if (_datasource==null)         {             _datasource = (DataSource)NamingEntryUtil.lookup(null, _jndiName);         }          // set up the select statements based on the table and column names configured         _userSql = &quot;select &quot; + _userTableKey + &quot;,&quot; + _userTablePasswordField                   + &quot; from &quot; + _userTableName                   + &quot; where &quot;+ _userTableUserField + &quot; = ?&quot;;          _roleSql = &quot;select r.&quot; + _roleTableRoleField                   + &quot; from &quot; + _roleTableName + &quot; r, &quot; + _userRoleTableName                   + &quot; u where u.&quot;+ _userRoleTableUserKey + &quot; = ?&quot;                   + &quot; and r.&quot; + _roleTableKey + &quot; = u.&quot; + _userRoleTableRoleKey;          prepareTables();     }      /* ------------------------------------------------------------ */     /**      * @throws NamingException      * @throws SQLException      */     private void prepareTables()     throws NamingException, SQLException     {         if (_createTables)         {             boolean autocommit = true;             Connection connection = getConnection();             try (Statement stmt = connection.createStatement())             {                 autocommit = connection.getAutoCommit();                 connection.setAutoCommit(false);                 DatabaseMetaData metaData = connection.getMetaData();                  //check if tables exist                 String tableName = (metaData.storesLowerCaseIdentifiers()? _userTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userTableName.toUpperCase(Locale.ENGLISH): _userTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //user table default                         /*                          * create table _userTableName (_userTableKey integer,                          * _userTableUserField varchar(100) not null unique,                          * _userTablePasswordField varchar(20) not null, primary key(_userTableKey));                          */                         stmt.executeUpdate(&quot;create table &quot;+_userTableName+ &quot;(&quot;+_userTableKey+&quot; integer,&quot;+                                 _userTableUserField+&quot; varchar(100) not null unique,&quot;+                                 _userTablePasswordField+&quot; varchar(20) not null, primary key(&quot;+_userTableKey+&quot;))&quot;);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_userTableName);                     }                 }                  tableName = (metaData.storesLowerCaseIdentifiers()? _roleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_roleTableName.toUpperCase(Locale.ENGLISH): _roleTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //role table default                         /*                          * create table _roleTableName (_roleTableKey integer,                          * _roleTableRoleField varchar(100) not null unique, primary key(_roleTableKey));                          */                         String str = &quot;create table &quot;+_roleTableName+&quot; (&quot;+_roleTableKey+&quot; integer, &quot;+                         _roleTableRoleField+&quot; varchar(100) not null unique, primary key(&quot;+_roleTableKey+&quot;))&quot;;                         stmt.executeUpdate(str);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_roleTableName);                     }                 }                  tableName = (metaData.storesLowerCaseIdentifiers()? _userRoleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userRoleTableName.toUpperCase(Locale.ENGLISH): _userRoleTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //user-role table                         /*                          * create table _userRoleTableName (_userRoleTableUserKey integer,                          * _userRoleTableRoleKey integer,                          * primary key (_userRoleTableUserKey, _userRoleTableRoleKey));                          *                          * create index idx_user_role on _userRoleTableName (_userRoleTableUserKey);                          */                         stmt.executeUpdate(&quot;create table &quot;+_userRoleTableName+&quot; (&quot;+_userRoleTableUserKey+&quot; integer, &quot;+                                 _userRoleTableRoleKey+&quot; integer, &quot;+                                 &quot;primary key (&quot;+_userRoleTableUserKey+&quot;, &quot;+_userRoleTableRoleKey+&quot;))&quot;);                         stmt.executeUpdate(&quot;create index indx_user_role on &quot;+_userRoleTableName+&quot;(&quot;+_userRoleTableUserKey+&quot;)&quot;);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_userRoleTableName +&quot; and index&quot;);                     }                 }                 connection.commit();             }             finally             {                 try                 {                     connection.setAutoCommit(autocommit);                 }                 catch (SQLException e)                 {                     if (LOG.isDebugEnabled()) LOG.debug(&quot;Prepare tables&quot;, e);                 }                 finally                 {                     try                     {                         connection.close();                     }                     catch (SQLException e)                     {                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Prepare tables&quot;, e);                     }                 }             }         }         else if (LOG.isDebugEnabled())         {             LOG.debug(&quot;createTables false&quot;);         }     }      /* ------------------------------------------------------------ */     /**      * @return      * @throws NamingException      * @throws SQLException      */     private Connection getConnection ()     throws NamingException, SQLException     {         initDb();         return _datasource.getConnection();     } }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">11959</td>
    <td align="left">https://github.com/eclipse/jetty.project/blob/65528f76c5ef6ddca11385f9721c8f0bc5f2eed7/jetty-plus/src/main/java/org/eclipse/jetty/plus/security/DataSourceLoginService.java/#L52-L530</td>
    <td align="right">1</td>
    <td align="right">1779</td>
    <td align="right">11959</td>
  </tr>
  <tr valign="top">
    <td align="right">1791</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;details&quot;: {&quot;bad_smells&quot;: [&quot;Blob&quot;]}}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TransportConnectionState extends org.apache.activemq.state.ConnectionState {      private ConnectionContext context;     private TransportConnection connection;     private AtomicInteger referenceCounter = new AtomicInteger();     private final Object connectionMutex = new Object();      public TransportConnectionState(ConnectionInfo info, TransportConnection transportConnection) {         super(info);         connection = transportConnection;     }      public ConnectionContext getContext() {         return context;     }      public TransportConnection getConnection() {         return connection;     }      public void setContext(ConnectionContext context) {         this.context = context;     }      public void setConnection(TransportConnection connection) {         this.connection = connection;     }      public int incrementReference() {         return referenceCounter.incrementAndGet();     }      public int decrementReference() {         return referenceCounter.decrementAndGet();     }  	public AtomicInteger getReferenceCounter() { 		return referenceCounter; 	}  	public void setReferenceCounter(AtomicInteger referenceCounter) { 		this.referenceCounter = referenceCounter; 	}  	public Object getConnectionMutex() { 		return connectionMutex; 	} }</td>
    <td align="left">data class</td>
    <td align="left">'bad_smells': 'Blob'</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">{',b,a,d,_,s,m,e,l,l,s,',:,&quot; &quot;,',B,l,o,b,'}</td>
    <td align="left">{',b,d,_,m,',:,&quot; &quot;,',B,o,b,'}</td>
    <td align="right">0</td>
    <td align="right">11988</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-broker/src/main/java/org/apache/activemq/broker/TransportConnectionState.java/#L27-L74</td>
    <td align="right">1</td>
    <td align="right">1791</td>
    <td align="right">11988</td>
  </tr>
  <tr valign="top">
    <td align="right">1831</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class DAOAttachment {         private final AttachmentId attachmentId;         private final BlobId blobId;         private final String type;         private final long size;          private DAOAttachment(AttachmentId attachmentId, BlobId blobId, String type, long size) {             this.attachmentId = attachmentId;             this.blobId = blobId;             this.type = type;             this.size = size;         }          public AttachmentId getAttachmentId() {             return attachmentId;         }          public BlobId getBlobId() {             return blobId;         }          public String getType() {             return type;         }          public long getSize() {             return size;         }          public Attachment toAttachment(byte[] data) {             return Attachment.builder()                 .attachmentId(attachmentId)                 .type(type)                 .bytes(data)                 .build();         }          @Override         public final boolean equals(Object o) {             if (o instanceof DAOAttachment) {                 DAOAttachment that = (DAOAttachment) o;                  return Objects.equals(this.size, that.size)                     &amp;&amp; Objects.equals(this.attachmentId, that.attachmentId)                     &amp;&amp; Objects.equals(this.blobId, that.blobId)                     &amp;&amp; Objects.equals(this.type, that.type);             }             return false;         }          @Override         public final int hashCode() {             return Objects.hash(attachmentId, blobId, type, size);         }     }</td>
    <td align="left">data class</td>
    <td align="left">Blob, Data Class</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">Blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12126</td>
    <td align="left">https://github.com/apache/james-project/blob/fa24a096a5853459c3769a34ccc68feb91626bfa/mailbox/cassandra/src/main/java/org/apache/james/mailbox/cassandra/mail/CassandraAttachmentDAOV2.java/#L50-L104</td>
    <td align="right">1</td>
    <td align="right">1831</td>
    <td align="right">12126</td>
  </tr>
  <tr valign="top">
    <td align="right">1864</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DruidPooledCallableStatement extends DruidPooledPreparedStatement implements CallableStatement {      private CallableStatement stmt;      public DruidPooledCallableStatement(DruidPooledConnection conn, PreparedStatementHolder holder) throws SQLException{         super(conn, holder);         this.stmt = (CallableStatement) holder.statement;     }      public CallableStatement getCallableStatementRaw() {         return stmt;     }      @Override     public void registerOutParameter(int parameterIndex, int sqlType) throws SQLException {         try {             stmt.registerOutParameter(parameterIndex, sqlType);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(int parameterIndex, int sqlType, int scale) throws SQLException {         try {             stmt.registerOutParameter(parameterIndex, sqlType, scale);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public boolean wasNull() throws SQLException {         try {             return stmt.wasNull();         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public String getString(int parameterIndex) throws SQLException {         try {             return stmt.getString(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public boolean getBoolean(int parameterIndex) throws SQLException {         try {             return stmt.getBoolean(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public byte getByte(int parameterIndex) throws SQLException {         try {             return stmt.getByte(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public short getShort(int parameterIndex) throws SQLException {         try {             return stmt.getShort(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public int getInt(int parameterIndex) throws SQLException {         try {             return stmt.getInt(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public long getLong(int parameterIndex) throws SQLException {         try {             return stmt.getLong(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public float getFloat(int parameterIndex) throws SQLException {         try {             return stmt.getFloat(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public double getDouble(int parameterIndex) throws SQLException {         try {             return stmt.getDouble(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     @Deprecated     public BigDecimal getBigDecimal(int parameterIndex, int scale) throws SQLException {         try {             return stmt.getBigDecimal(parameterIndex, scale);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public byte[] getBytes(int parameterIndex) throws SQLException {         try {             return stmt.getBytes(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Date getDate(int parameterIndex) throws SQLException {         try {             return stmt.getDate(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Time getTime(int parameterIndex) throws SQLException {         try {             return stmt.getTime(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Timestamp getTimestamp(int parameterIndex) throws SQLException {         try {             return stmt.getTimestamp(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Object getObject(int parameterIndex) throws SQLException {         try {             Object obj = stmt.getObject(parameterIndex);             return wrapObject(obj);         } catch (Throwable t) {             throw checkException(t);         }     }      private Object wrapObject(Object obj) {         if (obj instanceof ResultSet) {             ResultSet rs = (ResultSet) obj;                          DruidPooledResultSet poolableResultSet = new DruidPooledResultSet(this, rs);             addResultSetTrace(poolableResultSet);                          obj = poolableResultSet;         }                  return obj;     }      @Override     public BigDecimal getBigDecimal(int parameterIndex) throws SQLException {         try {             return stmt.getBigDecimal(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Object getObject(int parameterIndex, java.util.Map&gt; map) throws SQLException {         try {             Object obj = stmt.getObject(parameterIndex, map);             return wrapObject(obj);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Ref getRef(int parameterIndex) throws SQLException {         try {             return stmt.getRef(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Blob getBlob(int parameterIndex) throws SQLException {         try {             return stmt.getBlob(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Clob getClob(int parameterIndex) throws SQLException {         try {             return stmt.getClob(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Array getArray(int parameterIndex) throws SQLException {         try {             return stmt.getArray(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Date getDate(int parameterIndex, Calendar cal) throws SQLException {         try {             return stmt.getDate(parameterIndex, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Time getTime(int parameterIndex, Calendar cal) throws SQLException {         try {             return stmt.getTime(parameterIndex, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Timestamp getTimestamp(int parameterIndex, Calendar cal) throws SQLException {         try {             return stmt.getTimestamp(parameterIndex, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(int parameterIndex, int sqlType, String typeName) throws SQLException {         try {             stmt.registerOutParameter(parameterIndex, sqlType, typeName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(String parameterName, int sqlType) throws SQLException {         try {             stmt.registerOutParameter(parameterName, sqlType);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(String parameterName, int sqlType, int scale) throws SQLException {         try {             stmt.registerOutParameter(parameterName, sqlType, scale);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(String parameterName, int sqlType, String typeName) throws SQLException {         try {             stmt.registerOutParameter(parameterName, sqlType, typeName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.net.URL getURL(int parameterIndex) throws SQLException {         try {             return stmt.getURL(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setURL(String parameterName, java.net.URL val) throws SQLException {         try {             stmt.setURL(parameterName, val);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNull(String parameterName, int sqlType) throws SQLException {         try {             stmt.setNull(parameterName, sqlType);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBoolean(String parameterName, boolean x) throws SQLException {         try {             stmt.setBoolean(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setByte(String parameterName, byte x) throws SQLException {         try {             stmt.setByte(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setShort(String parameterName, short x) throws SQLException {         try {             stmt.setShort(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setInt(String parameterName, int x) throws SQLException {         try {             stmt.setInt(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setLong(String parameterName, long x) throws SQLException {         try {             stmt.setLong(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setFloat(String parameterName, float x) throws SQLException {         try {             stmt.setFloat(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setDouble(String parameterName, double x) throws SQLException {         try {             stmt.setDouble(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBigDecimal(String parameterName, BigDecimal x) throws SQLException {         try {             stmt.setBigDecimal(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setString(String parameterName, String x) throws SQLException {         try {             stmt.setString(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBytes(String parameterName, byte x[]) throws SQLException {         try {             stmt.setBytes(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setDate(String parameterName, java.sql.Date x) throws SQLException {         try {             stmt.setDate(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setTime(String parameterName, java.sql.Time x) throws SQLException {         try {             stmt.setTime(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setTimestamp(String parameterName, java.sql.Timestamp x) throws SQLException {         try {             stmt.setTimestamp(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setAsciiStream(String parameterName, java.io.InputStream x, int length) throws SQLException {         try {             stmt.setAsciiStream(parameterName, x, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBinaryStream(String parameterName, java.io.InputStream x, int length) throws SQLException {         try {             stmt.setBinaryStream(parameterName, x, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setObject(String parameterName, Object x, int targetSqlType, int scale) throws SQLException {         try {             stmt.setObject(parameterName, x, targetSqlType, scale);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setObject(String parameterName, Object x, int targetSqlType) throws SQLException {         try {             stmt.setObject(parameterName, x, targetSqlType);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setObject(String parameterName, Object x) throws SQLException {         try {             stmt.setObject(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setCharacterStream(String parameterName, java.io.Reader reader, int length) throws SQLException {         try {             stmt.setCharacterStream(parameterName, reader, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setDate(String parameterName, java.sql.Date x, Calendar cal) throws SQLException {         try {             stmt.setDate(parameterName, x, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setTime(String parameterName, java.sql.Time x, Calendar cal) throws SQLException {         try {             stmt.setTime(parameterName, x, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setTimestamp(String parameterName, java.sql.Timestamp x, Calendar cal) throws SQLException {         try {             stmt.setTimestamp(parameterName, x, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNull(String parameterName, int sqlType, String typeName) throws SQLException {         try {             stmt.setNull(parameterName, sqlType, typeName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public String getString(String parameterName) throws SQLException {         try {             return stmt.getString(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public boolean getBoolean(String parameterName) throws SQLException {         try {             return stmt.getBoolean(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public byte getByte(String parameterName) throws SQLException {         try {             return stmt.getByte(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public short getShort(String parameterName) throws SQLException {         try {             return stmt.getShort(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public int getInt(String parameterName) throws SQLException {         try {             return stmt.getInt(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public long getLong(String parameterName) throws SQLException {         try {             return stmt.getLong(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public float getFloat(String parameterName) throws SQLException {         try {             return stmt.getFloat(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public double getDouble(String parameterName) throws SQLException {         try {             return stmt.getDouble(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public byte[] getBytes(String parameterName) throws SQLException {         try {             return stmt.getBytes(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Date getDate(String parameterName) throws SQLException {         try {             return stmt.getDate(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Time getTime(String parameterName) throws SQLException {         try {             return stmt.getTime(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Timestamp getTimestamp(String parameterName) throws SQLException {         try {             return stmt.getTimestamp(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Object getObject(String parameterName) throws SQLException {         try {             Object obj = stmt.getObject(parameterName);             return wrapObject(obj);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public BigDecimal getBigDecimal(String parameterName) throws SQLException {         try {             return stmt.getBigDecimal(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Object getObject(String parameterName, java.util.Map&gt; map) throws SQLException {         try {             Object obj = stmt.getObject(parameterName, map);             return wrapObject(obj);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Ref getRef(String parameterName) throws SQLException {         try {             return stmt.getRef(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Blob getBlob(String parameterName) throws SQLException {         try {             return stmt.getBlob(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Clob getClob(String parameterName) throws SQLException {         try {             return stmt.getClob(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Array getArray(String parameterName) throws SQLException {         try {             return stmt.getArray(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Date getDate(String parameterName, Calendar cal) throws SQLException {         try {             return stmt.getDate(parameterName, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Time getTime(String parameterName, Calendar cal) throws SQLException {         try {             return stmt.getTime(parameterName, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Timestamp getTimestamp(String parameterName, Calendar cal) throws SQLException {         try {             return stmt.getTimestamp(parameterName, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.net.URL getURL(String parameterName) throws SQLException {         try {             return stmt.getURL(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public RowId getRowId(int parameterIndex) throws SQLException {         try {             return stmt.getRowId(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public RowId getRowId(String parameterName) throws SQLException {         try {             return stmt.getRowId(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setRowId(String parameterName, RowId x) throws SQLException {         try {             stmt.setRowId(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNString(String parameterName, String value) throws SQLException {         try {             stmt.setNString(parameterName, value);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNCharacterStream(String parameterName, Reader value, long length) throws SQLException {         try {             stmt.setNCharacterStream(parameterName, value, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNClob(String parameterName, NClob value) throws SQLException {         try {             stmt.setNClob(parameterName, value);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setClob(String parameterName, Reader reader, long length) throws SQLException {         try {             stmt.setClob(parameterName, reader, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBlob(String parameterName, InputStream inputStream, long length) throws SQLException {         try {             stmt.setBlob(parameterName, inputStream, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNClob(String parameterName, Reader reader, long length) throws SQLException {         try {             stmt.setNClob(parameterName, reader, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public NClob getNClob(int parameterIndex) throws SQLException {         try {             return stmt.getNClob(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public NClob getNClob(String parameterName) throws SQLException {         try {             return stmt.getNClob(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setSQLXML(String parameterName, SQLXML xmlObject) throws SQLException {         try {             stmt.setSQLXML(parameterName, xmlObject);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public SQLXML getSQLXML(int parameterIndex) throws SQLException {         try {             return stmt.getSQLXML(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public SQLXML getSQLXML(String parameterName) throws SQLException {         try {             return stmt.getSQLXML(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public String getNString(int parameterIndex) throws SQLException {         try {             return stmt.getNString(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public String getNString(String parameterName) throws SQLException {         try {             return stmt.getNString(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.io.Reader getNCharacterStream(int parameterIndex) throws SQLException {         try {             return stmt.getNCharacterStream(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.io.Reader getNCharacterStream(String parameterName) throws SQLException {         try {             return stmt.getNCharacterStream(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.io.Reader getCharacterStream(int parameterIndex) throws SQLException {         try {             return stmt.getCharacterStream(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.io.Reader getCharacterStream(String parameterName) throws SQLException {         try {             return stmt.getCharacterStream(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBlob(String parameterName, Blob x) throws SQLException {         try {             stmt.setBlob(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setClob(String parameterName, Clob x) throws SQLException {         try {             stmt.setClob(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setAsciiStream(String parameterName, java.io.InputStream x, long length) throws SQLException {         try {             stmt.setAsciiStream(parameterName, x, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBinaryStream(String parameterName, java.io.InputStream x, long length) throws SQLException {         try {             stmt.setBinaryStream(parameterName, x, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setCharacterStream(String parameterName, java.io.Reader reader, long length) throws SQLException {         try {             stmt.setCharacterStream(parameterName, reader, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setAsciiStream(String parameterName, java.io.InputStream x) throws SQLException {         try {             stmt.setAsciiStream(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBinaryStream(String parameterName, java.io.InputStream x) throws SQLException {         try {             stmt.setBinaryStream(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setCharacterStream(String parameterName, java.io.Reader reader) throws SQLException {         try {             stmt.setCharacterStream(parameterName, reader);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNCharacterStream(String parameterName, Reader value) throws SQLException {         try {             stmt.setNCharacterStream(parameterName, value);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setClob(String parameterName, Reader reader) throws SQLException {         try {             stmt.setClob(parameterName, reader);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBlob(String parameterName, InputStream inputStream) throws SQLException {         try {             stmt.setBlob(parameterName, inputStream);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNClob(String parameterName, Reader reader) throws SQLException {         try {             stmt.setNClob(parameterName, reader);         } catch (Throwable t) {             throw checkException(t);         }     }      public  T getObject(int parameterIndex, Class type) throws SQLException {         throw new SQLFeatureNotSupportedException();     }      public  T getObject(String parameterName, Class type) throws SQLException {         throw new SQLFeatureNotSupportedException();     }      @SuppressWarnings(&quot;unchecked&quot;)     public  T unwrap(Class iface) throws SQLException {         if (iface == CallableStatement.class || iface == PreparedStatement.class) {             if (stmt instanceof CallableStatementProxy) {                 return stmt.unwrap(iface);             }             return (T) stmt;         }                  return super.unwrap(iface);     } }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">12232</td>
    <td align="left">https://github.com/alibaba/druid/blob/768469fe4d1340efe1036453366a58c9ab7e30d1/src/main/java/com/alibaba/druid/pool/DruidPooledCallableStatement.java/#L40-L1089</td>
    <td align="right">1</td>
    <td align="right">1864</td>
    <td align="right">12232</td>
  </tr>
  <tr valign="top">
    <td align="right">1885</td>
    <td align="left">     {         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Long Method&quot;,             &quot;Blob&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @Override     public boolean isExists(Object identifier) throws AppCatalogException {         HashMap ids;         if (identifier instanceof Map) {             ids = (HashMap) identifier;         } else {             logger.error(&quot;Identifier should be a map with the field name and it's value&quot;);             throw new AppCatalogException(&quot;Identifier should be a map with the field name and it's value&quot;);         }          EntityManager em = null;         try {             em = AppCatalogJPAUtils.getEntityManager();             ComputeResourcePreference existingPreference = em.find(ComputeResourcePreference.class,                     new ComputeResourcePreferencePK(ids.get(ComputeResourcePreferenceConstants.GATEWAY_ID),                             ids.get(ComputeResourcePreferenceConstants.RESOURCE_ID)));             if (em.isOpen()) {                 if (em.getTransaction().isActive()){                     em.getTransaction().rollback();                 }                 em.close();             }             return existingPreference != null;         }catch (Exception e) {             logger.error(e.getMessage(), e);             throw new AppCatalogException(e);         } finally {             if (em != null &amp;&amp; em.isOpen()) {                 if (em.getTransaction().isActive()) {                     em.getTransaction().rollback();                 }                 em.close();             }         }     }</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12293</td>
    <td align="left">https://github.com/apache/airavata/blob/391843a00eefa7b6213e845f2f044b4e042894d5/modules/registry/registry-core/src/main/java/org/apache/airavata/registry/core/app/catalog/resources/ComputeHostPreferenceResource.java/#L522-L556</td>
    <td align="right">1</td>
    <td align="right">1885</td>
    <td align="right">12293</td>
  </tr>
  <tr valign="top">
    <td align="right">1887</td>
    <td align="left">&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Blob&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    TreeNodeChildren(final TreeNode parent, final Object metadata, final PropertyAccessor accessor) {         this.parent   = parent;         this.metadata = metadata;         this.accessor = accessor;         this.children = new TreeNode[accessor.count()];         /*          * Search for something that looks like the main property, to be associated with the parent node          * instead than provided as a child. The intent is to have more compact and easy to read trees.          * That property shall be a singleton for a simple value (not another metadata object).          */         if (parent.table.valuePolicy == ValueExistencePolicy.COMPACT) {             TitleProperty an = accessor.implementation.getAnnotation(TitleProperty.class);             if (an == null) {                 Class implementation = parent.table.standard.getImplementation(accessor.type);                 if (implementation != null) {                     an = implementation.getAnnotation(TitleProperty.class);                 }             }             if (an != null) {                 final int index = accessor.indexOf(an.name(), false);                 final Class type = accessor.type(index, TypeValuePolicy.ELEMENT_TYPE);                 if (type != null &amp;&amp; !parent.isMetadata(type) &amp;&amp; type == accessor.type(index, TypeValuePolicy.PROPERTY_TYPE)) {                     titleProperty = index;                     return;                 }             }         }         titleProperty = -1;     }</td>
    <td align="left">long method</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12299</td>
    <td align="left">https://github.com/apache/sis/blob/002121abc9b9826fbd51fac7150b3ee0c02cc88b/core/sis-metadata/src/main/java/org/apache/sis/metadata/TreeNodeChildren.java/#L137-L165</td>
    <td align="right">1</td>
    <td align="right">1887</td>
    <td align="right">12299</td>
  </tr>
  <tr valign="top">
    <td align="right">1909</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Blob&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public class GroupMultiplicitiesElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.xtext.validation.ConcreteSyntaxValidationTestLanguage.GroupMultiplicities&quot;); 		private final Group cGroup = (Group)rule.eContents().get(1); 		private final Keyword cNumberSignDigitFourKeyword_0 = (Keyword)cGroup.eContents().get(0); 		private final Assignment cVal1Assignment_1 = (Assignment)cGroup.eContents().get(1); 		private final RuleCall cVal1IDTerminalRuleCall_1_0 = (RuleCall)cVal1Assignment_1.eContents().get(0); 		private final Keyword cKw1Keyword_2 = (Keyword)cGroup.eContents().get(2); 		private final Group cGroup_3 = (Group)cGroup.eContents().get(3); 		private final Assignment cVal2Assignment_3_0 = (Assignment)cGroup_3.eContents().get(0); 		private final RuleCall cVal2IDTerminalRuleCall_3_0_0 = (RuleCall)cVal2Assignment_3_0.eContents().get(0); 		private final Assignment cVal3Assignment_3_1 = (Assignment)cGroup_3.eContents().get(1); 		private final RuleCall cVal3IDTerminalRuleCall_3_1_0 = (RuleCall)cVal3Assignment_3_1.eContents().get(0); 		private final Keyword cKw2Keyword_4 = (Keyword)cGroup.eContents().get(4); 		private final Group cGroup_5 = (Group)cGroup.eContents().get(5); 		private final Assignment cVal4Assignment_5_0 = (Assignment)cGroup_5.eContents().get(0); 		private final RuleCall cVal4IDTerminalRuleCall_5_0_0 = (RuleCall)cVal4Assignment_5_0.eContents().get(0); 		private final Assignment cVal5Assignment_5_1 = (Assignment)cGroup_5.eContents().get(1); 		private final RuleCall cVal5IDTerminalRuleCall_5_1_0 = (RuleCall)cVal5Assignment_5_1.eContents().get(0); 		private final Keyword cKw3Keyword_6 = (Keyword)cGroup.eContents().get(6); 		private final Group cGroup_7 = (Group)cGroup.eContents().get(7); 		private final Assignment cVal6Assignment_7_0 = (Assignment)cGroup_7.eContents().get(0); 		private final RuleCall cVal6IDTerminalRuleCall_7_0_0 = (RuleCall)cVal6Assignment_7_0.eContents().get(0); 		private final Assignment cVal7Assignment_7_1 = (Assignment)cGroup_7.eContents().get(1); 		private final RuleCall cVal7IDTerminalRuleCall_7_1_0 = (RuleCall)cVal7Assignment_7_1.eContents().get(0); 		 		//GroupMultiplicities: 		//	&quot;#4&quot; val1=ID &quot;kw1&quot; (val2=ID val3=ID)? &quot;kw2&quot; (val4+=ID val5+=ID)+ &quot;kw3&quot; (val6+=ID val7+=ID)*; 		@Override public ParserRule getRule() { return rule; } 		 		//&quot;#4&quot; val1=ID &quot;kw1&quot; (val2=ID val3=ID)? &quot;kw2&quot; (val4+=ID val5+=ID)+ &quot;kw3&quot; (val6+=ID val7+=ID)* 		public Group getGroup() { return cGroup; } 		 		//&quot;#4&quot; 		public Keyword getNumberSignDigitFourKeyword_0() { return cNumberSignDigitFourKeyword_0; } 		 		//val1=ID 		public Assignment getVal1Assignment_1() { return cVal1Assignment_1; } 		 		//ID 		public RuleCall getVal1IDTerminalRuleCall_1_0() { return cVal1IDTerminalRuleCall_1_0; } 		 		//&quot;kw1&quot; 		public Keyword getKw1Keyword_2() { return cKw1Keyword_2; } 		 		//(val2=ID val3=ID)? 		public Group getGroup_3() { return cGroup_3; } 		 		//val2=ID 		public Assignment getVal2Assignment_3_0() { return cVal2Assignment_3_0; } 		 		//ID 		public RuleCall getVal2IDTerminalRuleCall_3_0_0() { return cVal2IDTerminalRuleCall_3_0_0; } 		 		//val3=ID 		public Assignment getVal3Assignment_3_1() { return cVal3Assignment_3_1; } 		 		//ID 		public RuleCall getVal3IDTerminalRuleCall_3_1_0() { return cVal3IDTerminalRuleCall_3_1_0; } 		 		//&quot;kw2&quot; 		public Keyword getKw2Keyword_4() { return cKw2Keyword_4; } 		 		//(val4+=ID val5+=ID)+ 		public Group getGroup_5() { return cGroup_5; } 		 		//val4+=ID 		public Assignment getVal4Assignment_5_0() { return cVal4Assignment_5_0; } 		 		//ID 		public RuleCall getVal4IDTerminalRuleCall_5_0_0() { return cVal4IDTerminalRuleCall_5_0_0; } 		 		//val5+=ID 		public Assignment getVal5Assignment_5_1() { return cVal5Assignment_5_1; } 		 		//ID 		public RuleCall getVal5IDTerminalRuleCall_5_1_0() { return cVal5IDTerminalRuleCall_5_1_0; } 		 		//&quot;kw3&quot; 		public Keyword getKw3Keyword_6() { return cKw3Keyword_6; } 		 		//(val6+=ID val7+=ID)* 		public Group getGroup_7() { return cGroup_7; } 		 		//val6+=ID 		public Assignment getVal6Assignment_7_0() { return cVal6Assignment_7_0; } 		 		//ID 		public RuleCall getVal6IDTerminalRuleCall_7_0_0() { return cVal6IDTerminalRuleCall_7_0_0; } 		 		//val7+=ID 		public Assignment getVal7Assignment_7_1() { return cVal7Assignment_7_1; } 		 		//ID 		public RuleCall getVal7IDTerminalRuleCall_7_1_0() { return cVal7IDTerminalRuleCall_7_1_0; } 	}</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">12397</td>
    <td align="left">https://github.com/eclipse/xtext-core/blob/e04964e4c2a3e0338c0079bd8333688835e77c31/org.eclipse.xtext.tests/src-gen/org/eclipse/xtext/validation/services/ConcreteSyntaxValidationTestLanguageGrammarAccess.java/#L414-L508</td>
    <td align="right">1</td>
    <td align="right">1909</td>
    <td align="right">12397</td>
  </tr>
  <tr valign="top">
    <td align="right">1912</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;output&quot;: &quot;YES I found bad smells&quot;,         &quot;the bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class SetOrderReferenceDetailsRequest extends DelegateRequest implements Serializable {      @Override     protected SetOrderReferenceDetailsRequest getThis() {         return this;     }      //required parameters     private String amazonOrderReferenceId;     private String orderAmount;     private CurrencyCode orderCurrencyCode;      //optional parameters     private String platformId;     private String sellerNote;     private String sellerOrderId;     private String storeName;     private String supplementaryData;     private String customInformation;     private Boolean requestPaymentAuthorization;      /**      *      * @param amazonOrderReferenceId      *              This value is retrieved from the Amazon Button widget      *              after the buyer has successfully authenticated with Amazon.      *      * @param orderAmount      *              Specifies the total amount of the order represented by this order reference.      */     public SetOrderReferenceDetailsRequest(String amazonOrderReferenceId, String orderAmount) {         this.amazonOrderReferenceId = amazonOrderReferenceId;         this.orderAmount = orderAmount;     }      /**      * Overrides the Client's currency code with specified currency code in SetOrderReferenceDetailsRequest      *      * @param currencyCode      *              A three-digit currency code, formatted based on the ISO 4217 standard.      *      * @return currenyCode      */     public SetOrderReferenceDetailsRequest setOrderCurrencyCode(CurrencyCode currencyCode) {         this.orderCurrencyCode = currencyCode;         return this;     }      /**      * Represents the SellerId of the Solution Provider that developed the platform.      * This value should only be provided by Solution Providers. It should not be      * provided by merchants creating their own custom integration.      *      * @param platformId Represents the SellerId of the Solution Provider that developed the platform.      *                   This value should only be provided by Solution Providers. It should      *                   not be provided by merchants creating their own custom integration.      *      * @return Returns a reference to this object so that methods can be chained together.      */     public SetOrderReferenceDetailsRequest setPlatformId(String platformId) {         this.platformId = platformId;         return this;     }      /**      * Represents a description of the order that is displayed in emails to the buyer.      *      * @param sellerNote Represents a description of the order that is displayed in emails to the buyer.      *      * @return Returns a reference to this object so that methods can be chained together.      */     public SetOrderReferenceDetailsRequest setSellerNote(String sellerNote) {         this.sellerNote = sellerNote;         return this;     }      /**      * The merchant-specified identifier of this order. This is displayed to the      * buyer in their emails and transaction history on the Amazon Pay website.      *      * @param sellerOrderId merchant-specified identifier of the order.      *      * @return the Seller Order ID      */     public SetOrderReferenceDetailsRequest setSellerOrderId(String sellerOrderId) {         this.sellerOrderId = sellerOrderId;         return this;     }      /**      * The identifier of the store from which the order was placed. This overrides      * the default value in Seller Central under Settings &gt; Account Settings. It is      * displayed to the buyer in their emails and transaction history on the      * Amazon Pay website.      *      * @param storeName the identifier of the store from which the order was placed.      *      * @return the Store Name      */     public SetOrderReferenceDetailsRequest setStoreName(String storeName) {         this.storeName = storeName;         return this;     }      /**      * Set the trusted authorization supplementary data.      * Use only as directed by Amazon Pay.      *      * @param supplementaryData Trusted authorization supplementary data (JSON string)      *      * @return Request object      */     public SetOrderReferenceDetailsRequest setSupplementaryData(final String supplementaryData) {         this.supplementaryData = supplementaryData;         return this;     }      /**      * Any additional information that you want to include with this order reference.      *      * @param customInformation Additional information that merchant wants to pass for the order.      *      * @return Custom Information      */     public SetOrderReferenceDetailsRequest setCustomInformation(String customInformation) {         this.customInformation = customInformation;         return this;     }      /**      *      * @return AmazonOrderReferenceId      */     public String getAmazonOrderReferenceId() {         return amazonOrderReferenceId;     }      /**      *      * @return OrderAmount      */     public String getOrderAmount() {         return orderAmount;     }      /**      *      * @return OrderCurrencyCode      */     public CurrencyCode getOrderCurrencyCode() {         return orderCurrencyCode;     }      /**      *      * @return PlatformId      */     public String getPlatformId() {         return platformId;     }      /**      *      * @return SellerNote      */     public String getSellerNote() {         return sellerNote;     }      /**      *      * @return SellerOrderId      */     public String getSellerOrderId() {         return sellerOrderId;     }      /**      *      * @return StoreName      */     public String getStoreName() {         return storeName;     }      /**      * Returns the trusted authorization supplementary data.      *      * @return supplementaryData as a JSON string      */     public String getSupplementaryData() {         return supplementaryData;     }      /**      *      * @return CustomInformation      */     public String getCustomInformation() {         return customInformation;     }      /**      *Check if payment authorization has been requested or not      *      * @return Value of the requestPaymentAuthorization      */     public Boolean getRequestPaymentAuthorization() {         return requestPaymentAuthorization;     }      /**      * Specifies if the merchants want their buyers to go through multi-factor authentication      *      * @param requestPaymentAuthorization flag exposed to merchants using which merchants      *                                    can enforce their buyers to through multi-factor authentication      *      * @return Value of the requestPaymentAuthorization      */     public SetOrderReferenceDetailsRequest setRequestPaymentAuthorization(Boolean requestPaymentAuthorization) {         this.requestPaymentAuthorization = requestPaymentAuthorization;         return this;     }      /**      * Returns a string representation of this object; useful for testing and      * debugging.      *      * @return A string representation of this object.      *      * @see java.lang.Object#toString()      */     @Override     public String toString() {         return &quot;SetOrderReferenceDetailsRequest{&quot;                 + &quot;amazonOrderReferenceId=&quot; + amazonOrderReferenceId                 + &quot;, orderAmount=&quot; + orderAmount                 + &quot;, orderCurrencyCode=&quot; + orderCurrencyCode                 + &quot;, platformId=&quot; + platformId                 + &quot;, sellerNote=&quot; + sellerNote                 + &quot;, sellerOrderId=&quot; + sellerOrderId                 + &quot;, storeName=&quot; + storeName                 + &quot;, supplementaryData=&quot; + supplementaryData                 + &quot;, customInformation=&quot; + customInformation                 + &quot;, mwsAuthToken=&quot; + getMwsAuthToken() + '}';     }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">12401</td>
    <td align="left">https://github.com/amzn/amazon-pay-sdk-java/blob/5a3547d00c796aab8f0c8ac12e0310f7a5c4678a/src/com/amazon/pay/request/SetOrderReferenceDetailsRequest.java/#L25-L272</td>
    <td align="right">1</td>
    <td align="right">1912</td>
    <td align="right">12401</td>
  </tr>
  <tr valign="top">
    <td align="right">1928</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Long Method&quot;, &quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    boolean increaseConnectionWindow(int amount) {         List&gt; candidates = null;         controllerLock.lock();         try {             int size = connectionWindowSize;             size += amount;             if (size &lt; 0)                 return false;             connectionWindowSize = size;             if (debug.on())                 debug.log(&quot;Connection window size is now %d (amount added %d)&quot;,                           size, amount);              // Notify waiting streams, until the new increased window size is             // effectively exhausted.             Iterator,Integer&gt;&gt;&gt; iter =                     pending.entrySet().iterator();              while (iter.hasNext() &amp;&amp; size &gt; 0) {                 Map.Entry,Integer&gt;&gt; item = iter.next();                 Integer streamSize = streams.get(item.getKey());                 if (streamSize == null) {                     iter.remove();                 } else {                     Map.Entry,Integer&gt; e = item.getValue();                     int requestedAmount = e.getValue();                     // only wakes up the pending streams for which there is                     // at least 1 byte of space in both windows                     int minAmount = 1;                     if (size &gt;= minAmount &amp;&amp; streamSize &gt;= minAmount) {                         size -= Math.min(streamSize, requestedAmount);                         iter.remove();                         if (candidates == null)                             candidates = new ArrayList&lt;&gt;();                         candidates.add(e.getKey());                     }                 }             }         } finally {             controllerLock.unlock();         }         if (candidates != null) {             candidates.forEach(Stream::signalWindowUpdate);         }         return true;     }</td>
    <td align="left">long method</td>
    <td align="left">Long Method, Blob</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;Blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12445</td>
    <td align="left">https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/java.net.http/share/classes/jdk/internal/net/http/WindowController.java/#L181-L226</td>
    <td align="right">1</td>
    <td align="right">1928</td>
    <td align="right">12445</td>
  </tr>
  <tr valign="top">
    <td align="right">1950</td>
    <td align="left">&nbsp;{ &quot;message&quot;: &quot;YES, I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement public class Book {      private int id;     private String name;      public Book() {}      public Book(int bookId, String name) {         this.id = bookId;         this.name = name;     }      public int getId() {         return id;     }      public void setId(int id) {         this.id = id;     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">12530</td>
    <td align="left">https://github.com/apache/tomee/blob/d21933b313aff812fe5188b57bf572a9ad649148/examples/mp-rest-client/src/main/java/org/superbiz/rest/Book.java/#L22-L50</td>
    <td align="right">1</td>
    <td align="right">1950</td>
    <td align="right">12530</td>
  </tr>
  <tr valign="top">
    <td align="right">1957</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Blob&quot;,       &quot;Feature Envy&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  private void validateArrayStep(String arrStep)     throws QueryException   {     boolean wildAllowed  = true;    // * is allowed initially     boolean digitAllowed = true;    // Digit is allowed as next char     boolean commaAllowed = false;   // Comma is allowed as next char      boolean afterDigit    = false;  // Last non-space was a digit     boolean toAllowed     = false;  // Any space after digit allows &quot;to&quot;     boolean afterTo       = false;  // After &quot;to&quot; expecting range end     boolean toInProgress  = false;  // Prior char was 't' in &quot;to&quot;     boolean spaceRequired = false;  // A whitespace is required (after &quot;to&quot;)     boolean digitRequired = false;  // Digit required after comma or &quot;to&quot;      for (int i = 1; i &lt; arrStep.length() - 1; ++i)     {       char currentChar = arrStep.charAt(i);        if (currentChar == '*')       {         if (!wildAllowed)           throwArrayException(arrStep);          wildAllowed  = false;  // We've seen the only allowed wildcard         digitAllowed = false;  // Only whitespace is allowed afterward       }       else if (currentChar == ',')       {         if (!commaAllowed)           throwArrayException(arrStep);          commaAllowed  = false;         toAllowed     = false;         afterDigit    = false;         afterTo       = false;         digitRequired = true;  // Next non-space must be a digit       }       else if (&quot;0123456789&quot;.indexOf(currentChar) &gt;= 0)       {         if (!digitAllowed)           throwArrayException(arrStep);          wildAllowed   = false; // Wildcard no longer allowed         commaAllowed  = true;         afterDigit    = true;         digitRequired = false;       }       else if (&quot; \t\n\r&quot;.indexOf(currentChar) &gt;= 0)       {         // Whitespace not allowed when parsing &quot;to&quot;         if (toInProgress)           throwArrayException(arrStep);          if (afterDigit)         {           // Last non-space was a digit - next non-space is &quot;to&quot; or comma           digitAllowed = false;           toAllowed    = !afterTo;           commaAllowed = true;         }         else if (spaceRequired)         {           // This is the whitespace required after &quot;to&quot;           digitAllowed  = true;           spaceRequired = false;           digitRequired = true;  // At least one digit must follow         }       }       else if (currentChar == 't')       {         if (!toAllowed)           throwArrayException(arrStep);          toInProgress = true;  // Next char must be the 'o' in &quot;to&quot;         commaAllowed = false;         afterDigit   = false;       }       else if (currentChar == 'o')       {         if (!toInProgress)           throwArrayException(arrStep);          toInProgress  = false;         toAllowed     = false;         afterTo       = true;         spaceRequired = true;  // &quot;to&quot; must be followed by whitespace       }       else       {         // Invalid character         throwArrayException(arrStep);       }     }      // Empty array or only whitespace found     if (wildAllowed)       throwArrayException(arrStep);      // Incomplete &quot;to&quot; or comma sequence at end of subscript     if (toInProgress || spaceRequired || digitRequired)       throwArrayException(arrStep);   }</td>
    <td align="left">long method</td>
    <td align="left">blob, feature envy, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  feature envy</td>
    <td align="left">long method</td>
    <td align="right">0</td>
    <td align="right">12568</td>
    <td align="left">https://github.com/oracle/soda-for-java/blob/352634e26b5a0d9d529d5436f7a4c8e21ed1dbf0/src/oracle/json/parser/PathParser.java/#L138-L239</td>
    <td align="right">1</td>
    <td align="right">1957</td>
    <td align="right">12568</td>
  </tr>
  <tr valign="top">
    <td align="right">1963</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: {             &quot;1. Long Method&quot;: {},             &quot;2. Blob&quot;: {}         }     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public AsyncContextEvent(Context context,AsyncContextState asyncContext, HttpChannelState state, Request baseRequest, ServletRequest request, ServletResponse response)     {         super(null,request,response,null);         _context=context;         _asyncContext=asyncContext;         _state=state;          // If we haven't been async dispatched before         if (baseRequest.getAttribute(AsyncContext.ASYNC_REQUEST_URI)==null)         {             // We are setting these attributes during startAsync, when the spec implies that             // they are only available after a call to AsyncContext.dispatch(...);              // have we been forwarded before?             String uri=(String)baseRequest.getAttribute(RequestDispatcher.FORWARD_REQUEST_URI);             if (uri!=null)             {                 baseRequest.setAttribute(AsyncContext.ASYNC_REQUEST_URI,uri);                 baseRequest.setAttribute(AsyncContext.ASYNC_CONTEXT_PATH,baseRequest.getAttribute(RequestDispatcher.FORWARD_CONTEXT_PATH));                 baseRequest.setAttribute(AsyncContext.ASYNC_SERVLET_PATH,baseRequest.getAttribute(RequestDispatcher.FORWARD_SERVLET_PATH));                 baseRequest.setAttribute(AsyncContext.ASYNC_PATH_INFO,baseRequest.getAttribute(RequestDispatcher.FORWARD_PATH_INFO));                 baseRequest.setAttribute(AsyncContext.ASYNC_QUERY_STRING,baseRequest.getAttribute(RequestDispatcher.FORWARD_QUERY_STRING));             }             else             {                 baseRequest.setAttribute(AsyncContext.ASYNC_REQUEST_URI,baseRequest.getRequestURI());                 baseRequest.setAttribute(AsyncContext.ASYNC_CONTEXT_PATH,baseRequest.getContextPath());                 baseRequest.setAttribute(AsyncContext.ASYNC_SERVLET_PATH,baseRequest.getServletPath());                 baseRequest.setAttribute(AsyncContext.ASYNC_PATH_INFO,baseRequest.getPathInfo());                 baseRequest.setAttribute(AsyncContext.ASYNC_QUERY_STRING,baseRequest.getQueryString());             }         }     }</td>
    <td align="left">feature envy</td>
    <td align="left">1. long method: , 2. blob: </td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. long method: ,  2. blob: </td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">12587</td>
    <td align="left">https://github.com/eclipse/jetty.project/blob/65528f76c5ef6ddca11385f9721c8f0bc5f2eed7/jetty-server/src/main/java/org/eclipse/jetty/server/AsyncContextEvent.java/#L42-L74</td>
    <td align="right">1</td>
    <td align="right">1963</td>
    <td align="right">12587</td>
  </tr>
  <tr valign="top">
    <td align="right">2008</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;1. Long Method&quot;,       &quot;2. Blob&quot;     ]   }   </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement(name = &quot;realm&quot;) @XmlType public class RealmTO implements EntityTO, TemplatableTO {      private static final long serialVersionUID = 516330662956254391L;      private String key;      private String name;      private String parent;      private String fullPath;      private String accountPolicy;      private String passwordPolicy;      private final List actions = new ArrayList&lt;&gt;();      @XmlJavaTypeAdapter(XmlGenericMapAdapter.class)     private final Map templates = new HashMap&lt;&gt;();      private final Set resources = new HashSet&lt;&gt;();      @Override     public String getKey() {         return key;     }      @Override     public void setKey(final String key) {         this.key = key;     }      public String getName() {         return name;     }      public void setName(final String name) {         this.name = name;     }      public String getParent() {         return parent;     }      public void setParent(final String parent) {         this.parent = parent;     }      public String getFullPath() {         return fullPath;     }      @PathParam(&quot;fullPath&quot;)     public void setFullPath(final String fullPath) {         this.fullPath = fullPath;     }      public String getAccountPolicy() {         return accountPolicy;     }      public void setAccountPolicy(final String accountPolicy) {         this.accountPolicy = accountPolicy;     }      public String getPasswordPolicy() {         return passwordPolicy;     }      public void setPasswordPolicy(final String passwordPolicy) {         this.passwordPolicy = passwordPolicy;     }      @XmlElementWrapper(name = &quot;actions&quot;)     @XmlElement(name = &quot;action&quot;)     @JsonProperty(&quot;actions&quot;)     public List getActions() {         return actions;     }      @JsonProperty     @Override     public Map getTemplates() {         return templates;     }      @XmlElementWrapper(name = &quot;resources&quot;)     @XmlElement(name = &quot;resource&quot;)     @JsonProperty(&quot;resources&quot;)     public Set getResources() {         return resources;     }  }</td>
    <td align="left">data class</td>
    <td align="left">1. long method, 2. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. long method,  2. blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">12738</td>
    <td align="left">https://github.com/apache/syncope/blob/114c412afbfba24ffb4fbc804e5308a823a16a78/common/idrepo/lib/src/main/java/org/apache/syncope/common/lib/to/RealmTO.java/#L36-L132</td>
    <td align="right">1</td>
    <td align="right">2008</td>
    <td align="right">12738</td>
  </tr>
  <tr valign="top">
    <td align="right">2023</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Long Method&quot;,       &quot;Blob&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
		void cleanup() { 			for (final BundleWire requiredWire : requiredWires.getAllValues()) { 				final ConciergeBundleWiring bw = ((ConciergeBundleWire) requiredWire).providerWiring; 				if (bw != null) { 					bw.inUseSet.remove(revision); 				} 			} 			for (final BundleWire hostWire : providedWires 					.lookup(HostNamespace.HOST_NAMESPACE)) { 				final ConciergeBundleWiring bw = ((ConciergeBundleWire) hostWire).requirerWiring; 				if (bw != null) { 					bw.inUseSet.remove(revision); 				} 			} 		}</td>
    <td align="left">feature envy</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method,  blob</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">12796</td>
    <td align="left">https://github.com/eclipse/concierge/blob/4c73cacebc5ecbdef24d4256ab506359294f7a55/framework/org.eclipse.concierge/src/org/eclipse/concierge/Resources.java/#L626-L640</td>
    <td align="right">1</td>
    <td align="right">2023</td>
    <td align="right">12796</td>
  </tr>
  <tr valign="top">
    <td align="right">2038</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Table(name = &quot;clusters&quot;) @NamedQueries({     @NamedQuery(name = &quot;clusterByName&quot;, query =         &quot;SELECT cluster &quot; +             &quot;FROM ClusterEntity cluster &quot; +             &quot;WHERE cluster.clusterName=:clusterName&quot;),     @NamedQuery(name = &quot;allClusters&quot;, query =         &quot;SELECT clusters &quot; +             &quot;FROM ClusterEntity clusters&quot;),     @NamedQuery(name = &quot;clusterByResourceId&quot;, query =         &quot;SELECT cluster &quot; +             &quot;FROM ClusterEntity cluster &quot; +             &quot;WHERE cluster.resource.id=:resourceId&quot;) }) @Entity @TableGenerator(name = &quot;cluster_id_generator&quot;,     table = &quot;ambari_sequences&quot;, pkColumnName = &quot;sequence_name&quot;, valueColumnName = &quot;sequence_value&quot;     , pkColumnValue = &quot;cluster_id_seq&quot;     , initialValue = 1 ) public class ClusterEntity {    @Id   @Column(name = &quot;cluster_id&quot;, nullable = false, insertable = true, updatable = true)   @GeneratedValue(strategy = GenerationType.TABLE, generator = &quot;cluster_id_generator&quot;)   private Long clusterId;    @Basic   @Column(name = &quot;cluster_name&quot;, nullable = false, insertable = true,       updatable = true, unique = true, length = 100)   private String clusterName;    @Basic   @Enumerated(value = EnumType.STRING)   @Column(name = &quot;provisioning_state&quot;, insertable = true, updatable = true)   private State provisioningState = State.INIT;    @Basic   @Enumerated(value = EnumType.STRING)   @Column(name = &quot;security_type&quot;, nullable = false, insertable = true, updatable = true)   private SecurityType securityType = SecurityType.NONE;    @Basic   @Column(name = &quot;desired_cluster_state&quot;, insertable = true, updatable = true)   private String desiredClusterState = &quot;&quot;;    @Basic   @Column(name = &quot;cluster_info&quot;, insertable = true, updatable = true)   private String clusterInfo = &quot;&quot;;    /**    * Unidirectional one-to-one association to {@link StackEntity}    */   @OneToOne   @JoinColumn(name = &quot;desired_stack_id&quot;, unique = false, nullable = false, insertable = true, updatable = true)   private StackEntity desiredStack;    @OneToMany(mappedBy = &quot;clusterEntity&quot;)   private Collection clusterServiceEntities;    @OneToOne(mappedBy = &quot;clusterEntity&quot;, cascade = CascadeType.REMOVE)   private ClusterStateEntity clusterStateEntity;    @ManyToMany(mappedBy = &quot;clusterEntities&quot;)   private Collection hostEntities;    @OneToMany(mappedBy = &quot;clusterEntity&quot;, cascade = CascadeType.ALL)   private Collection configEntities;    @OneToMany(mappedBy = &quot;clusterEntity&quot;, cascade = CascadeType.ALL)   private Collection configGroupEntities;    @OneToMany(mappedBy = &quot;clusterEntity&quot;, cascade = CascadeType.ALL)   private Collection requestScheduleEntities;    @OneToMany(mappedBy = &quot;clusterEntity&quot;, cascade = CascadeType.REMOVE)   private Collection serviceConfigEntities;    @OneToMany(mappedBy = &quot;clusterEntity&quot;, cascade = CascadeType.REMOVE, fetch = FetchType.LAZY)   private Collection alertDefinitionEntities;    @OneToMany(mappedBy = &quot;clusterEntity&quot;, cascade = CascadeType.REMOVE, fetch = FetchType.LAZY)   private Collection widgetEntities;    @OneToMany(mappedBy = &quot;clusterEntity&quot;, cascade = CascadeType.REMOVE, fetch = FetchType.LAZY)   private Collection widgetLayoutEntities;    @OneToOne(cascade = CascadeType.ALL)   @JoinColumns({       @JoinColumn(name = &quot;resource_id&quot;, referencedColumnName = &quot;resource_id&quot;, nullable = false)   })   private ResourceEntity resource;    @Basic   @Column(name = &quot;upgrade_id&quot;, nullable = true, insertable = false, updatable = false)   private Long upgradeId;    /**    * {@code null} when there is no upgrade/downgrade in progress.    */   @OneToOne(cascade = CascadeType.REMOVE)   @JoinColumn(       name = &quot;upgrade_id&quot;,       referencedColumnName = &quot;upgrade_id&quot;,       nullable = true,       insertable = false,       updatable = true)   private UpgradeEntity upgradeEntity = null;    public Long getClusterId() {     return clusterId;   }    public void setClusterId(Long clusterId) {     this.clusterId = clusterId;   }    public String getClusterName() {     return clusterName;   }    public void setClusterName(String clusterName) {     this.clusterName = clusterName;   }    public String getDesiredClusterState() {     return defaultString(desiredClusterState);   }    public void setDesiredClusterState(String desiredClusterState) {     this.desiredClusterState = desiredClusterState;   }    public String getClusterInfo() {     return defaultString(clusterInfo);   }    public void setClusterInfo(String clusterInfo) {     this.clusterInfo = clusterInfo;   }    public StackEntity getDesiredStack() {     return desiredStack;   }    public void setDesiredStack(StackEntity desiredStack) {     this.desiredStack = desiredStack;   }    /**    * Gets whether the cluster is still initializing or has finished with its    * deployment requests.    *    * @return either {@link State#INIT} or {@link State#INSTALLED},    * never {@code null}.    */   public State getProvisioningState(){     return provisioningState;   }    /**    * Sets whether the cluster is still initializing or has finished with its    * deployment requests.    *    * @param provisioningState either {@link State#INIT} or    * {@link State#INSTALLED}, never {@code null}.    */   public void setProvisioningState(State provisioningState){     this.provisioningState = provisioningState;   }    /**    * Gets this ClusterEntity's security type.    *    * @return the current SecurityType    */   public SecurityType getSecurityType() {     return securityType;   }    /**    * Set's this ClusterEntity's security type    *    * @param securityType the new SecurityType    */   public void setSecurityType(SecurityType securityType) {     this.securityType = securityType;   }    @Override   public boolean equals(Object o) {     if (this == o) {       return true;     }     if (o == null || getClass() != o.getClass()) {       return false;     }      ClusterEntity that = (ClusterEntity) o;      if (!clusterId.equals(that.clusterId)) {       return false;     }     if (!clusterName.equals(that.clusterName)) {       return false;     }      return true;   }    @Override   public int hashCode() {     int result = null == clusterId ? 0 : clusterId.hashCode();     result = 31 * result + clusterName.hashCode();     return result;   }    public Collection getClusterServiceEntities() {     return clusterServiceEntities;   }    public void setClusterServiceEntities(Collection clusterServiceEntities) {     this.clusterServiceEntities = clusterServiceEntities;   }    public ClusterStateEntity getClusterStateEntity() {     return clusterStateEntity;   }    public void setClusterStateEntity(ClusterStateEntity clusterStateEntity) {     this.clusterStateEntity = clusterStateEntity;   }    public Collection getHostEntities() {     return hostEntities;   }    public void setHostEntities(Collection hostEntities) {     this.hostEntities = hostEntities;   }    public Collection getClusterConfigEntities() {     return configEntities;   }    public void setClusterConfigEntities(Collection entities) {     configEntities = entities;   }    public Collection getConfigGroupEntities() {     return configGroupEntities;   }    public void setConfigGroupEntities(Collection configGroupEntities) {     this.configGroupEntities = configGroupEntities;   }    public Collection getRequestScheduleEntities() {     return requestScheduleEntities;   }    public void setRequestScheduleEntities(Collection requestScheduleEntities) {     this.requestScheduleEntities = requestScheduleEntities;   }    public Collection getServiceConfigEntities() {     return serviceConfigEntities;   }    public void setServiceConfigEntities(Collection serviceConfigEntities) {     this.serviceConfigEntities = serviceConfigEntities;   }    public Collection getAlertDefinitionEntities() {     return alertDefinitionEntities;   }    /**    * Get the admin resource entity.    *    * @return the resource entity    */   public ResourceEntity getResource() {     return resource;   }    /**    * Set the admin resource entity.    *    * @param resource  the resource entity    */   public void setResource(ResourceEntity resource) {     this.resource = resource;   }    public UpgradeEntity getUpgradeEntity() {     return upgradeEntity;   }    public void setUpgradeEntity(UpgradeEntity upgradeEntity) {     this.upgradeEntity = upgradeEntity;   } }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">12843</td>
    <td align="left">https://github.com/apache/ambari/blob/2bc4779a1e6aabe638101fc8b0e28cd1963d6b13/ambari-server/src/main/java/org/apache/ambari/server/orm/entities/ClusterEntity.java/#L48-L350</td>
    <td align="right">1</td>
    <td align="right">2038</td>
    <td align="right">12843</td>
  </tr>
  <tr valign="top">
    <td align="right">2040</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Long Method&quot;,       &quot;Blob&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @Override     public boolean isValidSyntax( Object value )     {         String strValue;          if ( value == null )         {             if ( LOG.isDebugEnabled() )             {                 LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, &quot;null&quot; ) );             }                          return false;         }          if ( value instanceof String )         {             strValue = ( String ) value;         }         else if ( value instanceof byte[] )         {             strValue = Strings.utf8ToString( ( byte[] ) value );         }         else         {             strValue = value.toString();         }          // We must have at least '(cp)', '(xr)' or '(ca)'         if ( strValue.length() &lt; 4 )         {             if ( LOG.isDebugEnabled() )             {                 LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, value ) );             }                          return false;         }          // Check the opening and closing parenthesis         if ( ( strValue.charAt( 0 ) != '(' )             || ( strValue.charAt( strValue.length() - 1 ) != ')' ) )         {             if ( LOG.isDebugEnabled() )             {                 LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, value ) );             }                          return false;         }          Set keywords = new HashSet&lt;&gt;();         int len = strValue.length() - 1;         boolean needKeyword = true;          //          for ( int i = 1; i &lt; len; /* */)         {             // Skip spaces             while ( ( i &lt; len ) &amp;&amp; ( strValue.charAt( i ) == ' ' ) )             {                 i++;             }              int pos = i;              // Search for a keyword             while ( ( i &lt; len ) &amp;&amp; Chars.isAlphaASCII( strValue, pos ) )             {                 pos++;             }              if ( pos == i )             {                 // No keyword : error                 if ( LOG.isDebugEnabled() )                 {                     LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, value ) );                 }                                  return false;             }              String keyword = strValue.substring( i, pos );             i = pos;              if ( !DSE_BITS.contains( keyword ) )             {                 // Unknown keyword                 if ( LOG.isDebugEnabled() )                 {                     LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, value ) );                 }                                  return false;             }              // Check that the keyword has not been met             if ( keywords.contains( keyword ) )             {                 if ( LOG.isDebugEnabled() )                 {                     LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, value ) );                 }                                  return false;             }              keywords.add( keyword );             needKeyword = false;              // Skip spaces             while ( ( i &lt; len ) &amp;&amp; ( strValue.charAt( i ) == ' ' ) )             {                 i++;             }              // Do we have another keyword ?             if ( ( i &lt; len ) &amp;&amp; ( strValue.charAt( i ) == '$' ) )             {                 // yes                 i++;                 needKeyword = true;             }         }          // We are done         if ( LOG.isDebugEnabled() )         {             if ( needKeyword )             {                 LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, value ) );             }             else             {                 LOG.debug( I18n.msg( I18n.MSG_13701_SYNTAX_VALID, value ) );             }         }          return !needKeyword;     }</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12850</td>
    <td align="left">https://github.com/apache/directory-ldap-api/blob/5b93e102556ad2191b5d30411708410d1b1a9d71/ldap/model/src/main/java/org/apache/directory/api/ldap/model/schema/syntaxCheckers/DseTypeSyntaxChecker.java/#L133-L273</td>
    <td align="right">1</td>
    <td align="right">2040</td>
    <td align="right">12850</td>
  </tr>
  <tr valign="top">
    <td align="right">2041</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES, I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
        private static class GridMBeanServerData {             /** Set of grid names for selected MBeanServer. */             private Collection igniteInstanceNames = new HashSet&lt;&gt;();              /** */             private ObjectName mbean;              /** Count of grid instances. */             private int cnt;              /**              * Create data container.              *              * @param mbean Object name of MBean.              */             GridMBeanServerData(ObjectName mbean) {                 assert mbean != null;                  this.mbean = mbean;             }              /**              * Add Ignite instance name.              *              * @param igniteInstanceName Ignite instance name.              */             public void addIgniteInstance(String igniteInstanceName) {                 igniteInstanceNames.add(igniteInstanceName);             }              /**              * Remove Ignite instance name.              *              * @param igniteInstanceName Ignite instance name.              */             public void removeIgniteInstance(String igniteInstanceName) {                 igniteInstanceNames.remove(igniteInstanceName);             }              /**              * Returns {@code true} if data contains the specified              * Ignite instance name.              *              * @param igniteInstanceName Ignite instance name.              * @return {@code true} if data contains the specified Ignite instance name.              */             public boolean containsIgniteInstance(String igniteInstanceName) {                 return igniteInstanceNames.contains(igniteInstanceName);             }              /**              * Gets name used in MBean server.              *              * @return Object name of MBean.              */             public ObjectName getMbean() {                 return mbean;             }              /**              * Gets number of grid instances working with MBeanServer.              *              * @return Number of grid instances.              */             public int getCounter() {                 return cnt;             }              /**              * Sets number of grid instances working with MBeanServer.              *              * @param cnt Number of grid instances.              */             public void setCounter(int cnt) {                 this.cnt = cnt;             }         }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">12853</td>
    <td align="left">https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/core/src/main/java/org/apache/ignite/internal/IgnitionEx.java/#L2796-L2872</td>
    <td align="right">1</td>
    <td align="right">2041</td>
    <td align="right">12853</td>
  </tr>
  <tr valign="top">
    <td align="right">2044</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DebugInfoDecoder {     /** encoded debug info */     private final byte[] encoded;      /** positions decoded */     private final ArrayList positions;      /** locals decoded */     private final ArrayList locals;      /** size of code block in code units */     private final int codesize;      /** indexed by register, the last local variable live in a reg */     private final LocalEntry[] lastEntryForReg;      /** method descriptor of method this debug info is for */     private final Prototype desc;      /** true if method is static */     private final boolean isStatic;      /** dex file this debug info will be stored in */     private final DexFile file;      /**      * register size, in register units, of the register space      * used by this method      */     private final int regSize;      /** current decoding state: line number */     private int line = 1;      /** current decoding state: bytecode address */     private int address = 0;      /** string index of the string &quot;this&quot; */     private final int thisStringIdx;      /**      * Constructs an instance.      *      * @param encoded encoded debug info      * @param codesize size of code block in code units      * @param regSize register size, in register units, of the register space      * used by this method      * @param isStatic true if method is static      * @param ref method descriptor of method this debug info is for      * @param file dex file this debug info will be stored in      */     DebugInfoDecoder(byte[] encoded, int codesize, int regSize,             boolean isStatic, CstMethodRef ref, DexFile file) {         if (encoded == null) {             throw new NullPointerException(&quot;encoded == null&quot;);         }          this.encoded = encoded;         this.isStatic = isStatic;         this.desc = ref.getPrototype();         this.file = file;         this.regSize = regSize;          positions = new ArrayList();         locals = new ArrayList();         this.codesize = codesize;         lastEntryForReg = new LocalEntry[regSize];          int idx = -1;          try {             idx = file.getStringIds().indexOf(new CstString(&quot;this&quot;));         } catch (IllegalArgumentException ex) {             /*              * Silently tolerate not finding &quot;this&quot;. It just means that              * no method has local variable info that looks like              * a standard instance method.              */         }          thisStringIdx = idx;     }      /**      * An entry in the resulting postions table      */     static private class PositionEntry {         /** bytecode address */         public int address;          /** line number */         public int line;          public PositionEntry(int address, int line) {             this.address = address;             this.line = line;         }     }      /**      * An entry in the resulting locals table      */     static private class LocalEntry {         /** address of event */         public int address;          /** {@code true} iff it's a local start */         public boolean isStart;          /** register number */         public int reg;          /** index of name in strings table */         public int nameIndex;          /** index of type in types table */         public int typeIndex;          /** index of type signature in strings table */         public int signatureIndex;          public LocalEntry(int address, boolean isStart, int reg, int nameIndex,                 int typeIndex, int signatureIndex) {             this.address        = address;             this.isStart        = isStart;             this.reg            = reg;             this.nameIndex      = nameIndex;             this.typeIndex      = typeIndex;             this.signatureIndex = signatureIndex;         }          public String toString() {             return String.format(&quot;[%x %s v%d %04x %04x %04x]&quot;,                     address, isStart ? &quot;start&quot; : &quot;end&quot;, reg,                     nameIndex, typeIndex, signatureIndex);         }     }      /**      * Gets the decoded positions list.      * Valid after calling {@code decode}.      *      * @return positions list in ascending address order.      */     public List getPositionList() {         return positions;     }      /**      * Gets the decoded locals list, in ascending start-address order.      * Valid after calling {@code decode}.      *      * @return locals list in ascending address order.      */     public List getLocals() {         return locals;     }      /**      * Decodes the debug info sequence.      */     public void decode() {         try {             decode0();         } catch (Exception ex) {             throw ExceptionWithContext.withContext(ex,                     &quot;...while decoding debug info&quot;);         }     }      /**      * Reads a string index. String indicies are offset by 1, and a 0 value      * in the stream (-1 as returned by this method) means &quot;null&quot;      *      * @return index into file's string ids table, -1 means null      * @throws IOException      */     private int readStringIndex(ByteInput bs) throws IOException {         int offsetIndex = Leb128.readUnsignedLeb128(bs);          return offsetIndex - 1;     }      /**      * Gets the register that begins the method's parameter range (including      * the 'this' parameter for non-static methods). The range continues until      * {@code regSize}      *      * @return register as noted above.      */     private int getParamBase() {         return regSize                 - desc.getParameterTypes().getWordCount() - (isStatic? 0 : 1);     }      private void decode0() throws IOException {         ByteInput bs = new ByteArrayByteInput(encoded);          line = Leb128.readUnsignedLeb128(bs);         int szParams = Leb128.readUnsignedLeb128(bs);         StdTypeList params = desc.getParameterTypes();         int curReg = getParamBase();          if (szParams != params.size()) {             throw new RuntimeException(                     &quot;Mismatch between parameters_size and prototype&quot;);         }          if (!isStatic) {             // Start off with implicit 'this' entry             LocalEntry thisEntry =                 new LocalEntry(0, true, curReg, thisStringIdx, 0, 0);             locals.add(thisEntry);             lastEntryForReg[curReg] = thisEntry;             curReg++;         }          for (int i = 0; i &lt; szParams; i++) {             Type paramType = params.getType(i);             LocalEntry le;              int nameIdx = readStringIndex(bs);              if (nameIdx == -1) {                 /*                  * Unnamed parameter; often but not always filled in by an                  * extended start op after the prologue                  */                 le = new LocalEntry(0, true, curReg, -1, 0, 0);             } else {                 // TODO: Final 0 should be idx of paramType.getDescriptor().                 le = new LocalEntry(0, true, curReg, nameIdx, 0, 0);             }              locals.add(le);             lastEntryForReg[curReg] = le;             curReg += paramType.getCategory();         }          for (;;) {             int opcode = bs.readByte() &amp; 0xff;              switch (opcode) {                 case DBG_START_LOCAL: {                     int reg = Leb128.readUnsignedLeb128(bs);                     int nameIdx = readStringIndex(bs);                     int typeIdx = readStringIndex(bs);                     LocalEntry le = new LocalEntry(                             address, true, reg, nameIdx, typeIdx, 0);                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_START_LOCAL_EXTENDED: {                     int reg = Leb128.readUnsignedLeb128(bs);                     int nameIdx = readStringIndex(bs);                     int typeIdx = readStringIndex(bs);                     int sigIdx = readStringIndex(bs);                     LocalEntry le = new LocalEntry(                             address, true, reg, nameIdx, typeIdx, sigIdx);                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_RESTART_LOCAL: {                     int reg = Leb128.readUnsignedLeb128(bs);                     LocalEntry prevle;                     LocalEntry le;                      try {                         prevle = lastEntryForReg[reg];                          if (prevle.isStart) {                             throw new RuntimeException(&quot;nonsensical &quot;                                     + &quot;RESTART_LOCAL on live register v&quot;                                     + reg);                         }                          le = new LocalEntry(address, true, reg,                                 prevle.nameIndex, prevle.typeIndex, 0);                     } catch (NullPointerException ex) {                         throw new RuntimeException(                                 &quot;Encountered RESTART_LOCAL on new v&quot; + reg);                     }                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_END_LOCAL: {                     int reg = Leb128.readUnsignedLeb128(bs);                     LocalEntry prevle;                     LocalEntry le;                      try {                         prevle = lastEntryForReg[reg];                          if (!prevle.isStart) {                             throw new RuntimeException(&quot;nonsensical &quot;                                     + &quot;END_LOCAL on dead register v&quot; + reg);                         }                          le = new LocalEntry(address, false, reg,                                 prevle.nameIndex, prevle.typeIndex,                                 prevle.signatureIndex);                     } catch (NullPointerException ex) {                         throw new RuntimeException(                                 &quot;Encountered END_LOCAL on new v&quot; + reg);                     }                      locals.add(le);                     lastEntryForReg[reg] = le;                 }                 break;                  case DBG_END_SEQUENCE:                     // all done                 return;                  case DBG_ADVANCE_PC:                     address += Leb128.readUnsignedLeb128(bs);                 break;                  case DBG_ADVANCE_LINE:                     line += Leb128.readSignedLeb128(bs);                 break;                  case DBG_SET_PROLOGUE_END:                     //TODO do something with this.                 break;                  case DBG_SET_EPILOGUE_BEGIN:                     //TODO do something with this.                 break;                  case DBG_SET_FILE:                     //TODO do something with this.                 break;                  default:                     if (opcode &lt; DBG_FIRST_SPECIAL) {                         throw new RuntimeException(                                 &quot;Invalid extended opcode encountered &quot;                                         + opcode);                     }                      int adjopcode = opcode - DBG_FIRST_SPECIAL;                      address += adjopcode / DBG_LINE_RANGE;                     line += DBG_LINE_BASE + (adjopcode % DBG_LINE_RANGE);                      positions.add(new PositionEntry(address, line));                 break;              }         }     }      /**      * Validates an encoded debug info stream against data used to encode it,      * throwing an exception if they do not match. Used to validate the      * encoder.      *      * @param info encoded debug info      * @param file {@code non-null;} file to refer to during decoding      * @param ref {@code non-null;} method whose info is being decoded      * @param code {@code non-null;} original code object that was encoded      * @param isStatic whether the method is static      */     public static void validateEncode(byte[] info, DexFile file,             CstMethodRef ref, DalvCode code, boolean isStatic) {         PositionList pl = code.getPositions();         LocalList ll = code.getLocals();         DalvInsnList insns = code.getInsns();         int codeSize = insns.codeSize();         int countRegisters = insns.getRegistersSize();          try {             validateEncode0(info, codeSize, countRegisters,                     isStatic, ref, file, pl, ll);         } catch (RuntimeException ex) {             System.err.println(&quot;instructions:&quot;);             insns.debugPrint(System.err, &quot;  &quot;, true);             System.err.println(&quot;local list:&quot;);             ll.debugPrint(System.err, &quot;  &quot;);             throw ExceptionWithContext.withContext(ex,                     &quot;while processing &quot; + ref.toHuman());         }     }      private static void validateEncode0(byte[] info, int codeSize,             int countRegisters, boolean isStatic, CstMethodRef ref,             DexFile file, PositionList pl, LocalList ll) {         DebugInfoDecoder decoder                 = new DebugInfoDecoder(info, codeSize, countRegisters,                     isStatic, ref, file);          decoder.decode();          /*          * Go through the decoded position entries, matching up          * with original entries.          */          List decodedEntries = decoder.getPositionList();          if (decodedEntries.size() != pl.size()) {             throw new RuntimeException(                     &quot;Decoded positions table not same size was &quot;                     + decodedEntries.size() + &quot; expected &quot; + pl.size());         }          for (PositionEntry entry : decodedEntries) {             boolean found = false;             for (int i = pl.size() - 1; i &gt;= 0; i--) {                 PositionList.Entry ple = pl.get(i);                  if (entry.line == ple.getPosition().getLine()                         &amp;&amp; entry.address == ple.getAddress()) {                     found = true;                     break;                 }             }              if (!found) {                 throw new RuntimeException (&quot;Could not match position entry: &quot;                         + entry.address + &quot;, &quot; + entry.line);             }         }          /*          * Go through the original local list, in order, matching up          * with decoded entries.          */          List decodedLocals = decoder.getLocals();         int thisStringIdx = decoder.thisStringIdx;         int decodedSz = decodedLocals.size();         int paramBase = decoder.getParamBase();          /*          * Preflight to fill in any parameters that were skipped in          * the prologue (including an implied &quot;this&quot;) but then          * identified by full signature.          */         for (int i = 0; i &lt; decodedSz; i++) {             LocalEntry entry = decodedLocals.get(i);             int idx = entry.nameIndex;              if ((idx &lt; 0) || (idx == thisStringIdx)) {                 for (int j = i + 1; j &lt; decodedSz; j++) {                     LocalEntry e2 = decodedLocals.get(j);                     if (e2.address != 0) {                         break;                     }                     if ((entry.reg == e2.reg) &amp;&amp; e2.isStart) {                         decodedLocals.set(i, e2);                         decodedLocals.remove(j);                         decodedSz--;                         break;                     }                 }             }         }          int origSz = ll.size();         int decodeAt = 0;         boolean problem = false;          for (int i = 0; i &lt; origSz; i++) {             LocalList.Entry origEntry = ll.get(i);              if (origEntry.getDisposition()                     == LocalList.Disposition.END_REPLACED) {                 /*                  * The encoded list doesn't represent replacements, so                  * ignore them for the sake of comparison.                  */                 continue;             }              LocalEntry decodedEntry;              do {                 decodedEntry = decodedLocals.get(decodeAt);                 if (decodedEntry.nameIndex &gt;= 0) {                     break;                 }                 /*                  * A negative name index means this is an anonymous                  * parameter, and we shouldn't expect to see it in the                  * original list. So, skip it.                  */                 decodeAt++;             } while (decodeAt &lt; decodedSz);              int decodedAddress = decodedEntry.address;              if (decodedEntry.reg != origEntry.getRegister()) {                 System.err.println(&quot;local register mismatch at orig &quot; + i +                         &quot; / decoded &quot; + decodeAt);                 problem = true;                 break;             }              if (decodedEntry.isStart != origEntry.isStart()) {                 System.err.println(&quot;local start/end mismatch at orig &quot; + i +                         &quot; / decoded &quot; + decodeAt);                 problem = true;                 break;             }              /*              * The secondary check here accounts for the fact that a              * parameter might not be marked as starting at 0 in the              * original list.              */             if ((decodedAddress != origEntry.getAddress())                     &amp;&amp; !((decodedAddress == 0)                             &amp;&amp; (decodedEntry.reg &gt;= paramBase))) {                 System.err.println(&quot;local address mismatch at orig &quot; + i +                         &quot; / decoded &quot; + decodeAt);                 problem = true;                 break;             }              decodeAt++;         }          if (problem) {             System.err.println(&quot;decoded locals:&quot;);             for (LocalEntry e : decodedLocals) {                 System.err.println(&quot;  &quot; + e);             }             throw new RuntimeException(&quot;local table problem&quot;);         }     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12869</td>
    <td align="left">https://github.com/facebook/buck/blob/1bc8d383ea5cb153ca9bf4f2807e6be498648523/third-party/java/dx/src/com/android/dx/dex/file/DebugInfoDecoder.java/#L54-L596</td>
    <td align="right">1</td>
    <td align="right">2044</td>
    <td align="right">12869</td>
  </tr>
  <tr valign="top">
    <td align="right">2059</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Header {     @SerializedName(&quot;typ&quot;)     public String type;     @SerializedName(&quot;alg&quot;)     public String algorithm;     @SerializedName(&quot;cty&quot;)     public String contentType; }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">12962</td>
    <td align="left">https://github.com/vmware/xenon/blob/b6fb48b745985af2efc59b7ee0e5e7d69a289fbc/xenon-common/src/main/java/com/vmware/xenon/common/jwt/Header.java/#L23-L30</td>
    <td align="right">1</td>
    <td align="right">2059</td>
    <td align="right">12962</td>
  </tr>
  <tr valign="top">
    <td align="right">2084</td>
    <td align="left">&nbsp;{&quot;answer&quot;: &quot;YES I found bad smells&quot;,  &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  private static class FieldMetaData {     public final FieldInfo fieldInfo;     public final long numTerms;     public final long sumTotalTermFreq;     public final long sumDocFreq;     public final int docCount;     public final int longsSize;     public final FST dict;      public FieldMetaData(FieldInfo fieldInfo, long numTerms, long sumTotalTermFreq, long sumDocFreq, int docCount, int longsSize, FST fst) {       this.fieldInfo = fieldInfo;       this.numTerms = numTerms;       this.sumTotalTermFreq = sumTotalTermFreq;       this.sumDocFreq = sumDocFreq;       this.docCount = docCount;       this.longsSize = longsSize;       this.dict = fst;     }   }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13082</td>
    <td align="left">https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/lucene/codecs/src/java/org/apache/lucene/codecs/memory/FSTTermsWriter.java/#L229-L247</td>
    <td align="right">1</td>
    <td align="right">2084</td>
    <td align="right">13082</td>
  </tr>
  <tr valign="top">
    <td align="right">2089</td>
    <td align="left">{ &quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [ &quot;1. Blob&quot;, &quot;2. Long Method&quot; ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private void resizeInstructions() {         byte[] b = code.data; // bytecode of the method         int u, v, label; // indexes in b         int i, j; // loop indexes         /*          * 1st step: As explained above, resizing an instruction may require to          * resize another one, which may require to resize yet another one, and          * so on. The first step of the algorithm consists in finding all the          * instructions that need to be resized, without modifying the code.          * This is done by the following &quot;fix point&quot; algorithm:          *           * Parse the code to find the jump instructions whose offset will need          * more than 2 bytes to be stored (the future offset is computed from          * the current offset and from the number of bytes that will be inserted          * or removed between the source and target instructions). For each such          * instruction, adds an entry in (a copy of) the indexes and sizes          * arrays (if this has not already been done in a previous iteration!).          *           * If at least one entry has been added during the previous step, go          * back to the beginning, otherwise stop.          *           * In fact the real algorithm is complicated by the fact that the size          * of TABLESWITCH and LOOKUPSWITCH instructions depends on their          * position in the bytecode (because of padding). In order to ensure the          * convergence of the algorithm, the number of bytes to be added or          * removed from these instructions is over estimated during the previous          * loop, and computed exactly only after the loop is finished (this          * requires another pass to parse the bytecode of the method).          */         int[] allIndexes = new int[0]; // copy of indexes         int[] allSizes = new int[0]; // copy of sizes         boolean[] resize; // instructions to be resized         int newOffset; // future offset of a jump instruction          resize = new boolean[code.length];          // 3 = loop again, 2 = loop ended, 1 = last pass, 0 = done         int state = 3;         do {             if (state == 3) {                 state = 2;             }             u = 0;             while (u &lt; b.length) {                 int opcode = b[u] &amp; 0xFF; // opcode of current instruction                 int insert = 0; // bytes to be added after this instruction                  switch (ClassWriter.TYPE[opcode]) {                 case ClassWriter.NOARG_INSN:                 case ClassWriter.IMPLVAR_INSN:                     u += 1;                     break;                 case ClassWriter.LABEL_INSN:                     if (opcode &gt; 201) {                         // converts temporary opcodes 202 to 217, 218 and                         // 219 to IFEQ ... JSR (inclusive), IFNULL and                         // IFNONNULL                         opcode = opcode &lt; 218 ? opcode - 49 : opcode - 20;                         label = u + readUnsignedShort(b, u + 1);                     } else {                         label = u + readShort(b, u + 1);                     }                     newOffset = getNewOffset(allIndexes, allSizes, u, label);                     if (newOffset &lt; Short.MIN_VALUE                             || newOffset &gt; Short.MAX_VALUE) {                         if (!resize[u]) {                             if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {                                 // two additional bytes will be required to                                 // replace this GOTO or JSR instruction with                                 // a GOTO_W or a JSR_W                                 insert = 2;                             } else {                                 // five additional bytes will be required to                                 // replace this IFxxx  instruction with                                 // IFNOTxxx  GOTO_W , where IFNOTxxx                                 // is the &quot;opposite&quot; opcode of IFxxx (i.e.,                                 // IFNE for IFEQ) and where  designates                                 // the instruction just after the GOTO_W.                                 insert = 5;                             }                             resize[u] = true;                         }                     }                     u += 3;                     break;                 case ClassWriter.LABELW_INSN:                     u += 5;                     break;                 case ClassWriter.TABL_INSN:                     if (state == 1) {                         // true number of bytes to be added (or removed)                         // from this instruction = (future number of padding                         // bytes - current number of padding byte) -                         // previously over estimated variation =                         // = ((3 - newOffset%4) - (3 - u%4)) - u%4                         // = (-newOffset%4 + u%4) - u%4                         // = -(newOffset &amp; 3)                         newOffset = getNewOffset(allIndexes, allSizes, 0, u);                         insert = -(newOffset &amp; 3);                     } else if (!resize[u]) {                         // over estimation of the number of bytes to be                         // added to this instruction = 3 - current number                         // of padding bytes = 3 - (3 - u%4) = u%4 = u &amp; 3                         insert = u &amp; 3;                         resize[u] = true;                     }                     // skips instruction                     u = u + 4 - (u &amp; 3);                     u += 4 * (readInt(b, u + 8) - readInt(b, u + 4) + 1) + 12;                     break;                 case ClassWriter.LOOK_INSN:                     if (state == 1) {                         // like TABL_INSN                         newOffset = getNewOffset(allIndexes, allSizes, 0, u);                         insert = -(newOffset &amp; 3);                     } else if (!resize[u]) {                         // like TABL_INSN                         insert = u &amp; 3;                         resize[u] = true;                     }                     // skips instruction                     u = u + 4 - (u &amp; 3);                     u += 8 * readInt(b, u + 4) + 8;                     break;                 case ClassWriter.WIDE_INSN:                     opcode = b[u + 1] &amp; 0xFF;                     if (opcode == Opcodes.IINC) {                         u += 6;                     } else {                         u += 4;                     }                     break;                 case ClassWriter.VAR_INSN:                 case ClassWriter.SBYTE_INSN:                 case ClassWriter.LDC_INSN:                     u += 2;                     break;                 case ClassWriter.SHORT_INSN:                 case ClassWriter.LDCW_INSN:                 case ClassWriter.FIELDORMETH_INSN:                 case ClassWriter.TYPE_INSN:                 case ClassWriter.IINC_INSN:                     u += 3;                     break;                 case ClassWriter.ITFMETH_INSN:                 case ClassWriter.INDYMETH_INSN:                     u += 5;                     break;                 // case ClassWriter.MANA_INSN:                 default:                     u += 4;                     break;                 }                 if (insert != 0) {                     // adds a new (u, insert) entry in the allIndexes and                     // allSizes arrays                     int[] newIndexes = new int[allIndexes.length + 1];                     int[] newSizes = new int[allSizes.length + 1];                     System.arraycopy(allIndexes, 0, newIndexes, 0,                             allIndexes.length);                     System.arraycopy(allSizes, 0, newSizes, 0, allSizes.length);                     newIndexes[allIndexes.length] = u;                     newSizes[allSizes.length] = insert;                     allIndexes = newIndexes;                     allSizes = newSizes;                     if (insert &gt; 0) {                         state = 3;                     }                 }             }             if (state &lt; 3) {                 --state;             }         } while (state != 0);          // 2nd step:         // copies the bytecode of the method into a new bytevector, updates the         // offsets, and inserts (or removes) bytes as requested.          ByteVector newCode = new ByteVector(code.length);          u = 0;         while (u &lt; code.length) {             int opcode = b[u] &amp; 0xFF;             switch (ClassWriter.TYPE[opcode]) {             case ClassWriter.NOARG_INSN:             case ClassWriter.IMPLVAR_INSN:                 newCode.putByte(opcode);                 u += 1;                 break;             case ClassWriter.LABEL_INSN:                 if (opcode &gt; 201) {                     // changes temporary opcodes 202 to 217 (inclusive), 218                     // and 219 to IFEQ ... JSR (inclusive), IFNULL and                     // IFNONNULL                     opcode = opcode &lt; 218 ? opcode - 49 : opcode - 20;                     label = u + readUnsignedShort(b, u + 1);                 } else {                     label = u + readShort(b, u + 1);                 }                 newOffset = getNewOffset(allIndexes, allSizes, u, label);                 if (resize[u]) {                     // replaces GOTO with GOTO_W, JSR with JSR_W and IFxxx                     //  with IFNOTxxx  GOTO_W , where IFNOTxxx is                     // the &quot;opposite&quot; opcode of IFxxx (i.e., IFNE for IFEQ)                     // and where  designates the instruction just after                     // the GOTO_W.                     if (opcode == Opcodes.GOTO) {                         newCode.putByte(200); // GOTO_W                     } else if (opcode == Opcodes.JSR) {                         newCode.putByte(201); // JSR_W                     } else {                         newCode.putByte(opcode &lt;= 166 ? ((opcode + 1) ^ 1) - 1                                 : opcode ^ 1);                         newCode.putShort(8); // jump offset                         newCode.putByte(200); // GOTO_W                         // newOffset now computed from start of GOTO_W                         newOffset -= 3;                     }                     newCode.putInt(newOffset);                 } else {                     newCode.putByte(opcode);                     newCode.putShort(newOffset);                 }                 u += 3;                 break;             case ClassWriter.LABELW_INSN:                 label = u + readInt(b, u + 1);                 newOffset = getNewOffset(allIndexes, allSizes, u, label);                 newCode.putByte(opcode);                 newCode.putInt(newOffset);                 u += 5;                 break;             case ClassWriter.TABL_INSN:                 // skips 0 to 3 padding bytes                 v = u;                 u = u + 4 - (v &amp; 3);                 // reads and copies instruction                 newCode.putByte(Opcodes.TABLESWITCH);                 newCode.putByteArray(null, 0, (4 - newCode.length % 4) % 4);                 label = v + readInt(b, u);                 u += 4;                 newOffset = getNewOffset(allIndexes, allSizes, v, label);                 newCode.putInt(newOffset);                 j = readInt(b, u);                 u += 4;                 newCode.putInt(j);                 j = readInt(b, u) - j + 1;                 u += 4;                 newCode.putInt(readInt(b, u - 4));                 for (; j &gt; 0; --j) {                     label = v + readInt(b, u);                     u += 4;                     newOffset = getNewOffset(allIndexes, allSizes, v, label);                     newCode.putInt(newOffset);                 }                 break;             case ClassWriter.LOOK_INSN:                 // skips 0 to 3 padding bytes                 v = u;                 u = u + 4 - (v &amp; 3);                 // reads and copies instruction                 newCode.putByte(Opcodes.LOOKUPSWITCH);                 newCode.putByteArray(null, 0, (4 - newCode.length % 4) % 4);                 label = v + readInt(b, u);                 u += 4;                 newOffset = getNewOffset(allIndexes, allSizes, v, label);                 newCode.putInt(newOffset);                 j = readInt(b, u);                 u += 4;                 newCode.putInt(j);                 for (; j &gt; 0; --j) {                     newCode.putInt(readInt(b, u));                     u += 4;                     label = v + readInt(b, u);                     u += 4;                     newOffset = getNewOffset(allIndexes, allSizes, v, label);                     newCode.putInt(newOffset);                 }                 break;             case ClassWriter.WIDE_INSN:                 opcode = b[u + 1] &amp; 0xFF;                 if (opcode == Opcodes.IINC) {                     newCode.putByteArray(b, u, 6);                     u += 6;                 } else {                     newCode.putByteArray(b, u, 4);                     u += 4;                 }                 break;             case ClassWriter.VAR_INSN:             case ClassWriter.SBYTE_INSN:             case ClassWriter.LDC_INSN:                 newCode.putByteArray(b, u, 2);                 u += 2;                 break;             case ClassWriter.SHORT_INSN:             case ClassWriter.LDCW_INSN:             case ClassWriter.FIELDORMETH_INSN:             case ClassWriter.TYPE_INSN:             case ClassWriter.IINC_INSN:                 newCode.putByteArray(b, u, 3);                 u += 3;                 break;             case ClassWriter.ITFMETH_INSN:             case ClassWriter.INDYMETH_INSN:                 newCode.putByteArray(b, u, 5);                 u += 5;                 break;             // case MANA_INSN:             default:                 newCode.putByteArray(b, u, 4);                 u += 4;                 break;             }         }          // recomputes the stack map frames         if (frameCount &gt; 0) {             if (compute == FRAMES) {                 frameCount = 0;                 stackMap = null;                 previousFrame = null;                 frame = null;                 Frame f = new Frame();                 f.owner = labels;                 Type[] args = Type.getArgumentTypes(descriptor);                 f.initInputFrame(cw, access, args, maxLocals);                 visitFrame(f);                 Label l = labels;                 while (l != null) {                     /*                      * here we need the original label position. getNewOffset                      * must therefore never have been called for this label.                      */                     u = l.position - 3;                     if ((l.status &amp; Label.STORE) != 0 || (u &gt;= 0 &amp;&amp; resize[u])) {                         getNewOffset(allIndexes, allSizes, l);                         // TODO update offsets in UNINITIALIZED values                         visitFrame(l.frame);                     }                     l = l.successor;                 }             } else {                 /*                  * Resizing an existing stack map frame table is really hard.                  * Not only the table must be parsed to update the offets, but                  * new frames may be needed for jump instructions that were                  * inserted by this method. And updating the offsets or                  * inserting frames can change the format of the following                  * frames, in case of packed frames. In practice the whole table                  * must be recomputed. For this the frames are marked as                  * potentially invalid. This will cause the whole class to be                  * reread and rewritten with the COMPUTE_FRAMES option (see the                  * ClassWriter.toByteArray method). This is not very efficient                  * but is much easier and requires much less code than any other                  * method I can think of.                  */                 cw.invalidFrames = true;             }         }         // updates the exception handler block labels         Handler h = firstHandler;         while (h != null) {             getNewOffset(allIndexes, allSizes, h.start);             getNewOffset(allIndexes, allSizes, h.end);             getNewOffset(allIndexes, allSizes, h.handler);             h = h.next;         }         // updates the instructions addresses in the         // local var and line number tables         for (i = 0; i &lt; 2; ++i) {             ByteVector bv = i == 0 ? localVar : localVarType;             if (bv != null) {                 b = bv.data;                 u = 0;                 while (u &lt; bv.length) {                     label = readUnsignedShort(b, u);                     newOffset = getNewOffset(allIndexes, allSizes, 0, label);                     writeShort(b, u, newOffset);                     label += readUnsignedShort(b, u + 2);                     newOffset = getNewOffset(allIndexes, allSizes, 0, label)                             - newOffset;                     writeShort(b, u + 2, newOffset);                     u += 10;                 }             }         }         if (lineNumber != null) {             b = lineNumber.data;             u = 0;             while (u &lt; lineNumber.length) {                 writeShort(                         b,                         u,                         getNewOffset(allIndexes, allSizes, 0,                                 readUnsignedShort(b, u)));                 u += 4;             }         }         // updates the labels of the other attributes         Attribute attr = cattrs;         while (attr != null) {             Label[] labels = attr.getLabels();             if (labels != null) {                 for (i = labels.length - 1; i &gt;= 0; --i) {                     getNewOffset(allIndexes, allSizes, labels[i]);                 }             }             attr = attr.next;         }          // replaces old bytecodes with new ones         code = newCode;     }</td>
    <td align="left">long method</td>
    <td align="left">1. blob, 2. long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13117</td>
    <td align="left">https://github.com/apache/tajo/blob/fb326195083959014c82c10187cb46de91ece33f/tajo-thirdparty/asm/src/main/java/org/apache/tajo/org/objectweb/asm/MethodWriter.java/#L2145-L2559</td>
    <td align="right">1</td>
    <td align="right">2089</td>
    <td align="right">13117</td>
  </tr>
  <tr valign="top">
    <td align="right">2122</td>
    <td align="left">{ 	&quot;message&quot;: &quot;YES I found bad smells&quot;, 	&quot;detected_bad_smells&quot;: [ 		&quot;Blob&quot;, 		&quot;Data Class&quot;, 		&quot;Long Method&quot; 	] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LuceneIndexForPartitionedRegion extends LuceneIndexImpl {   protected Region fileAndChunkRegion;   protected final FileSystemStats fileSystemStats;    public static final String FILES_REGION_SUFFIX = &quot;.files&quot;;    private final ExecutorService waitingThreadPoolFromDM;    public LuceneIndexForPartitionedRegion(String indexName, String regionPath, InternalCache cache) {     super(indexName, regionPath, cache);     this.waitingThreadPoolFromDM = cache.getDistributionManager().getWaitingThreadPool();      final String statsName = indexName + &quot;-&quot; + regionPath;     this.fileSystemStats = new FileSystemStats(cache.getDistributedSystem(), statsName);   }    @Override   protected RepositoryManager createRepositoryManager(LuceneSerializer luceneSerializer) {     LuceneSerializer mapper = luceneSerializer;     if (mapper == null) {       mapper = new HeterogeneousLuceneSerializer();     }     PartitionedRepositoryManager partitionedRepositoryManager =         new PartitionedRepositoryManager(this, mapper, this.waitingThreadPoolFromDM);     return partitionedRepositoryManager;   }    @Override   public boolean isIndexingInProgress() {     PartitionedRegion userRegion = (PartitionedRegion) cache.getRegion(this.getRegionPath());     Set fileRegionPrimaryBucketIds =         this.getFileAndChunkRegion().getDataStore().getAllLocalPrimaryBucketIds();     for (Integer bucketId : fileRegionPrimaryBucketIds) {       BucketRegion userBucket = userRegion.getDataStore().getLocalBucketById(bucketId);       if (!userBucket.isEmpty() &amp;&amp; !this.isIndexAvailable(bucketId)) {         return true;       }     }     return false;   }    @Override   protected void createLuceneListenersAndFileChunkRegions(       PartitionedRepositoryManager partitionedRepositoryManager) {     partitionedRepositoryManager.setUserRegionForRepositoryManager((PartitionedRegion) dataRegion);     RegionShortcut regionShortCut;     final boolean withPersistence = withPersistence();     RegionAttributes regionAttributes = dataRegion.getAttributes();     final boolean withStorage = regionAttributes.getPartitionAttributes().getLocalMaxMemory() &gt; 0;      // TODO: 1) dataRegion should be withStorage     // 2) Persistence to Persistence     // 3) Replicate to Replicate, Partition To Partition     // 4) Offheap to Offheap     if (!withStorage) {       regionShortCut = RegionShortcut.PARTITION_PROXY;     } else if (withPersistence) {       // TODO: add PartitionedRegionAttributes instead       regionShortCut = RegionShortcut.PARTITION_PERSISTENT;     } else {       regionShortCut = RegionShortcut.PARTITION;     }      // create PR fileAndChunkRegion, but not to create its buckets for now     final String fileRegionName = createFileRegionName();     PartitionAttributes partitionAttributes = dataRegion.getPartitionAttributes();     DistributionManager dm = this.cache.getInternalDistributedSystem().getDistributionManager();     LuceneBucketListener lucenePrimaryBucketListener =         new LuceneBucketListener(partitionedRepositoryManager, dm);      if (!fileRegionExists(fileRegionName)) {       fileAndChunkRegion = createRegion(fileRegionName, regionShortCut, this.regionPath,           partitionAttributes, regionAttributes, lucenePrimaryBucketListener);     }      fileSystemStats         .setBytesSupplier(() -&gt; getFileAndChunkRegion().getPrStats().getDataStoreBytesInUse());    }    public PartitionedRegion getFileAndChunkRegion() {     return (PartitionedRegion) fileAndChunkRegion;   }    public FileSystemStats getFileSystemStats() {     return fileSystemStats;   }    boolean fileRegionExists(String fileRegionName) {     return cache.getRegion(fileRegionName) != null;   }    public String createFileRegionName() {     return LuceneServiceImpl.getUniqueIndexRegionName(indexName, regionPath, FILES_REGION_SUFFIX);   }    private PartitionAttributesFactory configureLuceneRegionAttributesFactory(       PartitionAttributesFactory attributesFactory,       PartitionAttributes dataRegionAttributes) {     attributesFactory.setTotalNumBuckets(dataRegionAttributes.getTotalNumBuckets());     attributesFactory.setRedundantCopies(dataRegionAttributes.getRedundantCopies());     attributesFactory.setPartitionResolver(getPartitionResolver(dataRegionAttributes));     attributesFactory.setRecoveryDelay(dataRegionAttributes.getRecoveryDelay());     attributesFactory.setStartupRecoveryDelay(dataRegionAttributes.getStartupRecoveryDelay());     return attributesFactory;   }    private PartitionResolver getPartitionResolver(PartitionAttributes dataRegionAttributes) {     if (dataRegionAttributes.getPartitionResolver() instanceof FixedPartitionResolver) {       return new BucketTargetingFixedResolver();     } else {       return new BucketTargetingResolver();     }   }    protected  Region createRegion(final String regionName,       final RegionShortcut regionShortCut, final String colocatedWithRegionName,       final PartitionAttributes partitionAttributes, final RegionAttributes regionAttributes,       PartitionListener lucenePrimaryBucketListener) {     PartitionAttributesFactory partitionAttributesFactory = new PartitionAttributesFactory();     if (lucenePrimaryBucketListener != null) {       partitionAttributesFactory.addPartitionListener(lucenePrimaryBucketListener);     }     partitionAttributesFactory.setColocatedWith(colocatedWithRegionName);     configureLuceneRegionAttributesFactory(partitionAttributesFactory, partitionAttributes);      // Create AttributesFactory based on input RegionShortcut     RegionAttributes baseAttributes = this.cache.getRegionAttributes(regionShortCut.toString());     AttributesFactory factory = new AttributesFactory(baseAttributes);     factory.setPartitionAttributes(partitionAttributesFactory.create());     if (regionAttributes.getDataPolicy().withPersistence()) {       factory.setDiskStoreName(regionAttributes.getDiskStoreName());     }     RegionAttributes attributes = factory.create();      return createRegion(regionName, attributes);   }    public void close() {}    @Override   public void dumpFiles(final String directory) {     ResultCollector results = FunctionService.onRegion(getDataRegion())         .setArguments(new String[] {directory, indexName}).execute(DumpDirectoryFiles.ID);     results.getResult();   }    @Override   public void destroy(boolean initiator) {     if (logger.isDebugEnabled()) {       logger.debug(&quot;Destroying index regionPath=&quot; + regionPath + &quot;; indexName=&quot; + indexName           + &quot;; initiator=&quot; + initiator);     }      // Invoke super destroy to remove the extension and async event queue     super.destroy(initiator);      // Destroy index on remote members if necessary     if (initiator) {       destroyOnRemoteMembers();     }      // Destroy the file region (colocated with the application region) if necessary     // localDestroyRegion can't be used because locally destroying regions is not supported on     // colocated regions     if (initiator) {       try {         fileAndChunkRegion.destroyRegion();         if (logger.isDebugEnabled()) {           logger.debug(&quot;Destroyed fileAndChunkRegion=&quot; + fileAndChunkRegion.getName());         }       } catch (RegionDestroyedException e) {         if (logger.isDebugEnabled()) {           logger.debug(&quot;Already destroyed fileAndChunkRegion=&quot; + fileAndChunkRegion.getName());         }       }     }      if (logger.isDebugEnabled()) {       logger.debug(&quot;Destroyed index regionPath=&quot; + regionPath + &quot;; indexName=&quot; + indexName           + &quot;; initiator=&quot; + initiator);     }   }    @Override   public boolean isIndexAvailable(int id) {     PartitionedRegion fileAndChunkRegion = getFileAndChunkRegion();     return (fileAndChunkRegion.get(IndexRepositoryFactory.APACHE_GEODE_INDEX_COMPLETE, id) != null         || !LuceneServiceImpl.LUCENE_REINDEX);   }    private void destroyOnRemoteMembers() {     DistributionManager dm = getDataRegion().getDistributionManager();     Set recipients = dm.getOtherNormalDistributionManagerIds();     if (!recipients.isEmpty()) {       if (logger.isDebugEnabled()) {         logger.debug(&quot;LuceneIndexForPartitionedRegion: About to send destroy message recipients=&quot;             + recipients);       }       ReplyProcessor21 processor = new ReplyProcessor21(dm, recipients);       DestroyLuceneIndexMessage message = new DestroyLuceneIndexMessage(recipients,           processor.getProcessorId(), regionPath, indexName);       dm.putOutgoing(message);       if (logger.isDebugEnabled()) {         logger.debug(&quot;LuceneIndexForPartitionedRegion: Sent message recipients=&quot; + recipients);       }       try {         processor.waitForReplies();       } catch (ReplyException e) {         Throwable cause = e.getCause();         if (cause instanceof IllegalArgumentException) {           // If the IllegalArgumentException is index not found, then its ok; otherwise rethrow it.           String fullRegionPath =               regionPath.startsWith(Region.SEPARATOR) ? regionPath : Region.SEPARATOR + regionPath;           String indexNotFoundMessage = String.format(&quot;Lucene index %s was not found in region %s&quot;,               indexName, fullRegionPath);           if (!cause.getLocalizedMessage().equals(indexNotFoundMessage)) {             throw e;           }         } else if (!(cause instanceof CancelException)) {           throw e;         }       } catch (InterruptedException e) {         dm.getCancelCriterion().checkCancelInProgress(e);         Thread.currentThread().interrupt();       }     }   } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">13214</td>
    <td align="left">https://github.com/apache/geode/blob/8fd839e8b73e40bd2dfd14f331b587431bd35a66/geode-lucene/src/main/java/org/apache/geode/cache/lucene/internal/LuceneIndexForPartitionedRegion.java/#L49-L277</td>
    <td align="right">1</td>
    <td align="right">2122</td>
    <td align="right">13214</td>
  </tr>
  <tr valign="top">
    <td align="right">2130</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{       &quot;message&quot;: &quot;YES I found bad smells&quot;,       &quot;bad smells are&quot;: [         &quot;Long Method&quot;,         &quot;Blob&quot;       ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static byte[] getIP() {         try {             Enumeration allNetInterfaces = NetworkInterface.getNetworkInterfaces();             InetAddress ip = null;             byte[] internalIP = null;             while (allNetInterfaces.hasMoreElements()) {                 NetworkInterface netInterface = (NetworkInterface) allNetInterfaces.nextElement();                 Enumeration addresses = netInterface.getInetAddresses();                 while (addresses.hasMoreElements()) {                     ip = (InetAddress) addresses.nextElement();                     if (ip != null &amp;&amp; ip instanceof Inet4Address) {                         byte[] ipByte = ip.getAddress();                         if (ipByte.length == 4) {                             if (ipCheck(ipByte)) {                                 if (!isInternalIP(ipByte)) {                                     return ipByte;                                 } else if (internalIP == null) {                                     internalIP = ipByte;                                 }                             }                         }                     }                 }             }             if (internalIP != null) {                 return internalIP;             } else {                 throw new RuntimeException(&quot;Can not get local ip&quot;);             }         } catch (Exception e) {             throw new RuntimeException(&quot;Can not get local ip&quot;, e);         }     }</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13230</td>
    <td align="left">https://github.com/apache/rocketmq/blob/971fa8ed8b209b39bdfe41c57cd64576d244e6bd/common/src/main/java/org/apache/rocketmq/common/UtilAll.java/#L484-L516</td>
    <td align="right">1</td>
    <td align="right">2130</td>
    <td align="right">13230</td>
  </tr>
  <tr valign="top">
    <td align="right">2152</td>
    <td align="left">{   &quot;output&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;Blob&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@InterfaceAudience.Public @InterfaceStability.Evolving public class Cluster {      @InterfaceStability.Evolving   public static enum JobTrackerStatus {INITIALIZING, RUNNING};      private ClientProtocolProvider clientProtocolProvider;   private ClientProtocol client;   private UserGroupInformation ugi;   private Configuration conf;   private FileSystem fs = null;   private Path sysDir = null;   private Path stagingAreaDir = null;   private Path jobHistoryDir = null;   private static final Log LOG = LogFactory.getLog(Cluster.class);    private static ServiceLoader frameworkLoader =       ServiceLoader.load(ClientProtocolProvider.class);      static {     ConfigUtil.loadResources();   }      public Cluster(Configuration conf) throws IOException {     this(null, conf);   }    public Cluster(InetSocketAddress jobTrackAddr, Configuration conf)        throws IOException {     this.conf = conf;     this.ugi = UserGroupInformation.getCurrentUser();     initialize(jobTrackAddr, conf);   }      private void initialize(InetSocketAddress jobTrackAddr, Configuration conf)       throws IOException {      synchronized (frameworkLoader) {       for (ClientProtocolProvider provider : frameworkLoader) {         LOG.debug(&quot;Trying ClientProtocolProvider : &quot;             + provider.getClass().getName());         ClientProtocol clientProtocol = null;          try {           if (jobTrackAddr == null) {             clientProtocol = provider.create(conf);           } else {             clientProtocol = provider.create(jobTrackAddr, conf);           }            if (clientProtocol != null) {             clientProtocolProvider = provider;             client = clientProtocol;             LOG.debug(&quot;Picked &quot; + provider.getClass().getName()                 + &quot; as the ClientProtocolProvider&quot;);             break;           }           else {             LOG.debug(&quot;Cannot pick &quot; + provider.getClass().getName()                 + &quot; as the ClientProtocolProvider - returned null protocol&quot;);           }         }          catch (Exception e) {           LOG.info(&quot;Failed to use &quot; + provider.getClass().getName()               + &quot; due to error: &quot; + e.getMessage());         }       }     }      if (null == clientProtocolProvider || null == client) {       throw new IOException(           &quot;Cannot initialize Cluster. Please check your configuration for &quot;               + MRConfig.FRAMEWORK_NAME               + &quot; and the correspond server addresses.&quot;);     }   }    ClientProtocol getClient() {     return client;   }      Configuration getConf() {     return conf;   }      /**    * Close the Cluster.    */   public synchronized void close() throws IOException {     clientProtocolProvider.close(client);   }    private Job[] getJobs(JobStatus[] stats) throws IOException {     List jobs = new ArrayList();     for (JobStatus stat : stats) {       jobs.add(Job.getInstance(this, stat, new JobConf(stat.getJobFile())));     }     return jobs.toArray(new Job[0]);   }    /**    * Get the file system where job-specific files are stored    *     * @return object of FileSystem    * @throws IOException    * @throws InterruptedException    */   public synchronized FileSystem getFileSystem()        throws IOException, InterruptedException {     if (this.fs == null) {       try {         this.fs = ugi.doAs(new PrivilegedExceptionAction() {           public FileSystem run() throws IOException, InterruptedException {             final Path sysDir = new Path(client.getSystemDir());             return sysDir.getFileSystem(getConf());           }         });       } catch (InterruptedException e) {         throw new RuntimeException(e);       }     }     return fs;   }    /**    * Get job corresponding to jobid.    *     * @param jobId    * @return object of {@link Job}    * @throws IOException    * @throws InterruptedException    */   public Job getJob(JobID jobId) throws IOException, InterruptedException {     JobStatus status = client.getJobStatus(jobId);     if (status != null) {       JobConf conf;       try {         conf = new JobConf(status.getJobFile());       } catch (RuntimeException ex) {         // If job file doesn't exist it means we can't find the job         if (ex.getCause() instanceof FileNotFoundException) {           return null;         } else {           throw ex;         }       }       return Job.getInstance(this, status, conf);     }     return null;   }      /**    * Get all the queues in cluster.    *     * @return array of {@link QueueInfo}    * @throws IOException    * @throws InterruptedException    */   public QueueInfo[] getQueues() throws IOException, InterruptedException {     return client.getQueues();   }      /**    * Get queue information for the specified name.    *     * @param name queuename    * @return object of {@link QueueInfo}    * @throws IOException    * @throws InterruptedException    */   public QueueInfo getQueue(String name)        throws IOException, InterruptedException {     return client.getQueue(name);   }    /**    * Get log parameters for the specified jobID or taskAttemptID    * @param jobID the job id.    * @param taskAttemptID the task attempt id. Optional.    * @return the LogParams    * @throws IOException    * @throws InterruptedException    */   public LogParams getLogParams(JobID jobID, TaskAttemptID taskAttemptID)       throws IOException, InterruptedException {     return client.getLogFileParams(jobID, taskAttemptID);   }    /**    * Get current cluster status.    *     * @return object of {@link ClusterMetrics}    * @throws IOException    * @throws InterruptedException    */   public ClusterMetrics getClusterStatus() throws IOException, InterruptedException {     return client.getClusterMetrics();   }      /**    * Get all active trackers in the cluster.    *     * @return array of {@link TaskTrackerInfo}    * @throws IOException    * @throws InterruptedException    */   public TaskTrackerInfo[] getActiveTaskTrackers()        throws IOException, InterruptedException  {     return client.getActiveTrackers();   }      /**    * Get blacklisted trackers.    *     * @return array of {@link TaskTrackerInfo}    * @throws IOException    * @throws InterruptedException    */   public TaskTrackerInfo[] getBlackListedTaskTrackers()        throws IOException, InterruptedException  {     return client.getBlacklistedTrackers();   }      /**    * Get all the jobs in cluster.    *     * @return array of {@link Job}    * @throws IOException    * @throws InterruptedException    * @deprecated Use {@link #getAllJobStatuses()} instead.    */   @Deprecated   public Job[] getAllJobs() throws IOException, InterruptedException {     return getJobs(client.getAllJobs());   }    /**    * Get job status for all jobs in the cluster.    * @return job status for all jobs in cluster    * @throws IOException    * @throws InterruptedException    */   public JobStatus[] getAllJobStatuses() throws IOException, InterruptedException {     return client.getAllJobs();   }    /**    * Grab the jobtracker system directory path where     * job-specific files will  be placed.    *     * @return the system directory where job-specific files are to be placed.    */   public Path getSystemDir() throws IOException, InterruptedException {     if (sysDir == null) {       sysDir = new Path(client.getSystemDir());     }     return sysDir;   }      /**    * Grab the jobtracker's view of the staging directory path where     * job-specific files will  be placed.    *     * @return the staging directory where job-specific files are to be placed.    */   public Path getStagingAreaDir() throws IOException, InterruptedException {     if (stagingAreaDir == null) {       stagingAreaDir = new Path(client.getStagingAreaDir());     }     return stagingAreaDir;   }    /**    * Get the job history file path for a given job id. The job history file at     * this path may or may not be existing depending on the job completion state.    * The file is present only for the completed jobs.    * @param jobId the JobID of the job submitted by the current user.    * @return the file path of the job history file    * @throws IOException    * @throws InterruptedException    */   public String getJobHistoryUrl(JobID jobId) throws IOException,      InterruptedException {     if (jobHistoryDir == null) {       jobHistoryDir = new Path(client.getJobHistoryDir());     }     return new Path(jobHistoryDir, jobId.toString() + &quot;_&quot;                     + ugi.getShortUserName()).toString();   }    /**    * Gets the Queue ACLs for current user    * @return array of QueueAclsInfo object for current user.    * @throws IOException    */   public QueueAclsInfo[] getQueueAclsForCurrentUser()        throws IOException, InterruptedException  {     return client.getQueueAclsForCurrentUser();   }    /**    * Gets the root level queues.    * @return array of JobQueueInfo object.    * @throws IOException    */   public QueueInfo[] getRootQueues() throws IOException, InterruptedException {     return client.getRootQueues();   }      /**    * Returns immediate children of queueName.    * @param queueName    * @return array of JobQueueInfo which are children of queueName    * @throws IOException    */   public QueueInfo[] getChildQueues(String queueName)        throws IOException, InterruptedException {     return client.getChildQueues(queueName);   }      /**    * Get the JobTracker's status.    *     * @return {@link JobTrackerStatus} of the JobTracker    * @throws IOException    * @throws InterruptedException    */   public JobTrackerStatus getJobTrackerStatus() throws IOException,       InterruptedException {     return client.getJobTrackerStatus();   }      /**    * Get the tasktracker expiry interval for the cluster    * @return the expiry interval in msec    */   public long getTaskTrackerExpiryInterval() throws IOException,       InterruptedException {     return client.getTaskTrackerExpiryInterval();   }    /**    * Get a delegation token for the user from the JobTracker.    * @param renewer the user who can renew the token    * @return the new token    * @throws IOException    */   public Token        getDelegationToken(Text renewer) throws IOException, InterruptedException{     // client has already set the service     return client.getDelegationToken(renewer);   }    /**    * Renew a delegation token    * @param token the token to renew    * @return the new expiration time    * @throws InvalidToken    * @throws IOException    * @deprecated Use {@link Token#renew} instead    */   public long renewDelegationToken(Token token                                    ) throws InvalidToken, IOException,                                             InterruptedException {     return token.renew(getConf());   }    /**    * Cancel a delegation token from the JobTracker    * @param token the token to cancel    * @throws IOException    * @deprecated Use {@link Token#cancel} instead    */   public void cancelDelegationToken(Token token                                     ) throws IOException,                                              InterruptedException {     token.cancel(getConf());   }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">13294</td>
    <td align="left">https://github.com/apache/hadoop-common/blob/42a61a4fbc88303913c4681f0d40ffcc737e70b5/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/Cluster.java/#L50-L429</td>
    <td align="right">1</td>
    <td align="right">2152</td>
    <td align="right">13294</td>
  </tr>
  <tr valign="top">
    <td align="right">2155</td>
    <td align="left">&nbsp;{ &quot;answer&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@ThreadSafe public final class ServiceLocation {      private final String location;     private final String name;      ServiceLocation(Element serviceLocationElement, String location) throws ServiceConfigException {         String name = serviceLocationElement.getAttribute(&quot;name&quot;).intern();         if (name.isEmpty()) {             throw new ServiceConfigException(&quot; element name attribute is empty&quot;);         }         this.name = name;         if (location.isEmpty()) {             throw new ServiceConfigException(&quot; element location attribute is empty&quot;);         }         this.location = location;     }      public String getLocation() {         return location;     }      public String getName() {         return name;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">13299</td>
    <td align="left">https://github.com/apache/ofbiz/blob/7ba7f3c2e16df6c8db0d8114e124957199cea1ff/framework/service/src/main/java/org/apache/ofbiz/service/config/model/ServiceLocation.java/#L28-L53</td>
    <td align="right">1</td>
    <td align="right">2155</td>
    <td align="right">13299</td>
  </tr>
  <tr valign="top">
    <td align="right">2167</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;answer&quot;: &quot;YES, I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Blob&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DruidPooledCallableStatement extends DruidPooledPreparedStatement implements CallableStatement {      private CallableStatement stmt;      public DruidPooledCallableStatement(DruidPooledConnection conn, PreparedStatementHolder holder) throws SQLException{         super(conn, holder);         this.stmt = (CallableStatement) holder.statement;     }      public CallableStatement getCallableStatementRaw() {         return stmt;     }      @Override     public void registerOutParameter(int parameterIndex, int sqlType) throws SQLException {         try {             stmt.registerOutParameter(parameterIndex, sqlType);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(int parameterIndex, int sqlType, int scale) throws SQLException {         try {             stmt.registerOutParameter(parameterIndex, sqlType, scale);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public boolean wasNull() throws SQLException {         try {             return stmt.wasNull();         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public String getString(int parameterIndex) throws SQLException {         try {             return stmt.getString(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public boolean getBoolean(int parameterIndex) throws SQLException {         try {             return stmt.getBoolean(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public byte getByte(int parameterIndex) throws SQLException {         try {             return stmt.getByte(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public short getShort(int parameterIndex) throws SQLException {         try {             return stmt.getShort(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public int getInt(int parameterIndex) throws SQLException {         try {             return stmt.getInt(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public long getLong(int parameterIndex) throws SQLException {         try {             return stmt.getLong(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public float getFloat(int parameterIndex) throws SQLException {         try {             return stmt.getFloat(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public double getDouble(int parameterIndex) throws SQLException {         try {             return stmt.getDouble(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     @Deprecated     public BigDecimal getBigDecimal(int parameterIndex, int scale) throws SQLException {         try {             return stmt.getBigDecimal(parameterIndex, scale);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public byte[] getBytes(int parameterIndex) throws SQLException {         try {             return stmt.getBytes(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Date getDate(int parameterIndex) throws SQLException {         try {             return stmt.getDate(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Time getTime(int parameterIndex) throws SQLException {         try {             return stmt.getTime(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Timestamp getTimestamp(int parameterIndex) throws SQLException {         try {             return stmt.getTimestamp(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Object getObject(int parameterIndex) throws SQLException {         try {             Object obj = stmt.getObject(parameterIndex);             return wrapObject(obj);         } catch (Throwable t) {             throw checkException(t);         }     }      private Object wrapObject(Object obj) {         if (obj instanceof ResultSet) {             ResultSet rs = (ResultSet) obj;                          DruidPooledResultSet poolableResultSet = new DruidPooledResultSet(this, rs);             addResultSetTrace(poolableResultSet);                          obj = poolableResultSet;         }                  return obj;     }      @Override     public BigDecimal getBigDecimal(int parameterIndex) throws SQLException {         try {             return stmt.getBigDecimal(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Object getObject(int parameterIndex, java.util.Map&gt; map) throws SQLException {         try {             Object obj = stmt.getObject(parameterIndex, map);             return wrapObject(obj);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Ref getRef(int parameterIndex) throws SQLException {         try {             return stmt.getRef(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Blob getBlob(int parameterIndex) throws SQLException {         try {             return stmt.getBlob(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Clob getClob(int parameterIndex) throws SQLException {         try {             return stmt.getClob(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Array getArray(int parameterIndex) throws SQLException {         try {             return stmt.getArray(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Date getDate(int parameterIndex, Calendar cal) throws SQLException {         try {             return stmt.getDate(parameterIndex, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Time getTime(int parameterIndex, Calendar cal) throws SQLException {         try {             return stmt.getTime(parameterIndex, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Timestamp getTimestamp(int parameterIndex, Calendar cal) throws SQLException {         try {             return stmt.getTimestamp(parameterIndex, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(int parameterIndex, int sqlType, String typeName) throws SQLException {         try {             stmt.registerOutParameter(parameterIndex, sqlType, typeName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(String parameterName, int sqlType) throws SQLException {         try {             stmt.registerOutParameter(parameterName, sqlType);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(String parameterName, int sqlType, int scale) throws SQLException {         try {             stmt.registerOutParameter(parameterName, sqlType, scale);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(String parameterName, int sqlType, String typeName) throws SQLException {         try {             stmt.registerOutParameter(parameterName, sqlType, typeName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.net.URL getURL(int parameterIndex) throws SQLException {         try {             return stmt.getURL(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setURL(String parameterName, java.net.URL val) throws SQLException {         try {             stmt.setURL(parameterName, val);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNull(String parameterName, int sqlType) throws SQLException {         try {             stmt.setNull(parameterName, sqlType);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBoolean(String parameterName, boolean x) throws SQLException {         try {             stmt.setBoolean(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setByte(String parameterName, byte x) throws SQLException {         try {             stmt.setByte(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setShort(String parameterName, short x) throws SQLException {         try {             stmt.setShort(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setInt(String parameterName, int x) throws SQLException {         try {             stmt.setInt(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setLong(String parameterName, long x) throws SQLException {         try {             stmt.setLong(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setFloat(String parameterName, float x) throws SQLException {         try {             stmt.setFloat(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setDouble(String parameterName, double x) throws SQLException {         try {             stmt.setDouble(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBigDecimal(String parameterName, BigDecimal x) throws SQLException {         try {             stmt.setBigDecimal(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setString(String parameterName, String x) throws SQLException {         try {             stmt.setString(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBytes(String parameterName, byte x[]) throws SQLException {         try {             stmt.setBytes(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setDate(String parameterName, java.sql.Date x) throws SQLException {         try {             stmt.setDate(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setTime(String parameterName, java.sql.Time x) throws SQLException {         try {             stmt.setTime(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setTimestamp(String parameterName, java.sql.Timestamp x) throws SQLException {         try {             stmt.setTimestamp(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setAsciiStream(String parameterName, java.io.InputStream x, int length) throws SQLException {         try {             stmt.setAsciiStream(parameterName, x, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBinaryStream(String parameterName, java.io.InputStream x, int length) throws SQLException {         try {             stmt.setBinaryStream(parameterName, x, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setObject(String parameterName, Object x, int targetSqlType, int scale) throws SQLException {         try {             stmt.setObject(parameterName, x, targetSqlType, scale);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setObject(String parameterName, Object x, int targetSqlType) throws SQLException {         try {             stmt.setObject(parameterName, x, targetSqlType);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setObject(String parameterName, Object x) throws SQLException {         try {             stmt.setObject(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setCharacterStream(String parameterName, java.io.Reader reader, int length) throws SQLException {         try {             stmt.setCharacterStream(parameterName, reader, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setDate(String parameterName, java.sql.Date x, Calendar cal) throws SQLException {         try {             stmt.setDate(parameterName, x, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setTime(String parameterName, java.sql.Time x, Calendar cal) throws SQLException {         try {             stmt.setTime(parameterName, x, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setTimestamp(String parameterName, java.sql.Timestamp x, Calendar cal) throws SQLException {         try {             stmt.setTimestamp(parameterName, x, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNull(String parameterName, int sqlType, String typeName) throws SQLException {         try {             stmt.setNull(parameterName, sqlType, typeName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public String getString(String parameterName) throws SQLException {         try {             return stmt.getString(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public boolean getBoolean(String parameterName) throws SQLException {         try {             return stmt.getBoolean(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public byte getByte(String parameterName) throws SQLException {         try {             return stmt.getByte(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public short getShort(String parameterName) throws SQLException {         try {             return stmt.getShort(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public int getInt(String parameterName) throws SQLException {         try {             return stmt.getInt(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public long getLong(String parameterName) throws SQLException {         try {             return stmt.getLong(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public float getFloat(String parameterName) throws SQLException {         try {             return stmt.getFloat(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public double getDouble(String parameterName) throws SQLException {         try {             return stmt.getDouble(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public byte[] getBytes(String parameterName) throws SQLException {         try {             return stmt.getBytes(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Date getDate(String parameterName) throws SQLException {         try {             return stmt.getDate(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Time getTime(String parameterName) throws SQLException {         try {             return stmt.getTime(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Timestamp getTimestamp(String parameterName) throws SQLException {         try {             return stmt.getTimestamp(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Object getObject(String parameterName) throws SQLException {         try {             Object obj = stmt.getObject(parameterName);             return wrapObject(obj);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public BigDecimal getBigDecimal(String parameterName) throws SQLException {         try {             return stmt.getBigDecimal(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Object getObject(String parameterName, java.util.Map&gt; map) throws SQLException {         try {             Object obj = stmt.getObject(parameterName, map);             return wrapObject(obj);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Ref getRef(String parameterName) throws SQLException {         try {             return stmt.getRef(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Blob getBlob(String parameterName) throws SQLException {         try {             return stmt.getBlob(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Clob getClob(String parameterName) throws SQLException {         try {             return stmt.getClob(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Array getArray(String parameterName) throws SQLException {         try {             return stmt.getArray(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Date getDate(String parameterName, Calendar cal) throws SQLException {         try {             return stmt.getDate(parameterName, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Time getTime(String parameterName, Calendar cal) throws SQLException {         try {             return stmt.getTime(parameterName, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Timestamp getTimestamp(String parameterName, Calendar cal) throws SQLException {         try {             return stmt.getTimestamp(parameterName, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.net.URL getURL(String parameterName) throws SQLException {         try {             return stmt.getURL(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public RowId getRowId(int parameterIndex) throws SQLException {         try {             return stmt.getRowId(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public RowId getRowId(String parameterName) throws SQLException {         try {             return stmt.getRowId(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setRowId(String parameterName, RowId x) throws SQLException {         try {             stmt.setRowId(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNString(String parameterName, String value) throws SQLException {         try {             stmt.setNString(parameterName, value);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNCharacterStream(String parameterName, Reader value, long length) throws SQLException {         try {             stmt.setNCharacterStream(parameterName, value, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNClob(String parameterName, NClob value) throws SQLException {         try {             stmt.setNClob(parameterName, value);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setClob(String parameterName, Reader reader, long length) throws SQLException {         try {             stmt.setClob(parameterName, reader, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBlob(String parameterName, InputStream inputStream, long length) throws SQLException {         try {             stmt.setBlob(parameterName, inputStream, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNClob(String parameterName, Reader reader, long length) throws SQLException {         try {             stmt.setNClob(parameterName, reader, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public NClob getNClob(int parameterIndex) throws SQLException {         try {             return stmt.getNClob(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public NClob getNClob(String parameterName) throws SQLException {         try {             return stmt.getNClob(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setSQLXML(String parameterName, SQLXML xmlObject) throws SQLException {         try {             stmt.setSQLXML(parameterName, xmlObject);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public SQLXML getSQLXML(int parameterIndex) throws SQLException {         try {             return stmt.getSQLXML(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public SQLXML getSQLXML(String parameterName) throws SQLException {         try {             return stmt.getSQLXML(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public String getNString(int parameterIndex) throws SQLException {         try {             return stmt.getNString(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public String getNString(String parameterName) throws SQLException {         try {             return stmt.getNString(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.io.Reader getNCharacterStream(int parameterIndex) throws SQLException {         try {             return stmt.getNCharacterStream(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.io.Reader getNCharacterStream(String parameterName) throws SQLException {         try {             return stmt.getNCharacterStream(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.io.Reader getCharacterStream(int parameterIndex) throws SQLException {         try {             return stmt.getCharacterStream(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.io.Reader getCharacterStream(String parameterName) throws SQLException {         try {             return stmt.getCharacterStream(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBlob(String parameterName, Blob x) throws SQLException {         try {             stmt.setBlob(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setClob(String parameterName, Clob x) throws SQLException {         try {             stmt.setClob(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setAsciiStream(String parameterName, java.io.InputStream x, long length) throws SQLException {         try {             stmt.setAsciiStream(parameterName, x, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBinaryStream(String parameterName, java.io.InputStream x, long length) throws SQLException {         try {             stmt.setBinaryStream(parameterName, x, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setCharacterStream(String parameterName, java.io.Reader reader, long length) throws SQLException {         try {             stmt.setCharacterStream(parameterName, reader, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setAsciiStream(String parameterName, java.io.InputStream x) throws SQLException {         try {             stmt.setAsciiStream(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBinaryStream(String parameterName, java.io.InputStream x) throws SQLException {         try {             stmt.setBinaryStream(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setCharacterStream(String parameterName, java.io.Reader reader) throws SQLException {         try {             stmt.setCharacterStream(parameterName, reader);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNCharacterStream(String parameterName, Reader value) throws SQLException {         try {             stmt.setNCharacterStream(parameterName, value);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setClob(String parameterName, Reader reader) throws SQLException {         try {             stmt.setClob(parameterName, reader);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBlob(String parameterName, InputStream inputStream) throws SQLException {         try {             stmt.setBlob(parameterName, inputStream);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNClob(String parameterName, Reader reader) throws SQLException {         try {             stmt.setNClob(parameterName, reader);         } catch (Throwable t) {             throw checkException(t);         }     }      public  T getObject(int parameterIndex, Class type) throws SQLException {         throw new SQLFeatureNotSupportedException();     }      public  T getObject(String parameterName, Class type) throws SQLException {         throw new SQLFeatureNotSupportedException();     }      @SuppressWarnings(&quot;unchecked&quot;)     public  T unwrap(Class iface) throws SQLException {         if (iface == CallableStatement.class || iface == PreparedStatement.class) {             if (stmt instanceof CallableStatementProxy) {                 return stmt.unwrap(iface);             }             return (T) stmt;         }                  return super.unwrap(iface);     } }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">13349</td>
    <td align="left">https://github.com/alibaba/druid/blob/768469fe4d1340efe1036453366a58c9ab7e30d1/src/main/java/com/alibaba/druid/pool/DruidPooledCallableStatement.java/#L40-L1089</td>
    <td align="right">1</td>
    <td align="right">2167</td>
    <td align="right">13349</td>
  </tr>
  <tr valign="top">
    <td align="right">2171</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@ManagedAttributeValueType public interface AclRule extends ManagedAttributeValue {     String getIdentity();     ObjectType getObjectType();     LegacyOperation getOperation();     Map getAttributes();     RuleOutcome getOutcome(); }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">13382</td>
    <td align="left">https://github.com/apache/qpid-broker-j/blob/4c4400b98a5a8493cfb9e5dbb21c97175f433a62/broker-plugins/access-control/src/main/java/org/apache/qpid/server/security/access/plugins/AclRule.java/#L31-L39</td>
    <td align="right">1</td>
    <td align="right">2171</td>
    <td align="right">13382</td>
  </tr>
  <tr valign="top">
    <td align="right">2183</td>
    <td align="left">{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Blob&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
final class TraceableHttpServletResponse implements TraceableResponse {  	private final HttpServletResponse delegate;  	TraceableHttpServletResponse(HttpServletResponse response) { 		this.delegate = response; 	}  	@Override 	public int getStatus() { 		return this.delegate.getStatus(); 	}  	@Override 	public Map&gt; getHeaders() { 		return extractHeaders(); 	}  	private Map&gt; extractHeaders() { 		Map&gt; headers = new LinkedHashMap&lt;&gt;(); 		for (String name : this.delegate.getHeaderNames()) { 			headers.put(name, new ArrayList&lt;&gt;(this.delegate.getHeaders(name))); 		} 		return headers; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">13424</td>
    <td align="left">https://github.com/spring-projects/spring-boot/blob/2225b362991f225e3a93f00e160526d2b8abdfb2/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/web/trace/servlet/TraceableHttpServletResponse.java/#L33-L59</td>
    <td align="right">1</td>
    <td align="right">2183</td>
    <td align="right">13424</td>
  </tr>
  <tr valign="top">
    <td align="right">2184</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Blob&quot;,             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SuppressWarnings(&quot;serial&quot;) public class ObjectRetrievalFailureException extends DataRetrievalFailureException {  	@Nullable 	private final Object persistentClass;  	@Nullable 	private final Object identifier;   	/** 	 * Create a general ObjectRetrievalFailureException with the given message, 	 * without any information on the affected object. 	 * @param msg the detail message 	 * @param cause the source exception 	 */ 	public ObjectRetrievalFailureException(String msg, Throwable cause) { 		super(msg, cause); 		this.persistentClass = null; 		this.identifier = null; 	}  	/** 	 * Create a new ObjectRetrievalFailureException for the given object, 	 * with the default &quot;not found&quot; message. 	 * @param persistentClass the persistent class 	 * @param identifier the ID of the object that should have been retrieved 	 */ 	public ObjectRetrievalFailureException(Class persistentClass, Object identifier) { 		this(persistentClass, identifier, 				&quot;Object of class [&quot; + persistentClass.getName() + &quot;] with identifier [&quot; + identifier + &quot;]: not found&quot;, 				null); 	}  	/** 	 * Create a new ObjectRetrievalFailureException for the given object, 	 * with the given explicit message and exception. 	 * @param persistentClass the persistent class 	 * @param identifier the ID of the object that should have been retrieved 	 * @param msg the detail message 	 * @param cause the source exception 	 */ 	public ObjectRetrievalFailureException( 			Class persistentClass, Object identifier, String msg, @Nullable Throwable cause) {  		super(msg, cause); 		this.persistentClass = persistentClass; 		this.identifier = identifier; 	}  	/** 	 * Create a new ObjectRetrievalFailureException for the given object, 	 * with the default &quot;not found&quot; message. 	 * @param persistentClassName the name of the persistent class 	 * @param identifier the ID of the object that should have been retrieved 	 */ 	public ObjectRetrievalFailureException(String persistentClassName, Object identifier) { 		this(persistentClassName, identifier, 				&quot;Object of class [&quot; + persistentClassName + &quot;] with identifier [&quot; + identifier + &quot;]: not found&quot;, 				null); 	}  	/** 	 * Create a new ObjectRetrievalFailureException for the given object, 	 * with the given explicit message and exception. 	 * @param persistentClassName the name of the persistent class 	 * @param identifier the ID of the object that should have been retrieved 	 * @param msg the detail message 	 * @param cause the source exception 	 */ 	public ObjectRetrievalFailureException( 			String persistentClassName, Object identifier, String msg, @Nullable Throwable cause) {  		super(msg, cause); 		this.persistentClass = persistentClassName; 		this.identifier = identifier; 	}   	/** 	 * Return the persistent class of the object that was not found. 	 * If no Class was specified, this method returns null. 	 */ 	@Nullable 	public Class getPersistentClass() { 		return (this.persistentClass instanceof Class ? (Class) this.persistentClass : null); 	}  	/** 	 * Return the name of the persistent class of the object that was not found. 	 * Will work for both Class objects and String names. 	 */ 	@Nullable 	public String getPersistentClassName() { 		if (this.persistentClass instanceof Class) { 			return ((Class) this.persistentClass).getName(); 		} 		return (this.persistentClass != null ? this.persistentClass.toString() : null); 	}  	/** 	 * Return the identifier of the object that was not found. 	 */ 	@Nullable 	public Object getIdentifier() { 		return this.identifier; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13426</td>
    <td align="left">https://github.com/spring-projects/spring-framework/blob/3a0f309e2c9fdbbf7fb2d348be861528177f8555/spring-orm/src/main/java/org/springframework/orm/ObjectRetrievalFailureException.java/#L29-L137</td>
    <td align="right">1</td>
    <td align="right">2184</td>
    <td align="right">13426</td>
  </tr>
  <tr valign="top">
    <td align="right">2185</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Long Method&quot;,       &quot;Blob&quot;     ]   }   </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
        Type asTuple() {             final Type result;             if (types.size() == 0) {                 result = unit.getEmptyType();             } else {                 final Type sequentialType;                 if (variadic) {                     Part part = new Part(&quot;Sequence&quot;, Collections.singletonList(getLast()));                     sequentialType = loadType(&quot;ceylon.language&quot;,                              atLeastOne ? &quot;ceylon.language.Sequence&quot; : &quot;ceylon.language.Sequential&quot;,                                      part, null);                 } else {                     sequentialType = unit.getEmptyType();                 }                                  if (variadic &amp;&amp; types.size() == 1) {                     result = sequentialType;                 } else {                     Part part = new Part();                     // if we're variadic we put the element type there because we skip it below                     // if we're not variadic we are not going to skip it so let's not union it with itself                     Type union = variadic ? getLast() : null;                     Type tupleType = sequentialType;                     // A,B=                      // union = null                     // tupleType = []                     // t = B                     // union = B                     // tupleType = [B]                     // tupleType = [B]|[]                     // t = A                     // union = A|B                     // tupleType = [A,[B]|[]]                      // A=,B=                      // union = null                     // tupleType = []                     // t = B                     // union = B                     // tupleType = [B]                     // tupleType = [B]|[]                     // t = A                     // union = A|B                     // tupleType = [A,[B]|[]]                     // tupleType = [A,[B]|[]]|[]                      // A=,B*                      // union = B                     // tupleType = [B*]                     // t = A                     // union = A|B                     // tupleType = [A,[B*]]                     // tupleType = [A,[B*]]|[]                      int makeDefaulted = defaulted;                     for (int ii  = types.size()-(variadic? 2 : 1); ii &gt;= 0; ii--) {                         Type t = types.get(ii);                         // FIXME: subtyping in the type parser may cause issues                         if(union != null) // any second element (variadic or not)                             union = ModelUtil.unionType(union, t, unit);                         else                             union = t; // any first element                         part.parameters = Arrays.asList(union, t, tupleType);                         part.name = &quot;Tuple&quot;;                         tupleType = loadType(&quot;ceylon.language&quot;, &quot;ceylon.language.Tuple&quot;, part, null);                         if(makeDefaulted &gt; 0){                             makeDefaulted--;                             tupleType = union(Arrays.asList(unit.getEmptyType(), tupleType), unit);                         }                     }                     result = tupleType;                 }             }             return result;         }</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13430</td>
    <td align="left">https://github.com/eclipse/ceylon/blob/d3994d6cd120c4df85952cd9432123b413cfd65a/model/src/org/eclipse/ceylon/model/loader/TypeParser.java/#L431-L505</td>
    <td align="right">1</td>
    <td align="right">2185</td>
    <td align="right">13430</td>
  </tr>
  <tr valign="top">
    <td align="right">2188</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Long Method&quot;,             &quot;Blob&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @Override     public Object getValue(final String columnLabel, final Class type) throws SQLException {         Object result;         if (Object.class == type) {             result = decrypt(columnLabel, resultSet.getObject(columnLabel));         } else if (boolean.class == type) {             result = decrypt(columnLabel, resultSet.getBoolean(columnLabel));         } else if (byte.class == type) {             result = decrypt(columnLabel, resultSet.getByte(columnLabel));         } else if (short.class == type) {             result = decrypt(columnLabel, resultSet.getShort(columnLabel));         } else if (int.class == type) {             result = decrypt(columnLabel, resultSet.getInt(columnLabel));         } else if (long.class == type) {             result = decrypt(columnLabel, resultSet.getLong(columnLabel));         } else if (float.class == type) {             result = decrypt(columnLabel, resultSet.getFloat(columnLabel));         } else if (double.class == type) {             result = decrypt(columnLabel, resultSet.getDouble(columnLabel));         } else if (String.class == type) {             result = decrypt(columnLabel, resultSet.getString(columnLabel));         } else if (BigDecimal.class == type) {             result = decrypt(columnLabel, resultSet.getBigDecimal(columnLabel));         } else if (byte[].class == type) {             result = resultSet.getBytes(columnLabel);         } else if (Date.class == type) {             result = resultSet.getDate(columnLabel);         } else if (Time.class == type) {             result = resultSet.getTime(columnLabel);         } else if (Timestamp.class == type) {             result = resultSet.getTimestamp(columnLabel);         } else if (URL.class == type) {             result = resultSet.getURL(columnLabel);         } else if (Blob.class == type) {             result = resultSet.getBlob(columnLabel);         } else if (Clob.class == type) {             result = resultSet.getClob(columnLabel);         } else if (SQLXML.class == type) {             result = resultSet.getSQLXML(columnLabel);         } else if (Reader.class == type) {             result = resultSet.getCharacterStream(columnLabel);         } else {             result = decrypt(columnLabel, resultSet.getObject(columnLabel));         }         return result;     }</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13444</td>
    <td align="left">https://github.com/apache/incubator-shardingsphere/blob/c5cf1d15b02f3a0fb3bda4f15d5f0b3779eac7ba/sharding-core/sharding-core-execute/src/main/java/org/apache/shardingsphere/core/execute/sql/execute/result/StreamQueryResult.java/#L117-L162</td>
    <td align="right">1</td>
    <td align="right">2188</td>
    <td align="right">13444</td>
  </tr>
  <tr valign="top">
    <td align="right">2190</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Blob&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class RabbitGatewaySupport implements InitializingBean {  	/** Logger available to subclasses. */ 	protected final Log logger = LogFactory.getLog(getClass()); // NOSONAR  	private RabbitOperations rabbitOperations;  	/** 	 * Set the Rabbit connection factory to be used by the gateway. 	 * Will automatically create a RabbitTemplate for the given ConnectionFactory. 	 * @param connectionFactory The connection factory. 	 * @see #createRabbitTemplate 	 * @see #setConnectionFactory(org.springframework.amqp.rabbit.connection.ConnectionFactory) 	 */ 	public final void setConnectionFactory(ConnectionFactory connectionFactory) { 		this.rabbitOperations = createRabbitTemplate(connectionFactory); 	}  	/** 	 * Create a RabbitTemplate for the given ConnectionFactory. 	 * Only invoked if populating the gateway with a ConnectionFactory reference. 	 * 	 * @param connectionFactory the Rabbit ConnectionFactory to create a RabbitTemplate for 	 * @return the new RabbitTemplate instance 	 * @see #setConnectionFactory 	 */ 	protected RabbitTemplate createRabbitTemplate(ConnectionFactory connectionFactory) { 		return new RabbitTemplate(connectionFactory); 	}  	/** 	 * @return The Rabbit ConnectionFactory used by the gateway. 	 */ 	@Nullable 	public final ConnectionFactory getConnectionFactory() { 		return (this.rabbitOperations != null ? this.rabbitOperations.getConnectionFactory() : null); 	}  	/** 	 * Set the {@link RabbitOperations} for the gateway. 	 * @param rabbitOperations The Rabbit operations. 	 * @see #setConnectionFactory(org.springframework.amqp.rabbit.connection.ConnectionFactory) 	 */ 	public final void setRabbitOperations(RabbitOperations rabbitOperations) { 		this.rabbitOperations = rabbitOperations; 	}  	/** 	 * @return The {@link RabbitOperations} for the gateway. 	 */ 	public final RabbitOperations getRabbitOperations() { 		return this.rabbitOperations; 	}  	@Override 	public final void afterPropertiesSet() throws IllegalArgumentException, BeanInitializationException { 		if (this.rabbitOperations == null) { 			throw new IllegalArgumentException(&quot;'connectionFactory' or 'rabbitTemplate' is required&quot;); 		} 		try { 			initGateway(); 		} 		catch (Exception ex) { 			throw new BeanInitializationException(&quot;Initialization of Rabbit gateway failed: &quot; + ex.getMessage(), ex); 		} 	}  	/** 	 * Subclasses can override this for custom initialization behavior. 	 * Gets called after population of this instance's bean properties. 	 */ 	protected void initGateway() { 	}  }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">13458</td>
    <td align="left">https://github.com/spring-projects/spring-amqp/blob/1614a4b0532b83e29b2a2fdb8dac102576b8aa51/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/RabbitGatewaySupport.java/#L43-L117</td>
    <td align="right">1</td>
    <td align="right">2190</td>
    <td align="right">13458</td>
  </tr>
  <tr valign="top">
    <td align="right">2192</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Blob&quot;,       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Status {     public String getAction() {         return action;     }      public Result getResult() {         return result;     }      public String getDetails() {         return details;     }      private String action;     private Result result;     private String details;      public Status(String action, Result result, String details) {         this.action = action;         this.result = result;         this.details = details;     }     public static enum Result {         SUCCESSFUL,         FAILED,     }      @Override     public String toString() {         return String.format(&quot;%s\t%s\t%s&quot;, action, result, details);     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13474</td>
    <td align="left">https://github.com/Microsoft/azure-tools-for-java/blob/d121e8ac9cc3ab400e5b49c8b372280ae332f3fb/Utils/azuretools-core/src/com/microsoft/azuretools/authmanage/srvpri/step/Status.java/#L28-L59</td>
    <td align="right">1</td>
    <td align="right">2192</td>
    <td align="right">13474</td>
  </tr>
  <tr valign="top">
    <td align="right">2215</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    static class Cause {         final Tuple tuple ;         final Mapping     mapping ;          public Cause(Tuple tuple, Mapping mapping) {             super() ;             this.tuple = tuple ;             this.mapping = mapping ;         }     }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">13529</td>
    <td align="left">https://github.com/apache/jena/blob/1cca775bbf0bb0fd3ee8ac55e31f0f30cdde3b77/jena-arq/src/main/java/org/apache/jena/sparql/util/IsoMatcher.java/#L113-L122</td>
    <td align="right">1</td>
    <td align="right">2215</td>
    <td align="right">13529</td>
  </tr>
  <tr valign="top">
    <td align="right">2226</td>
    <td align="left">&nbsp;{     &quot;answer&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Blob&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
   public class Header {        public String key;       public String val;        public Header(String key, String val) {          this.key = key;          this.val = val;       }        public String getEncodedKey() {          return encode(key);       }        public String getEncodedValue() {          return encode(val);       }    }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13576</td>
    <td align="left">https://github.com/apache/activemq-artemis/blob/5bd5c610195d6f4a3dd1ac28170727003f8a5a54/artemis-protocols/artemis-stomp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/stomp/StompFrame.java/#L158-L175</td>
    <td align="right">1</td>
    <td align="right">2226</td>
    <td align="right">13576</td>
  </tr>
  <tr valign="top">
    <td align="right">2238</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;response&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  abstract static class RequestParamsBuilder {     T body;      public RequestParamsBuilder(T body) {       this.body = body;     }      abstract RequestParams buildRequestParams();      void setBody(T body) {       this.body = body;     }   }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">13615</td>
    <td align="left">https://github.com/oracle/weblogic-kubernetes-operator/blob/1fb059d7e32b9b3514617d54e4dda41ab68e71ea/operator/src/main/java/oracle/kubernetes/operator/helpers/CallBuilder.java/#L179-L191</td>
    <td align="right">1</td>
    <td align="right">2238</td>
    <td align="right">13615</td>
  </tr>
  <tr valign="top">
    <td align="right">2261</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;the bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = &quot;@class&quot;) @JsonSubTypes({ 	@JsonSubTypes.Type(value = SubtaskCheckpointStatistics.CompletedSubtaskCheckpointStatistics.class, name = &quot;completed&quot;), 	@JsonSubTypes.Type(value = SubtaskCheckpointStatistics.PendingSubtaskCheckpointStatistics.class, name = &quot;pending&quot;)}) public class SubtaskCheckpointStatistics {  	public static final String FIELD_NAME_INDEX = &quot;index&quot;;  	public static final String FIELD_NAME_CHECKPOINT_STATUS = &quot;status&quot;;  	@JsonProperty(FIELD_NAME_INDEX) 	private final int index;  	@JsonProperty(FIELD_NAME_CHECKPOINT_STATUS) 	private final String checkpointStatus;  	@JsonCreator 	private SubtaskCheckpointStatistics( 			@JsonProperty(FIELD_NAME_INDEX) int index, 			@JsonProperty(FIELD_NAME_CHECKPOINT_STATUS) String checkpointStatus) { 		this.index = index; 		this.checkpointStatus = checkpointStatus; 	}  	public int getIndex() { 		return index; 	}  	public String getCheckpointStatus() { 		return checkpointStatus; 	}  	@Override 	public boolean equals(Object o) { 		if (this == o) { 			return true; 		} 		if (o == null || getClass() != o.getClass()) { 			return false; 		} 		SubtaskCheckpointStatistics that = (SubtaskCheckpointStatistics) o; 		return index == that.index &amp;&amp; 			Objects.equals(checkpointStatus, that.checkpointStatus); 	}  	@Override 	public int hashCode() { 		return Objects.hash(index, checkpointStatus); 	}  	// --------------------------------------------------------------------------------- 	// Static inner classes 	// ---------------------------------------------------------------------------------  	/** 	 * Checkpoint statistics for a completed subtask checkpoint. 	 */ 	public static final class CompletedSubtaskCheckpointStatistics extends SubtaskCheckpointStatistics {  		public static final String FIELD_NAME_ACK_TIMESTAMP = &quot;ack_timestamp&quot;;  		public static final String FIELD_NAME_DURATION = &quot;end_to_end_duration&quot;;  		public static final String FIELD_NAME_STATE_SIZE = &quot;state_size&quot;;  		public static final String FIELD_NAME_CHECKPOINT_DURATION = &quot;checkpoint&quot;;  		public static final String FIELD_NAME_ALIGNMENT = &quot;alignment&quot;;  		@JsonProperty(FIELD_NAME_ACK_TIMESTAMP) 		private final long ackTimestamp;  		@JsonProperty(FIELD_NAME_DURATION) 		private final long duration;  		@JsonProperty(FIELD_NAME_STATE_SIZE) 		private final long stateSize;  		@JsonProperty(FIELD_NAME_CHECKPOINT_DURATION) 		private final CheckpointDuration checkpointDuration;  		@JsonProperty(FIELD_NAME_ALIGNMENT) 		private final CheckpointAlignment alignment;  		@JsonCreator 		public CompletedSubtaskCheckpointStatistics( 				@JsonProperty(FIELD_NAME_INDEX) int index, 				@JsonProperty(FIELD_NAME_ACK_TIMESTAMP) long ackTimestamp, 				@JsonProperty(FIELD_NAME_DURATION) long duration, 				@JsonProperty(FIELD_NAME_STATE_SIZE) long stateSize, 				@JsonProperty(FIELD_NAME_CHECKPOINT_DURATION) CheckpointDuration checkpointDuration, 				@JsonProperty(FIELD_NAME_ALIGNMENT) CheckpointAlignment alignment) { 			super(index, &quot;completed&quot;); 			this.ackTimestamp = ackTimestamp; 			this.duration = duration; 			this.stateSize = stateSize; 			this.checkpointDuration = checkpointDuration; 			this.alignment = alignment; 		}  		public long getAckTimestamp() { 			return ackTimestamp; 		}  		public long getDuration() { 			return duration; 		}  		public long getStateSize() { 			return stateSize; 		}  		public CheckpointDuration getCheckpointDuration() { 			return checkpointDuration; 		}  		public CheckpointAlignment getAlignment() { 			return alignment; 		}  		@Override 		public boolean equals(Object o) { 			if (this == o) { 				return true; 			} 			if (o == null || getClass() != o.getClass()) { 				return false; 			} 			CompletedSubtaskCheckpointStatistics that = (CompletedSubtaskCheckpointStatistics) o; 			return ackTimestamp == that.ackTimestamp &amp;&amp; 				duration == that.duration &amp;&amp; 				stateSize == that.stateSize &amp;&amp; 				Objects.equals(checkpointDuration, that.checkpointDuration) &amp;&amp; 				Objects.equals(alignment, that.alignment); 		}  		@Override 		public int hashCode() { 			return Objects.hash(ackTimestamp, duration, stateSize, checkpointDuration, alignment); 		}  		/** 		 * Duration of the checkpoint. 		 */ 		public static final class CheckpointDuration {  			public static final String FIELD_NAME_SYNC_DURATION = &quot;sync&quot;;  			public static final String FIELD_NAME_ASYNC_DURATION = &quot;async&quot;;  			@JsonProperty(FIELD_NAME_SYNC_DURATION) 			private final long syncDuration;  			@JsonProperty(FIELD_NAME_ASYNC_DURATION) 			private final long asyncDuration;  			@JsonCreator 			public CheckpointDuration( 					@JsonProperty(FIELD_NAME_SYNC_DURATION) long syncDuration, 					@JsonProperty(FIELD_NAME_ASYNC_DURATION) long asyncDuration) { 				this.syncDuration = syncDuration; 				this.asyncDuration = asyncDuration; 			}  			public long getSyncDuration() { 				return syncDuration; 			}  			public long getAsyncDuration() { 				return asyncDuration; 			}  			@Override 			public boolean equals(Object o) { 				if (this == o) { 					return true; 				} 				if (o == null || getClass() != o.getClass()) { 					return false; 				} 				CheckpointDuration that = (CheckpointDuration) o; 				return syncDuration == that.syncDuration &amp;&amp; 					asyncDuration == that.asyncDuration; 			}  			@Override 			public int hashCode() { 				return Objects.hash(syncDuration, asyncDuration); 			} 		}  		/** 		 * Alignment statistics of the checkpoint. 		 */ 		public static final class CheckpointAlignment {  			public static final String FIELD_NAME_ALIGNMENT_BUFFERED = &quot;buffered&quot;;  			public static final String FIELD_NAME_ALIGNMENT_DURATION = &quot;duration&quot;;  			@JsonProperty(FIELD_NAME_ALIGNMENT_BUFFERED) 			private final long alignmentBuffered;  			@JsonProperty(FIELD_NAME_ALIGNMENT_DURATION) 			private final long alignmentDuration;  			@JsonCreator 			public CheckpointAlignment( 					@JsonProperty(FIELD_NAME_ALIGNMENT_BUFFERED) long alignmentBuffered, 					@JsonProperty(FIELD_NAME_ALIGNMENT_DURATION) long alignmentDuration) { 				this.alignmentBuffered = alignmentBuffered; 				this.alignmentDuration = alignmentDuration; 			}  			public long getAlignmentBuffered() { 				return alignmentBuffered; 			}  			public long getAlignmentDuration() { 				return alignmentDuration; 			}  			@Override 			public boolean equals(Object o) { 				if (this == o) { 					return true; 				} 				if (o == null || getClass() != o.getClass()) { 					return false; 				} 				CheckpointAlignment that = (CheckpointAlignment) o; 				return alignmentBuffered == that.alignmentBuffered &amp;&amp; 					alignmentDuration == that.alignmentDuration; 			}  			@Override 			public int hashCode() { 				return Objects.hash(alignmentBuffered, alignmentDuration); 			} 		} 	}  	/** 	 * Checkpoint statistics for a pending subtask checkpoint. 	 */ 	public static final class PendingSubtaskCheckpointStatistics extends SubtaskCheckpointStatistics {  		@JsonCreator 		public PendingSubtaskCheckpointStatistics(@JsonProperty(FIELD_NAME_INDEX) int index) { 			super(index, &quot;pending_or_failed&quot;); 		} 	} }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">13717</td>
    <td align="left">https://github.com/apache/flink/blob/8068c8775ad067d75828e6360e7e0994348da9b9/flink-runtime/src/main/java/org/apache/flink/runtime/rest/messages/checkpoints/SubtaskCheckpointStatistics.java/#L31-L283</td>
    <td align="right">1</td>
    <td align="right">2261</td>
    <td align="right">13717</td>
  </tr>
  <tr valign="top">
    <td align="right">2276</td>
    <td align="left">&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: {         &quot;1. Blob&quot;: &quot;ObjectInFolderListImpl class might be a Blob code smell as it contains multiple fields and methods that operate on these fields&quot;,         &quot;2. Data Class&quot;: &quot;ObjectInFolderListImpl class might be considered a Data Class since it mainly contains getters and setters for its fields&quot;     } }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ObjectInFolderListImpl extends AbstractExtensionData implements ObjectInFolderList {      private static final long serialVersionUID = 1L;      private List objects;     private Boolean hasMoreItems = Boolean.FALSE;     private BigInteger numItems;      @Override     public List getObjects() {         if (objects == null) {             objects = new ArrayList(0);         }          return objects;     }      public void setObjects(List objects) {         this.objects = objects;     }      @Override     public Boolean hasMoreItems() {         return hasMoreItems;     }      public void setHasMoreItems(Boolean hasMoreItems) {         this.hasMoreItems = hasMoreItems;     }      @Override     public BigInteger getNumItems() {         return numItems;     }      public void setNumItems(BigInteger numItems) {         this.numItems = numItems;     }      @Override     public String toString() {         return &quot;ObjectInFolder List [objects=&quot; + objects + &quot;, has more items=&quot; + hasMoreItems + &quot;, num items=&quot;                 + numItems + &quot;]&quot; + super.toString();     } }</td>
    <td align="left">data class</td>
    <td align="left">1. blob: objectinfolderlistimpl class might be a blob code smell as it contains multiple fields and methods that operate on these fields, 2. data class: objectinfolderlistimpl class might be considered a data class since it mainly contains getters and setters for its fields</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. blob: objectinfolderlistimpl class might be a blob code smell as it contains multiple fields and methods that operate on these fields</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13775</td>
    <td align="left">https://github.com/apache/chemistry-opencmis/blob/ef8513d708e5e21710afe5cafb8b32a62a0ae532/chemistry-opencmis-commons/chemistry-opencmis-commons-impl/src/main/java/org/apache/chemistry/opencmis/commons/impl/dataobjects/ObjectInFolderListImpl.java/#L31-L75</td>
    <td align="right">1</td>
    <td align="right">2276</td>
    <td align="right">13775</td>
  </tr>
  <tr valign="top">
    <td align="right">2279</td>
    <td align="left">{         &quot;output&quot;: &quot;YES, I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Blob&quot;,         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class ConfigBoolean extends ConfigVariable {     public ConfigBoolean(OptionSpec spec)     {         super(spec);          this.enabled = false;         this.isSet = false;     }      public ConfigBoolean(OptionSpec spec, boolean enabled)     {         super(spec);         this.set(enabled);     }          private boolean enabled;     private boolean isSet;       public void set(boolean value)     {         this.enabled = value;         this.isSet = true;     }      public void set(String value)     {         this.enabled = parseValue(value);         this.isSet = true;     }      public boolean isSet()     {     	return isSet;     	}      public void addToCommandline(Commandline cmdline)     {         if (isSet)             cmdline.createArgument(true).setValue(&quot;-&quot; + spec.getFullName() + &quot;=&quot; + enabled);     }      private boolean parseValue(String value)     {         return value.toLowerCase().matches(&quot;\\s*(true|yes|on)\\s*&quot;);     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13785</td>
    <td align="left">https://github.com/apache/royale-compiler/blob/fbd9bc3b9e48c80dbd8c1d32a6f83221e314efdd/royale-ant-tasks/src/main/java/org/apache/royale/compiler/ant/config/ConfigBoolean.java/#L28-L75</td>
    <td align="right">1</td>
    <td align="right">2279</td>
    <td align="right">13785</td>
  </tr>
  <tr valign="top">
    <td align="right">2287</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Blob&quot;,         &quot;Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ReportInstance extends AbstractDTOBase {      private String id;     private ReportStatusEnum status;     private String url;     private String ownerId;     private Boolean hasDetailRows;     private ZonedDateTime completionDate;     private ZonedDateTime requestDate;      public String getId() {         return id;     }      public void setId(String id) {         this.id = id;     }      public ReportStatusEnum getStatus() {         return status;     }      public void setStatus(ReportStatusEnum status) {         this.status = status;     }      public String getUrl() {         return url;     }      public void setUrl(String url) {         this.url = url;     }      public String getOwnerId() {         return ownerId;     }      public void setOwnerId(String ownerId) {         this.ownerId = ownerId;     }      public Boolean getHasDetailRows() {         return hasDetailRows;     }      public void setHasDetailRows(Boolean hasDetailRows) {         this.hasDetailRows = hasDetailRows;     }      public ZonedDateTime getCompletionDate() {         return completionDate;     }      public void setCompletionDate(ZonedDateTime completionDate) {         this.completionDate = completionDate;     }      public ZonedDateTime getRequestDate() {         return requestDate;     }      public void setRequestDate(ZonedDateTime requestDate) {         this.requestDate = requestDate;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13890</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/api/dto/analytics/reports/ReportInstance.java/#L26-L91</td>
    <td align="right">1</td>
    <td align="right">2287</td>
    <td align="right">13890</td>
  </tr>
  <tr valign="top">
    <td align="right">2294</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TagTag extends DefineTagSupport {      private String name;      public TagTag() {     }      // Tag interface     //-------------------------------------------------------------------------     public void doTag(XMLOutput output) throws JellyTagException {         getTagLibrary().registerDynamicTag( getName(), getBody() );     }      // Properties     //-------------------------------------------------------------------------      /** @return the name of the tag to create */     public String getName() {         return name;     }      /** Sets the name of the tag to create */     public void setName(String name) {         this.name = name;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">13978</td>
    <td align="left">https://github.com/apache/commons-jelly/blob/48c008cc2328402e0976295625b32c5197ba2324/jelly-tags/define/src/main/java/org/apache/commons/jelly/tags/define/TagTag.java/#L32-L57</td>
    <td align="right">1</td>
    <td align="right">2294</td>
    <td align="right">13978</td>
  </tr>
  <tr valign="top">
    <td align="right">2301</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Blob&quot;,       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class Builder {          private File path;          private String interval;          private boolean incremental;          private File out;          private String filter;          private boolean ignoreMissingSegments;          private Builder() {             // Prevent external instantiation.         }          /**          * The path to an existing segment store. This parameter is required.          *          * @param path the path to an existing segment store.          * @return this builder.          */         public Builder withPath(File path) {             this.path = checkNotNull(path);             return this;         }          /**          * The two node records to diff specified as a record ID interval. This          * parameter is required.          *           * The interval is specified as two record IDs separated by two full          * stops ({@code ..}). In example, {@code 333dc24d-438f-4cca-8b21-3ebf67c05856:12345..46116fda-7a72-4dbc-af88-a09322a7753a:67890}.          * Instead of using a full record ID, it is possible to use the special          * placeholder {@code head}. This placeholder is translated to the          * record ID of the most recent head state.          *          * @param interval an interval between two node record IDs.          * @return this builder.          */         public Builder withInterval(String interval) {             this.interval = checkNotNull(interval);             return this;         }          /**          * Set whether or not to perform an incremental diff of the specified          * interval. An incremental diff shows every change between the two          * records at every revision available to the segment store. This          * parameter is not mandatory and defaults to {@code false}.          *          * @param incremental {@code true} to perform an incremental diff,          *                    {@code false} otherwise.          * @return this builder.          */         public Builder withIncremental(boolean incremental) {             this.incremental = incremental;             return this;         }          /**          * The file where the output of this command is stored. this parameter          * is mandatory.          *          * @param file the output file.          * @return this builder.          */         public Builder withOutput(File file) {             this.out = checkNotNull(file);             return this;         }          /**          * The path to a subtree. If specified, this parameter allows to          * restrict the diff to the specified subtree. This parameter is not          * mandatory and defaults to the entire tree.          *          * @param filter a path used as as filter for the resulting diff.          * @return this builder.          */         public Builder withFilter(String filter) {             this.filter = checkNotNull(filter);             return this;         }          /**          * Whether to ignore exceptions caused by missing segments in the          * segment store. This parameter is not mandatory and defaults to {@code          * false}.          *          * @param ignoreMissingSegments {@code true} to ignore exceptions caused          *                              by missing segments, {@code false}          *                              otherwise.          * @return this builder.          */         public Builder withIgnoreMissingSegments(boolean ignoreMissingSegments) {             this.ignoreMissingSegments = ignoreMissingSegments;             return this;         }          /**          * Create an executable version of the {@link Diff} command.          *          * @return an instance of {@link Runnable}.          */         public Diff build() {             checkNotNull(path);             checkNotNull(interval);             checkNotNull(out);             checkNotNull(filter);             return new Diff(this);         }      }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14036</td>
    <td align="left">https://github.com/apache/jackrabbit-oak/blob/fa85f54a065e01c0a1cb8c03af74194fdf521ddd/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/tool/Diff.java/#L56-L171</td>
    <td align="right">1</td>
    <td align="right">2301</td>
    <td align="right">14036</td>
  </tr>
  <tr valign="top">
    <td align="right">2323</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Blob&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class AbstractControllerService extends AbstractConfigurableComponent implements ControllerService {      private String identifier;     private ControllerServiceLookup serviceLookup;     private ComponentLog logger;     private StateManager stateManager;     private volatile ConfigurationContext configurationContext;     private volatile boolean enabled = false;      @Override     public final void initialize(final ControllerServiceInitializationContext context) throws InitializationException {         this.identifier = context.getIdentifier();         serviceLookup = context.getControllerServiceLookup();         logger = context.getLogger();         stateManager = context.getStateManager();         init(context);     }      @Override     public String getIdentifier() {         return identifier;     }      /**      * @return the {@link ControllerServiceLookup} that was passed to the      * {@link #init(ControllerServiceInitializationContext)} method      */     protected final ControllerServiceLookup getControllerServiceLookup() {         return serviceLookup;     }      /**      * Provides a mechanism by which subclasses can perform initialization of      * the Controller Service before it is scheduled to be run      *      * @param config of initialization context      * @throws InitializationException if unable to init      */     protected void init(final ControllerServiceInitializationContext config) throws InitializationException {     }      @OnEnabled     public final void enabled() {         this.enabled = true;     }      @OnDisabled     public final void disabled() {         this.enabled = false;     }      public boolean isEnabled() {         return this.enabled;     }      /**      * @return the logger that has been provided to the component by the      * framework in its initialize method      */     protected ComponentLog getLogger() {         return logger;     }      /**      * @return the StateManager that can be used to store and retrieve state for this Controller Service      */     protected StateManager getStateManager() {         return stateManager;     }      @OnEnabled     public final void abstractStoreConfigContext(final ConfigurationContext configContext) {         this.configurationContext = configContext;     }      @OnDisabled     public final void abstractClearConfigContext() {         this.configurationContext = null;     }      protected ConfigurationContext getConfigurationContext() {         final ConfigurationContext context = this.configurationContext;         if (context == null) {             throw new IllegalStateException(&quot;No Configuration Context exists&quot;);         }          return configurationContext;     }      protected PropertyValue getProperty(final PropertyDescriptor descriptor) {         return getConfigurationContext().getProperty(descriptor);     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">14132</td>
    <td align="left">https://github.com/apache/nifi/blob/c8eff590efa3babcda0b755009224dcac168708b/nifi-api/src/main/java/org/apache/nifi/controller/AbstractControllerService.java/#L28-L120</td>
    <td align="right">1</td>
    <td align="right">2323</td>
    <td align="right">14132</td>
  </tr>
  <tr valign="top">
    <td align="right">2325</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TransportConnectionState extends org.apache.activemq.state.ConnectionState {      private ConnectionContext context;     private TransportConnection connection;     private AtomicInteger referenceCounter = new AtomicInteger();     private final Object connectionMutex = new Object();      public TransportConnectionState(ConnectionInfo info, TransportConnection transportConnection) {         super(info);         connection = transportConnection;     }      public ConnectionContext getContext() {         return context;     }      public TransportConnection getConnection() {         return connection;     }      public void setContext(ConnectionContext context) {         this.context = context;     }      public void setConnection(TransportConnection connection) {         this.connection = connection;     }      public int incrementReference() {         return referenceCounter.incrementAndGet();     }      public int decrementReference() {         return referenceCounter.decrementAndGet();     }  	public AtomicInteger getReferenceCounter() { 		return referenceCounter; 	}  	public void setReferenceCounter(AtomicInteger referenceCounter) { 		this.referenceCounter = referenceCounter; 	}  	public Object getConnectionMutex() { 		return connectionMutex; 	} }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14140</td>
    <td align="left">https://github.com/apache/activemq/blob/ccf56875b0660214e0a61bd2f8adc418143551fc/activemq-broker/src/main/java/org/apache/activemq/broker/TransportConnectionState.java/#L27-L74</td>
    <td align="right">1</td>
    <td align="right">2325</td>
    <td align="right">14140</td>
  </tr>
  <tr valign="top">
    <td align="right">2333</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;the bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class HistoryClientService extends AbstractService {    private static final Log LOG = LogFactory.getLog(HistoryClientService.class);    private HSClientProtocol protocolHandler;   private Server server;   private WebApp webApp;   private InetSocketAddress bindAddress;   private HistoryContext history;   private JHSDelegationTokenSecretManager jhsDTSecretManager;      public HistoryClientService(HistoryContext history,       JHSDelegationTokenSecretManager jhsDTSecretManager) {     super(&quot;HistoryClientService&quot;);     this.history = history;     this.protocolHandler = new HSClientProtocolHandler();     this.jhsDTSecretManager = jhsDTSecretManager;   }    protected void serviceStart() throws Exception {     Configuration conf = getConfig();     YarnRPC rpc = YarnRPC.create(conf);     initializeWebApp(conf);     InetSocketAddress address = conf.getSocketAddr(         JHAdminConfig.MR_HISTORY_BIND_HOST,         JHAdminConfig.MR_HISTORY_ADDRESS,         JHAdminConfig.DEFAULT_MR_HISTORY_ADDRESS,         JHAdminConfig.DEFAULT_MR_HISTORY_PORT);      server =         rpc.getServer(HSClientProtocol.class, protocolHandler, address,             conf, jhsDTSecretManager,             conf.getInt(JHAdminConfig.MR_HISTORY_CLIENT_THREAD_COUNT,                 JHAdminConfig.DEFAULT_MR_HISTORY_CLIENT_THREAD_COUNT));      // Enable service authorization?     if (conf.getBoolean(         CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHORIZATION,         false)) {       server.refreshServiceAcl(conf, new ClientHSPolicyProvider());     }          server.start();     this.bindAddress = conf.updateConnectAddr(JHAdminConfig.MR_HISTORY_BIND_HOST,                                               JHAdminConfig.MR_HISTORY_ADDRESS,                                               JHAdminConfig.DEFAULT_MR_HISTORY_ADDRESS,                                               server.getListenerAddress());     LOG.info(&quot;Instantiated HistoryClientService at &quot; + this.bindAddress);      super.serviceStart();   }    @VisibleForTesting   protected void initializeWebApp(Configuration conf) {     webApp = new HsWebApp(history);     InetSocketAddress bindAddress = MRWebAppUtil.getJHSWebBindAddress(conf);     // NOTE: there should be a .at(InetSocketAddress)     WebApps         .$for(&quot;jobhistory&quot;, HistoryClientService.class, this, &quot;ws&quot;)         .with(conf)         .withHttpSpnegoKeytabKey(             JHAdminConfig.MR_WEBAPP_SPNEGO_KEYTAB_FILE_KEY)         .withHttpSpnegoPrincipalKey(             JHAdminConfig.MR_WEBAPP_SPNEGO_USER_NAME_KEY)         .at(NetUtils.getHostPortString(bindAddress)).start(webApp);          String connectHost = MRWebAppUtil.getJHSWebappURLWithoutScheme(conf).split(&quot;:&quot;)[0];     MRWebAppUtil.setJHSWebappURLWithoutScheme(conf,         connectHost + &quot;:&quot; + webApp.getListenerAddress().getPort());   }    @Override   protected void serviceStop() throws Exception {     if (server != null) {       server.stop();     }     if (webApp != null) {       webApp.stop();     }     super.serviceStop();   }    @Private   public MRClientProtocol getClientHandler() {     return this.protocolHandler;   }    @Private   public InetSocketAddress getBindAddress() {     return this.bindAddress;   }    private class HSClientProtocolHandler implements HSClientProtocol {      private RecordFactory recordFactory = RecordFactoryProvider.getRecordFactory(null);      public InetSocketAddress getConnectAddress() {       return getBindAddress();     }          private Job verifyAndGetJob(final JobId jobID) throws IOException {       UserGroupInformation loginUgi = null;       Job job = null;       try {         loginUgi = UserGroupInformation.getLoginUser();         job = loginUgi.doAs(new PrivilegedExceptionAction() {            @Override           public Job run() throws Exception {             Job job = history.getJob(jobID);             return job;           }         });       } catch (InterruptedException e) {         throw new IOException(e);       }       if (job != null) {         JobACL operation = JobACL.VIEW_JOB;         checkAccess(job, operation);       }       return job;     }      @Override     public GetCountersResponse getCounters(GetCountersRequest request)         throws IOException {       JobId jobId = request.getJobId();       Job job = verifyAndGetJob(jobId);       GetCountersResponse response = recordFactory.newRecordInstance(GetCountersResponse.class);       response.setCounters(TypeConverter.toYarn(job.getAllCounters()));       return response;     }      @Override     public GetJobReportResponse getJobReport(GetJobReportRequest request)         throws IOException {       JobId jobId = request.getJobId();       Job job = verifyAndGetJob(jobId);       GetJobReportResponse response = recordFactory.newRecordInstance(GetJobReportResponse.class);       if (job != null) {         response.setJobReport(job.getReport());       }       else {         response.setJobReport(null);       }       return response;     }      @Override     public GetTaskAttemptReportResponse getTaskAttemptReport(         GetTaskAttemptReportRequest request) throws IOException {       TaskAttemptId taskAttemptId = request.getTaskAttemptId();       Job job = verifyAndGetJob(taskAttemptId.getTaskId().getJobId());       GetTaskAttemptReportResponse response = recordFactory.newRecordInstance(GetTaskAttemptReportResponse.class);       response.setTaskAttemptReport(job.getTask(taskAttemptId.getTaskId()).getAttempt(taskAttemptId).getReport());       return response;     }      @Override     public GetTaskReportResponse getTaskReport(GetTaskReportRequest request)         throws IOException {       TaskId taskId = request.getTaskId();       Job job = verifyAndGetJob(taskId.getJobId());       GetTaskReportResponse response = recordFactory.newRecordInstance(GetTaskReportResponse.class);       response.setTaskReport(job.getTask(taskId).getReport());       return response;     }      @Override     public GetTaskAttemptCompletionEventsResponse         getTaskAttemptCompletionEvents(             GetTaskAttemptCompletionEventsRequest request) throws IOException {       JobId jobId = request.getJobId();       int fromEventId = request.getFromEventId();       int maxEvents = request.getMaxEvents();        Job job = verifyAndGetJob(jobId);       GetTaskAttemptCompletionEventsResponse response = recordFactory.newRecordInstance(GetTaskAttemptCompletionEventsResponse.class);       response.addAllCompletionEvents(Arrays.asList(job.getTaskAttemptCompletionEvents(fromEventId, maxEvents)));       return response;     }      @Override     public KillJobResponse killJob(KillJobRequest request) throws IOException {       throw new IOException(&quot;Invalid operation on completed job&quot;);     }      @Override     public KillTaskResponse killTask(KillTaskRequest request)         throws IOException {       throw new IOException(&quot;Invalid operation on completed job&quot;);     }      @Override     public KillTaskAttemptResponse killTaskAttempt(         KillTaskAttemptRequest request) throws IOException {       throw new IOException(&quot;Invalid operation on completed job&quot;);     }      @Override     public GetDiagnosticsResponse getDiagnostics(GetDiagnosticsRequest request)         throws IOException {       TaskAttemptId taskAttemptId = request.getTaskAttemptId();        Job job = verifyAndGetJob(taskAttemptId.getTaskId().getJobId());        GetDiagnosticsResponse response = recordFactory.newRecordInstance(GetDiagnosticsResponse.class);       response.addAllDiagnostics(job.getTask(taskAttemptId.getTaskId()).getAttempt(taskAttemptId).getDiagnostics());       return response;     }      @Override     public FailTaskAttemptResponse failTaskAttempt(         FailTaskAttemptRequest request) throws IOException {       throw new IOException(&quot;Invalid operation on completed job&quot;);     }      @Override     public GetTaskReportsResponse getTaskReports(GetTaskReportsRequest request)         throws IOException {       JobId jobId = request.getJobId();       TaskType taskType = request.getTaskType();        GetTaskReportsResponse response = recordFactory.newRecordInstance(GetTaskReportsResponse.class);       Job job = verifyAndGetJob(jobId);       Collection tasks = job.getTasks(taskType).values();       for (Task task : tasks) {         response.addTaskReport(task.getReport());       }       return response;     }          @Override     public GetDelegationTokenResponse getDelegationToken(         GetDelegationTokenRequest request) throws IOException {        UserGroupInformation ugi = UserGroupInformation.getCurrentUser();        // Verify that the connection is kerberos authenticated         if (!isAllowedDelegationTokenOp()) {           throw new IOException(               &quot;Delegation Token can be issued only with kerberos authentication&quot;);         }        GetDelegationTokenResponse response = recordFactory.newRecordInstance(           GetDelegationTokenResponse.class);        String user = ugi.getUserName();       Text owner = new Text(user);       Text realUser = null;       if (ugi.getRealUser() != null) {         realUser = new Text(ugi.getRealUser().getUserName());       }       MRDelegationTokenIdentifier tokenIdentifier =           new MRDelegationTokenIdentifier(owner, new Text(             request.getRenewer()), realUser);       Token realJHSToken =           new Token(tokenIdentifier,               jhsDTSecretManager);       org.apache.hadoop.yarn.api.records.Token mrDToken =           org.apache.hadoop.yarn.api.records.Token.newInstance(             realJHSToken.getIdentifier(), realJHSToken.getKind().toString(),             realJHSToken.getPassword(), realJHSToken.getService().toString());       response.setDelegationToken(mrDToken);       return response;     }      @Override     public RenewDelegationTokenResponse renewDelegationToken(         RenewDelegationTokenRequest request) throws IOException {         if (!isAllowedDelegationTokenOp()) {           throw new IOException(               &quot;Delegation Token can be renewed only with kerberos authentication&quot;);         }          org.apache.hadoop.yarn.api.records.Token protoToken = request.getDelegationToken();         Token token =             new Token(                 protoToken.getIdentifier().array(), protoToken.getPassword()                     .array(), new Text(protoToken.getKind()), new Text(                     protoToken.getService()));          String user = UserGroupInformation.getCurrentUser().getShortUserName();         long nextExpTime = jhsDTSecretManager.renewToken(token, user);         RenewDelegationTokenResponse renewResponse = Records             .newRecord(RenewDelegationTokenResponse.class);         renewResponse.setNextExpirationTime(nextExpTime);         return renewResponse;     }      @Override     public CancelDelegationTokenResponse cancelDelegationToken(         CancelDelegationTokenRequest request) throws IOException {         if (!isAllowedDelegationTokenOp()) {           throw new IOException(               &quot;Delegation Token can be cancelled only with kerberos authentication&quot;);         }          org.apache.hadoop.yarn.api.records.Token protoToken = request.getDelegationToken();         Token token =             new Token(                 protoToken.getIdentifier().array(), protoToken.getPassword()                     .array(), new Text(protoToken.getKind()), new Text(                     protoToken.getService()));          String user = UserGroupInformation.getCurrentUser().getUserName();         jhsDTSecretManager.cancelToken(token, user);         return Records.newRecord(CancelDelegationTokenResponse.class);     }      private void checkAccess(Job job, JobACL jobOperation)         throws IOException {        UserGroupInformation callerUGI;       callerUGI = UserGroupInformation.getCurrentUser();        if (!job.checkAccess(callerUGI, jobOperation)) {         throw new IOException(new AccessControlException(&quot;User &quot;             + callerUGI.getShortUserName() + &quot; cannot perform operation &quot;             + jobOperation.name() + &quot; on &quot; + job.getID()));       }     }      private boolean isAllowedDelegationTokenOp() throws IOException {       if (UserGroupInformation.isSecurityEnabled()) {         return EnumSet.of(AuthenticationMethod.KERBEROS,                           AuthenticationMethod.KERBEROS_SSL,                           AuthenticationMethod.CERTIFICATE)             .contains(UserGroupInformation.getCurrentUser()                     .getRealAuthenticationMethod());       } else {         return true;       }     }    } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14159</td>
    <td align="left">https://github.com/apache/hadoop-common/blob/42a61a4fbc88303913c4681f0d40ffcc737e70b5/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-hs/src/main/java/org/apache/hadoop/mapreduce/v2/hs/HistoryClientService.java/#L99-L435</td>
    <td align="right">1</td>
    <td align="right">2333</td>
    <td align="right">14159</td>
  </tr>
  <tr valign="top">
    <td align="right">2341</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{             &quot;response&quot;: &quot;YES I found bad smells&quot;,             &quot;detected_bad_smells&quot;: [                 &quot;Blob&quot;,                 &quot;Data Class&quot;             ]         }  </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
final class AvlNode&gt; {     AvlNode parent = null;     AvlNode left = null;     AvlNode right = null;      int height = 0;     int balance = 0;     T value = null;       AvlNode( AvlNode parent, T value )     {         this.parent = parent;         this.value = value;     }       public AvlNode reset( AvlNode parent, T value )     {         this.parent = parent;         left = null;         right = null;          height = 0;         this.value = value;          return this;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14178</td>
    <td align="left">https://github.com/apache/directory-server/blob/310007cc1c7eb5415f93bed67d5553bc70980820/core-avl/src/main/java/org/apache/directory/server/core/avltree/avl/AvlNode.java/#L29-L58</td>
    <td align="right">1</td>
    <td align="right">2341</td>
    <td align="right">14178</td>
  </tr>
  <tr valign="top">
    <td align="right">2366</td>
    <td align="left">&nbsp;&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Named @RequestScoped public class UserUpdateBean {     private String name;          private String surname;          private int age;          private String userName;          private String password;          private @Inject @Default UserController controller;          private @Inject @Default SessionTracker tracker;          public UserUpdateBean()     {              }      public String showInfo()     {         //Just show how can access session webbeans         User user = this.controller.getUser(tracker.getUser().getId());                  setName(user.getName());         setSurname(user.getSurname());         setAge(user.getAge());         setUserName(user.getUserName());         setPassword(user.getPassword());                          return &quot;toUpdatePage&quot;;     }      public String clear()     {         setName(&quot;&quot;);         setSurname(&quot;&quot;);         setAge(0);         setUserName(&quot;&quot;);         setPassword(&quot;&quot;);                  return null;     }          public String update()     {         this.controller.updateUserInfo(tracker.getUser().getId(), name, surname, age, userName, password);                  JSFUtility.addInfoMessage(&quot;Personal information is succesfully updated.&quot;, &quot;&quot;);                  return null;     }          /**      * @return the name      */     public String getName()     {         return name;     }      /**      * @param name the name to set      */     public void setName(String name)     {         this.name = name;     }      /**      * @return the surname      */     public String getSurname()     {         return surname;     }      /**      * @param surname the surname to set      */     public void setSurname(String surname)     {         this.surname = surname;     }      /**      * @return the age      */     public int getAge()     {         return age;     }      /**      * @param age the age to set      */     public void setAge(int age)     {         this.age = age;     }      /**      * @return the userName      */     public String getUserName()     {         return userName;     }      /**      * @param userName the userName to set      */     public void setUserName(String userName)     {         this.userName = userName;     }      /**      * @return the password      */     public String getPassword()     {         return password;     }      /**      * @param password the password to set      */     public void setPassword(String password)     {         this.password = password;     }           }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14296</td>
    <td align="left">https://github.com/apache/openwebbeans/blob/7831798861478a035c9e9dcca151b5a67e4a28a3/samples/reservation/src/main/java/org/apache/webbeans/reservation/beans/user/UserUpdateBean.java/#L31-L169</td>
    <td align="right">1</td>
    <td align="right">2366</td>
    <td align="right">14296</td>
  </tr>
  <tr valign="top">
    <td align="right">2378</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;response&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_smells&quot;: [             &quot;Blob&quot;,             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    static class Cause {         final Tuple tuple ;         final Mapping     mapping ;          public Cause(Tuple tuple, Mapping mapping) {             super() ;             this.tuple = tuple ;             this.mapping = mapping ;         }     }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14333</td>
    <td align="left">https://github.com/apache/jena/blob/1cca775bbf0bb0fd3ee8ac55e31f0f30cdde3b77/jena-arq/src/main/java/org/apache/jena/sparql/util/IsoMatcher.java/#L113-L122</td>
    <td align="right">1</td>
    <td align="right">2378</td>
    <td align="right">14333</td>
  </tr>
  <tr valign="top">
    <td align="right">2387</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells. the bad smells are: 1. Blob, 2. Long Method&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private boolean fetchNext() throws IgniteCheckedException {         if (data == null)             return false;          try {             if (!data.next()) {                 close();                  return false;             }              if (res != null) {                 Value[] values = res.currentRow();                  for (int c = 0; c &lt; row.length; c++) {                     Value val = values[c];                      if (val instanceof GridH2ValueCacheObject) {                         GridH2ValueCacheObject valCacheObj = (GridH2ValueCacheObject)values[c];                          row[c] = valCacheObj.getObject(true);                     }                     else                         row[c] = val.getObject();                 }             }             else {                 for (int c = 0; c &lt; row.length; c++)                     row[c] = data.getObject(c + 1);             }              return true;         }         catch (SQLException e) {             throw new IgniteSQLException(e);         }     }</td>
    <td align="left">long method</td>
    <td align="left">1. blob, 2. long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14351</td>
    <td align="left">https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java/#L101-L137</td>
    <td align="right">1</td>
    <td align="right">2387</td>
    <td align="right">14351</td>
  </tr>
  <tr valign="top">
    <td align="right">2388</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&quot;message&quot;: &quot;YES I found bad smells. The bad smells are: Blob, Data Class, Long Method&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private boolean fetchNext() throws IgniteCheckedException {         if (data == null)             return false;          try {             if (!data.next()) {                 close();                  return false;             }              if (res != null) {                 Value[] values = res.currentRow();                  for (int c = 0; c &lt; row.length; c++) {                     Value val = values[c];                      if (val instanceof GridH2ValueCacheObject) {                         GridH2ValueCacheObject valCacheObj = (GridH2ValueCacheObject)values[c];                          row[c] = valCacheObj.getObject(true);                     }                     else                         row[c] = val.getObject();                 }             }             else {                 for (int c = 0; c &lt; row.length; c++)                     row[c] = data.getObject(c + 1);             }              return true;         }         catch (SQLException e) {             throw new IgniteSQLException(e);         }     }</td>
    <td align="left">feature envy</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  data class,  long method</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">14352</td>
    <td align="left">https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java/#L101-L137</td>
    <td align="right">1</td>
    <td align="right">2388</td>
    <td align="right">14352</td>
  </tr>
  <tr valign="top">
    <td align="right">2406</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;,  &quot;bad smells are&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Customer223 {  	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id; 	private String firstName; 	private String lastName;  	protected Customer223() {}  	public Customer223(String firstName, String lastName) { 		this.firstName = firstName; 		this.lastName = lastName; 	}  	@Override 	public String toString() { 		return String.format(&quot;Customer223[id=%d, firstName='%s', lastName='%s']&quot;, id, firstName, lastName); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">14388</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer223.java/#L8-L27</td>
    <td align="right">1</td>
    <td align="right">2406</td>
    <td align="right">14388</td>
  </tr>
  <tr valign="top">
    <td align="right">2408</td>
    <td align="left">{&quot;response&quot;:&quot;YES I found bad smells the bad smells are: 1. Blob&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class ShareContent         implements ShareModel {     private final Uri contentUrl;     private final List peopleIds;     private final String placeId;     private final String pageId;     private final String ref;     private final ShareHashtag hashtag;      protected ShareContent(final Builder builder) {         super();         this.contentUrl = builder.contentUrl;         this.peopleIds = builder.peopleIds;         this.placeId = builder.placeId;         this.pageId = builder.pageId;         this.ref = builder.ref;         this.hashtag = builder.hashtag;     }      protected ShareContent(final Parcel in) {         this.contentUrl = in.readParcelable(Uri.class.getClassLoader());         this.peopleIds = readUnmodifiableStringList(in);         this.placeId = in.readString();         this.pageId = in.readString();         this.ref = in.readString();         this.hashtag = new ShareHashtag.Builder().readFrom(in).build();     }      /**      * URL for the content being shared.  This URL will be checked for app link meta tags for      * linking in platform specific ways.      *       * See documentation for App Links.      *      * @return {@link android.net.Uri} representation of the content link.      */     @Nullable     public Uri getContentUrl() {         return this.contentUrl;     }      /**      * List of Ids for taggable people to tag with this content.      *       * See documentation for      *       * Taggable Friends.      *      * @return {@link java.util.List} of Ids for people to tag.      */     @Nullable     public List getPeopleIds() {         return this.peopleIds;     }      /**      * The Id for a place to tag with this content.      *      * @return The Id for the place to tag.      */     @Nullable     public String getPlaceId() {         return this.placeId;     }      /**      * For shares into Messenger, this pageID will be used to map the app to page and attach      * attribution to the share.      *      * @return The ID of the Facebook page this share is associated with.      */     @Nullable     public String getPageId() {         return this.pageId;     }      /**      * A value to be added to the referrer URL when a person follows a link from this shared      * content on feed.      *      * @return The ref for the content.      */     @Nullable     public String getRef() {         return this.ref;     }      /**      * Gets the ShareHashtag, if one has been set, for this content.      *      * @return The hashtag      */     @Nullable     public ShareHashtag getShareHashtag() {         return this.hashtag;     }      public int describeContents() {         return 0;     }      public void writeToParcel(final Parcel out, final int flags) {         out.writeParcelable(this.contentUrl, 0);         out.writeStringList(this.peopleIds);         out.writeString(this.placeId);         out.writeString(this.pageId);         out.writeString(this.ref);         out.writeParcelable(this.hashtag, 0);     }      private List readUnmodifiableStringList(final Parcel in) {         final List list = new ArrayList();         in.readStringList(list);         return (list.size() == 0 ? null : Collections.unmodifiableList(list));     }      /**      * Abstract builder for {@link com.facebook.share.model.ShareContent}      */     public abstract static class Builder             implements ShareModelBuilder {         private Uri contentUrl;         private List peopleIds;         private String placeId;         private String pageId;         private String ref;         private ShareHashtag hashtag;          /**          * Set the URL for the content being shared.          *          * @param contentUrl {@link android.net.Uri} representation of the content link.          * @return The builder.          */         public E setContentUrl(@Nullable final Uri contentUrl) {             this.contentUrl = contentUrl;             return (E) this;         }          /**          * Set the list of Ids for taggable people to tag with this content.          *          * @param peopleIds {@link java.util.List} of Ids for people to tag.          * @return The builder.          */         public E setPeopleIds(@Nullable final List peopleIds) {             this.peopleIds = (peopleIds == null ? null : Collections.unmodifiableList(peopleIds));             return (E) this;         }          /**          * Set the Id for a place to tag with this content.          *          * @param placeId The Id for the place to tag.          * @return The builder.          */         public E setPlaceId(@Nullable final String placeId) {             this.placeId = placeId;             return (E) this;         }          /**          * Set the Id of the Facebook page this share is associated with.          *          * @param pageId The Id for the Page          * @return The builder          */         public E setPageId(@Nullable final String pageId) {             this.pageId = pageId;             return (E) this;         }          /**          * Set the value to be added to the referrer URL when a person follows a link from this          * shared content on feed.          *          * @param ref The ref for the content.          * @return The builder.          */         public E setRef(@Nullable final String ref) {             this.ref = ref;             return (E) this;         }          /**          * Set the ShareHashtag for this content          *          * @param shareHashtag The hashtag for this content          * @return The builder          */         public E setShareHashtag(@Nullable final ShareHashtag shareHashtag) {             this.hashtag = shareHashtag;             return (E) this;         }          @Override         public E readFrom(final P content) {             if (content == null) {                 return (E) this;             }             return (E) this                     .setContentUrl(content.getContentUrl())                     .setPeopleIds(content.getPeopleIds())                     .setPlaceId(content.getPlaceId())                     .setPageId(content.getPageId())                     .setRef(content.getRef());         }     } }</td>
    <td align="left">data class</td>
    <td align="left">1. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">14390</td>
    <td align="left">https://github.com/facebook/facebook-android-sdk/blob/81ca34a2a0f7ee391f90c6051c5a22e5bc8663c2/facebook-common/src/main/java/com/facebook/share/model/ShareContent.java/#L35-L243</td>
    <td align="right">1</td>
    <td align="right">2408</td>
    <td align="right">14390</td>
  </tr>
  <tr valign="top">
    <td align="right">2414</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [         &quot;Blob&quot;,         &quot;Data Class&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Subchannel extends Pipe { 	/** 	 *  	 * Number of fuel rods contained within. 	 *  	 *  	 */ 	private int numRods;  	/** 	 *  	 * Diameter of the subchannel fuel rods (this assumes uniform rod sizes). 	 *  	 *  	 */ 	private double rodDiameter;  	/** 	 *  	 * Pitch of the fuel rod bundle (distance between adjacent rod centers). 	 *  	 *  	 */ 	private double pitch;  	/** 	 *  	 * Nullary constructor. 	 *  	 *  	 */ 	public Subchannel() {  		// Set the name, description and ID. 		setName(&quot;Subchannel 1&quot;); 		setDescription(&quot;A subchannel plant component for reactors&quot;); 		setId(1);  		// Set the default number of rods, rod diameter and pitch. 		setNumRods(1); 		setRodDiameter(1.0); 		setPitch(1.5); 		// Note: Pitch must always be set after diameter, as setPitch method 		// checks that pitch &gt;= rodDiameter.  		return; 	}  	/** 	 *  	 * Parameterized constructor. 	 *  	 *  	 * @param numRods 	 *             	 *            Number of rods contained. 	 *             	 * @param rodDiameter 	 *             	 *            Diameter of the (uniformly-sized) fuel rods. 	 *             	 * @param pitch 	 *             	 *            Pitch of the fuel rods. 	 *             	 */ 	public Subchannel(int numRods, double rodDiameter, double pitch) {  		// Set the name, description and ID. 		setName(&quot;Subchannel 1&quot;); 		setDescription(&quot;A subchannel plant component for reactors&quot;); 		setId(1);  		// Set the default number of rods, rod diameter and pitch. 		setNumRods(numRods); 		setRodDiameter(rodDiameter); 		setPitch(pitch);  		return; 	}  	/** 	 * @return the numRods 	 */ 	public int getNumRods() { 		return numRods; 	}  	/** 	 * @param numRods 	 *            the numRods to set 	 */ 	public void setNumRods(int numRods) {  		// Check the input is valid. 		if (numRods &gt;= 1) { 			this.numRods = numRods; 		} else { 			throw new InvalidParameterException(&quot;Subchannel error: The number &quot; 					+ &quot;of rods must greater than or equal to 1.&quot;); 		} 		return; 	}  	/** 	 * @return the rodDiameter 	 */ 	public double getRodDiameter() { 		return rodDiameter; 	}  	/** 	 * @param rodDiameter 	 *            the rodDiameter to set 	 */ 	public void setRodDiameter(double rodDiameter) {  		// Check the input is valid. 		if (rodDiameter &gt; 0) { 			this.rodDiameter = rodDiameter; 		} else { 			throw new InvalidParameterException(&quot;Subchannel error: The rod &quot; 					+ &quot;diameter must be non-negative.&quot;); 		} 		return; 	}  	/** 	 * @return the pitch 	 */ 	public double getPitch() { 		return pitch; 	}  	/** 	 * @param pitch 	 *            the pitch to set 	 */ 	public void setPitch(double pitch) {  		// Check that the input is valid. 		if (pitch &gt;= rodDiameter) { 			this.pitch = pitch; 		} else { 			throw new InvalidParameterException(&quot;Subchannel error: The rod &quot; 					+ &quot;pitch cannot be smaller than the rod diameter.&quot;); 		} 	}  	/** 	 *  	 * Performs an equality check between two Objects. 	 *  	 *  	 * @param otherObject 	 *             	 *            The other Object to compare against. 	 *             	 * @return  	 *         Returns true if the two objects are equal, otherwise false. 	 *          	 */ 	@Override 	public boolean equals(Object otherObject) {  		// By default, the objects are not equivalent. 		boolean equals = false;  		// Check the reference. 		if (this == otherObject) { 			equals = true; 		} 		// Check the information stored in the other object. 		else if (otherObject != null &amp;&amp; otherObject instanceof Subchannel) {  			// Cast the other object. 			Subchannel component = (Subchannel) otherObject;  			// Compare all the variables. (Save the biggest for last; Java 			// should 			// short-circuit the logical operators as soon as a mismatch is 			// found) 			equals = (super.equals(component) &amp;&amp; numRods == component.numRods 					&amp;&amp; rodDiameter == component.rodDiameter &amp;&amp; pitch == component.pitch); 		}  		return equals; 	}  	/** 	 *  	 * Performs a deep copy and returns a newly instantiated Object. 	 *  	 *  	 * @return  	 *         The newly instantiated Object. 	 *          	 */ 	@Override 	public Object clone() {  		// Initialize a new object. 		Subchannel object = new Subchannel();  		// Copy the contents from this one. 		object.copy(this);  		// Return the newly instantiated object. 		return object; 	}  	/** 	 *  	 * Deep copies the contents of otherObject. 	 *  	 *  	 * @param otherObject 	 *             	 *            The other object to copy the contents from. 	 *             	 */ 	public void copy(Subchannel otherObject) {  		// Check the otherObject is valid. 		if (otherObject == null) { 			return; 		} 		// Copy the other object. 		super.copy(otherObject); 		numRods = otherObject.numRods; 		rodDiameter = otherObject.rodDiameter; 		pitch = otherObject.pitch;  		return; 	}  	/** 	 *  	 * Returns the hashCode of the object. 	 *  	 *  	 * @return  	 *         The hashCode of the Object. 	 *          	 */ 	@Override 	public int hashCode() {  		// Call the super's hashCode. 		int hash = super.hashCode();  		// Add local hashes. 		hash = 31 * hash + numRods; 		hash = 31 * hash + new Double(rodDiameter).hashCode(); 		hash = 31 * hash + new Double(pitch).hashCode();  		return hash; 	}  	/** 	 *  	 * Accepts PlantComponentVisitors to reveal the type of a PlantComponent. 	 *  	 *  	 * @param visitor 	 *             	 *            The PlantComponent's visitor. 	 *             	 */ 	@Override 	public void accept(IPlantComponentVisitor visitor) {  		// Only accept valid visitors. 		if (visitor != null) { 			visitor.visit(this); 		} 		return; 	} }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14415</td>
    <td align="left">https://github.com/eclipse/ice/blob/3f6e0265f5b476ff90a660397ce83992944142c4/org.eclipse.ice.reactor.plant/src/org/eclipse/ice/reactor/plant/Subchannel.java/#L25-L303</td>
    <td align="right">1</td>
    <td align="right">2414</td>
    <td align="right">14415</td>
  </tr>
  <tr valign="top">
    <td align="right">2425</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;,  &quot;the bad smells are&quot;: [&quot;1. Blob&quot;, &quot;2. Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DataSourceLoginService extends AbstractLoginService {     private static final Logger LOG = Log.getLogger(DataSourceLoginService.class);      private String _jndiName = &quot;javax.sql.DataSource/default&quot;;     private DataSource _datasource;     private Server _server;     private String _userTableName = &quot;users&quot;;     private String _userTableKey = &quot;id&quot;;     private String _userTableUserField = &quot;username&quot;;     private String _userTablePasswordField = &quot;pwd&quot;;     private String _roleTableName = &quot;roles&quot;;     private String _roleTableKey = &quot;id&quot;;     private String _roleTableRoleField = &quot;role&quot;;     private String _userRoleTableName = &quot;user_roles&quot;;     private String _userRoleTableUserKey = &quot;user_id&quot;;     private String _userRoleTableRoleKey = &quot;role_id&quot;;     private String _userSql;     private String _roleSql;     private boolean _createTables = false;               /**      * DBUser      */     public class DBUserPrincipal extends UserPrincipal     {         private int _key;                  public DBUserPrincipal(String name, Credential credential, int key)         {             super(name, credential);             _key = key;         }                  public int getKey ()         {             return _key;         }              }      /* ------------------------------------------------------------ */     public DataSourceLoginService()     {     }      /* ------------------------------------------------------------ */     public DataSourceLoginService(String name)     {         setName(name);     }      /* ------------------------------------------------------------ */     public DataSourceLoginService(String name, IdentityService identityService)     {         setName(name);         setIdentityService(identityService);     }      /* ------------------------------------------------------------ */     public void setJndiName (String jndi)     {         _jndiName = jndi;     }      /* ------------------------------------------------------------ */     public String getJndiName ()     {         return _jndiName;     }      /* ------------------------------------------------------------ */     public void setServer (Server server)     {         _server=server;     }      /* ------------------------------------------------------------ */     public Server getServer()     {         return _server;     }      /* ------------------------------------------------------------ */     public void setCreateTables(boolean createTables)     {         _createTables = createTables;     }      /* ------------------------------------------------------------ */     public boolean getCreateTables()     {         return _createTables;     }      /* ------------------------------------------------------------ */     public void setUserTableName (String name)     {         _userTableName=name;     }      /* ------------------------------------------------------------ */     public String getUserTableName()     {         return _userTableName;     }      /* ------------------------------------------------------------ */     public String getUserTableKey()     {         return _userTableKey;     }       /* ------------------------------------------------------------ */     public void setUserTableKey(String tableKey)     {         _userTableKey = tableKey;     }       /* ------------------------------------------------------------ */     public String getUserTableUserField()     {         return _userTableUserField;     }       /* ------------------------------------------------------------ */     public void setUserTableUserField(String tableUserField)     {         _userTableUserField = tableUserField;     }       /* ------------------------------------------------------------ */     public String getUserTablePasswordField()     {         return _userTablePasswordField;     }       /* ------------------------------------------------------------ */     public void setUserTablePasswordField(String tablePasswordField)     {         _userTablePasswordField = tablePasswordField;     }       /* ------------------------------------------------------------ */     public String getRoleTableName()     {         return _roleTableName;     }       /* ------------------------------------------------------------ */     public void setRoleTableName(String tableName)     {         _roleTableName = tableName;     }       /* ------------------------------------------------------------ */     public String getRoleTableKey()     {         return _roleTableKey;     }       /* ------------------------------------------------------------ */     public void setRoleTableKey(String tableKey)     {         _roleTableKey = tableKey;     }       /* ------------------------------------------------------------ */     public String getRoleTableRoleField()     {         return _roleTableRoleField;     }       /* ------------------------------------------------------------ */     public void setRoleTableRoleField(String tableRoleField)     {         _roleTableRoleField = tableRoleField;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableName()     {         return _userRoleTableName;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableName(String roleTableName)     {         _userRoleTableName = roleTableName;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableUserKey()     {         return _userRoleTableUserKey;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableUserKey(String roleTableUserKey)     {         _userRoleTableUserKey = roleTableUserKey;     }       /* ------------------------------------------------------------ */     public String getUserRoleTableRoleKey()     {         return _userRoleTableRoleKey;     }       /* ------------------------------------------------------------ */     public void setUserRoleTableRoleKey(String roleTableRoleKey)     {         _userRoleTableRoleKey = roleTableRoleKey;     }              /* ------------------------------------------------------------ */     @Override     public UserPrincipal loadUserInfo (String username)     {         try         {             try (Connection connection = getConnection();                     PreparedStatement statement1 = connection.prepareStatement(_userSql))             {                 statement1.setObject(1, username);                 try (ResultSet rs1 = statement1.executeQuery())                 {                     if (rs1.next())                     {                         int key = rs1.getInt(_userTableKey);                         String credentials = rs1.getString(_userTablePasswordField);                                                  return new DBUserPrincipal(username, Credential.getCredential(credentials), key);                     }                 }             }         }         catch (NamingException e)         {             LOG.warn(&quot;No datasource for &quot;+_jndiName, e);         }         catch (SQLException e)         {             LOG.warn(&quot;Problem loading user info for &quot;+username, e);         }         return null;     }               /* ------------------------------------------------------------ */     @Override     public String[] loadRoleInfo (UserPrincipal user)     {         DBUserPrincipal dbuser = (DBUserPrincipal)user;          try         {             try (Connection connection = getConnection();                     PreparedStatement statement2 = connection.prepareStatement(_roleSql))             {                  List roles = new ArrayList();                  statement2.setInt(1, dbuser.getKey());                 try (ResultSet rs2 = statement2.executeQuery())                 {                     while (rs2.next())                     {                         roles.add(rs2.getString(_roleTableRoleField));                     }                                          return roles.toArray(new String[roles.size()]);                 }             }         }         catch (NamingException e)         {             LOG.warn(&quot;No datasource for &quot;+_jndiName, e);         }         catch (SQLException e)         {             LOG.warn(&quot;Problem loading user info for &quot;+user.getName(), e);         }         return null;     }             /* ------------------------------------------------------------ */     /**      * Lookup the datasource for the jndiName and formulate the      * necessary sql query strings based on the configured table      * and column names.      *      * @throws NamingException if unable to init jndi      * @throws SQLException if unable to init database      */     public void initDb() throws NamingException, SQLException     {         if (_datasource != null)             return;          @SuppressWarnings(&quot;unused&quot;)         InitialContext ic = new InitialContext();         assert ic!=null;          // TODO Should we try webapp scope too?          // try finding the datasource in the Server scope         if (_server != null)         {             try             {                 _datasource = (DataSource)NamingEntryUtil.lookup(_server, _jndiName);             }             catch (NameNotFoundException e)             {                 //next try the jvm scope             }         }           //try finding the datasource in the jvm scope         if (_datasource==null)         {             _datasource = (DataSource)NamingEntryUtil.lookup(null, _jndiName);         }          // set up the select statements based on the table and column names configured         _userSql = &quot;select &quot; + _userTableKey + &quot;,&quot; + _userTablePasswordField                   + &quot; from &quot; + _userTableName                   + &quot; where &quot;+ _userTableUserField + &quot; = ?&quot;;          _roleSql = &quot;select r.&quot; + _roleTableRoleField                   + &quot; from &quot; + _roleTableName + &quot; r, &quot; + _userRoleTableName                   + &quot; u where u.&quot;+ _userRoleTableUserKey + &quot; = ?&quot;                   + &quot; and r.&quot; + _roleTableKey + &quot; = u.&quot; + _userRoleTableRoleKey;          prepareTables();     }      /* ------------------------------------------------------------ */     /**      * @throws NamingException      * @throws SQLException      */     private void prepareTables()     throws NamingException, SQLException     {         if (_createTables)         {             boolean autocommit = true;             Connection connection = getConnection();             try (Statement stmt = connection.createStatement())             {                 autocommit = connection.getAutoCommit();                 connection.setAutoCommit(false);                 DatabaseMetaData metaData = connection.getMetaData();                  //check if tables exist                 String tableName = (metaData.storesLowerCaseIdentifiers()? _userTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userTableName.toUpperCase(Locale.ENGLISH): _userTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //user table default                         /*                          * create table _userTableName (_userTableKey integer,                          * _userTableUserField varchar(100) not null unique,                          * _userTablePasswordField varchar(20) not null, primary key(_userTableKey));                          */                         stmt.executeUpdate(&quot;create table &quot;+_userTableName+ &quot;(&quot;+_userTableKey+&quot; integer,&quot;+                                 _userTableUserField+&quot; varchar(100) not null unique,&quot;+                                 _userTablePasswordField+&quot; varchar(20) not null, primary key(&quot;+_userTableKey+&quot;))&quot;);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_userTableName);                     }                 }                  tableName = (metaData.storesLowerCaseIdentifiers()? _roleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_roleTableName.toUpperCase(Locale.ENGLISH): _roleTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //role table default                         /*                          * create table _roleTableName (_roleTableKey integer,                          * _roleTableRoleField varchar(100) not null unique, primary key(_roleTableKey));                          */                         String str = &quot;create table &quot;+_roleTableName+&quot; (&quot;+_roleTableKey+&quot; integer, &quot;+                         _roleTableRoleField+&quot; varchar(100) not null unique, primary key(&quot;+_roleTableKey+&quot;))&quot;;                         stmt.executeUpdate(str);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_roleTableName);                     }                 }                  tableName = (metaData.storesLowerCaseIdentifiers()? _userRoleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userRoleTableName.toUpperCase(Locale.ENGLISH): _userRoleTableName));                 try (ResultSet result = metaData.getTables(null, null, tableName, null))                 {                     if (!result.next())                     {                         //user-role table                         /*                          * create table _userRoleTableName (_userRoleTableUserKey integer,                          * _userRoleTableRoleKey integer,                          * primary key (_userRoleTableUserKey, _userRoleTableRoleKey));                          *                          * create index idx_user_role on _userRoleTableName (_userRoleTableUserKey);                          */                         stmt.executeUpdate(&quot;create table &quot;+_userRoleTableName+&quot; (&quot;+_userRoleTableUserKey+&quot; integer, &quot;+                                 _userRoleTableRoleKey+&quot; integer, &quot;+                                 &quot;primary key (&quot;+_userRoleTableUserKey+&quot;, &quot;+_userRoleTableRoleKey+&quot;))&quot;);                         stmt.executeUpdate(&quot;create index indx_user_role on &quot;+_userRoleTableName+&quot;(&quot;+_userRoleTableUserKey+&quot;)&quot;);                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Created table &quot;+_userRoleTableName +&quot; and index&quot;);                     }                 }                 connection.commit();             }             finally             {                 try                 {                     connection.setAutoCommit(autocommit);                 }                 catch (SQLException e)                 {                     if (LOG.isDebugEnabled()) LOG.debug(&quot;Prepare tables&quot;, e);                 }                 finally                 {                     try                     {                         connection.close();                     }                     catch (SQLException e)                     {                         if (LOG.isDebugEnabled()) LOG.debug(&quot;Prepare tables&quot;, e);                     }                 }             }         }         else if (LOG.isDebugEnabled())         {             LOG.debug(&quot;createTables false&quot;);         }     }      /* ------------------------------------------------------------ */     /**      * @return      * @throws NamingException      * @throws SQLException      */     private Connection getConnection ()     throws NamingException, SQLException     {         initDb();         return _datasource.getConnection();     } }</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. blob,  2. long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">14444</td>
    <td align="left">https://github.com/eclipse/jetty.project/blob/65528f76c5ef6ddca11385f9721c8f0bc5f2eed7/jetty-plus/src/main/java/org/eclipse/jetty/plus/security/DataSourceLoginService.java/#L52-L530</td>
    <td align="right">1</td>
    <td align="right">2425</td>
    <td align="right">14444</td>
  </tr>
  <tr valign="top">
    <td align="right">2432</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells the bad smells are: 1. Blob, 2. Data Class&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement(name = &quot;Product&quot;) public class Product {     private long id;     private String description;      public long getId() {         return id;     }      public void setId(long id) {         this.id = id;     }      public String getDescription() {         return description;     }      public void setDescription(String d) {         this.description = d;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14460</td>
    <td align="left">https://github.com/apache/cxf/blob/6bf89e9c8804c8845ec4d38583dd33eea8256439/distribution/src/main/release/samples/jax_rs/spring_security/src/main/java/demo/jaxrs/service/Product.java/#L23-L43</td>
    <td align="right">1</td>
    <td align="right">2432</td>
    <td align="right">14460</td>
  </tr>
  <tr valign="top">
    <td align="right">2434</td>
    <td align="left">{&quot;response&quot;:&quot;YES I found bad smells&quot;,&quot;the bad smells are&quot;:[&quot;Blob&quot;,&quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public abstract class ExternalLoadBalancerDeviceManagerImpl extends AdapterBase implements ExternalLoadBalancerDeviceManager, ResourceStateAdapter {      @Inject     NetworkExternalLoadBalancerDao _networkExternalLBDao;     @Inject     ExternalLoadBalancerDeviceDao _externalLoadBalancerDeviceDao;     @Inject     HostDao _hostDao;     @Inject     DataCenterDao _dcDao;     @Inject     NetworkModel _networkModel;     @Inject     NetworkOrchestrationService _networkMgr;     @Inject     InlineLoadBalancerNicMapDao _inlineLoadBalancerNicMapDao;     @Inject     NicDao _nicDao;     @Inject     AgentManager _agentMgr;     @Inject     ResourceManager _resourceMgr;     @Inject     IPAddressDao _ipAddressDao;     @Inject     VlanDao _vlanDao;     @Inject     NetworkOfferingDao _networkOfferingDao;     @Inject     AccountDao _accountDao;     @Inject     PhysicalNetworkDao _physicalNetworkDao;     @Inject     PhysicalNetworkServiceProviderDao _physicalNetworkServiceProviderDao;     @Inject     AccountManager _accountMgr;     @Inject     UserStatisticsDao _userStatsDao;     @Inject     NetworkDao _networkDao;     @Inject     DomainRouterDao _routerDao;     @Inject     LoadBalancerDao _loadBalancerDao;     @Inject     PortForwardingRulesDao _portForwardingRulesDao;     @Inject     ConfigurationDao _configDao;     @Inject     HostDetailsDao _hostDetailDao;     @Inject     NetworkExternalLoadBalancerDao _networkLBDao;     @Inject     NetworkServiceMapDao _ntwkSrvcProviderDao;     @Inject     NetworkExternalFirewallDao _networkExternalFirewallDao;     @Inject     ExternalFirewallDeviceDao _externalFirewallDeviceDao;     @Inject     protected HostPodDao _podDao = null;     @Inject     IpAddressManager _ipAddrMgr;     @Inject     protected     VirtualMachineManager _itMgr;     @Inject     VMInstanceDao _vmDao;     @Inject     VMTemplateDao _templateDao;     @Inject     ServiceOfferingDao _serviceOfferingDao;     @Inject     PhysicalNetworkServiceProviderDao _physicalProviderDao;     @Inject     VirtualRouterProviderDao _vrProviderDao;      private long _defaultLbCapacity;     private static final org.apache.log4j.Logger s_logger = Logger.getLogger(ExternalLoadBalancerDeviceManagerImpl.class);      @Override     @DB     public ExternalLoadBalancerDeviceVO addExternalLoadBalancer(long physicalNetworkId, String url, String username, String password, final String deviceName,         ServerResource resource, final boolean gslbProvider, final boolean exclusiveGslbProivider,         final String gslbSitePublicIp, final String gslbSitePrivateIp) {          PhysicalNetworkVO pNetwork = null;         final NetworkDevice ntwkDevice = NetworkDevice.getNetworkDevice(deviceName);         long zoneId;          if ((ntwkDevice == null) || (url == null) || (username == null) || (resource == null) || (password == null)) {             throw new InvalidParameterValueException(&quot;Atleast one of the required parameters (url, username, password,&quot;                 + &quot; server resource, zone id/physical network id) is not specified or a valid parameter.&quot;);         }          pNetwork = _physicalNetworkDao.findById(physicalNetworkId);         if (pNetwork == null) {             throw new InvalidParameterValueException(&quot;Could not find phyical network with ID: &quot; + physicalNetworkId);         }          zoneId = pNetwork.getDataCenterId();         PhysicalNetworkServiceProviderVO ntwkSvcProvider =             _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), ntwkDevice.getNetworkServiceProvder());          ntwkSvcProvider = _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), ntwkDevice.getNetworkServiceProvder());         if (ntwkSvcProvider == null) {             throw new CloudRuntimeException(&quot;Network Service Provider: &quot; + ntwkDevice.getNetworkServiceProvder() + &quot; is not enabled in the physical network: &quot; +                 physicalNetworkId + &quot;to add this device&quot;);         } else if (ntwkSvcProvider.getState() == PhysicalNetworkServiceProvider.State.Shutdown) {             throw new CloudRuntimeException(&quot;Network Service Provider: &quot; + ntwkSvcProvider.getProviderName() + &quot; is in shutdown state in the physical network: &quot; +                 physicalNetworkId + &quot;to add this device&quot;);         }          if (gslbProvider) {             ExternalLoadBalancerDeviceVO zoneGslbProvider =                 _externalLoadBalancerDeviceDao.findGslbServiceProvider(physicalNetworkId, ntwkDevice.getNetworkServiceProvder());             if (zoneGslbProvider != null) {                 throw new CloudRuntimeException(&quot;There is a GSLB service provider configured in the zone alredy.&quot;);             }         }          URI uri;         try {             uri = new URI(url);         } catch (Exception e) {             s_logger.debug(e);             throw new InvalidParameterValueException(e.getMessage());         }          String ipAddress = uri.getHost();         Map hostDetails = new HashMap();         String hostName = getExternalLoadBalancerResourceGuid(pNetwork.getId(), deviceName, ipAddress);         hostDetails.put(&quot;name&quot;, hostName);         hostDetails.put(&quot;guid&quot;, UUID.randomUUID().toString());         hostDetails.put(&quot;zoneId&quot;, String.valueOf(pNetwork.getDataCenterId()));         hostDetails.put(&quot;ip&quot;, ipAddress);         hostDetails.put(&quot;physicalNetworkId&quot;, String.valueOf(pNetwork.getId()));         hostDetails.put(&quot;username&quot;, username);         hostDetails.put(&quot;password&quot;, password);         hostDetails.put(&quot;deviceName&quot;, deviceName);          // leave parameter validation to be part server resource configure         Map configParams = new HashMap();         UrlUtil.parseQueryParameters(uri.getQuery(), false, configParams);         hostDetails.putAll(configParams);          try {             resource.configure(hostName, hostDetails);              final Host host = _resourceMgr.addHost(zoneId, resource, Host.Type.ExternalLoadBalancer, hostDetails);             if (host != null) {                  final boolean dedicatedUse =                     (configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_DEDICATED) != null) ? Boolean.parseBoolean(configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_DEDICATED))                         : false;                 long capacity = NumbersUtil.parseLong(configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_CAPACITY), 0);                 if (capacity == 0) {                     capacity = _defaultLbCapacity;                 }                  final long capacityFinal = capacity;                 final PhysicalNetworkVO pNetworkFinal = pNetwork;                 return Transaction.execute(new TransactionCallback() {                     @Override                     public ExternalLoadBalancerDeviceVO doInTransaction(TransactionStatus status) {                         ExternalLoadBalancerDeviceVO lbDeviceVO =                             new ExternalLoadBalancerDeviceVO(host.getId(), pNetworkFinal.getId(), ntwkDevice.getNetworkServiceProvder(), deviceName, capacityFinal,                                 dedicatedUse, gslbProvider);                         if (gslbProvider) {                             lbDeviceVO.setGslbSitePublicIP(gslbSitePublicIp);                             lbDeviceVO.setGslbSitePrivateIP(gslbSitePrivateIp);                             lbDeviceVO.setExclusiveGslbProvider(exclusiveGslbProivider);                         }                         _externalLoadBalancerDeviceDao.persist(lbDeviceVO);                         DetailVO hostDetail = new DetailVO(host.getId(), ApiConstants.LOAD_BALANCER_DEVICE_ID, String.valueOf(lbDeviceVO.getId()));                         _hostDetailDao.persist(hostDetail);                          return lbDeviceVO;                     }                 });             } else {                 throw new CloudRuntimeException(&quot;Failed to add load balancer device due to internal error.&quot;);             }         } catch (ConfigurationException e) {             throw new CloudRuntimeException(e.getMessage());         }     }      @Override     public boolean deleteExternalLoadBalancer(long hostId) {         HostVO externalLoadBalancer = _hostDao.findById(hostId);         if (externalLoadBalancer == null) {             throw new InvalidParameterValueException(&quot;Could not find an external load balancer with ID: &quot; + hostId);         }          DetailVO lbHostDetails = _hostDetailDao.findDetail(hostId, ApiConstants.LOAD_BALANCER_DEVICE_ID);         long lbDeviceId = Long.parseLong(lbHostDetails.getValue());          ExternalLoadBalancerDeviceVO lbDeviceVo = _externalLoadBalancerDeviceDao.findById(lbDeviceId);         if (lbDeviceVo.getAllocationState() == LBDeviceAllocationState.Provider) {             // check if cloudstack has provisioned any load balancer appliance on the device before deleting             List lbDevices = _externalLoadBalancerDeviceDao.listAll();             if (lbDevices != null) {                 for (ExternalLoadBalancerDeviceVO lbDevice : lbDevices) {                     if (lbDevice.getParentHostId() == hostId) {                         throw new CloudRuntimeException(                             &quot;This load balancer device can not be deleted as there are one or more load balancers applainces provisioned by cloudstack on the device.&quot;);                     }                 }             }         } else {             // check if any networks are using this load balancer device             List networks = _networkLBDao.listByLoadBalancerDeviceId(lbDeviceId);             if ((networks != null) &amp;&amp; !networks.isEmpty()) {                 throw new CloudRuntimeException(&quot;Delete can not be done as there are networks using this load balancer device &quot;);             }         }          try {             // put the host in maintenance state in order for it to be deleted             externalLoadBalancer.setResourceState(ResourceState.Maintenance);             _hostDao.update(hostId, externalLoadBalancer);             _resourceMgr.deleteHost(hostId, false, false);              // delete the external load balancer entry             _externalLoadBalancerDeviceDao.remove(lbDeviceId);              return true;         } catch (Exception e) {             s_logger.debug(e);             return false;         }     }      @Override     public List listExternalLoadBalancers(long physicalNetworkId, String deviceName) {         List lbHosts = new ArrayList();         NetworkDevice lbNetworkDevice = NetworkDevice.getNetworkDevice(deviceName);         PhysicalNetworkVO pNetwork = null;          pNetwork = _physicalNetworkDao.findById(physicalNetworkId);          if ((pNetwork == null) || (lbNetworkDevice == null)) {             throw new InvalidParameterValueException(&quot;Atleast one of the required parameter physical networkId, device name is invalid.&quot;);         }          PhysicalNetworkServiceProviderVO ntwkSvcProvider =             _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), lbNetworkDevice.getNetworkServiceProvder());         // if provider not configured in to physical network, then there can be no instances         if (ntwkSvcProvider == null) {             return null;         }          List lbDevices =             _externalLoadBalancerDeviceDao.listByPhysicalNetworkAndProvider(physicalNetworkId, ntwkSvcProvider.getProviderName());         for (ExternalLoadBalancerDeviceVO provderInstance : lbDevices) {             lbHosts.add(_hostDao.findById(provderInstance.getHostId()));         }         return lbHosts;     }      public ExternalLoadBalancerResponse createExternalLoadBalancerResponse(Host externalLoadBalancer) {         Map lbDetails = _hostDetailDao.findDetails(externalLoadBalancer.getId());         ExternalLoadBalancerResponse response = new ExternalLoadBalancerResponse();         response.setId(externalLoadBalancer.getUuid());         response.setIpAddress(externalLoadBalancer.getPrivateIpAddress());         response.setUsername(lbDetails.get(&quot;username&quot;));         response.setPublicInterface(lbDetails.get(&quot;publicInterface&quot;));         response.setPrivateInterface(lbDetails.get(&quot;privateInterface&quot;));         response.setNumRetries(lbDetails.get(&quot;numRetries&quot;));         return response;     }      public String getExternalLoadBalancerResourceGuid(long physicalNetworkId, String deviceName, String ip) {         return physicalNetworkId + &quot;-&quot; + deviceName + &quot;-&quot; + ip;     }      @Override     public ExternalLoadBalancerDeviceVO getExternalLoadBalancerForNetwork(Network network) {         NetworkExternalLoadBalancerVO lbDeviceForNetwork = _networkExternalLBDao.findByNetworkId(network.getId());         if (lbDeviceForNetwork != null) {             long lbDeviceId = lbDeviceForNetwork.getExternalLBDeviceId();             ExternalLoadBalancerDeviceVO lbDeviceVo = _externalLoadBalancerDeviceDao.findById(lbDeviceId);             assert (lbDeviceVo != null);             return lbDeviceVo;         }         return null;     }      public void setExternalLoadBalancerForNetwork(Network network, long externalLBDeviceID) {         NetworkExternalLoadBalancerVO lbDeviceForNetwork = new NetworkExternalLoadBalancerVO(network.getId(), externalLBDeviceID);         _networkExternalLBDao.persist(lbDeviceForNetwork);     }      @DB     protected ExternalLoadBalancerDeviceVO allocateLoadBalancerForNetwork(final Network guestConfig) throws InsufficientCapacityException {         boolean retry = true;         boolean tryLbProvisioning = false;         ExternalLoadBalancerDeviceVO lbDevice = null;         long physicalNetworkId = guestConfig.getPhysicalNetworkId();         NetworkOfferingVO offering = _networkOfferingDao.findById(guestConfig.getNetworkOfferingId());         String provider = _ntwkSrvcProviderDao.getProviderForServiceInNetwork(guestConfig.getId(), Service.Lb);          while (retry) {             GlobalLock deviceMapLock = GlobalLock.getInternLock(&quot;LoadBalancerAllocLock&quot;);             try {                 if (deviceMapLock.lock(120)) {                     try {                         final boolean dedicatedLB = offering.isDedicatedLB(); // does network offering supports a dedicated load balancer?                          try {                             lbDevice = Transaction.execute(new TransactionCallbackWithException() {                                 @Override                                 public ExternalLoadBalancerDeviceVO doInTransaction(TransactionStatus status) throws InsufficientCapacityException {                                     // FIXME: should the device allocation be done during network implement phase or do a                                     // lazy allocation when first rule for the network is configured??                                      // find a load balancer device for this network as per the network offering                                     ExternalLoadBalancerDeviceVO lbDevice = findSuitableLoadBalancerForNetwork(guestConfig, dedicatedLB);                                     long lbDeviceId = lbDevice.getId();                                      // persist the load balancer device id that will be used for this network. Once a network                                     // is implemented on a LB device then later on all rules will be programmed on to same device                                     NetworkExternalLoadBalancerVO networkLB = new NetworkExternalLoadBalancerVO(guestConfig.getId(), lbDeviceId);                                     _networkExternalLBDao.persist(networkLB);                                      // mark device to be either dedicated or shared use                                     lbDevice.setAllocationState(dedicatedLB ? LBDeviceAllocationState.Dedicated : LBDeviceAllocationState.Shared);                                     _externalLoadBalancerDeviceDao.update(lbDeviceId, lbDevice);                                     return lbDevice;                                 }                             });                              // allocated load balancer for the network, so skip retry                             tryLbProvisioning = false;                             retry = false;                         } catch (InsufficientCapacityException exception) {                             // if already attempted to provision load balancer then throw out of capacity exception,                             if (tryLbProvisioning) {                                 retry = false;                                 // TODO: throwing warning instead of error for now as its possible another provider can service this network                                 s_logger.warn(&quot;There are no load balancer device with the capacity for implementing this network&quot;);                                 throw exception;                             } else {                                 tryLbProvisioning = true; // if possible provision a LB appliance in to the physical network                             }                         }                     } finally {                         deviceMapLock.unlock();                     }                 }             } finally {                 deviceMapLock.releaseRef();             }              // there are no LB devices or there is no free capacity on the devices in the physical network so provision a new LB appliance             if (tryLbProvisioning) {                 // check if LB appliance can be dynamically provisioned                 List providerLbDevices =                     _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Provider);                 if ((providerLbDevices != null) &amp;&amp; (!providerLbDevices.isEmpty())) {                     for (ExternalLoadBalancerDeviceVO lbProviderDevice : providerLbDevices) {                         if (lbProviderDevice.getState() == LBDeviceState.Enabled) {                             // acquire a private IP from the data center which will be used as management IP of provisioned LB appliance,                             DataCenterIpAddressVO dcPrivateIp = _dcDao.allocatePrivateIpAddress(guestConfig.getDataCenterId(), lbProviderDevice.getUuid());                             if (dcPrivateIp == null) {                                 throw new InsufficientNetworkCapacityException(&quot;failed to acquire a priavate IP in the zone &quot; + guestConfig.getDataCenterId() +                                     &quot; needed for management IP of the load balancer appliance&quot;, DataCenter.class, guestConfig.getDataCenterId());                             }                             Pod pod = _podDao.findById(dcPrivateIp.getPodId());                             String lbIP = dcPrivateIp.getIpAddress();                             String netmask = NetUtils.getCidrNetmask(pod.getCidrSize());                             String gateway = pod.getGateway();                              // send CreateLoadBalancerApplianceCommand to the host capable of provisioning                             CreateLoadBalancerApplianceCommand lbProvisionCmd = new CreateLoadBalancerApplianceCommand(lbIP, netmask, gateway);                             CreateLoadBalancerApplianceAnswer createLbAnswer = null;                             try {                                 createLbAnswer = (CreateLoadBalancerApplianceAnswer)_agentMgr.easySend(lbProviderDevice.getHostId(), lbProvisionCmd);                                 if (createLbAnswer == null || !createLbAnswer.getResult()) {                                     s_logger.error(&quot;Could not provision load balancer instance on the load balancer device &quot; + lbProviderDevice.getId());                                     continue;                                 }                             } catch (Exception agentException) {                                 s_logger.error(&quot;Could not provision load balancer instance on the load balancer device &quot; + lbProviderDevice.getId() + &quot; due to &quot; +                                     agentException.getMessage());                                 continue;                             }                              String username = createLbAnswer.getUsername();                             String password = createLbAnswer.getPassword();                             String publicIf = createLbAnswer.getPublicInterface();                             String privateIf = createLbAnswer.getPrivateInterface();                              // we have provisioned load balancer so add the appliance as cloudstack provisioned external load balancer                             String dedicatedLb = offering.isDedicatedLB() ? &quot;true&quot; : &quot;false&quot;;                             String capacity = Long.toString(lbProviderDevice.getCapacity());                              // acquire a public IP to associate with lb appliance (used as subnet IP to make the appliance part of private network)                             PublicIp publicIp =                                 _ipAddrMgr.assignPublicIpAddress(guestConfig.getDataCenterId(), null, _accountMgr.getSystemAccount(), VlanType.VirtualNetwork, null,                                     null, false, false);                             String publicIPNetmask = publicIp.getVlanNetmask();                             String publicIPgateway = publicIp.getVlanGateway();                             String publicIP = publicIp.getAddress().toString();                             String publicIPVlanTag=&quot;&quot;;                             try {                                 publicIPVlanTag = BroadcastDomainType.getValue(publicIp.getVlanTag());                             } catch (URISyntaxException e) {                                 s_logger.error(&quot;Failed to parse public ip vlan tag&quot; + e.getMessage());                             }                              String url =                                 &quot;https://&quot; + lbIP + &quot;?publicinterface=&quot; + publicIf + &quot;&amp;privateinterface=&quot; + privateIf + &quot;&amp;lbdevicededicated=&quot; + dedicatedLb +                                     &quot;&amp;cloudmanaged=true&quot; + &quot;&amp;publicip=&quot; + publicIP + &quot;&amp;publicipnetmask=&quot; + publicIPNetmask + &quot;&amp;lbdevicecapacity=&quot; + capacity +                                     &quot;&amp;publicipvlan=&quot; + publicIPVlanTag + &quot;&amp;publicipgateway=&quot; + publicIPgateway;                             ExternalLoadBalancerDeviceVO lbAppliance = null;                             try {                                 lbAppliance =                                     addExternalLoadBalancer(physicalNetworkId, url, username, password, createLbAnswer.getDeviceName(),                                         createLbAnswer.getServerResource(), false, false, null, null);                             } catch (Exception e) {                                 s_logger.error(&quot;Failed to add load balancer appliance in to cloudstack due to &quot; + e.getMessage() +                                     &quot;. So provisioned load balancer appliance will be destroyed.&quot;);                             }                              if (lbAppliance != null) {                                 // mark the load balancer as cloudstack managed and set parent host id on which lb appliance is provisioned                                 ExternalLoadBalancerDeviceVO managedLb = _externalLoadBalancerDeviceDao.findById(lbAppliance.getId());                                 managedLb.setIsManagedDevice(true);                                 managedLb.setParentHostId(lbProviderDevice.getHostId());                                 _externalLoadBalancerDeviceDao.update(lbAppliance.getId(), managedLb);                             } else {                                 // failed to add the provisioned load balancer into cloudstack so destroy the appliance                                 DestroyLoadBalancerApplianceCommand lbDeleteCmd = new DestroyLoadBalancerApplianceCommand(lbIP);                                 DestroyLoadBalancerApplianceAnswer answer = null;                                 try {                                     answer = (DestroyLoadBalancerApplianceAnswer)_agentMgr.easySend(lbProviderDevice.getHostId(), lbDeleteCmd);                                     if (answer == null || !answer.getResult()) {                                         s_logger.warn(&quot;Failed to destroy load balancer appliance created&quot;);                                     } else {                                         // release the public &amp; private IP back to dc pool, as the load balancer appliance is now destroyed                                         _dcDao.releasePrivateIpAddress(lbIP, guestConfig.getDataCenterId(), null);                                         _ipAddrMgr.disassociatePublicIpAddress(publicIp.getId(), _accountMgr.getSystemUser().getId(), _accountMgr.getSystemAccount());                                     }                                 } catch (Exception e) {                                     s_logger.warn(&quot;Failed to destroy load balancer appliance created for the network&quot; + guestConfig.getId() + &quot; due to &quot; + e.getMessage());                                 }                             }                         }                     }                 }             }         }          return lbDevice;     }      @Override     public ExternalLoadBalancerDeviceVO findSuitableLoadBalancerForNetwork(Network network, boolean dedicatedLb) throws InsufficientCapacityException {         long physicalNetworkId = network.getPhysicalNetworkId();         List lbDevices = null;         String provider = _ntwkSrvcProviderDao.getProviderForServiceInNetwork(network.getId(), Service.Lb);         assert (provider != null);          if (dedicatedLb) {             lbDevices = _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Free);             if (lbDevices != null &amp;&amp; !lbDevices.isEmpty()) {                 // return first device that is free, fully configured and meant for dedicated use                 for (ExternalLoadBalancerDeviceVO lbdevice : lbDevices) {                     if (lbdevice.getState() == LBDeviceState.Enabled &amp;&amp; lbdevice.getIsDedicatedDevice()) {                         return lbdevice;                     }                 }             }         } else {             // get the LB devices that are already allocated for shared use             lbDevices = _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Shared);              if (lbDevices != null) {                  ExternalLoadBalancerDeviceVO maxFreeCapacityLbdevice = null;                 long maxFreeCapacity = 0;                  // loop through the LB device in the physical network and pick the one with maximum free capacity                 for (ExternalLoadBalancerDeviceVO lbdevice : lbDevices) {                      // skip if device is not enabled                     if (lbdevice.getState() != LBDeviceState.Enabled) {                         continue;                     }                      // get the used capacity from the list of guest networks that are mapped to this load balancer                     List mappedNetworks = _networkExternalLBDao.listByLoadBalancerDeviceId(lbdevice.getId());                     long usedCapacity = ((mappedNetworks == null) || (mappedNetworks.isEmpty())) ? 0 : mappedNetworks.size();                      // get the configured capacity for this device                     long fullCapacity = lbdevice.getCapacity();                     if (fullCapacity == 0) {                         fullCapacity = _defaultLbCapacity; // if capacity not configured then use the default                     }                      long freeCapacity = fullCapacity - usedCapacity;                     if (freeCapacity &gt; 0) {                         if (maxFreeCapacityLbdevice == null) {                             maxFreeCapacityLbdevice = lbdevice;                             maxFreeCapacity = freeCapacity;                         } else if (freeCapacity &gt; maxFreeCapacity) {                             maxFreeCapacityLbdevice = lbdevice;                             maxFreeCapacity = freeCapacity;                         }                     }                 }                  // return the device with maximum free capacity and is meant for shared use                 if (maxFreeCapacityLbdevice != null) {                     return maxFreeCapacityLbdevice;                 }             }              // if we are here then there are no existing LB devices in shared use or the devices in shared use has no // free capacity left             // so allocate a new load balancer configured for shared use from the pool of free LB devices             lbDevices = _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Free);             if (lbDevices != null &amp;&amp; !lbDevices.isEmpty()) {                 for (ExternalLoadBalancerDeviceVO lbdevice : lbDevices) {                     if (lbdevice.getState() == LBDeviceState.Enabled &amp;&amp; !lbdevice.getIsDedicatedDevice()) {                         return lbdevice;                     }                 }             }         }          // there are no devices which capacity         throw new InsufficientNetworkCapacityException(&quot;Unable to find a load balancing provider with sufficient capcity &quot; + &quot; to implement the network&quot;, Network.class,             network.getId());     }      @DB     protected boolean freeLoadBalancerForNetwork(final Network guestConfig) {         GlobalLock deviceMapLock = GlobalLock.getInternLock(&quot;LoadBalancerAllocLock&quot;);          try {             if (deviceMapLock.lock(120)) {                 ExternalLoadBalancerDeviceVO lbDevice = Transaction.execute(new TransactionCallback() {                     @Override                     public ExternalLoadBalancerDeviceVO doInTransaction(TransactionStatus status) {                         // since network is shutdown remove the network mapping to the load balancer device                         NetworkExternalLoadBalancerVO networkLBDevice = _networkExternalLBDao.findByNetworkId(guestConfig.getId());                         long lbDeviceId = networkLBDevice.getExternalLBDeviceId();                         _networkExternalLBDao.remove(networkLBDevice.getId());                          List ntwksMapped = _networkExternalLBDao.listByLoadBalancerDeviceId(networkLBDevice.getExternalLBDeviceId());                         ExternalLoadBalancerDeviceVO lbDevice = _externalLoadBalancerDeviceDao.findById(lbDeviceId);                         boolean lbInUse = !(ntwksMapped == null || ntwksMapped.isEmpty());                         boolean lbCloudManaged = lbDevice.getIsManagedDevice();                          if (!lbInUse &amp;&amp; !lbCloudManaged) {                             // this is the last network mapped to the load balancer device so set device allocation state to be free                             lbDevice.setAllocationState(LBDeviceAllocationState.Free);                             _externalLoadBalancerDeviceDao.update(lbDevice.getId(), lbDevice);                         }                          // commit the changes before sending agent command to destroy cloudstack managed LB                         if (!lbInUse &amp;&amp; lbCloudManaged) {                             return lbDevice;                         } else {                             return null;                         }                     }                 });                  if (lbDevice != null) {                     // send DestroyLoadBalancerApplianceCommand to the host where load balancer appliance is provisioned                     Host lbHost = _hostDao.findById(lbDevice.getHostId());                     String lbIP = lbHost.getPrivateIpAddress();                     DestroyLoadBalancerApplianceCommand lbDeleteCmd = new DestroyLoadBalancerApplianceCommand(lbIP);                     DestroyLoadBalancerApplianceAnswer answer = null;                     try {                         answer = (DestroyLoadBalancerApplianceAnswer)_agentMgr.easySend(lbDevice.getParentHostId(), lbDeleteCmd);                         if (answer == null || !answer.getResult()) {                             s_logger.warn(&quot;Failed to destoy load balancer appliance used by the network&quot;                                     + guestConfig.getId() + &quot; due to &quot; + answer == null ? &quot;communication error with agent&quot;                                     : answer.getDetails());                         }                     } catch (Exception e) {                         s_logger.warn(&quot;Failed to destroy load balancer appliance used by the network&quot; + guestConfig.getId() + &quot; due to &quot; + e.getMessage());                     }                      if (s_logger.isDebugEnabled()) {                         s_logger.debug(&quot;Successfully destroyed load balancer appliance used for the network&quot; + guestConfig.getId());                     }                     deviceMapLock.unlock();                      // remove the provisioned load balancer appliance from cloudstack                     deleteExternalLoadBalancer(lbHost.getId());                      // release the private IP back to dc pool, as the load balancer appliance is now destroyed                     _dcDao.releasePrivateIpAddress(lbHost.getPrivateIpAddress(), guestConfig.getDataCenterId(), null);                      // release the public IP allocated for this LB appliance                     DetailVO publicIpDetail = _hostDetailDao.findDetail(lbHost.getId(), &quot;publicip&quot;);                     IPAddressVO ipVo = _ipAddressDao.findByIpAndDcId(guestConfig.getDataCenterId(), publicIpDetail.toString());                     _ipAddrMgr.disassociatePublicIpAddress(ipVo.getId(), _accountMgr.getSystemUser().getId(), _accountMgr.getSystemAccount());                 } else {                     deviceMapLock.unlock();                 }                  return true;             } else {                 s_logger.error(&quot;Failed to release load balancer device for the network&quot; + guestConfig.getId() + &quot;as failed to acquire lock &quot;);                 return false;             }         } catch (Exception exception) {             s_logger.error(&quot;Failed to release load balancer device for the network&quot; + guestConfig.getId() + &quot; due to &quot; + exception.getMessage());         } finally {             deviceMapLock.releaseRef();         }          return false;     }      private void applyStaticNatRuleForInlineLBRule(DataCenterVO zone, Network network, boolean revoked, String publicIp, String privateIp)         throws ResourceUnavailableException {         List staticNats = new ArrayList();         IPAddressVO ipVO = _ipAddressDao.listByDcIdIpAddress(zone.getId(), publicIp).get(0);         StaticNatImpl staticNat = new StaticNatImpl(ipVO.getAllocatedToAccountId(), ipVO.getAllocatedInDomainId(), network.getId(), ipVO.getId(), privateIp, revoked);         staticNats.add(staticNat);         StaticNatServiceProvider element = _networkMgr.getStaticNatProviderForNetwork(network);         element.applyStaticNats(network, staticNats);     }      private enum MappingState {         Create, Remove, Unchanged,     };      private class MappingNic {         private Nic nic;         private MappingState state;          public Nic getNic() {             return nic;         }          public void setNic(Nic nic) {             this.nic = nic;         }          public MappingState getState() {             return state;         }          public void setState(MappingState state) {             this.state = state;         }     };      private MappingNic getLoadBalancingIpNic(DataCenterVO zone, Network network, long sourceIpId, boolean revoked, String existedGuestIp)         throws ResourceUnavailableException {         String srcIp = _networkModel.getIp(sourceIpId).getAddress().addr();         InlineLoadBalancerNicMapVO mapping = _inlineLoadBalancerNicMapDao.findByPublicIpAddress(srcIp);         Nic loadBalancingIpNic = null;         MappingNic nic = new MappingNic();         nic.setState(MappingState.Unchanged);         if (!revoked) {             if (mapping == null) {                 // Acquire a new guest IP address and save it as the load balancing IP address                 String loadBalancingIpAddress = existedGuestIp;                  if (loadBalancingIpAddress == null) {                     if (network.getGuestType() == Network.GuestType.Isolated) {                         loadBalancingIpAddress = _ipAddrMgr.acquireGuestIpAddress(network, null);                     } else if (network.getGuestType() == Network.GuestType.Shared) {                         try {                             PublicIp directIp =                                 _ipAddrMgr.assignPublicIpAddress(network.getDataCenterId(), null, _accountDao.findById(network.getAccountId()), VlanType.DirectAttached,                                     network.getId(), null, true, false);                             loadBalancingIpAddress = directIp.getAddress().addr();                         } catch (InsufficientCapacityException capException) {                             String msg = &quot;Ran out of guest IP addresses from the shared network.&quot;;                             s_logger.error(msg);                             throw new ResourceUnavailableException(msg, DataCenter.class, network.getDataCenterId());                         }                     }                 }                  if (loadBalancingIpAddress == null) {                     String msg = &quot;Ran out of guest IP addresses.&quot;;                     s_logger.error(msg);                     throw new ResourceUnavailableException(msg, DataCenter.class, network.getDataCenterId());                 }                  // If a NIC doesn't exist for the load balancing IP address, create one                 loadBalancingIpNic = _nicDao.findByIp4AddressAndNetworkId(loadBalancingIpAddress, network.getId());                 if (loadBalancingIpNic == null) {                     loadBalancingIpNic = _networkMgr.savePlaceholderNic(network, loadBalancingIpAddress, null, null);                 }                  // Save a mapping between the source IP address and the load balancing IP address NIC                 mapping = new InlineLoadBalancerNicMapVO(srcIp, loadBalancingIpNic.getId());                 _inlineLoadBalancerNicMapDao.persist(mapping);                  // On the firewall provider for the network, create a static NAT rule between the source IP                 // address and the load balancing IP address                 try {                     applyStaticNatRuleForInlineLBRule(zone, network, revoked, srcIp, loadBalancingIpNic.getIPv4Address());                 } catch (ResourceUnavailableException ex) {                     // Rollback db operation                     _inlineLoadBalancerNicMapDao.expunge(mapping.getId());                     _nicDao.expunge(loadBalancingIpNic.getId());                     throw ex;                 }                  s_logger.debug(&quot;Created static nat rule for inline load balancer&quot;);                 nic.setState(MappingState.Create);             } else {                 loadBalancingIpNic = _nicDao.findById(mapping.getNicId());             }         } else {             if (mapping != null) {                 // Find the NIC that the mapping refers to                 loadBalancingIpNic = _nicDao.findById(mapping.getNicId());                  int count = _ipAddrMgr.getRuleCountForIp(sourceIpId, Purpose.LoadBalancing, FirewallRule.State.Active);                 if (count == 0) {                     // On the firewall provider for the network, delete the static NAT rule between the source IP                     // address and the load balancing IP address                     applyStaticNatRuleForInlineLBRule(zone, network, revoked, srcIp, loadBalancingIpNic.getIPv4Address());                      // Delete the mapping between the source IP address and the load balancing IP address                     _inlineLoadBalancerNicMapDao.expunge(mapping.getId());                      // Delete the NIC                     _nicDao.expunge(loadBalancingIpNic.getId());                      s_logger.debug(&quot;Revoked static nat rule for inline load balancer&quot;);                     nic.setState(MappingState.Remove);                 }             } else {                 s_logger.debug(&quot;Revoking a rule for an inline load balancer that has not been programmed yet.&quot;);                 nic.setNic(null);                 return nic;             }         }          nic.setNic(loadBalancingIpNic);         return nic;     }      public boolean isNccServiceProvider(Network network) {         NetworkOffering networkOffering = _networkOfferingDao.findById(network.getNetworkOfferingId());         if(null!= networkOffering &amp;&amp; networkOffering.getServicePackage() != null ) {             return true;         }         else {             return false;         }     }      public HostVO getNetScalerControlCenterForNetwork(Network guestConfig) {         long zoneId = guestConfig.getDataCenterId();         return _hostDao.findByTypeNameAndZoneId(zoneId, &quot;NetscalerControlCenter&quot;, Type.NetScalerControlCenter);     }      @Override     public boolean applyLoadBalancerRules(Network network, List loadBalancingRules) throws ResourceUnavailableException {         // Find the external load balancer in this zone         long zoneId = network.getDataCenterId();         DataCenterVO zone = _dcDao.findById(zoneId);          if (loadBalancingRules == null || loadBalancingRules.isEmpty()) {             return true;         }          HostVO externalLoadBalancer = null;          if(isNccServiceProvider(network)) {             externalLoadBalancer  = getNetScalerControlCenterForNetwork(network);         } else {             ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(network);             if (lbDeviceVO == null) {                 s_logger.warn(&quot;There is no external load balancer device assigned to this network either network is not implement are already shutdown so just returning&quot;);                 return true;             } else {                 externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());             }         }            boolean externalLoadBalancerIsInline = _networkMgr.isNetworkInlineMode(network);          if (network.getState() == Network.State.Allocated) {             s_logger.debug(&quot;External load balancer was asked to apply LB rules for network with ID &quot; + network.getId() +                 &quot;; this network is not implemented. Skipping backend commands.&quot;);             return true;         }          List loadBalancersToApply = new ArrayList();         List mappingStates = new ArrayList();         for (int i = 0; i &lt; loadBalancingRules.size(); i++) {             LoadBalancingRule rule = loadBalancingRules.get(i);              boolean revoked = (rule.getState().equals(FirewallRule.State.Revoke));             String protocol = rule.getProtocol();             String algorithm = rule.getAlgorithm();             String uuid = rule.getUuid();             String srcIp = rule.getSourceIp().addr();             String srcIpVlan = null;             String srcIpGateway = null;             String srcIpNetmask = null;             Long vlanid =  _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getVlanId();             if(vlanid != null ) {               VlanVO publicVlan =   _vlanDao.findById(vlanid);               srcIpVlan =  publicVlan.getVlanTag();               srcIpGateway = publicVlan.getVlanGateway();               srcIpNetmask = publicVlan.getVlanNetmask();             }             int srcPort = rule.getSourcePortStart();             List destinations = rule.getDestinations();              if (externalLoadBalancerIsInline) {                 long ipId = _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getId();                 MappingNic nic = getLoadBalancingIpNic(zone, network, ipId, revoked, null);                 mappingStates.add(nic.getState());                 Nic loadBalancingIpNic = nic.getNic();                 if (loadBalancingIpNic == null) {                     continue;                 }                  // Change the source IP address for the load balancing rule to be the load balancing IP address                 srcIp = loadBalancingIpNic.getIPv4Address();             }              if ((destinations != null &amp;&amp; !destinations.isEmpty()) || rule.isAutoScaleConfig()) {                 boolean inline = _networkMgr.isNetworkInlineMode(network);                 LoadBalancerTO loadBalancer =                     new LoadBalancerTO(uuid, srcIp, srcPort, protocol, algorithm, revoked, false, inline, destinations, rule.getStickinessPolicies(),                         rule.getHealthCheckPolicies(), rule.getLbSslCert(), rule.getLbProtocol());                 loadBalancer.setNetworkId(network.getId());                 loadBalancer.setSrcIpVlan(srcIpVlan);                 loadBalancer.setSrcIpNetmask(srcIpNetmask);                 loadBalancer.setSrcIpGateway(srcIpGateway);                 if (rule.isAutoScaleConfig()) {                     loadBalancer.setAutoScaleVmGroup(rule.getAutoScaleVmGroup());                 }                 loadBalancersToApply.add(loadBalancer);             }         }          try {             if (loadBalancersToApply.size() &gt; 0) {                 int numLoadBalancersForCommand = loadBalancersToApply.size();                 LoadBalancerTO[] loadBalancersForCommand = loadBalancersToApply.toArray(new LoadBalancerTO[numLoadBalancersForCommand]);                 LoadBalancerConfigCommand cmd = new LoadBalancerConfigCommand(loadBalancersForCommand, null);                 long guestVlanTag = Integer.parseInt(BroadcastDomainType.getValue(network.getBroadcastUri()));                 cmd.setAccessDetail(NetworkElementCommand.GUEST_VLAN_TAG, String.valueOf(guestVlanTag));                 Answer answer = _agentMgr.easySend(externalLoadBalancer.getId(), cmd);                 if (answer == null || !answer.getResult()) {                     String details = (answer != null) ? answer.getDetails() : &quot;details unavailable&quot;;                     String msg = &quot;Unable to apply load balancer rules to the external load balancer appliance in zone &quot; + zone.getName() + &quot; due to: &quot; + details + &quot;.&quot;;                     s_logger.error(msg);                     throw new ResourceUnavailableException(msg, DataCenter.class, network.getDataCenterId());                 }             }         } catch (Exception ex) {             if (externalLoadBalancerIsInline) {                 s_logger.error(&quot;Rollbacking static nat operation of inline mode load balancing due to error on applying LB rules!&quot;);                 String existedGuestIp = loadBalancersToApply.get(0).getSrcIp();                 // Rollback static NAT operation in current session                 for (int i = 0; i &lt; loadBalancingRules.size(); i++) {                     LoadBalancingRule rule = loadBalancingRules.get(i);                     MappingState state = mappingStates.get(i);                     boolean revoke;                     if (state == MappingState.Create) {                         revoke = true;                     } else if (state == MappingState.Remove) {                         revoke = false;                     } else {                         continue;                     }                     long sourceIpId = _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getId();                     getLoadBalancingIpNic(zone, network, sourceIpId, revoke, existedGuestIp);                 }             }             throw new ResourceUnavailableException(ex.getMessage(), DataCenter.class, network.getDataCenterId());         }          return true;     }      @Override     public boolean manageGuestNetworkWithExternalLoadBalancer(boolean add, Network guestConfig) throws ResourceUnavailableException, InsufficientCapacityException {         if (guestConfig.getTrafficType() != TrafficType.Guest) {             s_logger.trace(&quot;External load balancer can only be used for guest networks.&quot;);             return false;         }          long zoneId = guestConfig.getDataCenterId();         DataCenterVO zone = _dcDao.findById(zoneId);         HostVO externalLoadBalancer = null;          if (add) {             ExternalLoadBalancerDeviceVO lbDeviceVO = null;             // on restart network, device could have been allocated already, skip allocation if a device is assigned             lbDeviceVO = getExternalLoadBalancerForNetwork(guestConfig);             if (lbDeviceVO == null) {                 // allocate a load balancer device for the network                 lbDeviceVO = allocateLoadBalancerForNetwork(guestConfig);                 if (lbDeviceVO == null) {                     String msg = &quot;failed to alloacate a external load balancer for the network &quot; + guestConfig.getId();                     s_logger.error(msg);                     throw new InsufficientNetworkCapacityException(msg, DataCenter.class, guestConfig.getDataCenterId());                 }             }             externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());             s_logger.debug(&quot;Allocated external load balancer device:&quot; + lbDeviceVO.getId() + &quot; for the network: &quot; + guestConfig.getId());         } else {             // find the load balancer device allocated for the network             ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(guestConfig);             if (lbDeviceVO == null) {                 s_logger.warn(&quot;Network shutdwon requested on external load balancer element, which did not implement the network.&quot;                     + &quot; Either network implement failed half way through or already network shutdown is completed. So just returning.&quot;);                 return true;             }              externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());             assert (externalLoadBalancer != null) : &quot;There is no device assigned to this network how did shutdown network ended up here??&quot;;         }          // Send a command to the external load balancer to implement or shutdown the guest network         String guestVlanTag = BroadcastDomainType.getValue(guestConfig.getBroadcastUri());         String selfIp = null;         String guestVlanNetmask = NetUtils.cidr2Netmask(guestConfig.getCidr());         Integer networkRate = _networkModel.getNetworkRate(guestConfig.getId(), null);          if (add) {             // on restart network, network could have already been implemented. If already implemented then return             Nic selfipNic = getPlaceholderNic(guestConfig);             if (selfipNic != null) {                 return true;             }              // Acquire a self-ip address from the guest network IP address range             selfIp = _ipAddrMgr.acquireGuestIpAddress(guestConfig, null);             if (selfIp == null) {                 String msg = &quot;failed to acquire guest IP address so not implementing the network on the external load balancer &quot;;                 s_logger.error(msg);                 throw new InsufficientNetworkCapacityException(msg, Network.class, guestConfig.getId());             }         } else {             // get the self-ip used by the load balancer             Nic selfipNic = getPlaceholderNic(guestConfig);             if (selfipNic == null) {                 s_logger.warn(&quot;Network shutdwon requested on external load balancer element, which did not implement the network.&quot;                     + &quot; Either network implement failed half way through or already network shutdown is completed. So just returning.&quot;);                 return true;             }             selfIp = selfipNic.getIPv4Address();         }          // It's a hack, using isOneToOneNat field for indicate if it's inline or not         boolean inline = _networkMgr.isNetworkInlineMode(guestConfig);         IpAddressTO ip =             new IpAddressTO(guestConfig.getAccountId(), null, add, false, true, guestVlanTag, selfIp, guestVlanNetmask, null, networkRate, inline);         IpAddressTO[] ips = new IpAddressTO[1];         ips[0] = ip;         IpAssocCommand cmd = new IpAssocCommand(ips);         Answer answer = _agentMgr.easySend(externalLoadBalancer.getId(), cmd);          if (answer == null || !answer.getResult()) {             String action = add ? &quot;implement&quot; : &quot;shutdown&quot;;             String answerDetails = (answer != null) ? answer.getDetails() : null;             answerDetails = (answerDetails != null) ? &quot; due to &quot; + answerDetails : &quot;&quot;;             String msg = &quot;External load balancer was unable to &quot; + action + &quot; the guest network on the external load balancer in zone &quot; + zone.getName() + answerDetails;             s_logger.error(msg);             throw new ResourceUnavailableException(msg, Network.class, guestConfig.getId());         }          if (add) {             // Insert a new NIC for this guest network to reserve the self IP             _networkMgr.savePlaceholderNic(guestConfig, selfIp, null, null);         } else {             // release the self-ip obtained from guest network             Nic selfipNic = getPlaceholderNic(guestConfig);             _nicDao.remove(selfipNic.getId());              // release the load balancer allocated for the network             boolean releasedLB = freeLoadBalancerForNetwork(guestConfig);             if (!releasedLB) {                 String msg = &quot;Failed to release the external load balancer used for the network: &quot; + guestConfig.getId();                 s_logger.error(msg);             }         }          if (s_logger.isDebugEnabled()) {             Account account = _accountDao.findByIdIncludingRemoved(guestConfig.getAccountId());             String action = add ? &quot;implemented&quot; : &quot;shut down&quot;;             s_logger.debug(&quot;External load balancer has &quot; + action + &quot; the guest network for account &quot; + account.getAccountName() + &quot;(id = &quot; + account.getAccountId() +                 &quot;) with VLAN tag &quot; + guestVlanTag);         }          return true;     }      @Override     public boolean configure(String name, Map params) throws ConfigurationException {         super.configure(name, params);         _defaultLbCapacity = NumbersUtil.parseLong(_configDao.getValue(Config.DefaultExternalLoadBalancerCapacity.key()), 50);         _resourceMgr.registerResourceStateAdapter(this.getClass().getSimpleName(), this);         return true;     }      @Override     public boolean start() {         return true;     }      @Override     public boolean stop() {         return true;     }      @Override     public HostVO createHostVOForConnectedAgent(HostVO host, StartupCommand[] cmd) {         // TODO Auto-generated method stub         return null;     }      @Override     public HostVO createHostVOForDirectConnectAgent(HostVO host, StartupCommand[] startup, ServerResource resource, Map details, List hostTags) {         if (!(startup[0] instanceof StartupExternalLoadBalancerCommand)) {             return null;         }         if(host.getName().equalsIgnoreCase(&quot;NetScalerControlCenter&quot;)) {             host.setType(Host.Type.NetScalerControlCenter);         }         else {             host.setType(Host.Type.ExternalLoadBalancer);         }         return host;     }      @Override     public DeleteHostAnswer deleteHost(HostVO host, boolean isForced, boolean isForceDeleteStorage) throws UnableDeleteHostException {         if (host.getType() != com.cloud.host.Host.Type.ExternalLoadBalancer) {             return null;         }         return new DeleteHostAnswer(true);     }      protected IpDeployer getIpDeployerForInlineMode(Network network) {         //We won't deploy IP, instead the firewall in front of us would do it         List providers = _networkMgr.getProvidersForServiceInNetwork(network, Service.Firewall);         //Only support one provider now         if (providers == null) {             s_logger.error(&quot;Cannot find firewall provider for network &quot; + network.getId());             return null;         }         if (providers.size() != 1) {             s_logger.error(&quot;Found &quot; + providers.size() + &quot; firewall provider for network &quot; + network.getId());             return null;         }          NetworkElement element = _networkModel.getElementImplementingProvider(providers.get(0).getName());         if (!(element instanceof IpDeployer)) {             s_logger.error(&quot;The firewall provider for network &quot; + network.getName() + &quot; don't have ability to deploy IP address!&quot;);             return null;         }         s_logger.info(&quot;Let &quot; + element.getName() + &quot; handle ip association for &quot; + getName() + &quot; in network &quot; + network.getId());         return (IpDeployer)element;     }      @Override     public List getLBHealthChecks(Network network, List loadBalancingRules) throws ResourceUnavailableException {          // Find the external load balancer in this zone         long zoneId = network.getDataCenterId();         DataCenterVO zone = _dcDao.findById(zoneId);          if (loadBalancingRules == null || loadBalancingRules.isEmpty()) {             return null;         }          HostVO externalLoadBalancer = null;          if(isNccServiceProvider(network)) {             externalLoadBalancer  = getNetScalerControlCenterForNetwork(network);         } else {             ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(network);             if (lbDeviceVO == null) {                 s_logger.warn(&quot;There is no external load balancer device assigned to this network either network is not implement are already shutdown so just returning&quot;);                 return null;             } else {                 externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());             }         }          boolean externalLoadBalancerIsInline = _networkMgr.isNetworkInlineMode(network);          if (network.getState() == Network.State.Allocated) {             s_logger.debug(&quot;External load balancer was asked to apply LB rules for network with ID &quot; + network.getId() +                 &quot;; this network is not implemented. Skipping backend commands.&quot;);             return null;         }          List loadBalancersToApply = new ArrayList();         List mappingStates = new ArrayList();         for (final LoadBalancingRule rule : loadBalancingRules) {             boolean revoked = (FirewallRule.State.Revoke.equals(rule.getState()));             String protocol = rule.getProtocol();             String algorithm = rule.getAlgorithm();             String uuid = rule.getUuid();             String srcIp = rule.getSourceIp().addr();             int srcPort = rule.getSourcePortStart();             List destinations = rule.getDestinations();              if (externalLoadBalancerIsInline) {                 long sourceIpId = _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getId();                 MappingNic nic = getLoadBalancingIpNic(zone, network, sourceIpId, revoked, null);                 mappingStates.add(nic.getState());                 Nic loadBalancingIpNic = nic.getNic();                 if (loadBalancingIpNic == null) {                     continue;                 }                  // Change the source IP address for the load balancing rule to                 // be the load balancing IP address                 srcIp = loadBalancingIpNic.getIPv4Address();             }              if ((destinations != null &amp;&amp; !destinations.isEmpty()) || !rule.isAutoScaleConfig()) {                 boolean inline = _networkMgr.isNetworkInlineMode(network);                 LoadBalancerTO loadBalancer =                     new LoadBalancerTO(uuid, srcIp, srcPort, protocol, algorithm, revoked, false, inline, destinations, rule.getStickinessPolicies(),                         rule.getHealthCheckPolicies(), rule.getLbSslCert(), rule.getLbProtocol());                 loadBalancersToApply.add(loadBalancer);             }         }          try {             if (loadBalancersToApply.size() &gt; 0) {                 int numLoadBalancersForCommand = loadBalancersToApply.size();                 LoadBalancerTO[] loadBalancersForCommand = loadBalancersToApply.toArray(new LoadBalancerTO[numLoadBalancersForCommand]);                 HealthCheckLBConfigCommand cmd = new HealthCheckLBConfigCommand(loadBalancersForCommand, network.getId());                 long guestVlanTag = Integer.parseInt(BroadcastDomainType.getValue(network.getBroadcastUri()));                 cmd.setAccessDetail(NetworkElementCommand.GUEST_VLAN_TAG, String.valueOf(guestVlanTag));                  HealthCheckLBConfigAnswer answer = (HealthCheckLBConfigAnswer) _agentMgr.easySend(externalLoadBalancer.getId(), cmd);                 // easySend will return null on error                 return answer == null ? null : answer.getLoadBalancers();             }         } catch (Exception ex) {             s_logger.error(&quot;Exception Occured &quot;, ex);         }         //null return is handled by clients         return null;     }      private NicVO getPlaceholderNic(Network network) {         List guestIps = _nicDao.listByNetworkId(network.getId());         for (NicVO guestIp : guestIps) {             // only external firewall and external load balancer will create NicVO with PlaceHolder reservation strategy             if (guestIp.getReservationStrategy().equals(ReservationStrategy.PlaceHolder) &amp;&amp; guestIp.getVmType() == null &amp;&amp; guestIp.getReserver() == null &amp;&amp;                 !guestIp.getIPv4Address().equals(network.getGateway())) {                 return guestIp;             }         }         return null;     }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">14462</td>
    <td align="left">https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/server/src/main/java/com/cloud/network/ExternalLoadBalancerDeviceManagerImpl.java/#L141-L1311</td>
    <td align="right">1</td>
    <td align="right">2434</td>
    <td align="right">14462</td>
  </tr>
  <tr valign="top">
    <td align="right">2435</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detected_bad_smells&quot;: [       &quot;Blob&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlTransient public abstract class PendingActionNotificationResponse     extends ImmutableObject implements ResponseData {    /** The inner name type that contains a name and the result boolean. */   @Embed   static class NameOrId extends ImmutableObject {     @XmlValue     String value;      @XmlAttribute(name = &quot;paResult&quot;)     boolean actionResult;   }    @XmlTransient   NameOrId nameOrId;    @XmlElement(name = &quot;paTRID&quot;)   Trid trid;    @XmlElement(name = &quot;paDate&quot;)   DateTime processedDate;    public String getNameAsString() {     return nameOrId.value;   }    @VisibleForTesting   public Trid getTrid() {     return trid;   }    @VisibleForTesting   public boolean getActionResult() {     return nameOrId.actionResult;   }    protected static  T init(       T response, String nameOrId, boolean actionResult, Trid trid, DateTime processedDate) {     response.nameOrId = new NameOrId();     response.nameOrId.value = nameOrId;     response.nameOrId.actionResult = actionResult;     response.trid = trid;     response.processedDate = processedDate;     return response;   }    /** An adapter to output the XML in response to resolving a pending command on a domain. */   @Embed   @XmlRootElement(name = &quot;panData&quot;, namespace = &quot;urn:ietf:params:xml:ns:domain-1.0&quot;)   @XmlType(       propOrder = {&quot;name&quot;, &quot;trid&quot;, &quot;processedDate&quot;},       namespace = &quot;urn:ietf:params:xml:ns:domain-1.0&quot;)   public static class DomainPendingActionNotificationResponse       extends PendingActionNotificationResponse {      @XmlElement     NameOrId getName() {       return nameOrId;     }      public static DomainPendingActionNotificationResponse create(         String fullyQualifiedDomainName, boolean actionResult, Trid trid, DateTime processedDate) {       return init(           new DomainPendingActionNotificationResponse(),           fullyQualifiedDomainName,           actionResult,           trid,           processedDate);     }   }    /** An adapter to output the XML in response to resolving a pending command on a contact. */   @Embed   @XmlRootElement(name = &quot;panData&quot;, namespace = &quot;urn:ietf:params:xml:ns:contact-1.0&quot;)   @XmlType(       propOrder = {&quot;id&quot;, &quot;trid&quot;, &quot;processedDate&quot;},       namespace = &quot;urn:ietf:params:xml:ns:contact-1.0&quot;)   public static class ContactPendingActionNotificationResponse       extends PendingActionNotificationResponse {      @XmlElement     NameOrId getId() {       return nameOrId;     }      public static ContactPendingActionNotificationResponse create(         String contactId, boolean actionResult, Trid trid, DateTime processedDate) {       return init(           new ContactPendingActionNotificationResponse(),           contactId,           actionResult,           trid,           processedDate);     }   }    /** An adapter to output the XML in response to resolving a pending command on a host. */   @Embed   @XmlRootElement(name = &quot;panData&quot;, namespace = &quot;urn:ietf:params:xml:ns:domain-1.0&quot;)   @XmlType(     propOrder = {&quot;name&quot;, &quot;trid&quot;, &quot;processedDate&quot;},     namespace = &quot;urn:ietf:params:xml:ns:domain-1.0&quot;   )   public static class HostPendingActionNotificationResponse       extends PendingActionNotificationResponse {      @XmlElement     NameOrId getName() {       return nameOrId;     }      public static HostPendingActionNotificationResponse create(         String fullyQualifiedHostName, boolean actionResult, Trid trid, DateTime processedDate) {       return init(           new HostPendingActionNotificationResponse(),           fullyQualifiedHostName,           actionResult,           trid,           processedDate);     }   } }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">14466</td>
    <td align="left">https://github.com/google/nomulus/blob/2481704d00f10f6b5675dd26f9effaad434ddbea/java/google/registry/model/poll/PendingActionNotificationResponse.java/#L31-L153</td>
    <td align="right">1</td>
    <td align="right">2435</td>
    <td align="right">14466</td>
  </tr>
  <tr valign="top">
    <td align="right">2439</td>
    <td align="left">&nbsp;	{ 		&quot;answer&quot;: &quot;YES I found bad smells&quot;, 		&quot;bad smells are&quot;: [ 			&quot;Blob&quot;, 			&quot;Data Class&quot;, 			&quot;Long Method&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class AssemblerConfig {  	// Private Member Variables ------------------------------------------------  	/** The portlet app descriptor, which is usually WEB-INF/portlet.xml. */     private File portletDescriptor;      /** The webapp descriptor to assemble, which is usually WEB-INF/web.xml. */     private File webappDescriptor;      /** The assemble destination, which points to the assembled WAR file. */     private File destination;      /** The class of the servlet that will handle portlet requests */     private String dispatchServletClass;      /** The source archive to assemble */     private File source;          /** Assembler sink buffer size.  Defaults to 4096 bytes. */     private int assemblerSinkBuflen = 1024 * 4; // 4kb      // Public Methods ----------------------------------------------------------      public File getPortletDescriptor() {         return portletDescriptor;     }      public void setPortletDescriptor(File portletDescriptor) {         this.portletDescriptor = portletDescriptor;     }      public File getWebappDescriptor() {         return webappDescriptor;     }      public void setWebappDescriptor(File webappDescriptor) {         this.webappDescriptor = webappDescriptor;     }      public File getDestination() {         return destination;     }      public void setDestination(File destination) {         this.destination = destination;     }      public String getDispatchServletClass() {         return dispatchServletClass;     }      public void setDispatchServletClass(String dispatchServletClass) {         this.dispatchServletClass = dispatchServletClass;     }      /**      * @deprecated use setSource(File) instead.      */     public void setWarSource(File source) {         this.source = source;     }          public void setSource(File source) {         this.source = source;     }          /**      * @deprecated use getSource() instead.      */     public File getWarSource() {         return source;     }          public File getSource() {         return source;     }          public int getAssemblerSinkBuflen() {         return assemblerSinkBuflen;     }          public void setAssemblerSinkBuflen(int buflen) {         this.assemblerSinkBuflen = buflen;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14478</td>
    <td align="left">https://github.com/apache/portals-pluto/blob/4db5ddd26fb2ce642be7b0894858e664c6076a3b/pluto-util/src/main/java/org/apache/pluto/util/assemble/AssemblerConfig.java/#L25-L110</td>
    <td align="right">1</td>
    <td align="right">2439</td>
    <td align="right">14478</td>
  </tr>
  <tr valign="top">
    <td align="right">2445</td>
    <td align="left">&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Blob&quot;,         &quot;Long Method&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement(name=&quot;mqtt&quot;) @XmlAccessorType(XmlAccessType.FIELD) public class MqttDTO extends ProtocolDTO {      @XmlAttribute(name=&quot;max_message_length&quot;)     public Integer max_message_length;      @XmlElementRef     public List protocol_filters = new ArrayList();      @XmlAttribute(name=&quot;queue_prefix&quot;)     public String queue_prefix;      @XmlAttribute(name=&quot;path_separator&quot;)     public String path_separator;      @XmlAttribute(name=&quot;any_child_wildcard&quot;)     public String any_child_wildcard;      @XmlAttribute(name=&quot;any_descendant_wildcard&quot;)     public String any_descendant_wildcard;      @XmlAttribute(name=&quot;regex_wildcard_start&quot;)     public String regex_wildcard_start;      @XmlAttribute(name=&quot;regex_wildcard_end&quot;)     public String regex_wildcard_end;      @XmlAttribute(name=&quot;part_pattern&quot;)     public String part_pattern;      @XmlAttribute(name=&quot;die_delay&quot;)     public Long die_delay;      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (o == null || getClass() != o.getClass()) return false;         if (!super.equals(o)) return false;          MqttDTO mqttDTO = (MqttDTO) o;          if (any_child_wildcard != null ? !any_child_wildcard.equals(mqttDTO.any_child_wildcard) : mqttDTO.any_child_wildcard != null)             return false;         if (any_descendant_wildcard != null ? !any_descendant_wildcard.equals(mqttDTO.any_descendant_wildcard) : mqttDTO.any_descendant_wildcard != null)             return false;         if (max_message_length != null ? !max_message_length.equals(mqttDTO.max_message_length) : mqttDTO.max_message_length != null)             return false;         if (path_separator != null ? !path_separator.equals(mqttDTO.path_separator) : mqttDTO.path_separator != null)             return false;         if (protocol_filters != null ? !protocol_filters.equals(mqttDTO.protocol_filters) : mqttDTO.protocol_filters != null)             return false;         if (queue_prefix != null ? !queue_prefix.equals(mqttDTO.queue_prefix) : mqttDTO.queue_prefix != null)             return false;         if (regex_wildcard_end != null ? !regex_wildcard_end.equals(mqttDTO.regex_wildcard_end) : mqttDTO.regex_wildcard_end != null)             return false;         if (regex_wildcard_start != null ? !regex_wildcard_start.equals(mqttDTO.regex_wildcard_start) : mqttDTO.regex_wildcard_start != null)             return false;         if (part_pattern != null ? !part_pattern.equals(mqttDTO.part_pattern) : mqttDTO.part_pattern != null)             return false;          return true;     }      @Override     public int hashCode() {         int result = super.hashCode();         result = 31 * result + (max_message_length != null ? max_message_length.hashCode() : 0);         result = 31 * result + (protocol_filters != null ? protocol_filters.hashCode() : 0);         result = 31 * result + (queue_prefix != null ? queue_prefix.hashCode() : 0);         result = 31 * result + (part_pattern != null ? part_pattern.hashCode() : 0);         result = 31 * result + (path_separator != null ? path_separator.hashCode() : 0);         result = 31 * result + (any_child_wildcard != null ? any_child_wildcard.hashCode() : 0);         result = 31 * result + (any_descendant_wildcard != null ? any_descendant_wildcard.hashCode() : 0);         result = 31 * result + (regex_wildcard_start != null ? regex_wildcard_start.hashCode() : 0);         result = 31 * result + (regex_wildcard_end != null ? regex_wildcard_end.hashCode() : 0);         return result;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">14492</td>
    <td align="left">https://github.com/apache/activemq-apollo/blob/8e4b134b2a5d3576aa62cd8df9905a9fe2eba2d0/apollo-mqtt/src/main/java/org/apache/activemq/apollo/mqtt/dto/MqttDTO.java/#L31-L109</td>
    <td align="right">1</td>
    <td align="right">2445</td>
    <td align="right">14492</td>
  </tr>
  <tr valign="top">
    <td align="right">2468</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Blob&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class OptionalManyTransitionImpl extends MinimalEObjectImpl.Container implements OptionalManyTransition {   /**    * The default value of the '{@link #getVal() Val}' attribute.    *     *     * @see #getVal()    * @generated    * @ordered    */   protected static final String VAL_EDEFAULT = null;    /**    * The cached value of the '{@link #getVal() Val}' attribute.    *     *     * @see #getVal()    * @generated    * @ordered    */   protected String val = VAL_EDEFAULT;    /**    *     *     * @generated    */   protected OptionalManyTransitionImpl()   {     super();   }    /**    *     *     * @generated    */   @Override   protected EClass eStaticClass()   {     return SyntacticsequencertestPackage.Literals.OPTIONAL_MANY_TRANSITION;   }    /**    *     *     * @generated    */   public String getVal()   {     return val;   }    /**    *     *     * @generated    */   public void setVal(String newVal)   {     String oldVal = val;     val = newVal;     if (eNotificationRequired())       eNotify(new ENotificationImpl(this, Notification.SET, SyntacticsequencertestPackage.OPTIONAL_MANY_TRANSITION__VAL, oldVal, val));   }    /**    *     *     * @generated    */   @Override   public Object eGet(int featureID, boolean resolve, boolean coreType)   {     switch (featureID)     {       case SyntacticsequencertestPackage.OPTIONAL_MANY_TRANSITION__VAL:         return getVal();     }     return super.eGet(featureID, resolve, coreType);   }    /**    *     *     * @generated    */   @Override   public void eSet(int featureID, Object newValue)   {     switch (featureID)     {       case SyntacticsequencertestPackage.OPTIONAL_MANY_TRANSITION__VAL:         setVal((String)newValue);         return;     }     super.eSet(featureID, newValue);   }    /**    *     *     * @generated    */   @Override   public void eUnset(int featureID)   {     switch (featureID)     {       case SyntacticsequencertestPackage.OPTIONAL_MANY_TRANSITION__VAL:         setVal(VAL_EDEFAULT);         return;     }     super.eUnset(featureID);   }    /**    *     *     * @generated    */   @Override   public boolean eIsSet(int featureID)   {     switch (featureID)     {       case SyntacticsequencertestPackage.OPTIONAL_MANY_TRANSITION__VAL:         return VAL_EDEFAULT == null ? val != null : !VAL_EDEFAULT.equals(val);     }     return super.eIsSet(featureID);   }    /**    *     *     * @generated    */   @Override   public String toString()   {     if (eIsProxy()) return super.toString();      StringBuffer result = new StringBuffer(super.toString());     result.append(&quot; (val: &quot;);     result.append(val);     result.append(')');     return result.toString();   }  } //OptionalManyTransitionImpl</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">14570</td>
    <td align="left">https://github.com/eclipse/xtext-core/blob/e04964e4c2a3e0338c0079bd8333688835e77c31/org.eclipse.xtext.tests/src-gen/org/eclipse/xtext/serializer/syntacticsequencertest/impl/OptionalManyTransitionImpl.java/#L29-L178</td>
    <td align="right">1</td>
    <td align="right">2468</td>
    <td align="right">14570</td>
  </tr>
  <tr valign="top">
    <td align="right">2470</td>
    <td align="left">&nbsp;	{ 		&quot;message&quot;: &quot;YES I found bad smells&quot;, 		&quot;detected_bad_smells&quot;: [ 			&quot;the bad smells are:&quot;, 			&quot;1. Blob&quot;, 			&quot;2. Data Class&quot; 		] 	}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ReportInstance extends AbstractDTOBase {      private String id;     private ReportStatusEnum status;     private String url;     private String ownerId;     private Boolean hasDetailRows;     private ZonedDateTime completionDate;     private ZonedDateTime requestDate;      public String getId() {         return id;     }      public void setId(String id) {         this.id = id;     }      public ReportStatusEnum getStatus() {         return status;     }      public void setStatus(ReportStatusEnum status) {         this.status = status;     }      public String getUrl() {         return url;     }      public void setUrl(String url) {         this.url = url;     }      public String getOwnerId() {         return ownerId;     }      public void setOwnerId(String ownerId) {         this.ownerId = ownerId;     }      public Boolean getHasDetailRows() {         return hasDetailRows;     }      public void setHasDetailRows(Boolean hasDetailRows) {         this.hasDetailRows = hasDetailRows;     }      public ZonedDateTime getCompletionDate() {         return completionDate;     }      public void setCompletionDate(ZonedDateTime completionDate) {         this.completionDate = completionDate;     }      public ZonedDateTime getRequestDate() {         return requestDate;     }      public void setRequestDate(ZonedDateTime requestDate) {         this.requestDate = requestDate;     } }</td>
    <td align="left">data class</td>
    <td align="left">the bad smells are:, 1. blob, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">the bad smells are:,  1. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14576</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/api/dto/analytics/reports/ReportInstance.java/#L26-L91</td>
    <td align="right">1</td>
    <td align="right">2470</td>
    <td align="right">14576</td>
  </tr>
  <tr valign="top">
    <td align="right">2478</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SuppressWarnings(&quot;serial&quot;) @Entity @Table(name = &quot;TRIGGER&quot;, uniqueConstraints = @UniqueConstraint(columnNames = { &quot;name&quot;, &quot;alert_id&quot; })) public class Trigger extends JPAEntity implements Serializable { 	 	 	public static class Serializer extends JsonSerializer {  		@Override 		public void serialize(Trigger trigger, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException { 			 			jgen.writeStartObject(); 			 			jgen.writeStringField(&quot;id&quot;, trigger.getId().toString()); 			jgen.writeStringField(&quot;name&quot;, trigger.getName()); 			jgen.writeStringField(&quot;type&quot;, trigger.getType().name()); 			jgen.writeNumberField(&quot;threshold&quot;, trigger.getThreshold().doubleValue()); 			 			if(trigger.getSecondaryThreshold() != null) { 				jgen.writeNumberField(&quot;secondaryThreshold&quot;, trigger.getSecondaryThreshold()); 			} 			 			if(trigger.getInertia() != null) { 				jgen.writeNumberField(&quot;inertia&quot;, trigger.getInertia()); 			} 			 			jgen.writeEndObject(); 		} 		 	} 	 	public static class Deserializer extends JsonDeserializer {  		@Override 		public Trigger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {  			Trigger trigger = new Trigger(); 			JsonNode rootNode = jp.getCodec().readTree(jp); 			 			BigInteger id = new BigInteger(rootNode.get(&quot;id&quot;).asText()); 			trigger.id = id; 			 			String name = rootNode.get(&quot;name&quot;).asText(); 			trigger.setName(name); 			 			TriggerType type = TriggerType.fromString(rootNode.get(&quot;type&quot;).asText()); 			trigger.setType(type); 			 			Double threshold = rootNode.get(&quot;threshold&quot;).asDouble(); 			trigger.setThreshold(threshold);  			if(rootNode.get(&quot;secondaryThreshold&quot;) != null) { 				trigger.setSecondaryThreshold(rootNode.get(&quot;secondaryThreshold&quot;).asDouble()); 			} 			 			if(rootNode.get(&quot;inertia&quot;) != null) { 				trigger.setInertia(rootNode.get(&quot;inertia&quot;).asLong()); 			} 			 			return trigger; 		} 		 	} 	      //~ Instance fields ******************************************************************************************************************************  	@Column(nullable = false)     @Enumerated(EnumType.STRING)     private TriggerType type;          @Basic(optional = false)     @Column(name = &quot;name&quot;, nullable = false)     private String name;          @Basic(optional = false)     private Double threshold;          private Double secondaryThreshold;          private Long inertia;      @ManyToOne(optional = false)     @JoinColumn(nullable = false, name = &quot;alert_id&quot;)     private Alert alert;          @ManyToMany(mappedBy = &quot;triggers&quot;, cascade = { CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH })     private List notifications = new ArrayList&lt;&gt;(0);      //~ Constructors *********************************************************************************************************************************      /**      * Creates a new Trigger object.      *      * @param  alert          The alert associated with the trigger. Cannot be null.      * @param  type           The type of the alert. Cannot be null.      * @param  name           The name of the alert. Cannot be null or empty.      * @param  threshold      The threshold value for the alert.      * @param  inertiaMillis  The amount of time in milliseconds a condition must exist for the trigger to fire. Cannot be negative.      */     public Trigger(Alert alert, TriggerType type, String name, double threshold, long inertiaMillis) {         this(alert, type, name, threshold, null, inertiaMillis);     }      /**      * Creates a new Trigger object.      *      * @param  alert               The alert associated with the trigger. Cannot be null.      * @param  type                The type of the alert. Cannot be null.      * @param  name                The name of the alert. Cannot be null or empty.      * @param  threshold           The threshold value for the alert.      * @param  secondaryThreshold  The secondary threshold value for the alert. May be null for types that only require one threshold.      * @param  inertiaMillis       The amount of time in milliseconds a condition must exist for the trigger to fire. Cannot be negative.      */     public Trigger(Alert alert, TriggerType type, String name, Double threshold, Double secondaryThreshold, long inertiaMillis) {         super(alert.getOwner());         setAlert(alert);         setType(type);         setName(name);         setThreshold(threshold);         setSecondaryThreshold(secondaryThreshold);         setInertia(inertiaMillis);         preUpdate();     }      /** Creates a new Trigger object. */     protected Trigger() {         super(null);     }      //~ Methods **************************************************************************************************************************************      /**      * Evaluates the trigger against actualValue (passed as parameter).      *      * @param   trigger      trigger to be evaluated.      * @param   actualValue  value against the trigger to be evaluated.      *      * @return  true if the trigger should be fired so that notification will be sent otherwise false.      *      * @throws  SystemException  If an error in evaluation occurs.      */     public static boolean evaluateTrigger(Trigger trigger, Double actualValue) {         requireArgument(trigger != null, &quot;Trigger cannot be null.&quot;);         requireArgument(actualValue != null, &quot;Trigger cannot be evaulated against null.&quot;);          Double lowThreshold, highThreshold;          switch (trigger.type) {             case GREATER_THAN:                 return actualValue.compareTo(trigger.getThreshold()) &gt; 0;             case GREATER_THAN_OR_EQ:                 return actualValue.compareTo(trigger.getThreshold()) &gt;= 0;             case LESS_THAN:                 return actualValue.compareTo(trigger.getThreshold()) &lt; 0;             case LESS_THAN_OR_EQ:                 return actualValue.compareTo(trigger.getThreshold()) &lt;= 0;             case EQUAL:                 return actualValue.compareTo(trigger.getThreshold()) == 0;             case NOT_EQUAL:                 return actualValue.compareTo(trigger.getThreshold()) != 0;             case BETWEEN:                 lowThreshold = Math.min(trigger.getThreshold(), trigger.getSecondaryThreshold());                 highThreshold = Math.max(trigger.getThreshold(), trigger.getSecondaryThreshold());                 return (actualValue.compareTo(lowThreshold) &gt;= 0 &amp;&amp; actualValue.compareTo(highThreshold) &lt;= 0);             case NOT_BETWEEN:                 lowThreshold = Math.min(trigger.getThreshold(), trigger.getSecondaryThreshold());                 highThreshold = Math.max(trigger.getThreshold(), trigger.getSecondaryThreshold());                 return (actualValue.compareTo(lowThreshold) &lt; 0 || actualValue.compareTo(highThreshold) &gt; 0);             case NO_DATA:             	    return actualValue == null;             default:                 throw new SystemException(&quot;Unsupported trigger type &quot; + trigger.type);         }     }      //~ Methods **************************************************************************************************************************************      /**      * Returns the notifications associated with the trigger.      *      * @return  The associated notifications.      */     public List getNotifications() {         return Collections.unmodifiableList(notifications);     }      /**      * Returns the trigger type.      *      * @return  The trigger type. Will never be null.      */     public TriggerType getType() {         return type;     }      /**      * Sets the trigger type.      *      * @param  type  The trigger type. Cannot be null.      */     public void setType(TriggerType type) {         requireArgument(type != null, &quot;The trigger type cannot be null.&quot;);         this.type = type;     }      /**      * Returns the trigger name.      *      * @return  The trigger name. Will never be null.      */     public String getName() {         return name;     }      /**      * Sets the name of the trigger.      *      * @param  name  The trigger name. Cannot be null or empty.      */     public void setName(String name) {         requireArgument(name != null &amp;&amp; !name.isEmpty(), &quot;Trigger name cannot be null or empty.&quot;);         this.name = name;     }      /**      * Returns the trigger threshold.      *      * @return  The trigger threshold.      */     public Double getThreshold() {         return threshold;     }      /**      * Sets the trigger threshold.      *      * @param  threshold  The trigger threshold. Cannot be null.      */     public void setThreshold(Double threshold) {         requireArgument(threshold != null, &quot;Trigger threshold cannot be null.&quot;);         this.threshold = threshold;     }      /**      * Returns the secondary threshold for the trigger.      *      * @return  The secondary threshold. Can return null for trigger types that only require a single threshold.      */     public Double getSecondaryThreshold() {         return secondaryThreshold;     }      /**      * Sets the secondary threshold for the trigger.      *      * @param  secondaryThreshold  The secondary threshold. Can be null for trigger types that only require a single threshold.      */     public void setSecondaryThreshold(Double secondaryThreshold) {         this.secondaryThreshold = secondaryThreshold;     }      /**      * Returns the inertia associated with the trigger in milliseconds.      *      * @return  The inertia in milliseconds.      */     public Long getInertia() {         return inertia;     }      /**      * Sets the inertia associated with the trigger in milliseconds.      *      * @param  inertiaMillis  The inertia associated with the trigger in milliseconds. Cannot be null or negative.      */     public void setInertia(Long inertiaMillis) {         if (this.alert == null) { // Only during deserialization.             this.inertia = inertiaMillis;         } else {             requireArgument(inertiaMillis != null &amp;&amp; inertiaMillis &gt;= 0, &quot;Inertia cannot be negative.&quot;);             Long longestIntervalLength = AlertUtils.getMaximumIntervalLength(this.alert.getExpression());             if (inertiaMillis &gt; longestIntervalLength)                 throw new IllegalArgumentException(String.format(&quot;Inertia %d cannot be more than width of the longest interval %d.&quot;, inertiaMillis, longestIntervalLength));             this.inertia = inertiaMillis;         }     }      /**      * Returns the alert with which the trigger is associated.      *      * @return  The alert with which the trigger is associated.      */     public Alert getAlert() {         return alert;     }      /**      * Sets the alert with which the trigger is associated.      *      * @param  alert  The alert with which the trigger is associated. Cannot be null.      */     public void setAlert(Alert alert) {         requireArgument(alert != null, &quot;The alert with which a trigger is associated cannot be null.&quot;);         this.alert = alert;     }      @Override     public int hashCode() {         int hash = 7;          hash = 97 * hash + Objects.hashCode(this.name);         hash = 97 * hash + Objects.hashCode(this.alert);         return hash;     }      @Override     public boolean equals(Object obj) {         if (obj == null) {             return false;         }         if (getClass() != obj.getClass()) {             return false;         }          final Trigger other = (Trigger) obj;          if (!Objects.equals(this.name, other.name)) {             return false;         }         if (!Objects.equals(this.alert, other.alert)) {             return false;         }         return true;     }      @Override     public String toString() {         if (type == TriggerType.BETWEEN || type == TriggerType.NOT_BETWEEN)             return &quot;Trigger{&quot; + &quot;type=&quot; + type + &quot;, name=&quot; + name + &quot;, primaryThreshold=&quot; + threshold + &quot;, secondaryThreshold=&quot; + secondaryThreshold +             &quot;, inertia=&quot; + inertia + '}';         else             return &quot;Trigger{&quot; + &quot;type=&quot; + type + &quot;, name=&quot; + name + &quot;, threshold=&quot; + threshold + &quot;, inertia=&quot; + inertia + '}';     }      //~ Enums ****************************************************************************************************************************************      /**      * The type of trigger.      *      * @author  Tom Valine (tvaline@salesforce.com)      */     public enum TriggerType {          /** Greater than. */         GREATER_THAN,         /** Greater than or equal to. */         GREATER_THAN_OR_EQ,         /** Less than. */         LESS_THAN,         /** Less than or equal to. */         LESS_THAN_OR_EQ,         /** Equal to. */         EQUAL,         /** Not equal to. */         NOT_EQUAL,         /** Between. */         BETWEEN,         /** Not between. */         NOT_BETWEEN,     	    /** No Data */     	    NO_DATA;          /**          * Converts a string to a trigger type.          *          * @param   name  The trigger type name.          *          * @return  The corresponding trigger type.          *          * @throws  IllegalArgumentException  If no corresponding trigger type is found.          */         @JsonCreator         public static TriggerType fromString(String name) {             for (TriggerType t : TriggerType.values()) {                 if (t.toString().equalsIgnoreCase(name)) {                     return t;                 }             }             throw new IllegalArgumentException(&quot;Trigger Type does not exist.&quot;);         }          /**          * Returns the name of the trigger type.          *          * @return  The name of the trigger type.          */         @JsonValue         public String value() {             return this.toString();         }      } }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">14590</td>
    <td align="left">https://github.com/salesforce/Argus/blob/121b59a268da264316cded6a3e9271366a23cd86/ArgusCore/src/main/java/com/salesforce/dva/argus/entity/Trigger.java/#L88-L491</td>
    <td align="right">1</td>
    <td align="right">2478</td>
    <td align="right">14590</td>
  </tr>
  <tr valign="top">
    <td align="right">2493</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SuppressWarnings(&quot;serial&quot;) public abstract class StaticMethodMatcherPointcutAdvisor extends StaticMethodMatcherPointcut 		implements PointcutAdvisor, Ordered, Serializable {  	private Advice advice = EMPTY_ADVICE;  	private int order = Ordered.LOWEST_PRECEDENCE;   	/** 	 * Create a new StaticMethodMatcherPointcutAdvisor, 	 * expecting bean-style configuration. 	 * @see #setAdvice 	 */ 	public StaticMethodMatcherPointcutAdvisor() { 	}  	/** 	 * Create a new StaticMethodMatcherPointcutAdvisor for the given advice. 	 * @param advice the Advice to use 	 */ 	public StaticMethodMatcherPointcutAdvisor(Advice advice) { 		Assert.notNull(advice, &quot;Advice must not be null&quot;); 		this.advice = advice; 	}   	public void setOrder(int order) { 		this.order = order; 	}  	@Override 	public int getOrder() { 		return this.order; 	}  	public void setAdvice(Advice advice) { 		this.advice = advice; 	}  	@Override 	public Advice getAdvice() { 		return this.advice; 	}  	@Override 	public boolean isPerInstance() { 		return true; 	}  	@Override 	public Pointcut getPointcut() { 		return this; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14624</td>
    <td align="left">https://github.com/spring-projects/spring-framework/blob/3a0f309e2c9fdbbf7fb2d348be861528177f8555/spring-aop/src/main/java/org/springframework/aop/support/StaticMethodMatcherPointcutAdvisor.java/#L35-L90</td>
    <td align="right">1</td>
    <td align="right">2493</td>
    <td align="right">14624</td>
  </tr>
  <tr valign="top">
    <td align="right">2511</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{             &quot;message&quot;: &quot;YES I found bad smells&quot;,             &quot;bad smells are&quot;: [                 &quot;Blob&quot;,                 &quot;Data Class&quot;             ]         }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class AssemblerConfig {  	// Private Member Variables ------------------------------------------------  	/** The portlet app descriptor, which is usually WEB-INF/portlet.xml. */     private File portletDescriptor;      /** The webapp descriptor to assemble, which is usually WEB-INF/web.xml. */     private File webappDescriptor;      /** The assemble destination, which points to the assembled WAR file. */     private File destination;      /** The class of the servlet that will handle portlet requests */     private String dispatchServletClass;      /** The source archive to assemble */     private File source;          /** Assembler sink buffer size.  Defaults to 4096 bytes. */     private int assemblerSinkBuflen = 1024 * 4; // 4kb      // Public Methods ----------------------------------------------------------      public File getPortletDescriptor() {         return portletDescriptor;     }      public void setPortletDescriptor(File portletDescriptor) {         this.portletDescriptor = portletDescriptor;     }      public File getWebappDescriptor() {         return webappDescriptor;     }      public void setWebappDescriptor(File webappDescriptor) {         this.webappDescriptor = webappDescriptor;     }      public File getDestination() {         return destination;     }      public void setDestination(File destination) {         this.destination = destination;     }      public String getDispatchServletClass() {         return dispatchServletClass;     }      public void setDispatchServletClass(String dispatchServletClass) {         this.dispatchServletClass = dispatchServletClass;     }      /**      * @deprecated use setSource(File) instead.      */     public void setWarSource(File source) {         this.source = source;     }          public void setSource(File source) {         this.source = source;     }          /**      * @deprecated use getSource() instead.      */     public File getWarSource() {         return source;     }          public File getSource() {         return source;     }          public int getAssemblerSinkBuflen() {         return assemblerSinkBuflen;     }          public void setAssemblerSinkBuflen(int buflen) {         this.assemblerSinkBuflen = buflen;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14687</td>
    <td align="left">https://github.com/apache/portals-pluto/blob/4db5ddd26fb2ce642be7b0894858e664c6076a3b/pluto-util/src/main/java/org/apache/pluto/util/assemble/AssemblerConfig.java/#L25-L110</td>
    <td align="right">1</td>
    <td align="right">2511</td>
    <td align="right">14687</td>
  </tr>
  <tr valign="top">
    <td align="right">2512</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad_smells&quot;: [       &quot;1. Long Method&quot;,       &quot;2. Blob&quot;,       &quot;3. Data Class&quot;     ]   } </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@SuppressWarnings(&quot;serial&quot;) public abstract class MqttMessageDeliveryEvent extends MqttIntegrationEvent {  	private final int messageId;  	private final String clientId;  	private final int clientInstance;  	public MqttMessageDeliveryEvent(Object source, int messageId, String clientId, int clientInstance) { 		super(source); 		this.messageId = messageId; 		this.clientId = clientId; 		this.clientInstance = clientInstance; 	}  	public int getMessageId() { 		return this.messageId; 	}  	public String getClientId() { 		return this.clientId; 	}  	public int getClientInstance() { 		return this.clientInstance; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">1. long method, 2. blob, 3. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. long method,  2. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14689</td>
    <td align="left">https://github.com/spring-projects/spring-integration/blob/872302de6e98c1fd34e3192d8e4de244008ca857/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/event/MqttMessageDeliveryEvent.java/#L28-L56</td>
    <td align="right">1</td>
    <td align="right">2512</td>
    <td align="right">14689</td>
  </tr>
  <tr valign="top">
    <td align="right">2524</td>
    <td align="left">&nbsp;{    &quot;response&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;1. Blob&quot;,     &quot;2. Data Class&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LivePropertySource {  	private final List properties; 	private final String sourceName;   	public LivePropertySource(String sourceName, List properties) { 		this.sourceName = sourceName; 		this.properties = properties != null ? ImmutableList.copyOf(properties) : ImmutableList.of(); 	}  	public String getSourceName() { 		return this.sourceName; 	}  	public LiveProperty getProperty(String propertyName) { 		for (LiveProperty liveProperty : properties) { 			if (liveProperty.getProperty().equals(propertyName)) { 				return liveProperty; 			} 		} 		return null; 	}  }</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14719</td>
    <td align="left">https://github.com/spring-projects/sts4/blob/46e9e985b0c5e28ea1952d9fc640ec12fd9c8fdd/headless-services/commons/commons-boot-app-cli/src/main/java/org/springframework/ide/vscode/commons/boot/app/cli/liveproperties/LivePropertySource.java/#L17-L41</td>
    <td align="right">1</td>
    <td align="right">2524</td>
    <td align="right">14719</td>
  </tr>
  <tr valign="top">
    <td align="right">2569</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells, the bad smells are: 1. Blob&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
class Segment {     private byte segmentType;      Segment(byte segmentType) {         this.segmentType = segmentType;     }      /**      * Returns the segmentType value.      *       * @return byte segmentType value.      */     public byte getSegmentType() {         return segmentType;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">14876</td>
    <td align="left">https://github.com/Microsoft/mssql-jdbc/blob/84484edf7944de56749fd2648d0af2ffa2459b7a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java/#L1932-L1947</td>
    <td align="right">1</td>
    <td align="right">2569</td>
    <td align="right">14876</td>
  </tr>
  <tr valign="top">
    <td align="right">2570</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ErrorDataException extends Exception {      /** serialVersionUID. */     private static final long serialVersionUID = -9052741930614009382L;          /** The rpc data package. */     private RpcDataPackage rpcDataPackage;          /** The error code. */     private int errorCode;          /**      * Gets the error code.      *      * @return the error code      */     public int getErrorCode() {         return errorCode;     }      /**      * Sets the error code.      *      * @param errorCode the new error code      */     public void setErrorCode(int errorCode) {         this.errorCode = errorCode;     }      /**      * Gets the rpc data package.      *      * @return the rpc data package      */     public RpcDataPackage getRpcDataPackage() {         return rpcDataPackage;     }      /**      * Sets the rpc data package.      *      * @param rpcDataPackage the new rpc data package      */     public void setRpcDataPackage(RpcDataPackage rpcDataPackage) {         this.rpcDataPackage = rpcDataPackage;     }      /**      * Instantiates a new error data exception.      */     public ErrorDataException() {         super();     }      /**      * Instantiates a new error data exception.      *      * @param message the message      * @param cause the cause      */     public ErrorDataException(String message, Throwable cause) {         super(message, cause);     }          /**      * Instantiates a new error data exception.      *      * @param message the message      * @param cause the cause      * @param errorCode the error code      */     public ErrorDataException(String message, Throwable cause, int errorCode) {         super(message, cause);         this.errorCode = errorCode;     }      /**      * Instantiates a new error data exception.      *      * @param message the message      */     public ErrorDataException(String message) {         super(message);     }      /**      * Instantiates a new error data exception.      *      * @param message the message      * @param errorCode the error code      */     public ErrorDataException(String message, int errorCode) {         super(message);         this.errorCode = errorCode;     }          /**      * Instantiates a new error data exception.      *      * @param cause the cause      */     public ErrorDataException(Throwable cause) {         super(cause);     }          /**      * Instantiates a new error data exception.      *      * @param cause the cause      * @param errorCode the error code      */     public ErrorDataException(Throwable cause, int errorCode) {         super(cause);         this.errorCode = errorCode;     }       }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">14881</td>
    <td align="left">https://github.com/baidu/Jprotobuf-rpc-socket/blob/4422e24c725eaf1f76646f674718bcc8750a4e1d/jprotobuf-rpc-core/src/main/java/com/baidu/jprotobuf/pbrpc/ErrorDataException.java/#L28-L145</td>
    <td align="right">1</td>
    <td align="right">2570</td>
    <td align="right">14881</td>
  </tr>
  <tr valign="top">
    <td align="right">2574</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;,  &quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @Override     protected GraphicsNode createImageGraphicsNode(                 BridgeContext ctx, Element imageElement, ParsedURL purl) {         AbstractFOPBridgeContext bridgeCtx = (AbstractFOPBridgeContext)ctx;          ImageManager manager = bridgeCtx.getImageManager();         ImageSessionContext sessionContext = bridgeCtx.getImageSessionContext();         try {             ImageInfo info = manager.getImageInfo(purl.toString(), sessionContext);             ImageFlavor[] supportedFlavors = getSupportedFlavours();             Image image = manager.getImage(info, supportedFlavors, sessionContext);              //TODO color profile overrides aren't handled, yet!             //ICCColorSpaceExt colorspaceOverride = extractColorSpace(e, ctx);             AbstractGraphicsNode specializedNode = null;             if (image instanceof ImageXMLDOM) {                 ImageXMLDOM xmlImage = (ImageXMLDOM)image;                 if (xmlImage.getDocument() instanceof SVGDocument) {                     //Clone DOM because the Batik's CSS Parser attaches to the DOM and is therefore                     //not thread-safe.                     SVGDocument clonedDoc = (SVGDocument)BatikUtil.cloneSVGDocument(                             xmlImage.getDocument());                     return createSVGImageNode(ctx, imageElement, clonedDoc);                 } else {                     //Convert image to Graphics2D                     image = manager.convertImage(xmlImage,                             new ImageFlavor[] {ImageFlavor.GRAPHICS2D});                 }             }             if (image instanceof ImageRawJPEG) {                 specializedNode = createLoaderImageNode(image, ctx, imageElement, purl);             } else if (image instanceof ImageRawCCITTFax) {                 specializedNode = createLoaderImageNode(image, ctx, imageElement, purl);             } else if (image instanceof ImageGraphics2D) {                 ImageGraphics2D g2dImage = (ImageGraphics2D)image;                 specializedNode = new Graphics2DNode(g2dImage);             } else {                 ctx.getUserAgent().displayError(                         new ImageException(&quot;Cannot convert an image to a usable format: &quot; + purl));             }              if (specializedNode != null) {                 Rectangle2D imgBounds = getImageBounds(ctx, imageElement);                 Rectangle2D bounds = specializedNode.getPrimitiveBounds();                 float [] vb = new float[4];                 vb[0] = 0; // x                 vb[1] = 0; // y                 vb[2] = (float) bounds.getWidth(); // width                 vb[3] = (float) bounds.getHeight(); // height                  // handles the 'preserveAspectRatio', 'overflow' and 'clip'                 // and sets the appropriate AffineTransform to the image node                 initializeViewport(ctx, imageElement, specializedNode, vb, imgBounds);                 return specializedNode;             }         } catch (Exception e) {             ctx.getUserAgent().displayError(e);         }          //Fallback         return superCreateGraphicsNode(ctx, imageElement, purl);     }</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14912</td>
    <td align="left">https://github.com/apache/fop/blob/caced35327f6b6d6eeac2a13543f3c458e902101/fop-core/src/main/java/org/apache/fop/svg/AbstractFOPImageElementBridge.java/#L70-L131</td>
    <td align="right">1</td>
    <td align="right">2574</td>
    <td align="right">14912</td>
  </tr>
  <tr valign="top">
    <td align="right">2579</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public static class Build {          /**          * Project version.          */         private String version = &quot;&quot;;          public String getVersion() {             return version;         }          public void setVersion(final String version) {             this.version = version;         }      }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14944</td>
    <td align="left">https://github.com/eclipse/hawkbit/blob/51be28147f6f575b6c1ab4a5ef84ffd9174f1209/hawkbit-core/src/main/java/org/eclipse/hawkbit/HawkbitServerProperties.java/#L75-L90</td>
    <td align="right">1</td>
    <td align="right">2579</td>
    <td align="right">14944</td>
  </tr>
  <tr valign="top">
    <td align="right">2584</td>
    <td align="left">&nbsp;{   &quot;response&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Long Method&quot;,     &quot;Blob&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;&quot;, propOrder = {     &quot;content&quot; }) @XmlRootElement(name = &quot;cache-policy-conf-other&quot;) public class CachePolicyConfOther {      @XmlMixed     @XmlAnyElement     protected List content;      /**      * Gets the value of the content property.      *       *       * This accessor method returns a reference to the live list,      * not a snapshot. Therefore any modification you make to the      * returned list will be present inside the JAXB object.      * This is why there is not a set method for the content property.      *       *       * For example, to add a new item, do as follows:      *       *    getContent().add(newItem);      *       *       *       *       * Objects of the following type(s) are allowed in the list      * {@link Element }      * {@link String }      */     public List getContent() {         if (content == null) {             content = new ArrayList();         }         return this.content;     }  }</td>
    <td align="left">data class</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method,  blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">14973</td>
    <td align="left">https://github.com/apache/tomee/blob/d21933b313aff812fe5188b57bf572a9ad649148/container/openejb-jee/src/main/java/org/apache/openejb/jee/jba/CachePolicyConfOther.java/#L32-L71</td>
    <td align="right">1</td>
    <td align="right">2584</td>
    <td align="right">14973</td>
  </tr>
  <tr valign="top">
    <td align="right">2601</td>
    <td align="left">&nbsp;{&quot;answer&quot;: &quot;YES I found bad smells, the bad smells are: 1. Blob&quot;}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TfsGitTreeEntriesJson {     private final String objectId;     private final List treeEntries;     private final int size;      @JsonCreator     public TfsGitTreeEntriesJson(         @JsonProperty(&quot;objectId&quot;) final String objectId,         @JsonProperty(&quot;treeEntries&quot;) final List treeEntries,         @JsonProperty(&quot;size&quot;) final int size) throws JsonProcessingException {         this.objectId = objectId;         this.treeEntries = treeEntries;         this.size = size;     }      public String getObjectId() {         return objectId;     }      public List getTreeEntries() {         return treeEntries;     }      public int getSize() {         return size;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">15019</td>
    <td align="left">https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.client.common/src/com/microsoft/tfs/client/common/git/json/TfsGitTreeEntriesJson.java/#L12-L38</td>
    <td align="right">1</td>
    <td align="right">2601</td>
    <td align="right">15019</td>
  </tr>
  <tr valign="top">
    <td align="right">2632</td>
    <td align="left">&nbsp;{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;1. Blob&quot;, &quot;2. Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ReferenceProperty     implements Property {     EntityReference reference;      public ReferenceProperty()     {     }      public ReferenceProperty( EntityReference reference )     {         this.reference = reference;     }      @Override     public EntityReference get()     {         return reference;     }      @Override     public void set( EntityReference newValue )         throws IllegalArgumentException, IllegalStateException     {         reference = newValue;     } }</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15108</td>
    <td align="left">https://github.com/apache/attic-polygene-java/blob/031beef870302a0bd01bd5895ce849e00f2d5d5b/core/runtime/src/main/java/org/apache/polygene/runtime/value/ReferenceProperty.java/#L28-L54</td>
    <td align="right">1</td>
    <td align="right">2632</td>
    <td align="right">15108</td>
  </tr>
  <tr valign="top">
    <td align="right">2648</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;Long Method&quot;, &quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class TCPSocketChannel {     private AsynchronousSocketChannel channel;     private String address;     private int port;     private String logname;      /**      * Create a TCPSocketChannel that is blocking but times out connects and writes.      * @param address The address to connect to.      * @param port The port to connect to. 0 value means don't open.      * @param logname A name to use for logging.      */     public TCPSocketChannel(String address, int port, String logname) {         this.address = address;         this.port = port;         this.logname = logname;          try {             connectWithTimeout();         } catch (IOException e) {             Log(Level.SEVERE, &quot;Failed to connectWithTimeout AsynchronousSocketChannel: &quot; + e);         } catch (ExecutionException e) {             Log(Level.SEVERE, &quot;Failed to connectWithTimeout AsynchronousSocketChannel: &quot; + e);         } catch (InterruptedException e) {             Log(Level.SEVERE, &quot;Failed to connectWithTimeout AsynchronousSocketChannel: &quot; + e);         } catch (TimeoutException e) {             Log(Level.SEVERE, &quot;AsynchronousSocketChannel connectWithTimeout timed out: &quot; + e);         }     }      public int getPort() { return port; }      public String getAddress() { return address; }      public boolean isValid() { return channel != null; }      public boolean isOpen() { return channel.isOpen(); }      private void Log(Level level, String message)     {         TCPUtils.Log(level, &quot;&lt;-&quot; + this.logname + &quot;(&quot; + this.address + &quot;:&quot; + this.port + &quot;) &quot; + message);     }      private void SysLog(Level level, String message)     {         TCPUtils.SysLog(level, &quot;&lt;-&quot; + this.logname + &quot;(&quot; + this.address + &quot;:&quot; + this.port + &quot;) &quot; + message);     }      private void connectWithTimeout() throws  IOException, ExecutionException, InterruptedException, TimeoutException {         if (port == 0)             return;         InetSocketAddress inetSocketAddress = new InetSocketAddress(address, port);         Log(Level.INFO, &quot;Attempting to open SocketChannel with InetSocketAddress: &quot; + inetSocketAddress);         this.channel = AsynchronousSocketChannel.open();         Future connected = this.channel.connect(inetSocketAddress);         connected.get(TCPUtils.DEFAULT_SOCKET_TIMEOUT_MS, TimeUnit.MILLISECONDS);     }      public void close()     {         Log(Level.INFO, &quot;Attempting to close channel.&quot;);         if (this.channel != null)         {             try             {                 this.channel.close();             }             catch (IOException e)             {                 SysLog(Level.SEVERE, &quot;Failed to close channel: &quot; + e);             }         }     }      /**      * Send string over TCP to the specified address via the specified port, including a header.      *      * @param message string to be sent over TCP      * @return true if message was successfully sent      */     public boolean sendTCPString(String message)     {         return sendTCPString(message, 0);     }      /**      * Send string over TCP to the specified address via the specified port, including a header.      *      * @param message string to be sent over TCP      * @param retries number of times to retry in event of failure      * @return true if message was successfully sent      */     public boolean sendTCPString(String message, int retries)     {         Log(Level.FINE, &quot;About to send: &quot; + message);         byte[] bytes = message.getBytes();         return sendTCPBytes(bytes, retries);     }      /**      * Send byte buffer over TCP, including a length header.      *      * @param buffer the bytes to send      * @return true if the message was sent successfully      */     public boolean sendTCPBytes(byte[] buffer)     {         return sendTCPBytes(buffer, 0);     }      /**      * Send byte buffer over TCP, including a length header.      *      * @param bytes the bytes to send      * @param retries number of times to retry in event of failure      * @return true if the message was sent successfully      */     public boolean sendTCPBytes(byte[] bytes, int retries) {         try {             ByteBuffer header = createHeader(bytes.length);              safeWrite(header);              ByteBuffer buffer = ByteBuffer.wrap(bytes);              safeWrite(buffer);          } catch (Exception e) {             SysLog(Level.SEVERE, &quot;Failed to send TCP bytes&quot; + (retries &gt; 0 ? &quot; -- retrying &quot; : &quot;&quot;) + &quot;: &quot; + e);              try {                 channel.close();             } catch (IOException ioe) {             }              if (retries &gt; 0) {                 try {                     connectWithTimeout();                 } catch (Exception connectException) {                     SysLog(Level.SEVERE, &quot;Failed to reconnect: &quot; + connectException);                     return false;                 }                 return sendTCPBytes(bytes, retries - 1);             }              return false;         }         return true;     }      /**      * Send byte buffer over TCP, including a length header.      *       * @param srcbuffers the bytes to send      * @return true if the message was sent successfully      */     public boolean sendTCPBytes(ByteBuffer[] srcbuffers, int length)     {         boolean success = false;         try         {             ByteBuffer header = createHeader(length);             ByteBuffer[] buffers = new ByteBuffer[1 + srcbuffers.length];             buffers[0] = header;             for (int i = 0; i &lt; srcbuffers.length; i++)                 buffers[i + 1] = srcbuffers[i];             if (TCPUtils.isLogging())             {                 long t1 = System.nanoTime();                 long bytesWritten = write(buffers);                 long t2 = System.nanoTime();                 double rate = 1000.0 * 1000.0 * 1000.0 * (double) (bytesWritten) / (1024.0 * (double) (t2 - t1));                 Log(Level.INFO, &quot;Sent &quot; + bytesWritten + &quot; bytes at &quot; + rate + &quot; Kb/s&quot;);             }             else             {                 write(buffers);             }             success = true;         }         catch (Exception e)         {             SysLog(Level.SEVERE, &quot;Failed to send TCP bytes: &quot; + e);             try { channel.close(); } catch (IOException ioe) {}         }         return success;     }      private ByteBuffer createHeader(int length) {         ByteBuffer header = ByteBuffer.allocate(4).order(ByteOrder.BIG_ENDIAN).putInt(length);         header.flip();         return header;     }      private void safeWrite(ByteBuffer buffer) throws InterruptedException, TimeoutException, ExecutionException, IOException {         while (buffer.remaining() &gt; 0) {             Future  future = this.channel.write(buffer);             int bytesWritten = future.get(TCPUtils.DEFAULT_SOCKET_TIMEOUT_MS, TimeUnit.MILLISECONDS);             if (bytesWritten == 0) {                 throw new IOException(&quot;async write failed to send any bytes.&quot;);             }         }     }      private long write(ByteBuffer[] buffers) throws InterruptedException, TimeoutException, ExecutionException, IOException {         long bytesWritten = 0;         for (ByteBuffer b : buffers) {             bytesWritten += b.remaining();             safeWrite(b);         }         return bytesWritten;     } }</td>
    <td align="left">data class</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method,  blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">15162</td>
    <td align="left">https://github.com/Microsoft/malmo/blob/91b1a7a01ec0dd883f81a51048badac0398695f7/Minecraft/src/main/java/com/microsoft/Malmo/Utils/TCPSocketChannel.java/#L15-L228</td>
    <td align="right">1</td>
    <td align="right">2648</td>
    <td align="right">15162</td>
  </tr>
  <tr valign="top">
    <td align="right">2650</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;output&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Blob&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @Override     public Object getValue(final String columnLabel, final Class type) throws SQLException {         Object result;         if (Object.class == type) {             result = decrypt(columnLabel, resultSet.getObject(columnLabel));         } else if (boolean.class == type) {             result = decrypt(columnLabel, resultSet.getBoolean(columnLabel));         } else if (byte.class == type) {             result = decrypt(columnLabel, resultSet.getByte(columnLabel));         } else if (short.class == type) {             result = decrypt(columnLabel, resultSet.getShort(columnLabel));         } else if (int.class == type) {             result = decrypt(columnLabel, resultSet.getInt(columnLabel));         } else if (long.class == type) {             result = decrypt(columnLabel, resultSet.getLong(columnLabel));         } else if (float.class == type) {             result = decrypt(columnLabel, resultSet.getFloat(columnLabel));         } else if (double.class == type) {             result = decrypt(columnLabel, resultSet.getDouble(columnLabel));         } else if (String.class == type) {             result = decrypt(columnLabel, resultSet.getString(columnLabel));         } else if (BigDecimal.class == type) {             result = decrypt(columnLabel, resultSet.getBigDecimal(columnLabel));         } else if (byte[].class == type) {             result = resultSet.getBytes(columnLabel);         } else if (Date.class == type) {             result = resultSet.getDate(columnLabel);         } else if (Time.class == type) {             result = resultSet.getTime(columnLabel);         } else if (Timestamp.class == type) {             result = resultSet.getTimestamp(columnLabel);         } else if (URL.class == type) {             result = resultSet.getURL(columnLabel);         } else if (Blob.class == type) {             result = resultSet.getBlob(columnLabel);         } else if (Clob.class == type) {             result = resultSet.getClob(columnLabel);         } else if (SQLXML.class == type) {             result = resultSet.getSQLXML(columnLabel);         } else if (Reader.class == type) {             result = resultSet.getCharacterStream(columnLabel);         } else {             result = decrypt(columnLabel, resultSet.getObject(columnLabel));         }         return result;     }</td>
    <td align="left">long method</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">long method</td>
    <td align="right">0</td>
    <td align="right">15167</td>
    <td align="left">https://github.com/apache/incubator-shardingsphere/blob/c5cf1d15b02f3a0fb3bda4f15d5f0b3779eac7ba/sharding-core/sharding-core-execute/src/main/java/org/apache/shardingsphere/core/execute/sql/execute/result/StreamQueryResult.java/#L117-L162</td>
    <td align="right">1</td>
    <td align="right">2650</td>
    <td align="right">15167</td>
  </tr>
  <tr valign="top">
    <td align="right">2672</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Graph extends GraphShapeElement { 	public enum Alignment { 		HORIZONTAL, VERTICAL 	}  	private List nodes = new ArrayList&lt;&gt;(); 	private Set edges = new HashSet&lt;&gt;(); 	private Set subgraphs = new HashSet&lt;&gt;(); 	private Alignment alignment = Alignment.VERTICAL;  	/** 	 * Constructs a Graph that uses the specified GraphEventManager to handle 	 * any user generated events on GraphElements. 	 *  	 * @param eventManager 	 */ 	public Graph(GraphController graphController) { 		super(graphController); 	}  	/** 	 * Adds an edge to the Graph and sets its parent to be this Graph. 	 *  	 * @param edge 	 *            the edge to add 	 */ 	public void addEdge(GraphEdge edge) { 		edge.setParent(this); 		edges.add(edge); 	}  	/** 	 * Adds a node to the Graph and sets its parent to be this Graph. 	 *  	 * @param node 	 *            the node to add 	 */ 	public void addNode(GraphNode node) { 		node.setParent(this); 		nodes.add(node); 	}  	/** 	 * Adds a subgraph to the Graph and sets its parent to be this Graph. 	 *  	 * @param subgraph 	 *            the subgraph to add 	 */ 	public void addSubgraph(Graph subgraph) { 		subgraph.setParent(this); 		subgraphs.add(subgraph); 	}  	/** 	 * Returns the alignment of the Graph. 	 *  	 * @return the alignment of the Graph 	 */ 	public Alignment getAlignment() { 		return alignment; 	}  	/** 	 * Returns the edges contained in the Graph. 	 *  	 * @return the edges contained in the Graph 	 */ 	public Set getEdges() { 		return Collections.unmodifiableSet(edges); 	}  	/** 	 * Returns the nodes contained in the Graph. 	 *  	 * @return the nodes contained in the Graph 	 */ 	public List getNodes() { 		return Collections.unmodifiableList(nodes); 	}  	/** 	 * Returns the subgraphs contained in the Graph. 	 *  	 * @return the subgraphs contained in the Graph 	 */ 	public Set getSubgraphs() { 		return Collections.unmodifiableSet(subgraphs); 	}  	/** 	 * Removes an edge from the Graph. 	 *  	 * @param edge 	 *            the edge to remove 	 * @return true if the edge is removed from the Graph 	 */ 	public boolean removeEdge(GraphEdge edge) { 		return edges.remove(edge); 	}  	/** 	 * Removes a node from the Graph. 	 *  	 * @param node 	 *            the node to remove 	 * @return true if the node is removed from the Graph 	 */ 	public boolean removeNode(GraphNode node) { 		return nodes.remove(node); 	}  	/** 	 * Removes a subgraph from the Graph. 	 *  	 * @param subgraph 	 *            the subgraph to remove 	 * @return true if the subgraph is removed from the Graph 	 */ 	public boolean removeSubgraph(Graph subgraph) { 		return subgraphs.remove(subgraph); 	}  	/** 	 * Sets the alignment of the Graph. 	 *  	 * @param alignment 	 *            the new alignment 	 */ 	public void setAlignment(Alignment alignment) { 		this.alignment = alignment; 	} }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15216</td>
    <td align="left">https://github.com/apache/incubator-taverna-workbench/blob/2b74964ac1ee22e56c5dad3321869d84f7052dcf/taverna-graph-model/src/main/java/org/apache/taverna/workbench/models/graph/Graph.java/#L30-L161</td>
    <td align="right">1</td>
    <td align="right">2672</td>
    <td align="right">15216</td>
  </tr>
  <tr valign="top">
    <td align="right">2679</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;output&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Long Method&quot;,             &quot;Blob&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  private void processEmail(EmailData emailData) {     if (logger.isTraceEnabled()) {       logger.trace(&quot;Entered MailManager:processEmail&quot;);     }      if (mailHost == null || mailHost.length() == 0 || emailData == null         || mailToAddresses.length == 0) {       logger.error(&quot;Required mail server configuration is not specfied.&quot;);       if (logger.isDebugEnabled()) {         logger.debug(&quot;Exited MailManager:processEmail: Not sending email as conditions not met&quot;);       }       return;     }      Session session = Session.getDefaultInstance(getMailHostConfiguration());     MimeMessage mimeMessage = new MimeMessage(session);     String subject = emailData.subject;     String message = emailData.message;     String mailToList = getMailToAddressesAsString();      try {       for (int i = 0; i &lt; mailToAddresses.length; i++) {         mimeMessage.addRecipient(Message.RecipientType.TO, new InternetAddress(mailToAddresses[i]));       }        if (subject == null) {         subject = &quot;Alert from GemFire Admin Agent&quot;;       }       mimeMessage.setSubject(subject);        if (message == null) {         message = &quot;&quot;;       }       mimeMessage.setText(message);        Transport.send(mimeMessage);       logger.info(&quot;Email sent to {}. Subject: {}, Content: {}&quot;,           new Object[] {mailToList, subject, message});     } catch (VirtualMachineError err) {       SystemFailure.initiateFailure(err);       // If this ever returns, rethrow the error. We're poisoned       // now, so don't let this thread continue.       throw err;     } catch (Throwable ex) {       // Whenever you catch Error or Throwable, you must also       // catch VirtualMachineError (see above). However, there is       // _still_ a possibility that you are dealing with a cascading       // error condition, so you also need to check to see if the JVM       // is still usable:       SystemFailure.checkFailure();       StringBuilder buf = new StringBuilder();       buf.append(&quot;An exception occurred while sending email.&quot;);       buf.append(           &quot;Unable to send email. Please check your mail settings and the log file.&quot;);       buf.append(&quot;\n\n&quot;).append(           String.format(&quot;Exception message: %s&quot;, ex.getMessage()));       buf.append(&quot;\n\n&quot;).append(           &quot;Following email was not delivered:&quot;);       buf.append(&quot;\n\t&quot;)           .append(String.format(&quot;Mail Host: %s&quot;, mailHost));       buf.append(&quot;\n\t&quot;).append(String.format(&quot;From: %s&quot;, mailFrom));       buf.append(&quot;\n\t&quot;).append(String.format(&quot;To: %s&quot;, mailToList));       buf.append(&quot;\n\t&quot;).append(String.format(&quot;Subject: %s&quot;, subject));       buf.append(&quot;\n\t&quot;).append(String.format(&quot;Content: %s&quot;, message));        logger.error(buf.toString(), ex);     }     if (logger.isTraceEnabled()) {       logger.trace(&quot;Exited MailManager:processEmail&quot;);     }   }</td>
    <td align="left">feature envy</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method,  blob</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">15254</td>
    <td align="left">https://github.com/apache/geode/blob/8fd839e8b73e40bd2dfd14f331b587431bd35a66/geode-core/src/main/java/org/apache/geode/admin/jmx/internal/MailManager.java/#L80-L150</td>
    <td align="right">1</td>
    <td align="right">2679</td>
    <td align="right">15254</td>
  </tr>
  <tr valign="top">
    <td align="right">2683</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Long Method&quot;,             &quot;Blob&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  @Override   public final Description matchClass(ClassTree classTree, VisitorState state) {     if (!HAS_CONSTRUCTORS_WITH_INJECT.matches(classTree, state)) {       return Description.NO_MATCH;     }      List ctors = ASTHelpers.getConstructors(classTree);     List ctorsWithInject =         ctors.stream()             .filter(c -&gt; hasInjectAnnotation().matches(c, state))             .collect(toImmutableList());      if (ctorsWithInject.size() != 1) {       // Injection frameworks don't support multiple @Inject ctors.       // There is already an ERROR check for it.       // http://errorprone.info/bugpattern/MoreThanOneInjectableConstructor       return Description.NO_MATCH;     }      // collect the assignments in ctor     Set variablesAssigned = new HashSet&lt;&gt;();     new TreeScanner() {       @Override       public Void visitAssignment(AssignmentTree tree, Void unused) {         Symbol symbol = ASTHelpers.getSymbol(tree.getVariable());         // check if it is instance field.         if (symbol != null &amp;&amp; symbol.getKind() == ElementKind.FIELD &amp;&amp; !symbol.isStatic()) {           variablesAssigned.add(symbol);         }         return super.visitAssignment(tree, null);       }     }.scan((JCTree) getOnlyElement(ctorsWithInject), null);      SuggestedFix.Builder fix = SuggestedFix.builder();     VariableTree variableTreeFirstMatch = null;     for (Tree member : classTree.getMembers()) {       if (!(member instanceof VariableTree)) {         continue;       }       VariableTree variableTree = (VariableTree) member;       if (!INSTANCE_FIELD_WITH_INJECT.matches(variableTree, state)) {         continue;       }       if (!variablesAssigned.contains(ASTHelpers.getSymbol(variableTree))) {         continue;       }       variableTreeFirstMatch = variableTree;       removeInjectAnnotationFromVariable(variableTree, state).ifPresent(fix::merge);     }     if (variableTreeFirstMatch == null) {       return Description.NO_MATCH;     }     if (fix.isEmpty()) {       return describeMatch(variableTreeFirstMatch);     }     return describeMatch(variableTreeFirstMatch, fix.build());   }</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15269</td>
    <td align="left">https://github.com/google/error-prone/blob/61cb540c08ec63faa56dccce00049cff1f8b41ea/core/src/main/java/com/google/errorprone/bugpatterns/inject/InjectOnMemberAndConstructor.java/#L72-L128</td>
    <td align="right">1</td>
    <td align="right">2683</td>
    <td align="right">15269</td>
  </tr>
  <tr valign="top">
    <td align="right">2703</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             &quot;Long Method&quot;,             &quot;Blob&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    static Class findProviderClass(String className, ClassLoader cl,                                            boolean doFallback)         throws ClassNotFoundException, ConfigurationError     {            //throw security exception if the calling thread is not allowed to access the         //class. Restrict the access to the package classes as specified in java.security policy.         SecurityManager security = System.getSecurityManager();         try{                 if (security != null){                     final int lastDot = className.lastIndexOf('.');                     String packageName = className;                     if (lastDot != -1) packageName = className.substring(0, lastDot);                     security.checkPackageAccess(packageName);                  }            }catch(SecurityException e){             throw e;         }                  Class providerClass;         if (cl == null) {             // XXX Use the bootstrap ClassLoader.  There is no way to             // load a class using the bootstrap ClassLoader that works             // in both JDK 1.1 and Java 2.  However, this should still             // work b/c the following should be true:             //             // (cl == null) iff current ClassLoader == null             //             // Thus Class.forName(String) will use the current             // ClassLoader which will be the bootstrap ClassLoader.             providerClass = Class.forName(className);         } else {             try {                 providerClass = cl.loadClass(className);             } catch (ClassNotFoundException x) {                 if (doFallback) {                     // Fall back to current classloader                     ClassLoader current = ObjectFactory.class.getClassLoader();                     if (current == null) {                         providerClass = Class.forName(className);                     } else if (cl != current) {                         cl = current;                         providerClass = cl.loadClass(className);                     } else {                         throw x;                     }                 } else {                     throw x;                 }             }         }          return providerClass;     }</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15335</td>
    <td align="left">https://github.com/apache/servicemix-bundles/blob/5f2c7727f71c167997947ad4604f9b8200952af2/xalan-2.7.2/src/main/java/org/apache/xalan/xsltc/runtime/ObjectFactory.java/#L477-L529</td>
    <td align="right">1</td>
    <td align="right">2703</td>
    <td align="right">15335</td>
  </tr>
  <tr valign="top">
    <td align="right">2750</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;detected_bad_smells&quot;: [             {                 &quot;1&quot;: &quot;Blob&quot;             },             {                 &quot;2&quot;: &quot;Long Method&quot;             }         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	@Override 	public String getLoggerLevel(String loggerName) { 		String result = null;  /*[IF Sidecar19-SE]*/ 		try { 			Object logger = getLoggerFromName(loggerName); /*[ELSE]	 			Logger logger = LogManager.getLogManager().getLogger(loggerName); /*[ENDIF]*/			 			 			if (logger != null) { 				// The named Logger exists. Now attempt to obtain its log level. /*[IF Sidecar19-SE]*/ 				Object level = logger_getLevel.invoke(logger); /*[ELSE]					 				Level level = logger.getLevel(); /*[ENDIF]*/					 				if (level != null) { /*[IF Sidecar19-SE]*/ 					result = (String)level_getName.invoke(level); /*[ELSE]	 					result = level.getName(); /*[ENDIF]*/	 				} else { 					// A null return from getLevel() means that the Logger 					// is inheriting its log level from an ancestor. Return an 					// empty string to the caller. 					result = &quot;&quot;; //$NON-NLS-1$ 				} 			} /*[IF Sidecar19-SE]*/ 		} catch (Exception e) { 			throw handleError(e); 		} /*[ENDIF]*/ 		 		return result; 	}</td>
    <td align="left">long method</td>
    <td align="left">1: blob, 2: long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1: blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">818</td>
    <td align="left">https://github.com/eclipse/openj9/blob/4911084853eb75b20e037c434ad4521b7317ebfb/jcl/src/java.management/share/classes/com/ibm/java/lang/management/internal/LoggingMXBeanImpl.java/#L148-L186</td>
    <td align="right">1</td>
    <td align="right">2750</td>
    <td align="right">818</td>
  </tr>
  <tr valign="top">
    <td align="right">2851</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells&quot;: [&quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	@Override 	public String getDisplayName() { 		return AssignmentsTestLanguageLanguage.INSTANCE.getDisplayName(); 	}</td>
    <td align="left">feature envy</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">1807</td>
    <td align="left">https://github.com/eclipse/xtext-idea/blob/3aa1424ae35f1942dd7c3a457057006f9131de5e/org.eclipse.xtext.core.idea.tests/src-gen/org/eclipse/xtext/parser/assignments/idea/highlighting/AssignmentsTestLanguageBaseColorSettingsPage.java/#L13-L16</td>
    <td align="right">1</td>
    <td align="right">2851</td>
    <td align="right">1807</td>
  </tr>
  <tr valign="top">
    <td align="right">3326</td>
    <td align="left">&nbsp;{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Data Class&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class RestConfiguration {      public static final String CORS_ACCESS_CONTROL_ALLOW_ORIGIN = &quot;*&quot;;     public static final String CORS_ACCESS_CONTROL_ALLOW_METHODS = &quot;GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, CONNECT, PATCH&quot;;     public static final String CORS_ACCESS_CONTROL_MAX_AGE = &quot;3600&quot;;     public static final String CORS_ACCESS_CONTROL_ALLOW_HEADERS = &quot;Origin, Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers&quot;;      public enum RestBindingMode {         auto, off, json, xml, json_xml     }      public enum RestHostNameResolver {         allLocalIp, localIp, localHostName     }      private String component;     private String apiComponent;     private String producerComponent;     private String producerApiDoc;     private String scheme;     private String host;     private boolean useXForwardHeaders = true;     private String apiHost;     private int port;     private String contextPath;     private String apiContextPath;     private String apiContextRouteId;     private String apiContextIdPattern;     private boolean apiContextListing;     private boolean apiVendorExtension;     private RestHostNameResolver hostNameResolver = RestHostNameResolver.allLocalIp;     private RestBindingMode bindingMode = RestBindingMode.off;     private boolean skipBindingOnErrorCode = true;     private boolean clientRequestValidation;     private boolean enableCORS;     private String jsonDataFormat;     private String xmlDataFormat;     private Map componentProperties;     private Map endpointProperties;     private Map consumerProperties;     private Map dataFormatProperties;     private Map apiProperties;     private Map corsHeaders;      /**      * Gets the name of the Camel component to use as the REST consumer      *      * @return the component name, or null to let Camel search the {@link Registry} to find suitable implementation      */     public String getComponent() {         return component;     }      /**      * Sets the name of the Camel component to use as the REST consumer      *      * @param componentName the name of the component (such as restlet, spark-rest, etc.)      */     public void setComponent(String componentName) {         this.component = componentName;     }      /**      * Gets the name of the Camel component to use as the REST API (such as swagger)      *      * @return the component name, or null to let Camel use the default name swagger      */     public String getApiComponent() {         return apiComponent;     }      /**      * Sets the name of the Camel component to use as the REST API (such as swagger)      *      * @param apiComponent the name of the component (such as swagger)      */     public void setApiComponent(String apiComponent) {         this.apiComponent = apiComponent;     }      /**      * Gets the name of the Camel component to use as the REST producer      *      * @return the component name, or null to let Camel search the {@link Registry} to find suitable implementation      */     public String getProducerComponent() {         return producerComponent;     }      /**      * Sets the name of the Camel component to use as the REST producer      *      * @param componentName the name of the component (such as restlet, jetty, etc.)      */     public void setProducerComponent(String componentName) {         this.producerComponent = componentName;     }      /**      * Gets the location of the api document (swagger api) the REST producer will use      * to validate the REST uri and query parameters are valid accordingly to the api document.      */     public String getProducerApiDoc() {         return producerApiDoc;     }      /**      * Sets the location of the api document (swagger api) the REST producer will use      * to validate the REST uri and query parameters are valid accordingly to the api document.      * This requires adding camel-swagger-java to the classpath, and any miss configuration      * will let Camel fail on startup and report the error(s).      *       * The location of the api document is loaded from classpath by default, but you can use      * file: or http: to refer to resources to load from file or http url.      */     public void setProducerApiDoc(String producerApiDoc) {         this.producerApiDoc = producerApiDoc;     }      /**      * Gets the hostname to use by the REST consumer      *      * @return the hostname, or null to use default hostname      */     public String getHost() {         return host;     }      /**      * Sets the hostname to use by the REST consumer      *      * @param host the hostname      */     public void setHost(String host) {         this.host = host;     }      /**      * WWhether to use X-Forward headers to set host etc. for Swagger.      *       * This option is default true.      */     public boolean isUseXForwardHeaders() {         return useXForwardHeaders;     }      /**      * WWhether to use X-Forward headers to set host etc. for Swagger.      *       * This option is default true.      *       * @param useXForwardHeaders whether to use X-Forward headers      */     public void setUseXForwardHeaders(boolean useXForwardHeaders) {         this.useXForwardHeaders = useXForwardHeaders;     }      public String getApiHost() {         return apiHost;     }      /**      * To use an specific hostname for the API documentation (eg swagger)      *       * This can be used to override the generated host with this configured hostname      */     public void setApiHost(String apiHost) {         this.apiHost = apiHost;     }      /**      * Gets the scheme to use by the REST consumer      *      * @return the scheme, or null to use default scheme      */     public String getScheme() {         return scheme;     }      /**      * Sets the scheme to use by the REST consumer      *      * @param scheme the scheme      */     public void setScheme(String scheme) {         this.scheme = scheme;     }      /**      * Gets the port to use by the REST consumer      *      * @return the port, or 0 or -1 to use default port      */     public int getPort() {         return port;     }      /**      * Sets the port to use by the REST consumer      *      * @param port the port number      */     public void setPort(int port) {         this.port = port;     }      /**      * Gets the configured context-path      *      * @return the context path, or null if none configured.      */     public String getContextPath() {         return contextPath;     }      /**      * Sets a leading context-path the REST services will be using.      *       * This can be used when using components such as camel-servlet where the deployed web application      * is deployed using a context-path. Or for components such as camel-jetty or camel-netty4-http      * that includes a HTTP server.      *      * @param contextPath the context path      */     public void setContextPath(String contextPath) {         this.contextPath = contextPath;     }      public String getApiContextPath() {         return apiContextPath;     }      /**      * Sets a leading API context-path the REST API services will be using.      *       * This can be used when using components such as camel-servlet where the deployed web application      * is deployed using a context-path.      *      * @param contextPath the API context path      */     public void setApiContextPath(String contextPath) {         this.apiContextPath = contextPath;     }      public String getApiContextRouteId() {         return apiContextRouteId;     }      /**      * Sets the route id to use for the route that services the REST API.      *       * The route will by default use an auto assigned route id.      *      * @param apiContextRouteId  the route id      */     public void setApiContextRouteId(String apiContextRouteId) {         this.apiContextRouteId = apiContextRouteId;     }      public String getApiContextIdPattern() {         return apiContextIdPattern;     }      /**      * Optional CamelContext id pattern to only allow Rest APIs from rest services within CamelContext's which name matches the pattern.      *       * The pattern #name# refers to the CamelContext name, to match on the current CamelContext only.      * For any other value, the pattern uses the rules from {@link org.apache.camel.support.EndpointHelper#matchPattern(String, String)}      *      * @param apiContextIdPattern  the pattern      */     public void setApiContextIdPattern(String apiContextIdPattern) {         this.apiContextIdPattern = apiContextIdPattern;     }      public boolean isApiContextListing() {         return apiContextListing;     }      /**      * Sets whether listing of all available CamelContext's with REST services in the JVM is enabled. If enabled it allows to discover      * these contexts, if false then only the current CamelContext is in use.      */     public void setApiContextListing(boolean apiContextListing) {         this.apiContextListing = apiContextListing;     }      public boolean isApiVendorExtension() {         return apiVendorExtension;     }      /**      * Whether vendor extension is enabled in the Rest APIs. If enabled then Camel will include additional information      * as vendor extension (eg keys starting with x-) such as route ids, class names etc.      * Not all 3rd party API gateways and tools supports vendor-extensions when importing your API docs.      */     public void setApiVendorExtension(boolean apiVendorExtension) {         this.apiVendorExtension = apiVendorExtension;     }      /**      * Gets the resolver to use for resolving hostname      *      * @return the resolver      */     public RestHostNameResolver getHostNameResolver() {         return hostNameResolver;     }      /**      * Sets the resolver to use for resolving hostname      *      * @param hostNameResolver the resolver      */     public void setHostNameResolver(RestHostNameResolver hostNameResolver) {         this.hostNameResolver = hostNameResolver;     }      /**      * Sets the resolver to use for resolving hostname      *      * @param hostNameResolver the resolver      */     public void setHostNameResolver(String hostNameResolver) {         this.hostNameResolver = RestHostNameResolver.valueOf(hostNameResolver);     }      /**      * Gets the binding mode used by the REST consumer      *      * @return the binding mode      */     public RestBindingMode getBindingMode() {         return bindingMode;     }      /**      * Sets the binding mode to be used by the REST consumer      *      * @param bindingMode the binding mode      */     public void setBindingMode(RestBindingMode bindingMode) {         this.bindingMode = bindingMode;     }      /**      * Sets the binding mode to be used by the REST consumer      *      * @param bindingMode the binding mode      */     public void setBindingMode(String bindingMode) {         this.bindingMode = RestBindingMode.valueOf(bindingMode);     }      /**      * Whether to skip binding output if there is a custom HTTP error code, and instead use the response body as-is.      *       * This option is default true.      *      * @return whether to skip binding on error code      */     public boolean isSkipBindingOnErrorCode() {         return skipBindingOnErrorCode;     }      /**      * Whether to skip binding output if there is a custom HTTP error code, and instead use the response body as-is.      *       * This option is default true.      *      * @param skipBindingOnErrorCode whether to skip binding on error code      */     public void setSkipBindingOnErrorCode(boolean skipBindingOnErrorCode) {         this.skipBindingOnErrorCode = skipBindingOnErrorCode;     }      public boolean isClientRequestValidation() {         return clientRequestValidation;     }      /**      * Whether to enable validation of the client request to check whether the Content-Type and Accept headers from      * the client is supported by the Rest-DSL configuration of its consumes/produces settings.      *       * This can be turned on, to enable this check. In case of validation error, then HTTP Status codes 415 or 406 is returned.      *       * The default value is false.      */     public void setClientRequestValidation(boolean clientRequestValidation) {         this.clientRequestValidation = clientRequestValidation;     }      /**      * To specify whether to enable CORS which means Camel will automatic include CORS in the HTTP headers in the response.      *       * This option is default false      *      * @return whether CORS is enabled or not      */     public boolean isEnableCORS() {         return enableCORS;     }      /**      * To specify whether to enable CORS which means Camel will automatic include CORS in the HTTP headers in the response.      *       * This option is default false      *      * @param enableCORS true to enable CORS      */     public void setEnableCORS(boolean enableCORS) {         this.enableCORS = enableCORS;     }      /**      * Gets the name of the json data format.      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @return the name, or null to use default      */     public String getJsonDataFormat() {         return jsonDataFormat;     }      /**      * Sets a custom json data format to be used      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @param name name of the data format      */     public void setJsonDataFormat(String name) {         this.jsonDataFormat = name;     }      /**      * Gets the name of the xml data format.      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @return the name, or null to use default      */     public String getXmlDataFormat() {         return xmlDataFormat;     }      /**      * Sets a custom xml data format to be used.      *       * Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.      *      * @param name name of the data format      */     public void setXmlDataFormat(String name) {         this.xmlDataFormat = name;     }      /**      * Gets additional options on component level      *      * @return additional options      */     public Map getComponentProperties() {         return componentProperties;     }      /**      * Sets additional options on component level      *      * @param componentProperties the options      */     public void setComponentProperties(Map componentProperties) {         this.componentProperties = componentProperties;     }      /**      * Gets additional options on endpoint level      *      * @return additional options      */     public Map getEndpointProperties() {         return endpointProperties;     }      /**      * Sets additional options on endpoint level      *      * @param endpointProperties the options      */     public void setEndpointProperties(Map endpointProperties) {         this.endpointProperties = endpointProperties;     }      /**      * Gets additional options on consumer level      *      * @return additional options      */     public Map getConsumerProperties() {         return consumerProperties;     }      /**      * Sets additional options on consumer level      *      * @param consumerProperties the options      */     public void setConsumerProperties(Map consumerProperties) {         this.consumerProperties = consumerProperties;     }      /**      * Gets additional options on data format level      *      * @return additional options      */     public Map getDataFormatProperties() {         return dataFormatProperties;     }      /**      * Sets additional options on data format level      *      * @param dataFormatProperties the options      */     public void setDataFormatProperties(Map dataFormatProperties) {         this.dataFormatProperties = dataFormatProperties;     }      public Map getApiProperties() {         return apiProperties;     }      /**      * Sets additional options on api level      *      * @param apiProperties the options      */     public void setApiProperties(Map apiProperties) {         this.apiProperties = apiProperties;     }      /**      * Gets the CORS headers to use if CORS has been enabled.      *      * @return the CORS headers      */     public Map getCorsHeaders() {         return corsHeaders;     }      /**      * Sets the CORS headers to use if CORS has been enabled.      *      * @param corsHeaders the CORS headers      */     public void setCorsHeaders(Map corsHeaders) {         this.corsHeaders = corsHeaders;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6173</td>
    <td align="left">https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/core/camel-api/src/main/java/org/apache/camel/spi/RestConfiguration.java/#L25-L585</td>
    <td align="right">1</td>
    <td align="right">3326</td>
    <td align="right">6173</td>
  </tr>
  <tr valign="top">
    <td align="right">3437</td>
    <td align="left">&nbsp;{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells&quot;: [     &quot;Blob&quot;,     &quot;Data Class&quot;   ] }  </td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class ChannelTypeXmlResult {      private ChannelType channelType;     private ConfigDescription configDescription;     private boolean system;      public ChannelTypeXmlResult(ChannelType channelType, ConfigDescription configDescription) {         this(channelType, configDescription, false);     }      public ChannelTypeXmlResult(ChannelType channelType, ConfigDescription configDescription, boolean system) {         this.channelType = channelType;         this.configDescription = configDescription;         this.system = system;     }      public ChannelType toChannelType() {         return this.channelType;     }      public ConfigDescription getConfigDescription() {         return this.configDescription;     }      public boolean isSystem() {         return system;     }      @Override     public String toString() {         return &quot;ChannelTypeXmlResult [channelType=&quot; + channelType + &quot;, configDescription=&quot; + configDescription + &quot;]&quot;;     }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">6831</td>
    <td align="left">https://github.com/eclipse/smarthome/blob/b8455de15d65512e8fac4e94d42de6ab2fccf1c5/bundles/core/org.eclipse.smarthome.core.thing.xml/src/main/java/org/eclipse/smarthome/core/thing/xml/internal/ChannelTypeXmlResult.java/#L28-L61</td>
    <td align="right">1</td>
    <td align="right">3437</td>
    <td align="right">6831</td>
  </tr>
  <tr valign="top">
    <td align="right">3557</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;response&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Long Method&quot;,             &quot;Blob&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @Override     public Object getValue(final String columnLabel, final Class type) throws SQLException {         Object result;         if (Object.class == type) {             result = decrypt(columnLabel, resultSet.getObject(columnLabel));         } else if (boolean.class == type) {             result = decrypt(columnLabel, resultSet.getBoolean(columnLabel));         } else if (byte.class == type) {             result = decrypt(columnLabel, resultSet.getByte(columnLabel));         } else if (short.class == type) {             result = decrypt(columnLabel, resultSet.getShort(columnLabel));         } else if (int.class == type) {             result = decrypt(columnLabel, resultSet.getInt(columnLabel));         } else if (long.class == type) {             result = decrypt(columnLabel, resultSet.getLong(columnLabel));         } else if (float.class == type) {             result = decrypt(columnLabel, resultSet.getFloat(columnLabel));         } else if (double.class == type) {             result = decrypt(columnLabel, resultSet.getDouble(columnLabel));         } else if (String.class == type) {             result = decrypt(columnLabel, resultSet.getString(columnLabel));         } else if (BigDecimal.class == type) {             result = decrypt(columnLabel, resultSet.getBigDecimal(columnLabel));         } else if (byte[].class == type) {             result = resultSet.getBytes(columnLabel);         } else if (Date.class == type) {             result = resultSet.getDate(columnLabel);         } else if (Time.class == type) {             result = resultSet.getTime(columnLabel);         } else if (Timestamp.class == type) {             result = resultSet.getTimestamp(columnLabel);         } else if (URL.class == type) {             result = resultSet.getURL(columnLabel);         } else if (Blob.class == type) {             result = resultSet.getBlob(columnLabel);         } else if (Clob.class == type) {             result = resultSet.getClob(columnLabel);         } else if (SQLXML.class == type) {             result = resultSet.getSQLXML(columnLabel);         } else if (Reader.class == type) {             result = resultSet.getCharacterStream(columnLabel);         } else {             result = decrypt(columnLabel, resultSet.getObject(columnLabel));         }         return result;     }</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">7777</td>
    <td align="left">https://github.com/apache/incubator-shardingsphere/blob/c5cf1d15b02f3a0fb3bda4f15d5f0b3779eac7ba/sharding-core/sharding-core-execute/src/main/java/org/apache/shardingsphere/core/execute/sql/execute/result/StreamQueryResult.java/#L117-L162</td>
    <td align="right">1</td>
    <td align="right">3557</td>
    <td align="right">7777</td>
  </tr>
  <tr valign="top">
    <td align="right">3612</td>
    <td align="left">{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [&quot;Blob&quot;] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class DruidPooledCallableStatement extends DruidPooledPreparedStatement implements CallableStatement {      private CallableStatement stmt;      public DruidPooledCallableStatement(DruidPooledConnection conn, PreparedStatementHolder holder) throws SQLException{         super(conn, holder);         this.stmt = (CallableStatement) holder.statement;     }      public CallableStatement getCallableStatementRaw() {         return stmt;     }      @Override     public void registerOutParameter(int parameterIndex, int sqlType) throws SQLException {         try {             stmt.registerOutParameter(parameterIndex, sqlType);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(int parameterIndex, int sqlType, int scale) throws SQLException {         try {             stmt.registerOutParameter(parameterIndex, sqlType, scale);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public boolean wasNull() throws SQLException {         try {             return stmt.wasNull();         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public String getString(int parameterIndex) throws SQLException {         try {             return stmt.getString(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public boolean getBoolean(int parameterIndex) throws SQLException {         try {             return stmt.getBoolean(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public byte getByte(int parameterIndex) throws SQLException {         try {             return stmt.getByte(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public short getShort(int parameterIndex) throws SQLException {         try {             return stmt.getShort(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public int getInt(int parameterIndex) throws SQLException {         try {             return stmt.getInt(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public long getLong(int parameterIndex) throws SQLException {         try {             return stmt.getLong(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public float getFloat(int parameterIndex) throws SQLException {         try {             return stmt.getFloat(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public double getDouble(int parameterIndex) throws SQLException {         try {             return stmt.getDouble(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     @Deprecated     public BigDecimal getBigDecimal(int parameterIndex, int scale) throws SQLException {         try {             return stmt.getBigDecimal(parameterIndex, scale);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public byte[] getBytes(int parameterIndex) throws SQLException {         try {             return stmt.getBytes(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Date getDate(int parameterIndex) throws SQLException {         try {             return stmt.getDate(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Time getTime(int parameterIndex) throws SQLException {         try {             return stmt.getTime(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Timestamp getTimestamp(int parameterIndex) throws SQLException {         try {             return stmt.getTimestamp(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Object getObject(int parameterIndex) throws SQLException {         try {             Object obj = stmt.getObject(parameterIndex);             return wrapObject(obj);         } catch (Throwable t) {             throw checkException(t);         }     }      private Object wrapObject(Object obj) {         if (obj instanceof ResultSet) {             ResultSet rs = (ResultSet) obj;                          DruidPooledResultSet poolableResultSet = new DruidPooledResultSet(this, rs);             addResultSetTrace(poolableResultSet);                          obj = poolableResultSet;         }                  return obj;     }      @Override     public BigDecimal getBigDecimal(int parameterIndex) throws SQLException {         try {             return stmt.getBigDecimal(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Object getObject(int parameterIndex, java.util.Map&gt; map) throws SQLException {         try {             Object obj = stmt.getObject(parameterIndex, map);             return wrapObject(obj);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Ref getRef(int parameterIndex) throws SQLException {         try {             return stmt.getRef(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Blob getBlob(int parameterIndex) throws SQLException {         try {             return stmt.getBlob(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Clob getClob(int parameterIndex) throws SQLException {         try {             return stmt.getClob(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Array getArray(int parameterIndex) throws SQLException {         try {             return stmt.getArray(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Date getDate(int parameterIndex, Calendar cal) throws SQLException {         try {             return stmt.getDate(parameterIndex, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Time getTime(int parameterIndex, Calendar cal) throws SQLException {         try {             return stmt.getTime(parameterIndex, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Timestamp getTimestamp(int parameterIndex, Calendar cal) throws SQLException {         try {             return stmt.getTimestamp(parameterIndex, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(int parameterIndex, int sqlType, String typeName) throws SQLException {         try {             stmt.registerOutParameter(parameterIndex, sqlType, typeName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(String parameterName, int sqlType) throws SQLException {         try {             stmt.registerOutParameter(parameterName, sqlType);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(String parameterName, int sqlType, int scale) throws SQLException {         try {             stmt.registerOutParameter(parameterName, sqlType, scale);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void registerOutParameter(String parameterName, int sqlType, String typeName) throws SQLException {         try {             stmt.registerOutParameter(parameterName, sqlType, typeName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.net.URL getURL(int parameterIndex) throws SQLException {         try {             return stmt.getURL(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setURL(String parameterName, java.net.URL val) throws SQLException {         try {             stmt.setURL(parameterName, val);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNull(String parameterName, int sqlType) throws SQLException {         try {             stmt.setNull(parameterName, sqlType);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBoolean(String parameterName, boolean x) throws SQLException {         try {             stmt.setBoolean(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setByte(String parameterName, byte x) throws SQLException {         try {             stmt.setByte(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setShort(String parameterName, short x) throws SQLException {         try {             stmt.setShort(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setInt(String parameterName, int x) throws SQLException {         try {             stmt.setInt(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setLong(String parameterName, long x) throws SQLException {         try {             stmt.setLong(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setFloat(String parameterName, float x) throws SQLException {         try {             stmt.setFloat(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setDouble(String parameterName, double x) throws SQLException {         try {             stmt.setDouble(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBigDecimal(String parameterName, BigDecimal x) throws SQLException {         try {             stmt.setBigDecimal(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setString(String parameterName, String x) throws SQLException {         try {             stmt.setString(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBytes(String parameterName, byte x[]) throws SQLException {         try {             stmt.setBytes(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setDate(String parameterName, java.sql.Date x) throws SQLException {         try {             stmt.setDate(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setTime(String parameterName, java.sql.Time x) throws SQLException {         try {             stmt.setTime(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setTimestamp(String parameterName, java.sql.Timestamp x) throws SQLException {         try {             stmt.setTimestamp(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setAsciiStream(String parameterName, java.io.InputStream x, int length) throws SQLException {         try {             stmt.setAsciiStream(parameterName, x, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBinaryStream(String parameterName, java.io.InputStream x, int length) throws SQLException {         try {             stmt.setBinaryStream(parameterName, x, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setObject(String parameterName, Object x, int targetSqlType, int scale) throws SQLException {         try {             stmt.setObject(parameterName, x, targetSqlType, scale);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setObject(String parameterName, Object x, int targetSqlType) throws SQLException {         try {             stmt.setObject(parameterName, x, targetSqlType);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setObject(String parameterName, Object x) throws SQLException {         try {             stmt.setObject(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setCharacterStream(String parameterName, java.io.Reader reader, int length) throws SQLException {         try {             stmt.setCharacterStream(parameterName, reader, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setDate(String parameterName, java.sql.Date x, Calendar cal) throws SQLException {         try {             stmt.setDate(parameterName, x, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setTime(String parameterName, java.sql.Time x, Calendar cal) throws SQLException {         try {             stmt.setTime(parameterName, x, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setTimestamp(String parameterName, java.sql.Timestamp x, Calendar cal) throws SQLException {         try {             stmt.setTimestamp(parameterName, x, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNull(String parameterName, int sqlType, String typeName) throws SQLException {         try {             stmt.setNull(parameterName, sqlType, typeName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public String getString(String parameterName) throws SQLException {         try {             return stmt.getString(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public boolean getBoolean(String parameterName) throws SQLException {         try {             return stmt.getBoolean(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public byte getByte(String parameterName) throws SQLException {         try {             return stmt.getByte(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public short getShort(String parameterName) throws SQLException {         try {             return stmt.getShort(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public int getInt(String parameterName) throws SQLException {         try {             return stmt.getInt(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public long getLong(String parameterName) throws SQLException {         try {             return stmt.getLong(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public float getFloat(String parameterName) throws SQLException {         try {             return stmt.getFloat(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public double getDouble(String parameterName) throws SQLException {         try {             return stmt.getDouble(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public byte[] getBytes(String parameterName) throws SQLException {         try {             return stmt.getBytes(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Date getDate(String parameterName) throws SQLException {         try {             return stmt.getDate(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Time getTime(String parameterName) throws SQLException {         try {             return stmt.getTime(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Timestamp getTimestamp(String parameterName) throws SQLException {         try {             return stmt.getTimestamp(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Object getObject(String parameterName) throws SQLException {         try {             Object obj = stmt.getObject(parameterName);             return wrapObject(obj);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public BigDecimal getBigDecimal(String parameterName) throws SQLException {         try {             return stmt.getBigDecimal(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Object getObject(String parameterName, java.util.Map&gt; map) throws SQLException {         try {             Object obj = stmt.getObject(parameterName, map);             return wrapObject(obj);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Ref getRef(String parameterName) throws SQLException {         try {             return stmt.getRef(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Blob getBlob(String parameterName) throws SQLException {         try {             return stmt.getBlob(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Clob getClob(String parameterName) throws SQLException {         try {             return stmt.getClob(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public Array getArray(String parameterName) throws SQLException {         try {             return stmt.getArray(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Date getDate(String parameterName, Calendar cal) throws SQLException {         try {             return stmt.getDate(parameterName, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Time getTime(String parameterName, Calendar cal) throws SQLException {         try {             return stmt.getTime(parameterName, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.sql.Timestamp getTimestamp(String parameterName, Calendar cal) throws SQLException {         try {             return stmt.getTimestamp(parameterName, cal);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.net.URL getURL(String parameterName) throws SQLException {         try {             return stmt.getURL(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public RowId getRowId(int parameterIndex) throws SQLException {         try {             return stmt.getRowId(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public RowId getRowId(String parameterName) throws SQLException {         try {             return stmt.getRowId(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setRowId(String parameterName, RowId x) throws SQLException {         try {             stmt.setRowId(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNString(String parameterName, String value) throws SQLException {         try {             stmt.setNString(parameterName, value);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNCharacterStream(String parameterName, Reader value, long length) throws SQLException {         try {             stmt.setNCharacterStream(parameterName, value, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNClob(String parameterName, NClob value) throws SQLException {         try {             stmt.setNClob(parameterName, value);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setClob(String parameterName, Reader reader, long length) throws SQLException {         try {             stmt.setClob(parameterName, reader, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBlob(String parameterName, InputStream inputStream, long length) throws SQLException {         try {             stmt.setBlob(parameterName, inputStream, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNClob(String parameterName, Reader reader, long length) throws SQLException {         try {             stmt.setNClob(parameterName, reader, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public NClob getNClob(int parameterIndex) throws SQLException {         try {             return stmt.getNClob(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public NClob getNClob(String parameterName) throws SQLException {         try {             return stmt.getNClob(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setSQLXML(String parameterName, SQLXML xmlObject) throws SQLException {         try {             stmt.setSQLXML(parameterName, xmlObject);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public SQLXML getSQLXML(int parameterIndex) throws SQLException {         try {             return stmt.getSQLXML(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public SQLXML getSQLXML(String parameterName) throws SQLException {         try {             return stmt.getSQLXML(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public String getNString(int parameterIndex) throws SQLException {         try {             return stmt.getNString(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public String getNString(String parameterName) throws SQLException {         try {             return stmt.getNString(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.io.Reader getNCharacterStream(int parameterIndex) throws SQLException {         try {             return stmt.getNCharacterStream(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.io.Reader getNCharacterStream(String parameterName) throws SQLException {         try {             return stmt.getNCharacterStream(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.io.Reader getCharacterStream(int parameterIndex) throws SQLException {         try {             return stmt.getCharacterStream(parameterIndex);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public java.io.Reader getCharacterStream(String parameterName) throws SQLException {         try {             return stmt.getCharacterStream(parameterName);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBlob(String parameterName, Blob x) throws SQLException {         try {             stmt.setBlob(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setClob(String parameterName, Clob x) throws SQLException {         try {             stmt.setClob(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setAsciiStream(String parameterName, java.io.InputStream x, long length) throws SQLException {         try {             stmt.setAsciiStream(parameterName, x, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBinaryStream(String parameterName, java.io.InputStream x, long length) throws SQLException {         try {             stmt.setBinaryStream(parameterName, x, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setCharacterStream(String parameterName, java.io.Reader reader, long length) throws SQLException {         try {             stmt.setCharacterStream(parameterName, reader, length);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setAsciiStream(String parameterName, java.io.InputStream x) throws SQLException {         try {             stmt.setAsciiStream(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBinaryStream(String parameterName, java.io.InputStream x) throws SQLException {         try {             stmt.setBinaryStream(parameterName, x);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setCharacterStream(String parameterName, java.io.Reader reader) throws SQLException {         try {             stmt.setCharacterStream(parameterName, reader);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNCharacterStream(String parameterName, Reader value) throws SQLException {         try {             stmt.setNCharacterStream(parameterName, value);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setClob(String parameterName, Reader reader) throws SQLException {         try {             stmt.setClob(parameterName, reader);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setBlob(String parameterName, InputStream inputStream) throws SQLException {         try {             stmt.setBlob(parameterName, inputStream);         } catch (Throwable t) {             throw checkException(t);         }     }      @Override     public void setNClob(String parameterName, Reader reader) throws SQLException {         try {             stmt.setNClob(parameterName, reader);         } catch (Throwable t) {             throw checkException(t);         }     }      public  T getObject(int parameterIndex, Class type) throws SQLException {         throw new SQLFeatureNotSupportedException();     }      public  T getObject(String parameterName, Class type) throws SQLException {         throw new SQLFeatureNotSupportedException();     }      @SuppressWarnings(&quot;unchecked&quot;)     public  T unwrap(Class iface) throws SQLException {         if (iface == CallableStatement.class || iface == PreparedStatement.class) {             if (stmt instanceof CallableStatementProxy) {                 return stmt.unwrap(iface);             }             return (T) stmt;         }                  return super.unwrap(iface);     } }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">8077</td>
    <td align="left">https://github.com/alibaba/druid/blob/768469fe4d1340efe1036453366a58c9ab7e30d1/src/main/java/com/alibaba/druid/pool/DruidPooledCallableStatement.java/#L40-L1089</td>
    <td align="right">1</td>
    <td align="right">3612</td>
    <td align="right">8077</td>
  </tr>
  <tr valign="top">
    <td align="right">3714</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Blob&quot;,       &quot;Data Class&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public class ExistingEnumElements extends AbstractEnumRuleElementFinder { 		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.xtext.enumrules.EnumRulesTestLanguage.ExistingEnum&quot;); 		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1); 		private final EnumLiteralDeclaration cSameNameEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0); 		private final Keyword cSameNameSameNameKeyword_0_0 = (Keyword)cSameNameEnumLiteralDeclaration_0.eContents().get(0); 		private final EnumLiteralDeclaration cOverriddenLiteralEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1); 		private final Keyword cOverriddenLiteralOverriddenKeyword_1_0 = (Keyword)cOverriddenLiteralEnumLiteralDeclaration_1.eContents().get(0); 		private final EnumLiteralDeclaration cDifferentNameEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2); 		private final Keyword cDifferentNameDifferentLiteralKeyword_2_0 = (Keyword)cDifferentNameEnumLiteralDeclaration_2.eContents().get(0); 		 		//enum ExistingEnum: 		//	SameName | OverriddenLiteral=&quot;overridden&quot; | DifferentName=&quot;DifferentLiteral&quot;; 		public EnumRule getRule() { return rule; } 		 		//SameName | OverriddenLiteral=&quot;overridden&quot; | DifferentName=&quot;DifferentLiteral&quot; 		public Alternatives getAlternatives() { return cAlternatives; } 		 		//SameName 		public EnumLiteralDeclaration getSameNameEnumLiteralDeclaration_0() { return cSameNameEnumLiteralDeclaration_0; } 		 		//&quot;SameName&quot; 		public Keyword getSameNameSameNameKeyword_0_0() { return cSameNameSameNameKeyword_0_0; } 		 		//OverriddenLiteral=&quot;overridden&quot; 		public EnumLiteralDeclaration getOverriddenLiteralEnumLiteralDeclaration_1() { return cOverriddenLiteralEnumLiteralDeclaration_1; } 		 		//&quot;overridden&quot; 		public Keyword getOverriddenLiteralOverriddenKeyword_1_0() { return cOverriddenLiteralOverriddenKeyword_1_0; } 		 		//DifferentName=&quot;DifferentLiteral&quot; 		public EnumLiteralDeclaration getDifferentNameEnumLiteralDeclaration_2() { return cDifferentNameEnumLiteralDeclaration_2; } 		 		//&quot;DifferentLiteral&quot; 		public Keyword getDifferentNameDifferentLiteralKeyword_2_0() { return cDifferentNameDifferentLiteralKeyword_2_0; } 	}</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8980</td>
    <td align="left">https://github.com/eclipse/xtext-extras/blob/5634c291880cd46fe2f8e9a47e48ef88b85e8bda/org.eclipse.xtext.extras.tests/src-gen/org/eclipse/xtext/enumrules/services/EnumRulesTestLanguageGrammarAccess.java/#L88-L122</td>
    <td align="right">1</td>
    <td align="right">3714</td>
    <td align="right">8980</td>
  </tr>
  <tr valign="top">
    <td align="right">3763</td>
    <td align="left">{&quot;response&quot;: &quot;YES, I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public final class CurrentCreationalContext {     private final ThreadLocal&gt; creationalContext = new ThreadLocal&gt;();      public CreationalContext get() {         return creationalContext.get();     }      public void set(CreationalContext value) {         creationalContext.set(value);     }      public void remove() {         creationalContext.remove();     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">9405</td>
    <td align="left">https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/container/openejb-core/src/main/java/org/apache/openejb/cdi/CurrentCreationalContext.java/#L24-L38</td>
    <td align="right">1</td>
    <td align="right">3763</td>
    <td align="right">9405</td>
  </tr>
  <tr valign="top">
    <td align="right">3947</td>
    <td align="left">{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [         &quot;Blob&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class Shape {      private String type;      private Map members = Collections.emptyMap();      private String documentation;      private List required;      private List enumValues;      private String payload;      private boolean flattened;      private boolean exception;      private boolean streaming;      private boolean wrapper;      private Member listMember;      private Member mapKeyType;      private Member mapValueType;      @JsonProperty(value = &quot;error&quot;)     private ErrorTrait errorTrait;      private long min;      private long max;      private String pattern;      private boolean fault;      private boolean deprecated;      @JsonProperty(value = &quot;eventstream&quot;)     private boolean isEventStream;      @JsonProperty(value = &quot;event&quot;)     private boolean isEvent;      private String timestampFormat;      private boolean sensitive;      public boolean isFault() {         return fault;     }      public void setFault(boolean fault) {         this.fault = fault;     }      public String getPattern() {         return pattern;     }      public void setPattern(String pattern) {         this.pattern = pattern;     }      public String getType() {         return type;     }      public void setType(String type) {         this.type = type;     }      public Map getMembers() {         return members;     }      public void setMembers(Map members) {         this.members = members;     }      public String getDocumentation() {         return documentation;     }      public void setDocumentation(String documentation) {         this.documentation = documentation;     }      public List getRequired() {         return required;     }      public void setRequired(List required) {         this.required = required;     }      public List getEnumValues() {         return enumValues;     }      @JsonProperty(value = &quot;enum&quot;)     public void setEnumValues(List enumValues) {         this.enumValues = enumValues;     }      public String getPayload() {         return payload;     }      public void setPayload(String payload) {         this.payload = payload;     }      public boolean isFlattened() {         return flattened;     }      public void setFlattened(boolean flattened) {         this.flattened = flattened;     }      public boolean isException() {         return exception;     }      public void setException(boolean exception) {         this.exception = exception;     }      public Member getMapKeyType() {         return mapKeyType;     }      @JsonProperty(value = &quot;key&quot;)     public void setMapKeyType(Member mapKeyType) {         this.mapKeyType = mapKeyType;     }      public Member getMapValueType() {         return mapValueType;     }      @JsonProperty(value = &quot;value&quot;)     public void setMapValueType(Member mapValueType) {         this.mapValueType = mapValueType;     }      public Member getListMember() {         return listMember;     }      @JsonProperty(value = &quot;member&quot;)     public void setListMember(Member listMember) {         this.listMember = listMember;     }      public long getMin() {         return min;     }      public void setMin(long min) {         this.min = min;     }      public long getMax() {         return max;     }      public void setMax(long max) {         this.max = max;     }      public boolean isStreaming() {         return streaming;     }      public void setStreaming(boolean streaming) {         this.streaming = streaming;     }      public boolean isWrapper() {         return wrapper;     }      public void setWrapper(boolean wrapper) {         this.wrapper = wrapper;     }      public ErrorTrait getErrorTrait() {         return errorTrait;     }      public void setErrorTrait(ErrorTrait errorTrait) {         this.errorTrait = errorTrait;     }      public boolean isDeprecated() {         return deprecated;     }      public void setDeprecated(boolean deprecated) {         this.deprecated = deprecated;     }      public boolean isEventStream() {         return isEventStream;     }      public void setIsEventStream(boolean eventStream) {         isEventStream = eventStream;     }      public boolean isEvent() {         return isEvent;     }      public void setIsEvent(boolean event) {         isEvent = event;     }      public String getTimestampFormat() {         return timestampFormat;     }      public void setTimestampFormat(String timestampFormat) {         this.timestampFormat = timestampFormat;     }      public boolean isSensitive() {         return sensitive;     }      public void setSensitive(boolean sensitive) {         this.sensitive = sensitive;     } }</td>
    <td align="left">data class</td>
    <td align="left">blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">10329</td>
    <td align="left">https://github.com/aws/aws-sdk-java-v2/blob/1d5d11e8087c93ab1a3a2d35193052e526fd123c/codegen/src/main/java/software/amazon/awssdk/codegen/model/service/Shape.java/#L23-L261</td>
    <td align="right">1</td>
    <td align="right">3947</td>
    <td align="right">10329</td>
  </tr>
  <tr valign="top">
    <td align="right">3968</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public BindStatus(RequestContext requestContext, String path, boolean htmlEscape) throws IllegalStateException { 		this.requestContext = requestContext; 		this.path = path; 		this.htmlEscape = htmlEscape;  		// determine name of the object and property 		String beanName; 		int dotPos = path.indexOf('.'); 		if (dotPos == -1) { 			// property not set, only the object itself 			beanName = path; 			this.expression = null; 		} 		else { 			beanName = path.substring(0, dotPos); 			this.expression = path.substring(dotPos + 1); 		}  		this.errors = requestContext.getErrors(beanName, false);  		if (this.errors != null) { 			// Usual case: A BindingResult is available as request attribute. 			// Can determine error codes and messages for the given expression. 			// Can use a custom PropertyEditor, as registered by a form controller. 			if (this.expression != null) { 				if (&quot;*&quot;.equals(this.expression)) { 					this.objectErrors = this.errors.getAllErrors(); 				} 				else if (this.expression.endsWith(&quot;*&quot;)) { 					this.objectErrors = this.errors.getFieldErrors(this.expression); 				} 				else { 					this.objectErrors = this.errors.getFieldErrors(this.expression); 					this.value = this.errors.getFieldValue(this.expression); 					this.valueType = this.errors.getFieldType(this.expression); 					if (this.errors instanceof BindingResult) { 						this.bindingResult = (BindingResult) this.errors; 						this.actualValue = this.bindingResult.getRawFieldValue(this.expression); 						this.editor = this.bindingResult.findEditor(this.expression, null); 					} 					else { 						this.actualValue = this.value; 					} 				} 			} 			else { 				this.objectErrors = this.errors.getGlobalErrors(); 			} 			this.errorCodes = initErrorCodes(this.objectErrors); 		}  		else { 			// No BindingResult available as request attribute: 			// Probably forwarded directly to a form view. 			// Let's do the best we can: extract a plain target if appropriate. 			Object target = requestContext.getModelObject(beanName); 			if (target == null) { 				throw new IllegalStateException(&quot;Neither BindingResult nor plain target object for bean name '&quot; + 						beanName + &quot;' available as request attribute&quot;); 			} 			if (this.expression != null &amp;&amp; !&quot;*&quot;.equals(this.expression) &amp;&amp; !this.expression.endsWith(&quot;*&quot;)) { 				BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(target); 				this.value = bw.getPropertyValue(this.expression); 				this.valueType = bw.getPropertyType(this.expression); 				this.actualValue = this.value; 			} 			this.errorCodes = new String[0]; 			this.errorMessages = new String[0]; 		}  		if (htmlEscape &amp;&amp; this.value instanceof String) { 			this.value = HtmlUtils.htmlEscape((String) this.value); 		} 	}</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10409</td>
    <td align="left">https://github.com/spring-projects/spring-framework/blob/3a0f309e2c9fdbbf7fb2d348be861528177f8555/spring-webmvc/src/main/java/org/springframework/web/servlet/support/BindStatus.java/#L96-L169</td>
    <td align="right">1</td>
    <td align="right">3968</td>
    <td align="right">10409</td>
  </tr>
  <tr valign="top">
    <td align="right">3975</td>
    <td align="left">{&quot;response&quot;: &quot;YES I found bad smells&quot;, &quot;detected_bad_smells&quot;: [&quot;1. Blob&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Singleton public class CheProductInfoDataProvider extends ProductInfoDataProviderImpl {    private final LocalizationConstant locale;   private final Resources resources;    @Inject   public CheProductInfoDataProvider(LocalizationConstant locale, Resources resources) {     this.locale = locale;     this.resources = resources;   }    @Override   public String getName() {     return locale.getProductName();   }    @Override   public String getSupportLink() {     return locale.getSupportLink();   }    @Override   public String getDocumentTitle() {     return locale.cheTabTitle();   }    @Override   public String getDocumentTitle(String workspaceName) {     return locale.cheTabTitle(workspaceName);   }    @Override   public SVGResource getLogo() {     return resources.logo();   }    @Override   public SVGResource getWaterMarkLogo() {     return resources.waterMarkLogo();   }    @Override   public String getSupportTitle() {     return locale.supportTitle();   } }</td>
    <td align="left">data class</td>
    <td align="left">1. blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1. blob</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">10430</td>
    <td align="left">https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/plugins/plugin-product-info/src/main/java/org/eclipse/che/plugin/product/info/client/CheProductInfoDataProvider.java/#L26-L72</td>
    <td align="right">1</td>
    <td align="right">3975</td>
    <td align="right">10430</td>
  </tr>
  <tr valign="top">
    <td align="right">3986</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{    &quot;answer&quot;: &quot;YES I found bad smells&quot;,   &quot;bad smells are&quot;: [     &quot;Long Method&quot;,     &quot;Blob&quot;   ]  }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  @Override   public BatchResponsePart executeChangeSet(final BatchHandler handler, final List requests)       throws ODataException {     List responses = new ArrayList();     try {       oDataJPAContext.getODataJPATransaction().begin();        for (ODataRequest request : requests) {         oDataJPAContext.setODataContext(getContext());         ODataResponse response = handler.handleRequest(request);         if (response.getStatus().getStatusCode() &gt;= HttpStatusCodes.BAD_REQUEST.getStatusCode()) {           // Rollback           oDataJPAContext.getODataJPATransaction().rollback();           List errorResponses = new ArrayList(1);           errorResponses.add(response);           return BatchResponsePart.responses(errorResponses).changeSet(false).build();         }         responses.add(response);       }       oDataJPAContext.getODataJPATransaction().commit();        return BatchResponsePart.responses(responses).changeSet(true).build();     } catch (Exception e) {       throw new ODataException(&quot;Error on processing request content:&quot; + e.getMessage(), e);     } finally {       close(true);     }   }</td>
    <td align="left">feature envy</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">long method,  blob</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">10501</td>
    <td align="left">https://github.com/apache/olingo-odata2/blob/c5e9fdf569b5e2e50f5670c91013db8f9ae1d950/odata2-jpa-processor/jpa-api/src/main/java/org/apache/olingo/odata2/jpa/processor/api/ODataJPADefaultProcessor.java/#L270-L297</td>
    <td align="right">1</td>
    <td align="right">3986</td>
    <td align="right">10501</td>
  </tr>
  <tr valign="top">
    <td align="right">3987</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [&quot;Long Method&quot;, &quot;Blob&quot;]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  @Override   public BatchResponsePart executeChangeSet(final BatchHandler handler, final List requests)       throws ODataException {     List responses = new ArrayList();     try {       oDataJPAContext.getODataJPATransaction().begin();        for (ODataRequest request : requests) {         oDataJPAContext.setODataContext(getContext());         ODataResponse response = handler.handleRequest(request);         if (response.getStatus().getStatusCode() &gt;= HttpStatusCodes.BAD_REQUEST.getStatusCode()) {           // Rollback           oDataJPAContext.getODataJPATransaction().rollback();           List errorResponses = new ArrayList(1);           errorResponses.add(response);           return BatchResponsePart.responses(errorResponses).changeSet(false).build();         }         responses.add(response);       }       oDataJPAContext.getODataJPATransaction().commit();        return BatchResponsePart.responses(responses).changeSet(true).build();     } catch (Exception e) {       throw new ODataException(&quot;Error on processing request content:&quot; + e.getMessage(), e);     } finally {       close(true);     }   }</td>
    <td align="left">long method</td>
    <td align="left">long method, blob</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">&nbsp;blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10502</td>
    <td align="left">https://github.com/apache/olingo-odata2/blob/c5e9fdf569b5e2e50f5670c91013db8f9ae1d950/odata2-jpa-processor/jpa-api/src/main/java/org/apache/olingo/odata2/jpa/processor/api/ODataJPADefaultProcessor.java/#L270-L297</td>
    <td align="right">1</td>
    <td align="right">3987</td>
    <td align="right">10502</td>
  </tr>
  <tr valign="top">
    <td align="right">4001</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;{       &quot;output&quot;: &quot;YES, I found bad smells&quot;,       &quot;detected_bad_smells&quot;: [          {             &quot;1&quot;: &quot;Blob&quot;          },          {             &quot;2&quot;: &quot;Long Method&quot;          }       ]    }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    private static boolean resolveGenericRef(GenericRef ref, Class clazz, Type type)     {         if (type instanceof Class)         {             if (type == ref.ifaceClass)             {                 // is this a straight ref or a TypeVariable?                 // debug(&quot;Found ref (as class): %s&quot;,toShortName(type));                 ref.setGenericFromType(type,0);                 return true;             }             else             {                 // Keep digging                 return resolveGenericRef(ref,type);             }         }          if (type instanceof ParameterizedType)         {             ParameterizedType ptype = (ParameterizedType)type;             Type rawType = ptype.getRawType();             if (rawType == ref.ifaceClass)             {                 // debug(&quot;Found ref on [%s] as ParameterizedType [%s]&quot;,toShortName(clazz),toShortName(ptype));                 // Always get the raw type parameter, let unwrap() solve for what it is                 ref.setGenericFromType(ptype.getActualTypeArguments()[0],0);                 return true;             }             else             {                 // Keep digging                 return resolveGenericRef(ref,rawType);             }         }         return false;     }</td>
    <td align="left">feature envy</td>
    <td align="left">1: blob, 2: long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">1: blob,  2: long method</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">10574</td>
    <td align="left">https://github.com/eclipse/jetty.project/blob/65528f76c5ef6ddca11385f9721c8f0bc5f2eed7/jetty-websocket/websocket-common/src/main/java/org/eclipse/jetty/websocket/common/util/ReflectUtils.java/#L189-L225</td>
    <td align="right">1</td>
    <td align="right">4001</td>
    <td align="right">10574</td>
  </tr>
  <tr valign="top">
    <td align="right">4031</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;response&quot;: &quot;YES I found bad smells&quot;,     &quot;the bad smells are&quot;: [       &quot;Blob&quot;,       &quot;Data Class&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@Entity public class Customer388 {  	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id; 	private String firstName; 	private String lastName;  	protected Customer388() {}  	public Customer388(String firstName, String lastName) { 		this.firstName = firstName; 		this.lastName = lastName; 	}  	@Override 	public String toString() { 		return String.format(&quot;Customer388[id=%d, firstName='%s', lastName='%s']&quot;, id, firstName, lastName); 	}  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">10668</td>
    <td align="left">https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer388.java/#L8-L27</td>
    <td align="right">1</td>
    <td align="right">4031</td>
    <td align="right">10668</td>
  </tr>
  <tr valign="top">
    <td align="right">4109</td>
    <td align="left">{&quot;message&quot;: &quot;YES I found bad smells&quot;, &quot;bad smells are&quot;: [&quot;Blob&quot;, &quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
			 			int count = readUnsignedShort(); 			requires = new Require[count]; 			for (int i = 0; i &lt; count; i++) { 				requires[i] = new Require(readUnsignedShort(), readUnsignedShort(), readUnsignedShort()); 			} 			 			count = readUnsignedShort(); 			exports = new Export[count]; 			for (int i = 0; i &lt; count; i++) { 				int index = readUnsignedShort(); 				int flags = readUnsignedShort(); 				int toCount = readUnsignedShort(); 				int[] to = new int[toCount]; 				for (int j = 0; j &lt; toCount; j++) { 					to[j] = readUnsignedShort(); 				} 				exports[i] = new Export(index, flags, to); 			} 			 			count = readUnsignedShort();</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">10822</td>
    <td align="left">https://github.com/eclipse/org.aspectj/blob/370f291c359cd159c5f3f0abd6e9e53e81234a07/bcel-builder/src/main/java/org/aspectj/apache/bcel/classfile/Module.java/#L335-L355</td>
    <td align="right">1</td>
    <td align="right">4109</td>
    <td align="right">10822</td>
  </tr>
  <tr valign="top">
    <td align="right">4138</td>
    <td align="left">&nbsp;{   &quot;message&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;Blob&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
	public class GroupMultiplicitiesElements extends AbstractParserRuleElementFinder { 		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), &quot;org.eclipse.xtext.validation.ConcreteSyntaxValidationTestLanguage.GroupMultiplicities&quot;); 		private final Group cGroup = (Group)rule.eContents().get(1); 		private final Keyword cNumberSignDigitFourKeyword_0 = (Keyword)cGroup.eContents().get(0); 		private final Assignment cVal1Assignment_1 = (Assignment)cGroup.eContents().get(1); 		private final RuleCall cVal1IDTerminalRuleCall_1_0 = (RuleCall)cVal1Assignment_1.eContents().get(0); 		private final Keyword cKw1Keyword_2 = (Keyword)cGroup.eContents().get(2); 		private final Group cGroup_3 = (Group)cGroup.eContents().get(3); 		private final Assignment cVal2Assignment_3_0 = (Assignment)cGroup_3.eContents().get(0); 		private final RuleCall cVal2IDTerminalRuleCall_3_0_0 = (RuleCall)cVal2Assignment_3_0.eContents().get(0); 		private final Assignment cVal3Assignment_3_1 = (Assignment)cGroup_3.eContents().get(1); 		private final RuleCall cVal3IDTerminalRuleCall_3_1_0 = (RuleCall)cVal3Assignment_3_1.eContents().get(0); 		private final Keyword cKw2Keyword_4 = (Keyword)cGroup.eContents().get(4); 		private final Group cGroup_5 = (Group)cGroup.eContents().get(5); 		private final Assignment cVal4Assignment_5_0 = (Assignment)cGroup_5.eContents().get(0); 		private final RuleCall cVal4IDTerminalRuleCall_5_0_0 = (RuleCall)cVal4Assignment_5_0.eContents().get(0); 		private final Assignment cVal5Assignment_5_1 = (Assignment)cGroup_5.eContents().get(1); 		private final RuleCall cVal5IDTerminalRuleCall_5_1_0 = (RuleCall)cVal5Assignment_5_1.eContents().get(0); 		private final Keyword cKw3Keyword_6 = (Keyword)cGroup.eContents().get(6); 		private final Group cGroup_7 = (Group)cGroup.eContents().get(7); 		private final Assignment cVal6Assignment_7_0 = (Assignment)cGroup_7.eContents().get(0); 		private final RuleCall cVal6IDTerminalRuleCall_7_0_0 = (RuleCall)cVal6Assignment_7_0.eContents().get(0); 		private final Assignment cVal7Assignment_7_1 = (Assignment)cGroup_7.eContents().get(1); 		private final RuleCall cVal7IDTerminalRuleCall_7_1_0 = (RuleCall)cVal7Assignment_7_1.eContents().get(0); 		 		//GroupMultiplicities: 		//	&quot;#4&quot; val1=ID &quot;kw1&quot; (val2=ID val3=ID)? &quot;kw2&quot; (val4+=ID val5+=ID)+ &quot;kw3&quot; (val6+=ID val7+=ID)*; 		@Override public ParserRule getRule() { return rule; } 		 		//&quot;#4&quot; val1=ID &quot;kw1&quot; (val2=ID val3=ID)? &quot;kw2&quot; (val4+=ID val5+=ID)+ &quot;kw3&quot; (val6+=ID val7+=ID)* 		public Group getGroup() { return cGroup; } 		 		//&quot;#4&quot; 		public Keyword getNumberSignDigitFourKeyword_0() { return cNumberSignDigitFourKeyword_0; } 		 		//val1=ID 		public Assignment getVal1Assignment_1() { return cVal1Assignment_1; } 		 		//ID 		public RuleCall getVal1IDTerminalRuleCall_1_0() { return cVal1IDTerminalRuleCall_1_0; } 		 		//&quot;kw1&quot; 		public Keyword getKw1Keyword_2() { return cKw1Keyword_2; } 		 		//(val2=ID val3=ID)? 		public Group getGroup_3() { return cGroup_3; } 		 		//val2=ID 		public Assignment getVal2Assignment_3_0() { return cVal2Assignment_3_0; } 		 		//ID 		public RuleCall getVal2IDTerminalRuleCall_3_0_0() { return cVal2IDTerminalRuleCall_3_0_0; } 		 		//val3=ID 		public Assignment getVal3Assignment_3_1() { return cVal3Assignment_3_1; } 		 		//ID 		public RuleCall getVal3IDTerminalRuleCall_3_1_0() { return cVal3IDTerminalRuleCall_3_1_0; } 		 		//&quot;kw2&quot; 		public Keyword getKw2Keyword_4() { return cKw2Keyword_4; } 		 		//(val4+=ID val5+=ID)+ 		public Group getGroup_5() { return cGroup_5; } 		 		//val4+=ID 		public Assignment getVal4Assignment_5_0() { return cVal4Assignment_5_0; } 		 		//ID 		public RuleCall getVal4IDTerminalRuleCall_5_0_0() { return cVal4IDTerminalRuleCall_5_0_0; } 		 		//val5+=ID 		public Assignment getVal5Assignment_5_1() { return cVal5Assignment_5_1; } 		 		//ID 		public RuleCall getVal5IDTerminalRuleCall_5_1_0() { return cVal5IDTerminalRuleCall_5_1_0; } 		 		//&quot;kw3&quot; 		public Keyword getKw3Keyword_6() { return cKw3Keyword_6; } 		 		//(val6+=ID val7+=ID)* 		public Group getGroup_7() { return cGroup_7; } 		 		//val6+=ID 		public Assignment getVal6Assignment_7_0() { return cVal6Assignment_7_0; } 		 		//ID 		public RuleCall getVal6IDTerminalRuleCall_7_0_0() { return cVal6IDTerminalRuleCall_7_0_0; } 		 		//val7+=ID 		public Assignment getVal7Assignment_7_1() { return cVal7Assignment_7_1; } 		 		//ID 		public RuleCall getVal7IDTerminalRuleCall_7_1_0() { return cVal7IDTerminalRuleCall_7_1_0; } 	}</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">10899</td>
    <td align="left">https://github.com/eclipse/xtext-core/blob/e04964e4c2a3e0338c0079bd8333688835e77c31/org.eclipse.xtext.tests/src-gen/org/eclipse/xtext/validation/services/ConcreteSyntaxValidationTestLanguageGrammarAccess.java/#L414-L508</td>
    <td align="right">1</td>
    <td align="right">4138</td>
    <td align="right">10899</td>
  </tr>
  <tr valign="top">
    <td align="right">4314</td>
    <td align="left">&nbsp;{     &quot;output&quot;: &quot;YES I found bad smells&quot;,     &quot;detected bad smells&quot;: [         &quot;1. Blob&quot;,         &quot;2. Data Class&quot;     ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
public class LoopedModelImpl extends MinimalEObjectImpl.Container implements LoopedModel {   /**    * The cached value of the '{@link #getVisibility() Visibility}' attribute list.    *     *     * @see #getVisibility()    * @generated    * @ordered    */   protected EList visibility;    /**    * The cached value of the '{@link #getStatic() Static}' attribute list.    *     *     * @see #getStatic()    * @generated    * @ordered    */   protected EList static_;    /**    * The cached value of the '{@link #getSynchronized() Synchronized}' attribute list.    *     *     * @see #getSynchronized()    * @generated    * @ordered    */   protected EList synchronized_;    /**    * The cached value of the '{@link #getAbstract() Abstract}' attribute list.    *     *     * @see #getAbstract()    * @generated    * @ordered    */   protected EList abstract_;    /**    * The cached value of the '{@link #getFinal() Final}' attribute list.    *     *     * @see #getFinal()    * @generated    * @ordered    */   protected EList final_;    /**    * The default value of the '{@link #getName() Name}' attribute.    *     *     * @see #getName()    * @generated    * @ordered    */   protected static final String NAME_EDEFAULT = null;    /**    * The cached value of the '{@link #getName() Name}' attribute.    *     *     * @see #getName()    * @generated    * @ordered    */   protected String name = NAME_EDEFAULT;    /**    *     *     * @generated    */   protected LoopedModelImpl()   {     super();   }    /**    *     *     * @generated    */   @Override   protected EClass eStaticClass()   {     return UnorderedGroupsTestPackage.Literals.LOOPED_MODEL;   }    /**    *     *     * @generated    */   public EList getVisibility()   {     if (visibility == null)     {       visibility = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY);     }     return visibility;   }    /**    *     *     * @generated    */   public EList getStatic()   {     if (static_ == null)     {       static_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC);     }     return static_;   }    /**    *     *     * @generated    */   public EList getSynchronized()   {     if (synchronized_ == null)     {       synchronized_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED);     }     return synchronized_;   }    /**    *     *     * @generated    */   public EList getAbstract()   {     if (abstract_ == null)     {       abstract_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT);     }     return abstract_;   }    /**    *     *     * @generated    */   public EList getFinal()   {     if (final_ == null)     {       final_ = new EDataTypeEList(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL);     }     return final_;   }    /**    *     *     * @generated    */   public String getName()   {     return name;   }    /**    *     *     * @generated    */   public void setName(String newName)   {     String oldName = name;     name = newName;     if (eNotificationRequired())       eNotify(new ENotificationImpl(this, Notification.SET, UnorderedGroupsTestPackage.LOOPED_MODEL__NAME, oldName, name));   }    /**    *     *     * @generated    */   @Override   public Object eGet(int featureID, boolean resolve, boolean coreType)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         return getVisibility();       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         return getStatic();       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         return getSynchronized();       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         return getAbstract();       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         return getFinal();       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         return getName();     }     return super.eGet(featureID, resolve, coreType);   }    /**    *     *     * @generated    */   @SuppressWarnings(&quot;unchecked&quot;)   @Override   public void eSet(int featureID, Object newValue)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         getVisibility().clear();         getVisibility().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         getStatic().clear();         getStatic().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         getSynchronized().clear();         getSynchronized().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         getAbstract().clear();         getAbstract().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         getFinal().clear();         getFinal().addAll((Collection)newValue);         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         setName((String)newValue);         return;     }     super.eSet(featureID, newValue);   }    /**    *     *     * @generated    */   @Override   public void eUnset(int featureID)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         getVisibility().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         getStatic().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         getSynchronized().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         getAbstract().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         getFinal().clear();         return;       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         setName(NAME_EDEFAULT);         return;     }     super.eUnset(featureID);   }    /**    *     *     * @generated    */   @Override   public boolean eIsSet(int featureID)   {     switch (featureID)     {       case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:         return visibility != null &amp;&amp; !visibility.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:         return static_ != null &amp;&amp; !static_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:         return synchronized_ != null &amp;&amp; !synchronized_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:         return abstract_ != null &amp;&amp; !abstract_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:         return final_ != null &amp;&amp; !final_.isEmpty();       case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:         return NAME_EDEFAULT == null ? name != null : !NAME_EDEFAULT.equals(name);     }     return super.eIsSet(featureID);   }    /**    *     *     * @generated    */   @Override   public String toString()   {     if (eIsProxy()) return super.toString();      StringBuffer result = new StringBuffer(super.toString());     result.append(&quot; (visibility: &quot;);     result.append(visibility);     result.append(&quot;, static: &quot;);     result.append(static_);     result.append(&quot;, synchronized: &quot;);     result.append(synchronized_);     result.append(&quot;, abstract: &quot;);     result.append(abstract_);     result.append(&quot;, final: &quot;);     result.append(final_);     result.append(&quot;, name: &quot;);     result.append(name);     result.append(')');     return result.toString();   }  } //LoopedModelImpl</td>
    <td align="left">data class</td>
    <td align="left">1. blob, 2. data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">1. blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">11368</td>
    <td align="left">https://github.com/eclipse/xtext-eclipse/blob/0c7546b6aaf3644a77fc68eef9f3da368cbbeabd/org.eclipse.xtext.ui.tests/src-gen/org/eclipse/xtext/ui/tests/editor/contentassist/unorderedGroupsTest/impl/LoopedModelImpl.java/#L40-L375</td>
    <td align="right">1</td>
    <td align="right">4314</td>
    <td align="right">11368</td>
  </tr>
  <tr valign="top">
    <td align="right">4604</td>
    <td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{         &quot;message&quot;: &quot;YES I found bad smells&quot;,         &quot;bad smells are&quot;: [             &quot;Blob&quot;,             &quot;Data Class&quot;         ]     }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlRootElement(name = &quot;pagedResult&quot;) @XmlType public class PagedResult implements Serializable {      private static final long serialVersionUID = 3472875885259250934L;      private URI prev;      private URI next;      private final List result = new ArrayList&lt;&gt;();      private int page;      private int size;      private int totalCount;      public URI getPrev() {         return prev;     }      public void setPrev(final URI prev) {         this.prev = prev;     }      public URI getNext() {         return next;     }      public void setNext(final URI next) {         this.next = next;     }      @XmlElementWrapper(name = &quot;result&quot;)     @XmlElement(name = &quot;item&quot;)     @JsonProperty(&quot;result&quot;)     @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = &quot;@class&quot;)     public List getResult() {         return result;     }      public int getPage() {         return page;     }      public void setPage(final int page) {         this.page = page;     }      public int getSize() {         return size;     }      public void setSize(final int size) {         this.size = size;     }      public int getTotalCount() {         return totalCount;     }      public void setTotalCount(final int totalCount) {         this.totalCount = totalCount;     }      @Override     public int hashCode() {         return new HashCodeBuilder().                 append(prev).                 append(next).                 append(result).                 append(page).                 append(size).                 append(totalCount).                 build();     }      @Override     public boolean equals(final Object obj) {         if (this == obj) {             return true;         }         if (obj == null) {             return false;         }         if (getClass() != obj.getClass()) {             return false;         }         @SuppressWarnings(&quot;unchecked&quot;)         final PagedResult other = (PagedResult) obj;         return new EqualsBuilder().                 append(prev, other.prev).                 append(next, other.next).                 append(result, other.result).                 append(page, other.page).                 append(size, other.size).                 append(totalCount, other.totalCount).                 build();     } }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12251</td>
    <td align="left">https://github.com/apache/syncope/blob/114c412afbfba24ffb4fbc804e5308a823a16a78/common/idrepo/lib/src/main/java/org/apache/syncope/common/lib/to/PagedResult.java/#L35-L135</td>
    <td align="right">1</td>
    <td align="right">4604</td>
    <td align="right">12251</td>
  </tr>
  <tr valign="top">
    <td align="right">5084</td>
    <td align="left">{&quot;message&quot;:&quot;YES I found bad smells&quot;,&quot;detected_bad_smells&quot;:[&quot;Blob&quot;,&quot;Data Class&quot;,&quot;Long Method&quot;]}</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
@XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = &quot;ProviderCreditReversalDetails&quot;, propOrder = {     &quot;amazonProviderCreditReversalId&quot;,     &quot;sellerId&quot;,     &quot;providerSellerId&quot;,     &quot;creditReversalReferenceId&quot;,     &quot;creditReversalAmount&quot;,     &quot;creationTimestamp&quot;,     &quot;creditReversalStatus&quot;,     &quot;creditReversalNote&quot; }) public class ProviderCreditReversalDetails {      @XmlElement(name = &quot;AmazonProviderCreditReversalId&quot;, required = true)     protected String amazonProviderCreditReversalId;     @XmlElement(name = &quot;SellerId&quot;, required = true)     protected String sellerId;     @XmlElement(name = &quot;ProviderSellerId&quot;, required = true)     protected String providerSellerId;     @XmlElement(name = &quot;CreditReversalReferenceId&quot;, required = true)     protected String creditReversalReferenceId;     @XmlElement(name = &quot;CreditReversalAmount&quot;, required = true)     protected Price creditReversalAmount;     @XmlElement(name = &quot;CreationTimestamp&quot;, required = true)     @XmlSchemaType(name = &quot;dateTime&quot;)     protected XMLGregorianCalendar creationTimestamp;     @XmlElement(name = &quot;CreditReversalStatus&quot;, required = true)     protected Status creditReversalStatus;     @XmlElement(name = &quot;CreditReversalNote&quot;)     protected String creditReversalNote;      public ProviderCreditReversalDetails() {         super();     }      /**      * Returns the amazonProviderCreditReversalId from notification      *       * @return Returns the amazonProviderCreditReversalId from notification      */     public String getAmazonProviderCreditReversalId() {         return amazonProviderCreditReversalId;     }      /**      * Returns the sellerId from notification      *       * @return Returns the sellerId from notification      */     public String getSellerId() {         return sellerId;     }      /**      * Returns the providerSellerId from notification      *       * @return Returns the providerSellerId from notification      */     public String getProviderSellerId() {         return providerSellerId;     }      /**      * Returns the creditReversalReferenceId from notification      *       * @return Returns the creditReversalReferenceId from notification      */     public String getCreditReversalReferenceId() {         return creditReversalReferenceId;     }       /**      * Returns the creditReversalAmount from notification       *       * @return Returns the creditReversalAmount from notification       */     public Price getCreditReversalAmount() {         return creditReversalAmount;     }      /**      * Returns the creationTimestamp from notification      *       * @return Returns the creationTimestamp from notification      */     public XMLGregorianCalendar getCreationTimestamp() {         return creationTimestamp;     }      /**      * Returns the creditReversalStatus from notification      *       * @return Returns the creditReversalStatus from notification      */     public Status getCreditReversalStatus() {         return creditReversalStatus;     }      /**      * Returns the creditReversalNote from notification      *       * @return Returns the creditReversalNote from notification      */     public String getCreditReversalNote() {         return creditReversalNote;     }      /**      * String representation of providerCreditReversalNotification      */     @Override     public String toString() {         return &quot;ProviderCreditReversalDetails{&quot; + &quot;amazonProviderCreditReversalId=&quot; + amazonProviderCreditReversalId                  + &quot;, sellerId=&quot; + sellerId + &quot;, providerId=&quot; + providerSellerId + &quot;, creditReversalReferenceId=&quot;                  + creditReversalReferenceId + &quot;, creditReversalAmount=&quot; + creditReversalAmount + &quot;, creationTimestamp=&quot;                  + creationTimestamp + &quot;, creditReversalStatus=&quot; + creditReversalStatus + &quot;, creditReversalNote=&quot;                  + creditReversalNote + '}';     }  }</td>
    <td align="left">data class</td>
    <td align="left">blob, data class, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob,  long method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">14204</td>
    <td align="left">https://github.com/amzn/amazon-pay-sdk-java/blob/5a3547d00c796aab8f0c8ac12e0310f7a5c4678a/src/com/amazon/pay/response/ipn/model/ProviderCreditReversalDetails.java/#L25-L145</td>
    <td align="right">1</td>
    <td align="right">5084</td>
    <td align="right">14204</td>
  </tr>
  <tr valign="top">
    <td align="right">5395</td>
    <td align="left">{   &quot;answer&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_smells&quot;: [     &quot;Blob&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
None</td>
    <td align="left">data class</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">blob,  long method</td>
    <td align="left">data class</td>
    <td align="right">0</td>
    <td align="right">15164</td>
    <td align="left">https://github.com/apache/airavata/blob/391843a00eefa7b6213e845f2f044b4e042894d5/modules/registry/registry-server/registry-api-stubs/src/main/java/org/apache/airavata/registry/api/RegistryService.java/#L72161-L72513</td>
    <td align="right">1</td>
    <td align="right">5395</td>
    <td align="right">15164</td>
  </tr>
  <tr valign="top">
    <td align="right">5401</td>
    <td align="left">{   &quot;answer&quot;: &quot;YES I found bad smells&quot;,   &quot;detected_bad_smells&quot;: [     &quot;Blob&quot;,     &quot;Long Method&quot;   ] }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
None</td>
    <td align="left">long method</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15176</td>
    <td align="left">https://github.com/apache/accumulo/blob/f896c98c2356a52dfa2235d2cc02ae556ab17909/proxy/src/main/java/org/apache/accumulo/proxy/thrift/AccumuloProxy.java/#L126206-L126230</td>
    <td align="right">1</td>
    <td align="right">5401</td>
    <td align="right">15176</td>
  </tr>
  <tr valign="top">
    <td align="right">5407</td>
    <td align="left">&nbsp;&nbsp;&nbsp;{     &quot;message&quot;: &quot;YES I found bad smells&quot;,     &quot;bad smells are&quot;: [       &quot;Blob&quot;,       &quot;Long Method&quot;     ]   }</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    public void read(org.apache.thrift.protocol.TProtocol iprot, WMTrigger struct) throws org.apache.thrift.TException {       org.apache.thrift.protocol.TField schemeField;       iprot.readStructBegin();       while (true)       {         schemeField = iprot.readFieldBegin();         if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;         }         switch (schemeField.id) {           case 1: // RESOURCE_PLAN_NAME             if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {               struct.resourcePlanName = iprot.readString();               struct.setResourcePlanNameIsSet(true);             } else {                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);             }             break;           case 2: // TRIGGER_NAME             if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {               struct.triggerName = iprot.readString();               struct.setTriggerNameIsSet(true);             } else {                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);             }             break;           case 3: // TRIGGER_EXPRESSION             if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {               struct.triggerExpression = iprot.readString();               struct.setTriggerExpressionIsSet(true);             } else {                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);             }             break;           case 4: // ACTION_EXPRESSION             if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {               struct.actionExpression = iprot.readString();               struct.setActionExpressionIsSet(true);             } else {                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);             }             break;           case 5: // IS_IN_UNMANAGED             if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {               struct.isInUnmanaged = iprot.readBool();               struct.setIsInUnmanagedIsSet(true);             } else {                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);             }             break;           case 6: // NS             if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {               struct.ns = iprot.readString();               struct.setNsIsSet(true);             } else {                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);             }             break;           default:             org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);         }         iprot.readFieldEnd();       }       iprot.readStructEnd();       struct.validate();     }</td>
    <td align="left">long method</td>
    <td align="left">blob, long method</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">t</td>
    <td align="left">blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">15185</td>
    <td align="left">https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/standalone-metastore/metastore-common/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/WMTrigger.java/#L733-L798</td>
    <td align="right">1</td>
    <td align="right">5407</td>
    <td align="right">15185</td>
  </tr>
  <tr valign="top">
    <td align="right">5516</td>
    <td align="left">&nbsp;&nbsp;&nbsp;YES I found bad smells  the bad smells are: 1. Blob 2. Long method</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @SuppressWarnings(&quot;try&quot;)     private void doRun(Map entryPoints, Method mainEntryPoint,                     JavaMainSupport javaMainSupport, String imageName, AbstractBootImage.NativeImageKind k,                     SubstitutionProcessor harnessSubstitutions,                     ForkJoinPool compilationExecutor, ForkJoinPool analysisExecutor) {         List hostedEntryPoints = new ArrayList&lt;&gt;();          OptionValues options = HostedOptionValues.singleton();         SnippetReflectionProvider originalSnippetReflection = GraalAccess.getOriginalSnippetReflection();         try (DebugContext debug = DebugContext.create(options, new GraalDebugHandlersFactory(originalSnippetReflection))) {             setupNativeImage(imageName, options, entryPoints, javaMainSupport, harnessSubstitutions, analysisExecutor, originalSnippetReflection, debug);              boolean returnAfterAnalysis = runPointsToAnalysis(imageName, options, debug);             if (returnAfterAnalysis) {                 return;             }              NativeImageHeap heap;             HostedMethod mainEntryPointHostedStub;             HostedMetaAccess hMetaAccess;             SharedRuntimeConfigurationBuilder runtime;             try (StopTimer t = new Timer(imageName, &quot;universe&quot;).start()) {                 hUniverse = new HostedUniverse(bigbang);                 hMetaAccess = new HostedMetaAccess(hUniverse, bigbang.getMetaAccess());                  new UniverseBuilder(aUniverse, bigbang.getMetaAccess(), hUniverse, hMetaAccess, HostedConfiguration.instance().createStaticAnalysisResultsBuilder(bigbang, hUniverse),                                 bigbang.getUnsupportedFeatures()).build(debug);                  runtime = new HostedRuntimeConfigurationBuilder(options, bigbang.getHostVM(), hUniverse, hMetaAccess, bigbang.getProviders()).build();                 registerGraphBuilderPlugins(featureHandler, runtime.getRuntimeConfig(), (HostedProviders) runtime.getRuntimeConfig().getProviders(), bigbang.getMetaAccess(), aUniverse,                                 hMetaAccess, hUniverse,                                 nativeLibraries, loader, false, true, bigbang.getAnnotationSubstitutionProcessor(), new SubstrateClassInitializationPlugin((SVMHost) aUniverse.hostVM()),                                 bigbang.getHostVM().getClassInitializationSupport());                  if (NativeImageOptions.PrintUniverse.getValue()) {                     printTypes();                 }                  /* Find the entry point methods in the hosted world. */                 for (AnalysisMethod m : aUniverse.getMethods()) {                     if (m.isEntryPoint()) {                         HostedMethod found = hUniverse.lookup(m);                         assert found != null;                         hostedEntryPoints.add(found);                     }                 }                 /* Find main entry point */                 if (mainEntryPoint != null) {                     AnalysisMethod analysisStub = CEntryPointCallStubSupport.singleton().getStubForMethod(mainEntryPoint);                     mainEntryPointHostedStub = (HostedMethod) hMetaAccess.getUniverse().lookup(analysisStub);                     assert hostedEntryPoints.contains(mainEntryPointHostedStub);                 } else {                     mainEntryPointHostedStub = null;                 }                 if (hostedEntryPoints.size() == 0) {                     throw UserError.abort(&quot;Warning: no entry points found, i.e., no method annotated with @&quot; + CEntryPoint.class.getSimpleName());                 }                  heap = new NativeImageHeap(aUniverse, hUniverse, hMetaAccess);                  BeforeCompilationAccessImpl config = new BeforeCompilationAccessImpl(featureHandler, loader, aUniverse, hUniverse, hMetaAccess, heap, debug);                 featureHandler.forEachFeature(feature -&gt; feature.beforeCompilation(config));                  bigbang.getUnsupportedFeatures().report(bigbang);             } catch (UnsupportedFeatureException ufe) {                 throw UserError.abort(ufe.getMessage());             }              recordMethodsWithStackValues();             recordRestrictHeapAccessCallees(aUniverse.getMethods());              /*              * After this point, all TypeFlow (and therefore also TypeState) objects are unreachable              * and can be garbage collected. This is important to keep the overall memory footprint              * low. However, this also means we no longer have complete call chain information. Only              * the summarized information stored in the StaticAnalysisResult objects is available              * after this point.              */             bigbang.cleanupAfterAnalysis();              NativeImageCodeCache codeCache;             CompileQueue compileQueue;             try (StopTimer t = new Timer(imageName, &quot;compile&quot;).start()) {                 compileQueue = HostedConfiguration.instance().createCompileQueue(debug, featureHandler, hUniverse, runtime, DeoptTester.enabled(), bigbang.getProviders().getSnippetReflection(),                                 compilationExecutor);                 compileQueue.finish(debug);                  /* release memory taken by graphs for the image writing */                 hUniverse.getMethods().forEach(HostedMethod::clear);                  codeCache = NativeImageCodeCacheFactory.get().newCodeCache(compileQueue, heap);                 codeCache.layoutConstants();                 codeCache.layoutMethods(debug, imageName);                  AfterCompilationAccessImpl config = new AfterCompilationAccessImpl(featureHandler, loader, aUniverse, hUniverse, hMetaAccess, heap, debug);                 featureHandler.forEachFeature(feature -&gt; feature.afterCompilation(config));             }              try (Indent indent = debug.logAndIndent(&quot;create native image&quot;)) {                 try (DebugContext.Scope buildScope = debug.scope(&quot;CreateBootImage&quot;)) {                     try (StopTimer t = new Timer(imageName, &quot;image&quot;).start()) {                          // Start building the model of the native image heap.                         heap.addInitialObjects();                         // Then build the model of the code cache, which can                         // add objects to the native image heap.                         codeCache.addConstantsToHeap();                         // Finish building the model of the native image heap.                         heap.addTrailingObjects();                          AfterHeapLayoutAccessImpl config = new AfterHeapLayoutAccessImpl(featureHandler, loader, hMetaAccess, debug);                         featureHandler.forEachFeature(feature -&gt; feature.afterHeapLayout(config));                          this.image = AbstractBootImage.create(k, hUniverse, hMetaAccess, nativeLibraries, heap, codeCache, hostedEntryPoints, mainEntryPointHostedStub, loader.getClassLoader());                         image.build(debug);                         if (NativeImageOptions.PrintUniverse.getValue()) {                             /*                              * This debug output must be printed _after_ and not _during_ image                              * building, because it adds some PrintStream objects to static fields,                              * which disrupts the heap.                              */                             codeCache.printCompilationResults();                         }                     }                 }             }              BeforeImageWriteAccessImpl beforeConfig = new BeforeImageWriteAccessImpl(featureHandler, loader, imageName, image,                             runtime.getRuntimeConfig(), aUniverse, hUniverse, optionProvider, hMetaAccess, debug);             featureHandler.forEachFeature(feature -&gt; feature.beforeImageWrite(beforeConfig));              try (StopTimer t = new Timer(imageName, &quot;write&quot;).start()) {                 /*                  * This will write the debug info too -- i.e. we may be writing more than one file,                  * if the debug info is in a separate file. We need to push writing the file to the                  * image implementation, because whether the debug info and image share a file or                  * not is an implementation detail of the image.                  */                 Path tmpDir = tempDirectory();                 Path imagePath = image.write(debug, generatedFiles(HostedOptionValues.singleton()), tmpDir, imageName, beforeConfig).getOutputFile();                  AfterImageWriteAccessImpl afterConfig = new AfterImageWriteAccessImpl(featureHandler, loader, hUniverse, imagePath, tmpDir, image.getBootImageKind(), debug);                 featureHandler.forEachFeature(feature -&gt; feature.afterImageWrite(afterConfig));             }         }     }</td>
    <td align="left">feature envy</td>
    <td align="left">&nbsp;Blob2 Long method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">f</td>
    <td align="left">. Blob2. Long method</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">4261</td>
    <td align="left">https://github.com/oracle/graal/blob/4deb681aaaa79c248115037fc8e399c9876619fd/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageGenerator.java/#L487-L632</td>
    <td align="right">1</td>
    <td align="right">5516</td>
    <td align="right">4261</td>
  </tr>
  <tr valign="top">
    <td align="right">5526</td>
    <td align="left">&nbsp;YES I found bad smells the bad smells are: 1. Blob 2. Long method</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  private void asJson(OutputStream out, Map data)       throws HiveException       {     try {       new ObjectMapper().writeValue(out, data);     } catch (IOException e) {       throw new HiveException(&quot;Unable to convert to json&quot;, e);     }       }</td>
    <td align="left">feature envy</td>
    <td align="left">&nbsp;Blob2 Long method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">f</td>
    <td align="left">. Blob2. Long method</td>
    <td align="left">feature envy</td>
    <td align="right">0</td>
    <td align="right">5595</td>
    <td align="left">https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/ql/src/java/org/apache/hadoop/hive/ql/metadata/formatting/JsonMetaDataFormatter.java/#L76-L84</td>
    <td align="right">1</td>
    <td align="right">5526</td>
    <td align="right">5595</td>
  </tr>
  <tr valign="top">
    <td align="right">5571</td>
    <td align="left">&nbsp;YES I found bad smells  the bad smells are: Blob, Data Class, Feature Envy, Long Method</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
  @Override   public void configureInputJobProperties(TableDesc tableDesc,                       Map jobProperties) {      try {       Map tableProperties = tableDesc.getJobProperties();        String jobInfoProperty = tableProperties.get(HCatConstants.HCAT_KEY_JOB_INFO);       if (jobInfoProperty != null) {          LinkedList inputJobInfos = (LinkedList) HCatUtil.deserialize(                 jobInfoProperty);         if (inputJobInfos == null || inputJobInfos.isEmpty()) {           throw new IOException(&quot;No InputJobInfo was set in job config&quot;);         }         InputJobInfo inputJobInfo = inputJobInfos.getLast();          HCatTableInfo tableInfo = inputJobInfo.getTableInfo();         HCatSchema dataColumns = tableInfo.getDataColumns();         List dataFields = dataColumns.getFields();         StringBuilder columnNamesSb = new StringBuilder();         StringBuilder typeNamesSb = new StringBuilder();         for (HCatFieldSchema dataField : dataFields) {         if (columnNamesSb.length() &gt; 0) {             columnNamesSb.append(&quot;,&quot;);             typeNamesSb.append(&quot;:&quot;);           }           columnNamesSb.append(dataField.getName());           typeNamesSb.append(dataField.getTypeString());         }         jobProperties.put(IOConstants.SCHEMA_EVOLUTION_COLUMNS, columnNamesSb.toString());         jobProperties.put(IOConstants.SCHEMA_EVOLUTION_COLUMNS_TYPES, typeNamesSb.toString());          boolean isTransactionalTable = AcidUtils.isTablePropertyTransactional(tableProperties);         AcidUtils.AcidOperationalProperties acidOperationalProperties =                 AcidUtils.getAcidOperationalProperties(tableProperties);         AcidUtils.setAcidOperationalProperties(             jobProperties, isTransactionalTable, acidOperationalProperties);       }     } catch (IOException e) {       throw new IllegalStateException(&quot;Failed to set output path&quot;, e);     }    }</td>
    <td align="left">feature envy</td>
    <td align="left">&nbsp;Blob, Data Class, Feature Envy, Long Method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp;Blob,  Data Class,  Long Method</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">8188</td>
    <td align="left">https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/hcatalog/core/src/main/java/org/apache/hive/hcatalog/mapreduce/FosterStorageHandler.java/#L107-L150</td>
    <td align="right">1</td>
    <td align="right">5571</td>
    <td align="right">8188</td>
  </tr>
  <tr valign="top">
    <td align="right">5690</td>
    <td align="left">&nbsp;YES I found bad smells  the bad smells are: 1. Blob 2. Long method</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @Override     public java.util.concurrent.Future updateStack(             final UpdateStackRequest request,             final com.oracle.bmc.responses.AsyncHandler                     handler) {         LOG.trace(&quot;Called async updateStack&quot;);         final UpdateStackRequest interceptedRequest =                 UpdateStackConverter.interceptRequest(request);         final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =                 UpdateStackConverter.fromRequest(client, interceptedRequest);         final com.google.common.base.Function                 transformer = UpdateStackConverter.fromResponse();          com.oracle.bmc.responses.AsyncHandler                 handlerToUse = handler;         if (handler != null                 &amp;&amp; this.authenticationDetailsProvider                         instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {             handlerToUse =                     new com.oracle.bmc.util.internal.RefreshAuthTokenWrappingAsyncHandler&lt;                             UpdateStackRequest, UpdateStackResponse&gt;(                             (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)                                     this.authenticationDetailsProvider,                             handler) {                         @Override                         public void retryCall() {                             final com.oracle.bmc.util.internal.Consumer                                     onSuccess =                                             new com.oracle.bmc.http.internal.SuccessConsumer&lt;&gt;(                                                     this, transformer, interceptedRequest);                             final com.oracle.bmc.util.internal.Consumer onError =                                     new com.oracle.bmc.http.internal.ErrorConsumer&lt;&gt;(                                             this, interceptedRequest);                             client.put(                                     ib,                                     interceptedRequest.getUpdateStackDetails(),                                     interceptedRequest,                                     onSuccess,                                     onError);                         }                     };         }          final com.oracle.bmc.util.internal.Consumer onSuccess =                 (handler == null)                         ? null                         : new com.oracle.bmc.http.internal.SuccessConsumer&lt;&gt;(                                 handlerToUse, transformer, interceptedRequest);         final com.oracle.bmc.util.internal.Consumer onError =                 (handler == null)                         ? null                         : new com.oracle.bmc.http.internal.ErrorConsumer&lt;&gt;(                                 handlerToUse, interceptedRequest);          java.util.concurrent.Future responseFuture =                 client.put(                         ib,                         interceptedRequest.getUpdateStackDetails(),                         interceptedRequest,                         onSuccess,                         onError);          if (this.authenticationDetailsProvider                 instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {             return new com.oracle.bmc.util.internal.RefreshAuthTokenTransformingFuture&lt;                     javax.ws.rs.core.Response, UpdateStackResponse&gt;(                     responseFuture,                     transformer,                     (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)                             this.authenticationDetailsProvider,                     new com.google.common.base.Supplier&lt;                             java.util.concurrent.Future&gt;() {                         @Override                         public java.util.concurrent.Future get() {                             return client.put(                                     ib,                                     interceptedRequest.getUpdateStackDetails(),                                     interceptedRequest,                                     onSuccess,                                     onError);                         }                     });         } else {             return new com.oracle.bmc.util.internal.TransformingFuture&lt;&gt;(                     responseFuture, transformer);         }     }</td>
    <td align="left">long method</td>
    <td align="left">&nbsp;Blob2 Long method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">&nbsp; </td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12064</td>
    <td align="left">https://github.com/oracle/oci-java-sdk/blob/76e9cecd7b309d9f12e5efe96c74167c66a98872/bmc-resourcemanager/src/main/java/com/oracle/bmc/resourcemanager/ResourceManagerAsyncClient.java/#L1366-L1452</td>
    <td align="right">1</td>
    <td align="right">5690</td>
    <td align="right">12064</td>
  </tr>
  <tr valign="top">
    <td align="right">5691</td>
    <td align="left">&nbsp;&nbsp;YES I found bad smells The bad smells are: 1. Blob, 2. Long method</td>
    <td align="left">The list below presents common code smells (aka bad<br />
smells) I need to check if the Java code provided at the<br />
end of the input contains at least one of them.<br />
* Blob<br />
* Data Class<br />
* Feature Envy<br />
* Long Method<br />
Could you please identify which smells occur in the<br />
following code? However, do not describe the smells, just<br />
list them.<br />
Please start your answer with “YES I found bad smells”<br />
when you find any bad smell. Otherwise, start your answer<br />
with “NO, I did not find any bad smell”.<br />
When you start to list the detected bad smells, always<br />
put in your answer “the bad smells are:” amongst the text<br />
your answer and always separate it in this format: 1. Long<br />
method, 2.Feature envy:<br />
    @SuppressWarnings(&quot;try&quot;)     private void doRun(Map entryPoints, Method mainEntryPoint,                     JavaMainSupport javaMainSupport, String imageName, AbstractBootImage.NativeImageKind k,                     SubstitutionProcessor harnessSubstitutions,                     ForkJoinPool compilationExecutor, ForkJoinPool analysisExecutor) {         List hostedEntryPoints = new ArrayList&lt;&gt;();          OptionValues options = HostedOptionValues.singleton();         SnippetReflectionProvider originalSnippetReflection = GraalAccess.getOriginalSnippetReflection();         try (DebugContext debug = DebugContext.create(options, new GraalDebugHandlersFactory(originalSnippetReflection))) {             setupNativeImage(imageName, options, entryPoints, javaMainSupport, harnessSubstitutions, analysisExecutor, originalSnippetReflection, debug);              boolean returnAfterAnalysis = runPointsToAnalysis(imageName, options, debug);             if (returnAfterAnalysis) {                 return;             }              NativeImageHeap heap;             HostedMethod mainEntryPointHostedStub;             HostedMetaAccess hMetaAccess;             SharedRuntimeConfigurationBuilder runtime;             try (StopTimer t = new Timer(imageName, &quot;universe&quot;).start()) {                 hUniverse = new HostedUniverse(bigbang);                 hMetaAccess = new HostedMetaAccess(hUniverse, bigbang.getMetaAccess());                  new UniverseBuilder(aUniverse, bigbang.getMetaAccess(), hUniverse, hMetaAccess, HostedConfiguration.instance().createStaticAnalysisResultsBuilder(bigbang, hUniverse),                                 bigbang.getUnsupportedFeatures()).build(debug);                  runtime = new HostedRuntimeConfigurationBuilder(options, bigbang.getHostVM(), hUniverse, hMetaAccess, bigbang.getProviders()).build();                 registerGraphBuilderPlugins(featureHandler, runtime.getRuntimeConfig(), (HostedProviders) runtime.getRuntimeConfig().getProviders(), bigbang.getMetaAccess(), aUniverse,                                 hMetaAccess, hUniverse,                                 nativeLibraries, loader, false, true, bigbang.getAnnotationSubstitutionProcessor(), new SubstrateClassInitializationPlugin((SVMHost) aUniverse.hostVM()),                                 bigbang.getHostVM().getClassInitializationSupport());                  if (NativeImageOptions.PrintUniverse.getValue()) {                     printTypes();                 }                  /* Find the entry point methods in the hosted world. */                 for (AnalysisMethod m : aUniverse.getMethods()) {                     if (m.isEntryPoint()) {                         HostedMethod found = hUniverse.lookup(m);                         assert found != null;                         hostedEntryPoints.add(found);                     }                 }                 /* Find main entry point */                 if (mainEntryPoint != null) {                     AnalysisMethod analysisStub = CEntryPointCallStubSupport.singleton().getStubForMethod(mainEntryPoint);                     mainEntryPointHostedStub = (HostedMethod) hMetaAccess.getUniverse().lookup(analysisStub);                     assert hostedEntryPoints.contains(mainEntryPointHostedStub);                 } else {                     mainEntryPointHostedStub = null;                 }                 if (hostedEntryPoints.size() == 0) {                     throw UserError.abort(&quot;Warning: no entry points found, i.e., no method annotated with @&quot; + CEntryPoint.class.getSimpleName());                 }                  heap = new NativeImageHeap(aUniverse, hUniverse, hMetaAccess);                  BeforeCompilationAccessImpl config = new BeforeCompilationAccessImpl(featureHandler, loader, aUniverse, hUniverse, hMetaAccess, heap, debug);                 featureHandler.forEachFeature(feature -&gt; feature.beforeCompilation(config));                  bigbang.getUnsupportedFeatures().report(bigbang);             } catch (UnsupportedFeatureException ufe) {                 throw UserError.abort(ufe.getMessage());             }              recordMethodsWithStackValues();             recordRestrictHeapAccessCallees(aUniverse.getMethods());              /*              * After this point, all TypeFlow (and therefore also TypeState) objects are unreachable              * and can be garbage collected. This is important to keep the overall memory footprint              * low. However, this also means we no longer have complete call chain information. Only              * the summarized information stored in the StaticAnalysisResult objects is available              * after this point.              */             bigbang.cleanupAfterAnalysis();              NativeImageCodeCache codeCache;             CompileQueue compileQueue;             try (StopTimer t = new Timer(imageName, &quot;compile&quot;).start()) {                 compileQueue = HostedConfiguration.instance().createCompileQueue(debug, featureHandler, hUniverse, runtime, DeoptTester.enabled(), bigbang.getProviders().getSnippetReflection(),                                 compilationExecutor);                 compileQueue.finish(debug);                  /* release memory taken by graphs for the image writing */                 hUniverse.getMethods().forEach(HostedMethod::clear);                  codeCache = NativeImageCodeCacheFactory.get().newCodeCache(compileQueue, heap);                 codeCache.layoutConstants();                 codeCache.layoutMethods(debug, imageName);                  AfterCompilationAccessImpl config = new AfterCompilationAccessImpl(featureHandler, loader, aUniverse, hUniverse, hMetaAccess, heap, debug);                 featureHandler.forEachFeature(feature -&gt; feature.afterCompilation(config));             }              try (Indent indent = debug.logAndIndent(&quot;create native image&quot;)) {                 try (DebugContext.Scope buildScope = debug.scope(&quot;CreateBootImage&quot;)) {                     try (StopTimer t = new Timer(imageName, &quot;image&quot;).start()) {                          // Start building the model of the native image heap.                         heap.addInitialObjects();                         // Then build the model of the code cache, which can                         // add objects to the native image heap.                         codeCache.addConstantsToHeap();                         // Finish building the model of the native image heap.                         heap.addTrailingObjects();                          AfterHeapLayoutAccessImpl config = new AfterHeapLayoutAccessImpl(featureHandler, loader, hMetaAccess, debug);                         featureHandler.forEachFeature(feature -&gt; feature.afterHeapLayout(config));                          this.image = AbstractBootImage.create(k, hUniverse, hMetaAccess, nativeLibraries, heap, codeCache, hostedEntryPoints, mainEntryPointHostedStub, loader.getClassLoader());                         image.build(debug);                         if (NativeImageOptions.PrintUniverse.getValue()) {                             /*                              * This debug output must be printed _after_ and not _during_ image                              * building, because it adds some PrintStream objects to static fields,                              * which disrupts the heap.                              */                             codeCache.printCompilationResults();                         }                     }                 }             }              BeforeImageWriteAccessImpl beforeConfig = new BeforeImageWriteAccessImpl(featureHandler, loader, imageName, image,                             runtime.getRuntimeConfig(), aUniverse, hUniverse, optionProvider, hMetaAccess, debug);             featureHandler.forEachFeature(feature -&gt; feature.beforeImageWrite(beforeConfig));              try (StopTimer t = new Timer(imageName, &quot;write&quot;).start()) {                 /*                  * This will write the debug info too -- i.e. we may be writing more than one file,                  * if the debug info is in a separate file. We need to push writing the file to the                  * image implementation, because whether the debug info and image share a file or                  * not is an implementation detail of the image.                  */                 Path tmpDir = tempDirectory();                 Path imagePath = image.write(debug, generatedFiles(HostedOptionValues.singleton()), tmpDir, imageName, beforeConfig).getOutputFile();                  AfterImageWriteAccessImpl afterConfig = new AfterImageWriteAccessImpl(featureHandler, loader, hUniverse, imagePath, tmpDir, image.getBootImageKind(), debug);                 featureHandler.forEachFeature(feature -&gt; feature.afterImageWrite(afterConfig));             }         }     }</td>
    <td align="left">long method</td>
    <td align="left">&nbsp;Blob, 2 Long method</td>
    <td align="left">t</td>
    <td align="left">f</td>
    <td align="left">t</td>
    <td align="left">. Blob</td>
    <td align="left">&nbsp; </td>
    <td align="right">0</td>
    <td align="right">12087</td>
    <td align="left">https://github.com/oracle/graal/blob/4deb681aaaa79c248115037fc8e399c9876619fd/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageGenerator.java/#L487-L632</td>
    <td align="right">1</td>
    <td align="right">5691</td>
    <td align="right">12087</td>
  </tr>
</table>
<p>(244 rows)<br />
</p>
